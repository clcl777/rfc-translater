<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 3951 - Internet Low Bit Rate Codec (iLBC) 日本語訳</title>
  <meta name="description" content="RFC 3951は、インターネット上での低ビットレート音声通信を可能にするiLBCコーデックに関するものです。その目的は、低帯域幅環境での高品質な音声通信を実現することです。">

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3951</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc3951">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 3951 - Internet Low Bit Rate Codec (iLBC) 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc3951">
            https://datatracker.ietf.org/doc/html/rfc3951
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 3951 - インターネット低ビット レート コーデック (iLBC)</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] RFC 3951は、インターネット上での低ビットレート音声通信を可能にするiLBCコーデックに関するものです。その目的は、低帯域幅環境での高品質な音声通信を実現することです。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                        S. Andersen
Request for Comments: 3951                            Aalborg University
Category: Experimental                                          A. Duric
                                                                   Telio
                                                               H. Astrom
                                                                R. Hagen
                                                               W. Kleijn
                                                               J. Linden
                                                         Global IP Sound
                                                           December 2004
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
Internet Low Bit Rate Codec (iLBC)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
インターネット低ビット レート コーデック (iLBC)
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind. Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、インターネット コミュニティ向けの実験プロトコルを定義します。いかなる種類のインターネット標準も指定しません。改善のための議論と提案が求められます。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2004).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権 (C) インターネット協会 (2004)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies a speech codec suitable for robust voice communication over IP. The codec is developed by Global IP Sound (GIPS). It is designed for narrow band speech and results in a payload bit rate of 13.33 kbit/s for 30 ms frames and 15.20 kbit/s for 20 ms frames. The codec enables graceful speech quality degradation in the case of lost frames, which occurs in connection with lost or delayed IP packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、IP 上の堅牢な音声通信に適した音声コーデックを指定します。コーデックは Global IP Sound (GIPS) によって開発されました。狭帯域音声用に設計されており、ペイロード ビット レートは 30 ms フレームで 13.33 kbit/s、20 ms フレームで 15.20 kbit/s になります。このコーデックにより、IP パケットの損失または遅延に関連して発生するフレーム損失の場合に、音声品質を適切に低下させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
   2.  Outline of the Codec . . . . . . . . . . . . . . . . . . . . .  5
       2.1.  Encoder. . . . . . . . . . . . . . . . . . . . . . . . .  5
       2.2.  Decoder. . . . . . . . . . . . . . . . . . . . . . . . .  7
   3.  Encoder Principles . . . . . . . . . . . . . . . . . . . . . .  7
       3.1.  Pre-processing . . . . . . . . . . . . . . . . . . . . .  9
       3.2.  LPC Analysis and Quantization. . . . . . . . . . . . . .  9
             3.2.1.  Computation of Autocorrelation Coefficients. . . 10
             3.2.2.  Computation of LPC Coefficients. . . . . . . . . 11
             3.2.3.  Computation of LSF Coefficients from LPC
                     Coefficients . . . . . . . . . . . . . . . . . . 11
             3.2.4.  Quantization of LSF Coefficients . . . . . . . . 12
             3.2.5.  Stability Check of LSF Coefficients. . . . . . . 13
             3.2.6.  Interpolation of LSF Coefficients. . . . . . . . 13
             3.2.7.  LPC Analysis and Quantization for 20 ms Frames . 14
       3.3.  Calculation of the Residual. . . . . . . . . . . . . . . 15
       3.4.  Perceptual Weighting Filter. . . . . . . . . . . . . . . 15
       3.5.  Start State Encoder. . . . . . . . . . . . . . . . . . . 15
             3.5.1.  Start State Estimation . . . . . . . . . . . . . 16
             3.5.2.  All-Pass Filtering and Scale Quantization. . . . 17
             3.5.3.  Scalar Quantization. . . . . . . . . . . . . . . 18
       3.6.  Encoding the Remaining Samples . . . . . . . . . . . . . 19
             3.6.1.  Codebook Memory. . . . . . . . . . . . . . . . . 20
             3.6.2.  Perceptual Weighting of Codebook Memory
                     and Target . . . . . . . . . . . . . . . . . . . 22
             3.6.3.  Codebook Creation. . . . . . . . . . . . . . . . 23
                     3.6.3.1. Creation of a Base Codebook . . . . . . 23
                     3.6.3.2. Codebook Expansion. . . . . . . . . . . 24
                     3.6.3.3. Codebook Augmentation . . . . . . . . . 24
             3.6.4.  Codebook Search. . . . . . . . . . . . . . . . . 26
                     3.6.4.1. Codebook Search at Each Stage . . . . . 26
                     3.6.4.2. Gain Quantization at Each Stage . . . . 27
                     3.6.4.3. Preparation of Target for Next Stage. . 28
       3.7.  Gain Correction Encoding . . . . . . . . . . . . . . . . 28
       3.8.  Bitstream Definition . . . . . . . . . . . . . . . . . . 29
   4.  Decoder Principles . . . . . . . . . . . . . . . . . . . . . . 32
       4.1.  LPC Filter Reconstruction. . . . . . . . . . . . . . . . 33
       4.2.  Start State Reconstruction . . . . . . . . . . . . . . . 33
       4.3.  Excitation Decoding Loop . . . . . . . . . . . . . . . . 34
       4.4.  Multistage Adaptive Codebook Decoding. . . . . . . . . . 35
             4.4.1.  Construction of the Decoded Excitation Signal. . 35
       4.5.  Packet Loss Concealment. . . . . . . . . . . . . . . . . 35
             4.5.1.  Block Received Correctly and Previous Block
                     Also Received. . . . . . . . . . . . . . . . . . 35
             4.5.2.  Block Not Received . . . . . . . . . . . . . . . 36
                4.5.3.  Block Received Correctly When Previous Block
                     Not Received . . . . . . . . . . . . . . . . . . 36
       4.6.  Enhancement. . . . . . . . . . . . . . . . . . . . . . . 37
             4.6.1.  Estimating the Pitch . . . . . . . . . . . . . . 39
             4.6.2.  Determination of the Pitch-Synchronous
                     Sequences. . . . . . . . . . . . . . . . . . . . 39
             4.6.3.  Calculation of the Smoothed Excitation . . . . . 41
             4.6.4.  Enhancer Criterion . . . . . . . . . . . . . . . 41
             4.6.5.  Enhancing the Excitation . . . . . . . . . . . . 42
       4.7.  Synthesis Filtering. . . . . . . . . . . . . . . . . . . 43
       4.8.  Post Filtering . . . . . . . . . . . . . . . . . . . . . 43
   5.  Security Considerations. . . . . . . . . . . . . . . . . . . . 43
   6.  Evaluation of the iLBC Implementations . . . . . . . . . . . . 43
   7.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 43
       7.1.  Normative References . . . . . . . . . . . . . . . . . . 43
       7.2.  Informative References . . . . . . . . . . . . . . . . . 44
   8.  ACKNOWLEDGEMENTS . . . . . . . . . . . . . . . . . . . . . . . 44
   APPENDIX A: Reference Implementation . . . . . . . . . . . . . . . 45
       A.1.  iLBC_test.c. . . . . . . . . . . . . . . . . . . . . . . 46
       A.2   iLBC_encode.h. . . . . . . . . . . . . . . . . . . . . . 52
       A.3.  iLBC_encode.c. . . . . . . . . . . . . . . . . . . . . . 53
       A.4.  iLBC_decode.h. . . . . . . . . . . . . . . . . . . . . . 63
       A.5.  iLBC_decode.c. . . . . . . . . . . . . . . . . . . . . . 64
       A.6.  iLBC_define.h. . . . . . . . . . . . . . . . . . . . . . 76
       A.7.  constants.h. . . . . . . . . . . . . . . . . . . . . . . 80
       A.8.  constants.c. . . . . . . . . . . . . . . . . . . . . . . 82
       A.9.  anaFilter.h. . . . . . . . . . . . . . . . . . . . . . . 96
       A.10. anaFilter.c. . . . . . . . . . . . . . . . . . . . . . . 97
       A.11. createCB.h . . . . . . . . . . . . . . . . . . . . . . . 98
       A.12. createCB.c . . . . . . . . . . . . . . . . . . . . . . . 99
       A.13. doCPLC.h . . . . . . . . . . . . . . . . . . . . . . . .104
       A.14. doCPLC.c . . . . . . . . . . . . . . . . . . . . . . . .104
       A.15. enhancer.h . . . . . . . . . . . . . . . . . . . . . . .109
       A.16. enhancer.c . . . . . . . . . . . . . . . . . . . . . . .110
       A.17. filter.h . . . . . . . . . . . . . . . . . . . . . . . .123
       A.18. filter.c . . . . . . . . . . . . . . . . . . . . . . . .125
       A.19. FrameClassify.h. . . . . . . . . . . . . . . . . . . . .128
       A.20. FrameClassify.c. . . . . . . . . . . . . . . . . . . . .129
       A.21. gainquant.h. . . . . . . . . . . . . . . . . . . . . . .131
       A.22. gainquant.c. . . . . . . . . . . . . . . . . . . . . . .131
       A.23. getCBvec.h . . . . . . . . . . . . . . . . . . . . . . .134
       A.24. getCBvec.c . . . . . . . . . . . . . . . . . . . . . . .134
       A.25. helpfun.h. . . . . . . . . . . . . . . . . . . . . . . .138
       A.26. helpfun.c. . . . . . . . . . . . . . . . . . . . . . . .140
       A.27. hpInput.h. . . . . . . . . . . . . . . . . . . . . . . .146
       A.28. hpInput.c. . . . . . . . . . . . . . . . . . . . . . . .146
       A.29. hpOutput.h . . . . . . . . . . . . . . . . . . . . . . .148
       A.30. hpOutput.c . . . . . . . . . . . . . . . . . . . . . . .148
          A.31. iCBConstruct.h . . . . . . . . . . . . . . . . . . . . .149
       A.32. iCBConstruct.c . . . . . . . . . . . . . . . . . . . . .150
       A.33. iCBSearch.h. . . . . . . . . . . . . . . . . . . . . . .152
       A.34. iCBSearch.c. . . . . . . . . . . . . . . . . . . . . . .153
       A.35. LPCdecode.h. . . . . . . . . . . . . . . . . . . . . . .163
       A.36. LPCdecode.c. . . . . . . . . . . . . . . . . . . . . . .164
       A.37. LPCencode.h. . . . . . . . . . . . . . . . . . . . . . .167
       A.38. LPCencode.c. . . . . . . . . . . . . . . . . . . . . . .167
       A.39. lsf.h. . . . . . . . . . . . . . . . . . . . . . . . . .172
       A.40. lsf.c. . . . . . . . . . . . . . . . . . . . . . . . . .172
       A.41. packing.h. . . . . . . . . . . . . . . . . . . . . . . .178
       A.42. packing.c. . . . . . . . . . . . . . . . . . . . . . . .179
       A.43. StateConstructW.h. . . . . . . . . . . . . . . . . . . .182
       A.44. StateConstructW.c. . . . . . . . . . . . . . . . . . . .183
       A.45. StateSearchW.h . . . . . . . . . . . . . . . . . . . . .185
       A.46. StateSearchW.c . . . . . . . . . . . . . . . . . . . . .186
       A.47. syntFilter.h . . . . . . . . . . . . . . . . . . . . . .190
       A.48. syntFilter.c . . . . . . . . . . . . . . . . . . . . . .190
   Authors&#39; Addresses . . . . . . . . . . . . . . . . . . . . . . . .192
   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . .194
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document contains the description of an algorithm for the coding of speech signals sampled at 8 kHz. The algorithm, called iLBC, uses a block-independent linear-predictive coding (LPC) algorithm and has support for two basic frame lengths: 20 ms at 15.2 kbit/s and 30 ms at 13.33 kbit/s. When the codec operates at block lengths of 20 ms, it produces 304 bits per block, which SHOULD be packetized as in [1]. Similarly, for block lengths of 30 ms it produces 400 bits per block, which SHOULD be packetized as in [1]. The two modes for the different frame sizes operate in a very similar way. When they differ it is explicitly stated in the text, usually with the notation x/y, where x refers to the 20 ms mode and y refers to the 30 ms mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書には、8 kHz でサンプリングされた音声信号を符号化するためのアルゴリズムの説明が含まれています。iLBC と呼ばれるこのアルゴリズムは、ブロック独立線形予測符号化 (LPC) アルゴリズムを使用し、2 つの基本フレーム長 (15.2 kbit/s で 20 ms と 13.33 kbit/s で 30 ms) をサポートします。コーデックが 20 ミリ秒のブロック長で動作する場合、ブロックあたり 304 ビットが生成され、[1] のようにパケット化する必要があります (SHOULD)。同様に、ブロック長が 30 ミリ秒の場合、ブロックあたり 400 ビットが生成され、[1] のようにパケット化する必要があります。異なるフレーム サイズの 2 つのモードは、非常に似た方法で動作します。異なる場合は、通常は x/y という表記で本文に明示的に記載されます。x は 20 ms モードを指し、y は 30 ms モードを指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The described algorithm results in a speech coding system with a controlled response to packet losses similar to what is known from pulse code modulation (PCM) with packet loss concealment (PLC), such as the ITU-T G.711 standard [4], which operates at a fixed bit rate of 64 kbit/s. At the same time, the described algorithm enables fixed bit rate coding with a quality-versus-bit rate tradeoff close to state-of-the-art. A suitable RTP payload format for the iLBC codec is specified in [1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明されているアルゴリズムにより、ITU-T G.711 標準 [4] などのパケット損失隠蔽 (PLC) を備えたパルス符号変調 (PCM) で知られているものと同様に、パケット損失に対する制御された応答を備えた音声符号化システムが実現されます。64 kbit/s の固定ビット レートで動作します。同時に、説明したアルゴリズムにより、品質とビット レートのトレードオフが最先端に近い固定ビット レート コーディングが可能になります。iLBC コーデックに適した RTP ペイロード形式は、[1] で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some of the applications for which this coder is suitable are real time communications such as telephony and videoconferencing, streaming audio, archival, and messaging.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このコーダーが適しているアプリケーションには、電話やビデオ会議、ストリーミング オーディオ、アーカイブ、メッセージングなどのリアルタイム通信があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cable Television Laboratories (CableLabs(R)) has adopted iLBC as a mandatory PacketCable(TM) audio codec standard for VoIP over Cable applications [3].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cable Television Laboratories (CableLabs(R)) は、VoIP over Cable アプリケーションの必須 PacketCable(TM) オーディオ コーデック標準として iLBC を採用しました [3]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is organized as follows. Section 2 gives a brief outline of the codec. The specific encoder and decoder algorithms are explained in sections 3 and 4, respectively. Appendix A provides a c-code reference implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は次のように構成されています。セクション 2 では、コーデックの概要を説明します。具体的なエンコーダとデコーダのアルゴリズムについては、それぞれセクション 3 とセクション 4 で説明します。付録 A では、C コードのリファレンス実装を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14, RFC 2119 [2].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード「しなければならない」、「してはならない」、「必須」、「しなければならない」、「してはならない」、「すべきである」、「すべきではない」、「推奨」、「してもよい」、「任意」は次のとおりです。BCP 14、RFC 2119 [2] に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Outline-of-the-Codec">
2. Outline of the Codec
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. コーデックの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The codec consists of an encoder and a decoder as described in sections 2.1 and 2.2, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コーデックは、セクション 2.1 と 2.2 でそれぞれ説明されているエンコーダとデコーダで構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The essence of the codec is LPC and block-based coding of the LPC residual signal. For each 160/240 (20 ms/30 ms) sample block, the following major steps are performed: A set of LPC filters are computed, and the speech signal is filtered through them to produce the residual signal. The codec uses scalar quantization of the dominant part, in terms of energy, of the residual signal for the block. The dominant state is of length 57/58 (20 ms/30 ms) samples and forms a start state for dynamic codebooks constructed from the already coded parts of the residual signal. These dynamic codebooks are used to code the remaining parts of the residual signal. By this method, coding independence between blocks is achieved, resulting in elimination of propagation of perceptual degradations due to packet loss. The method facilitates high-quality packet loss concealment (PLC).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コーデックの本質は、LPC および LPC 残差信号のブロックベースのコーディングです。160/240 (20 ms/30 ms) サンプル ブロックごとに、次の主要な手順が実行されます。一連の LPC フィルターが計算され、音声信号がそれらを通じてフィルターされて残差信号が生成されます。コーデックは、ブロックの残差信号のエネルギーの観点から支配的な部分のスカラー量子化を使用します。ドミナント状態は長さ 57/58 (20 ms/30 ms) サンプルであり、残差信号の既に符号化された部分から構築された動的コードブックの開始状態を形成します。これらの動的コードブックは、残差信号の残りの部分をコーディングするために使用されます。この方法により、ブロック間の符号化の独立性が達成され、パケット損失による知覚劣化の伝播が排除されます。この方法により、高品質のパケット損失隠蔽 (PLC) が容易になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1--Encoder">
2.1. Encoder
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. エンコーダ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The input to the encoder SHOULD be 16 bit uniform PCM sampled at 8 kHz. It SHOULD be partitioned into blocks of BLOCKL=160/240 samples for the 20/30 ms frame size. Each block is divided into NSUB=4/6 consecutive sub-blocks of SUBL=40 samples each. For 30 ms frame size, the encoder performs two LPC_FILTERORDER=10 linear-predictive coding (LPC) analyses. The first analysis applies a smooth window centered over the second sub-block and extending to the middle of the fifth sub-block. The second LPC analysis applies a smooth asymmetric window centered over the fifth sub-block and extending to the end of the sixth sub-block. For 20 ms frame size, one LPC_FILTERORDER=10 linear-predictive coding (LPC) analysis is performed with a smooth window centered over the third sub-frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコーダへの入力は、8 kHz でサンプリングされた 16 ビット均一 PCM である必要があります。20/30 ミリ秒のフレーム サイズに対して、BLOCKL=160/240 サンプルのブロックに分割されるべきです (SHOULD)。各ブロックは、それぞれ SUBL=40 サンプルの NSUB=4/6 の連続したサブブロックに分割されます。30 ミリ秒のフレーム サイズの場合、エンコーダは 2 つの LPC_FILTERORDER=10 線形予測コーディング (LPC) 分析を実行します。最初の分析では、2 番目のサブブロックを中心とし、5 番目のサブブロックの中央まで拡張するスムーズ ウィンドウを適用します。2 番目の LPC 分析は、5 番目のサブブロックを中心にして 6 番目のサブブロックの終わりまで広がる滑らかな非対称ウィンドウを適用します。20 ms フレーム サイズの場合、1 回の LPC_FILTERORDER=10 線形予測コーディング (LPC) 分析が、3 番目のサブフレームの中央にあるスムーズ ウィンドウで実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each of the LPC analyses, a set of line-spectral frequencies (LSFs) are obtained, quantized, and interpolated to obtain LSF coefficients for each sub-block. Subsequently, the LPC residual is computed by using the quantized and interpolated LPC analysis filters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各 LPC 解析では、線スペクトル周波数 (LSF) のセットが取得、量子化、補間されて、各サブブロックの LSF 係数が取得されます。続いて、量子化および補間された LPC 分析フィルターを使用して、LPC 残差が計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two consecutive sub-blocks of the residual exhibiting the maximal weighted energy are identified. Within these two sub-blocks, the start state (segment) is selected from two choices: the first 57/58 samples or the last 57/58 samples of the two consecutive sub-blocks. The selected segment is the one of higher energy. The start state is encoded with scalar quantization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最大の重み付けされたエネルギーを示す残差の 2 つの連続するサブブロックが識別されます。これら 2 つのサブブロック内で、開始状態 (セグメント) は 2 つの選択肢から選択されます: 2 つの連続するサブブロックの最初の 57/58 サンプルまたは最後の 57/58 サンプルです。選択されたセグメントは、より高いエネルギーのセグメントです。開始状態はスカラー量子化でエンコードされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A dynamic codebook encoding procedure is used to encode 1) the 23/22 (20 ms/30 ms) remaining samples in the two sub-blocks containing the start state; 2) the sub-blocks after the start state in time; and 3) the sub-blocks before the start state in time. Thus, the encoding target can be either the 23/22 samples remaining of the two sub-blocks containing the start state or a 40-sample sub-block. This target can consist of samples indexed forward in time or backward in time, depending on the location of the start state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
動的コードブック符号化手順を使用して、1) 開始状態を含む 2 つのサブブロック内の残りの 23/22 (20 ミリ秒/30 ミリ秒) サンプルを符号化します。2) 開始状態の後のサブブロック。3) 開始状態の前のサブブロック。したがって、符号化ターゲットは、開始状態を含む 2 つのサブブロックの残りの 23/22 サンプル、または 40 サンプルのサブブロックのいずれかになります。このターゲットは、開始状態の位置に応じて、時間的に前方または時間的に後方にインデックス付けされたサンプルで構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The codebook coding is based on an adaptive codebook built from a codebook memory that contains decoded LPC excitation samples from the already encoded part of the block. These samples are indexed in the same time direction as the target vector, ending at the sample instant prior to the first sample instant represented in the target vector. The codebook is used in CB_NSTAGES=3 stages in a successive refinement approach, and the resulting three code vector gains are encoded with 5-, 4-, and 3-bit scalar quantization, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードブックのコーディングは、ブロックの既にエンコードされた部分からデコードされた LPC 励振サンプルを含むコードブック メモリから構築された適応コードブックに基づいています。これらのサンプルは、ターゲット ベクトルと同じ時間方向にインデックス付けされ、ターゲット ベクトルで表される最初のサンプル瞬間より前のサンプル瞬間で終了します。コードブックは、逐次リファインメント手法の CB_NSTAGES=3 ステージで使用され、結果として得られる 3 つのコード ベクトル ゲインは、それぞれ 5、4、および 3 ビットのスカラー量子化でエンコードされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The codebook search method employs noise shaping derived from the LPC filters, and the main decision criterion is to minimize the squared error between the target vector and the code vectors. Each code vector in this codebook comes from one of CB_EXPAND=2 codebook sections. The first section is filled with delayed, already encoded residual vectors. The code vectors of the second codebook section are constructed by predefined linear combinations of vectors in the first section of the codebook.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードブック検索方法では、LPC フィルターから得られるノイズ シェーピングが使用され、主な決定基準は、ターゲット ベクトルとコード ベクトル間の二乗誤差を最小限に抑えることです。このコードブックの各コード ベクトルは、CB_EXPAND=2 コードブック セクションの 1 つから取得されます。最初のセクションは、遅延された、すでにエンコードされた残差ベクトルで埋められています。コードブックの 2 番目のセクションのコード ベクトルは、コードブックの最初のセクションのベクトルの事前定義された線形結合によって構築されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As codebook encoding with squared-error matching is known to produce a coded signal of less power than does the scalar quantized start state signal, a gain re-scaling method is implemented by a refined search for a better set of codebook gains in terms of power matching after encoding. This is done by searching for a higher value of the gain factor for the first stage codebook, as the subsequent stage codebook gains are scaled by the first stage gain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
二乗誤差マッチングを使用したコードブック符号化は、スカラー量子化された開始状態信号よりも低い電力の符号化信号を生成することが知られているため、電力の観点からより適切なコードブック ゲインのセットを絞り込んだ検索によってゲイン再スケーリング方法が実装されます。エンコード後のマッチング。これは、後続ステージのコードブックのゲインが第 1 ステージのゲインによって調整されるため、第 1 ステージのコードブックのゲイン係数のより高い値を検索することによって行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2--Decoder">
2.2. Decoder
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. デコーダ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Typically for packet communications, a jitter buffer placed at the receiving end decides whether the packet containing an encoded signal block has been received or lost. This logic is not part of the codec described here. For each encoded signal block received the decoder performs a decoding. For each lost signal block, the decoder performs a PLC operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、パケット通信の場合、受信側に配置されたジッター バッファーによって、符号化された信号ブロックを含むパケットが受信されたか失われたかが決まります。このロジックは、ここで説明するコーデックの一部ではありません。受信した符号化された信号ブロックごとに、デコーダは復号化を実行します。失われた信号ブロックごとに、デコーダは PLC 操作を実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoding for each block starts by decoding and interpolating the LPC coefficients. Subsequently the start state is decoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ブロックの復号化は、LPC 係数の復号化と補間から始まります。その後、開始状態がデコードされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For codebook-encoded segments, each segment is decoded by constructing the three code vectors given by the received codebook indices in the same way that the code vectors were constructed in the encoder. The three gain factors are also decoded and the resulting decoded signal is given by the sum of the three codebook vectors scaled with respective gain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードブックでエンコードされたセグメントの場合、各セグメントは、エンコーダでコード ベクトルが構築されたのと同じ方法で、受信したコードブック インデックスによって指定された 3 つのコード ベクトルを構築することによってデコードされます。3 つのゲイン係数もデコードされ、結果としてデコードされた信号は、それぞれのゲインでスケーリングされた 3 つのコードブック ベクトルの合計によって得られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An enhancement algorithm is applied to the reconstructed excitation signal. This enhancement augments the periodicity of voiced speech regions. The enhancement is optimized under the constraint that the modification signal (defined as the difference between the enhanced excitation and the excitation signal prior to enhancement) has a short-time energy that does not exceed a preset fraction of the short-time energy of the excitation signal prior to enhancement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再構築された励起信号に強化アルゴリズムが適用されます。この拡張により、有声音声領域の周期性が強化されます。強化は、修正信号 (強化された励起と強化前の励起信号の差として定義される) の短時間エネルギーが励起の短時間エネルギーの事前設定された部分を超えないという制約の下で最適化されます。強化前の信号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A packet loss concealment (PLC) operation is easily embedded in the decoder. The PLC operation can, e.g., be based on repeating LPC filters and obtaining the LPC residual signal by using a long-term prediction estimate from previous residual blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット損失隠蔽 (PLC) 操作はデコーダに簡単に埋め込まれます。ＰＬＣ動作は、例えば、ＬＰＣフィルタを繰り返し、以前の残差ブロックからの長期予測推定を使用することによってＬＰＣ残差信号を取得することに基づくことができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Encoder-Principles">
3. Encoder Principles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. エンコーダの原理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following block diagram is an overview of all the components of the iLBC encoding procedure. The description of the blocks contains references to the section where that particular procedure is further described.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のブロック図は、iLBC エンコード手順のすべてのコンポーネントの概要です。ブロックの説明には、その特定の手順がさらに説明されているセクションへの参照が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             +-----------+    +---------+    +---------+
   speech -&gt; | 1. Pre P  | -&gt; | 2. LPC  | -&gt; | 3. Ana  | -&gt;
             +-----------+    +---------+    +---------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             +---------------+   +--------------+
          -&gt; | 4. Start Sel  | -&gt;| 5. Scalar Qu | -&gt;
             +---------------+   +--------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             +--------------+    +---------------+
          -&gt; |6. CB Search  | -&gt; | 7. Packetize  | -&gt; payload
          |  +--------------+ |  +---------------+
          ----&lt;---------&lt;------
       sub-frame 0..2/4 (20 ms/30 ms)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 3.1. Flow chart of the iLBC encoder
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図3.1。iLBCエンコーダのフローチャート
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Pre-process speech with a HP filter, if needed (section 3.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 必要に応じて、HP フィルターを使用して音声を前処理します (セクション 3.1)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Compute LPC parameters, quantize, and interpolate (section 3.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. LPC パラメータを計算し、量子化し、補間します (セクション 3.2)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Use analysis filters on speech to compute residual (section 3.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 音声の分析フィルターを使用して残差を計算します (セクション 3.3)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Select position of 57/58-sample start state (section 3.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 57/58 サンプル開始ステートの位置を選択します (3.5 節)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Quantize the 57/58-sample start state with scalar quantization (section 3.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. スカラー量子化を使用して 57/58 サンプルの開始状態を量子化します (セクション 3.5)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Search the codebook for each sub-frame. Start with 23/22 sample block, then encode sub-blocks forward in time, and then encode sub-blocks backward in time. For each block, the steps in Figure 3.4 are performed (section 3.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 各サブフレームのコードブックを検索します。23/22 サンプル ブロックから開始し、次にサブブロックを時間的に順方向にエンコードし、次にサブブロックを時間的に逆方向にエンコードします。各ブロックに対して、図 3.4 の手順が実行されます (セクション 3.6)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Packetize the bits into the payload specified in Table 3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. ビットを表 3.2 で指定されたペイロードにパケット化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The input to the encoder SHOULD be 16-bit uniform PCM sampled at 8 kHz. Also it SHOULD be partitioned into blocks of BLOCKL=160/240 samples. Each block input to the encoder is divided into NSUB=4/6 consecutive sub-blocks of SUBL=40 samples each.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコーダへの入力は、8 kHz でサンプリングされた 16 ビット均一 PCM である必要があります。また、BLOCKL=160/240 サンプルのブロックに分割する必要があります (SHOULD)。エンコーダへの各ブロック入力は、それぞれ SUBL=40 サンプルの NSUB=4/6 の連続したサブブロックに分割されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             0        39        79       119       159
             +---------------------------------------+
             |    1    |    2    |    3    |    4    |
             +---------------------------------------+
                            20 ms frame
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   0        39        79       119       159       199       239
   +-----------------------------------------------------------+
   |    1    |    2    |    3    |    4    |    5    |    6    |
   +-----------------------------------------------------------+
                                  30 ms frame
   Figure 3.2. One input block to the encoder for 20 ms (with four sub-
   frames) and 30 ms (with six sub-frames).
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Pre-processing">
3.1. Pre-processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 前処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some applications, the recorded speech signal contains DC level and/or 50/60 Hz noise. If these components have not been removed prior to the encoder call, they should be removed by a high-pass filter. A reference implementation of this, using a filter with a cutoff frequency of 90 Hz, can be found in Appendix A.28.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションによっては、録音された音声信号に DC レベルや 50/60 Hz ノイズが含まれる場合があります。これらのコンポーネントがエンコーダ呼び出しの前に削除されていない場合は、ハイパス フィルターによって削除する必要があります。カットオフ周波数 90 Hz のフィルターを使用したこのリファレンス実装は、付録 A.28 にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--LPC-Analysis-and-Quantization">
3.2. LPC Analysis and Quantization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. LPC 分析と量子化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The input to the LPC analysis module is a possibly high-pass filtered speech buffer, speech_hp, that contains 240/300 (LPC_LOOKBACK + BLOCKL = 80/60 + 160/240 = 240/300) speech samples, where samples 0 through 79/59 are from the previous block and samples 80/60 through 239/299 are from the current block. No look-ahead into the next block is used. For the very first block processed, the look-back samples are assumed to be zeros.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LPC 分析モジュールへの入力は、おそらくハイパス フィルター処理された音声バッファー speech_hp で、これには 240/300 (LPC_LOOKBACK BLOCKL = 80/60 160/240 = 240/300) 音声サンプルが含まれます。サンプル 0 ～ 79/59 は次のとおりです。前のブロックからのものであり、サンプル 80/60 から 239/299 は現在のブロックからのものです。次のブロックへの先読みは使用されません。処理される最初のブロックでは、ルックバック サンプルはゼロであると想定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each input block, the LPC analysis calculates one/two set(s) of LPC_FILTERORDER=10 LPC filter coefficients using the autocorrelation method and the Levinson-Durbin recursion. These coefficients are converted to the Line Spectrum Frequency representation. In the 20 ms case, the single lsf set represents the spectral characteristics as measured at the center of the third sub-block. For 30 ms frames, the first set, lsf1, represents the spectral properties of the input signal at the center of the second sub-block, and the other set, lsf2, represents the spectral characteristics as measured at the center of the fifth sub-block. The details of the computation for 30 ms frames are described in sections 3.2.1 through 3.2.6. Section 3.2.7 explains how the LPC Analysis and Quantization differs for 20 ms frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各入力ブロックについて、LPC 分析は、自己相関法とレビンソン・ダービン再帰を使用して、LPC_FILTERORDER=10 個の LPC フィルター係数の 1 つまたは 2 つのセットを計算します。これらの係数は線スペクトル周波数表現に変換されます。20 ms の場合、単一の lsf セットは 3 番目のサブブロックの中心で測定されたスペクトル特性を表します。30 ms フレームの場合、最初のセット lsf1 は 2 番目のサブブロックの中心での入力信号のスペクトル特性を表し、もう 1 つのセット lsf2 は 5 番目のサブブロックの中心で測定されたスペクトル特性を表します。ブロック。30 ms フレームの計算の詳細については、セクション 3.2.1 ～ 3.2.6 で説明します。セクション 3.2.7 では、20 ms フレームの LPC 分析と量子化がどのように異なるかを説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-1--Computation-of-Autocorrelation-Coefficients">
3.2.1. Computation of Autocorrelation Coefficients
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. 自己相関係数の計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first step in the LPC analysis procedure is to calculate autocorrelation coefficients by using windowed speech samples. This windowing is the only difference in the LPC analysis procedure for the two sets of coefficients. For the first set, a 240-sample-long standard symmetric Hanning window is applied to samples 0 through 239 of the input data. The first window, lpc_winTbl, is defined as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LPC 分析手順の最初のステップは、ウィンドウ化された音声サンプルを使用して自己相関係数を計算することです。このウィンドウ処理が、2 つの係数セットに対する LPC 分析手順の唯一の違いです。最初のセットでは、240 サンプル長の標準対称ハニング ウィンドウが入力データのサンプル 0 ～ 239 に適用されます。最初のウィンドウ lpc_winTbl は次のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      lpc_winTbl[i]= 0.5 * (1.0 - cos((2*PI*(i+1))/(BLOCKL+1)));
               i=0,...,119
      lpc_winTbl[i] = winTbl[BLOCKL - i - 1]; i=120,...,239
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The windowed speech speech_hp_win1 is then obtained by multiplying the first 240 samples of the input speech buffer with the window coefficients:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、ウィンドウ化された音声 speech_hp_win1 は、入力音声バッファの最初の 240 サンプルにウィンドウ係数を乗算して取得されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      speech_hp_win1[i] = speech_hp[i] * lpc_winTbl[i];
               i=0,...,BLOCKL-1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From these 240 windowed speech samples, 11 (LPC_FILTERORDER + 1) autocorrelation coefficients, acf1, are calculated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの 240 のウィンドウ処理された音声サンプルから、11 (LPC_FILTERORDER 1) の自己相関係数 acf1 が計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      acf1[lag] += speech_hp_win1[n] * speech_hp_win1[n + lag];
               lag=0,...,LPC_FILTERORDER; n=0,...,BLOCKL-lag-1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to make the analysis more robust against numerical precision problems, a spectral smoothing procedure is applied by windowing the autocorrelation coefficients before the LPC coefficients are computed. Also, a white noise floor is added to the autocorrelation function by multiplying coefficient zero by 1.0001 (40dB below the energy of the windowed speech signal). These two steps are implemented by multiplying the autocorrelation coefficients with the following window:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数値精度の問題に対して解析をより堅牢にするために、LPC 係数が計算される前に自己相関係数をウィンドウ処理することによってスペクトル平滑化手順が適用されます。また、ホワイト ノイズ フロアは、係数ゼロに 1.0001 (ウィンドウ処理された音声信号のエネルギーより 40dB 低い) を乗算することによって自己相関関数に追加されます。これら 2 つのステップは、次のウィンドウで自己相関係数を乗算することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      lpc_lagwinTbl[0] = 1.0001;
      lpc_lagwinTbl[i] = exp(-0.5 * ((2 * PI * 60.0 * i) /FS)^2);
               i=1,...,LPC_FILTERORDER
               where FS=8000 is the sampling frequency
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Then, the windowed acf function acf1_win is obtained by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、ウィンドウ化された ACF 関数 acf1_win は次のように取得されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      acf1_win[i] = acf1[i] * lpc_lagwinTbl[i];
               i=0,...,LPC_FILTERORDER
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second set of autocorrelation coefficients, acf2_win, are obtained in a similar manner. The window, lpc_asymwinTbl, is applied to samples 60 through 299, i.e., the entire current block. The window consists of two segments, the first (samples 0 to 219) being half a Hanning window with length 440 and the second a quarter of a cycle of a cosine wave. By using this asymmetric window, an LPC analysis centered in the fifth sub-block is obtained without the need for any look-ahead, which would add delay. The asymmetric window is defined as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2 番目の自己相関係数セット acf2_win も同様の方法で取得されます。ウィンドウ lpc_asymwinTbl は、サンプル 60 から 299、つまり現在のブロック全体に適用されます。ウィンドウは 2 つのセグメントで構成され、最初のセグメント (サンプル 0 ～ 219) は長さ 440 のハニング ウィンドウの半分であり、2 番目のセグメントは余弦波の 4 分の 1 サイクルです。この非対称ウィンドウを使用することにより、遅延を追加する先読みを必要とせずに、5 番目のサブブロックを中心とする LPC 分析が得られます。非対称ウィンドウは次のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      lpc_asymwinTbl[i] = (sin(PI * (i + 1) / 441))^2; i=0,...,219
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      lpc_asymwinTbl[i] = cos((i - 220) * PI / 40); i=220,...,239
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and the windowed speech is computed by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ウィンドウ化された音声は次のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      speech_hp_win2[i] = speech_hp[i + LPC_LOOKBACK] *
               lpc_asymwinTbl[i];  i=0,....BLOCKL-1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The windowed autocorrelation coefficients are then obtained in exactly the same way as for the first analysis instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その後、最初の分析インスタンスの場合とまったく同じ方法で、ウィンドウ処理された自己相関係数が取得されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The generation of the windows lpc_winTbl, lpc_asymwinTbl, and lpc_lagwinTbl are typically done in advance, and the arrays are stored in ROM rather than repeating the calculation for every block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ウィンドウ lpc_winTbl、lpc_asymwinTbl、および lpc_lagwinTbl の生成は通常、事前に行われ、ブロックごとに計算を繰り返すのではなく、配列が ROM に保存されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-2--Computation-of-LPC-Coefficients">
3.2.2. Computation of LPC Coefficients
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2. LPC 係数の計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the 2 x 11 smoothed autocorrelation coefficients, acf1_win and acf2_win, the 2 x 11 LPC coefficients, lp1 and lp2, are calculated in the same way for both analysis locations by using the well known Levinson-Durbin recursion. The first LPC coefficient is always 1.0, resulting in ten unique coefficients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2 x 11 の平滑化自己相関係数 acf1_win および acf2_win から、2 x 11 LPC 係数 lp1 および lp2 は、よく知られているレビンソン・ダービン再帰法を使用して、両方の分析位置で同じ方法で計算されます。最初の LPC 係数は常に 1.0 であり、結果として 10 個の一意の係数が得られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After determining the LPC coefficients, a bandwidth expansion procedure is applied to smooth the spectral peaks in the short-term spectrum. The bandwidth addition is obtained by the following modification of the LPC coefficients:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LPC 係数を決定した後、帯域幅拡張手順を適用して、短期スペクトルのスペクトル ピークを平滑化します。帯域幅の追加は、LPC 係数を次のように変更することで得られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      lp1_bw[i] = lp1[i] * chirp^i; i=0,...,LPC_FILTERORDER
      lp2_bw[i] = lp2[i] * chirp^i; i=0,...,LPC_FILTERORDER
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where &#34;chirp&#34; is a real number between 0 and 1. It is RECOMMENDED to use a value of 0.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、「chirp」は 0 ～ 1 の間の実数です。値 0.9 を使用することが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-3--Computation-of-LSF-Coefficients-from-LPC-Coefficients">
3.2.3. Computation of LSF Coefficients from LPC Coefficients
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3. LPC 係数からの LSF 係数の計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus far, two sets of LPC coefficients that represent the short-term spectral characteristics of the speech signal for two different time locations within the current block have been determined. These coefficients SHOULD be quantized and interpolated. Before this is done, it is advantageous to convert the LPC parameters into another type of representation called Line Spectral Frequencies (LSF). The LSF parameters are used because they are better suited for quantization and interpolation than the regular LPC coefficients. Many computationally efficient methods for calculating the LSFs from the LPC coefficients have been proposed in the literature. The detailed implementation of one applicable method can be found in Appendix A.26. The two arrays of LSF coefficients obtained, lsf1 and lsf2, are of dimension 10 (LPC_FILTERORDER).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまでのところ、現在のブロック内の 2 つの異なる時間位置における音声信号の短期スペクトル特性を表す 2 組の LPC 係数が決定されています。これらの係数は量子化され、補間されるべきです(SHOULD)。これを行う前に、LPC パラメータを線スペクトル周波数 (LSF) と呼ばれる別のタイプの表現に変換すると有利です。LSF パラメータが使用されるのは、通常の LPC 係数よりも量子化と補間に適しているためです。LPC 係数から LSF を計算するための計算効率の高い方法が文献で多数提案されています。適用可能な 1 つのメソッドの詳細な実装については、付録 A.26 を参照してください。取得された LSF 係数の 2 つの配列 lsf1 と lsf2 は、次元 10 (LPC_FILTERORDER) です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-4--Quantization-of-LSF-Coefficients">
3.2.4. Quantization of LSF Coefficients
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.4. LSF 係数の量子化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the LPC filters defined by the two sets of LSFs are also needed in the decoder, the LSF parameters need to be quantized and transmitted as side information. The total number of bits required to represent the quantization of the two LSF representations for one block of speech is 40, with 20 bits used for each of lsf1 and lsf2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2 つの LSF セットによって定義された LPC フィルターもデコーダで必要となるため、LSF パラメータを量子化し、サイド情報として送信する必要があります。1 つの音声ブロックの 2 つの LSF 表現の量子化を表すのに必要なビットの総数は 40 で、lsf1 と lsf2 のそれぞれに 20 ビットが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For computational and storage reasons, the LSF vectors are quantized using three-split vector quantization (VQ). That is, the LSF vectors are split into three sub-vectors that are each quantized with a regular VQ. The quantized versions of lsf1 and lsf2, qlsf1 and qlsf2, are obtained by using the same memoryless split VQ. The length of each of these two LSF vectors is 10, and they are split into three sub-vectors containing 3, 3, and 4 values, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
計算およびストレージ上の理由から、LSF ベクトルは 3 分割ベクトル量子化 (VQ) を使用して量子化されます。つまり、LSF ベクトルは 3 つのサブベクトルに分割され、それぞれが通常の VQ で量子化されます。lsf1 と lsf2 の量子化バージョン、qlsf1 と qlsf2 は、同じメモリレス分割 VQ を使用して取得されます。これら 2 つの LSF ベクトルの長さはそれぞれ 10 で、それぞれ 3、3、および 4 の値を含む 3 つのサブベクトルに分割されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each of the sub-vectors, a separate codebook of quantized values has been designed with a standard VQ training method for a large database containing speech from a large number of speakers recorded under various conditions. The size of each of the three codebooks associated with the split definitions above is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブベクトルごとに、量子化値の個別のコードブックが、さまざまな条件下で録音された多数の話者からの音声を含む大規模なデータベース用の標準 VQ トレーニング方法を使用して設計されています。上記の分割定義に関連付けられた 3 つのコードブックのそれぞれのサイズは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int size_lsfCbTbl[LSF_NSPLIT] = {64,128,128};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The actual values of the vector quantization codebook that must be used can be found in the reference code of Appendix A. Both sets of LSF coefficients, lsf1 and lsf2, are quantized with a standard memoryless split vector quantization (VQ) structure using the squared error criterion in the LSF domain. The split VQ quantization consists of the following steps:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用する必要があるベクトル量子化コードブックの実際の値は、付録 A のリファレンス コードに記載されています。LSF 係数のセット、lsf1 と lsf2 は両方とも、二乗誤差を使用する標準のメモリレス分割ベクトル量子化 (VQ) 構造で量子化されます。LSF ドメインの基準。分割 VQ 量子化は次の手順で構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1) Quantize the first three LSF coefficients (1 - 3) with a VQ codebook of size 64. 2) Quantize the next three LSF coefficients 4 - 6 with VQ a codebook of size 128. 3) Quantize the last four LSF coefficients (7 - 10) with a VQ codebook of size 128.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1) 最初の 3 つの LSF 係数 (1 ～ 3) をサイズ 64 の VQ コードブックで量子化します。 2) 次の 3 つの LSF 係数 4 ～ 6 を、サイズ 128 の VQ コードブックで量子化します。 3) 最後の 4 つの LSF 係数 (7 ～ 10) を量子化します。) サイズ 128 の VQ コードブックを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This procedure, repeated for lsf1 and lsf2, gives six quantization indices and the quantized sets of LSF coefficients qlsf1 and qlsf2. Each set of three indices is encoded with 6 + 7 + 7 = 20 bits. The total number of bits used for LSF quantization in a block is thus 40 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この手順を lsf1 と lsf2 に対して繰り返すと、6 つの量子化インデックスと量子化された LSF 係数のセット qlsf1 と qlsf2 が得られます。3 つのインデックスの各セットは 6 7 7 = 20 ビットでエンコードされます。したがって、ブロック内の LSF 量子化に使用されるビットの総数は 40 ビットになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-5--Stability-Check-of-LSF-Coefficients">
3.2.5. Stability Check of LSF Coefficients
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.5. LSF 係数の安定性チェック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LSF representation of the LPC filter has the convenient property that the coefficients are ordered by increasing value, i.e., lsf(n-1) &lt; lsf(n), 0 &lt; n &lt; 10, if the corresponding synthesis filter is stable. As we are employing a split VQ scheme, it is possible that at the split boundaries the LSF coefficients are not ordered correctly and hence that the corresponding LP filter is unstable. To ensure that the filter used is stable, a stability check is performed for the quantized LSF vectors. If it turns out that the coefficients are not ordered appropriately (with a safety margin of 50 Hz to ensure that formant peaks are not too narrow), they will be moved apart. The detailed method for this can be found in Appendix A.40. The same procedure is performed in the decoder. This ensures that exactly the same LSF representations are used in both encoder and decoder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LPC フィルターの LSF 表現には、対応する合成フィルターが安定している場合、係数が値の増加順に並べられるという便利な特性があります (つまり、lsf(n-1) &lt; lsf(n)、0 &lt; n &lt; 10)。分割 VQ スキームを採用しているため、分割境界で LSF 係数が正しく順序付けされておらず、対応する LP フィルターが不安定になる可能性があります。使用されるフィルターが安定していることを確認するために、量子化された LSF ベクトルに対して安定性チェックが実行されます。係数が適切に順序付けされていないことが判明した場合 (フォルマントのピークが狭すぎないように 50 Hz の安全マージンを設けます)、係数は離されます。この詳細な方法については、付録 A.40 を参照してください。同じ手順がデコーダでも実行されます。これにより、エンコーダとデコーダの両方でまったく同じ LSF 表現が使用されることが保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-6--Interpolation-of-LSF-Coefficients">
3.2.6. Interpolation of LSF Coefficients
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.6. LSF 係数の補間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the two sets of LSF coefficients that are computed for each block of speech, different LSFs are obtained for each sub-block by means of interpolation. This procedure is performed for the original LSFs (lsf1 and lsf2), as well as the quantized versions qlsf1 and qlsf2, as both versions are used in the encoder. Here follows a brief summary of the interpolation scheme; the details are found in the c-code of Appendix A. In the first sub-block, the average of the second LSF vector from the previous block and the first LSF vector in the current block is used. For sub-blocks two through five, the LSFs used are obtained by linear interpolation from lsf1 (and qlsf1) to lsf2 (and qlsf2), with lsf1 used in sub-block two and lsf2 in sub-block five. In the last sub-block, lsf2 is used. For the very first block it is assumed that the last LSF vector of the previous block is equal to a predefined vector, lsfmeanTbl, obtained by calculating the mean LSF vector of the LSF design database.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
音声のブロックごとに計算された 2 つの LSF 係数セットから、補間によってサブブロックごとに異なる LSF が取得されます。この手順は、元の LSF (lsf1 および lsf2) だけでなく、量子化バージョン qlsf1 および qlsf2 に対しても実行されます。これは、両方のバージョンがエンコーダーで使用されるためです。以下に補間スキームの簡単な概要を示します。詳細は付録 A の C コードを参照してください。最初のサブブロックでは、前のブロックの 2 番目の LSF ベクトルと現在のブロックの最初の LSF ベクトルの平均が使用されます。サブブロック 2 ～ 5 では、使用される LSF は lsf1 (および qlsf1) から lsf2 (および qlsf2) への線形補間によって取得されます。lsf1 はサブブロック 2 で使用され、lsf2 はサブブロック 5 で使用されます。最後のサブブロックでは、lsf2 が使用されます。一番最初のブロックでは、前のブロックの最後の LSF ベクトルが、LSF 設計データベースの平均 LSF ベクトルを計算することによって得られる事前定義ベクトル lsfmeanTbl に等しいと想定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   lsfmeanTbl[LPC_FILTERORDER] = {0.281738, 0.445801, 0.663330,
                  0.962524, 1.251831, 1.533081, 1.850586, 2.137817,
                  2.481445, 2.777344}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The interpolation method is standard linear interpolation in the LSF domain. The interpolated LSF values are converted to LPC coefficients for each sub-block. The unquantized and quantized LPC coefficients form two sets of filters respectively. The unquantized analysis filter for sub-block k is defined as follows
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
補間方法は、LSF ドメインの標準的な線形補間です。補間された LSF 値は、サブブロックごとに LPC 係数に変換されます。量子化されていない LPC 係数と量子化された LPC 係数は、それぞれ 2 組のフィルターを形成します。サブブロック k の非量子化分析フィルターは次のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                ___
                \
      Ak(z)= 1 + &gt; ak(i)*z^(-i)
                /__
             i=1...LPC_FILTERORDER
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   The quantized analysis filter for sub-block k is defined as follows
                 ___
                 \
      A~k(z)= 1 + &gt; a~k(i)*z^(-i)
                 /__
             i=1...LPC_FILTERORDER
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reference implementation of the lsf encoding is given in Appendix A.38. A reference implementation of the corresponding decoding can be found in Appendix A.36.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lsf エンコーディングのリファレンス実装は、付録 A.38 に記載されています。対応するデコードのリファレンス実装は、付録 A.36 にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-7--LPC-Analysis-and-Quantization-for-20-ms-Frames">
3.2.7. LPC Analysis and Quantization for 20 ms Frames
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.7. 20 ms フレームの LPC 分析と量子化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As previously stated, the codec only calculates one set of LPC parameters for the 20 ms frame size as opposed to two sets for 30 ms frames. A single set of autocorrelation coefficients is calculated on the LPC_LOOKBACK + BLOCKL = 80 + 160 = 240 samples. These samples are windowed with the asymmetric window lpc_asymwinTbl, centered over the third sub-frame, to form speech_hp_win. Autocorrelation coefficients, acf, are calculated on the 240 samples in speech_hp_win and then windowed exactly as in section 3.2.1 (resulting in acf_win).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前述したように、コーデックは、30 ms フレームの場合は 2 セットの LPC パラメータを計算するのに対し、20 ms フレーム サイズでは 1 セットの LPC パラメータのみを計算します。自己相関係数の単一セットは、LPC_LOOKBACK BLOCKL = 80 160 = 240 サンプルで計算されます。これらのサンプルは、3 番目のサブフレームを中心とする非対称ウィンドウ lpc_asymwinTbl でウィンドウ処理され、speech_hp_win を形成します。自己相関係数 acf は speech_hp_win の 240 サンプルで計算され、セクション 3.2.1 とまったく同じようにウィンドウ処理されます (結果として acf_win が得られます)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This single set of windowed autocorrelation coefficients is used to calculate LPC coefficients, LSF coefficients, and quantized LSF coefficients in exactly the same manner as in sections 3.2.3 through 3.2.4. As for the 30 ms frame size, the ten LSF coefficients are divided into three sub-vectors of size 3, 3, and 4 and quantized by using the same scheme and codebook as in section 3.2.4 to finally get 3 quantization indices. The quantized LSF coefficients are stabilized with the algorithm described in section 3.2.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このウィンドウ処理された自己相関係数の単一セットは、セクション 3.2.3 から 3.2.4 とまったく同じ方法で、LPC 係数、LSF 係数、および量子化 LSF 係数を計算するために使用されます。30 ms のフレーム サイズに関しては、10 個の LSF 係数がサイズ 3、3、および 4 の 3 つのサブベクトルに分割され、セクション 3.2.4 と同じスキームとコードブックを使用して量子化され、最終的に 3 つの量子化インデックスが得られます。量子化された LSF 係数は、セクション 3.2.5 で説明されているアルゴリズムで安定化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the set of LSF coefficients computed for this block and those from the previous block, different LSFs are obtained for each sub-block by means of interpolation. The interpolation is done linearly in the LSF domain over the four sub-blocks, so that the n-th sub- frame uses the weight (4-n)/4 for the LSF from old frame and the weight n/4 of the LSF from the current frame. For the very first block the mean LSF, lsfmeanTbl, is used as the LSF from the previous block. Similarly as seen in section 3.2.6, both unquantized, A(z), and quantized, A~(z), analysis filters are calculated for each of the four sub-blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このブロックに対して計算された LSF 係数のセットと前のブロックからの LSF 係数のセットから、補間によってサブブロックごとに異なる LSF が取得されます。補間は 4 つのサブブロックにわたる LSF ドメインで線形に行われるため、n 番目のサブフレームでは古いフレームからの LSF の重み (4-n)/4 と LSF の重み n/4 が使用されます。現在のフレームから。一番最初のブロックでは、平均 LSF lsfmeanTbl が前のブロックの LSF として使用されます。同様に、セクション 3.2.6 で見られるように、非量子化 A(z) と量子化 A~(z) の両方の分析フィルターが 4 つのサブブロックのそれぞれに対して計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--Calculation-of-the-Residual">
3.3. Calculation of the Residual
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 残差の計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The block of speech samples is filtered by the quantized and interpolated LPC analysis filters to yield the residual signal. In particular, the corresponding LPC analysis filter for each 40 sample sub-block is used to filter the speech samples for the same sub-block. The filter memory at the end of each sub-block is carried over to the LPC filter of the next sub-block. The signal at the output of each LP analysis filter constitutes the residual signal for the corresponding sub-block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
音声サンプルのブロックは、量子化および補間された LPC 分析フィルターによってフィルター処理され、残差信号が生成されます。特に、各 40 サンプル サブブロックの対応する LPC 分析フィルターは、同じサブブロックの音声サンプルをフィルター処理するために使用されます。各サブブロックの終わりにあるフィルター メモリは、次のサブブロックの LPC フィルターに引き継がれます。各 LP 分析フィルターの出力における信号は、対応するサブブロックの残差信号を構成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reference implementation of the LPC analysis filters is given in Appendix A.10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LPC 分析フィルターのリファレンス実装は、付録 A.10 に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-4--Perceptual-Weighting-Filter">
3.4. Perceptual Weighting Filter
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. 知覚重み付けフィルター
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In principle any good design of a perceptual weighting filter can be applied in the encoder without compromising this codec definition. However, it is RECOMMENDED to use the perceptual weighting filter Wk for sub-block k specified below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
原理的には、知覚的重み付けフィルタの優れた設計は、このコーデックの定義を損なうことなくエンコーダに適用できます。ただし、以下に指定されるサブブロック k に対して知覚重み付けフィルター Wk を使用することが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Wk(z)=1/Ak(z/LPC_CHIRP_WEIGHTDENUM), where
                               LPC_CHIRP_WEIGHTDENUM = 0.4222
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is a simple design with low complexity that is applied in the LPC residual domain. Here Ak(z) is the filter obtained for sub-block k from unquantized but interpolated LSF coefficients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、LPC 残差ドメインに適用される、複雑さの低い単純な設計です。ここで、Ak(z) は、量子化されていないが補間された LSF 係数からサブブロック k に対して取得されたフィルターです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5--Start-State-Encoder">
3.5. Start State Encoder
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. 開始状態エンコーダー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The start state is quantized by using a common 6-bit scalar quantizer for the block and a 3-bit scalar quantizer operating on scaled samples in the weighted speech domain. In the following we describe the state encoding in greater detail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
開始状態は、ブロック用の共通の 6 ビット スカラー量子化器と、重み付き音声ドメインのスケーリングされたサンプルで動作する 3 ビット スカラー量子化器を使用して量子化されます。以下では、状態エンコーディングについて詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-1--Start-State-Estimation">
3.5.1. Start State Estimation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1. 状態推定の開始
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two sub-blocks containing the start state are determined by finding the two consecutive sub-blocks in the block having the highest power. Advantageously, down-weighting is used in the beginning and end of the sub-frames, i.e., the following measure is computed (NSUB=4/6 for 20/30 ms frame size):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
開始状態を含む 2 つのサブブロックは、ブロック内で最も高い電力を持つ 2 つの連続するサブブロックを見つけることによって決定されます。有利なことに、ダウン重み付けはサブフレームの最初と最後で使用されます。つまり、次の尺度が計算されます（20/30 ms フレーム サイズでは NSUB=4/6）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nsub=1,...,NSUB-1
      ssqn[nsub] = 0.0;
      for (i=(nsub-1)*SUBL; i&lt;(nsub-1)*SUBL+5; i++)
               ssqn[nsub] += sampEn_win[i-(nsub-1)*SUBL]*
                                 residual[i]*residual[i];
      for (i=(nsub-1)*SUBL+5; i&lt;(nsub+1)*SUBL-5; i++)
               ssqn[nsub] += residual[i]*residual[i];
      for (i=(nsub+1)*SUBL-5; i&lt;(nsub+1)*SUBL; i++)
               ssqn[nsub] += sampEn_win[(nsub+1)*SUBL-i-1]*
                                 residual[i]*residual[i];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where sampEn_win[5]={1/6, 2/6, 3/6, 4/6, 5/6}; MAY be used. The sub-frame number corresponding to the maximum value of ssqEn_win[nsub-1]*ssqn[nsub] is selected as the start state indicator. A weighting of ssqEn_win[]={0.8,0.9,1.0,0.9,0.8} for 30 ms frames and ssqEn_win[]={0.9,1.0,0.9} for 20 ms frames; MAY advantageously be used to bias the start state towards the middle of the frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、sampEn_win[5]={1/6、2/6、3/6、4/6、5/6};使用してもよい。ssqEn_win[nsub-1]*ssqn[nsub]の最大値に対応するサブフレーム番号が開始状態指示子として選択される。30 ミリ秒フレームの場合は ssqEn_win[]={0.8,0.9,1.0,0.9,0.8}、20 ミリ秒フレームの場合は ssqEn_win[]={0.9,1.0,0.9} の重み付け。開始状態をフレームの中央に向けてバイアスするために使用すると有利になる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For 20 ms frames there are three possible positions for the two-sub-block length maximum power segment; the start state position is encoded with 2 bits. The start state position, start, MUST be encoded as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
20 ms フレームの場合、2 サブブロック長の最大パワー セグメントには 3 つの可能な位置があります。開始状態の位置は 2 ビットでエンコードされます。開始状態の位置 start は、次のようにエンコードされなければなりません (MUST)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      start=1: start state in sub-frame 0 and 1
      start=2: start state in sub-frame 1 and 2
      start=3: start state in sub-frame 2 and 3
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For 30 ms frames there are five possible positions of the two-sub-block length maximum power segment, the start state position is encoded with 3 bits. The start state position, start, MUST be encoded as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
30 ms フレームの場合、2 サブブロック長の最大パワー セグメントの可能な位置は 5 つあり、開始状態の位置は 3 ビットでエンコードされます。開始状態の位置 start は、次のようにエンコードされなければなりません (MUST)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      start=1: start state in sub-frame 0 and 1
      start=2: start state in sub-frame 1 and 2
      start=3: start state in sub-frame 2 and 3
      start=4: start state in sub-frame 3 and 4
      start=5: start state in sub-frame 4 and 5
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hence, in both cases, index 0 is not used. In order to shorten the start state for bit rate efficiency, the start state is brought down to STATE_SHORT_LEN=57 samples for 20 ms frames and STATE_SHORT_LEN=58 samples for 30 ms frames. The power of the first 23/22 and last 23/22 samples of the two sub-frame blocks identified above is computed as the sum of the squared signal sample values, and the 23/22-sample segment with the lowest power is excluded from the start state. One bit is transmitted to indicate which of the two possible 57/58 sample segments is used. The start state position within the two sub-frames determined above, state_first, MUST be encoded as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、どちらの場合もインデックス 0 は使用されません。ビット レート効率を高めるために開始状態を短縮するために、開始状態は 20 ms フレームの場合は STATE_SHORT_LEN=57 サンプル、30 ms フレームの場合は STATE_SHORT_LEN=58 サンプルに引き下げられます。上記で識別された 2 つのサブフレーム ブロックの最初の 23/22 サンプルと最後の 23/22 サンプルのパワーは、二乗信号サンプル値の合計として計算され、最も低いパワーを持つ 23/22 サンプル セグメントは除外されます。開始状態。1 ビットが送信され、2 つの可能な 57/58 サンプル セグメントのどれが使用されるかを示します。上記で決定された 2 つのサブフレーム内の開始状態位置、state_first は、次のようにエンコードされなければなりません (MUST)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      state_first=1: start state is first STATE_SHORT_LEN samples
      state_first=0: start state is last STATE_SHORT_LEN samples
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-2--All-Pass-Filtering-and-Scale-Quantization">
3.5.2. All-Pass Filtering and Scale Quantization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.2. オールパスフィルタリングとスケール量子化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The block of residual samples in the start state is first filtered by an all-pass filter with the quantized LPC coefficients as denominator and reversed quantized LPC coefficients as numerator. The purpose of this phase-dispersion filter is to get a more even distribution of the sample values in the residual signal. The filtering is performed by circular convolution, where the initial filter memory is set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
開始状態の残差サンプルのブロックは、まず、分母として量子化 LPC 係数、分子として逆量子化 LPC 係数を使用するオールパス フィルターによってフィルター処理されます。この位相分散フィルターの目的は、残差信号内のサンプル値のより均一な分布を取得することです。フィルタリングは循環畳み込みによって実行され、初期フィルタ メモリはゼロに設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      res(0..(STATE_SHORT_LEN-1))   = uncoded start state residual
      res((STATE_SHORT_LEN)..(2*STATE_SHORT_LEN-1)) = 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Pk(z) = A~rk(z)/A~k(z), where
                                   ___
                                   \
      A~rk(z)= z^(-LPC_FILTERORDER)+&gt;a~k(i+1)*z^(i-(LPC_FILTERORDER-1))
                                   /__
                               i=0...(LPC_FILTERORDER-1)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
and A~k(z) is taken from the block where the start state begins
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A~k(z) は開始状態が始まるブロックから取得されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      res -&gt; Pk(z) -&gt; filtered
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ccres(k) = filtered(k) + filtered(k+STATE_SHORT_LEN),
                                        k=0..(STATE_SHORT_LEN-1)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The all-pass filtered block is searched for its largest magnitude sample. The 10-logarithm of this magnitude is quantized with a 6-bit quantizer, state_frgqTbl, by finding the nearest representation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オールパス フィルター処理されたブロックで最大の大きさのサンプルが検索されます。この大きさの 10 対数は、最も近い表現を見つけることによって 6 ビット量子化器 state_frgqTbl で量子化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This results in an index, idxForMax, corresponding to a quantized value, qmax. The all-pass filtered residual samples in the block are then multiplied with a scaling factor scal=4.5/(10^qmax) to yield normalized samples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、量子化値 qmax に対応するインデックス idxForMax が生成されます。次に、ブロック内のオールパス フィルター処理された残差サンプルにスケーリング係数 scal=4.5/(10^qmax) を乗算して、正規化されたサンプルを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   state_frgqTbl[64] = {1.000085, 1.071695, 1.140395, 1.206868,
                  1.277188, 1.351503, 1.429380, 1.500727, 1.569049,
                  1.639599, 1.707071, 1.781531, 1.840799, 1.901550,
                  1.956695, 2.006750, 2.055474, 2.102787, 2.142819,
                  2.183592, 2.217962, 2.257177, 2.295739, 2.332967,
                  2.369248, 2.402792, 2.435080, 2.468598, 2.503394,
                  2.539284, 2.572944, 2.605036, 2.636331, 2.668939,
                  2.698780, 2.729101, 2.759786, 2.789834, 2.818679,
                  2.848074, 2.877470, 2.906899, 2.936655, 2.967804,
                  3.000115, 3.033367, 3.066355, 3.104231, 3.141499,
                  3.183012, 3.222952, 3.265433, 3.308441, 3.350823,
                  3.395275, 3.442793, 3.490801, 3.542514, 3.604064,
                  3.666050, 3.740994, 3.830749, 3.938770, 4.101764}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-3--Scalar-Quantization">
3.5.3. Scalar Quantization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.3. スカラー量子化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The normalized samples are quantized in the perceptually weighted speech domain by a sample-by-sample scalar DPCM quantization as depicted in Figure 3.3. Each sample in the block is filtered by a weighting filter Wk(z), specified in section 3.4, to form a weighted speech sample x[n]. The target sample d[n] is formed by subtracting a predicted sample y[n], where the prediction filter is given by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正規化されたサンプルは、図 3.3 に示すように、サンプルごとのスカラー DPCM 量子化によって、知覚的に重み付けされた音声ドメインで量子化されます。ブロック内の各サンプルは、セクション 3.4 で指定された重み付けフィルター Wk(z) によってフィルター処理され、重み付けされた音声サンプル x[n] が形成されます。ターゲット サンプル d[n] は、予測サンプル y[n] を減算することによって形成されます。ここで、予測フィルターは次の式で与えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
Pk(z) = 1 - 1 / Wk(z).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
Pk(z) = 1 - 1 / Wk(z)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               +-------+  x[n] +    d[n] +-----------+ u[n]
   residual --&gt;| Wk(z) |--------&gt;(+)----&gt;| Quantizer |------&gt; quantized
               +-------+       - /|\     +-----------+    |   residual
                                  |                      \|/
                             y[n] +---------------------&gt;(+)
                                  |                       |
                                  |        +------+       |
                                  +--------| Pk(z)|&lt;------+
                                           +------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 3.3. Quantization of start state samples by DPCM in weighted speech domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図3.3。加重音声ドメインにおける DPCM による開始状態サンプルの量子化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The coded state sample u[n] is obtained by quantizing d[n] with a 3- bit quantizer with quantization table state_sq3Tbl.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コード化された状態サンプル u[n] は、量子化テーブル state_sq3Tbl を備えた 3 ビット量子化器で d[n] を量子化することによって取得されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   state_sq3Tbl[8] = {-3.719849, -2.177490, -1.130005, -0.309692,
                  0.444214, 1.329712, 2.436279, 3.983887}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The quantized samples are transformed back to the residual domain by 1) scaling with 1/scal; 2) time-reversing the scaled samples; 3) filtering the time-reversed samples by the same all-pass filter, as in section 3.5.2, by using circular convolution; and 4) time-reversing the filtered samples. (More detail is in section 4.2.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
量子化されたサンプルは、1) 1/scal でスケーリングすることによって、残差ドメインに変換されます。２）スケーリングされたサンプルを時間反転する。3) 循環畳み込みを使用して、セクション 3.5.2 と同じオールパス フィルターで時間反転したサンプルをフィルター処理します。4) フィルタリングされたサンプルを時間反転します。(詳細についてはセクション 4.2 を参照してください。)
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reference implementation of the start-state encoding can be found in Appendix A.46.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
開始状態エンコーディングの参照実装は、付録 A.46 にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6--Encoding-the-Remaining-Samples">
3.6. Encoding the Remaining Samples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. 残りのサンプルのエンコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A dynamic codebook is used to encode 1) the 23/22 remaining samples in the two sub-blocks containing the start state; 2) the sub-blocks after the start state in time; and 3) the sub-blocks before the start state in time. Thus, the encoding target can be either the 23/22 samples remaining of the 2 sub-blocks containing the start state, or a 40-sample sub-block. This target can consist of samples that are indexed forward in time or backward in time, depending on the location of the start state. The length of the target is denoted by lTarget.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
動的コードブックは、1) 開始状態を含む 2 つのサブブロック内の残りの 23/22 サンプルをエンコードするために使用されます。2) 開始状態の後のサブブロック。3) 開始状態の前のサブブロック。したがって、符号化ターゲットは、開始状態を含む 2 つのサブブロックの残りの 23/22 サンプル、または 40 サンプルのサブブロックのいずれかになります。このターゲットは、開始状態の位置に応じて、時間的に順方向または時間的に逆方向にインデックス付けされたサンプルで構成されます。ターゲットの長さは lTarget で示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The coding is based on an adaptive codebook that is built from a codebook memory that contains decoded LPC excitation samples from the already encoded part of the block. These samples are indexed in the same time direction as is the target vector and end at the sample instant prior to the first sample instant represented in the target vector. The codebook memory has length lMem, which is equal to CB_MEML=147 for the two/four 40-sample sub-blocks and 85 for the 23/22-sample sub-block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コーディングは、ブロックの既にエンコードされた部分からデコードされた LPC 励振サンプルを含むコードブック メモリから構築される適応コードブックに基づいています。これらのサンプルは、ターゲット ベクトルと同じ時間方向にインデックス付けされ、ターゲット ベクトルで表される最初のサンプル瞬間より前のサンプル瞬間で終了します。コードブックメモリの長さはlMemであり、これは2/4の40サンプルサブブロックではCB_MEML=147、23/22サンプルサブブロックでは85に等しい。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following figure shows an overview of the encoding procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコード手順の概要を次の図に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         +------------+    +---------------+    +-------------+
      -&gt; | 1. Decode  | -&gt; | 2. Mem setup  | -&gt; | 3. Perc. W. | -&gt;
         +------------+    +---------------+    +-------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         +------------+    +-----------------+
      -&gt; | 4. Search  | -&gt; | 5. Upd. Target  | ------------------&gt;
       | +------------+    +------------------ |
       ----&lt;-------------&lt;-----------&lt;----------
                     stage=0..2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         +----------------+
      -&gt; | 6. Recalc G[0] | ---------------&gt; gains and CB indices
         +----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 3.4. Flow chart of the codebook search in the iLBC encoder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図3.4。iLBC エンコーダでのコードブック検索のフローチャート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Decode the part of the residual that has been encoded so far, using the codebook without perceptual weighting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 知覚的重み付けを行わずにコードブックを使用して、これまでにエンコードされた残差の部分をデコードします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Set up the memory by taking data from the decoded residual. This memory is used to construct codebooks. For blocks preceding the start state, both the decoded residual and the target are time reversed (section 3.6.1). 3. Filter the memory + target with the perceptual weighting filter (section 3.6.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. デコードされた残差からデータを取得してメモリをセットアップします。このメモリはコードブックの構築に使用されます。開始状態に先行するブロックでは、デコードされた残差とターゲットの両方が時間反転されます (セクション 3.6.1)。3. 知覚重み付けフィルタを使用してメモリターゲットをフィルタリングします (セクション 3.6.2)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Search for the best match between the target and the codebook vector. Compute the optimal gain for this match and quantize that gain (section 3.6.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. ターゲットとコードブック ベクトルの間で最も一致するものを検索します。この一致に対する最適なゲインを計算し、そのゲインを量子化します (セクション 3.6.4)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Update the perceptually weighted target by subtracting the contribution from the selected codebook vector from the perceptually weighted memory (quantized gain times selected vector). Repeat 4 and 5 for the two additional stages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 知覚的に重み付けされたメモリから選択されたコードブック ベクトルからの寄与を減算することにより、知覚的に重み付けされたターゲットを更新します (量子化ゲインと選択したベクトルの積)。追加の 2 つのステージに対して 4 と 5 を繰り返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Calculate the energy loss due to encoding of the residual. If needed, compensate for this loss by an upscaling and requantization of the gain for the first stage (section 3.7).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 残差のエンコードによるエネルギー損失を計算します。必要に応じて、最初のステージのゲインのアップスケーリングと再量子化によってこの損失を補償します (セクション 3.7)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following sections provide an in-depth description of the different blocks of Figure 3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクションでは、図 3.4 のさまざまなブロックについて詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-1--Codebook-Memory">
3.6.1. Codebook Memory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.1. コードブックメモリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The codebook memory is based on the already encoded sub-blocks, so the available data for encoding increases for each new sub-block that has been encoded. Until enough sub-blocks have been encoded to fill the codebook memory with data, it is padded with zeros. The following figure shows an example of the order in which the sub-blocks are encoded for the 30 ms frame size if the start state is located in the last 58 samples of sub-block 2 and 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードブック メモリは、すでにエンコードされたサブブロックに基づいているため、エンコードに利用できるデータは、エンコードされた新しいサブブロックごとに増加します。コードブック メモリをデータで埋めるのに十分なサブブロックがエンコードされるまで、コードブック メモリにはゼロが埋め込まれます。次の図は、開始状態がサブブロック 2 と 3 の最後の 58 サンプルにある場合に、30 ミリ秒のフレーム サイズでサブブロックがエンコードされる順序の例を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----------------------------------------------------+
   |  5     | 1  |///|////////|    2   |    3   |    4   |
   +-----------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 3.5. The order from 1 to 5 in which the sub-blocks are encoded. The slashed area is the start state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図3.5。サブブロックがエンコードされる 1 から 5 の順序。斜線部分が開始状態です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first target sub-block to be encoded is number 1, and the corresponding codebook memory is shown in the following figure. As the target vector comes before the start state in time, the codebook memory and target vector are time reversed; thus, after the block has been time reversed the search algorithm can be reused. As only the start state has been encoded so far, the last samples of the codebook memory are padded with zeros.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
符号化される最初のターゲット サブブロックは番号 1 であり、対応するコードブック メモリを次の図に示します。ターゲット ベクトルが開始状態よりも時間的に前に来ると、コードブック メモリとターゲット ベクトルの時間が逆転します。したがって、ブロックが時間反転された後、検索アルゴリズムを再利用できます。これまでは開始状態のみがエンコードされているため、コードブック メモリの最後のサンプルにはゼロが埋め込まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------------------
   |zeros|\\\\\\\\|\\\\|  1 |
   +-------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 3.6. The codebook memory, length lMem=85 samples, and the target vector 1, length 22 samples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図3.6。コードブック メモリ、長さ lMem=85 サンプル、およびターゲット ベクトル 1、長さ 22 サンプル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next step is to encode sub-block 2 by using the memory that now has increased since sub-block 1 has been encoded. The following figure shows the codebook memory for encoding of sub-block 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のステップは、サブブロック 1 がエンコードされてから増加したメモリを使用して、サブブロック 2 をエンコードすることです。次の図は、サブブロック 2 の符号化のためのコードブック メモリを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----------------------------------
   | zeros | 1  |///|////////|    2   |
   +-----------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 3.7. The codebook memory, length lMem=147 samples, and the target vector 2, length 40 samples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図3.7。コードブック メモリ、長さ lMem=147 サンプル、およびターゲット ベクトル 2、長さ 40 サンプル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next step is to encode sub-block 3 by using the memory which has been increased yet again since sub-blocks 1 and 2 have been encoded, but the sub-block still has to be padded with a few zeros. The following figure shows the codebook memory for encoding of sub-block 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のステップは、サブブロック 1 と 2 がエンコードされてからさらに増加したメモリを使用してサブブロック 3 をエンコードすることですが、サブブロックにはまだいくつかのゼロを埋め込む必要があります。次の図は、サブブロック 3 の符号化のためのコードブック メモリを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------------------------------------
   |zeros| 1  |///|////////|    2   |   3    |
   +------------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 3.8. The codebook memory, length lMem=147 samples, and the target vector 3, length 40 samples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図3.8。コードブック メモリ、長さ lMem=147 サンプル、およびターゲット ベクトル 3、長さ 40 サンプル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next step is to encode sub-block 4 by using the memory which now has increased yet again since sub-blocks 1, 2, and 3 have been encoded. This time, the memory does not have to be padded with zeros. The following figure shows the codebook memory for encoding of sub-block 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のステップは、サブブロック 1、2、および 3 が符号化されてからさらに増加したメモリを使用して、サブブロック 4 を符号化することです。今回は、メモリにゼロを埋め込む必要はありません。次の図は、サブブロック 4 の符号化のためのコードブック メモリを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------------------------------------
   |1|///|////////|    2   |   3    |   4    |
   +------------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 3.9. The codebook memory, length lMem=147 samples, and the target vector 4, length 40 samples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図3.9。コードブック メモリ、長さ lMem=147 サンプル、およびターゲット ベクトル 4、長さ 40 サンプル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The final target sub-block to be encoded is number 5, and the following figure shows the corresponding codebook memory. As the target vector comes before the start state in time, the codebook memory and target vector are time reversed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコードされる最終ターゲット サブブロックは 5 番で、次の図は対応するコードブック メモリを示しています。ターゲット ベクトルが開始状態よりも時間的に前に来ると、コードブック メモリとターゲット ベクトルの時間が逆転します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------------------------------------
   |  3  |   2    |\\\\\\\\|\\\\|  1 |   5    |
   +-------------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 3.10. The codebook memory, length lMem=147 samples, and the target vector 5, length 40 samples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図3.10。コードブック メモリ、長さ lMem=147 サンプル、およびターゲット ベクトル 5、長さ 40 サンプル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the case of 20 ms frames, the encoding procedure looks almost exactly the same. The only difference is that the size of the start state is 57 samples and that there are only three sub-blocks to be encoded. The encoding order is the same as above, starting with the 23-sample target and then encoding the two remaining 40-sample sub-blocks, first going forward in time and then going backward in time relative to the start state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
20 ms フレームの場合、エンコード手順はほぼ同じになります。唯一の違いは、開始状態のサイズが 57 サンプルであり、エンコードされるサブブロックが 3 つだけであることです。エンコード順序は上記と同じで、23 サンプルのターゲットから開始して、残りの 2 つの 40 サンプルのサブブロックをエンコードします。最初は時間的に順方向に進み、次に開始状態に対して時間的に逆方向に進みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2--Perceptual-Weighting-of-Codebook-Memory-and-Target">
3.6.2. Perceptual Weighting of Codebook Memory and Target
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2. コードブックメモリとターゲットの知覚的重み付け
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide a perceptual weighting of the coding error, a concatenation of the codebook memory and the target to be coded is all-pole filtered with the perceptual weighting filter specified in section 3.4. The filter state of the weighting filter is set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
符号化エラーの知覚的重み付けを提供するために、コードブック メモリと符号化対象のターゲットの連結が、セクション 3.4 で指定された知覚的重み付けフィルタで全極フィルタリングされます。重み付けフィルタのフィルタ状態はゼロに設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      in(0..(lMem-1))            = unweighted codebook memory
      in(lMem..(lMem+lTarget-1)) = unweighted target signal
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      in -&gt; Wk(z) -&gt; filtered,
          where Wk(z) is taken from the sub-block of the target
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      weighted codebook memory = filtered(0..(lMem-1))
      weighted target signal = filtered(lMem..(lMem+lTarget-1))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The codebook search is done with the weighted codebook memory and the weighted target, whereas the decoding and the codebook memory update uses the unweighted codebook memory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードブックの検索は重み付けされたコードブック メモリと重み付けされたターゲットを使用して実行されますが、デコードとコードブック メモリの更新は重み付けされていないコードブック メモリを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3--Codebook-Creation">
3.6.3. Codebook Creation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3. コードブックの作成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The codebook for the search is created from the perceptually weighted codebook memory. It consists of two sections, where the first is referred to as the base codebook and the second as the expanded codebook, as it is created by linear combinations of the first. Each of these two sections also has a subsection referred to as the augmented codebook. The augmented codebook is only created and used for the coding of the 40-sample sub-blocks and not for the 23/22- sample sub-block case. The codebook size used for the different sub-blocks and different stages are summarized in the table below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
検索用のコードブックは、知覚的に重み付けされたコードブック メモリから作成されます。これは 2 つのセクションで構成されており、最初のセクションは基本コードブックと呼ばれ、2 番目のセクションは最初のコードブックの線形結合によって作成されるため、拡張コードブックと呼ばれます。これら 2 つのセクションにはそれぞれ、拡張コードブックと呼ばれるサブセクションもあります。拡張コードブックは、40 サンプルのサブブロックのコーディングにのみ作成および使用され、23/22 サンプルのサブブロックの場合には使用されません。さまざまなサブブロックおよびさまざまなステージに使用されるコードブックのサイズを以下の表にまとめます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                              Stage
                        1               2 &amp; 3
           --------------------------------------------
                22     128  (64+0)*2     128 (64+0)*2
   Sub-    1:st 40     256  (108+20)*2   128 (44+20)*2
   Blocks  2:nd 40     256  (108+20)*2   256 (108+20)*2
           3:rd 40     256  (108+20)*2   256 (108+20)*2
           4:th 40     256  (108+20)*2   256 (108+20)*2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 3.1. Codebook sizes for the 30 ms mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表3.1。30 ms モードのコードブック サイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 3.1 shows the codebook size for the different sub-blocks and stages for 30 ms frames. Inside the parentheses it shows how the number of codebook vectors is distributed, within the two sections, between the base/expanded codebook and the augmented base/expanded codebook. It should be interpreted in the following way: (base/expanded cb + augmented base/expanded cb). The total number of codebook vectors for a specific sub-block and stage is given by the following formula:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表 3.1 は、30 ms フレームのさまざまなサブブロックとステージのコードブック サイズを示しています。括弧内は、2 つのセクション内で、基本/拡張コードブックと拡張基本/拡張コードブックの間でコードブック ベクトルの数がどのように配分されるかを示しています。これは次のように解釈する必要があります: (ベース/拡張 CB 拡張ベース/拡張 CB)。特定のサブブロックおよびステージのコードブック ベクトルの総数は、次の式で求められます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Tot. cb vectors = base cb + aug. base cb + exp. cb + aug. exp. cb
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The corresponding values to Figure 3.1 for 20 ms frames are only slightly modified. The short sub-block is 23 instead of 22 samples, and the 3:rd and 4:th sub-frame are not present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
20 ms フレームの図 3.1 に対応する値は、わずかに変更されているだけです。短いサブブロックは 22 サンプルではなく 23 サンプルであり、3 番目と 4 番目のサブフレームは存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-1--Creation-of-a-Base-Codebook">
3.6.3.1. Creation of a Base Codebook
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.1. 基本コードブックの作成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The base codebook is given by the perceptually weighted codebook memory that is mentioned in section 3.5.3. The different codebook vectors are given by sliding a window of length 23/22 or 40, given by variable lTarget, over the lMem-long perceptually weighted codebook memory. The indices are ordered so that the codebook vector containing sample (lMem-lTarget-n) to (lMem-n-1) of the codebook memory vector has index n, where n=0..lMem-lTarget. Thus the total number of base codebook vectors is lMem-lTarget+1, and the indices are ordered from sample delay lTarget (23/22 or 40) to lMem+1 (86 or 148).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本コードブックは、セクション 3.5.3 で説明されている知覚的に重み付けされたコードブック メモリによって与えられます。異なるコードブック ベクトルは、変数 lTarget で指定される長さ 23/22 または 40 のウィンドウを、lMem の長さの知覚的に重み付けされたコードブック メモリ上でスライドさせることによって指定されます。インデックスは、コードブック メモリ ベクトルのサンプル (lMem-lTarget-n) から (lMem-n-1) を含むコードブック ベクトルがインデックス n を持つように順序付けされます (n=0..lMem-lTarget)。したがって、基本コードブック ベクトルの総数は lMem - lTarget 1 であり、インデックスはサンプル遅延 lTarget (23/22 または 40) から lMem 1 (86 または 148) までの順序になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-2--Codebook-Expansion">
3.6.3.2. Codebook Expansion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.2. コードブックの拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The base codebook is expanded by a factor of 2, creating an additional section in the codebook. This new section is obtained by filtering the base codebook, base_cb, with a FIR filter with filter length CB_FILTERLEN=8. The construction of the expanded codebook compensates for the delay of four samples introduced by the FIR filter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本コードブックは 2 倍に拡張され、コードブックに追加セクションが作成されます。この新しいセクションは、フィルタ長 CB_FILTERLEN=8 の FIR フィルタを使用してベース コードブック、base_cb をフィルタリングすることによって取得されます。拡張されたコードブックの構築により、FIR フィルターによって導入された 4 つのサンプルの遅延が補償されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   cbfiltersTbl[CB_FILTERLEN]={-0.033691, 0.083740, -0.144043,
                  0.713379, 0.806152, -0.184326,
                  0.108887, -0.034180};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   ___
                   \
      exp_cb(k)=  + &gt; cbfiltersTbl(i)*x(k-i+4)
                   /__
             i=0...(LPC_FILTERORDER-1)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      where x(j) = base_cb(j) for j=0..lMem-1 and 0 otherwise
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The individual codebook vectors of the new filtered codebook, exp_cb, and their indices are obtained in the same fashion as described above for the base codebook.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいフィルタリングされたコードブックの個々のコードブック ベクトル exp_cb とそのインデックスは、ベース コードブックについて上で説明したのと同じ方法で取得されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-3--Codebook-Augmentation">
3.6.3.3. Codebook Augmentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.3. コードブックの拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For cases where encoding entire sub-blocks, i.e., cbveclen=40, the base and expanded codebooks are augmented to increase codebook richness. The codebooks are augmented by vectors produced by interpolation of segments. The base and expanded codebook, constructed above, consists of vectors corresponding to sample delays in the range from cbveclen to lMem. The codebook augmentation attempts to augment these codebooks with vectors corresponding to sample delays from 20 to 39. However, not all of these samples are present in the base codebook and expanded codebook, respectively. Therefore, the augmentation vectors are constructed as linear combinations between samples corresponding to sample delays in the range 20 to 39. The general idea of this procedure is presented in the following figures and text. The procedure is performed for both the base codebook and the expanded codebook.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブブロック全体をエンコードする場合、つまり cbveclen=40 の場合、基本コードブックと拡張コードブックが拡張されてコードブックの豊富さが向上します。コードブックは、セグメントの補間によって生成されたベクトルによって拡張されます。上記で構築された基本コードブックと拡張コードブックは、cbveclen から lMem までの範囲のサンプル遅延に対応するベクトルで構成されています。コードブックの拡張では、20 ～ 39 のサンプル遅延に対応するベクトルでこれらのコードブックを拡張しようとします。ただし、これらのサンプルのすべてがそれぞれ基本コードブックと拡張コードブックに存在するわけではありません。したがって、拡張ベクトルは、20 ～ 39 の範囲のサンプル遅延に対応するサンプル間の線形結合として構築されます。この手順の一般的な概念は、次の図と本文に示されています。この手順は、基本コードブックと拡張コードブックの両方に対して実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       - - ------------------------|
    codebook memory                |
       - - ------------------------|
                  |-5-|---15---|-5-|
                  pi  pp       po
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                      |        |                       Codebook vector
                      |---15---|-5-|-----20-----|   &lt;- corresponding to
                          i     ii      iii            sample delay 20
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 3.11. Generation of the first augmented codebook.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図3.11。最初の拡張コードブックの生成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 3.11 shows the codebook memory with pointers pi, pp, and po, where pi points to sample 25, pp to sample 20, and po to sample 5. Below the codebook memory, the augmented codebook vector corresponding to sample delay 20 is drawn. Segment i consists of fifteen samples from pointer pp and forward in time. Segment ii consists of five interpolated samples from pi and forward and from po and forward. The samples are linearly interpolated with weights [0.0, 0.2, 0.4, 0.6, 0.8] for pi and weights [1.0, 0.8, 0.6, 0.4, 0.2] for po. Segment iii consists of twenty samples from pp and forward. The augmented codebook vector corresponding to sample delay 21 is produced by moving pointers pp and pi one sample backward in time. This gives us the following figure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図 3.11 は、ポインタ pi、pp、po を持つコードブック メモリを示しています。ここで、pi はサンプル 25、pp はサンプル 20、po はサンプル 5 を指します。コードブック メモリの下には、サンプル遅延 20 に対応する拡張コードブック ベクトルが描画されます。セグメント i は、ポインター pp 以降の 15 個のサンプルで構成されます。セグメント ii は、pi 以降および po 以降の 5 つの補間サンプルで構成されます。サンプルは、pi の重み [0.0、0.2、0.4、0.6、0.8]、po の重み [1.0、0.8、0.6、0.4、0.2] で線形補間されます。セグメント iii は、pp 以降の 20 個のサンプルで構成されます。サンプル遅延 21 に対応する拡張コードブック ベクトルは、ポインタ pp および pi を時間的に 1 サンプル後方に移動することによって生成されます。これにより、次の図が得られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       - - ------------------------|
    codebook memory                |
       - - ------------------------|
                  |-5-|---16---|-5-|
                  pi  pp       po
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                      |        |                       Codebook vector
                      |---16---|-5-|-----19-----|   &lt;- corresponding to
                          i     ii      iii            sample delay 21
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 3.12. Generation of the second augmented codebook.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図3.122 番目の拡張コードブックの生成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 3.12 shows the codebook memory with pointers pi, pp and po where pi points to sample 26, pp to sample 21, and po to sample 5. Below the codebook memory, the augmented codebook vector corresponding to sample delay 21 is drawn. Segment i now consists of sixteen samples from pp and forward. Segment ii consists of five interpolated samples from pi and forward and from po and forward, and the interpolation weights are the same throughout the procedure. Segment iii consists of nineteen samples from pp and forward. The same procedure of moving the two pointers is continued until the last augmented vector corresponding to sample delay 39 has been created. This gives a total of twenty new codebook vectors to each of the two sections. Thus the total number of codebook vectors for each of the two sections, when including the augmented codebook, becomes lMem-SUBL+1+SUBL/2. This is provided that augmentation is evoked, i.e., that lTarget=SUBL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図 3.12 は、ポインタ pi、pp、po を持つコードブック メモリを示しています。ここで、pi はサンプル 26、pp はサンプル 21、po はサンプル 5 を指します。コードブック メモリの下には、サンプル遅延 21 に対応する拡張コードブック ベクトルが描画されます。セグメント i は、pp 以降の 16 個のサンプルで構成されています。セグメント ii は、pi 以降および po 以降の 5 つの補間サンプルで構成され、補間重みは手順全体を通じて同じです。セグメント iii は、pp 以降の 19 個のサンプルで構成されます。２つのポインタを移動する同じ手順は、サンプル遅延３９に対応する最後の拡張ベクトルが作成されるまで継続される。これにより、合計 20 個の新しいコードブック ベクトルが 2 つのセクションのそれぞれに与えられます。したがって、拡張コードブックを含む場合、2 つのセクションのそれぞれのコードブック ベクトルの総数は、lMem-SUBL 1 SUBL/2 になります。これは、拡張が呼び出される場合、つまり lTarget=SUBL が条件となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-4--Codebook-Search">
3.6.4. Codebook Search
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.4. コードブックの検索
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The codebook search uses the codebooks described in the sections above to find the best match of the perceptually weighted target, see section 3.6.2. The search method is a multi-stage gain-shape matching performed as follows. At each stage the best shape vector is identified, then the gain is calculated and quantized, and finally the target is updated in preparation for the next codebook search stage. The number of stages is CB_NSTAGES=3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードブック検索では、上のセクションで説明したコードブックを使用して、知覚的に重み付けされたターゲットの最適な一致を見つけます。セクション 3.6.2 を参照してください。探索方法は次のように多段階のゲイン形状マッチングを行います。各ステージで最適な形状ベクトルが特定され、ゲインが計算されて量子化され、最後に次のコードブック検索ステージに備えてターゲットが更新されます。ステージ数はCB_NSTAGES=3です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the target is the 23/22-sample vector the codebooks are indexed so that the base codebook is followed by the expanded codebook. If the target is 40 samples the order is as follows: base codebook, augmented base codebook, expanded codebook, and augmented expanded codebook. The size of each codebook section and its corresponding augmented section is given by Table 3.1 in section 3.6.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットが 23/22 サンプル ベクトルの場合、基本コードブックの後に拡張コードブックが続くようにコードブックにインデックスが付けられます。ターゲットが 40 サンプルの場合、順序は基本コードブック、拡張基本コードブック、拡張コードブック、拡張拡張コードブックになります。各コードブック セクションとそれに対応する拡張セクションのサイズは、セクション 3.6.3 の表 3.1 に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, when the second 40-sample sub-block is coded, indices 0 - 107 correspond to the base codebook, 108 - 127 correspond to the augmented base codebook, 128 - 235 correspond to the expanded codebook, and indices 236 - 255 correspond to the augmented expanded codebook. The indices are divided in the same fashion for all stages in the example. Only in the case of coding the first 40-sample sub-block is there a difference between stages (see Table 3.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、2 番目の 40 サンプルのサブブロックが符号化される場合、インデックス 0 ～ 107 は基本コードブックに対応し、108 ～ 127 は拡張基本コードブックに対応し、128 ～ 235 は拡張コードブックに対応し、インデックス 236 ～ 255 は拡張コードブックに対応します。拡張された拡張コードブックに。この例では、インデックスはすべてのステージで同じ方法で分割されています。最初の 40 サンプルのサブブロックを符号化する場合にのみ、ステージ間に違いがあります (表 3.1 を参照)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-4-1--Codebook-Search-at-Each-Stage">
3.6.4.1. Codebook Search at Each Stage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.4.1. 各段階でのコードブック検索
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The codebooks are searched to find the best match to the target at each stage. When the best match is found, the target is updated and the next-stage search is started. The three chosen codebook vectors and their corresponding gains constitute the encoded sub-block. The best match is decided by the following three criteria:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードブックは、各段階でターゲットに最もよく一致するものを見つけるために検索されます。最適な一致が見つかると、ターゲットが更新され、次の段階の検索が開始されます。選択された 3 つのコードブック ベクトルとそれらに対応するゲインは、符号化されたサブブロックを構成します。最適な一致は、次の 3 つの基準によって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Compute the measure
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. メジャーを計算する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      (target*cbvec)^2 / ||cbvec||^2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
for all codebook vectors, cbvec, and choose the codebook vector maximizing the measure. The expression (target*cbvec) is the dot product between the target vector to be coded and the codebook vector for which we compute the measure. The norm, ||x||, is defined as the square root of (x*x).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのコードブック ベクトルに対して cbvec を使用し、尺度を最大化するコードブック ベクトルを選択します。式 (target*cbvec) は、コード化されるターゲット ベクトルと測定値を計算するコードブック ベクトルの間のドット積です。ノルム ||x|| は (x*x) の平方根として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The absolute value of the gain, corresponding to the chosen codebook vector, cbvec, must be smaller than a fixed limit, CB_MAXGAIN=1.3:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 選択したコードブック ベクトル cbvec に対応するゲインの絶対値は、固定制限 CB_MAXGAIN=1.3 より小さくなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
|gain| &lt; CB_MAXGAIN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
|ゲイン|&lt; CB_MAXGAIN
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
where the gain is computed in the following way:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ここで、ゲインは次の方法で計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            gain = (target*cbvec) / ||cbvec||^2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. For the first stage, the dot product of the chosen codebook vector and target must be positive:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 最初の段階では、選択したコードブック ベクトルとターゲットのドット積が正である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
target*cbvec &gt; 0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ターゲット*cbvec &gt; 0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In practice the above criteria are used in a sequential search through all codebook vectors. The best match is found by registering a new max measure and index whenever the previously registered max measure is surpassed and all other criteria are fulfilled. If none of the codebook vectors fulfill (2) and (3), the first codebook vector is selected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際には、上記の基準は、すべてのコードブック ベクトルの順次検索に使用されます。以前に登録された最大メジャーを超え、他のすべての基準が満たされるたびに、新しい最大メジャーとインデックスを登録することによって、最良の一致が見つかります。(2) と (3) を満たすコードブック ベクトルがない場合は、最初のコードブック ベクトルが選択されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-4-2--Gain-Quantization-at-Each-Stage">
3.6.4.2. Gain Quantization at Each Stage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.4.2. 各段階でのゲイン量子化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The gain follows as a result of the computation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
計算の結果としてゲインが得られます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      gain = (target*cbvec) / ||cbvec||^2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
for the optimal codebook vector found by the procedure in section 3.6.4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション 3.6.4.1 の手順で見つかった最適なコードブック ベクトル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The three stages quantize the gain, using 5, 4, and 3 bits, respectively. In the first stage, the gain is limited to positive values. This gain is quantized by finding the nearest value in the quantization table gain_sq5Tbl.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3 つのステージでは、それぞれ 5、4、3 ビットを使用してゲインを量子化します。最初の段階では、ゲインは正の値に制限されます。このゲインは、量子化テーブル Gain_sq5Tbl で最も近い値を見つけることによって量子化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
gain_sq5Tbl[32]={0.037476, 0.075012, 0.112488, 0.150024, 0.187500, 0.224976, 0.262512, 0.299988, 0.337524, 0.375000, 0.412476, 0.450012, 0.487488, 0.525024, 0.562500, 0.599976, 0.637512, 0.674988, 0.712524, 0.750000, 0.787476, 0.825012, 0.862488, 0.900024, 0.937500, 0.974976, 1.012512, 1.049988, 1.087524, 1.125000, 1.162476, 1.200012}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ゲイン_sq5Tbl[32]={0.037476, 0.075012, 0.112488, 0.150024, 0.187500, 0.224976, 0.262512, 0.299988, 0.337524, 0.375000, 0.412476, 0.450012、0.487488、0.525024、0.562500、0.599976、0.637512、0.674988、0.712524、0.750000、0.787476、0.825012、0.862488、0.900024、0.937500、0.974976、1.012512、1.049988、1.087524、1.125000、1.162476、1.200012}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The gains of the subsequent two stages can be either positive or negative. The gains are quantized by using a quantization table times a scale factor. The second stage uses the table gain_sq4Tbl, and the third stage uses gain_sq3Tbl. The scale factor equates 0.1 or the absolute value of the quantized gain representation value obtained in the previous stage, whichever is larger. Again, the resulting gain index is the index to the nearest value of the quantization table times the scale factor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
後続の 2 つのステージのゲインは、正または負のいずれかになります。ゲインは、量子化テーブルにスケール係数を掛けたものを使用して量子化されます。2 番目のステージではテーブル Gain_sq4Tbl が使用され、3 番目のステージでは Gain_sq3Tbl が使用されます。スケールファクタは、0.1 または前段で得られた量子化ゲイン表現値の絶対値のいずれか大きい方に相当します。繰り返しますが、結果として得られるゲイン インデックスは、量子化テーブルの最も近い値のインデックスにスケール ファクターを掛けたものになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
gainQ = scaleFact * gain_sqXTbl[index]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
ゲインQ = スケールファクト * ゲイン_sqXTbl[インデックス]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   gain_sq4Tbl[16]={-1.049988, -0.900024, -0.750000, -0.599976,
                  -0.450012, -0.299988, -0.150024, 0.000000, 0.150024,
                  0.299988, 0.450012, 0.599976, 0.750000, 0.900024,
                  1.049988, 1.200012}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   gain_sq3Tbl[8]={-1.000000, -0.659973, -0.330017,0.000000,
                  0.250000, 0.500000, 0.750000, 1.00000}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-4-3--Preparation-of-Target-for-Next-Stage">
3.6.4.3. Preparation of Target for Next Stage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.4.3. 次のステージに向けた目標の準備
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before performing the search for the next stage, the perceptually weighted target vector is updated by subtracting from it the selected codebook vector (from the perceptually weighted codebook) times the corresponding quantized gain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のステージの検索を実行する前に、知覚的に重み付けされたターゲット ベクトルから、(知覚的に重み付けされたコードブックからの) 選択されたコードブック ベクトルと対応する量子化ゲインの積を減算することによって、知覚的に重み付けされたターゲット ベクトルが更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      target[i] = target[i] - gainQ * selected_vec[i];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reference implementation of the codebook encoding is found in Appendix A.34.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードブックエンコーディングの参照実装は、付録 A.34 にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-7--Gain-Correction-Encoding">
3.7. Gain Correction Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7. ゲイン補正エンコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The start state is quantized in a relatively model independent manner using 3 bits per sample. In contrast, the remaining parts of the block are encoded by using an adaptive codebook. This codebook will produce high matching accuracy whenever there is a high correlation between the target and the best codebook vector. For unvoiced speech segments and background noises, this is not necessarily so, which, due to the nature of the squared error criterion, results in a coded signal with less power than the target signal. As the coded start state has good power matching to the target, the result is a power fluctuation within the encoded frame. Perceptually, the main problem with this is that the time envelope of the signal energy becomes unsteady. To overcome this problem, the gains for the codebooks are re-scaled after the codebook encoding by searching for a new gain factor for the first stage codebook that provides better power matching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
開始状態は、サンプルあたり 3 ビットを使用して、比較的モデルに依存しない方法で量子化されます。対照的に、ブロックの残りの部分は適応コードブックを使用してエンコードされます。このコードブックは、ターゲットと最適なコードブック ベクトルの間に高い相関がある場合に、高いマッチング精度を生成します。無声音声セグメントや背景雑音の場合、これは必ずしもそうではありません。二乗誤差基準の性質により、コード化された信号のパワーがターゲット信号よりも低くなります。符号化された開始状態のパワーはターゲットと良好に一致しているため、結果として、符号化されたフレーム内でパワーが変動します。知覚的には、これに関する主な問題は、信号エネルギーの時間エンベロープが不安定になることです。この問題を解決するために、コードブックのゲインは、より優れた電力マッチングを提供する第 1 段階のコードブックの新しいゲイン係数を検索することによって、コードブックのエンコード後に再スケーリングされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, the energy for the target signal, tene, is computed along with the energy for the coded signal, cene, given by the addition of the three gain scaled codebook vectors. Because the gains of the second and third stage scale with the gain of the first stage, when the first stage gain is changed from gain[0] to gain_sq5Tbl[i] the energy of the coded signal changes from cene to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まず、ターゲット信号のエネルギー tene が、3 つのゲイン スケーリング コードブック ベクトルの加算によって得られるコード化信号 cene のエネルギーとともに計算されます。2 番目と 3 番目のステージのゲインは 1 番目のステージのゲインに合わせて調整されるため、最初のステージのゲインが Gain[0] から Gain_sq5Tbl[i] に変更されると、コード化された信号のエネルギーは cene から cene に変化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      cene*(gain_sq5Tbl[i]*gain_sq5Tbl[i])/(gain[0]*gain[0])
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where gain[0] is the gain for the first stage found in the original codebook search. A refined search is performed by testing the gain indices i=0 to 31, and as long as the new codebook energy as given above is less than tene, the gain index for stage 1 is increased. A restriction is applied so that the new gain value for stage 1 cannot be more than two times higher than the original value found in the codebook search. Note that by using this method we do not change the shape of the encoded vector, only the gain or amplitude.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、gain[0] は、元のコードブック検索で見つかった最初のステージのゲインです。洗練された検索は、ゲイン インデックス i=0 ～ 31 をテストすることによって実行され、上記の新しいコードブック エネルギーが 10 未満である限り、ステージ 1 のゲイン インデックスは増加します。ステージ 1 の新しいゲイン値が、コードブック検索で見つかった元の値の 2 倍を超えてはいけないという制限が適用されます。この方法を使用すると、エンコードされたベクトルの形状は変更されず、ゲインまたは振幅のみが変更されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-8--Bitstream-Definition">
3.8. Bitstream Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8. ビットストリームの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The total number of bits used to describe one frame of 20 ms speech is 304, which fits in 38 bytes and results in a bit rate of 15.20 kbit/s. For the case of a frame length of 30 ms speech, the total number of bits used is 400, which fits in 50 bytes and results in a bit rate of 13.33 kbit/s. In the bitstream definition, the bits are distributed into three classes according to their bit error or loss sensitivity. The most sensitive bits (class 1) are placed first in the bitstream for each frame. The less sensitive bits (class 2) are placed after the class 1 bits. The least sensitive bits (class 3) are placed at the end of the bitstream for each frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
20 ミリ秒の音声の 1 フレームを記述するために使用されるビットの総数は 304 で、これは 38 バイトに収まり、ビット レートは 15.20 kbit/s になります。フレーム長が 30 ms の音声の場合、使用されるビットの総数は 400 で、50 バイトに収まり、ビット レートは 13.33 kbit/s になります。ビットストリーム定義では、ビットはビットエラーまたは損失感度に応じて 3 つのクラスに分類されます。最も機密性の高いビット (クラス 1) が各フレームのビットストリームの最初に配置されます。機密性の低いビット (クラス 2) は、クラス 1 ビットの後に配置されます。最も機密性の低いビット (クラス 3) は、各フレームのビットストリームの最後に配置されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the 20/30 ms frame length cases for each class, the following hold true: The class 1 bits occupy a total of 6/8 bytes (48/64 bits), the class 2 bits occupy 8/12 bytes (64/96 bits), and the class 3 bits occupy 24/30 bytes (191/239 bits). This distribution of the bits enables the use of uneven level protection (ULP) as is exploited in the payload format definition for iLBC [1]. The detailed bit allocation is shown in the table below. When a quantization index is distributed between more classes, the more significant bits belong to the lowest class.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各クラスのフレーム長が 20/30 ミリ秒の場合、次のことが当てはまります。クラス 1 ビットは合計 6/8 バイト (48/64 ビット) を占有し、クラス 2 ビットは 8/12 バイト (64/96 ビット) を占有します。ビット）、クラス 3 ビットは 24/30 バイト（191/239 ビット）を占有します。このビットの分配により、iLBC [1] のペイロード フォーマット定義で活用されているような、不均等レベル保護 (ULP) の使用が可能になります。詳細なビット割り当てを次の表に示します。量子化インデックスがより多くのクラスに分散される場合、より重要なビットは最下位のクラスに属します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bitstream structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビットストリーム構造:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ------------------------------------------------------------------+
   Parameter                         |       Bits Class &lt;1,2,3&gt;      |
                                     |  20 ms frame  |  30 ms frame  |
   ----------------------------------+---------------+---------------+
                            Split 1  |   6 &lt;6,0,0&gt;   |   6 &lt;6,0,0&gt;   |
                   LSF 1    Split 2  |   7 &lt;7,0,0&gt;   |   7 &lt;7,0,0&gt;   |
   LSF                      Split 3  |   7 &lt;7,0,0&gt;   |   7 &lt;7,0,0&gt;   |
                   ------------------+---------------+---------------+
                            Split 1  | NA (Not Appl.)|   6 &lt;6,0,0&gt;   |
                   LSF 2    Split 2  |      NA       |   7 &lt;7,0,0&gt;   |
                            Split 3  |      NA       |   7 &lt;7,0,0&gt;   |
                   ------------------+---------------+---------------+
                   Sum               |  20 &lt;20,0,0&gt;  |  40 &lt;40,0,0&gt;  |
   ----------------------------------+---------------+---------------+
   Block Class                       |   2 &lt;2,0,0&gt;   |   3 &lt;3,0,0&gt;   |
   ----------------------------------+---------------+---------------+
   Position 22 sample segment        |   1 &lt;1,0,0&gt;   |   1 &lt;1,0,0&gt;   |
   ----------------------------------+---------------+---------------+
   Scale Factor State Coder          |   6 &lt;6,0,0&gt;   |   6 &lt;6,0,0&gt;   |
   ----------------------------------+---------------+---------------+
                   Sample 0          |   3 &lt;0,1,2&gt;   |   3 &lt;0,1,2&gt;   |
   Quantized       Sample 1          |   3 &lt;0,1,2&gt;   |   3 &lt;0,1,2&gt;   |
   Residual           :              |   :    :      |   :    :      |
   State              :              |   :    :      |   :    :      |
   Samples            :              |   :    :      |   :    :      |
                   Sample 56         |   3 &lt;0,1,2&gt;   |   3 &lt;0,1,2&gt;   |
                   Sample 57         |      NA       |   3 &lt;0,1,2&gt;   |
                   ------------------+---------------+---------------+
                   Sum               | 171 &lt;0,57,114&gt;| 174 &lt;0,58,116&gt;|
   ----------------------------------+---------------+---------------+
                            Stage 1  |   7 &lt;6,0,1&gt;   |   7 &lt;4,2,1&gt;   |
   CB for 22/23             Stage 2  |   7 &lt;0,0,7&gt;   |   7 &lt;0,0,7&gt;   |
   sample block             Stage 3  |   7 &lt;0,0,7&gt;   |   7 &lt;0,0,7&gt;   |
                   ------------------+---------------+---------------+
                   Sum               |  21 &lt;6,0,15&gt;  |  21 &lt;4,2,15&gt;  |
   ----------------------------------+---------------+---------------+
                            Stage 1  |   5 &lt;2,0,3&gt;   |   5 &lt;1,1,3&gt;   |
   Gain for 22/23           Stage 2  |   4 &lt;1,1,2&gt;   |   4 &lt;1,1,2&gt;   |
   sample block             Stage 3  |   3 &lt;0,0,3&gt;   |   3 &lt;0,0,3&gt;   |
                   ------------------+---------------+---------------+
                   Sum               |  12 &lt;3,1,8&gt;   |  12 &lt;2,2,8&gt;   |
   ----------------------------------+---------------+---------------+
                            Stage 1  |   8 &lt;7,0,1&gt;   |   8 &lt;6,1,1&gt;   |
               sub-block 1  Stage 2  |   7 &lt;0,0,7&gt;   |   7 &lt;0,0,7&gt;   |
                            Stage 3  |   7 &lt;0,0,7&gt;   |   7 &lt;0,0,7&gt;   |
                   ------------------+---------------+---------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            Stage 1  |   8 &lt;0,0,8&gt;   |   8 &lt;0,7,1&gt;   |
               sub-block 2  Stage 2  |   8 &lt;0,0,8&gt;   |   8 &lt;0,0,8&gt;   |
   Indices                  Stage 3  |   8 &lt;0,0,8&gt;   |   8 &lt;0,0,8&gt;   |
   for CB          ------------------+---------------+---------------+
   sub-blocks               Stage 1  |      NA       |   8 &lt;0,7,1&gt;   |
               sub-block 3  Stage 2  |      NA       |   8 &lt;0,0,8&gt;   |
                            Stage 3  |      NA       |   8 &lt;0,0,8&gt;   |
                   ------------------+---------------+---------------+
                            Stage 1  |      NA       |   8 &lt;0,7,1&gt;   |
               sub-block 4  Stage 2  |      NA       |   8 &lt;0,0,8&gt;   |
                            Stage 3  |      NA       |   8 &lt;0,0,8&gt;   |
                   ------------------+---------------+---------------+
                   Sum               |  46 &lt;7,0,39&gt;  |  94 &lt;6,22,66&gt; |
   ----------------------------------+---------------+---------------+
                            Stage 1  |   5 &lt;1,2,2&gt;   |   5 &lt;1,2,2&gt;   |
               sub-block 1  Stage 2  |   4 &lt;1,1,2&gt;   |   4 &lt;1,2,1&gt;   |
                            Stage 3  |   3 &lt;0,0,3&gt;   |   3 &lt;0,0,3&gt;   |
                   ------------------+---------------+---------------+
                            Stage 1  |   5 &lt;1,1,3&gt;   |   5 &lt;0,2,3&gt;   |
               sub-block 2  Stage 2  |   4 &lt;0,2,2&gt;   |   4 &lt;0,2,2&gt;   |
                            Stage 3  |   3 &lt;0,0,3&gt;   |   3 &lt;0,0,3&gt;   |
   Gains for       ------------------+---------------+---------------+
   sub-blocks               Stage 1  |      NA       |   5 &lt;0,1,4&gt;   |
               sub-block 3  Stage 2  |      NA       |   4 &lt;0,1,3&gt;   |
                            Stage 3  |      NA       |   3 &lt;0,0,3&gt;   |
                   ------------------+---------------+---------------+
                            Stage 1  |      NA       |   5 &lt;0,1,4&gt;   |
               sub-block 4  Stage 2  |      NA       |   4 &lt;0,1,3&gt;   |
                            Stage 3  |      NA       |   3 &lt;0,0,3&gt;   |
                   ------------------+---------------+---------------+
                   Sum               |  24 &lt;3,6,15&gt;  |  48 &lt;2,12,34&gt; |
   ----------------------------------+---------------+---------------+
   Empty frame indicator             |   1 &lt;0,0,1&gt;   |   1 &lt;0,0,1&gt;   |
   -------------------------------------------------------------------
   SUM                                 304 &lt;48,64,192&gt; 400 &lt;64,96,240&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 3.2. The bitstream definition for iLBC for both the 20 ms frame size mode and the 30 ms frame size mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表3.220 ms フレーム サイズ モードと 30 ms フレーム サイズ モードの両方の iLBC のビットストリーム定義。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When packetized into the payload, the bits MUST be sorted as follows: All the class 1 bits in the order (from top to bottom) as specified in the table, all the class 2 bits (from top to bottom), and all the class 3 bits in the same sequential order. The last bit, the empty frame indicator, SHOULD be set to zero by the encoder. If this bit is set to 1 the decoder SHOULD treat the data as a lost frame. For example, this bit can be set to 1 to indicate lost frame for file storage format, as in [1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ペイロードにパケット化されるとき、ビットは次のようにソートされなければなりません。表で指定されている順序で (上から下へ) クラス 1 のすべてのビット、(上から下へ) クラス 2 のすべてのビット、およびクラスのすべてのビット同じ順序の 3 ビット。最後のビットである空フレームインジケーターは、エンコーダーによってゼロに設定されるべきです(SHOULD)。このビットが 1 に設定されている場合、デコーダはデータを失われたフレームとして扱うべきです(SHOULD)。たとえば、[1] のように、このビットを 1 に設定すると、ファイル ストレージ フォーマットのフレームが失われたことを示すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Decoder-Principles">
4. Decoder Principles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. デコーダの原理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the principles of each component of the decoder algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、デコーダ アルゴリズムの各コンポーネントの原理について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              +-------------+    +--------+    +---------------+
   payload -&gt; | 1. Get para | -&gt; | 2. LPC | -&gt; | 3. Sc Dequant | -&gt;
              +-------------+    +--------+    +---------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              +-------------+    +------------------+
           -&gt; | 4. Mem setup| -&gt; | 5. Construct res |-------&gt;
           |  +-------------+    +-------------------   |
           ---------&lt;-----------&lt;-----------&lt;------------
                     Sub-frame 0...2/4 (20 ms/30 ms)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              +----------------+    +----------+
           -&gt; | 6. Enhance res | -&gt; | 7. Synth | ------------&gt;
              +----------------+    +----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              +-----------------+
           -&gt; | 8. Post Process | ----------------&gt; decoded speech
              +-----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 4.1. Flow chart of the iLBC decoder. If a frame was lost, steps 1 to 5 SHOULD be replaced by a PLC algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図4.1。iLBC デコーダのフローチャート。フレームが失われた場合は、ステップ 1 ～ 5 を PLC アルゴリズムに置き換えるべきです (SHOULD)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Extract the parameters from the bitstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. ビットストリームからパラメータを抽出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Decode the LPC and interpolate (section 4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. LPC をデコードして補間します (セクション 4.1)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Construct the 57/58-sample start state (section 4.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 57/58 サンプルの開始状態を構築します (セクション 4.2)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Set up the memory by using data from the decoded residual. This memory is used for codebook construction. For blocks preceding the start state, both the decoded residual and the target are time reversed. Sub-frames are decoded in the same order as they were encoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. デコードされた残差からのデータを使用してメモリをセットアップします。このメモリはコードブックの構築に使用されます。開始状態に先行するブロックの場合、デコードされた残差とターゲットの両方が時間反転されます。サブフレームは、エンコードされたときと同じ順序でデコードされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Construct the residuals of this sub-frame (gain[0]*cbvec[0] + gain[1]*cbvec[1] + gain[2]*cbvec[2]). Repeat 4 and 5 until the residual of all sub-blocks has been constructed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. このサブフレームの残差を構築します (gain[0]*cbvec[0]、gain[1]*cbvec[1]、gain[2]*cbvec[2])。すべてのサブブロックの残差が構築されるまで、4 と 5 を繰り返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Enhance the residual with the post filter (section 4.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. ポストフィルターを使用して残差を強調します (セクション 4.6)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Synthesis of the residual (section 4.7).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. 残差の合成 (セクション 4.7)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Post process with HP filter, if desired (section 4.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. 必要に応じて、HP フィルターを使用した後処理を行います (セクション 4.8)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--LPC-Filter-Reconstruction">
4.1. LPC Filter Reconstruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. LPC フィルターの再構築
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoding of the LP filter parameters is very straightforward. For a set of three/six indices, the corresponding LSF vector(s) are found by simple table lookup. For each of the LSF vectors, the three split vectors are concatenated to obtain qlsf1 and qlsf2, respectively (in the 20 ms mode only one LSF vector, qlsf, is constructed). The next step is the stability check described in section 3.2.5 followed by the interpolation scheme described in section 3.2.6 (3.2.7 for 20 ms frames). The only difference is that only the quantized LSFs are known at the decoder, and hence the unquantized LSFs are not processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LP フィルター パラメーターのデコードは非常に簡単です。3 つまたは 6 つのインデックスのセットの場合、対応する LSF ベクトルは単純なテーブル検索によって見つかります。各 LSF ベクトルについて、3 つの分割ベクトルが連結されて、それぞれ qlsf1 と qlsf2 が得られます (20 ms モードでは、1 つの LSF ベクトル qlsf のみが構築されます)。次のステップは、セクション 3.2.5 で説明されている安定性チェックであり、その後、セクション 3.2.6 (20 ms フレームの場合は 3.2.7) で説明されている補間スキームが続きます。唯一の違いは、量子化された LSF のみがデコーダで認識されるため、量子化されていない LSF は処理されないことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reference implementation of the LPC filter reconstruction is given in Appendix A.36.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LPC フィルタ再構成の参照実装は、付録 A.36 に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Start-State-Reconstruction">
4.2. Start State Reconstruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 状態の再構築を開始する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The scalar encoded STATE_SHORT_LEN=58 (STATE_SHORT_LEN=57 in the 20 ms mode) state samples are reconstructed by 1) forming a set of samples (by table lookup) from the index stream idxVec[n], 2) multiplying the set with 1/scal=(10^qmax)/4.5, 3) time reversing the 57/58 samples, 4) filtering the time reversed block with the dispersion (all-pass) filter used in the encoder (as described in section 3.5.2); this compensates for the phase distortion of the earlier filter operation, and 5 reversing the 57/58 samples from the previous step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スカラー エンコードされた STATE_SHORT_LEN=58 (20 ミリ秒モードでは STATE_SHORT_LEN=57) 状態サンプルは、1) インデックス ストリーム idxVec[n] から (テーブル ルックアップによって) サンプルのセットを形成し、2) セットに 1/ を乗算することによって再構築されます。scal=(10^qmax)/4.5、3) 57/58 サンプルの時間を反転、4) エンコーダで使用される分散 (オールパス) フィルターで時間反転ブロックをフィルター処理 (セクション 3.5.2 で説明)。これにより、前のフィルタ操作の位相歪みが補償され、前のステップからの 57/58 サンプルが反転されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
in(0..(STATE_SHORT_LEN-1)) = time reversed samples from table look-up, idxVecDec((STATE_SHORT_LEN-1)..0)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
in(0..(STATE_SHORT_LEN-1)) = テーブルルックアップからの時間反転サンプル、idxVecDec((STATE_SHORT_LEN-1)..0)
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   in(STATE_SHORT_LEN..(2*STATE_SHORT_LEN-1)) = 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Pk(z) = A~rk(z)/A~k(z), where
                                  ___
                                  \
   A~rk(z)= z^(-LPC_FILTERORDER) + &gt; a~ki*z^(i-(LPC_FILTERORDER-1))
                                  /__
                              i=0...(LPC_FILTERORDER-1)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and A~k(z) is taken from the block where the start state begins
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A~k(z) は開始状態が始まるブロックから取得されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   in -&gt; Pk(z) -&gt; filtered
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   out(k) = filtered(STATE_SHORT_LEN-1-k) +
                           filtered(2*STATE_SHORT_LEN-1-k),
                                         k=0..(STATE_SHORT_LEN-1)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remaining 23/22 samples in the state are reconstructed by the same adaptive codebook technique described in section 4.3. The location bit determines whether these are the first or the last 23/22 samples of the 80-sample state vector. If the remaining 23/22 samples are the first samples, then the scalar encoded STATE_SHORT_LEN state samples are time-reversed before initialization of the adaptive codebook memory vector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態内の残りの 23/22 サンプルは、セクション 4.3 で説明されているのと同じ適応コードブック手法によって再構築されます。位置ビットは、これらが 80 サンプルの状態ベクトルの最初の 23/22 サンプルであるか最後の 23/22 サンプルであるかを決定します。残りの 23/22 サンプルが最初のサンプルである場合、スカラー エンコードされた STATE_SHORT_LEN 状態サンプルは、適応コードブック メモリ ベクトルの初期化前に時間反転されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reference implementation of the start state reconstruction is given in Appendix A.44.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
開始状態再構築の参照実装は、付録 A.44 に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--Excitation-Decoding-Loop">
4.3. Excitation Decoding Loop
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 励起デコードループ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoding of the LPC excitation vector proceeds in the same order in which the residual was encoded at the encoder. That is, after the decoding of the entire 80-sample state vector, the forward sub-blocks (corresponding to samples occurring after the state vector samples) are decoded, and then the backward sub-blocks (corresponding to samples occurring before the state vector) are decoded, resulting in a fully decoded block of excitation signal samples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LPC 励起ベクトルの復号化は、残差がエンコーダで符号化されたのと同じ順序で進行します。つまり、80 サンプルの状態ベクトル全体を復号した後、前方サブブロック (状態ベクトル サンプルの後に発生するサンプルに対応) が復号され、次に後方サブブロック (状態ベクトルの前に発生するサンプルに対応) が復号されます。) がデコードされ、励起信号サンプルの完全にデコードされたブロックが得られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In particular, each sub-block is decoded by using the multistage adaptive codebook decoding module described in section 4.4. This module relies upon an adaptive codebook memory constructed before each run of the adaptive codebook decoding. The construction of the adaptive codebook memory in the decoder is identical to the method outlined in section 3.6.3, except that it is done on the codebook memory without perceptual weighting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に、各サブブロックは、セクション 4.4 で説明されている多段階適応コードブック復号モジュールを使用して復号されます。このモジュールは、適応コードブック復号化の各実行前に構築された適応コードブック メモリに依存します。デコーダ内の適応コードブック メモリの構築は、知覚的重み付けを行わずにコードブック メモリ上で行われることを除いて、セクション 3.6.3 で概説した方法と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the initial forward sub-block, the last STATE_LEN=80 samples of the length CB_LMEM=147 adaptive codebook memory are filled with the samples of the state vector. For subsequent forward sub-blocks, the first SUBL=40 samples of the adaptive codebook memory are discarded, the remaining samples are shifted by SUBL samples toward the beginning of the vector, and the newly decoded SUBL=40 samples are placed at the end of the adaptive codebook memory. For backward sub-blocks, the construction is similar, except that every vector of samples involved is first time reversed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の前方サブブロックでは、長さ CB_LMEM=147 の適応コードブック メモリの最後の STATE_LEN=80 サンプルが状態ベクトルのサンプルで満たされます。後続の前方サブブロックでは、適応コードブック メモリの最初の SUBL=40 サンプルが破棄され、残りのサンプルがベクトルの先頭に向かって SUBL サンプルずつシフトされ、新しくデコードされた SUBL=40 サンプルがベクトルの最後に配置されます。適応コードブックメモリ。逆方向サブブロックの場合、関係するサンプルのすべてのベクトルが最初に反転されることを除いて、構築は同様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reference implementation of the excitation decoding loop is found in Appendix A.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
励起復号化ループの参照実装は付録 A.5 にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4--Multistage-Adaptive-Codebook-Decoding">
4.4. Multistage Adaptive Codebook Decoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 多段階適応コードブック復号化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Multistage Adaptive Codebook Decoding module is used at both the sender (encoder) and the receiver (decoder) ends to produce a synthetic signal in the residual domain that is eventually used to produce synthetic speech. The module takes the index values used to construct vectors that are scaled and summed together to produce a synthetic signal that is the output of the module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチステージ適応コードブック復号モジュールは、送信側 (エンコーダー) と受信側 (デコーダー) の両方で使用され、最終的に合成音声の生成に使用される残差領域で合成信号を生成します。モジュールは、スケーリングおよび合計されてモジュールの出力である合成信号を生成するベクトルを構築するために使用されるインデックス値を取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4-1--Construction-of-the-Decoded-Excitation-Signal">
4.4.1. Construction of the Decoded Excitation Signal
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1. デコードされた励起信号の構築
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The unpacked index values provided at the input to the module are references to extended codebooks, which are constructed as described in section 3.6.3, except that they are based on the codebook memory without the perceptual weighting. The unpacked three indices are used to look up three codebook vectors. The unpacked three gain indices are used to decode the corresponding 3 gains. In this decoding, the successive rescaling, as described in section 3.6.4.2, is applied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モジュールへの入力で提供されるアンパックされたインデックス値は拡張コードブックへの参照であり、知覚的重み付けのないコードブック メモリに基づいている点を除き、セクション 3.6.3 で説明したように構築されます。アンパックされた 3 つのインデックスは、3 つのコードブック ベクトルを検索するために使用されます。アンパックされた 3 つのゲイン インデックスは、対応する 3 つのゲインをデコードするために使用されます。このデコードでは、セクション 3.6.4.2 で説明されているように、逐次再スケーリングが適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reference implementation of the adaptive codebook decoding is listed in Appendix A.32.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
適応コードブック復号化の参照実装は、付録 A.32 にリストされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-5--Packet-Loss-Concealment">
4.5. Packet Loss Concealment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. パケットロスの隠蔽
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If packet loss occurs, the decoder receives a signal saying that information regarding a block is lost. For such blocks it is RECOMMENDED to use a Packet Loss Concealment (PLC) unit to create a decoded signal that masks the effect of that packet loss. In the following we will describe an example of a PLC unit that can be used with the iLBC codec. As the PLC unit is used only at the decoder, the PLC unit does not affect interoperability between implementations. Other PLC implementations MAY therefore be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット損失が発生すると、デコーダはブロックに関する情報が失われたことを示す信号を受信します。このようなブロックの場合、パケット損失隠蔽 (PLC) ユニットを使用して、パケット損失の影響をマスクするデコードされた信号を作成することが推奨されます。以下に、iLBC コーデックで使用できる PLC ユニットの例を説明します。PLC ユニットはデコーダでのみ使用されるため、PLC ユニットは実装間の相互運用性に影響を与えません。したがって、他の PLC 実装を使用してもよい(MAY)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PLC described operates on the LP filters and the excitation signals and is based on the following principles:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明した PLC は LP フィルターと励起信号で動作し、次の原理に基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-5-1--Block-Received-Correctly-and-Previous-Block-Also-Received">
4.5.1. Block Received Correctly and Previous Block Also Received
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.1. ブロックは正しく受信され、前のブロックも受信されました
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the block is received correctly, the PLC only records state information of the current block that can be used in case the next block is lost. The LP filter coefficients for each sub-block and the entire decoded excitation signal are all saved in the decoder state structure. All of this information will be needed if the following block is lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロックが正しく受信された場合、PLC は、次のブロックが失われた場合に使用できる現在のブロックの状態情報のみを記録します。各サブブロックの LP フィルター係数と復号化された励振信号全体は、すべてデコーダー状態構造に保存されます。次のブロックが失われた場合、この情報はすべて必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-5-2--Block-Not-Received">
4.5.2. Block Not Received
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2. ブロックが受信されませんでした
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the block is not received, the block substitution is based on a pitch-synchronous repetition of the excitation signal, which is filtered by the last LP filter of the previous block. The previous block&#39;s information is stored in the decoder state structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロックが受信されない場合、ブロック置換は、前のブロックの最後の LP フィルターによってフィルター処理された励起信号のピッチ同期繰り返しに基づいて行われます。前のブロックの情報はデコーダ状態構造体に保存されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A correlation analysis is performed on the previous block&#39;s excitation signal in order to detect the amount of pitch periodicity and a pitch value. The correlation measure is also used to decide on the voicing level (the degree to which the previous block&#39;s excitation was a voiced or roughly periodic signal). The excitation in the previous block is used to create an excitation for the block to be substituted, such that the pitch of the previous block is maintained. Therefore, the new excitation is constructed in a pitch-synchronous manner. In order to avoid a buzzy-sounding substituted block, a random excitation is mixed with the new pitch periodic excitation, and the relative use of the two components is computed from the correlation measure (voicing level).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピッチ周期性の量とピッチ値を検出するために、前のブロックの励起信号に対して相関分析が実行されます。相関測定は、有声レベル (前のブロックの励起が有声信号またはほぼ周期的な信号であった程度) を決定するためにも使用されます。前のブロックの励振は、前のブロックのピッチが維持されるように、置換されるブロックの励振を作成するために使用されます。したがって、新しい励振はピッチ同期方式で構築されます。ブンジーなサウンドの置換ブロックを回避するために、ランダムな励振が新しいピッチ周期的な励振と混合され、2 つの成分の相対的な使用が相関尺度 (有声レベル) から計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the block to be substituted, the newly constructed excitation signal is then passed through the LP filter to produce the speech that will be substituted for the lost block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロックを置き換えるために、新しく構築された励起信号が LP フィルターを通過して、失われたブロックの代わりとなる音声が生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For several consecutive lost blocks, the packet loss concealment continues in a similar manner. The correlation measure of the last block received is still used along with the same pitch value. The LP filters of the last block received are also used again. The energy of the substituted excitation for consecutive lost blocks is decreased, leading to a dampened excitation, and therefore to dampened speech.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの連続した失われたブロックについて、パケット損失の隠蔽は同様の方法で継続されます。最後に受信したブロックの相関尺度は、同じピッチ値とともに引き続き使用されます。最後に受信したブロックの LP フィルターも再度使用されます。連続的に失われたブロックの代替励起のエネルギーは減少し、励起の減衰につながり、したがって音声の減衰につながります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-5-3--Block-Received-Correctly-When-Previous-Block-Not-Received">
4.5.3. Block Received Correctly When Previous Block Not Received
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.3. 前のブロックが受信されなかった場合でもブロックは正しく受信されました
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the case in which a block is received correctly when the previous block was not, the correctly received block&#39;s directly decoded speech (based solely on the received block) is not used as the actual output. The reason for this is that the directly decoded speech does not necessarily smoothly merge into the synthetic speech generated for the previous lost block. If the two signals are not smoothly merged, an audible discontinuity is accidentally produced. Therefore, a correlation analysis between the two blocks of excitation signal (the excitation of the previous concealed block and that of the current received block) is performed to find the best phase match. Then a simple overlap-add procedure is performed to merge the previous excitation smoothly into the current block&#39;s excitation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前のブロックが正しく受信されなかったときにブロックが正しく受信された場合、正しく受信されたブロックの直接デコードされた音声 (受信ブロックのみに基づく) は実際の出力として使用されません。その理由は、直接デコードされた音声が、以前の失われたブロックに対して生成された合成音声に必ずしもスムーズにマージするとは限らないためです。2 つの信号がスムーズにマージされないと、誤って聞こえる不連続性が発生します。したがって、励起信号の 2 つのブロック (前の隠蔽されたブロックの励起と現在の受信ブロックの励起) 間の相関分析が実行され、最良の位相一致が見つかります。次に、単純なオーバーラップ加算手順が実行され、前の励起が現在のブロックの励起にスムーズにマージされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The exact implementation of the packet loss concealment does not influence interoperability of the codec.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット損失隠蔽の正確な実装は、コーデックの相互運用性に影響しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reference implementation of the packet loss concealment is suggested in Appendix A.14. Exact compliance with this suggested algorithm is not needed for a reference implementation to be fully compatible with the overall codec specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット損失隠蔽のリファレンス実装は、付録 A.14 で提案されています。リファレンス実装がコーデック仕様全体と完全に互換性を持つためには、この推奨アルゴリズムに厳密に準拠する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6--Enhancement">
4.6. Enhancement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. 強化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoder contains an enhancement unit that operates on the reconstructed excitation signal. The enhancement unit increases the perceptual quality of the reconstructed signal by reducing the speech-correlated noise in the voiced speech segments. Compared to traditional postfilters, the enhancer has an advantage in that it can only modify the excitation signal slightly. This means that there is no risk of over enhancement. The enhancer works very similarly for both the 20 ms frame size mode and the 30 ms frame size mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコーダには、再構成された励起信号に作用する拡張ユニットが含まれています。強化ユニットは、有声音声セグメント内の音声相関ノイズを低減することにより、再構成された信号の知覚品質を向上させます。従来のポストフィルターと比較して、エンハンサーには励起信号をわずかに変更するだけであるという利点があります。これは、過剰な強化のリスクがないことを意味します。エンハンサーは、20 ms フレーム サイズ モードと 30 ms フレーム サイズ モードの両方で非常に同様に機能します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the mode with 20 ms frame size, the enhancer uses a memory of six 80-sample excitation blocks prior in time plus the two new 80-sample excitation blocks. For each block of 160 new unenhanced excitation samples, 160 enhanced excitation samples are produced. The enhanced excitation is 40-sample delayed compared to the unenhanced excitation, as the enhancer algorithm uses lookahead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
20 ms フレーム サイズのモードの場合、エンハンサーは、時間的に前の 6 つの 80 サンプル励起ブロックのメモリと、2 つの新しい 80 サンプル励起ブロックのメモリを使用します。160 個の新しい非強化励起サンプルのブロックごとに、160 個の強化励起サンプルが生成されます。エンハンサー アルゴリズムが先読みを使用するため、強化された励起は、強化されていない励起と比較して 40 サンプル遅延します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the mode with 30 ms frame size, the enhancer uses a memory of five 80-sample excitation blocks prior in time plus the three new 80-sample excitation blocks. For each block of 240 new unenhanced excitation samples, 240 enhanced excitation samples are produced. The enhanced excitation is 80-sample delayed compared to the unenhanced excitation, as the enhancer algorithm uses lookahead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレーム サイズが 30 ms のモードの場合、エンハンサーは、時間的に前の 5 つの 80 サンプル励起ブロックと、3 つの新しい 80 サンプル励起ブロックのメモリを使用します。240 個の新しい非強化励起サンプルのブロックごとに、240 個の強化励起サンプルが生成されます。エンハンサー アルゴリズムが先読みを使用するため、強化された励起は、強化されていない励起と比較して 80 サンプル遅延します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Outline of Enhancer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンハンサーの概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The speech enhancement unit operates on sub-blocks of 80 samples, which means that there are two/three 80 sample sub-blocks per frame. Each of these two/three sub-blocks is enhanced separately, but in an analogous manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
音声強調ユニットは 80 サンプルのサブブロックで動作します。これは、フレームごとに 2 つまたは 3 つの 80 サンプルのサブブロックがあることを意味します。これら 2 つまたは 3 つのサブブロックはそれぞれ個別に強化されますが、同様の方法で強化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   unenhanced residual
           |
           |   +---------------+    +--------------+
           +-&gt; | 1. Pitch Est  | -&gt; | 2. Find PSSQ | --------&gt;
               +---------------+  | +--------------+
                                  +-----&lt;-------&lt;------&lt;--+
               +------------+         enh block 0..1/2    |
            -&gt; | 3. Smooth  |                             |
               +------------+                             |
                 \                                        |
                 /\                                       |
                /  \   Already                            |
               / 4. \-----------&gt;-----------&gt;-----------+ |
               \Crit/ Fulfilled                         | |
                \? /                                    v |
                 \/                                     | |
                  \  +-----------------+    +---------+ | |
              Not +-&gt;| 5. Use Constr.  | -&gt; | 6. Mix  | -----&gt;
           Fulfilled +-----------------+    +---------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            ---------------&gt; enhanced residual
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 4.2. Flow chart of the enhancer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図4.2。エンハンサーのフローチャート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Pitch estimation of each of the two/three new 80-sample blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 2 つまたは 3 つの新しい 80 サンプル ブロックのそれぞれのピッチ推定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Find the pitch-period-synchronous sequence n (for block k) by a search around the estimated pitch value. Do this for n=1,2,3, -1,-2,-3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 推定されたピッチ値の周囲を探索することによって、ピッチ周期同期シーケンス n (ブロック k の場合) を見つけます。これを n=1,2,3, -1,-2,-3 に対して行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Calculate the smoothed residual generated by the six pitch-period-synchronous sequences from prior step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 前のステップからの 6 つのピッチ周期同期シーケンスによって生成された平滑化された残差を計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Check if the smoothed residual satisfies the criterion (section 4.6.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 平滑化された残差が基準 (セクション 4.6.4) を満たしているかどうかを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Use constraint to calculate mixing factor (section 4.6.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 制約を使用して混合係数を計算します (セクション 4.6.5)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Mix smoothed signal with unenhanced residual (pssq(n) n=0).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 平滑化された信号と強化されていない残差を混合します (pssq(n) n=0)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The main idea of the enhancer is to find three 80 sample blocks before and three 80-sample blocks after the analyzed unenhanced sub-block and to use these to improve the quality of the excitation in that sub-block. The six blocks are chosen so that they have the highest possible correlation with the unenhanced sub-block that is being enhanced. In other words, the six blocks are pitch-period-synchronous sequences to the unenhanced sub-block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンハンサーの主なアイデアは、分析された非エンハンス サブブロックの前に 3 つの 80 サンプル ブロックとその後に 3 つの 80 サンプル ブロックを見つけ、これらを使用してそのサブブロックの励起の品質を向上させることです。6 つのブロックは、強化されている未強化のサブブロックとの相関が最も高くなるように選択されます。換言すれば、６つのブロックは、非強化サブブロックに対するピッチ周期同期シーケンスである。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A linear combination of the six pitch-period-synchronous sequences is calculated that approximates the sub-block. If the squared error between the approximation and the unenhanced sub-block is small enough, the enhanced residual is set equal to this approximation. For the cases when the squared error criterion is not fulfilled, a linear combination of the approximation and the unenhanced residual forms the enhanced residual.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブブロックを近似する 6 つのピッチ周期同期シーケンスの線形結合が計算されます。近似値と非強化サブブロック間の二乗誤差が十分に小さい場合、強化された残差はこの近似値に等しく設定されます。二乗誤差基準が満たされない場合、近似と非強化残差の線形結合により強化残差が形成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6-1--Estimating-the-Pitch">
4.6.1. Estimating the Pitch
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. ピッチの推定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pitch estimates are needed to determine the locations of the pitch-period-synchronous sequences in a complexity-efficient way. For each of the new two/three sub-blocks, a pitch estimate is calculated by finding the maximum correlation in the range from lag 20 to lag 120. These pitch estimates are used to narrow down the search for the best possible pitch-period-synchronous sequences.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピッチ推定は、複雑さを効率的に行う方法でピッチ周期同期シーケンスの位置を決定するために必要である。新しい 2 つまたは 3 つのサブブロックのそれぞれについて、ラグ 20 からラグ 120 までの範囲で最大の相関を見つけることによってピッチ推定値が計算されます。これらのピッチ推定値は、可能な限り最良のピッチ周期の検索を絞り込むために使用されます。同期シーケンス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6-2--Determination-of-the-Pitch-Synchronous-Sequences">
4.6.2. Determination of the Pitch-Synchronous Sequences
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2. ピッチ同期シーケンスの決定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receiving the pitch estimates from the prior step, the enhancer analyzes and enhances one 80-sample sub-block at a time. The pitch-period-synchronous-sequences pssq(n) can be viewed as vectors of length 80 samples each shifted n*lag samples from the current sub-block. The six pitch-period-synchronous-sequences, pssq(-3) to pssq(-1) and pssq(1) to pssq(3), are found one at a time by the steps below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前のステップからピッチ推定を受け取ると、エンハンサーは一度に 1 つの 80 サンプルのサブブロックを分析してエンハンスします。ピッチ周期同期シーケンス pssq(n) は、それぞれが現在のサブブロックから n*lag サンプルだけシフトされた長さ 80 サンプルのベクトルとして見ることができます。6 つのピッチ周期同期シーケンス pssq(-3) から pssq(-1) および pssq(1) から pssq(3) は、以下の手順で一度に 1 つずつ見つかります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1) Calculate the estimate of the position of the pssq(n). For pssq(n) in front of pssq(0) (n &gt; 0), the location of the pssq(n) is estimated by moving one pitch estimate forward in time from the exact location of pssq(n-1). Similarly, pssq(n) behind pssq(0) (n &lt; 0) is estimated by moving one pitch estimate backward in time from the exact location of pssq(n+1). If the estimated pssq(n) vector location is totally within the enhancer memory (Figure 4.3), steps 2, 3, and 4 are performed, otherwise the pssq(n) is set to zeros.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1) pssq(n) の位置の推定値を計算します。pssq(0) の前にある pssq(n) (n &gt; 0) の場合、pssq(n) の位置は、pssq(n-1) の正確な位置から時間的に 1 ピッチ推定値を前方に移動することによって推定されます。同様に、pssq(0) の後ろの pssq(n) (n &lt; 0) は、pssq(n 1) の正確な位置から時間的に 1 ピッチ推定値を後方に移動することによって推定されます。推定された pssq(n) ベクトルの位置が完全にエンハンサー メモリ内にある場合 (図 4.3)、ステップ 2、3、および 4 が実行されます。それ以外の場合、pssq(n) は 0 に設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2) Compute the correlation between the unenhanced excitation and vectors around the estimated location interval of pssq(n). The correlation is calculated in the interval estimated location +/- 2 samples. This results in five correlation values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2) 強化されていない励起と、pssq(n) の推定位置間隔の周囲のベクトルとの間の相関を計算します。相関は、推定位置 /- 2 サンプルの間隔で計算されます。これにより、5 つの相関値が得られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3) The five correlation values are upsampled by a factor of 4, by using four simple upsampling filters (MA filters with coefficients upsFilter1.. upsFilter4). Within these the maximum value is found, which specifies the best pitch-period with a resolution of a quarter of a sample.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3) 5 つの相関値は、4 つの単純なアップサンプリング フィルター (係数 upsFilter1.. upsFilter4 を持つ MA フィルター) を使用して、係数 4 でアップサンプリングされます。これらの中で最大値が見つかり、これはサンプルの 4 分の 1 の解像度で最適なピッチ周期を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      upsFilter1[7]={0.000000 0.000000 0.000000 1.000000
             0.000000 0.000000 0.000000}
      upsFilter2[7]={0.015625 -0.076904 0.288330 0.862061
            -0.106445 0.018799 -0.015625}
      upsFilter3[7]={0.023682 -0.124268 0.601563 0.601563
            -0.124268 0.023682 -0.023682}
      upsFilter4[7]={0.018799 -0.106445 0.862061 0.288330
            -0.076904 0.015625 -0.018799}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4) Generate the pssq(n) vector by upsampling of the excitation memory and extracting the sequence that corresponds to the lag delay that was calculated in prior step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4) 励起メモリをアップサンプリングし、前のステップで計算された遅れ遅延に対応するシーケンスを抽出することにより、pssq(n) ベクトルを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the steps above, all the pssq(n) can be found in an iterative manner, first moving backward in time from pssq(0) and then forward in time from pssq(0).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の手順により、最初に pssq(0) から時間的に後方に移動し、次に pssq(0) から時間的に順方向に移動して、すべての pssq(n) を反復的に見つけることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   0              159             319             479             639
   +---------------------------------------------------------------+
   |  -5   |  -4   |  -3   |  -2   |  -1   |   0   |   1   |   2   |
   +---------------------------------------------------------------+
                                               |pssq 0 |
                                          |pssq -1| |pssq 1 |
                                       |pssq -2|       |pssq 2 |
                                    |pssq -3|             |pssq 3 |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 4.3. Enhancement for 20 ms frame size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図4.3。20 ms フレーム サイズの拡張。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 4.3 depicts pitch-period-synchronous sequences in the enhancement of the first 80 sample block in the 20 ms frame size mode. The unenhanced signal input is stored in the last two sub-blocks (1 - 2), and the six other sub-blocks contain unenhanced residual prior-in-time. We perform the enhancement algorithm on two blocks of 80 samples, where the first of the two blocks consists of the last 40 samples of sub-block 0 and the first 40 samples of sub-block 1. The second 80-sample block consists of the last 40 samples of sub-block 1 and the first 40 samples of sub-block 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図 4.3 は、20 ms フレーム サイズ モードでの最初の 80 サンプル ブロックのエンハンスメントにおけるピッチ周期同期シーケンスを示しています。強化されていない信号入力は最後の 2 つのサブブロック (1 ～ 2) に格納され、他の 6 つのサブブロックには強化されていない残差の時間前が含まれます。80 サンプルの 2 つのブロックに対して拡張アルゴリズムを実行します。2 つのブロックのうち最初のブロックは、サブブロック 0 の最後の 40 サンプルとサブブロック 1 の最初の 40 サンプルで構成されます。2 番目の 80 サンプル ブロックは、サブブロック 1 の最後の 40 サンプルとサブブロック 2 の最初の 40 サンプル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   0              159             319             479             639
   +---------------------------------------------------------------+
   |  -4   |  -3   |  -2   |  -1   |   0   |   1   |   2   |   3   |
   +---------------------------------------------------------------+
                                   |pssq 0 |
                              |pssq -1| |pssq 1 |
                           |pssq -2|       |pssq 2 |
                        |pssq -3|             |pssq 3 |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 4.4. Enhancement for 30 ms frame size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図4.4。30 ms フレーム サイズの拡張。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 4.4 depicts pitch-period-synchronous sequences in the enhancement of the first 80-sample block in the 30 ms frame size mode. The unenhanced signal input is stored in the last three sub-blocks (1 - 3). The five other sub-blocks contain unenhanced residual prior-in-time. The enhancement algorithm is performed on the three 80 sample sub-blocks 0, 1, and 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図 4.4 は、30 ms フレーム サイズ モードでの最初の 80 サンプル ブロックのエンハンスメントにおけるピッチ周期同期シーケンスを示しています。強化されていない信号入力は、最後の 3 つのサブブロック (1 ～ 3) に保存されます。他の 5 つのサブブロックには、拡張されていない残差事前時間情報が含まれています。エンハンスメント アルゴリズムは、3 つの 80 サンプル サブブロック 0、1、2 に対して実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6-3--Calculation-of-the-Smoothed-Excitation">
4.6.3. Calculation of the Smoothed Excitation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3. 平滑化励振の計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A linear combination of the six pssq(n) (n!=0) form a smoothed approximation, z, of pssq(0). Most of the weight is put on the sequences that are close to pssq(0), as these are likely to be most similar to pssq(0). The smoothed vector is also rescaled so that the energy of z is the same as the energy of pssq(0).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6 つの pssq(n) (n!=0) の線形結合により、pssq(0) の平滑化された近似 z が形成されます。pssq(0) に最も似ている可能性が高いため、pssq(0) に近いシーケンスに重みの大部分が置かれます。平滑化されたベクトルも、z のエネルギーが pssq(0) のエネルギーと同じになるように再スケーリングされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ___
      \
   y = &gt; pssq(i) * pssq_weight(i)
      /__
   i=-3,-2,-1,1,2,3
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   pssq_weight(i) = 0.5*(1-cos(2*pi*(i+4)/(2*3+2)))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   z = C * y, where C = ||pssq(0)||/||y||
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6-4--Enhancer-Criterion">
4.6.4. Enhancer Criterion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.4. エンハンサー基準
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The criterion of the enhancer is that the enhanced excitation is not allowed to differ much from the unenhanced excitation. This criterion is checked for each 80-sample sub-block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンハンサーの基準は、強化された励起が強化されていない励起と大きく異なることが許容されないことです。この基準は、80 サンプルのサブブロックごとにチェックされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   e &lt; (b * ||pssq(0)||^2), where b=0.05 and   (Constraint 1)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   e = (pssq(0)-z)*(pssq(0)-z), and &#34;*&#34; means the dot product
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6-5--Enhancing-the-excitation">
4.6.5. Enhancing the excitation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.5. 興奮を高める
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the criterion in the previous section, it is clear that the excitation is not allowed to change much. The purpose of this constraint is to prevent the creation of an enhanced signal significantly different from the original signal. This also means that the constraint limits the numerical size of the errors that the enhancement procedure can make. That is especially important in unvoiced segments and background noise segments for which increased periodicity could lead to lower perceived quality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前のセクションの基準から、励起はあまり変更できないことが明らかです。この制約の目的は、元の信号とは大きく異なる強化された信号の作成を防ぐことです。これは、制約によって、拡張手順で発生する可能性のあるエラーの数値サイズが制限されることも意味します。これは、周期性の増加が知覚品質の低下につながる可能性がある無声セグメントや背景雑音セグメントでは特に重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the constraint in the prior section is not met, the enhanced residual is instead calculated through a constrained optimization by using the Lagrange multiplier technique. The new constraint is that
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前のセクションの制約が満たされない場合、強化された残差は代わりに、ラグランジュ乗算手法を使用した制約付き最適化を通じて計算されます。新しい制約は、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      e = (b * ||pssq(0)||^2)                     (Constraint 2)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We distinguish two solution regions for the optimization: 1) the region where the first constraint is fulfilled and 2) the region where the first constraint is not fulfilled and the second constraint must be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最適化のために 2 つのソリューション領域を区別します。1) 最初の制約が満たされる領域、2) 最初の制約が満たされず 2 番目の制約が使用されなければならない領域です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the first case, where the second constraint is not needed, the optimized re-estimated vector is simply z, the energy-scaled version of y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2 番目の制約が必要ない最初のケースでは、最適化された再推定ベクトルは単に z (y のエネルギースケール版) になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the second case, where the second constraint is activated and becomes an equality constraint, we have
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2 番目のケースでは、2 番目の制約がアクティブ化され、等価制約になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      z= A*y + B*pssq(0)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      A = sqrt((b-b^2/4)*(w00*w00)/ (w11*w00 + w10*w10)) and
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      w11 = pssq(0)*pssq(0)
      w00 = y*y
      w10 = y*pssq(0)    (* symbolizes the dot product)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そしてと及びアンド並びに且つ兼又共それですると亦だからそれからはたまた
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      B = 1 - b/2 - A * w10/w00
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Appendix A.16 contains a listing of a reference implementation for the enhancement method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付録 A.16 には、拡張メソッドの参照実装のリストが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-7--Synthesis-Filtering">
4.7. Synthesis Filtering
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. 合成フィルタリング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon decoding or PLC of the LP excitation block, the decoded speech block is obtained by running the decoded LP synthesis filter, 1/A~k(z), over the block. The synthesis filters have to be shifted to compensate for the delay in the enhancer. For 20 ms frame size mode, they SHOULD be shifted one 40-sample sub-block, and for 30 ms frame size mode, they SHOULD be shifted two 40-sample sub-blocks. The LP coefficients SHOULD be changed at the first sample of every sub-block while keeping the filter state. For PLC blocks, one solution is to apply the last LP coefficients of the last decoded speech block for all sub-blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LP 励起ブロックの復号化または PLC の際、復号化された音声ブロックは、ブロックに対して復号化された LP 合成フィルター 1/A~k(z) を実行することによって取得されます。エンハンサーの遅延を補償するには、合成フィルターをシフトする必要があります。20 ms フレーム サイズ モードの場合は 40 サンプル サブブロック 1 つシフトする必要があり、30 ms フレーム サイズ モードの場合は 40 サンプル サブブロック 2 つシフトする必要があります。LP 係数は、フィルタの状態を維持しながら、すべてのサブブロックの最初のサンプルで変更されるべきです (SHOULD)。PLC ブロックの場合、解決策の 1 つは、最後に復号された音声ブロックの最後の LP 係数をすべてのサブブロックに適用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reference implementation for the synthesis filtering can be found in Appendix A.48.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
合成フィルタリングのリファレンス実装は、付録 A.48 にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-8--Post-Filtering">
4.8. Post Filtering
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. ポストフィルタリング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If desired, the decoded block can be filtered by a high-pass filter. This removes the low frequencies of the decoded signal. A reference implementation of this, with cutoff at 65 Hz, is shown in Appendix A.30.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必要に応じて、デコードされたブロックをハイパス フィルターでフィルター処理できます。これにより、デコードされた信号の低周波数が除去されます。65 Hz でカットオフするこのリファレンス実装を付録 A.30 に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Security-Considerations">
5. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This algorithm for the coding of speech signals is not subject to any known security consideration; however, its RTP payload format [1] is subject to several considerations, which are addressed there. Confidentiality of the media streams is achieved by encryption; therefore external mechanisms, such as SRTP [5], MAY be used for that purpose.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
音声信号を符号化するためのこのアルゴリズムは、既知のセキュリティに関する考慮事項の対象にはなりません。ただし、その RTP ペイロード形式 [1] にはいくつかの考慮事項があり、そこで説明されています。メディア ストリームの機密性は暗号化によって実現されます。したがって、SRTP [5] などの外部メカニズムをその目的に使用してもよい(MAY)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Evaluation-of-the-iLBC-Implementations">
6. Evaluation of the iLBC Implementations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. iLBC 実装の評価
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible and suggested to evaluate certain iLBC implementation by utilizing methodology and tools available at http://www.ilbcfreeware.org/evaluation.html
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
http://www.ilbcfreeware.org/evaluation.html で入手可能な方法論とツールを利用して、特定の iLBC 実装を評価することが可能であり、推奨されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--References">
7. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1--Normative-References">
7.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Duric, A. and S. Andersen, &#34;Real-time Transport Protocol (RTP) Payload Format for internet Low Bit Rate Codec (iLBC) Speech&#34;, RFC 3952, December 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Duric, A. および S. Andersen、「インターネット低ビット レート コーデック (iLBC) 音声用のリアルタイム トランスポート プロトコル (RTP) ペイロード フォーマット」、RFC 3952、2004 年 12 月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Bradner, S.、「要件レベルを示すために RFC で使用するキーワード」、BCP 14、RFC 2119、1997 年 3 月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] PacketCable(TM) Audio/Video Codecs Specification, Cable Television Laboratories, Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] PacketCable(TM) オーディオ/ビデオ コーデック仕様、Cable Television Laboratories, Inc.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-2--Informative-References">
7.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] ITU-T Recommendation G.711, available online from the ITU bookstore at http://www.itu.int.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] ITU-T 勧告 G.711。ITU ブックストア http://www.itu.int からオンラインで入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norman, &#34;The Secure Real Time Transport Protocol (SRTP)&#34;, RFC 3711, March 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Baugher, M.、McGrew, D.、Naslund, M.、Carrara, E.、および K. Norman、「セキュア リアルタイム トランスポート プロトコル (SRTP)」、RFC 3711、2004 年 3 月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Acknowledgements">
8. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This extensive work, besides listed authors, has the following authors, who could not have been listed among &#34;official&#34; authors (due to IESG restrictions in the number of authors who can be listed):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この広範な著作には、リストされている著者以外に、(IESG によるリスト可能な著者数の制限のため) 「公式」著者としてリストされることができなかった以下の著者が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Manohar N. Murthi (Department of Electrical and Computer Engineering, University of Miami), Fredrik Galschiodt, Julian Spittka, and Jan Skoglund (Global IP Sound).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Manohar N. Murthi (マイアミ大学電気・コンピュータ工学科)、Fredrik Galschiodt、Julian Spittka、Jan Skoglund (Global IP Sound)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors are deeply indebted to the following people and thank them sincerely:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者らは以下の方々に深く感謝し、心から感謝いたします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Henry Sinnreich, Patrik Faltstrom, Alan Johnston, and Jean-Francois Mule for great support of the iLBC initiative and for valuable feedback and comments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Henry Sinnreich、Patrik Faltstrom、Alan Johnston、Jean-Francois Mule の皆様には、iLBC イニシアチブへの多大なご支援と、貴重なフィードバックとコメントをいただきました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Peter Vary, Frank Mertz, and Christoph Erdmann (RWTH Aachen); Vladimir Cuperman (Niftybox LLC); Thomas Eriksson (Chalmers Univ of Tech), and Gernot Kubin (TU Graz), for thorough review of the iLBC document and their valuable feedback and remarks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Peter Vary、Frank Mertz、Christoph Erdmann (アーヘン工科大学)。ウラジミール・クペルマン (Niftybox LLC);Thomas Eriksson (Chalmers 工科大学) と Gernot Kubin (グラーツ工科大学) には、iLBC 文書を徹底的にレビューしていただき、貴重なフィードバックとコメントをいただきました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
APPENDIX A. Reference Implementation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録 A. リファレンス実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This appendix contains the complete c-code for a reference implementation of encoder and decoder for the specified codec.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この付録には、指定されたコーデックのエンコーダおよびデコーダのリファレンス実装の完全な C コードが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The c-code consists of the following files with highest-level functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
C コードは、最高レベルの関数を含む次のファイルで構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
iLBC_test.c: main function for evaluation purpose iLBC_encode.h: encoder header iLBC_encode.c: encoder function iLBC_decode.h: decoder header iLBC_decode.c: decoder function
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
iLBC_test.c: 評価用メイン関数 iLBC_encode.h: エンコーダヘッダ iLBC_encode.c: エンコーダ関数 iLBC_decode.h: デコーダヘッダ iLBC_decode.c: デコーダ関数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following files contain global defines and constants:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のファイルには、グローバル定義と定数が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
iLBC_define.h: global defines constants.h: global constants header constants.c: global constants memory allocations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
iLBC_define.h: グローバル定義 constants.h: グローバル定数ヘッダー constants.c: グローバル定数のメモリ割り当て
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following files contain subroutines:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のファイルにはサブルーチンが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
anaFilter.h: lpc analysis filter header anaFilter.c: lpc analysis filter function createCB.h: codebook construction header createCB.c: codebook construction function doCPLC.h: packet loss concealment header doCPLC.c: packet loss concealment function enhancer.h: signal enhancement header enhancer.c: signal enhancement function filter.h: general filter header filter.c: general filter functions FrameClassify.h: start state classification header FrameClassify.c: start state classification function gainquant.h: gain quantization header gainquant.c: gain quantization function getCBvec.h: codebook vector construction header getCBvec.c: codebook vector construction function helpfun.h: general purpose header helpfun.c: general purpose functions hpInput.h: input high pass filter header hpInput.c: input high pass filter function hpOutput.h: output high pass filter header hpOutput.c: output high pass filter function iCBConstruct.h: excitation decoding header iCBConstruct.c: excitation decoding function iCBSearch.h: excitation encoding header iCBSearch.c: excitation encoding function LPCdecode.h: lpc decoding header LPCdecode.c: lpc decoding function LPCencode.h: lpc encoding header LPCencode.c: lpc encoding function lsf.h: line spectral frequencies header lsf.c: line spectral frequencies functions packing.h: bitstream packetization header packing.c: bitstream packetization functions StateConstructW.h: state decoding header StateConstructW.c: state decoding functions StateSearchW.h: state encoding header StateSearchW.c: state encoding function syntFilter.h: lpc synthesis filter header syntFilter.c: lpc synthesis filter function
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
anaFilter.h: lpc 分析フィルターヘッダー anaFilter.c: lpc 分析フィルター関数 createCB.h: コードブック構築ヘッダー createCB.c: コードブック構築関数 doCPLC.h: パケット損失隠蔽ヘッダー doCPLC.c: パケット損失隠蔽関数Enhancer.h:信号強調ヘッダー extender.c: 信号強調関数 filter.h: 一般的なフィルター ヘッダー filter.c: 一般的なフィルター関数 FrameClassify.h: 開始状態分類ヘッダー FrameClassify.c: 開始状態分類関数 Gainquant.h: ゲイン量子化ヘッダー Gainquant.c: ゲイン量子化関数 getCBvec.h: コードブック ベクトル構築ヘッダ getCBvec.c: コードブック ベクトル構築関数 helpfun.h: 汎用ヘッダ helpfun.c: 汎用関数 hpInput.h: 入力ハイパス フィルタ ヘッダ hpInput.c: 入力ハイパスフィルタ関数 hpOutput.h: 出力ハイパス フィルタ ヘッダ hpOutput.c: 出力ハイパス フィルタ関数 iCBConstruct.h: 励振デコード ヘッダ iCBConstruct.c: 励振デコード関数 iCBSearch.h: 励振エンコード ヘッダ iCBSearch.c: 励振エンコード関数 LPCdecode。h: lpc デコード ヘッダー LPCdecode.c: lpc デコード関数 LPCencode.h: lpc エンコード ヘッダー LPCencode.c: lpc エンコード関数 lsf.h: 線スペクトル周波数ヘッダー lsf.c: 線スペクトル周波数関数Packing.h: ビットストリーム パケット化ヘッダー パッキング.c: ビットストリーム パケット化関数 StateConstructW.h: 状態デコード ヘッダー StateConstructW.c: 状態デコード関数 StateSearchW.h: 状態エンコード ヘッダー StateSearchW.c: 状態エンコード関数 syntFilter.h: lpc 合成フィルター ヘッダー syntFilter.c: lpc 合成フィルター関数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The implementation is portable and should work on many different platforms. However, it is not difficult to optimize the implementation on particular platforms, an exercise left to the reader.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この実装は移植可能であり、さまざまなプラットフォームで動作するはずです。ただし、特定のプラットフォームでの実装を最適化することは難しくありません。これは読者に任せてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-1--iLBCtest-c">
A.1. iLBC_test.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. iLBC_test.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC_test.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC_test.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;math.h&gt;
   #include &lt;stdlib.h&gt;
   #include &lt;stdio.h&gt;
   #include &lt;string.h&gt;
   #include &#34;iLBC_define.h&#34;
   #include &#34;iLBC_encode.h&#34;
   #include &#34;iLBC_decode.h&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Runtime statistics */
   #include &lt;time.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define ILBCNOOFWORDS_MAX (NO_OF_BYTES_30MS/2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define ILBCNOOFWORDS_MAX (NO_OF_BYTES_30MS/2)
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  Encoder interface function
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   short encode(   /* (o) Number of bytes encoded */
       iLBC_Enc_Inst_t *iLBCenc_inst,
                                   /* (i/o) Encoder instance */
       short *encoded_data,    /* (o) The encoded bytes */
       short *data                 /* (i) The signal block to encode*/
   ){
       float block[BLOCKL_MAX];
       int k;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* convert signal to float */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (k=0; k&lt;iLBCenc_inst-&gt;blockl; k++)
           block[k] = (float)data[k];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* do the actual encoding */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       iLBC_encode((unsigned char *)encoded_data, block, iLBCenc_inst);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return (iLBCenc_inst-&gt;no_of_bytes); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
return (iLBCenc_inst-&gt;no_of_bytes);}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  Decoder interface function
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   short decode(       /* (o) Number of decoded samples */
       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) Decoder instance */
       short *decoded_data,        /* (o) Decoded signal block*/
       short *encoded_data,        /* (i) Encoded bytes */
       short mode                       /* (i) 0=PL, 1=Normal */
   ){
       int k;
       float decblock[BLOCKL_MAX], dtmp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* check if mode is valid */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (mode&lt;0 || mode&gt;1) {
           printf(&#34;\nERROR - Wrong mode - 0, 1 allowed\n&#34;); exit(3);}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* do actual decoding of block */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC_decode(decblock, (unsigned char *)encoded_data, iLBCdec_inst, mode);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC_decode(decblock, (unsigned char *)encoded_data, iLBCdec_inst, mode);
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* convert to short */
              for (k=0; k&lt;iLBCdec_inst-&gt;blockl; k++){
           dtmp=decblock[k];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (dtmp&lt;MIN_SAMPLE)
               dtmp=MIN_SAMPLE;
           else if (dtmp&gt;MAX_SAMPLE)
               dtmp=MAX_SAMPLE;
           decoded_data[k] = (short) dtmp;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return (iLBCdec_inst-&gt;blockl); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
return (iLBCdec_inst-&gt;blockl);}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*---------------------------------------------------------------*
    *  Main program to test iLBC encoding and decoding
    *
    *  Usage:
    *    exefile_name.exe &lt;infile&gt; &lt;bytefile&gt; &lt;outfile&gt; &lt;channel&gt;
    *
    *    &lt;infile&gt;   : Input file, speech for encoder (16-bit pcm file)
    *    &lt;bytefile&gt; : Bit stream output from the encoder
    *    &lt;outfile&gt;  : Output file, decoded speech (16-bit pcm file)
    *    &lt;channel&gt;  : Bit error file, optional (16-bit)
    *                     1 - Packet received correctly
    *                     0 - Packet Lost
    *
    *--------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int main(int argc, char* argv[]) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int main(int argc, char* argv[]) {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Runtime statistics */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       float starttime;
       float runtime;
       float outtime;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       FILE *ifileid,*efileid,*ofileid, *cfileid;
       short data[BLOCKL_MAX];
       short encoded_data[ILBCNOOFWORDS_MAX], decoded_data[BLOCKL_MAX];
       int len;
       short pli, mode;
       int blockcount = 0;
       int packetlosscount = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Create structs */
       iLBC_Enc_Inst_t Enc_Inst;
       iLBC_Dec_Inst_t Dec_Inst;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* get arguments and open files */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if ((argc!=5) &amp;&amp; (argc!=6)) {
           fprintf(stderr,
           &#34;\n*-----------------------------------------------*\n&#34;);
           fprintf(stderr,
           &#34;   %s &lt;20,30&gt; input encoded decoded (channel)\n\n&#34;,
               argv[0]);
           fprintf(stderr,
           &#34;   mode    : Frame size for the encoding/decoding\n&#34;);
           fprintf(stderr,
           &#34;                 20 - 20 ms\n&#34;);
           fprintf(stderr,
           &#34;                 30 - 30 ms\n&#34;);
           fprintf(stderr,
           &#34;   input   : Speech for encoder (16-bit pcm file)\n&#34;);
           fprintf(stderr,
           &#34;   encoded : Encoded bit stream\n&#34;);
           fprintf(stderr,
           &#34;   decoded : Decoded speech (16-bit pcm file)\n&#34;);
           fprintf(stderr,
           &#34;   channel : Packet loss pattern, optional (16-bit)\n&#34;);
           fprintf(stderr,
           &#34;                  1 - Packet received correctly\n&#34;);
           fprintf(stderr,
           &#34;                  0 - Packet Lost\n&#34;);
           fprintf(stderr,
           &#34;*-----------------------------------------------*\n\n&#34;);
           exit(1);
       }
       mode=atoi(argv[1]);
       if (mode != 20 &amp;&amp; mode != 30) {
           fprintf(stderr,&#34;Wrong mode %s, must be 20, or 30\n&#34;,
               argv[1]);
           exit(2);
       }
       if ( (ifileid=fopen(argv[2],&#34;rb&#34;)) == NULL) {
           fprintf(stderr,&#34;Cannot open input file %s\n&#34;, argv[2]);
           exit(2);}
       if ( (efileid=fopen(argv[3],&#34;wb&#34;)) == NULL) {
           fprintf(stderr, &#34;Cannot open encoded file %s\n&#34;,
               argv[3]); exit(1);}
       if ( (ofileid=fopen(argv[4],&#34;wb&#34;)) == NULL) {
           fprintf(stderr, &#34;Cannot open decoded file %s\n&#34;,
               argv[4]); exit(1);}
       if (argc==6) {
           if( (cfileid=fopen(argv[5],&#34;rb&#34;)) == NULL) {
               fprintf(stderr, &#34;Cannot open channel file %s\n&#34;,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   argv[5]);
               exit(1);
           }
       } else {
           cfileid=NULL;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* print info */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       fprintf(stderr, &#34;\n&#34;);
       fprintf(stderr,
           &#34;*---------------------------------------------------*\n&#34;);
       fprintf(stderr,
           &#34;*                                                   *\n&#34;);
       fprintf(stderr,
           &#34;*      iLBC test program                            *\n&#34;);
       fprintf(stderr,
           &#34;*                                                   *\n&#34;);
       fprintf(stderr,
           &#34;*                                                   *\n&#34;);
       fprintf(stderr,
           &#34;*---------------------------------------------------*\n&#34;);
       fprintf(stderr,&#34;\nMode           : %2d ms\n&#34;, mode);
       fprintf(stderr,&#34;Input file     : %s\n&#34;, argv[2]);
       fprintf(stderr,&#34;Encoded file   : %s\n&#34;, argv[3]);
       fprintf(stderr,&#34;Output file    : %s\n&#34;, argv[4]);
       if (argc==6) {
           fprintf(stderr,&#34;Channel file   : %s\n&#34;, argv[5]);
       }
       fprintf(stderr,&#34;\n&#34;);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Initialization */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       initEncode(&amp;Enc_Inst, mode);
       initDecode(&amp;Dec_Inst, mode, 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Runtime statistics */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       starttime=clock()/(float)CLOCKS_PER_SEC;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* loop over input blocks */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       while (fread(data,sizeof(short),Enc_Inst.blockl,ifileid)==
               Enc_Inst.blockl) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           blockcount++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* encoding */
                      fprintf(stderr, &#34;--- Encoding block %i --- &#34;,blockcount);
           len=encode(&amp;Enc_Inst, encoded_data, data);
           fprintf(stderr, &#34;\r&#34;);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* write byte file */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           fwrite(encoded_data, sizeof(unsigned char), len, efileid);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* get channel data if provided */
           if (argc==6) {
               if (fread(&amp;pli, sizeof(short), 1, cfileid)) {
                   if ((pli!=0)&amp;&amp;(pli!=1)) {
                       fprintf(stderr, &#34;Error in channel file\n&#34;);
                       exit(0);
                   }
                   if (pli==0) {
                       /* Packet loss -&gt; remove info from frame */
                       memset(encoded_data, 0,
                           sizeof(short)*ILBCNOOFWORDS_MAX);
                       packetlosscount++;
                   }
               } else {
                   fprintf(stderr, &#34;Error. Channel file too short\n&#34;);
                   exit(0);
               }
           } else {
               pli=1;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* decoding */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           fprintf(stderr, &#34;--- Decoding block %i --- &#34;,blockcount);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           len=decode(&amp;Dec_Inst, decoded_data, encoded_data, pli);
           fprintf(stderr, &#34;\r&#34;);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* write output file */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           fwrite(decoded_data,sizeof(short),len,ofileid);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Runtime statistics */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       runtime = (float)(clock()/(float)CLOCKS_PER_SEC-starttime);
       outtime = (float)((float)blockcount*(float)mode/1000.0);
       printf(&#34;\n\nLength of speech file: %.1f s\n&#34;, outtime);
       printf(&#34;Packet loss          : %.1f%%\n&#34;,
           100.0*(float)packetlosscount/(float)blockcount);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       printf(&#34;Time to run iLBC     :&#34;);
       printf(&#34; %.1f s (%.1f %% of realtime)\n\n&#34;, runtime,
           (100*runtime/outtime));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* close files */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       fclose(ifileid);  fclose(efileid); fclose(ofileid);
       if (argc==6) {
           fclose(cfileid);
       }
       return(0);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-2--iLBCencode-h">
A.2. iLBC_encode.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. iLBC_エンコード.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC_encode.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC_エンコード.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_ILBCENCODE_H #define __iLBC_ILBCENCODE_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_ILBCENCODE_H #define __iLBC_ILBCENCODE_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   short initEncode(                   /* (o) Number of bytes
                                              encoded */
       iLBC_Enc_Inst_t *iLBCenc_inst,  /* (i/o) Encoder instance */
       int mode                    /* (i) frame size mode */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void iLBC_encode(
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void iLBC_encode(
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       unsigned char *bytes,           /* (o) encoded data bits iLBC */
       float *block,                   /* (o) speech vector to
                                              encode */
       iLBC_Enc_Inst_t *iLBCenc_inst   /* (i/o) the general encoder
                                              state */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-3--iLBCencode-c">
A.3. iLBC_encode.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.3. iLBC_エンコード.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC_encode.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC_エンコード.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;math.h&gt;
   #include &lt;stdlib.h&gt;
   #include &lt;string.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;LPCencode.h&#34; #include &#34;FrameClassify.h&#34; #include &#34;StateSearchW.h&#34; #include &#34;StateConstructW.h&#34; #include &#34;helpfun.h&#34; #include &#34;constants.h&#34; #include &#34;packing.h&#34; #include &#34;iCBSearch.h&#34; #include &#34;iCBConstruct.h&#34; #include &#34;hpInput.h&#34; #include &#34;anaFilter.h&#34; #include &#34;syntFilter.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;LPCencode.h&#34; #include &#34;FrameClassify.h&#34; #include &#34;StateSearchW.h&#34; #include &#34;StateConstructW.h&#34; #include &#34;helpfun.h&#34; #include &#34;constants.h&#34; #include &#34;packing.h&#34; #include &#34;iCBSearch.h&#34; #include &#34;iCBConstruct.h&#34; #include &#34;hpInput.h&#34; #include &#34;anaFilter.h&#34; #include &#34;syntFilter.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  Initiation of encoder instance.
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   short initEncode(                   /* (o) Number of bytes
                                              encoded */
       iLBC_Enc_Inst_t *iLBCenc_inst,  /* (i/o) Encoder instance */
       int mode                    /* (i) frame size mode */
   ){
       iLBCenc_inst-&gt;mode = mode;
       if (mode==30) {
           iLBCenc_inst-&gt;blockl = BLOCKL_30MS;
           iLBCenc_inst-&gt;nsub = NSUB_30MS;
           iLBCenc_inst-&gt;nasub = NASUB_30MS;
           iLBCenc_inst-&gt;lpc_n = LPC_N_30MS;
           iLBCenc_inst-&gt;no_of_bytes = NO_OF_BYTES_30MS;
           iLBCenc_inst-&gt;no_of_words = NO_OF_WORDS_30MS;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           iLBCenc_inst-&gt;state_short_len=STATE_SHORT_LEN_30MS;
           /* ULP init */
           iLBCenc_inst-&gt;ULP_inst=&amp;ULP_30msTbl;
       }
       else if (mode==20) {
           iLBCenc_inst-&gt;blockl = BLOCKL_20MS;
           iLBCenc_inst-&gt;nsub = NSUB_20MS;
           iLBCenc_inst-&gt;nasub = NASUB_20MS;
           iLBCenc_inst-&gt;lpc_n = LPC_N_20MS;
           iLBCenc_inst-&gt;no_of_bytes = NO_OF_BYTES_20MS;
           iLBCenc_inst-&gt;no_of_words = NO_OF_WORDS_20MS;
           iLBCenc_inst-&gt;state_short_len=STATE_SHORT_LEN_20MS;
           /* ULP init */
           iLBCenc_inst-&gt;ULP_inst=&amp;ULP_20msTbl;
       }
       else {
           exit(2);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memset((*iLBCenc_inst).anaMem, 0,
           LPC_FILTERORDER*sizeof(float));
       memcpy((*iLBCenc_inst).lsfold, lsfmeanTbl,
           LPC_FILTERORDER*sizeof(float));
       memcpy((*iLBCenc_inst).lsfdeqold, lsfmeanTbl,
           LPC_FILTERORDER*sizeof(float));
       memset((*iLBCenc_inst).lpc_buffer, 0,
           (LPC_LOOKBACK+BLOCKL_MAX)*sizeof(float));
       memset((*iLBCenc_inst).hpimem, 0, 4*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return (iLBCenc_inst-&gt;no_of_bytes); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
return (iLBCenc_inst-&gt;no_of_bytes);}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  main encoder function
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void iLBC_encode(
       unsigned char *bytes,           /* (o) encoded data bits iLBC */
       float *block,                   /* (o) speech vector to
                                              encode */
       iLBC_Enc_Inst_t *iLBCenc_inst   /* (i/o) the general encoder
                                              state */
   ){
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
float data[BLOCKL_MAX]; float residual[BLOCKL_MAX], reverseResidual[BLOCKL_MAX];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
浮動小数点データ[BLOCKL_MAX];float 残差[BLOCKL_MAX]、reverseResidual[BLOCKL_MAX];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
int start, idxForMax, idxVec[STATE_LEN];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
int start、idxForMax、idxVec[STATE_LEN];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       float reverseDecresidual[BLOCKL_MAX], mem[CB_MEML];
       int n, k, meml_gotten, Nfor, Nback, i, pos;
       int gain_index[CB_NSTAGES*NASUB_MAX],
           extra_gain_index[CB_NSTAGES];
       int cb_index[CB_NSTAGES*NASUB_MAX],extra_cb_index[CB_NSTAGES];
       int lsf_i[LSF_NSPLIT*LPC_N_MAX];
       unsigned char *pbytes;
       int diff, start_pos, state_first;
       float en1, en2;
       int index, ulp, firstpart;
       int subcount, subframe;
       float weightState[LPC_FILTERORDER];
       float syntdenum[NSUB_MAX*(LPC_FILTERORDER+1)];
       float weightdenum[NSUB_MAX*(LPC_FILTERORDER+1)];
       float decresidual[BLOCKL_MAX];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* high pass filtering of input signal if such is not done
              prior to calling this function */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       hpInput(block, iLBCenc_inst-&gt;blockl,
                   data, (*iLBCenc_inst).hpimem);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* otherwise simply copy */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*memcpy(data,block,iLBCenc_inst-&gt;blockl*sizeof(float));*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* LPC of hp filtered input data */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
LPCencode(syntdenum, weightdenum, lsf_i, data, iLBCenc_inst);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
LPCencode(syntdenum、weightdenum、lsf_i、データ、iLBCenc_inst);
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* inverse filter to get residual */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (n=0; n&lt;iLBCenc_inst-&gt;nsub; n++) {
           anaFilter(&amp;data[n*SUBL], &amp;syntdenum[n*(LPC_FILTERORDER+1)],
               SUBL, &amp;residual[n*SUBL], iLBCenc_inst-&gt;anaMem);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* find state location */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       start = FrameClassify(iLBCenc_inst, residual);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* check if state should be in first or last part of the
       two subframes */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       diff = STATE_LEN - iLBCenc_inst-&gt;state_short_len;
       en1 = 0;
       index = (start-1)*SUBL;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; iLBCenc_inst-&gt;state_short_len; i++) {
           en1 += residual[index+i]*residual[index+i];
       }
       en2 = 0;
       index = (start-1)*SUBL+diff;
       for (i = 0; i &lt; iLBCenc_inst-&gt;state_short_len; i++) {
           en2 += residual[index+i]*residual[index+i];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (en1 &gt; en2) {
           state_first = 1;
           start_pos = (start-1)*SUBL;
       } else {
           state_first = 0;
           start_pos = (start-1)*SUBL + diff;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* scalar quantization of state */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       StateSearchW(iLBCenc_inst, &amp;residual[start_pos],
           &amp;syntdenum[(start-1)*(LPC_FILTERORDER+1)],
           &amp;weightdenum[(start-1)*(LPC_FILTERORDER+1)], &amp;idxForMax,
           idxVec, iLBCenc_inst-&gt;state_short_len, state_first);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       StateConstructW(idxForMax, idxVec,
           &amp;syntdenum[(start-1)*(LPC_FILTERORDER+1)],
           &amp;decresidual[start_pos], iLBCenc_inst-&gt;state_short_len);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* predictive quantization in state */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (state_first) { /* put adaptive part in the end */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* setup memory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           memset(mem, 0,
               (CB_MEML-iLBCenc_inst-&gt;state_short_len)*sizeof(float));
           memcpy(mem+CB_MEML-iLBCenc_inst-&gt;state_short_len,
               decresidual+start_pos,
               iLBCenc_inst-&gt;state_short_len*sizeof(float));
           memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* encode sub-frames */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
iCBSearch(iLBCenc_inst, extra_cb_index, extra_gain_index, &amp;residual[start_pos+iLBCenc_inst-&gt;state_short_len], mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
iCBSearch(iLBCenc_inst, extra_cb_index, extra_gain_index, &amp;residual[start_pos iLBCenc_inst-&gt;state_short_len], mem CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES,
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
&amp;weightdenum[start*(LPC_FILTERORDER+1)], weightState, 0);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
&amp;weightdenum[start*(LPC_FILTERORDER 1)],weightState, 0);
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* construct decoded vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
iCBConstruct( &amp;decresidual[start_pos+iLBCenc_inst-&gt;state_short_len], extra_cb_index, extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
iCBConstruct( &amp;decresidual[start_pos iLBCenc_inst-&gt;state_short_len], extra_cb_index, extra_gain_index, mem CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       }
       else { /* put adaptive part in the beginning */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* create reversed vectors for prediction */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (k=0; k&lt;diff; k++) {
               reverseResidual[k] = residual[(start+1)*SUBL-1
                   -(k+iLBCenc_inst-&gt;state_short_len)];
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* setup memory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           meml_gotten = iLBCenc_inst-&gt;state_short_len;
           for (k=0; k&lt;meml_gotten; k++) {
               mem[CB_MEML-1-k] = decresidual[start_pos + k];
           }
           memset(mem, 0, (CB_MEML-k)*sizeof(float));
           memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* encode sub-frames */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
iCBSearch(iLBCenc_inst, extra_cb_index, extra_gain_index, reverseResidual, mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES, &amp;weightdenum[(start-1)*(LPC_FILTERORDER+1)], weightState, 0);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
iCBSearch(iLBCenc_inst, extra_cb_index, extra_gain_index, reverseResidual, mem CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES, &amp;weightdenum[(start-1)*(LPC_FILTERORDER 1)],weightState, 0);
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* construct decoded vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
iCBConstruct(reverseDecresidual, extra_cb_index, extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
iCBConstruct(reverseDecresidual, extra_cb_index, extra_gain_index, mem CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* get decoded residual from reversed vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (k=0; k&lt;diff; k++) {
               decresidual[start_pos-1-k] = reverseDecresidual[k];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* counter for predicted sub-frames */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
subcount=0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
サブカウント=0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* forward prediction of sub-frames */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Nfor = iLBCenc_inst-&gt;nsub-start-1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if ( Nfor &gt; 0 ) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if ( Nfor &gt; 0 ) {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* setup memory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           memset(mem, 0, (CB_MEML-STATE_LEN)*sizeof(float));
           memcpy(mem+CB_MEML-STATE_LEN, decresidual+(start-1)*SUBL,
               STATE_LEN*sizeof(float));
           memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* loop over sub-frames to encode */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (subframe=0; subframe&lt;Nfor; subframe++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* encode sub-frame */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               iCBSearch(iLBCenc_inst, cb_index+subcount*CB_NSTAGES,
                   gain_index+subcount*CB_NSTAGES,
                   &amp;residual[(start+1+subframe)*SUBL],
                   mem+CB_MEML-memLfTbl[subcount],
                   memLfTbl[subcount], SUBL, CB_NSTAGES,
                   &amp;weightdenum[(start+1+subframe)*
                               (LPC_FILTERORDER+1)],
                   weightState, subcount+1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* construct decoded vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               iCBConstruct(&amp;decresidual[(start+1+subframe)*SUBL],
                   cb_index+subcount*CB_NSTAGES,
                   gain_index+subcount*CB_NSTAGES,
                   mem+CB_MEML-memLfTbl[subcount],
                   memLfTbl[subcount], SUBL, CB_NSTAGES);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* update memory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float)); memcpy(mem+CB_MEML-SUBL,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
memcpy(mem, mem SUBL, (CB_MEML-SUBL)*sizeof(float));memcpy(mem CB_MEML-SUBL,
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   &amp;decresidual[(start+1+subframe)*SUBL],
                   SUBL*sizeof(float));
               memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               subcount++;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* backward prediction of sub-frames */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Nback = start-1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Nback = 開始-1;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if ( Nback &gt; 0 ) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if ( Nback &gt; 0 ) {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* create reverse order vectors */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (n=0; n&lt;Nback; n++) {
               for (k=0; k&lt;SUBL; k++) {
                   reverseResidual[n*SUBL+k] =
                       residual[(start-1)*SUBL-1-n*SUBL-k];
                   reverseDecresidual[n*SUBL+k] =
                       decresidual[(start-1)*SUBL-1-n*SUBL-k];
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* setup memory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           meml_gotten = SUBL*(iLBCenc_inst-&gt;nsub+1-start);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if ( meml_gotten &gt; CB_MEML ) {
               meml_gotten=CB_MEML;
           }
           for (k=0; k&lt;meml_gotten; k++) {
               mem[CB_MEML-1-k] = decresidual[(start-1)*SUBL + k];
           }
           memset(mem, 0, (CB_MEML-k)*sizeof(float));
           memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* loop over sub-frames to encode */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (subframe=0; subframe&lt;Nback; subframe++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* encode sub-frame */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
iCBSearch(iLBCenc_inst, cb_index+subcount*CB_NSTAGES,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
iCBSearch(iLBCenc_inst, cb_index サブカウント *CB_NSTAGES,
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   gain_index+subcount*CB_NSTAGES,
                   &amp;reverseResidual[subframe*SUBL],
                   mem+CB_MEML-memLfTbl[subcount],
                   memLfTbl[subcount], SUBL, CB_NSTAGES,
                   &amp;weightdenum[(start-2-subframe)*
                               (LPC_FILTERORDER+1)],
                   weightState, subcount+1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* construct decoded vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               iCBConstruct(&amp;reverseDecresidual[subframe*SUBL],
                   cb_index+subcount*CB_NSTAGES,
                   gain_index+subcount*CB_NSTAGES,
                   mem+CB_MEML-memLfTbl[subcount],
                   memLfTbl[subcount], SUBL, CB_NSTAGES);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* update memory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float));
               memcpy(mem+CB_MEML-SUBL,
                   &amp;reverseDecresidual[subframe*SUBL],
                   SUBL*sizeof(float));
               memset(weightState, 0, LPC_FILTERORDER*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               subcount++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* get decoded residual from reversed vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (i=0; i&lt;SUBL*Nback; i++) {
               decresidual[SUBL*Nback - i - 1] =
                   reverseDecresidual[i];
           }
       }
       /* end encoding part */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* adjust index */
       index_conv_enc(cb_index);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* pack bytes */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       pbytes=bytes;
       pos=0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* loop over the 3 ULP classes */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (ulp=0; ulp&lt;3; ulp++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* LSF */
           for (k=0; k&lt;LSF_NSPLIT*iLBCenc_inst-&gt;lpc_n; k++) {
               packsplit(&amp;lsf_i[k], &amp;firstpart, &amp;lsf_i[k],
                   iLBCenc_inst-&gt;ULP_inst-&gt;lsf_bits[k][ulp],
                   iLBCenc_inst-&gt;ULP_inst-&gt;lsf_bits[k][ulp]+
                   iLBCenc_inst-&gt;ULP_inst-&gt;lsf_bits[k][ulp+1]+
                   iLBCenc_inst-&gt;ULP_inst-&gt;lsf_bits[k][ulp+2]);
               dopack( &amp;pbytes, firstpart,
                   iLBCenc_inst-&gt;ULP_inst-&gt;lsf_bits[k][ulp], &amp;pos);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Start block info */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           packsplit(&amp;start, &amp;firstpart, &amp;start,
               iLBCenc_inst-&gt;ULP_inst-&gt;start_bits[ulp],
               iLBCenc_inst-&gt;ULP_inst-&gt;start_bits[ulp]+
               iLBCenc_inst-&gt;ULP_inst-&gt;start_bits[ulp+1]+
               iLBCenc_inst-&gt;ULP_inst-&gt;start_bits[ulp+2]);
           dopack( &amp;pbytes, firstpart,
               iLBCenc_inst-&gt;ULP_inst-&gt;start_bits[ulp], &amp;pos);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           packsplit(&amp;state_first, &amp;firstpart, &amp;state_first,
               iLBCenc_inst-&gt;ULP_inst-&gt;startfirst_bits[ulp],
               iLBCenc_inst-&gt;ULP_inst-&gt;startfirst_bits[ulp]+
               iLBCenc_inst-&gt;ULP_inst-&gt;startfirst_bits[ulp+1]+
               iLBCenc_inst-&gt;ULP_inst-&gt;startfirst_bits[ulp+2]);
           dopack( &amp;pbytes, firstpart,
               iLBCenc_inst-&gt;ULP_inst-&gt;startfirst_bits[ulp], &amp;pos);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           packsplit(&amp;idxForMax, &amp;firstpart, &amp;idxForMax,
               iLBCenc_inst-&gt;ULP_inst-&gt;scale_bits[ulp],
               iLBCenc_inst-&gt;ULP_inst-&gt;scale_bits[ulp]+
               iLBCenc_inst-&gt;ULP_inst-&gt;scale_bits[ulp+1]+
               iLBCenc_inst-&gt;ULP_inst-&gt;scale_bits[ulp+2]);
           dopack( &amp;pbytes, firstpart,
               iLBCenc_inst-&gt;ULP_inst-&gt;scale_bits[ulp], &amp;pos);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (k=0; k&lt;iLBCenc_inst-&gt;state_short_len; k++) {
               packsplit(idxVec+k, &amp;firstpart, idxVec+k,
                   iLBCenc_inst-&gt;ULP_inst-&gt;state_bits[ulp],
                   iLBCenc_inst-&gt;ULP_inst-&gt;state_bits[ulp]+
                   iLBCenc_inst-&gt;ULP_inst-&gt;state_bits[ulp+1]+
                   iLBCenc_inst-&gt;ULP_inst-&gt;state_bits[ulp+2]);
               dopack( &amp;pbytes, firstpart,
                   iLBCenc_inst-&gt;ULP_inst-&gt;state_bits[ulp], &amp;pos);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* 23/22 (20ms/30ms) sample block */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (k=0;k&lt;CB_NSTAGES;k++) {
               packsplit(extra_cb_index+k, &amp;firstpart,
                   extra_cb_index+k,
                   iLBCenc_inst-&gt;ULP_inst-&gt;extra_cb_index[k][ulp],
                   iLBCenc_inst-&gt;ULP_inst-&gt;extra_cb_index[k][ulp]+
                   iLBCenc_inst-&gt;ULP_inst-&gt;extra_cb_index[k][ulp+1]+
                   iLBCenc_inst-&gt;ULP_inst-&gt;extra_cb_index[k][ulp+2]);
               dopack( &amp;pbytes, firstpart,
                   iLBCenc_inst-&gt;ULP_inst-&gt;extra_cb_index[k][ulp],
                   &amp;pos);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (k=0;k&lt;CB_NSTAGES;k++) {
               packsplit(extra_gain_index+k, &amp;firstpart,
                   extra_gain_index+k,
                   iLBCenc_inst-&gt;ULP_inst-&gt;extra_cb_gain[k][ulp],
                   iLBCenc_inst-&gt;ULP_inst-&gt;extra_cb_gain[k][ulp]+
                   iLBCenc_inst-&gt;ULP_inst-&gt;extra_cb_gain[k][ulp+1]+
                   iLBCenc_inst-&gt;ULP_inst-&gt;extra_cb_gain[k][ulp+2]);
               dopack( &amp;pbytes, firstpart,
                   iLBCenc_inst-&gt;ULP_inst-&gt;extra_cb_gain[k][ulp],
                   &amp;pos);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* The two/four (20ms/30ms) 40 sample sub-blocks */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (i=0; i&lt;iLBCenc_inst-&gt;nasub; i++) {
               for (k=0; k&lt;CB_NSTAGES; k++) {
                   packsplit(cb_index+i*CB_NSTAGES+k, &amp;firstpart,
                       cb_index+i*CB_NSTAGES+k,
                       iLBCenc_inst-&gt;ULP_inst-&gt;cb_index[i][k][ulp],
                       iLBCenc_inst-&gt;ULP_inst-&gt;cb_index[i][k][ulp]+
                       iLBCenc_inst-&gt;ULP_inst-&gt;cb_index[i][k][ulp+1]+
                       iLBCenc_inst-&gt;ULP_inst-&gt;cb_index[i][k][ulp+2]);
                   dopack( &amp;pbytes, firstpart,
                       iLBCenc_inst-&gt;ULP_inst-&gt;cb_index[i][k][ulp],
                       &amp;pos);
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (i=0; i&lt;iLBCenc_inst-&gt;nasub; i++) {
               for (k=0; k&lt;CB_NSTAGES; k++) {
                   packsplit(gain_index+i*CB_NSTAGES+k, &amp;firstpart,
                       gain_index+i*CB_NSTAGES+k,
                       iLBCenc_inst-&gt;ULP_inst-&gt;cb_gain[i][k][ulp],
                       iLBCenc_inst-&gt;ULP_inst-&gt;cb_gain[i][k][ulp]+
                              iLBCenc_inst-&gt;ULP_inst-&gt;cb_gain[i][k][ulp+1]+
                       iLBCenc_inst-&gt;ULP_inst-&gt;cb_gain[i][k][ulp+2]);
                   dopack( &amp;pbytes, firstpart,
                       iLBCenc_inst-&gt;ULP_inst-&gt;cb_gain[i][k][ulp],
                       &amp;pos);
               }
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* set the last bit to zero (otherwise the decoder
          will treat it as a lost frame) */
       dopack( &amp;pbytes, 0, 1, &amp;pos);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-4--iLBCdecode-h">
A.4. iLBC_decode.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4. iLBC_デコード.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC_decode.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC_デコード.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_ILBCDECODE_H #define __iLBC_ILBCDECODE_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_ILBCDECODE_H #define __iLBC_ILBCDECODE_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   short initDecode(                   /* (o) Number of decoded
                                              samples */
       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) Decoder instance */
       int mode,                       /* (i) frame size mode */
       int use_enhancer                /* (i) 1 to use enhancer
                                              0 to run without
                                                enhancer */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void iLBC_decode(
       float *decblock,            /* (o) decoded signal block */
       unsigned char *bytes,           /* (i) encoded signal bits */
       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state
                                                structure */
       int mode                    /* (i) 0: bad packet, PLC,
                                              1: normal */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
);
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-5--iLBCdecode-c">
A.5. iLBC_decode.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.5. iLBC_デコード.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC_decode.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC_デコード.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;math.h&gt;
   #include &lt;stdlib.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;StateConstructW.h&#34; #include &#34;LPCdecode.h&#34; #include &#34;iCBConstruct.h&#34; #include &#34;doCPLC.h&#34; #include &#34;helpfun.h&#34; #include &#34;constants.h&#34; #include &#34;packing.h&#34; #include &#34;string.h&#34; #include &#34;enhancer.h&#34; #include &#34;hpOutput.h&#34; #include &#34;syntFilter.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;StateConstructW.h&#34; #include &#34;LPCdecode.h&#34; #include &#34;iCBConstruct.h&#34; #include &#34;doCPLC.h&#34; #include &#34;helpfun.h&#34; #include &#34;constants.h&#34; #include &#34;packing.h&#34; #include &#34;string.h&#34; #include &#34;enhancer.h&#34; #include &#34;hpOutput.h&#34; #include &#34;syntFilter.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  Initiation of decoder instance.
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   short initDecode(                   /* (o) Number of decoded
                                              samples */
       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) Decoder instance */
       int mode,                       /* (i) frame size mode */
       int use_enhancer                /* (i) 1 to use enhancer
                                              0 to run without
                                                enhancer */
   ){
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       iLBCdec_inst-&gt;mode = mode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (mode==30) {
           iLBCdec_inst-&gt;blockl = BLOCKL_30MS;
           iLBCdec_inst-&gt;nsub = NSUB_30MS;
           iLBCdec_inst-&gt;nasub = NASUB_30MS;
           iLBCdec_inst-&gt;lpc_n = LPC_N_30MS;
           iLBCdec_inst-&gt;no_of_bytes = NO_OF_BYTES_30MS;
           iLBCdec_inst-&gt;no_of_words = NO_OF_WORDS_30MS;
           iLBCdec_inst-&gt;state_short_len=STATE_SHORT_LEN_30MS;
           /* ULP init */
           iLBCdec_inst-&gt;ULP_inst=&amp;ULP_30msTbl;
       }
       else if (mode==20) {
           iLBCdec_inst-&gt;blockl = BLOCKL_20MS;
           iLBCdec_inst-&gt;nsub = NSUB_20MS;
           iLBCdec_inst-&gt;nasub = NASUB_20MS;
           iLBCdec_inst-&gt;lpc_n = LPC_N_20MS;
           iLBCdec_inst-&gt;no_of_bytes = NO_OF_BYTES_20MS;
           iLBCdec_inst-&gt;no_of_words = NO_OF_WORDS_20MS;
           iLBCdec_inst-&gt;state_short_len=STATE_SHORT_LEN_20MS;
           /* ULP init */
           iLBCdec_inst-&gt;ULP_inst=&amp;ULP_20msTbl;
       }
       else {
           exit(2);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memset(iLBCdec_inst-&gt;syntMem, 0,
           LPC_FILTERORDER*sizeof(float));
       memcpy((*iLBCdec_inst).lsfdeqold, lsfmeanTbl,
           LPC_FILTERORDER*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memset(iLBCdec_inst-&gt;old_syntdenum, 0,
           ((LPC_FILTERORDER + 1)*NSUB_MAX)*sizeof(float));
       for (i=0; i&lt;NSUB_MAX; i++)
           iLBCdec_inst-&gt;old_syntdenum[i*(LPC_FILTERORDER+1)]=1.0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       iLBCdec_inst-&gt;last_lag = 20;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       iLBCdec_inst-&gt;prevLag = 120;
       iLBCdec_inst-&gt;per = 0.0;
       iLBCdec_inst-&gt;consPLICount = 0;
       iLBCdec_inst-&gt;prevPLI = 0;
       iLBCdec_inst-&gt;prevLpc[0] = 1.0;
       memset(iLBCdec_inst-&gt;prevLpc+1,0,
           LPC_FILTERORDER*sizeof(float));
       memset(iLBCdec_inst-&gt;prevResidual, 0, BLOCKL_MAX*sizeof(float));
       iLBCdec_inst-&gt;seed=777;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memset(iLBCdec_inst-&gt;hpomem, 0, 4*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       iLBCdec_inst-&gt;use_enhancer = use_enhancer;
       memset(iLBCdec_inst-&gt;enh_buf, 0, ENH_BUFL*sizeof(float));
       for (i=0;i&lt;ENH_NBLOCKS_TOT;i++)
           iLBCdec_inst-&gt;enh_period[i]=(float)40.0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       iLBCdec_inst-&gt;prev_enh_pl = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return (iLBCdec_inst-&gt;blockl); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
return (iLBCdec_inst-&gt;blockl);}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  frame residual decoder function (subrutine to iLBC_decode)
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void Decode(
       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state
                                                structure */
       float *decresidual,             /* (o) decoded residual frame */
       int start,                      /* (i) location of start
                                              state */
       int idxForMax,                  /* (i) codebook index for the
                                              maximum value */
       int *idxVec,                /* (i) codebook indexes for the
                                              samples  in the start
                                              state */
       float *syntdenum,               /* (i) the decoded synthesis
                                              filter coefficients */
       int *cb_index,                  /* (i) the indexes for the
                                              adaptive codebook */
       int *gain_index,            /* (i) the indexes for the
                                              corresponding gains */
       int *extra_cb_index,        /* (i) the indexes for the
                                              adaptive codebook part
                                              of start state */
       int *extra_gain_index,          /* (i) the indexes for the
                                              corresponding gains */
       int state_first                 /* (i) 1 if non adaptive part
                                              of start state comes
                                              first 0 if that part
                                              comes last */
   ){
       float reverseDecresidual[BLOCKL_MAX], mem[CB_MEML];
       int k, meml_gotten, Nfor, Nback, i;
       int diff, start_pos;
       int subcount, subframe;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       diff = STATE_LEN - iLBCdec_inst-&gt;state_short_len;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (state_first == 1) {
           start_pos = (start-1)*SUBL;
       } else {
           start_pos = (start-1)*SUBL + diff;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* decode scalar part of start state */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       StateConstructW(idxForMax, idxVec,
           &amp;syntdenum[(start-1)*(LPC_FILTERORDER+1)],
           &amp;decresidual[start_pos], iLBCdec_inst-&gt;state_short_len);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (state_first) { /* put adaptive part in the end */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* setup memory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           memset(mem, 0,
               (CB_MEML-iLBCdec_inst-&gt;state_short_len)*sizeof(float));
           memcpy(mem+CB_MEML-iLBCdec_inst-&gt;state_short_len,
               decresidual+start_pos,
               iLBCdec_inst-&gt;state_short_len*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* construct decoded vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
iCBConstruct( &amp;decresidual[start_pos+iLBCdec_inst-&gt;state_short_len], extra_cb_index, extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
iCBConstruct( &amp;decresidual[start_pos iLBCdec_inst-&gt;state_short_len], extra_cb_index, extra_gain_index, mem CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       }
       else {/* put adaptive part in the beginning */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* create reversed vectors for prediction */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (k=0; k&lt;diff; k++) {
               reverseDecresidual[k] =
                   decresidual[(start+1)*SUBL-1-
                           (k+iLBCdec_inst-&gt;state_short_len)];
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* setup memory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           meml_gotten = iLBCdec_inst-&gt;state_short_len;
           for (k=0; k&lt;meml_gotten; k++){
               mem[CB_MEML-1-k] = decresidual[start_pos + k];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           }
           memset(mem, 0, (CB_MEML-k)*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* construct decoded vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
iCBConstruct(reverseDecresidual, extra_cb_index, extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
iCBConstruct(reverseDecresidual, extra_cb_index, extra_gain_index, mem CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* get decoded residual from reversed vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (k=0; k&lt;diff; k++) {
               decresidual[start_pos-1-k] = reverseDecresidual[k];
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* counter for predicted sub-frames */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
subcount=0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
サブカウント=0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* forward prediction of sub-frames */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Nfor = iLBCdec_inst-&gt;nsub-start-1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if ( Nfor &gt; 0 ){
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if ( Nfor &gt; 0 ){
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* setup memory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           memset(mem, 0, (CB_MEML-STATE_LEN)*sizeof(float));
           memcpy(mem+CB_MEML-STATE_LEN, decresidual+(start-1)*SUBL,
               STATE_LEN*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* loop over sub-frames to encode */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (subframe=0; subframe&lt;Nfor; subframe++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* construct decoded vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               iCBConstruct(&amp;decresidual[(start+1+subframe)*SUBL],
                   cb_index+subcount*CB_NSTAGES,
                   gain_index+subcount*CB_NSTAGES,
                   mem+CB_MEML-memLfTbl[subcount],
                   memLfTbl[subcount], SUBL, CB_NSTAGES);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* update memory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float)); memcpy(mem+CB_MEML-SUBL,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
memcpy(mem, mem SUBL, (CB_MEML-SUBL)*sizeof(float));memcpy(mem CB_MEML-SUBL,
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   &amp;decresidual[(start+1+subframe)*SUBL],
                   SUBL*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               subcount++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* backward prediction of sub-frames */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Nback = start-1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Nback = 開始-1;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if ( Nback &gt; 0 ) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if ( Nback &gt; 0 ) {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* setup memory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           meml_gotten = SUBL*(iLBCdec_inst-&gt;nsub+1-start);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if ( meml_gotten &gt; CB_MEML ) {
               meml_gotten=CB_MEML;
           }
           for (k=0; k&lt;meml_gotten; k++) {
               mem[CB_MEML-1-k] = decresidual[(start-1)*SUBL + k];
           }
           memset(mem, 0, (CB_MEML-k)*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* loop over subframes to decode */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (subframe=0; subframe&lt;Nback; subframe++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* construct decoded vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               iCBConstruct(&amp;reverseDecresidual[subframe*SUBL],
                   cb_index+subcount*CB_NSTAGES,
                   gain_index+subcount*CB_NSTAGES,
                   mem+CB_MEML-memLfTbl[subcount], memLfTbl[subcount],
                   SUBL, CB_NSTAGES);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* update memory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float));
               memcpy(mem+CB_MEML-SUBL,
                   &amp;reverseDecresidual[subframe*SUBL],
                   SUBL*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               subcount++;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* get decoded residual from reversed vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (i=0; i&lt;SUBL*Nback; i++)
               decresidual[SUBL*Nback - i - 1] =
               reverseDecresidual[i];
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  main decoder function
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void iLBC_decode(
       float *decblock,            /* (o) decoded signal block */
       unsigned char *bytes,           /* (i) encoded signal bits */
       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state
                                                structure */
       int mode                    /* (i) 0: bad packet, PLC,
                                              1: normal */
   ){
       float data[BLOCKL_MAX];
       float lsfdeq[LPC_FILTERORDER*LPC_N_MAX];
       float PLCresidual[BLOCKL_MAX], PLClpc[LPC_FILTERORDER + 1];
       float zeros[BLOCKL_MAX], one[LPC_FILTERORDER + 1];
       int k, i, start, idxForMax, pos, lastpart, ulp;
       int lag, ilag;
       float cc, maxcc;
       int idxVec[STATE_LEN];
       int check;
       int gain_index[NASUB_MAX*CB_NSTAGES],
           extra_gain_index[CB_NSTAGES];
       int cb_index[CB_NSTAGES*NASUB_MAX], extra_cb_index[CB_NSTAGES];
       int lsf_i[LSF_NSPLIT*LPC_N_MAX];
       int state_first;
       int last_bit;
       unsigned char *pbytes;
       float weightdenum[(LPC_FILTERORDER + 1)*NSUB_MAX];
       int order_plus_one;
       float syntdenum[NSUB_MAX*(LPC_FILTERORDER+1)];
       float decresidual[BLOCKL_MAX];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (mode&gt;0) { /* the data are good */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* decode data */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           pbytes=bytes;
           pos=0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Set everything to zero before decoding */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (k=0; k&lt;LSF_NSPLIT*LPC_N_MAX; k++) {
               lsf_i[k]=0;
           }
           start=0;
           state_first=0;
           idxForMax=0;
           for (k=0; k&lt;iLBCdec_inst-&gt;state_short_len; k++) {
               idxVec[k]=0;
           }
           for (k=0; k&lt;CB_NSTAGES; k++) {
               extra_cb_index[k]=0;
           }
           for (k=0; k&lt;CB_NSTAGES; k++) {
               extra_gain_index[k]=0;
           }
           for (i=0; i&lt;iLBCdec_inst-&gt;nasub; i++) {
               for (k=0; k&lt;CB_NSTAGES; k++) {
                   cb_index[i*CB_NSTAGES+k]=0;
               }
           }
           for (i=0; i&lt;iLBCdec_inst-&gt;nasub; i++) {
               for (k=0; k&lt;CB_NSTAGES; k++) {
                   gain_index[i*CB_NSTAGES+k]=0;
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* loop over ULP classes */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (ulp=0; ulp&lt;3; ulp++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* LSF */
               for (k=0; k&lt;LSF_NSPLIT*iLBCdec_inst-&gt;lpc_n; k++){
                   unpack( &amp;pbytes, &amp;lastpart,
                       iLBCdec_inst-&gt;ULP_inst-&gt;lsf_bits[k][ulp], &amp;pos);
                   packcombine(&amp;lsf_i[k], lastpart,
                       iLBCdec_inst-&gt;ULP_inst-&gt;lsf_bits[k][ulp]);
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* Start block info */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               unpack( &amp;pbytes, &amp;lastpart,
                   iLBCdec_inst-&gt;ULP_inst-&gt;start_bits[ulp], &amp;pos);
               packcombine(&amp;start, lastpart,
                   iLBCdec_inst-&gt;ULP_inst-&gt;start_bits[ulp]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
unpack( &amp;pbytes, &amp;lastpart,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
unpack( &amp;pbytes, &amp;lastpart,
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   iLBCdec_inst-&gt;ULP_inst-&gt;startfirst_bits[ulp], &amp;pos);
               packcombine(&amp;state_first, lastpart,
                   iLBCdec_inst-&gt;ULP_inst-&gt;startfirst_bits[ulp]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               unpack( &amp;pbytes, &amp;lastpart,
                   iLBCdec_inst-&gt;ULP_inst-&gt;scale_bits[ulp], &amp;pos);
               packcombine(&amp;idxForMax, lastpart,
                   iLBCdec_inst-&gt;ULP_inst-&gt;scale_bits[ulp]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               for (k=0; k&lt;iLBCdec_inst-&gt;state_short_len; k++) {
                   unpack( &amp;pbytes, &amp;lastpart,
                       iLBCdec_inst-&gt;ULP_inst-&gt;state_bits[ulp], &amp;pos);
                   packcombine(idxVec+k, lastpart,
                       iLBCdec_inst-&gt;ULP_inst-&gt;state_bits[ulp]);
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* 23/22 (20ms/30ms) sample block */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               for (k=0; k&lt;CB_NSTAGES; k++) {
                   unpack( &amp;pbytes, &amp;lastpart,
                       iLBCdec_inst-&gt;ULP_inst-&gt;extra_cb_index[k][ulp],
                       &amp;pos);
                   packcombine(extra_cb_index+k, lastpart,
                       iLBCdec_inst-&gt;ULP_inst-&gt;extra_cb_index[k][ulp]);
               }
               for (k=0; k&lt;CB_NSTAGES; k++) {
                   unpack( &amp;pbytes, &amp;lastpart,
                       iLBCdec_inst-&gt;ULP_inst-&gt;extra_cb_gain[k][ulp],
                       &amp;pos);
                   packcombine(extra_gain_index+k, lastpart,
                       iLBCdec_inst-&gt;ULP_inst-&gt;extra_cb_gain[k][ulp]);
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* The two/four (20ms/30ms) 40 sample sub-blocks */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               for (i=0; i&lt;iLBCdec_inst-&gt;nasub; i++) {
                   for (k=0; k&lt;CB_NSTAGES; k++) {
                       unpack( &amp;pbytes, &amp;lastpart,
                       iLBCdec_inst-&gt;ULP_inst-&gt;cb_index[i][k][ulp],
                           &amp;pos);
                       packcombine(cb_index+i*CB_NSTAGES+k, lastpart,
                       iLBCdec_inst-&gt;ULP_inst-&gt;cb_index[i][k][ulp]);
                   }
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               for (i=0; i&lt;iLBCdec_inst-&gt;nasub; i++) {
                   for (k=0; k&lt;CB_NSTAGES; k++) {
                       unpack( &amp;pbytes, &amp;lastpart,
                                  iLBCdec_inst-&gt;ULP_inst-&gt;cb_gain[i][k][ulp],
                           &amp;pos);
                       packcombine(gain_index+i*CB_NSTAGES+k, lastpart,
                           iLBCdec_inst-&gt;ULP_inst-&gt;cb_gain[i][k][ulp]);
                   }
               }
           }
           /* Extract last bit. If it is 1 this indicates an
              empty/lost frame */
           unpack( &amp;pbytes, &amp;last_bit, 1, &amp;pos);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Check for bit errors or empty/lost frames */
           if (start&lt;1)
               mode = 0;
           if (iLBCdec_inst-&gt;mode==20 &amp;&amp; start&gt;3)
               mode = 0;
           if (iLBCdec_inst-&gt;mode==30 &amp;&amp; start&gt;5)
               mode = 0;
           if (last_bit==1)
               mode = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (mode==1) { /* No bit errors was detected,
                             continue decoding */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* adjust index */
               index_conv_dec(cb_index);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* decode the lsf */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               SimplelsfDEQ(lsfdeq, lsf_i, iLBCdec_inst-&gt;lpc_n);
               check=LSF_check(lsfdeq, LPC_FILTERORDER,
                   iLBCdec_inst-&gt;lpc_n);
               DecoderInterpolateLSF(syntdenum, weightdenum,
                   lsfdeq, LPC_FILTERORDER, iLBCdec_inst);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Decode(iLBCdec_inst, decresidual, start, idxForMax, idxVec, syntdenum, cb_index, gain_index, extra_cb_index, extra_gain_index, state_first);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Decode(iLBCdec_inst、decresidual、start、idxForMax、idxVec、syntdenum、cb_index、gain_index、extra_cb_index、extra_gain_index、state_first);
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* preparing the plc for a future loss! */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               doThePLC(PLCresidual, PLClpc, 0, decresidual,
                   syntdenum +
                   (LPC_FILTERORDER + 1)*(iLBCdec_inst-&gt;nsub - 1),
                   (*iLBCdec_inst).last_lag, iLBCdec_inst);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               memcpy(decresidual, PLCresidual,
                   iLBCdec_inst-&gt;blockl*sizeof(float));
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (mode == 0) {
           /* the data is bad (either a PLC call
            * was made or a severe bit error was detected)
            */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* packet loss conceal */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           memset(zeros, 0, BLOCKL_MAX*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           one[0] = 1;
           memset(one+1, 0, LPC_FILTERORDER*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
start=0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
開始=0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           doThePLC(PLCresidual, PLClpc, 1, zeros, one,
               (*iLBCdec_inst).last_lag, iLBCdec_inst);
           memcpy(decresidual, PLCresidual,
               iLBCdec_inst-&gt;blockl*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           order_plus_one = LPC_FILTERORDER + 1;
           for (i = 0; i &lt; iLBCdec_inst-&gt;nsub; i++) {
               memcpy(syntdenum+(i*order_plus_one), PLClpc,
                   order_plus_one*sizeof(float));
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (iLBCdec_inst-&gt;use_enhancer == 1) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* post filtering */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           iLBCdec_inst-&gt;last_lag =
               enhancerInterface(data, decresidual, iLBCdec_inst);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* synthesis filtering */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (iLBCdec_inst-&gt;mode==20) {
               /* Enhancer has 40 samples delay */
               i=0;
               syntFilter(data + i*SUBL,
                   iLBCdec_inst-&gt;old_syntdenum +
                   (i+iLBCdec_inst-&gt;nsub-1)*(LPC_FILTERORDER+1),
                   SUBL, iLBCdec_inst-&gt;syntMem);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               for (i=1; i &lt; iLBCdec_inst-&gt;nsub; i++) {
                   syntFilter(data + i*SUBL,
                       syntdenum + (i-1)*(LPC_FILTERORDER+1),
                       SUBL, iLBCdec_inst-&gt;syntMem);
               }
           } else if (iLBCdec_inst-&gt;mode==30) {
               /* Enhancer has 80 samples delay */
               for (i=0; i &lt; 2; i++) {
                   syntFilter(data + i*SUBL,
                       iLBCdec_inst-&gt;old_syntdenum +
                       (i+iLBCdec_inst-&gt;nsub-2)*(LPC_FILTERORDER+1),
                       SUBL, iLBCdec_inst-&gt;syntMem);
               }
               for (i=2; i &lt; iLBCdec_inst-&gt;nsub; i++) {
                   syntFilter(data + i*SUBL,
                       syntdenum + (i-2)*(LPC_FILTERORDER+1), SUBL,
                       iLBCdec_inst-&gt;syntMem);
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
} else {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
} それ以外 {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Find last lag */
           lag = 20;
           maxcc = xCorrCoef(&amp;decresidual[BLOCKL_MAX-ENH_BLOCKL],
               &amp;decresidual[BLOCKL_MAX-ENH_BLOCKL-lag], ENH_BLOCKL);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (ilag=21; ilag&lt;120; ilag++) {
               cc = xCorrCoef(&amp;decresidual[BLOCKL_MAX-ENH_BLOCKL],
                   &amp;decresidual[BLOCKL_MAX-ENH_BLOCKL-ilag],
                   ENH_BLOCKL);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (cc &gt; maxcc) {
                   maxcc = cc;
                   lag = ilag;
               }
           }
           iLBCdec_inst-&gt;last_lag = lag;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* copy data and run synthesis filter */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           memcpy(data, decresidual,
               iLBCdec_inst-&gt;blockl*sizeof(float));
           for (i=0; i &lt; iLBCdec_inst-&gt;nsub; i++) {
               syntFilter(data + i*SUBL,
                   syntdenum + i*(LPC_FILTERORDER+1), SUBL,
                   iLBCdec_inst-&gt;syntMem);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* high pass filtering on output if desired, otherwise
          copy to out */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       hpOutput(data, iLBCdec_inst-&gt;blockl,
                   decblock,iLBCdec_inst-&gt;hpomem);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* memcpy(decblock,data,iLBCdec_inst-&gt;blockl*sizeof(float));*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
memcpy(iLBCdec_inst-&gt;old_syntdenum, syntdenum,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
memcpy(iLBCdec_inst-&gt;old_syntdenum, syntdenum,
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           iLBCdec_inst-&gt;nsub*(LPC_FILTERORDER+1)*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       iLBCdec_inst-&gt;prev_enh_pl=0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (mode==0) { /* PLC was used */
           iLBCdec_inst-&gt;prev_enh_pl=1;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-6--iLBCdefine-h">
A.6. iLBC_define.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.6. iLBC_define.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC_define.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC_define.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
   #include &lt;string.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_ILBCDEFINE_H #define __iLBC_ILBCDEFINE_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_ILBCDEFINE_H #define __iLBC_ILBCDEFINE_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* general codec settings */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define FS                      (float)8000.0
   #define BLOCKL_20MS             160
   #define BLOCKL_30MS             240
   #define BLOCKL_MAX              240
   #define NSUB_20MS               4
   #define NSUB_30MS               6
   #define NSUB_MAX            6
   #define NASUB_20MS              2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define NASUB_30MS              4
   #define NASUB_MAX               4
   #define SUBL                40
   #define STATE_LEN               80
   #define STATE_SHORT_LEN_30MS    58
   #define STATE_SHORT_LEN_20MS    57
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* LPC settings */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define LPC_FILTERORDER         10
   #define LPC_CHIRP_SYNTDENUM     (float)0.9025
   #define LPC_CHIRP_WEIGHTDENUM   (float)0.4222
   #define LPC_LOOKBACK        60
   #define LPC_N_20MS              1
   #define LPC_N_30MS              2
   #define LPC_N_MAX               2
   #define LPC_ASYMDIFF        20
   #define LPC_BW                  (float)60.0
   #define LPC_WN                  (float)1.0001
   #define LSF_NSPLIT              3
   #define LSF_NUMBER_OF_STEPS     4
   #define LPC_HALFORDER           (LPC_FILTERORDER/2)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* cb settings */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define CB_NSTAGES              3
   #define CB_EXPAND               2
   #define CB_MEML                 147
   #define CB_FILTERLEN        2*4
   #define CB_HALFFILTERLEN    4
   #define CB_RESRANGE             34
   #define CB_MAXGAIN              (float)1.3
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* enhancer */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define ENH_BLOCKL              80  /* block length */
   #define ENH_BLOCKL_HALF         (ENH_BLOCKL/2)
   #define ENH_HL                  3   /* 2*ENH_HL+1 is number blocks
                                          in said second sequence */
   #define ENH_SLOP            2   /* max difference estimated and
                                          correct pitch period */
   #define ENH_PLOCSL              20  /* pitch-estimates and pitch-
                                          locations buffer length */
   #define ENH_OVERHANG        2
   #define ENH_UPS0            4   /* upsampling rate */
   #define ENH_FL0                 3   /* 2*FLO+1 is the length of
                                          each filter */
   #define ENH_VECTL               (ENH_BLOCKL+2*ENH_FL0)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define ENH_CORRDIM             (2*ENH_SLOP+1)
   #define ENH_NBLOCKS             (BLOCKL_MAX/ENH_BLOCKL)
   #define ENH_NBLOCKS_EXTRA       5
   #define ENH_NBLOCKS_TOT         8   /* ENH_NBLOCKS +
                                          ENH_NBLOCKS_EXTRA */
   #define ENH_BUFL            (ENH_NBLOCKS_TOT)*ENH_BLOCKL
   #define ENH_ALPHA0              (float)0.05
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Down sampling */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define FILTERORDER_DS          7
   #define DELAY_DS            3
   #define FACTOR_DS               2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* bit stream defs */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define NO_OF_BYTES_20MS    38
   #define NO_OF_BYTES_30MS    50
   #define NO_OF_WORDS_20MS    19
   #define NO_OF_WORDS_30MS    25
   #define STATE_BITS              3
   #define BYTE_LEN            8
   #define ULP_CLASSES             3
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* help parameters */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define FLOAT_MAX (float)1.0e37 #define EPS (float)2.220446049250313e-016 #define PI (float)3.14159265358979323846 #define MIN_SAMPLE -32768 #define MAX_SAMPLE 32767 #define TWO_PI (float)6.283185307 #define PI2 (float)0.159154943
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define FLOAT_MAX (float)1.0e37 #define EPS (float)2.220446049250313e-016 #define PI (float)3.14159265358979323846 #define MIN_SAMPLE -32768 #define MAX_SAMPLE 32767 #define TWO_PI (fフロート)6.283185307 #define PI2 (フロート)0.159154943
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* type definition encoder instance */
   typedef struct iLBC_ULP_Inst_t_ {
       int lsf_bits[6][ULP_CLASSES+2];
       int start_bits[ULP_CLASSES+2];
       int startfirst_bits[ULP_CLASSES+2];
       int scale_bits[ULP_CLASSES+2];
       int state_bits[ULP_CLASSES+2];
       int extra_cb_index[CB_NSTAGES][ULP_CLASSES+2];
       int extra_cb_gain[CB_NSTAGES][ULP_CLASSES+2];
       int cb_index[NSUB_MAX][CB_NSTAGES][ULP_CLASSES+2];
       int cb_gain[NSUB_MAX][CB_NSTAGES][ULP_CLASSES+2];
   } iLBC_ULP_Inst_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* type definition encoder instance */
      typedef struct iLBC_Enc_Inst_t_ {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* flag for frame size mode */
       int mode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* basic parameters for different frame sizes */
       int blockl;
       int nsub;
       int nasub;
       int no_of_bytes, no_of_words;
       int lpc_n;
       int state_short_len;
       const iLBC_ULP_Inst_t *ULP_inst;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* analysis filter state */
       float anaMem[LPC_FILTERORDER];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* old lsf parameters for interpolation */
       float lsfold[LPC_FILTERORDER];
       float lsfdeqold[LPC_FILTERORDER];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* signal buffer for LP analysis */
       float lpc_buffer[LPC_LOOKBACK + BLOCKL_MAX];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* state of input HP filter */
       float hpimem[4];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
} iLBC_Enc_Inst_t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iLBC_Enc_Inst_t;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* type definition decoder instance */
   typedef struct iLBC_Dec_Inst_t_ {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* flag for frame size mode */
       int mode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* basic parameters for different frame sizes */
       int blockl;
       int nsub;
       int nasub;
       int no_of_bytes, no_of_words;
       int lpc_n;
       int state_short_len;
       const iLBC_ULP_Inst_t *ULP_inst;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* synthesis filter state */
       float syntMem[LPC_FILTERORDER];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* old LSF for interpolation */
              float lsfdeqold[LPC_FILTERORDER];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* pitch lag estimated in enhancer and used in PLC */
       int last_lag;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* PLC state information */
       int prevLag, consPLICount, prevPLI, prev_enh_pl;
       float prevLpc[LPC_FILTERORDER+1];
       float prevResidual[NSUB_MAX*SUBL];
       float per;
       unsigned long seed;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* previous synthesis filter parameters */
       float old_syntdenum[(LPC_FILTERORDER + 1)*NSUB_MAX];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* state of output HP filter */
       float hpomem[4];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* enhancer state information */
       int use_enhancer;
       float enh_buf[ENH_BUFL];
       float enh_period[ENH_NBLOCKS_TOT];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
} iLBC_Dec_Inst_t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iLBC_Dec_Inst_t;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-7--constants-h">
A.7. constants.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.7. 定数.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
constants.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
定数.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_CONSTANTS_H #define __iLBC_CONSTANTS_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_CONSTANTS_H #define __iLBC_CONSTANTS_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* ULP bit allocation */
      extern const iLBC_ULP_Inst_t ULP_20msTbl;
   extern const iLBC_ULP_Inst_t ULP_30msTbl;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* high pass filters */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   extern float hpi_zero_coefsTbl[];
   extern float hpi_pole_coefsTbl[];
   extern float hpo_zero_coefsTbl[];
   extern float hpo_pole_coefsTbl[];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* low pass filters */
   extern float lpFilt_coefsTbl[];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* LPC analysis and quantization */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   extern float lpc_winTbl[];
   extern float lpc_asymwinTbl[];
   extern float lpc_lagwinTbl[];
   extern float lsfCbTbl[];
   extern float lsfmeanTbl[];
   extern int   dim_lsfCbTbl[];
   extern int   size_lsfCbTbl[];
   extern float lsf_weightTbl_30ms[];
   extern float lsf_weightTbl_20ms[];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* state quantization tables */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
extern float state_sq3Tbl[]; extern float state_frgqTbl[];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
extern float state_sq3Tbl[];extern float state_frgqTbl[];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* gain quantization tables */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   extern float gain_sq3Tbl[];
   extern float gain_sq4Tbl[];
   extern float gain_sq5Tbl[];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* adaptive codebook definitions */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   extern int search_rangeTbl[5][CB_NSTAGES];
   extern int memLfTbl[];
   extern int stMemLTbl;
   extern float cbfiltersTbl[CB_FILTERLEN];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* enhancer definitions */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
extern float polyphaserTbl[]; extern float enh_plocsTbl[];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
extern float ポリフェイザーTbl[];extern float enh_plocsTbl[];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-8--constants-c">
A.8. constants.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.8. 定数.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
constants.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
定数.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* ULP bit allocation */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* 20 ms frame */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const iLBC_ULP_Inst_t ULP_20msTbl = {
       /* LSF */
       {   {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0},
           {0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},
       /* Start state location, gain and samples */
       {2,0,0,0,0},
       {1,0,0,0,0},
       {6,0,0,0,0},
       {0,1,2,0,0},
       /* extra CB index and extra CB gain */
       {{6,0,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},
       {{2,0,3,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},
       /* CB index and CB gain */
       {   {{7,0,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},
           {{0,0,8,0,0}, {0,0,8,0,0}, {0,0,8,0,0}},
           {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},
           {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}}},
       {   {{1,2,2,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},
           {{1,1,3,0,0}, {0,2,2,0,0}, {0,0,3,0,0}},
           {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},
           {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}}}
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* 30 ms frame */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const iLBC_ULP_Inst_t ULP_30msTbl = {
       /* LSF */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       {   {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0},
           {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0}},
       /* Start state location, gain and samples */
       {3,0,0,0,0},
       {1,0,0,0,0},
       {6,0,0,0,0},
       {0,1,2,0,0},
       /* extra CB index and extra CB gain */
       {{4,2,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},
       {{1,1,3,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},
       /* CB index and CB gain */
       {   {{6,1,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},
           {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}},
           {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}},
           {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}}},
       {   {{1,2,2,0,0}, {1,2,1,0,0}, {0,0,3,0,0}},
           {{0,2,3,0,0}, {0,2,2,0,0}, {0,0,3,0,0}},
           {{0,1,4,0,0}, {0,1,3,0,0}, {0,0,3,0,0}},
           {{0,1,4,0,0}, {0,1,3,0,0}, {0,0,3,0,0}}}
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* HP Filters */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   float hpi_zero_coefsTbl[3] = {
       (float)0.92727436, (float)-1.8544941, (float)0.92727436
   };
   float hpi_pole_coefsTbl[3] = {
       (float)1.0, (float)-1.9059465, (float)0.9114024
   };
   float hpo_zero_coefsTbl[3] = {
       (float)0.93980581, (float)-1.8795834, (float)0.93980581
   };
   float hpo_pole_coefsTbl[3] = {
       (float)1.0, (float)-1.9330735, (float)0.93589199
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* LP Filter */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
float lpFilt_coefsTbl[FILTERORDER_DS]={ (float)-0.066650, (float)0.125000, (float)0.316650, (float)0.414063, (float)0.316650, (float)0.125000, (float)-0.066650 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
float lpFilt_coefsTbl[FILTERORDER_DS]={ (float)-0.066650, (float)0.125000, (float)0.316650, (float)0.414063, (float)0.316650, (float)0.125000, (float)-0.066650 };
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* State quantization tables */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   float state_sq3Tbl[8] = {
       (float)-3.719849, (float)-2.177490, (float)-1.130005,
          (float)-0.309692, (float)0.444214, (float)1.329712,
       (float)2.436279, (float)3.983887
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   float state_frgqTbl[64] = {
       (float)1.000085, (float)1.071695, (float)1.140395,
       (float)1.206868, (float)1.277188, (float)1.351503,
       (float)1.429380, (float)1.500727, (float)1.569049,
       (float)1.639599, (float)1.707071, (float)1.781531,
       (float)1.840799, (float)1.901550, (float)1.956695,
       (float)2.006750, (float)2.055474, (float)2.102787,
       (float)2.142819, (float)2.183592, (float)2.217962,
       (float)2.257177, (float)2.295739, (float)2.332967,
       (float)2.369248, (float)2.402792, (float)2.435080,
       (float)2.468598, (float)2.503394, (float)2.539284,
       (float)2.572944, (float)2.605036, (float)2.636331,
       (float)2.668939, (float)2.698780, (float)2.729101,
       (float)2.759786, (float)2.789834, (float)2.818679,
       (float)2.848074, (float)2.877470, (float)2.906899,
       (float)2.936655, (float)2.967804, (float)3.000115,
       (float)3.033367, (float)3.066355, (float)3.104231,
       (float)3.141499, (float)3.183012, (float)3.222952,
       (float)3.265433, (float)3.308441, (float)3.350823,
       (float)3.395275, (float)3.442793, (float)3.490801,
       (float)3.542514, (float)3.604064, (float)3.666050,
       (float)3.740994, (float)3.830749, (float)3.938770,
       (float)4.101764
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* CB tables */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int search_rangeTbl[5][CB_NSTAGES]={{58,58,58}, {108,44,44},
               {108,108,108}, {108,108,108}, {108,108,108}};
   int stMemLTbl=85;
   int memLfTbl[NASUB_MAX]={147,147,147,147};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* expansion filter(s) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
float cbfiltersTbl[CB_FILTERLEN]={ (float)-0.034180, (float)0.108887, (float)-0.184326, (float)0.806152, (float)0.713379, (float)-0.144043, (float)0.083740, (float)-0.033691 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
float cbfiltersTbl[CB_FILTERLEN]={ (float)-0.034180, (float)0.108887, (float)-0.184326, (float)0.806152, (float)0.713379, (float)-0.144043, (float)0.083740, (flo) at)-0.033691};
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Gain Quantization */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
float gain_sq3Tbl[8]={ (float)-1.000000, (float)-0.659973, (float)-0.330017, (float)0.000000, (float)0.250000, (float)0.500000, (float)0.750000, (float)1.00000};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
float Gain_sq3Tbl[8]={ (float)-1.000000, (float)-0.659973, (float)-0.330017, (float)0.000000, (float)0.250000, (float)0.500000, (float)0.750000, (float)1.0 0000};
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
float gain_sq4Tbl[16]={ (float)-1.049988, (float)-0.900024, (float)-0.750000, (float)-0.599976, (float)-0.450012, (float)-0.299988, (float)-0.150024, (float)0.000000, (float)0.150024, (float)0.299988, (float)0.450012, (float)0.599976, (float)0.750000, (float)0.900024, (float)1.049988, (float)1.200012};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
float Gain_sq4Tbl[16]={ (float)-1.049988, (float)-0.900024, (float)-0.750000, (float)-0.599976, (float)-0.450012, (float)-0.299988, (float)-0.150024, (浮動小数点)0.000000、(浮動小数点)0.150024、(浮動小数点)0.299988、(浮動小数点)0.450012、(浮動小数点)0.599976、(浮動小数点)0.750000、(浮動小数点)0.900024、(浮動小数点)1.049988、(浮動小数点)1.200012 };
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
float gain_sq5Tbl[32]={ (float)0.037476, (float)0.075012, (float)0.112488, (float)0.150024, (float)0.187500, (float)0.224976, (float)0.262512, (float)0.299988, (float)0.337524, (float)0.375000, (float)0.412476, (float)0.450012, (float)0.487488, (float)0.525024, (float)0.562500, (float)0.599976, (float)0.637512, (float)0.674988, (float)0.712524, (float)0.750000, (float)0.787476, (float)0.825012, (float)0.862488, (float)0.900024, (float)0.937500, (float)0.974976, (float)1.012512, (float)1.049988, (float)1.087524, (float)1.125000, (float)1.162476, (float)1.200012};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
float Gain_sq5Tbl[32]={ (浮動小数点)0.037476, (浮動小数点)0.075012, (浮動小数点)0.112488, (浮動小数点)0.150024, (浮動小数点)0.187500, (浮動小数点)0.224976, (浮動小数点)0.262512, (浮動小数点)0.299 988、(浮動小数点数)0.337524、（浮動小数点）0.375000、（浮動小数点）0.412476、（浮動小数点）0.450012、（浮動小数点）0.487488、（浮動小数点）0.525024、（浮動小数点）0.562500、（浮動小数点）0.599976、（浮動小数点）0.637512、 (浮動小数点)0.674988、(浮動小数点)0.712524、（浮動小数点）0.750000、（浮動小数点）0.787476、（浮動小数点）0.825012、（浮動小数点）0.862488、（浮動小数点）0.900024、（浮動小数点）0.937500、（浮動小数点）0.974976、（浮動小数点）1.012512、 (浮動小数点)1.049988、(浮動小数点)1.087524、(浮動小数点)1.125000、(浮動小数点)1.162476、(浮動小数点)1.200012};
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Enhancer - Upsamling a factor 4 (ENH_UPS0 = 4) */
   float polyphaserTbl[ENH_UPS0*(2*ENH_FL0+1)]={
       (float)0.000000, (float)0.000000, (float)0.000000,
   (float)1.000000,
           (float)0.000000, (float)0.000000, (float)0.000000,
       (float)0.015625, (float)-0.076904, (float)0.288330,
   (float)0.862061,
           (float)-0.106445, (float)0.018799, (float)-0.015625,
       (float)0.023682, (float)-0.124268, (float)0.601563,
   (float)0.601563,
           (float)-0.124268, (float)0.023682, (float)-0.023682,
       (float)0.018799, (float)-0.106445, (float)0.862061,
   (float)0.288330,
           (float)-0.076904, (float)0.015625, (float)-0.018799};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   float enh_plocsTbl[ENH_NBLOCKS_TOT] = {(float)40.0, (float)120.0,
               (float)200.0, (float)280.0, (float)360.0,
               (float)440.0, (float)520.0, (float)600.0};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* LPC analysis and quantization */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int dim_lsfCbTbl[LSF_NSPLIT] = {3, 3, 4};
   int size_lsfCbTbl[LSF_NSPLIT] = {64,128,128};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   float lsfmeanTbl[LPC_FILTERORDER] = {
       (float)0.281738, (float)0.445801, (float)0.663330,
       (float)0.962524, (float)1.251831, (float)1.533081,
       (float)1.850586, (float)2.137817, (float)2.481445,
       (float)2.777344};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   float lsf_weightTbl_30ms[6] = {(float)(1.0/2.0), (float)1.0,
   (float)(2.0/3.0),
       (float)(1.0/3.0), (float)0.0, (float)0.0};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   float lsf_weightTbl_20ms[4] = {(float)(3.0/4.0), (float)(2.0/4.0),
       (float)(1.0/4.0), (float)(0.0)};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Hanning LPC window */
   float lpc_winTbl[BLOCKL_MAX]={
       (float)0.000183, (float)0.000671, (float)0.001526,
       (float)0.002716, (float)0.004242, (float)0.006104,
       (float)0.008301, (float)0.010834, (float)0.013702,
       (float)0.016907, (float)0.020416, (float)0.024261,
       (float)0.028442, (float)0.032928, (float)0.037750,
       (float)0.042877, (float)0.048309, (float)0.054047,
       (float)0.060089, (float)0.066437, (float)0.073090,
       (float)0.080017, (float)0.087219, (float)0.094727,
       (float)0.102509, (float)0.110535, (float)0.118835,
       (float)0.127411, (float)0.136230, (float)0.145294,
       (float)0.154602, (float)0.164154, (float)0.173920,
       (float)0.183899, (float)0.194122, (float)0.204529,
       (float)0.215149, (float)0.225952, (float)0.236938,
       (float)0.248108, (float)0.259460, (float)0.270966,
       (float)0.282654, (float)0.294464, (float)0.306396,
       (float)0.318481, (float)0.330688, (float)0.343018,
       (float)0.355438, (float)0.367981, (float)0.380585,
       (float)0.393280, (float)0.406067, (float)0.418884,
       (float)0.431763, (float)0.444702, (float)0.457672,
       (float)0.470673, (float)0.483704, (float)0.496735,
       (float)0.509766, (float)0.522797, (float)0.535828,
       (float)0.548798, (float)0.561768, (float)0.574677,
       (float)0.587524, (float)0.600342, (float)0.613068,
       (float)0.625732, (float)0.638306, (float)0.650787,
       (float)0.663147, (float)0.675415, (float)0.687561,
       (float)0.699585, (float)0.711487, (float)0.723206,
       (float)0.734802, (float)0.746216, (float)0.757477,
       (float)0.768585, (float)0.779480, (float)0.790192,
       (float)0.800720, (float)0.811005, (float)0.821106,
       (float)0.830994, (float)0.840668, (float)0.850067,
       (float)0.859253, (float)0.868225, (float)0.876892,
       (float)0.885345, (float)0.893524, (float)0.901428,
       (float)0.909058, (float)0.916412, (float)0.923492,
          (float)0.930267, (float)0.936768, (float)0.942963,
       (float)0.948853, (float)0.954437, (float)0.959717,
       (float)0.964691, (float)0.969360, (float)0.973694,
       (float)0.977692, (float)0.981384, (float)0.984741,
       (float)0.987762, (float)0.990479, (float)0.992828,
       (float)0.994873, (float)0.996552, (float)0.997925,
       (float)0.998932, (float)0.999603, (float)0.999969,
       (float)0.999969, (float)0.999603, (float)0.998932,
       (float)0.997925, (float)0.996552, (float)0.994873,
       (float)0.992828, (float)0.990479, (float)0.987762,
       (float)0.984741, (float)0.981384, (float)0.977692,
       (float)0.973694, (float)0.969360, (float)0.964691,
       (float)0.959717, (float)0.954437, (float)0.948853,
       (float)0.942963, (float)0.936768, (float)0.930267,
       (float)0.923492, (float)0.916412, (float)0.909058,
       (float)0.901428, (float)0.893524, (float)0.885345,
       (float)0.876892, (float)0.868225, (float)0.859253,
       (float)0.850067, (float)0.840668, (float)0.830994,
       (float)0.821106, (float)0.811005, (float)0.800720,
       (float)0.790192, (float)0.779480, (float)0.768585,
       (float)0.757477, (float)0.746216, (float)0.734802,
       (float)0.723206, (float)0.711487, (float)0.699585,
       (float)0.687561, (float)0.675415, (float)0.663147,
       (float)0.650787, (float)0.638306, (float)0.625732,
       (float)0.613068, (float)0.600342, (float)0.587524,
       (float)0.574677, (float)0.561768, (float)0.548798,
       (float)0.535828, (float)0.522797, (float)0.509766,
       (float)0.496735, (float)0.483704, (float)0.470673,
       (float)0.457672, (float)0.444702, (float)0.431763,
       (float)0.418884, (float)0.406067, (float)0.393280,
       (float)0.380585, (float)0.367981, (float)0.355438,
       (float)0.343018, (float)0.330688, (float)0.318481,
       (float)0.306396, (float)0.294464, (float)0.282654,
       (float)0.270966, (float)0.259460, (float)0.248108,
       (float)0.236938, (float)0.225952, (float)0.215149,
       (float)0.204529, (float)0.194122, (float)0.183899,
       (float)0.173920, (float)0.164154, (float)0.154602,
       (float)0.145294, (float)0.136230, (float)0.127411,
       (float)0.118835, (float)0.110535, (float)0.102509,
       (float)0.094727, (float)0.087219, (float)0.080017,
       (float)0.073090, (float)0.066437, (float)0.060089,
       (float)0.054047, (float)0.048309, (float)0.042877,
       (float)0.037750, (float)0.032928, (float)0.028442,
       (float)0.024261, (float)0.020416, (float)0.016907,
       (float)0.013702, (float)0.010834, (float)0.008301,
       (float)0.006104, (float)0.004242, (float)0.002716,
       (float)0.001526, (float)0.000671, (float)0.000183
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Asymmetric LPC window */
   float lpc_asymwinTbl[BLOCKL_MAX]={
       (float)0.000061, (float)0.000214, (float)0.000458,
       (float)0.000824, (float)0.001282, (float)0.001831,
       (float)0.002472, (float)0.003235, (float)0.004120,
       (float)0.005066, (float)0.006134, (float)0.007294,
       (float)0.008545, (float)0.009918, (float)0.011383,
       (float)0.012939, (float)0.014587, (float)0.016357,
       (float)0.018219, (float)0.020172, (float)0.022217,
       (float)0.024353, (float)0.026611, (float)0.028961,
       (float)0.031372, (float)0.033905, (float)0.036530,
       (float)0.039276, (float)0.042084, (float)0.044983,
       (float)0.047974, (float)0.051086, (float)0.054260,
       (float)0.057526, (float)0.060883, (float)0.064331,
       (float)0.067871, (float)0.071503, (float)0.075226,
       (float)0.079010, (float)0.082916, (float)0.086884,
       (float)0.090942, (float)0.095062, (float)0.099304,
       (float)0.103607, (float)0.107971, (float)0.112427,
       (float)0.116974, (float)0.121582, (float)0.126282,
       (float)0.131073, (float)0.135895, (float)0.140839,
       (float)0.145813, (float)0.150879, (float)0.156006,
       (float)0.161224, (float)0.166504, (float)0.171844,
       (float)0.177246, (float)0.182709, (float)0.188263,
       (float)0.193848, (float)0.199524, (float)0.205231,
       (float)0.211029, (float)0.216858, (float)0.222778,
       (float)0.228729, (float)0.234741, (float)0.240814,
       (float)0.246918, (float)0.253082, (float)0.259308,
       (float)0.265564, (float)0.271881, (float)0.278259,
       (float)0.284668, (float)0.291107, (float)0.297607,
       (float)0.304138, (float)0.310730, (float)0.317322,
       (float)0.323975, (float)0.330658, (float)0.337372,
       (float)0.344147, (float)0.350922, (float)0.357727,
       (float)0.364594, (float)0.371460, (float)0.378357,
       (float)0.385284, (float)0.392212, (float)0.399170,
       (float)0.406158, (float)0.413177, (float)0.420197,
       (float)0.427246, (float)0.434296, (float)0.441376,
       (float)0.448456, (float)0.455536, (float)0.462646,
       (float)0.469757, (float)0.476868, (float)0.483978,
       (float)0.491089, (float)0.498230, (float)0.505341,
       (float)0.512451, (float)0.519592, (float)0.526703,
       (float)0.533813, (float)0.540924, (float)0.548004,
       (float)0.555084, (float)0.562164, (float)0.569244,
       (float)0.576294, (float)0.583313, (float)0.590332,
       (float)0.597321, (float)0.604309, (float)0.611267,
       (float)0.618195, (float)0.625092, (float)0.631989,
       (float)0.638855, (float)0.645660, (float)0.652466,
       (float)0.659241, (float)0.665985, (float)0.672668,
       (float)0.679352, (float)0.685974, (float)0.692566,
          (float)0.699127, (float)0.705658, (float)0.712128,
       (float)0.718536, (float)0.724945, (float)0.731262,
       (float)0.737549, (float)0.743805, (float)0.750000,
       (float)0.756134, (float)0.762238, (float)0.768280,
       (float)0.774261, (float)0.780182, (float)0.786072,
       (float)0.791870, (float)0.797638, (float)0.803314,
       (float)0.808960, (float)0.814514, (float)0.820038,
       (float)0.825470, (float)0.830841, (float)0.836151,
       (float)0.841400, (float)0.846558, (float)0.851654,
       (float)0.856689, (float)0.861633, (float)0.866516,
       (float)0.871338, (float)0.876068, (float)0.880737,
       (float)0.885315, (float)0.889801, (float)0.894226,
       (float)0.898560, (float)0.902832, (float)0.907013,
       (float)0.911102, (float)0.915100, (float)0.919037,
       (float)0.922882, (float)0.926636, (float)0.930328,
       (float)0.933899, (float)0.937408, (float)0.940796,
       (float)0.944122, (float)0.947357, (float)0.950470,
       (float)0.953522, (float)0.956482, (float)0.959351,
       (float)0.962097, (float)0.964783, (float)0.967377,
       (float)0.969849, (float)0.972229, (float)0.974518,
       (float)0.976715, (float)0.978821, (float)0.980835,
       (float)0.982727, (float)0.984528, (float)0.986237,
       (float)0.987854, (float)0.989380, (float)0.990784,
       (float)0.992096, (float)0.993317, (float)0.994415,
       (float)0.995422, (float)0.996338, (float)0.997162,
       (float)0.997864, (float)0.998474, (float)0.998962,
       (float)0.999390, (float)0.999695, (float)0.999878,
       (float)0.999969, (float)0.999969, (float)0.996918,
       (float)0.987701, (float)0.972382, (float)0.951050,
       (float)0.923889, (float)0.891022, (float)0.852631,
       (float)0.809021, (float)0.760406, (float)0.707092,
       (float)0.649445, (float)0.587799, (float)0.522491,
       (float)0.453979, (float)0.382690, (float)0.309021,
       (float)0.233459, (float)0.156433, (float)0.078461
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Lag window for LPC */
   float lpc_lagwinTbl[LPC_FILTERORDER + 1]={
       (float)1.000100, (float)0.998890, (float)0.995569,
           (float)0.990057, (float)0.982392,
       (float)0.972623, (float)0.960816, (float)0.947047,
           (float)0.931405, (float)0.913989, (float)0.894909};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* LSF quantization*/
   float lsfCbTbl[64 * 3 + 128 * 3 + 128 * 4] = {
   (float)0.155396, (float)0.273193, (float)0.451172,
   (float)0.390503, (float)0.648071, (float)1.002075,
   (float)0.440186, (float)0.692261, (float)0.955688,
      (float)0.343628, (float)0.642334, (float)1.071533,
   (float)0.318359, (float)0.491577, (float)0.670532,
   (float)0.193115, (float)0.375488, (float)0.725708,
   (float)0.364136, (float)0.510376, (float)0.658691,
   (float)0.297485, (float)0.527588, (float)0.842529,
   (float)0.227173, (float)0.365967, (float)0.563110,
   (float)0.244995, (float)0.396729, (float)0.636475,
   (float)0.169434, (float)0.300171, (float)0.520264,
   (float)0.312866, (float)0.464478, (float)0.643188,
   (float)0.248535, (float)0.429932, (float)0.626099,
   (float)0.236206, (float)0.491333, (float)0.817139,
   (float)0.334961, (float)0.625122, (float)0.895752,
   (float)0.343018, (float)0.518555, (float)0.698608,
   (float)0.372803, (float)0.659790, (float)0.945435,
   (float)0.176880, (float)0.316528, (float)0.581421,
   (float)0.416382, (float)0.625977, (float)0.805176,
   (float)0.303223, (float)0.568726, (float)0.915039,
   (float)0.203613, (float)0.351440, (float)0.588135,
   (float)0.221191, (float)0.375000, (float)0.614746,
   (float)0.199951, (float)0.323364, (float)0.476074,
   (float)0.300781, (float)0.433350, (float)0.566895,
   (float)0.226196, (float)0.354004, (float)0.507568,
   (float)0.300049, (float)0.508179, (float)0.711670,
   (float)0.312012, (float)0.492676, (float)0.763428,
   (float)0.329956, (float)0.541016, (float)0.795776,
   (float)0.373779, (float)0.604614, (float)0.928833,
   (float)0.210571, (float)0.452026, (float)0.755249,
   (float)0.271118, (float)0.473267, (float)0.662476,
   (float)0.285522, (float)0.436890, (float)0.634399,
   (float)0.246704, (float)0.565552, (float)0.859009,
   (float)0.270508, (float)0.406250, (float)0.553589,
   (float)0.361450, (float)0.578491, (float)0.813843,
   (float)0.342651, (float)0.482788, (float)0.622437,
   (float)0.340332, (float)0.549438, (float)0.743164,
   (float)0.200439, (float)0.336304, (float)0.540894,
   (float)0.407837, (float)0.644775, (float)0.895142,
   (float)0.294678, (float)0.454834, (float)0.699097,
   (float)0.193115, (float)0.344482, (float)0.643188,
   (float)0.275757, (float)0.420776, (float)0.598755,
   (float)0.380493, (float)0.608643, (float)0.861084,
   (float)0.222778, (float)0.426147, (float)0.676514,
   (float)0.407471, (float)0.700195, (float)1.053101,
   (float)0.218384, (float)0.377197, (float)0.669922,
   (float)0.313232, (float)0.454102, (float)0.600952,
   (float)0.347412, (float)0.571533, (float)0.874146,
   (float)0.238037, (float)0.405396, (float)0.729492,
   (float)0.223877, (float)0.412964, (float)0.822021,
   (float)0.395264, (float)0.582153, (float)0.743896,
      (float)0.247925, (float)0.485596, (float)0.720581,
   (float)0.229126, (float)0.496582, (float)0.907715,
   (float)0.260132, (float)0.566895, (float)1.012695,
   (float)0.337402, (float)0.611572, (float)0.978149,
   (float)0.267822, (float)0.447632, (float)0.769287,
   (float)0.250610, (float)0.381714, (float)0.530029,
   (float)0.430054, (float)0.805054, (float)1.221924,
   (float)0.382568, (float)0.544067, (float)0.701660,
   (float)0.383545, (float)0.710327, (float)1.149170,
   (float)0.271362, (float)0.529053, (float)0.775513,
   (float)0.246826, (float)0.393555, (float)0.588623,
   (float)0.266846, (float)0.422119, (float)0.676758,
   (float)0.311523, (float)0.580688, (float)0.838623,
   (float)1.331177, (float)1.576782, (float)1.779541,
   (float)1.160034, (float)1.401978, (float)1.768188,
   (float)1.161865, (float)1.525146, (float)1.715332,
   (float)0.759521, (float)0.913940, (float)1.119873,
   (float)0.947144, (float)1.121338, (float)1.282471,
   (float)1.015015, (float)1.557007, (float)1.804932,
   (float)1.172974, (float)1.402100, (float)1.692627,
   (float)1.087524, (float)1.474243, (float)1.665405,
   (float)0.899536, (float)1.105225, (float)1.406250,
   (float)1.148438, (float)1.484741, (float)1.796265,
   (float)0.785645, (float)1.209839, (float)1.567749,
   (float)0.867798, (float)1.166504, (float)1.450684,
   (float)0.922485, (float)1.229858, (float)1.420898,
   (float)0.791260, (float)1.123291, (float)1.409546,
   (float)0.788940, (float)0.966064, (float)1.340332,
   (float)1.051147, (float)1.272827, (float)1.556641,
   (float)0.866821, (float)1.181152, (float)1.538818,
   (float)0.906738, (float)1.373535, (float)1.607910,
   (float)1.244751, (float)1.581421, (float)1.933838,
   (float)0.913940, (float)1.337280, (float)1.539673,
   (float)0.680542, (float)0.959229, (float)1.662720,
   (float)0.887207, (float)1.430542, (float)1.800781,
   (float)0.912598, (float)1.433594, (float)1.683960,
   (float)0.860474, (float)1.060303, (float)1.455322,
   (float)1.005127, (float)1.381104, (float)1.706909,
   (float)0.800781, (float)1.363892, (float)1.829102,
   (float)0.781860, (float)1.124390, (float)1.505981,
   (float)1.003662, (float)1.471436, (float)1.684692,
   (float)0.981323, (float)1.309570, (float)1.618042,
   (float)1.228760, (float)1.554321, (float)1.756470,
   (float)0.734375, (float)0.895752, (float)1.225586,
   (float)0.841797, (float)1.055664, (float)1.249268,
   (float)0.920166, (float)1.119385, (float)1.486206,
   (float)0.894409, (float)1.539063, (float)1.828979,
   (float)1.283691, (float)1.543335, (float)1.858276,
      (float)0.676025, (float)0.933105, (float)1.490845,
   (float)0.821289, (float)1.491821, (float)1.739868,
   (float)0.923218, (float)1.144653, (float)1.580566,
   (float)1.057251, (float)1.345581, (float)1.635864,
   (float)0.888672, (float)1.074951, (float)1.353149,
   (float)0.942749, (float)1.195435, (float)1.505493,
   (float)1.492310, (float)1.788086, (float)2.039673,
   (float)1.070313, (float)1.634399, (float)1.860962,
   (float)1.253296, (float)1.488892, (float)1.686035,
   (float)0.647095, (float)0.864014, (float)1.401855,
   (float)0.866699, (float)1.254883, (float)1.453369,
   (float)1.063965, (float)1.532593, (float)1.731323,
   (float)1.167847, (float)1.521484, (float)1.884033,
   (float)0.956055, (float)1.502075, (float)1.745605,
   (float)0.928711, (float)1.288574, (float)1.479614,
   (float)1.088013, (float)1.380737, (float)1.570801,
   (float)0.905029, (float)1.186768, (float)1.371948,
   (float)1.057861, (float)1.421021, (float)1.617432,
   (float)1.108276, (float)1.312500, (float)1.501465,
   (float)0.979492, (float)1.416992, (float)1.624268,
   (float)1.276001, (float)1.661011, (float)2.007935,
   (float)0.993042, (float)1.168579, (float)1.331665,
   (float)0.778198, (float)0.944946, (float)1.235962,
   (float)1.223755, (float)1.491333, (float)1.815674,
   (float)0.852661, (float)1.350464, (float)1.722290,
   (float)1.134766, (float)1.593140, (float)1.787354,
   (float)1.051392, (float)1.339722, (float)1.531006,
   (float)0.803589, (float)1.271240, (float)1.652100,
   (float)0.755737, (float)1.143555, (float)1.639404,
   (float)0.700928, (float)0.837280, (float)1.130371,
   (float)0.942749, (float)1.197876, (float)1.669800,
   (float)0.993286, (float)1.378296, (float)1.566528,
   (float)0.801025, (float)1.095337, (float)1.298950,
   (float)0.739990, (float)1.032959, (float)1.383667,
   (float)0.845703, (float)1.072266, (float)1.543823,
   (float)0.915649, (float)1.072266, (float)1.224487,
   (float)1.021973, (float)1.226196, (float)1.481323,
   (float)0.999878, (float)1.204102, (float)1.555908,
   (float)0.722290, (float)0.913940, (float)1.340210,
   (float)0.673340, (float)0.835938, (float)1.259521,
   (float)0.832397, (float)1.208374, (float)1.394165,
   (float)0.962158, (float)1.576172, (float)1.912842,
   (float)1.166748, (float)1.370850, (float)1.556763,
   (float)0.946289, (float)1.138550, (float)1.400391,
   (float)1.035034, (float)1.218262, (float)1.386475,
   (float)1.393799, (float)1.717773, (float)2.000244,
   (float)0.972656, (float)1.260986, (float)1.760620,
   (float)1.028198, (float)1.288452, (float)1.484619,
      (float)0.773560, (float)1.258057, (float)1.756714,
   (float)1.080322, (float)1.328003, (float)1.742676,
   (float)0.823975, (float)1.450806, (float)1.917725,
   (float)0.859009, (float)1.016602, (float)1.191895,
   (float)0.843994, (float)1.131104, (float)1.645020,
   (float)1.189697, (float)1.702759, (float)1.894409,
   (float)1.346680, (float)1.763184, (float)2.066040,
   (float)0.980469, (float)1.253784, (float)1.441650,
   (float)1.338135, (float)1.641968, (float)1.932739,
   (float)1.223267, (float)1.424194, (float)1.626465,
   (float)0.765747, (float)1.004150, (float)1.579102,
   (float)1.042847, (float)1.269165, (float)1.647461,
   (float)0.968750, (float)1.257568, (float)1.555786,
   (float)0.826294, (float)0.993408, (float)1.275146,
   (float)0.742310, (float)0.950439, (float)1.430542,
   (float)1.054321, (float)1.439819, (float)1.828003,
   (float)1.072998, (float)1.261719, (float)1.441895,
   (float)0.859375, (float)1.036377, (float)1.314819,
   (float)0.895752, (float)1.267212, (float)1.605591,
   (float)0.805420, (float)0.962891, (float)1.142334,
   (float)0.795654, (float)1.005493, (float)1.468506,
   (float)1.105347, (float)1.313843, (float)1.584839,
   (float)0.792236, (float)1.221802, (float)1.465698,
   (float)1.170532, (float)1.467651, (float)1.664063,
   (float)0.838257, (float)1.153198, (float)1.342163,
   (float)0.968018, (float)1.198242, (float)1.391235,
   (float)1.250122, (float)1.623535, (float)1.823608,
   (float)0.711670, (float)1.058350, (float)1.512085,
   (float)1.204834, (float)1.454468, (float)1.739136,
   (float)1.137451, (float)1.421753, (float)1.620117,
   (float)0.820435, (float)1.322754, (float)1.578247,
   (float)0.798706, (float)1.005005, (float)1.213867,
   (float)0.980713, (float)1.324951, (float)1.512939,
   (float)1.112305, (float)1.438843, (float)1.735596,
   (float)1.135498, (float)1.356689, (float)1.635742,
   (float)1.101318, (float)1.387451, (float)1.686523,
   (float)0.849854, (float)1.276978, (float)1.523438,
   (float)1.377930, (float)1.627563, (float)1.858154,
   (float)0.884888, (float)1.095459, (float)1.287476,
   (float)1.289795, (float)1.505859, (float)1.756592,
   (float)0.817505, (float)1.384155, (float)1.650513,
   (float)1.446655, (float)1.702148, (float)1.931885,
   (float)0.835815, (float)1.023071, (float)1.385376,
   (float)0.916626, (float)1.139038, (float)1.335327,
   (float)0.980103, (float)1.174072, (float)1.453735,
   (float)1.705688, (float)2.153809, (float)2.398315, (float)2.743408,
   (float)1.797119, (float)2.016846, (float)2.445679, (float)2.701904,
   (float)1.990356, (float)2.219116, (float)2.576416, (float)2.813477,
      (float)1.849365, (float)2.190918, (float)2.611572, (float)2.835083,
   (float)1.657959, (float)1.854370, (float)2.159058, (float)2.726196,
   (float)1.437744, (float)1.897705, (float)2.253174, (float)2.655396,
   (float)2.028687, (float)2.247314, (float)2.542358, (float)2.875854,
   (float)1.736938, (float)1.922119, (float)2.185913, (float)2.743408,
   (float)1.521606, (float)1.870972, (float)2.526855, (float)2.786987,
   (float)1.841431, (float)2.050659, (float)2.463623, (float)2.857666,
   (float)1.590088, (float)2.067261, (float)2.427979, (float)2.794434,
   (float)1.746826, (float)2.057373, (float)2.320190, (float)2.800781,
   (float)1.734619, (float)1.940552, (float)2.306030, (float)2.826416,
   (float)1.786255, (float)2.204468, (float)2.457520, (float)2.795288,
   (float)1.861084, (float)2.170532, (float)2.414551, (float)2.763672,
   (float)2.001465, (float)2.307617, (float)2.552734, (float)2.811890,
   (float)1.784424, (float)2.124146, (float)2.381592, (float)2.645508,
   (float)1.888794, (float)2.135864, (float)2.418579, (float)2.861206,
   (float)2.301147, (float)2.531250, (float)2.724976, (float)2.913086,
   (float)1.837769, (float)2.051270, (float)2.261963, (float)2.553223,
   (float)2.012939, (float)2.221191, (float)2.440186, (float)2.678101,
   (float)1.429565, (float)1.858276, (float)2.582275, (float)2.845703,
   (float)1.622803, (float)1.897705, (float)2.367310, (float)2.621094,
   (float)1.581543, (float)1.960449, (float)2.515869, (float)2.736450,
   (float)1.419434, (float)1.933960, (float)2.394653, (float)2.746704,
   (float)1.721924, (float)2.059570, (float)2.421753, (float)2.769653,
   (float)1.911011, (float)2.220703, (float)2.461060, (float)2.740723,
   (float)1.581177, (float)1.860840, (float)2.516968, (float)2.874634,
   (float)1.870361, (float)2.098755, (float)2.432373, (float)2.656494,
   (float)2.059692, (float)2.279785, (float)2.495605, (float)2.729370,
   (float)1.815674, (float)2.181519, (float)2.451538, (float)2.680542,
   (float)1.407959, (float)1.768311, (float)2.343018, (float)2.668091,
   (float)2.168701, (float)2.394653, (float)2.604736, (float)2.829346,
   (float)1.636230, (float)1.865723, (float)2.329102, (float)2.824219,
   (float)1.878906, (float)2.139526, (float)2.376709, (float)2.679810,
   (float)1.765381, (float)1.971802, (float)2.195435, (float)2.586914,
   (float)2.164795, (float)2.410889, (float)2.673706, (float)2.903198,
   (float)2.071899, (float)2.331055, (float)2.645874, (float)2.907104,
   (float)2.026001, (float)2.311523, (float)2.594849, (float)2.863892,
   (float)1.948975, (float)2.180786, (float)2.514893, (float)2.797852,
   (float)1.881836, (float)2.130859, (float)2.478149, (float)2.804199,
   (float)2.238159, (float)2.452759, (float)2.652832, (float)2.868286,
   (float)1.897949, (float)2.101685, (float)2.524292, (float)2.880127,
   (float)1.856445, (float)2.074585, (float)2.541016, (float)2.791748,
   (float)1.695557, (float)2.199097, (float)2.506226, (float)2.742676,
   (float)1.612671, (float)1.877075, (float)2.435425, (float)2.732910,
   (float)1.568848, (float)1.786499, (float)2.194580, (float)2.768555,
   (float)1.953369, (float)2.164551, (float)2.486938, (float)2.874023,
   (float)1.388306, (float)1.725342, (float)2.384521, (float)2.771851,
   (float)2.115356, (float)2.337769, (float)2.592896, (float)2.864014,
   (float)1.905762, (float)2.111328, (float)2.363525, (float)2.789307,
      (float)1.882568, (float)2.332031, (float)2.598267, (float)2.827637,
   (float)1.683594, (float)2.088745, (float)2.361938, (float)2.608643,
   (float)1.874023, (float)2.182129, (float)2.536133, (float)2.766968,
   (float)1.861938, (float)2.070435, (float)2.309692, (float)2.700562,
   (float)1.722168, (float)2.107422, (float)2.477295, (float)2.837646,
   (float)1.926880, (float)2.184692, (float)2.442627, (float)2.663818,
   (float)2.123901, (float)2.337280, (float)2.553101, (float)2.777466,
   (float)1.588135, (float)1.911499, (float)2.212769, (float)2.543945,
   (float)2.053955, (float)2.370850, (float)2.712158, (float)2.939941,
   (float)2.210449, (float)2.519653, (float)2.770386, (float)2.958618,
   (float)2.199463, (float)2.474731, (float)2.718262, (float)2.919922,
   (float)1.960083, (float)2.175415, (float)2.608032, (float)2.888794,
   (float)1.953735, (float)2.185181, (float)2.428223, (float)2.809570,
   (float)1.615234, (float)2.036499, (float)2.576538, (float)2.834595,
   (float)1.621094, (float)2.028198, (float)2.431030, (float)2.664673,
   (float)1.824951, (float)2.267456, (float)2.514526, (float)2.747925,
   (float)1.994263, (float)2.229126, (float)2.475220, (float)2.833984,
   (float)1.746338, (float)2.011353, (float)2.588257, (float)2.826904,
   (float)1.562866, (float)2.135986, (float)2.471680, (float)2.687256,
   (float)1.748901, (float)2.083496, (float)2.460938, (float)2.686279,
   (float)1.758057, (float)2.131470, (float)2.636597, (float)2.891602,
   (float)2.071289, (float)2.299072, (float)2.550781, (float)2.814331,
   (float)1.839600, (float)2.094360, (float)2.496460, (float)2.723999,
   (float)1.882202, (float)2.088257, (float)2.636841, (float)2.923096,
   (float)1.957886, (float)2.153198, (float)2.384399, (float)2.615234,
   (float)1.992920, (float)2.351196, (float)2.654419, (float)2.889771,
   (float)2.012817, (float)2.262451, (float)2.643799, (float)2.903076,
   (float)2.025635, (float)2.254761, (float)2.508423, (float)2.784058,
   (float)2.316040, (float)2.589355, (float)2.794189, (float)2.963623,
   (float)1.741211, (float)2.279541, (float)2.578491, (float)2.816284,
   (float)1.845337, (float)2.055786, (float)2.348511, (float)2.822021,
   (float)1.679932, (float)1.926514, (float)2.499756, (float)2.835693,
   (float)1.722534, (float)1.946899, (float)2.448486, (float)2.728760,
   (float)1.829834, (float)2.043213, (float)2.580444, (float)2.867676,
   (float)1.676636, (float)2.071655, (float)2.322510, (float)2.704834,
   (float)1.791504, (float)2.113525, (float)2.469727, (float)2.784058,
   (float)1.977051, (float)2.215088, (float)2.497437, (float)2.726929,
   (float)1.800171, (float)2.106689, (float)2.357788, (float)2.738892,
   (float)1.827759, (float)2.170166, (float)2.525879, (float)2.852417,
   (float)1.918335, (float)2.132813, (float)2.488403, (float)2.728149,
   (float)1.916748, (float)2.225098, (float)2.542603, (float)2.857666,
   (float)1.761230, (float)1.976074, (float)2.507446, (float)2.884521,
   (float)2.053711, (float)2.367432, (float)2.608032, (float)2.837646,
   (float)1.595337, (float)2.000977, (float)2.307129, (float)2.578247,
   (float)1.470581, (float)2.031250, (float)2.375854, (float)2.647583,
   (float)1.801392, (float)2.128052, (float)2.399780, (float)2.822876,
   (float)1.853638, (float)2.066650, (float)2.429199, (float)2.751465,
   (float)1.956299, (float)2.163696, (float)2.394775, (float)2.734253,
      (float)1.963623, (float)2.275757, (float)2.585327, (float)2.865234,
   (float)1.887451, (float)2.105469, (float)2.331787, (float)2.587402,
   (float)2.120117, (float)2.443359, (float)2.733887, (float)2.941406,
   (float)1.506348, (float)1.766968, (float)2.400513, (float)2.851807,
   (float)1.664551, (float)1.981079, (float)2.375732, (float)2.774414,
   (float)1.720703, (float)1.978882, (float)2.391479, (float)2.640991,
   (float)1.483398, (float)1.814819, (float)2.434448, (float)2.722290,
   (float)1.769043, (float)2.136597, (float)2.563721, (float)2.774414,
   (float)1.810791, (float)2.049316, (float)2.373901, (float)2.613647,
   (float)1.788330, (float)2.005981, (float)2.359131, (float)2.723145,
   (float)1.785156, (float)1.993164, (float)2.399780, (float)2.832520,
   (float)1.695313, (float)2.022949, (float)2.522583, (float)2.745117,
   (float)1.584106, (float)1.965576, (float)2.299927, (float)2.715576,
   (float)1.894897, (float)2.249878, (float)2.655884, (float)2.897705,
   (float)1.720581, (float)1.995728, (float)2.299438, (float)2.557007,
   (float)1.619385, (float)2.173950, (float)2.574219, (float)2.787964,
   (float)1.883179, (float)2.220459, (float)2.474365, (float)2.825073,
   (float)1.447632, (float)2.045044, (float)2.555542, (float)2.744873,
   (float)1.502686, (float)2.156616, (float)2.653320, (float)2.846558,
   (float)1.711548, (float)1.944092, (float)2.282959, (float)2.685791,
   (float)1.499756, (float)1.867554, (float)2.341064, (float)2.578857,
   (float)1.916870, (float)2.135132, (float)2.568237, (float)2.826050,
   (float)1.498047, (float)1.711182, (float)2.223267, (float)2.755127,
   (float)1.808716, (float)1.997559, (float)2.256470, (float)2.758545,
   (float)2.088501, (float)2.402710, (float)2.667358, (float)2.890259,
   (float)1.545044, (float)1.819214, (float)2.324097, (float)2.692993,
   (float)1.796021, (float)2.012573, (float)2.505737, (float)2.784912,
   (float)1.786499, (float)2.041748, (float)2.290405, (float)2.650757,
   (float)1.938232, (float)2.264404, (float)2.529053, (float)2.796143
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-9--anaFilter-h">
A.9. anaFilter.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.9. anaFilter.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
anaFilter.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
anaFilter.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_ANAFILTER_H #define __iLBC_ANAFILTER_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_ANAFILTER_H #define __iLBC_ANAFILTER_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void anaFilter(
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void anaFilter(
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       float *In,  /* (i) Signal to be filtered */
       float *a,   /* (i) LP parameters */
       int len,/* (i) Length of signal */
       float *Out, /* (o) Filtered signal */
       float *mem  /* (i/o) Filter state */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-10--anaFilter-c">
A.10. anaFilter.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.10. anaFilter.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
anaFilter.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
anaFilter.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;string.h&gt;
   #include &#34;iLBC_define.h&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  LP analysis filter.
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void anaFilter(
       float *In,  /* (i) Signal to be filtered */
       float *a,   /* (i) LP parameters */
       int len,/* (i) Length of signal */
       float *Out, /* (o) Filtered signal */
       float *mem  /* (i/o) Filter state */
   ){
       int i, j;
       float *po, *pi, *pm, *pa;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
po = Out;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
po = アウト;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Filter first part using memory from past */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i=0; i&lt;LPC_FILTERORDER; i++) {
           pi = &amp;In[i];
           pm = &amp;mem[LPC_FILTERORDER-1];
           pa = a;
           *po=0.0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (j=0; j&lt;=i; j++) {
               *po+=(*pa++)*(*pi--);
           }
           for (j=i+1; j&lt;LPC_FILTERORDER+1; j++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               *po+=(*pa++)*(*pm--);
           }
           po++;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Filter last part where the state is entirely
          in the input vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i=LPC_FILTERORDER; i&lt;len; i++) {
           pi = &amp;In[i];
           pa = a;
           *po=0.0;
           for (j=0; j&lt;LPC_FILTERORDER+1; j++) {
               *po+=(*pa++)*(*pi--);
           }
           po++;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Update state vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memcpy(mem, &amp;In[len-LPC_FILTERORDER],
           LPC_FILTERORDER*sizeof(float));
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-11--createCB-h">
A.11. createCB.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.11. createCB.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
createCB.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
createCB.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_CREATECB_H #define __iLBC_CREATECB_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_CREATECB_H #define __iLBC_CREATECB_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void filteredCBvecs(
       float *cbvectors,   /* (o) Codebook vector for the
                                  higher section */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       float *mem,         /* (i) Buffer to create codebook
                                  vectors from */
       int lMem        /* (i) Length of buffer */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void searchAugmentedCB(
       int low,        /* (i) Start index for the search */
       int high,           /* (i) End index for the search */
       int stage,          /* (i) Current stage */
       int startIndex,     /* (i) CB index for the first
                                  augmented vector */
       float *target,      /* (i) Target vector for encoding */
       float *buffer,      /* (i) Pointer to the end of the
                                  buffer for augmented codebook
                                  construction */
       float *max_measure, /* (i/o) Currently maximum measure */
       int *best_index,/* (o) Currently the best index */
       float *gain,    /* (o) Currently the best gain */
       float *energy,      /* (o) Energy of augmented
                                  codebook vectors */
       float *invenergy/* (o) Inv energy of aug codebook
                                  vectors */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void createAugmentedVec(
       int index,          /* (i) Index for the aug vector
                                  to be created */
       float *buffer,      /* (i) Pointer to the end of the
                                  buffer for augmented codebook
                                  construction */
       float *cbVec    /* (o) The construced codebook vector */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-12--createCB-c">
A.12. createCB.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.12. createCB.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
createCB.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
createCB.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &#34;iLBC_define.h&#34;
   #include &#34;constants.h&#34;
   #include &lt;string.h&gt;
   #include &lt;math.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  Construct an additional codebook vector by filtering the
    *  initial codebook buffer. This vector is then used to expand
    *  the codebook with an additional section.
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void filteredCBvecs(
       float *cbvectors,   /* (o) Codebook vectors for the
                                  higher section */
       float *mem,         /* (i) Buffer to create codebook
                                  vector from */
       int lMem        /* (i) Length of buffer */
   ){
       int j, k;
       float *pp, *pp1;
       float tempbuff2[CB_MEML+CB_FILTERLEN];
       float *pos;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memset(tempbuff2, 0, (CB_HALFFILTERLEN-1)*sizeof(float));
       memcpy(&amp;tempbuff2[CB_HALFFILTERLEN-1], mem, lMem*sizeof(float));
       memset(&amp;tempbuff2[lMem+CB_HALFFILTERLEN-1], 0,
           (CB_HALFFILTERLEN+1)*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Create codebook vector for higher section by filtering */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* do filtering */
       pos=cbvectors;
       memset(pos, 0, lMem*sizeof(float));
       for (k=0; k&lt;lMem; k++) {
           pp=&amp;tempbuff2[k];
           pp1=&amp;cbfiltersTbl[CB_FILTERLEN-1];
           for (j=0;j&lt;CB_FILTERLEN;j++) {
               (*pos)+=(*pp++)*(*pp1--);
           }
           pos++;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  Search the augmented part of the codebook to find the best
    *  measure.
    *----------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void searchAugmentedCB(
       int low,        /* (i) Start index for the search */
       int high,           /* (i) End index for the search */
       int stage,          /* (i) Current stage */
       int startIndex,     /* (i) Codebook index for the first
                                  aug vector */
       float *target,      /* (i) Target vector for encoding */
       float *buffer,      /* (i) Pointer to the end of the buffer for
                                  augmented codebook construction */
       float *max_measure, /* (i/o) Currently maximum measure */
       int *best_index,/* (o) Currently the best index */
       float *gain,    /* (o) Currently the best gain */
       float *energy,      /* (o) Energy of augmented codebook
                                  vectors */
       float *invenergy/* (o) Inv energy of augmented codebook
                                  vectors */
   ) {
       int icount, ilow, j, tmpIndex;
       float *pp, *ppo, *ppi, *ppe, crossDot, alfa;
       float weighted, measure, nrjRecursive;
       float ftmp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Compute the energy for the first (low-5)
          noninterpolated samples */
       nrjRecursive = (float) 0.0;
       pp = buffer - low + 1;
       for (j=0; j&lt;(low-5); j++) {
           nrjRecursive += ( (*pp)*(*pp) );
           pp++;
       }
       ppe = buffer - low;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (icount=low; icount&lt;=high; icount++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Index of the codebook vector used for retrieving
              energy values */
           tmpIndex = startIndex+icount-20;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
ilow = icount-4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
ilow = icount-4;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Update the energy recursively to save complexity */
           nrjRecursive = nrjRecursive + (*ppe)*(*ppe);
           ppe--;
           energy[tmpIndex] = nrjRecursive;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Compute cross dot product for the first (low-5)
              samples */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           crossDot = (float) 0.0;
           pp = buffer-icount;
           for (j=0; j&lt;ilow; j++) {
               crossDot += target[j]*(*pp++);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* interpolation */
           alfa = (float) 0.2;
           ppo = buffer-4;
           ppi = buffer-icount-4;
           for (j=ilow; j&lt;icount; j++) {
               weighted = ((float)1.0-alfa)*(*ppo)+alfa*(*ppi);
               ppo++;
               ppi++;
               energy[tmpIndex] += weighted*weighted;
               crossDot += target[j]*weighted;
               alfa += (float)0.2;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Compute energy and cross dot product for the
              remaining samples */
           pp = buffer - icount;
           for (j=icount; j&lt;SUBL; j++) {
               energy[tmpIndex] += (*pp)*(*pp);
               crossDot += target[j]*(*pp++);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (energy[tmpIndex]&gt;0.0) {
               invenergy[tmpIndex]=(float)1.0/(energy[tmpIndex]+EPS);
           } else {
               invenergy[tmpIndex] = (float) 0.0;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (stage==0) {
               measure = (float)-10000000.0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (crossDot &gt; 0.0) {
                   measure = crossDot*crossDot*invenergy[tmpIndex];
               }
           }
           else {
               measure = crossDot*crossDot*invenergy[tmpIndex];
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* check if measure is better */
           ftmp = crossDot*invenergy[tmpIndex];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if ((measure&gt;*max_measure) &amp;&amp; (fabs(ftmp)&lt;CB_MAXGAIN)) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               *best_index = tmpIndex;
               *max_measure = measure;
               *gain = ftmp;
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  Recreate a specific codebook vector from the augmented part.
    *
    *----------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void createAugmentedVec(
       int index,      /* (i) Index for the augmented vector
                              to be created */
       float *buffer,  /* (i) Pointer to the end of the buffer for
                              augmented codebook construction */
       float *cbVec/* (o) The construced codebook vector */
   ) {
       int ilow, j;
       float *pp, *ppo, *ppi, alfa, alfa1, weighted;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
ilow = index-5;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
ilow = インデックス-5;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* copy the first noninterpolated part */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       pp = buffer-index;
       memcpy(cbVec,pp,sizeof(float)*index);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* interpolation */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       alfa1 = (float)0.2;
       alfa = 0.0;
       ppo = buffer-5;
       ppi = buffer-index-5;
       for (j=ilow; j&lt;index; j++) {
           weighted = ((float)1.0-alfa)*(*ppo)+alfa*(*ppi);
           ppo++;
           ppi++;
           cbVec[j] = weighted;
           alfa += alfa1;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* copy the second noninterpolated part */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       pp = buffer - index;
       memcpy(cbVec+index,pp,sizeof(float)*(SUBL-index));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-13--doCPLC-h">
A.13. doCPLC.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.13. doCPLC.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
doCPLC.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
doCPLC.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_DOLPC_H #define __iLBC_DOLPC_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_DOLPC_H #define __iLBC_DOLPC_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void doThePLC(
       float *PLCresidual, /* (o) concealed residual */
       float *PLClpc,      /* (o) concealed LP parameters */
       int PLI,        /* (i) packet loss indicator
                                  0 - no PL, 1 = PL */
       float *decresidual, /* (i) decoded residual */
       float *lpc,         /* (i) decoded LPC (only used for no PL) */
       int inlag,          /* (i) pitch lag */
       iLBC_Dec_Inst_t *iLBCdec_inst
                           /* (i/o) decoder instance */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-14--doCPLC-c">
A.14. doCPLC.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.14. doCPLC.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
doCPLC.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
doCPLC.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;math.h&gt;
   #include &lt;string.h&gt;
   #include &lt;stdio.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  Compute cross correlation and pitch gain for pitch prediction
    *  of last subframe at given lag.
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void compCorr(
       float *cc,      /* (o) cross correlation coefficient */
       float *gc,      /* (o) gain */
       float *pm,
       float *buffer,  /* (i) signal buffer */
       int lag,    /* (i) pitch lag */
       int bLen,       /* (i) length of buffer */
       int sRange      /* (i) correlation search length */
   ){
       int i;
       float ftmp1, ftmp2, ftmp3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Guard against getting outside buffer */
       if ((bLen-sRange-lag)&lt;0) {
           sRange=bLen-lag;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       ftmp1 = 0.0;
       ftmp2 = 0.0;
       ftmp3 = 0.0;
       for (i=0; i&lt;sRange; i++) {
           ftmp1 += buffer[bLen-sRange+i] *
               buffer[bLen-sRange+i-lag];
           ftmp2 += buffer[bLen-sRange+i-lag] *
                   buffer[bLen-sRange+i-lag];
           ftmp3 += buffer[bLen-sRange+i] *
                   buffer[bLen-sRange+i];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (ftmp2 &gt; 0.0) {
           *cc = ftmp1*ftmp1/ftmp2;
           *gc = (float)fabs(ftmp1/ftmp2);
           *pm=(float)fabs(ftmp1)/
               ((float)sqrt(ftmp2)*(float)sqrt(ftmp3));
       }
       else {
           *cc = 0.0;
           *gc = 0.0;
           *pm=0.0;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  Packet loss concealment routine. Conceals a residual signal
    *  and LP parameters. If no packet loss, update state.
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void doThePLC(
       float *PLCresidual, /* (o) concealed residual */
       float *PLClpc,      /* (o) concealed LP parameters */
       int PLI,        /* (i) packet loss indicator
                                  0 - no PL, 1 = PL */
       float *decresidual, /* (i) decoded residual */
       float *lpc,         /* (i) decoded LPC (only used for no PL) */
       int inlag,          /* (i) pitch lag */
       iLBC_Dec_Inst_t *iLBCdec_inst
                           /* (i/o) decoder instance */
   ){
       int lag=20, randlag;
       float gain, maxcc;
       float use_gain;
       float gain_comp, maxcc_comp, per, max_per;
       int i, pick, use_lag;
       float ftmp, randvec[BLOCKL_MAX], pitchfact, energy;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Packet Loss */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (PLI == 1) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           iLBCdec_inst-&gt;consPLICount += 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* if previous frame not lost,
              determine pitch pred. gain */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (iLBCdec_inst-&gt;prevPLI != 1) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* Search around the previous lag to find the
                  best pitch period */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               lag=inlag-3;
               compCorr(&amp;maxcc, &amp;gain, &amp;max_per,
                   iLBCdec_inst-&gt;prevResidual,
                   lag, iLBCdec_inst-&gt;blockl, 60);
               for (i=inlag-2;i&lt;=inlag+3;i++) {
                   compCorr(&amp;maxcc_comp, &amp;gain_comp, &amp;per,
                       iLBCdec_inst-&gt;prevResidual,
                       i, iLBCdec_inst-&gt;blockl, 60);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   if (maxcc_comp&gt;maxcc) {
                       maxcc=maxcc_comp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       gain=gain_comp;
                       lag=i;
                       max_per=per;
                   }
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* previous frame lost, use recorded lag and periodicity */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           else {
               lag=iLBCdec_inst-&gt;prevLag;
               max_per=iLBCdec_inst-&gt;per;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* downscaling */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           use_gain=1.0;
           if (iLBCdec_inst-&gt;consPLICount*iLBCdec_inst-&gt;blockl&gt;320)
               use_gain=(float)0.9;
           else if (iLBCdec_inst-&gt;consPLICount*
                           iLBCdec_inst-&gt;blockl&gt;2*320)
               use_gain=(float)0.7;
           else if (iLBCdec_inst-&gt;consPLICount*
                           iLBCdec_inst-&gt;blockl&gt;3*320)
               use_gain=(float)0.5;
           else if (iLBCdec_inst-&gt;consPLICount*
                           iLBCdec_inst-&gt;blockl&gt;4*320)
               use_gain=(float)0.0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* mix noise and pitch repeatition */
           ftmp=(float)sqrt(max_per);
           if (ftmp&gt;(float)0.7)
               pitchfact=(float)1.0;
           else if (ftmp&gt;(float)0.4)
               pitchfact=(ftmp-(float)0.4)/((float)0.7-(float)0.4);
           else
               pitchfact=0.0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* avoid repetition of same pitch cycle */
           use_lag=lag;
           if (lag&lt;80) {
               use_lag=2*lag;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* compute concealed residual */
                      energy = 0.0;
           for (i=0; i&lt;iLBCdec_inst-&gt;blockl; i++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* noise component */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               iLBCdec_inst-&gt;seed=(iLBCdec_inst-&gt;seed*69069L+1) &amp;
                   (0x80000000L-1);
               randlag = 50 + ((signed long) iLBCdec_inst-&gt;seed)%70;
               pick = i - randlag;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (pick &lt; 0) {
                   randvec[i] =
                       iLBCdec_inst-&gt;prevResidual[
                                   iLBCdec_inst-&gt;blockl+pick];
               } else {
                   randvec[i] =  randvec[pick];
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* pitch repeatition component */
               pick = i - use_lag;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (pick &lt; 0) {
                   PLCresidual[i] =
                       iLBCdec_inst-&gt;prevResidual[
                                   iLBCdec_inst-&gt;blockl+pick];
               } else {
                   PLCresidual[i] = PLCresidual[pick];
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* mix random and periodicity component */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (i&lt;80)
                   PLCresidual[i] = use_gain*(pitchfact *
                               PLCresidual[i] +
                               ((float)1.0 - pitchfact) * randvec[i]);
               else if (i&lt;160)
                   PLCresidual[i] = (float)0.95*use_gain*(pitchfact *
                               PLCresidual[i] +
                               ((float)1.0 - pitchfact) * randvec[i]);
               else
                   PLCresidual[i] = (float)0.9*use_gain*(pitchfact *
                               PLCresidual[i] +
                               ((float)1.0 - pitchfact) * randvec[i]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               energy += PLCresidual[i] * PLCresidual[i];
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* less than 30 dB, use only noise */
                      if (sqrt(energy/(float)iLBCdec_inst-&gt;blockl) &lt; 30.0) {
               gain=0.0;
               for (i=0; i&lt;iLBCdec_inst-&gt;blockl; i++) {
                   PLCresidual[i] = randvec[i];
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* use old LPC */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           memcpy(PLClpc,iLBCdec_inst-&gt;prevLpc,
               (LPC_FILTERORDER+1)*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* no packet loss, copy input */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       else {
           memcpy(PLCresidual, decresidual,
               iLBCdec_inst-&gt;blockl*sizeof(float));
           memcpy(PLClpc, lpc, (LPC_FILTERORDER+1)*sizeof(float));
           iLBCdec_inst-&gt;consPLICount = 0;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* update state */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (PLI) {
           iLBCdec_inst-&gt;prevLag = lag;
           iLBCdec_inst-&gt;per=max_per;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       iLBCdec_inst-&gt;prevPLI = PLI;
       memcpy(iLBCdec_inst-&gt;prevLpc, PLClpc,
           (LPC_FILTERORDER+1)*sizeof(float));
       memcpy(iLBCdec_inst-&gt;prevResidual, PLCresidual,
           iLBCdec_inst-&gt;blockl*sizeof(float));
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-15--enhancer-h">
A.15. enhancer.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.15. エンハンサー.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
enhancer.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
エンハンサー.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __ENHANCER_H #define __ENHANCER_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __ENHANCER_H #define __ENHANCER_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   float xCorrCoef(
       float *target,      /* (i) first array */
       float *regressor,   /* (i) second array */
       int subl        /* (i) dimension arrays */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int enhancerInterface(
       float *out,         /* (o) the enhanced recidual signal */
       float *in,          /* (i) the recidual signal to enhance */
       iLBC_Dec_Inst_t *iLBCdec_inst
                           /* (i/o) the decoder state structure */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-16--enhancer-c">
A.16. enhancer.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.16. エンハンサー.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
enhancer.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
エンハンサー.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;math.h&gt;
   #include &lt;string.h&gt;
   #include &#34;iLBC_define.h&#34;
   #include &#34;constants.h&#34;
   #include &#34;filter.h&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    * Find index in array such that the array element with said
    * index is the element of said array closest to &#34;value&#34;
    * according to the squared-error criterion
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void NearestNeighbor(
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void 最近隣(
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int   *index,   /* (o) index of array element closest
                              to value */
       float *array,   /* (i) data array */
       float value,/* (i) value */
       int arlength/* (i) dimension of data array */
   ){
       int i;
       float bestcrit,crit;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       crit=array[0]-value;
       bestcrit=crit*crit;
       *index=0;
       for (i=1; i&lt;arlength; i++) {
           crit=array[i]-value;
           crit=crit*crit;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (crit&lt;bestcrit) {
               bestcrit=crit;
               *index=i;
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    * compute cross correlation between sequences
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void mycorr1(
       float* corr,    /* (o) correlation of seq1 and seq2 */
       float* seq1,    /* (i) first sequence */
       int dim1,           /* (i) dimension first seq1 */
       const float *seq2,  /* (i) second sequence */
       int dim2        /* (i) dimension seq2 */
   ){
       int i,j;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i=0; i&lt;=dim1-dim2; i++) {
           corr[i]=0.0;
           for (j=0; j&lt;dim2; j++) {
               corr[i] += seq1[i+j] * seq2[j];
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    * upsample finite array assuming zeros outside bounds
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void enh_upsample(
       float* useq1,   /* (o) upsampled output sequence */
       float* seq1,/* (i) unupsampled sequence */
       int dim1,       /* (i) dimension seq1 */
       int hfl         /* (i) polyphase filter length=2*hfl+1 */
   ){
       float *pu,*ps;
       int i,j,k,q,filterlength,hfl2;
       const float *polyp[ENH_UPS0]; /* pointers to
                                        polyphase columns */
       const float *pp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* define pointers for filter */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       filterlength=2*hfl+1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if ( filterlength &gt; dim1 ) {
           hfl2=(int) (dim1/2);
           for (j=0; j&lt;ENH_UPS0; j++) {
               polyp[j]=polyphaserTbl+j*filterlength+hfl-hfl2;
           }
           hfl=hfl2;
           filterlength=2*hfl+1;
       }
       else {
           for (j=0; j&lt;ENH_UPS0; j++) {
               polyp[j]=polyphaserTbl+j*filterlength;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* filtering: filter overhangs left side of sequence */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       pu=useq1;
       for (i=hfl; i&lt;filterlength; i++) {
           for (j=0; j&lt;ENH_UPS0; j++) {
               *pu=0.0;
               pp = polyp[j];
               ps = seq1+i;
               for (k=0; k&lt;=i; k++) {
                   *pu += *ps-- * *pp++;
               }
               pu++;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* filtering: simple convolution=inner products */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i=filterlength; i&lt;dim1; i++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (j=0;j&lt;ENH_UPS0; j++){
               *pu=0.0;
               pp = polyp[j];
               ps = seq1+i;
               for (k=0; k&lt;filterlength; k++) {
                   *pu += *ps-- * *pp++;
               }
               pu++;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* filtering: filter overhangs right side of sequence */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (q=1; q&lt;=hfl; q++) {
           for (j=0; j&lt;ENH_UPS0; j++) {
               *pu=0.0;
               pp = polyp[j]+q;
               ps = seq1+dim1-1;
               for (k=0; k&lt;filterlength-q; k++) {
                   *pu += *ps-- * *pp++;
               }
               pu++;
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    * find segment starting near idata+estSegPos that has highest
    * correlation with idata+centerStartPos through
    * idata+centerStartPos+ENH_BLOCKL-1 segment is found at a
    * resolution of ENH_UPSO times the original of the original
    * sampling rate
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void refiner(
       float *seg,         /* (o) segment array */
       float *updStartPos, /* (o) updated start point */
       float* idata,       /* (i) original data buffer */
       int idatal,         /* (i) dimension of idata */
       int centerStartPos, /* (i) beginning center segment */
       float estSegPos,/* (i) estimated beginning other segment */
       float period    /* (i) estimated pitch period */
   ){
       int estSegPosRounded,searchSegStartPos,searchSegEndPos,corrdim;
       int tloc,tloc2,i,st,en,fraction;
       float vect[ENH_VECTL],corrVec[ENH_CORRDIM],maxv;
       float corrVecUps[ENH_CORRDIM*ENH_UPS0];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* defining array bounds */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       estSegPosRounded=(int)(estSegPos - 0.5);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
searchSegStartPos=estSegPosRounded-ENH_SLOP;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
searchSegStartPos=estSegPosRounded-ENH_SLOP;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (searchSegStartPos&lt;0) {
           searchSegStartPos=0;
       }
       searchSegEndPos=estSegPosRounded+ENH_SLOP;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (searchSegEndPos+ENH_BLOCKL &gt;= idatal) {
           searchSegEndPos=idatal-ENH_BLOCKL-1;
       }
       corrdim=searchSegEndPos-searchSegStartPos+1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* compute upsampled correlation (corr33) and find
          location of max */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       mycorr1(corrVec,idata+searchSegStartPos,
           corrdim+ENH_BLOCKL-1,idata+centerStartPos,ENH_BLOCKL);
       enh_upsample(corrVecUps,corrVec,corrdim,ENH_FL0);
       tloc=0; maxv=corrVecUps[0];
       for (i=1; i&lt;ENH_UPS0*corrdim; i++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (corrVecUps[i]&gt;maxv) {
               tloc=i;
               maxv=corrVecUps[i];
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* make vector can be upsampled without ever running outside
          bounds */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       *updStartPos= (float)searchSegStartPos +
           (float)tloc/(float)ENH_UPS0+(float)1.0;
       tloc2=(int)(tloc/ENH_UPS0);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (tloc&gt;tloc2*ENH_UPS0) {
           tloc2++;
       }
       st=searchSegStartPos+tloc2-ENH_FL0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (st&lt;0) {
           memset(vect,0,-st*sizeof(float));
           memcpy(&amp;vect[-st],idata, (ENH_VECTL+st)*sizeof(float));
       }
       else {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           en=st+ENH_VECTL;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (en&gt;idatal) {
               memcpy(vect, &amp;idata[st],
                   (ENH_VECTL-(en-idatal))*sizeof(float));
               memset(&amp;vect[ENH_VECTL-(en-idatal)], 0,
                   (en-idatal)*sizeof(float));
           }
           else {
               memcpy(vect, &amp;idata[st], ENH_VECTL*sizeof(float));
           }
       }
       fraction=tloc2*ENH_UPS0-tloc;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* compute the segment (this is actually a convolution) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       mycorr1(seg,vect,ENH_VECTL,polyphaserTbl+(2*ENH_FL0+1)*fraction,
           2*ENH_FL0+1);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    * find the smoothed output data
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void smath(
       float *odata,   /* (o) smoothed output */
       float *sseq,/* (i) said second sequence of waveforms */
       int hl,         /* (i) 2*hl+1 is sseq dimension */
       float alpha0/* (i) max smoothing energy fraction */
   ){
       int i,k;
       float w00,w10,w11,A,B,C,*psseq,err,errs;
       float surround[BLOCKL_MAX]; /* shape contributed by other than
                                      current */
       float wt[2*ENH_HL+1];       /* waveform weighting to get
                                      surround shape */
       float denom;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* create shape of contribution from all waveforms except the
          current one */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i=1; i&lt;=2*hl+1; i++) {
           wt[i-1] = (float)0.5*(1 - (float)cos(2*PI*i/(2*hl+2)));
       }
       wt[hl]=0.0; /* for clarity, not used */
       for (i=0; i&lt;ENH_BLOCKL; i++) {
           surround[i]=sseq[i]*wt[0];
       }
              for (k=1; k&lt;hl; k++) {
           psseq=sseq+k*ENH_BLOCKL;
           for(i=0;i&lt;ENH_BLOCKL; i++) {
               surround[i]+=psseq[i]*wt[k];
           }
       }
       for (k=hl+1; k&lt;=2*hl; k++) {
           psseq=sseq+k*ENH_BLOCKL;
           for(i=0;i&lt;ENH_BLOCKL; i++) {
               surround[i]+=psseq[i]*wt[k];
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* compute some inner products */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       w00 = w10 = w11 = 0.0;
       psseq=sseq+hl*ENH_BLOCKL; /* current block  */
       for (i=0; i&lt;ENH_BLOCKL;i++) {
           w00+=psseq[i]*psseq[i];
           w11+=surround[i]*surround[i];
           w10+=surround[i]*psseq[i];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (fabs(w11) &lt; 1.0) {
           w11=1.0;
       }
       C = (float)sqrt( w00/w11);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* first try enhancement without power-constraint */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       errs=0.0;
       psseq=sseq+hl*ENH_BLOCKL;
       for (i=0; i&lt;ENH_BLOCKL; i++) {
           odata[i]=C*surround[i];
           err=psseq[i]-odata[i];
           errs+=err*err;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* if constraint violated by first try, add constraint */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (errs &gt; alpha0 * w00) {
           if ( w00 &lt; 1) {
               w00=1;
           }
           denom = (w11*w00-w10*w10)/(w00*w00);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (denom &gt; 0.0001) { /* eliminates numerical problems
                                    for if smooth */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               A = (float)sqrt( (alpha0- alpha0*alpha0/4)/denom);
               B = -alpha0/2 - A * w10/w00;
               B = B+1;
           }
           else { /* essentially no difference between cycles;
                     smoothing not needed */
               A= 0.0;
               B= 1.0;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* create smoothed sequence */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           psseq=sseq+hl*ENH_BLOCKL;
           for (i=0; i&lt;ENH_BLOCKL; i++) {
               odata[i]=A*surround[i]+B*psseq[i];
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    * get the pitch-synchronous sample sequence
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void getsseq(
       float *sseq,    /* (o) the pitch-synchronous sequence */
       float *idata,       /* (i) original data */
       int idatal,         /* (i) dimension of data */
       int centerStartPos, /* (i) where current block starts */
       float *period,      /* (i) rough-pitch-period array */
       float *plocs,       /* (i) where periods of period array
                                  are taken */
       int periodl,    /* (i) dimension period array */
       int hl              /* (i) 2*hl+1 is the number of sequences */
   ){
       int i,centerEndPos,q;
       float blockStartPos[2*ENH_HL+1];
       int lagBlock[2*ENH_HL+1];
       float plocs2[ENH_PLOCSL];
       float *psseq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       centerEndPos=centerStartPos+ENH_BLOCKL-1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* present */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       NearestNeighbor(lagBlock+hl,plocs,
           (float)0.5*(centerStartPos+centerEndPos),periodl);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
blockStartPos[hl]=(float)centerStartPos;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
blockStartPos[hl]=(float)centerStartPos;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       psseq=sseq+ENH_BLOCKL*hl;
       memcpy(psseq, idata+centerStartPos, ENH_BLOCKL*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* past */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (q=hl-1; q&gt;=0; q--) {
           blockStartPos[q]=blockStartPos[q+1]-period[lagBlock[q+1]];
           NearestNeighbor(lagBlock+q,plocs,
               blockStartPos[q]+
               ENH_BLOCKL_HALF-period[lagBlock[q+1]], periodl);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (blockStartPos[q]-ENH_OVERHANG&gt;=0) {
               refiner(sseq+q*ENH_BLOCKL, blockStartPos+q, idata,
                   idatal, centerStartPos, blockStartPos[q],
                   period[lagBlock[q+1]]);
           } else {
               psseq=sseq+q*ENH_BLOCKL;
               memset(psseq, 0, ENH_BLOCKL*sizeof(float));
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* future */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i=0; i&lt;periodl; i++) {
           plocs2[i]=plocs[i]-period[i];
       }
       for (q=hl+1; q&lt;=2*hl; q++) {
           NearestNeighbor(lagBlock+q,plocs2,
               blockStartPos[q-1]+ENH_BLOCKL_HALF,periodl);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           blockStartPos[q]=blockStartPos[q-1]+period[lagBlock[q]];
           if (blockStartPos[q]+ENH_BLOCKL+ENH_OVERHANG&lt;idatal) {
               refiner(sseq+ENH_BLOCKL*q, blockStartPos+q, idata,
                   idatal, centerStartPos, blockStartPos[q],
                   period[lagBlock[q]]);
           }
           else {
               psseq=sseq+q*ENH_BLOCKL;
               memset(psseq, 0, ENH_BLOCKL*sizeof(float));
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    * perform enhancement on idata+centerStartPos through
    * idata+centerStartPos+ENH_BLOCKL-1
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void enhancer(
       float *odata,       /* (o) smoothed block, dimension blockl */
       float *idata,       /* (i) data buffer used for enhancing */
       int idatal,         /* (i) dimension idata */
       int centerStartPos, /* (i) first sample current block
                                  within idata */
       float alpha0,       /* (i) max correction-energy-fraction
                                 (in [0,1]) */
       float *period,      /* (i) pitch period array */
       float *plocs,       /* (i) locations where period array
                                  values valid */
       int periodl         /* (i) dimension of period and plocs */
   ){
       float sseq[(2*ENH_HL+1)*ENH_BLOCKL];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* get said second sequence of segments */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
getsseq(sseq,idata,idatal,centerStartPos,period, plocs,periodl,ENH_HL);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
getseq(sseq,idata,idatal,centerStartPos,period,plocs,periodl,ENH_HL);
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* compute the smoothed output from said second sequence */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
smath(odata,sseq,ENH_HL,alpha0);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
smath(odata,sseq,ENH_HL,alpha0);
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    * cross correlation
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   float xCorrCoef(
       float *target,      /* (i) first array */
       float *regressor,   /* (i) second array */
       int subl        /* (i) dimension arrays */
   ){
       int i;
       float ftmp1, ftmp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       ftmp1 = 0.0;
       ftmp2 = 0.0;
       for (i=0; i&lt;subl; i++) {
           ftmp1 += target[i]*regressor[i];
           ftmp2 += regressor[i]*regressor[i];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (ftmp1 &gt; 0.0) {
           return (float)(ftmp1*ftmp1/ftmp2);
       }
          else {
           return (float)0.0;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    * interface for enhancer
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int enhancerInterface(
       float *out,                     /* (o) enhanced signal */
       float *in,                      /* (i) unenhanced signal */
       iLBC_Dec_Inst_t *iLBCdec_inst   /* (i) buffers etc */
   ){
       float *enh_buf, *enh_period;
       int iblock, isample;
       int lag=0, ilag, i, ioffset;
       float cc, maxcc;
       float ftmp1, ftmp2;
       float *inPtr, *enh_bufPtr1, *enh_bufPtr2;
       float plc_pred[ENH_BLOCKL];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       float lpState[6], downsampled[(ENH_NBLOCKS*ENH_BLOCKL+120)/2];
       int inLen=ENH_NBLOCKS*ENH_BLOCKL+120;
       int start, plc_blockl, inlag;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enh_buf=iLBCdec_inst-&gt;enh_buf;
       enh_period=iLBCdec_inst-&gt;enh_period;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memmove(enh_buf, &amp;enh_buf[iLBCdec_inst-&gt;blockl],
           (ENH_BUFL-iLBCdec_inst-&gt;blockl)*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memcpy(&amp;enh_buf[ENH_BUFL-iLBCdec_inst-&gt;blockl], in,
           iLBCdec_inst-&gt;blockl*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (iLBCdec_inst-&gt;mode==30)
           plc_blockl=ENH_BLOCKL;
       else
           plc_blockl=40;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* when 20 ms frame, move processing one block */
       ioffset=0;
       if (iLBCdec_inst-&gt;mode==20) ioffset=1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       i=3-ioffset;
       memmove(enh_period, &amp;enh_period[i],
           (ENH_NBLOCKS_TOT-i)*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Set state information to the 6 samples right before
          the samples to be downsampled. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memcpy(lpState,
           enh_buf+(ENH_NBLOCKS_EXTRA+ioffset)*ENH_BLOCKL-126,
           6*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Down sample a factor 2 to save computations */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       DownSample(enh_buf+(ENH_NBLOCKS_EXTRA+ioffset)*ENH_BLOCKL-120,
                   lpFilt_coefsTbl, inLen-ioffset*ENH_BLOCKL,
                   lpState, downsampled);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Estimate the pitch in the down sampled domain. */
       for (iblock = 0; iblock&lt;ENH_NBLOCKS-ioffset; iblock++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           lag = 10;
           maxcc = xCorrCoef(downsampled+60+iblock*
               ENH_BLOCKL_HALF, downsampled+60+iblock*
               ENH_BLOCKL_HALF-lag, ENH_BLOCKL_HALF);
           for (ilag=11; ilag&lt;60; ilag++) {
               cc = xCorrCoef(downsampled+60+iblock*
                   ENH_BLOCKL_HALF, downsampled+60+iblock*
                   ENH_BLOCKL_HALF-ilag, ENH_BLOCKL_HALF);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (cc &gt; maxcc) {
                   maxcc = cc;
                   lag = ilag;
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Store the estimated lag in the non-downsampled domain */
           enh_period[iblock+ENH_NBLOCKS_EXTRA+ioffset] = (float)lag*2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* PLC was performed on the previous packet */
       if (iLBCdec_inst-&gt;prev_enh_pl==1) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           inlag=(int)enh_period[ENH_NBLOCKS_EXTRA+ioffset];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           lag = inlag-1;
           maxcc = xCorrCoef(in, in+lag, plc_blockl);
           for (ilag=inlag; ilag&lt;=inlag+1; ilag++) {
               cc = xCorrCoef(in, in+ilag, plc_blockl);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (cc &gt; maxcc) {
                   maxcc = cc;
                   lag = ilag;
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           enh_period[ENH_NBLOCKS_EXTRA+ioffset-1]=(float)lag;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* compute new concealed residual for the old lookahead,
              mix the forward PLC with a backward PLC from
              the new frame */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
inPtr=&amp;in[lag-1];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
intPtr=in[lag-1];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
enh_bufPtr1=&amp;plc_pred[plc_blockl-1];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
enh_bufPtr1=&amp;plc_pred[plc_blockl-1];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (lag&gt;plc_blockl) {
               start=plc_blockl;
           } else {
               start=lag;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (isample = start; isample&gt;0; isample--) {
               *enh_bufPtr1-- = *inPtr--;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           enh_bufPtr2=&amp;enh_buf[ENH_BUFL-1-iLBCdec_inst-&gt;blockl];
           for (isample = (plc_blockl-1-lag); isample&gt;=0; isample--) {
               *enh_bufPtr1-- = *enh_bufPtr2--;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* limit energy change */
           ftmp2=0.0;
           ftmp1=0.0;
           for (i=0;i&lt;plc_blockl;i++) {
               ftmp2+=enh_buf[ENH_BUFL-1-iLBCdec_inst-&gt;blockl-i]*
                   enh_buf[ENH_BUFL-1-iLBCdec_inst-&gt;blockl-i];
               ftmp1+=plc_pred[i]*plc_pred[i];
           }
           ftmp1=(float)sqrt(ftmp1/(float)plc_blockl);
           ftmp2=(float)sqrt(ftmp2/(float)plc_blockl);
           if (ftmp1&gt;(float)2.0*ftmp2 &amp;&amp; ftmp1&gt;0.0) {
               for (i=0;i&lt;plc_blockl-10;i++) {
                   plc_pred[i]*=(float)2.0*ftmp2/ftmp1;
               }
               for (i=plc_blockl-10;i&lt;plc_blockl;i++) {
                   plc_pred[i]*=(float)(i-plc_blockl+10)*
                       ((float)1.0-(float)2.0*ftmp2/ftmp1)/(float)(10)+
                                  (float)2.0*ftmp2/ftmp1;
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           enh_bufPtr1=&amp;enh_buf[ENH_BUFL-1-iLBCdec_inst-&gt;blockl];
           for (i=0; i&lt;plc_blockl; i++) {
               ftmp1 = (float) (i+1) / (float) (plc_blockl+1);
               *enh_bufPtr1 *= ftmp1;
               *enh_bufPtr1 += ((float)1.0-ftmp1)*
                                   plc_pred[plc_blockl-1-i];
               enh_bufPtr1--;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (iLBCdec_inst-&gt;mode==20) {
           /* Enhancer with 40 samples delay */
           for (iblock = 0; iblock&lt;2; iblock++) {
               enhancer(out+iblock*ENH_BLOCKL, enh_buf,
                   ENH_BUFL, (5+iblock)*ENH_BLOCKL+40,
                   ENH_ALPHA0, enh_period, enh_plocsTbl,
                       ENH_NBLOCKS_TOT);
           }
       } else if (iLBCdec_inst-&gt;mode==30) {
           /* Enhancer with 80 samples delay */
           for (iblock = 0; iblock&lt;3; iblock++) {
               enhancer(out+iblock*ENH_BLOCKL, enh_buf,
                   ENH_BUFL, (4+iblock)*ENH_BLOCKL,
                   ENH_ALPHA0, enh_period, enh_plocsTbl,
                       ENH_NBLOCKS_TOT);
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return (lag*2); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リターン (ラグ*2);}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-17--filter-h">
A.17. filter.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.17. フィルター.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
filter.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
フィルター.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_FILTER_H #define __iLBC_FILTER_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_FILTER_H #define __iLBC_FILTER_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void AllPoleFilter(
       float *InOut,   /* (i/o) on entrance InOut[-orderCoef] to
                              InOut[-1] contain the state of the
                              filter (delayed samples). InOut[0] to
                              InOut[lengthInOut-1] contain the filter
                              input, on en exit InOut[-orderCoef] to
                              InOut[-1] is unchanged and InOut[0] to
                              InOut[lengthInOut-1] contain filtered
                              samples */
       float *Coef,/* (i) filter coefficients, Coef[0] is assumed
                              to be 1.0 */
       int lengthInOut,/* (i) number of input/output samples */
       int orderCoef   /* (i) number of filter coefficients */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void AllZeroFilter(
       float *In,      /* (i) In[0] to In[lengthInOut-1] contain
                              filter input samples */
       float *Coef,/* (i) filter coefficients (Coef[0] is assumed
                              to be 1.0) */
       int lengthInOut,/* (i) number of input/output samples */
       int orderCoef,  /* (i) number of filter coefficients */
       float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]
                              contain the filter state, on exit Out[0]
                              to Out[lengthInOut-1] contain filtered
                              samples */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void ZeroPoleFilter(
       float *In,      /* (i) In[0] to In[lengthInOut-1] contain filter
                              input samples In[-orderCoef] to In[-1]
                              contain state of all-zero section */
       float *ZeroCoef,/* (i) filter coefficients for all-zero
                              section (ZeroCoef[0] is assumed to
                              be 1.0) */
       float *PoleCoef,/* (i) filter coefficients for all-pole section
                              (ZeroCoef[0] is assumed to be 1.0) */
       int lengthInOut,/* (i) number of input/output samples */
       int orderCoef,  /* (i) number of filter coefficients */
       float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]
                              contain state of all-pole section. On
                              exit Out[0] to Out[lengthInOut-1]
                              contain filtered samples */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void DownSample (
       float  *In,     /* (i) input samples */
       float  *Coef,   /* (i) filter coefficients */
       int lengthIn,   /* (i) number of input samples */
       float  *state,  /* (i) filter state */
       float  *Out     /* (o) downsampled output */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-18--filter-c">
A.18. filter.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.18. フィルター.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
filter.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
フィルター.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  all-pole filter
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void AllPoleFilter(
       float *InOut,   /* (i/o) on entrance InOut[-orderCoef] to
                              InOut[-1] contain the state of the
                              filter (delayed samples). InOut[0] to
                              InOut[lengthInOut-1] contain the filter
                              input, on en exit InOut[-orderCoef] to
                              InOut[-1] is unchanged and InOut[0] to
                              InOut[lengthInOut-1] contain filtered
                              samples */
       float *Coef,/* (i) filter coefficients, Coef[0] is assumed
                              to be 1.0 */
       int lengthInOut,/* (i) number of input/output samples */
       int orderCoef   /* (i) number of filter coefficients */
   ){
       int n,k;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for(n=0;n&lt;lengthInOut;n++){
           for(k=1;k&lt;=orderCoef;k++){
               *InOut -= Coef[k]*InOut[-k];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           }
           InOut++;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  all-zero filter
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void AllZeroFilter(
       float *In,      /* (i) In[0] to In[lengthInOut-1] contain
                              filter input samples */
       float *Coef,/* (i) filter coefficients (Coef[0] is assumed
                              to be 1.0) */
       int lengthInOut,/* (i) number of input/output samples */
       int orderCoef,  /* (i) number of filter coefficients */
       float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]
                              contain the filter state, on exit Out[0]
                              to Out[lengthInOut-1] contain filtered
                              samples */
   ){
       int n,k;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for(n=0;n&lt;lengthInOut;n++){
           *Out = Coef[0]*In[0];
           for(k=1;k&lt;=orderCoef;k++){
               *Out += Coef[k]*In[-k];
           }
           Out++;
           In++;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  pole-zero filter
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void ZeroPoleFilter(
       float *In,      /* (i) In[0] to In[lengthInOut-1] contain
                              filter input samples In[-orderCoef] to
                              In[-1] contain state of all-zero
                              section */
       float *ZeroCoef,/* (i) filter coefficients for all-zero
                              section (ZeroCoef[0] is assumed to
                              be 1.0) */
       float *PoleCoef,/* (i) filter coefficients for all-pole section
                              (ZeroCoef[0] is assumed to be 1.0) */
       int lengthInOut,/* (i) number of input/output samples */
          int orderCoef,  /* (i) number of filter coefficients */
       float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]
                              contain state of all-pole section. On
                              exit Out[0] to Out[lengthInOut-1]
                              contain filtered samples */
   ){
       AllZeroFilter(In,ZeroCoef,lengthInOut,orderCoef,Out);
       AllPoleFilter(Out,PoleCoef,lengthInOut,orderCoef);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    * downsample (LP filter and decimation)
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void DownSample (
       float  *In,     /* (i) input samples */
       float  *Coef,   /* (i) filter coefficients */
       int lengthIn,   /* (i) number of input samples */
       float  *state,  /* (i) filter state */
       float  *Out     /* (o) downsampled output */
   ){
       float   o;
       float *Out_ptr = Out;
       float *Coef_ptr, *In_ptr;
       float *state_ptr;
       int i, j, stop;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* LP filter and decimate at the same time */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = DELAY_DS; i &lt; lengthIn; i+=FACTOR_DS)
       {
           Coef_ptr = &amp;Coef[0];
           In_ptr = &amp;In[i];
           state_ptr = &amp;state[FILTERORDER_DS-2];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           o = (float)0.0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           stop = (i &lt; FILTERORDER_DS) ? i + 1 : FILTERORDER_DS;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (j = 0; j &lt; stop; j++)
           {
               o += *Coef_ptr++ * (*In_ptr--);
           }
           for (j = i + 1; j &lt; FILTERORDER_DS; j++)
           {
               o += *Coef_ptr++ * (*state_ptr--);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           *Out_ptr++ = o;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Get the last part (use zeros as input for the future) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i=(lengthIn+FACTOR_DS); i&lt;(lengthIn+DELAY_DS);
               i+=FACTOR_DS) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
o=(float)0.0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
o=(浮動小数点)0.0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (i&lt;lengthIn) {
               Coef_ptr = &amp;Coef[0];
               In_ptr = &amp;In[i];
               for (j=0; j&lt;FILTERORDER_DS; j++) {
                       o += *Coef_ptr++ * (*Out_ptr--);
               }
           } else {
               Coef_ptr = &amp;Coef[i-lengthIn];
               In_ptr = &amp;In[lengthIn-1];
               for (j=0; j&lt;FILTERORDER_DS-(i-lengthIn); j++) {
                       o += *Coef_ptr++ * (*In_ptr--);
               }
           }
           *Out_ptr++ = o;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-19--FrameClassify-h">
A.19. FrameClassify.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.19. FrameClassify.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
FrameClassify.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
FrameClassify.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_FRAMECLASSIFY_H #define __iLBC_FRAMECLASSIFY_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_FRAMECLASSIFY_H #define __iLBC_FRAMECLASSIFY_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int FrameClassify(      /* index to the max-energy sub-frame */
       iLBC_Enc_Inst_t *iLBCenc_inst,
                           /* (i/o) the encoder state structure */
       float *residual     /* (i) lpc residual signal */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-20--FrameClassify-c">
A.20. FrameClassify.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.20. FrameClassify.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
FrameClassify.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
FrameClassify.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*---------------------------------------------------------------*
    *  Classification of subframes to localize start state
    *--------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int FrameClassify(      /* index to the max-energy sub-frame */
       iLBC_Enc_Inst_t *iLBCenc_inst,
                           /* (i/o) the encoder state structure */
       float *residual     /* (i) lpc residual signal */
   ) {
       float max_ssqEn, fssqEn[NSUB_MAX], bssqEn[NSUB_MAX], *pp;
       int n, l, max_ssqEn_n;
       const float ssqEn_win[NSUB_MAX-1]={(float)0.8,(float)0.9,
           (float)1.0,(float)0.9,(float)0.8};
       const float sampEn_win[5]={(float)1.0/(float)6.0,
           (float)2.0/(float)6.0, (float)3.0/(float)6.0,
           (float)4.0/(float)6.0, (float)5.0/(float)6.0};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* init the front and back energies to zero */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memset(fssqEn, 0, NSUB_MAX*sizeof(float));
       memset(bssqEn, 0, NSUB_MAX*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Calculate front of first seqence */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       n=0;
       pp=residual;
       for (l=0; l&lt;5; l++) {
           fssqEn[n] += sampEn_win[l] * (*pp) * (*pp);
           pp++;
       }
       for (l=5; l&lt;SUBL; l++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           fssqEn[n] += (*pp) * (*pp);
           pp++;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Calculate front and back of all middle sequences */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (n=1; n&lt;iLBCenc_inst-&gt;nsub-1; n++) {
           pp=residual+n*SUBL;
           for (l=0; l&lt;5; l++) {
               fssqEn[n] += sampEn_win[l] * (*pp) * (*pp);
               bssqEn[n] += (*pp) * (*pp);
               pp++;
           }
           for (l=5; l&lt;SUBL-5; l++) {
               fssqEn[n] += (*pp) * (*pp);
               bssqEn[n] += (*pp) * (*pp);
               pp++;
           }
           for (l=SUBL-5; l&lt;SUBL; l++) {
               fssqEn[n] += (*pp) * (*pp);
               bssqEn[n] += sampEn_win[SUBL-l-1] * (*pp) * (*pp);
               pp++;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Calculate back of last seqence */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       n=iLBCenc_inst-&gt;nsub-1;
       pp=residual+n*SUBL;
       for (l=0; l&lt;SUBL-5; l++) {
           bssqEn[n] += (*pp) * (*pp);
           pp++;
       }
       for (l=SUBL-5; l&lt;SUBL; l++) {
           bssqEn[n] += sampEn_win[SUBL-l-1] * (*pp) * (*pp);
           pp++;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* find the index to the weighted 80 sample with
          most energy */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (iLBCenc_inst-&gt;mode==20) l=1;
       else                        l=0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       max_ssqEn=(fssqEn[0]+bssqEn[1])*ssqEn_win[l];
       max_ssqEn_n=1;
       for (n=2; n&lt;iLBCenc_inst-&gt;nsub; n++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           l++;
           if ((fssqEn[n-1]+bssqEn[n])*ssqEn_win[l] &gt; max_ssqEn) {
               max_ssqEn=(fssqEn[n-1]+bssqEn[n]) *
                               ssqEn_win[l];
               max_ssqEn_n=n;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return max_ssqEn_n; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max_ssqEn_n を返します。}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-21--gainquant-h">
A.21. gainquant.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.21. ゲインクォント.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
gainquant.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
ゲインクォント.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_GAINQUANT_H #define __iLBC_GAINQUANT_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_GAINQUANT_H #define __iLBC_GAINQUANT_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   float gainquant(/* (o) quantized gain value */
       float in,       /* (i) gain value */
       float maxIn,/* (i) maximum of gain value */
       int cblen,      /* (i) number of quantization indices */
       int *index      /* (o) quantization index */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   float gaindequant(  /* (o) quantized gain value */
       int index,      /* (i) quantization index */
       float maxIn,/* (i) maximum of unquantized gain */
       int cblen       /* (i) number of quantization indices */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-22--gainquant-c">
A.22. gainquant.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.22. ゲインクオント.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code gainquant.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード Gainquant.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;string.h&gt;
   #include &lt;math.h&gt;
   #include &#34;constants.h&#34;
   #include &#34;filter.h&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  quantizer for the gain in the gain-shape coding of residual
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   float gainquant(/* (o) quantized gain value */
       float in,       /* (i) gain value */
       float maxIn,/* (i) maximum of gain value */
       int cblen,      /* (i) number of quantization indices */
       int *index      /* (o) quantization index */
   ){
       int i, tindex;
       float minmeasure,measure, *cb, scale;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* ensure a lower bound on the scaling factor */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
scale=maxIn;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
スケール=最大値;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (scale&lt;0.1) {
           scale=(float)0.1;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* select the quantization table */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (cblen == 8) {
           cb = gain_sq3Tbl;
       } else if (cblen == 16) {
           cb = gain_sq4Tbl;
       } else  {
           cb = gain_sq5Tbl;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* select the best index in the quantization table */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       minmeasure=10000000.0;
       tindex=0;
       for (i=0; i&lt;cblen; i++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           measure=(in-scale*cb[i])*(in-scale*cb[i]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (measure&lt;minmeasure) {
               tindex=i;
               minmeasure=measure;
           }
       }
       *index=tindex;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* return the quantized value */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return scale*cb[tindex]; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スケール*cb[tindex]を返します;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  decoder for quantized gains in the gain-shape coding of
    *  residual
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   float gaindequant(  /* (o) quantized gain value */
       int index,      /* (i) quantization index */
       float maxIn,/* (i) maximum of unquantized gain */
       int cblen       /* (i) number of quantization indices */
   ){
       float scale;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* obtain correct scale factor */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       scale=(float)fabs(maxIn);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (scale&lt;0.1) {
           scale=(float)0.1;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* select the quantization table and return the decoded value */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (cblen==8) {
           return scale*gain_sq3Tbl[index];
       } else if (cblen==16) {
           return scale*gain_sq4Tbl[index];
       }
       else if (cblen==32) {
           return scale*gain_sq5Tbl[index];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return 0.0; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0.0を返します。}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-23--getCBvec-h">
A.23. getCBvec.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.23. getCBvec.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
getCBvec.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
getCBvec.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_GETCBVEC_H #define __iLBC_GETCBVEC_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_GETCBVEC_H #define __iLBC_GETCBVEC_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void getCBvec(
       float *cbvec,   /* (o) Constructed codebook vector */
       float *mem,     /* (i) Codebook buffer */
       int index,      /* (i) Codebook index */
       int lMem,       /* (i) Length of codebook buffer */
       int cbveclen/* (i) Codebook vector length */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-24--getCBvec-c">
A.24. getCBvec.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.24. getCBvec.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
getCBvec.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
getCBvec.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &#34;iLBC_define.h&#34;
   #include &#34;constants.h&#34;
   #include &lt;string.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  Construct codebook vector for given index.
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void getCBvec(
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void getCBvec(
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       float *cbvec,   /* (o) Constructed codebook vector */
       float *mem,     /* (i) Codebook buffer */
       int index,      /* (i) Codebook index */
       int lMem,       /* (i) Length of codebook buffer */
       int cbveclen/* (i) Codebook vector length */
   ){
       int j, k, n, memInd, sFilt;
       float tmpbuf[CB_MEML];
       int base_size;
       int ilow, ihigh;
       float alfa, alfa1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Determine size of codebook sections */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       base_size=lMem-cbveclen+1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (cbveclen==SUBL) {
           base_size+=cbveclen/2;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* No filter -&gt; First codebook section */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (index&lt;lMem-cbveclen+1) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* first non-interpolated vectors */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           k=index+cbveclen;
           /* get vector */
           memcpy(cbvec, mem+lMem-k, cbveclen*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       } else if (index &lt; base_size) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           k=2*(index-(lMem-cbveclen+1))+cbveclen;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           ihigh=k/2;
           ilow=ihigh-5;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Copy first noninterpolated part */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           memcpy(cbvec, mem+lMem-k/2, ilow*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* interpolation */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           alfa1=(float)0.2;
           alfa=0.0;
           for (j=ilow; j&lt;ihigh; j++) {
               cbvec[j]=((float)1.0-alfa)*mem[lMem-k/2+j]+
                   alfa*mem[lMem-k+j];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               alfa+=alfa1;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Copy second noninterpolated part */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           memcpy(cbvec+ihigh, mem+lMem-k+ihigh,
               (cbveclen-ihigh)*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Higher codebook section based on filtering */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
else {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
それ以外 {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* first non-interpolated vectors */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (index-base_size&lt;lMem-cbveclen+1) {
               float tempbuff2[CB_MEML+CB_FILTERLEN+1];
               float *pos;
               float *pp, *pp1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               memset(tempbuff2, 0,
                   CB_HALFFILTERLEN*sizeof(float));
               memcpy(&amp;tempbuff2[CB_HALFFILTERLEN], mem,
                   lMem*sizeof(float));
               memset(&amp;tempbuff2[lMem+CB_HALFFILTERLEN], 0,
                   (CB_HALFFILTERLEN+1)*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               k=index-base_size+cbveclen;
               sFilt=lMem-k;
               memInd=sFilt+1-CB_HALFFILTERLEN;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* do filtering */
               pos=cbvec;
               memset(pos, 0, cbveclen*sizeof(float));
               for (n=0; n&lt;cbveclen; n++) {
                   pp=&amp;tempbuff2[memInd+n+CB_HALFFILTERLEN];
                   pp1=&amp;cbfiltersTbl[CB_FILTERLEN-1];
                   for (j=0; j&lt;CB_FILTERLEN; j++) {
                       (*pos)+=(*pp++)*(*pp1--);
                   }
                   pos++;
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* interpolated vectors */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
else {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
それ以外 {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               float tempbuff2[CB_MEML+CB_FILTERLEN+1];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               float *pos;
               float *pp, *pp1;
               int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               memset(tempbuff2, 0,
                   CB_HALFFILTERLEN*sizeof(float));
               memcpy(&amp;tempbuff2[CB_HALFFILTERLEN], mem,
                   lMem*sizeof(float));
               memset(&amp;tempbuff2[lMem+CB_HALFFILTERLEN], 0,
                   (CB_HALFFILTERLEN+1)*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               k=2*(index-base_size-
                   (lMem-cbveclen+1))+cbveclen;
               sFilt=lMem-k;
               memInd=sFilt+1-CB_HALFFILTERLEN;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* do filtering */
               pos=&amp;tmpbuf[sFilt];
               memset(pos, 0, k*sizeof(float));
               for (i=0; i&lt;k; i++) {
                   pp=&amp;tempbuff2[memInd+i+CB_HALFFILTERLEN];
                   pp1=&amp;cbfiltersTbl[CB_FILTERLEN-1];
                   for (j=0; j&lt;CB_FILTERLEN; j++) {
                       (*pos)+=(*pp++)*(*pp1--);
                   }
                   pos++;
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               ihigh=k/2;
               ilow=ihigh-5;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* Copy first noninterpolated part */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               memcpy(cbvec, tmpbuf+lMem-k/2,
                   ilow*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* interpolation */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               alfa1=(float)0.2;
               alfa=0.0;
               for (j=ilow; j&lt;ihigh; j++) {
                   cbvec[j]=((float)1.0-alfa)*
                       tmpbuf[lMem-k/2+j]+alfa*tmpbuf[lMem-k+j];
                   alfa+=alfa1;
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* Copy second noninterpolated part */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               memcpy(cbvec+ihigh, tmpbuf+lMem-k+ihigh,
                   (cbveclen-ihigh)*sizeof(float));
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-25--helpfun-h">
A.25. helpfun.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.25. ヘルプファン.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
helpfun.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
ヘルプファン.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_HELPFUN_H #define __iLBC_HELPFUN_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_HELPFUN_H #define __iLBC_HELPFUN_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void autocorr(
       float *r,       /* (o) autocorrelation vector */
       const float *x, /* (i) data vector */
       int N,          /* (i) length of data vector */
       int order       /* largest lag for calculated
                          autocorrelations */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void window(
       float *z,       /* (o) the windowed data */
       const float *x, /* (i) the original data vector */
       const float *y, /* (i) the window */
       int N           /* (i) length of all vectors */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void levdurb(
       float *a,       /* (o) lpc coefficient vector starting
                              with 1.0 */
       float *k,       /* (o) reflection coefficients */
       float *r,       /* (i) autocorrelation vector */
       int order       /* (i) order of lpc filter */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void interpolate(
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void 補間(
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       float *out,     /* (o) the interpolated vector */
       float *in1,     /* (i) the first vector for the
                              interpolation */
       float *in2,     /* (i) the second vector for the
                              interpolation */
       float coef,     /* (i) interpolation weights */
       int length      /* (i) length of all vectors */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void bwexpand(
       float *out,     /* (o) the bandwidth expanded lpc
                              coefficients */
       float *in,      /* (i) the lpc coefficients before bandwidth
                              expansion */
       float coef,     /* (i) the bandwidth expansion factor */
       int length      /* (i) the length of lpc coefficient vectors */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void vq(
       float *Xq,      /* (o) the quantized vector */
       int *index,     /* (o) the quantization index */
       const float *CB,/* (i) the vector quantization codebook */
       float *X,       /* (i) the vector to quantize */
       int n_cb,       /* (i) the number of vectors in the codebook */
       int dim         /* (i) the dimension of all vectors */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void SplitVQ(
       float *qX,      /* (o) the quantized vector */
       int *index,     /* (o) a vector of indexes for all vector
                              codebooks in the split */
       float *X,       /* (i) the vector to quantize */
       const float *CB,/* (i) the quantizer codebook */
       int nsplit,     /* the number of vector splits */
       const int *dim, /* the dimension of X and qX */
       const int *cbsize /* the number of vectors in the codebook */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void sort_sq(
       float *xq,      /* (o) the quantized value */
       int *index,     /* (o) the quantization index */
       float x,    /* (i) the value to quantize */
       const float *cb,/* (i) the quantization codebook */
       int cb_size     /* (i) the size of the quantization codebook */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int LSF_check(      /* (o) 1 for stable lsf vectors and 0 for
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                              nonstable ones */
       float *lsf,     /* (i) a table of lsf vectors */
       int dim,    /* (i) the dimension of each lsf vector */
       int NoAn    /* (i) the number of lsf vectors in the
                              table */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-26--helpfun-c">
A.26. helpfun.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.26. ヘルプファン.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
helpfun.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
ヘルプファン.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;math.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;constants.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;constants.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  calculation of auto correlation
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void autocorr(
       float *r,       /* (o) autocorrelation vector */
       const float *x, /* (i) data vector */
       int N,          /* (i) length of data vector */
       int order       /* largest lag for calculated
                          autocorrelations */
   ){
       int     lag, n;
       float   sum;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (lag = 0; lag &lt;= order; lag++) {
           sum = 0;
           for (n = 0; n &lt; N - lag; n++) {
               sum += x[n] * x[n+lag];
           }
           r[lag] = sum;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  window multiplication
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void window(
       float *z,       /* (o) the windowed data */
       const float *x, /* (i) the original data vector */
       const float *y, /* (i) the window */
       int N           /* (i) length of all vectors */
   ){
       int     i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i &lt; N; i++) {
           z[i] = x[i] * y[i];
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  levinson-durbin solution for lpc coefficients
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void levdurb(
       float *a,       /* (o) lpc coefficient vector starting
                              with 1.0 */
       float *k,       /* (o) reflection coefficients */
       float *r,       /* (i) autocorrelation vector */
       int order       /* (i) order of lpc filter */
   ){
       float  sum, alpha;
       int     m, m_h, i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
a[0] = 1.0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
a[0] = 1.0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (r[0] &lt; EPS) { /* if r[0] &lt;= 0, set LPC coeff. to zero */
           for (i = 0; i &lt; order; i++) {
               k[i] = 0;
               a[i+1] = 0;
           }
       } else {
           a[1] = k[0] = -r[1]/r[0];
           alpha = r[0] + r[1] * k[0];
           for (m = 1; m &lt; order; m++){
               sum = r[m + 1];
               for (i = 0; i &lt; m; i++){
                   sum += a[i+1] * r[m - i];
               }
                  k[m] = -sum / alpha;
               alpha += k[m] * sum;
               m_h = (m + 1) &gt;&gt; 1;
               for (i = 0; i &lt; m_h; i++){
                   sum = a[i+1] + k[m] * a[m - i];
                   a[m - i] += k[m] * a[i+1];
                   a[i+1] = sum;
               }
               a[m+1] = k[m];
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  interpolation between vectors
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void interpolate(
       float *out,      /* (o) the interpolated vector */
       float *in1,     /* (i) the first vector for the
                              interpolation */
       float *in2,     /* (i) the second vector for the
                              interpolation */
       float coef,      /* (i) interpolation weights */
       int length      /* (i) length of all vectors */
   ){
       int i;
       float invcoef;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       invcoef = (float)1.0 - coef;
       for (i = 0; i &lt; length; i++) {
           out[i] = coef * in1[i] + invcoef * in2[i];
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  lpc bandwidth expansion
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void bwexpand(
       float *out,      /* (o) the bandwidth expanded lpc
                              coefficients */
       float *in,      /* (i) the lpc coefficients before bandwidth
                              expansion */
       float coef,     /* (i) the bandwidth expansion factor */
       int length      /* (i) the length of lpc coefficient vectors */
   ){
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
float chirp;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
フロートチャープ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
chirp = coef;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
チャープ = 係数;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       out[0] = in[0];
       for (i = 1; i &lt; length; i++) {
           out[i] = chirp * in[i];
           chirp *= coef;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  vector quantization
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void vq(
       float *Xq,      /* (o) the quantized vector */
       int *index,     /* (o) the quantization index */
       const float *CB,/* (i) the vector quantization codebook */
       float *X,       /* (i) the vector to quantize */
       int n_cb,       /* (i) the number of vectors in the codebook */
       int dim         /* (i) the dimension of all vectors */
   ){
       int     i, j;
       int     pos, minindex;
       float   dist, tmp, mindist;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       pos = 0;
       mindist = FLOAT_MAX;
       minindex = 0;
       for (j = 0; j &lt; n_cb; j++) {
           dist = X[0] - CB[pos];
           dist *= dist;
           for (i = 1; i &lt; dim; i++) {
               tmp = X[i] - CB[pos + i];
               dist += tmp*tmp;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (dist &lt; mindist) {
               mindist = dist;
               minindex = j;
           }
           pos += dim;
       }
       for (i = 0; i &lt; dim; i++) {
           Xq[i] = CB[minindex*dim + i];
       }
       *index = minindex;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  split vector quantization
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void SplitVQ(
       float *qX,      /* (o) the quantized vector */
       int *index,     /* (o) a vector of indexes for all vector
                              codebooks in the split */
       float *X,       /* (i) the vector to quantize */
       const float *CB,/* (i) the quantizer codebook */
       int nsplit,     /* the number of vector splits */
       const int *dim, /* the dimension of X and qX */
       const int *cbsize /* the number of vectors in the codebook */
   ){
       int    cb_pos, X_pos, i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       cb_pos = 0;
       X_pos= 0;
       for (i = 0; i &lt; nsplit; i++) {
           vq(qX + X_pos, index + i, CB + cb_pos, X + X_pos,
               cbsize[i], dim[i]);
           X_pos += dim[i];
           cb_pos += dim[i] * cbsize[i];
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  scalar quantization
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void sort_sq(
       float *xq,      /* (o) the quantized value */
       int *index,     /* (o) the quantization index */
       float x,    /* (i) the value to quantize */
       const float *cb,/* (i) the quantization codebook */
       int cb_size      /* (i) the size of the quantization codebook */
   ){
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (x &lt;= cb[0]) {
           *index = 0;
           *xq = cb[0];
       } else {
           i = 0;
           while ((x &gt; cb[i]) &amp;&amp; i &lt; cb_size - 1) {
               i++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (x &gt; ((cb[i] + cb[i - 1])/2)) {
               *index = i;
               *xq = cb[i];
           } else {
               *index = i - 1;
               *xq = cb[i - 1];
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  check for stability of lsf coefficients
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int LSF_check(    /* (o) 1 for stable lsf vectors and 0 for
                              nonstable ones */
       float *lsf,     /* (i) a table of lsf vectors */
       int dim,    /* (i) the dimension of each lsf vector */
       int NoAn    /* (i) the number of lsf vectors in the
                              table */
   ){
       int k,n,m, Nit=2, change=0,pos;
       float tmp;
       static float eps=(float)0.039; /* 50 Hz */
       static float eps2=(float)0.0195;
       static float maxlsf=(float)3.14; /* 4000 Hz */
       static float minlsf=(float)0.01; /* 0 Hz */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* LSF separation check*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (n=0; n&lt;Nit; n++) { /* Run through a couple of times */
           for (m=0; m&lt;NoAn; m++) { /* Number of analyses per frame */
               for (k=0; k&lt;(dim-1); k++) {
                   pos=m*dim+k;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   if ((lsf[pos+1]-lsf[pos])&lt;eps) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       if (lsf[pos+1]&lt;lsf[pos]) {
                           tmp=lsf[pos+1];
                           lsf[pos+1]= lsf[pos]+eps2;
                           lsf[pos]= lsf[pos+1]-eps2;
                       } else {
                           lsf[pos]-=eps2;
                           lsf[pos+1]+=eps2;
                       }
                       change=1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   if (lsf[pos]&lt;minlsf) {
                       lsf[pos]=minlsf;
                       change=1;
                   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   if (lsf[pos]&gt;maxlsf) {
                       lsf[pos]=maxlsf;
                       change=1;
                   }
               }
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return change; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
釣り銭を返す。}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-27--hpInput-h">
A.27. hpInput.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.27. hpInput.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
hpInput.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
hpInput.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_HPINPUT_H #define __iLBC_HPINPUT_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_HPINPUT_H #define __iLBC_HPINPUT_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void hpInput(
       float *In,  /* (i) vector to filter */
       int len,    /* (i) length of vector to filter */
       float *Out, /* (o) the resulting filtered vector */
       float *mem  /* (i/o) the filter state */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-28--hpInput-c">
A.28. hpInput.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.28. hpInput.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code hpInput.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード hpInput.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;constants.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;定数.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  Input high-pass filter
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void hpInput(
       float *In,  /* (i) vector to filter */
       int len,    /* (i) length of vector to filter */
       float *Out, /* (o) the resulting filtered vector */
       float *mem  /* (i/o) the filter state */
   ){
       int i;
       float *pi, *po;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* all-zero section*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       pi = &amp;In[0];
       po = &amp;Out[0];
       for (i=0; i&lt;len; i++) {
           *po = hpi_zero_coefsTbl[0] * (*pi);
           *po += hpi_zero_coefsTbl[1] * mem[0];
           *po += hpi_zero_coefsTbl[2] * mem[1];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           mem[1] = mem[0];
           mem[0] = *pi;
           po++;
           pi++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* all-pole section*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       po = &amp;Out[0];
       for (i=0; i&lt;len; i++) {
           *po -= hpi_pole_coefsTbl[1] * mem[2];
           *po -= hpi_pole_coefsTbl[2] * mem[3];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           mem[3] = mem[2];
           mem[2] = *po;
           po++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-29--hpOutput-h">
A.29. hpOutput.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.29. hp出力.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
hpOutput.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
hp出力.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_HPOUTPUT_H #define __iLBC_HPOUTPUT_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_HPOUTPUT_H #define __iLBC_HPOUTPUT_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void hpOutput(
       float *In,  /* (i) vector to filter */
       int len,/* (i) length of vector to filter */
       float *Out, /* (o) the resulting filtered vector */
       float *mem  /* (i/o) the filter state */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-30--hpOutput-c">
A.30. hpOutput.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.30. hp出力.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
hpOutput.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
hp出力.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;constants.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;定数.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  Output high-pass filter
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void hpOutput(
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void hpOutput(
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       float *In,  /* (i) vector to filter */
       int len,/* (i) length of vector to filter */
       float *Out, /* (o) the resulting filtered vector */
       float *mem  /* (i/o) the filter state */
   ){
       int i;
       float *pi, *po;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* all-zero section*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       pi = &amp;In[0];
       po = &amp;Out[0];
       for (i=0; i&lt;len; i++) {
           *po = hpo_zero_coefsTbl[0] * (*pi);
           *po += hpo_zero_coefsTbl[1] * mem[0];
           *po += hpo_zero_coefsTbl[2] * mem[1];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           mem[1] = mem[0];
           mem[0] = *pi;
           po++;
           pi++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* all-pole section*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       po = &amp;Out[0];
       for (i=0; i&lt;len; i++) {
           *po -= hpo_pole_coefsTbl[1] * mem[2];
           *po -= hpo_pole_coefsTbl[2] * mem[3];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           mem[3] = mem[2];
           mem[2] = *po;
           po++;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-31--iCBConstruct-h">
A.31. iCBConstruct.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.31. iCBConstruct.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iCBConstruct.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iCBConstruct.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_ICBCONSTRUCT_H #define __iLBC_ICBCONSTRUCT_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_ICBCONSTRUCT_H #define __iLBC_ICBCONSTRUCT_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void index_conv_enc(
       int *index          /* (i/o) Codebook indexes */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void index_conv_dec(
       int *index          /* (i/o) Codebook indexes */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void iCBConstruct(
       float *decvector,   /* (o) Decoded vector */
       int *index,         /* (i) Codebook indices */
       int *gain_index,/* (i) Gain quantization indices */
       float *mem,         /* (i) Buffer for codevector construction */
       int lMem,           /* (i) Length of buffer */
       int veclen,         /* (i) Length of vector */
       int nStages         /* (i) Number of codebook stages */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-32--iCBConstruct-c">
A.32. iCBConstruct.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.32. iCBConstruct.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iCBConstruct.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iCBConstruct.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;math.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;gainquant.h&#34; #include &#34;getCBvec.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;gainquant.h&#34; #include &#34;getCBvec.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  Convert the codebook indexes to make the search easier
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void index_conv_enc(
       int *index          /* (i/o) Codebook indexes */
   ){
       int k;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (k=1; k&lt;CB_NSTAGES; k++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if ((index[k]&gt;=108)&amp;&amp;(index[k]&lt;172)) {
               index[k]-=64;
           } else if (index[k]&gt;=236) {
               index[k]-=128;
           } else {
               /* ERROR */
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void index_conv_dec(
       int *index          /* (i/o) Codebook indexes */
   ){
       int k;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (k=1; k&lt;CB_NSTAGES; k++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if ((index[k]&gt;=44)&amp;&amp;(index[k]&lt;108)) {
               index[k]+=64;
           } else if ((index[k]&gt;=108)&amp;&amp;(index[k]&lt;128)) {
               index[k]+=128;
           } else {
               /* ERROR */
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  Construct decoded vector from codebook and gains.
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void iCBConstruct(
       float *decvector,   /* (o) Decoded vector */
       int *index,         /* (i) Codebook indices */
       int *gain_index,/* (i) Gain quantization indices */
       float *mem,         /* (i) Buffer for codevector construction */
       int lMem,           /* (i) Length of buffer */
       int veclen,         /* (i) Length of vector */
       int nStages         /* (i) Number of codebook stages */
   ){
       int j,k;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
float gain[CB_NSTAGES]; float cbvec[SUBL];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
浮動小数点ゲイン[CB_NSTAGES];float cbvec[SUBL];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* gain de-quantization */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       gain[0] = gaindequant(gain_index[0], 1.0, 32);
       if (nStages &gt; 1) {
           gain[1] = gaindequant(gain_index[1],
               (float)fabs(gain[0]), 16);
       }
       if (nStages &gt; 2) {
           gain[2] = gaindequant(gain_index[2],
               (float)fabs(gain[1]), 8);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* codebook vector construction and construction of
       total vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       getCBvec(cbvec, mem, index[0], lMem, veclen);
       for (j=0;j&lt;veclen;j++){
           decvector[j] = gain[0]*cbvec[j];
       }
       if (nStages &gt; 1) {
           for (k=1; k&lt;nStages; k++) {
               getCBvec(cbvec, mem, index[k], lMem, veclen);
               for (j=0;j&lt;veclen;j++) {
                   decvector[j] += gain[k]*cbvec[j];
               }
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-33--iCBSearch-h">
A.33. iCBSearch.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.33. iCBSearch.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iCBSearch.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iCBSearch.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #ifndef __iLBC_ICBSEARCH_H
   #define __iLBC_ICBSEARCH_H
      void iCBSearch(
       iLBC_Enc_Inst_t *iLBCenc_inst,
                           /* (i) the encoder state structure */
       int *index,         /* (o) Codebook indices */
       int *gain_index,/* (o) Gain quantization indices */
       float *intarget,/* (i) Target vector for encoding */
       float *mem,         /* (i) Buffer for codebook construction */
       int lMem,           /* (i) Length of buffer */
       int lTarget,    /* (i) Length of vector */
       int nStages,    /* (i) Number of codebook stages */
       float *weightDenum, /* (i) weighting filter coefficients */
       float *weightState, /* (i) weighting filter state */
       int block           /* (i) the sub-block number */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-34--iCBSearch-c">
A.34. iCBSearch.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.34. iCBSearch.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iCBSearch.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iCBSearch.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;math.h&gt;
   #include &lt;string.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;gainquant.h&#34; #include &#34;createCB.h&#34; #include &#34;filter.h&#34; #include &#34;constants.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;gainquant.h&#34; #include &#34;createCB.h&#34; #include &#34;filter.h&#34; #include &#34;constants.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  Search routine for codebook encoding and gain quantization.
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void iCBSearch(
       iLBC_Enc_Inst_t *iLBCenc_inst,
                           /* (i) the encoder state structure */
       int *index,         /* (o) Codebook indices */
       int *gain_index,/* (o) Gain quantization indices */
          float *intarget,/* (i) Target vector for encoding */
       float *mem,         /* (i) Buffer for codebook construction */
       int lMem,           /* (i) Length of buffer */
       int lTarget,    /* (i) Length of vector */
       int nStages,    /* (i) Number of codebook stages */
       float *weightDenum, /* (i) weighting filter coefficients */
       float *weightState, /* (i) weighting filter state */
       int block           /* (i) the sub-block number */
   ){
       int i, j, icount, stage, best_index, range, counter;
       float max_measure, gain, measure, crossDot, ftmp;
       float gains[CB_NSTAGES];
       float target[SUBL];
       int base_index, sInd, eInd, base_size;
       int sIndAug=0, eIndAug=0;
       float buf[CB_MEML+SUBL+2*LPC_FILTERORDER];
       float invenergy[CB_EXPAND*128], energy[CB_EXPAND*128];
       float *pp, *ppi=0, *ppo=0, *ppe=0;
       float cbvectors[CB_MEML];
       float tene, cene, cvec[SUBL];
       float aug_vec[SUBL];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memset(cvec,0,SUBL*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Determine size of codebook sections */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       base_size=lMem-lTarget+1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (lTarget==SUBL) {
           base_size=lMem-lTarget+1+lTarget/2;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* setup buffer for weighting */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memcpy(buf,weightState,sizeof(float)*LPC_FILTERORDER);
       memcpy(buf+LPC_FILTERORDER,mem,lMem*sizeof(float));
       memcpy(buf+LPC_FILTERORDER+lMem,intarget,lTarget*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* weighting */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       AllPoleFilter(buf+LPC_FILTERORDER, weightDenum,
           lMem+lTarget, LPC_FILTERORDER);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Construct the codebook and target needed */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memcpy(target, buf+LPC_FILTERORDER+lMem, lTarget*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
tene=0.0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
10 = 0.0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i=0; i&lt;lTarget; i++) {
           tene+=target[i]*target[i];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Prepare search over one more codebook section. This section
          is created by filtering the original buffer with a filter. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       filteredCBvecs(cbvectors, buf+LPC_FILTERORDER, lMem);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* The Main Loop over stages */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (stage=0; stage&lt;nStages; stage++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
range = search_rangeTbl[block][stage];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
range = search_rangeTbl[ブロック][ステージ];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* initialize search measure */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           max_measure = (float)-10000000.0;
           gain = (float)0.0;
           best_index = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Compute cross dot product between the target
              and the CB memory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           crossDot=0.0;
           pp=buf+LPC_FILTERORDER+lMem-lTarget;
           for (j=0; j&lt;lTarget; j++) {
               crossDot += target[j]*(*pp++);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (stage==0) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* Calculate energy in the first block of
                 &#39;lTarget&#39; samples. */
               ppe = energy;
               ppi = buf+LPC_FILTERORDER+lMem-lTarget-1;
               ppo = buf+LPC_FILTERORDER+lMem-1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               *ppe=0.0;
               pp=buf+LPC_FILTERORDER+lMem-lTarget;
               for (j=0; j&lt;lTarget; j++) {
                   *ppe+=(*pp)*(*pp++);
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (*ppe&gt;0.0) {
                   invenergy[0] = (float) 1.0 / (*ppe + EPS);
               } else {
                   invenergy[0] = (float) 0.0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               }
               ppe++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
measure=(float)-10000000.0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
メジャー = (浮動小数点数)-10000000.0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (crossDot &gt; 0.0) {
                      measure = crossDot*crossDot*invenergy[0];
               }
           }
           else {
               measure = crossDot*crossDot*invenergy[0];
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* check if measure is better */
           ftmp = crossDot*invenergy[0];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if ((measure&gt;max_measure) &amp;&amp; (fabs(ftmp)&lt;CB_MAXGAIN)) {
               best_index = 0;
               max_measure = measure;
               gain = ftmp;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* loop over the main first codebook section,
              full search */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (icount=1; icount&lt;range; icount++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* calculate measure */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               crossDot=0.0;
               pp = buf+LPC_FILTERORDER+lMem-lTarget-icount;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               for (j=0; j&lt;lTarget; j++) {
                   crossDot += target[j]*(*pp++);
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (stage==0) {
                   *ppe++ = energy[icount-1] + (*ppi)*(*ppi) -
                       (*ppo)*(*ppo);
                   ppo--;
                   ppi--;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   if (energy[icount]&gt;0.0) {
                       invenergy[icount] =
                           (float)1.0/(energy[icount]+EPS);
                   } else {
                       invenergy[icount] = (float) 0.0;
                   }
                                      measure=(float)-10000000.0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   if (crossDot &gt; 0.0) {
                       measure = crossDot*crossDot*invenergy[icount];
                   }
               }
               else {
                   measure = crossDot*crossDot*invenergy[icount];
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* check if measure is better */
               ftmp = crossDot*invenergy[icount];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if ((measure&gt;max_measure) &amp;&amp; (fabs(ftmp)&lt;CB_MAXGAIN)) {
                   best_index = icount;
                   max_measure = measure;
                   gain = ftmp;
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Loop over augmented part in the first codebook
            * section, full search.
            * The vectors are interpolated.
            */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (lTarget==SUBL) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* Search for best possible cb vector and
                  compute the CB-vectors&#39; energy. */
               searchAugmentedCB(20, 39, stage, base_size-lTarget/2,
                   target, buf+LPC_FILTERORDER+lMem,
                   &amp;max_measure, &amp;best_index, &amp;gain, energy,
                   invenergy);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* set search range for following codebook sections */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
base_index=best_index;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
ベースインデックス=ベストインデックス;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* unrestricted search */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (CB_RESRANGE == -1) {
               sInd=0;
               eInd=range-1;
               sIndAug=20;
               eIndAug=39;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* restricted search around best index from first
           codebook section */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           else {
               /* Initialize search indices */
               sIndAug=0;
               eIndAug=0;
               sInd=base_index-CB_RESRANGE/2;
               eInd=sInd+CB_RESRANGE;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (lTarget==SUBL) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
if (sInd&lt;0) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
if (sInd&lt;0) {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       sIndAug = 40 + sInd;
                       eIndAug = 39;
                       sInd=0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   } else if ( base_index &lt; (base_size-20) ) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       if (eInd &gt; range) {
                           sInd -= (eInd-range);
                           eInd = range;
                       }
                   } else { /* base_index &gt;= (base_size-20) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       if (sInd &lt; (base_size-20)) {
                           sIndAug = 20;
                           sInd = 0;
                           eInd = 0;
                           eIndAug = 19 + CB_RESRANGE;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                           if(eIndAug &gt; 39) {
                               eInd = eIndAug-39;
                               eIndAug = 39;
                           }
                       } else {
                           sIndAug = 20 + sInd - (base_size-20);
                           eIndAug = 39;
                           sInd = 0;
                           eInd = CB_RESRANGE - (eIndAug-sIndAug+1);
                       }
                   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               } else { /* lTarget = 22 or 23 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   if (sInd &lt; 0) {
                       eInd -= sInd;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
 sInd = 0; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
sInd = 0;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   if(eInd &gt; range) {
                       sInd -= (eInd - range);
                       eInd = range;
                   }
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* search of higher codebook section */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* index search range */
           counter = sInd;
           sInd += base_size;
           eInd += base_size;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (stage==0) {
               ppe = energy+base_size;
               *ppe=0.0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               pp=cbvectors+lMem-lTarget;
               for (j=0; j&lt;lTarget; j++) {
                   *ppe+=(*pp)*(*pp++);
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               ppi = cbvectors + lMem - 1 - lTarget;
               ppo = cbvectors + lMem - 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               for (j=0; j&lt;(range-1); j++) {
                   *(ppe+1) = *ppe + (*ppi)*(*ppi) - (*ppo)*(*ppo);
                   ppo--;
                   ppi--;
                   ppe++;
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* loop over search range */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (icount=sInd; icount&lt;eInd; icount++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* calculate measure */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               crossDot=0.0;
               pp=cbvectors + lMem - (counter++) - lTarget;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               for (j=0;j&lt;lTarget;j++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   crossDot += target[j]*(*pp++);
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (energy[icount]&gt;0.0) {
                   invenergy[icount] =(float)1.0/(energy[icount]+EPS);
               } else {
                   invenergy[icount] =(float)0.0;
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (stage==0) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
measure=(float)-10000000.0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
メジャー = (浮動小数点数)-10000000.0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   if (crossDot &gt; 0.0) {
                       measure = crossDot*crossDot*
                           invenergy[icount];
                   }
               }
               else {
                   measure = crossDot*crossDot*invenergy[icount];
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* check if measure is better */
               ftmp = crossDot*invenergy[icount];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if ((measure&gt;max_measure) &amp;&amp; (fabs(ftmp)&lt;CB_MAXGAIN)) {
                   best_index = icount;
                   max_measure = measure;
                   gain = ftmp;
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Search the augmented CB inside the limited range. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if ((lTarget==SUBL)&amp;&amp;(sIndAug!=0)) {
               searchAugmentedCB(sIndAug, eIndAug, stage,
                   2*base_size-20, target, cbvectors+lMem,
                   &amp;max_measure, &amp;best_index, &amp;gain, energy,
                   invenergy);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* record best index */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
index[stage] = best_index;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
インデックス[ステージ] = best_index;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* gain quantization */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (stage==0){
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (gain&lt;0.0){
                   gain = 0.0;
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (gain&gt;CB_MAXGAIN) {
                   gain = (float)CB_MAXGAIN;
               }
               gain = gainquant(gain, 1.0, 32, &amp;gain_index[stage]);
           }
           else {
               if (stage==1) {
                   gain = gainquant(gain, (float)fabs(gains[stage-1]),
                       16, &amp;gain_index[stage]);
               } else {
                   gain = gainquant(gain, (float)fabs(gains[stage-1]),
                       8, &amp;gain_index[stage]);
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Extract the best (according to measure)
              codebook vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (lTarget==(STATE_LEN-iLBCenc_inst-&gt;state_short_len)) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (index[stage]&lt;base_size) {
                   pp=buf+LPC_FILTERORDER+lMem-lTarget-index[stage];
               } else {
                   pp=cbvectors+lMem-lTarget-
                       index[stage]+base_size;
               }
           } else {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (index[stage]&lt;base_size) {
                   if (index[stage]&lt;(base_size-20)) {
                       pp=buf+LPC_FILTERORDER+lMem-
                           lTarget-index[stage];
                   } else {
                       createAugmentedVec(index[stage]-base_size+40,
                               buf+LPC_FILTERORDER+lMem,aug_vec);
                       pp=aug_vec;
                   }
               } else {
                   int filterno, position;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   filterno=index[stage]/base_size;
                   position=index[stage]-filterno*base_size;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   if (position&lt;(base_size-20)) {
                       pp=cbvectors+filterno*lMem-lTarget-
                           index[stage]+filterno*base_size;
                   } else {
                       createAugmentedVec(
                           index[stage]-(filterno+1)*base_size+40,
                           cbvectors+filterno*lMem,aug_vec);
                       pp=aug_vec;
                   }
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Subtract the best codebook vector, according
              to measure, from the target vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (j=0;j&lt;lTarget;j++) {
               cvec[j] += gain*(*pp);
               target[j] -= gain*(*pp++);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* record quantized gain */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
gains[stage]=gain;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
ゲイン[段階]=ゲイン;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       }/* end of Main Loop. for (stage=0;... */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Gain adjustment for energy matching */
       cene=0.0;
       for (i=0; i&lt;lTarget; i++) {
           cene+=cvec[i]*cvec[i];
       }
       j=gain_index[0];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i=gain_index[0]; i&lt;32; i++) {
           ftmp=cene*gain_sq5Tbl[i]*gain_sq5Tbl[i];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if ((ftmp&lt;(tene*gains[0]*gains[0])) &amp;&amp;
               (gain_sq5Tbl[j]&lt;(2.0*gains[0]))) {
               j=i;
           }
       }
       gain_index[0]=j;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-35--LPCdecode-h">
A.35. LPCdecode.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.35. LPCdecode.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
LPC_decode.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
LPC_デコード.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_LPC_DECODE_H #define __iLBC_LPC_DECODE_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_LPC_DECODE_H #define __iLBC_LPC_DECODE_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void LSFinterpolate2a_dec(
       float *a,           /* (o) lpc coefficients for a sub-frame */
       float *lsf1,    /* (i) first lsf coefficient vector */
       float *lsf2,    /* (i) second lsf coefficient vector */
       float coef,         /* (i) interpolation weight */
       int length          /* (i) length of lsf vectors */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void SimplelsfDEQ(
       float *lsfdeq,      /* (o) dequantized lsf coefficients */
       int *index,         /* (i) quantization index */
       int lpc_n           /* (i) number of LPCs */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void DecoderInterpolateLSF(
       float *syntdenum,   /* (o) synthesis filter coefficients */
       float *weightdenum, /* (o) weighting denumerator
                                  coefficients */
       float *lsfdeq,      /* (i) dequantized lsf coefficients */
       int length,         /* (i) length of lsf coefficient vector */
       iLBC_Dec_Inst_t *iLBCdec_inst
                           /* (i) the decoder state structure */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-36--LPCdecode-c">
A.36. LPCdecode.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.36. LPCデコード.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
LPC_decode.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
LPC_デコード.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;math.h&gt;
   #include &lt;string.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;helpfun.h&#34; #include &#34;lsf.h&#34; #include &#34;iLBC_define.h&#34; #include &#34;constants.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;helpfun.h&#34; #include &#34;lsf.h&#34; #include &#34;iLBC_define.h&#34; #include &#34;constants.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*---------------------------------------------------------------*
    *  interpolation of lsf coefficients for the decoder
    *--------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void LSFinterpolate2a_dec(
       float *a,           /* (o) lpc coefficients for a sub-frame */
       float *lsf1,    /* (i) first lsf coefficient vector */
       float *lsf2,    /* (i) second lsf coefficient vector */
       float coef,         /* (i) interpolation weight */
       int length          /* (i) length of lsf vectors */
   ){
       float  lsftmp[LPC_FILTERORDER];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       interpolate(lsftmp, lsf1, lsf2, coef, length);
       lsf2a(a, lsftmp);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*---------------------------------------------------------------*
    *  obtain dequantized lsf coefficients from quantization index
    *--------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void SimplelsfDEQ(
       float *lsfdeq,    /* (o) dequantized lsf coefficients */
       int *index,         /* (i) quantization index */
       int lpc_n           /* (i) number of LPCs */
   ){
       int i, j, pos, cb_pos;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* decode first LSF */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       pos = 0;
       cb_pos = 0;
       for (i = 0; i &lt; LSF_NSPLIT; i++) {
           for (j = 0; j &lt; dim_lsfCbTbl[i]; j++) {
               lsfdeq[pos + j] = lsfCbTbl[cb_pos +
                   (long)(index[i])*dim_lsfCbTbl[i] + j];
           }
           pos += dim_lsfCbTbl[i];
           cb_pos += size_lsfCbTbl[i]*dim_lsfCbTbl[i];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (lpc_n&gt;1) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (lpc_n&gt;1) {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* decode last LSF */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           pos = 0;
           cb_pos = 0;
           for (i = 0; i &lt; LSF_NSPLIT; i++) {
               for (j = 0; j &lt; dim_lsfCbTbl[i]; j++) {
                   lsfdeq[LPC_FILTERORDER + pos + j] =
                       lsfCbTbl[cb_pos +
                       (long)(index[LSF_NSPLIT + i])*
                       dim_lsfCbTbl[i] + j];
               }
               pos += dim_lsfCbTbl[i];
               cb_pos += size_lsfCbTbl[i]*dim_lsfCbTbl[i];
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  obtain synthesis and weighting filters form lsf coefficients
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void DecoderInterpolateLSF(
       float *syntdenum, /* (o) synthesis filter coefficients */
       float *weightdenum, /* (o) weighting denumerator
                                  coefficients */
       float *lsfdeq,       /* (i) dequantized lsf coefficients */
       int length,         /* (i) length of lsf coefficient vector */
       iLBC_Dec_Inst_t *iLBCdec_inst
                           /* (i) the decoder state structure */
   ){
       int    i, pos, lp_length;
       float  lp[LPC_FILTERORDER + 1], *lsfdeq2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       lsfdeq2 = lsfdeq + length;
       lp_length = length + 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (iLBCdec_inst-&gt;mode==30) {
           /* sub-frame 1: Interpolation between old and first */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           LSFinterpolate2a_dec(lp, iLBCdec_inst-&gt;lsfdeqold, lsfdeq,
               lsf_weightTbl_30ms[0], length);
           memcpy(syntdenum,lp,lp_length*sizeof(float));
           bwexpand(weightdenum, lp, LPC_CHIRP_WEIGHTDENUM,
               lp_length);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* sub-frames 2 to 6: interpolation between first
              and last LSF */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           pos = lp_length;
           for (i = 1; i &lt; 6; i++) {
               LSFinterpolate2a_dec(lp, lsfdeq, lsfdeq2,
                   lsf_weightTbl_30ms[i], length);
               memcpy(syntdenum + pos,lp,lp_length*sizeof(float));
               bwexpand(weightdenum + pos, lp,
                   LPC_CHIRP_WEIGHTDENUM, lp_length);
               pos += lp_length;
           }
       }
       else {
           pos = 0;
           for (i = 0; i &lt; iLBCdec_inst-&gt;nsub; i++) {
               LSFinterpolate2a_dec(lp, iLBCdec_inst-&gt;lsfdeqold,
                   lsfdeq, lsf_weightTbl_20ms[i], length);
               memcpy(syntdenum+pos,lp,lp_length*sizeof(float));
               bwexpand(weightdenum+pos, lp, LPC_CHIRP_WEIGHTDENUM,
                   lp_length);
               pos += lp_length;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* update memory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (iLBCdec_inst-&gt;mode==30)
           memcpy(iLBCdec_inst-&gt;lsfdeqold, lsfdeq2,
                       length*sizeof(float));
       else
           memcpy(iLBCdec_inst-&gt;lsfdeqold, lsfdeq,
                       length*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-37--LPCencode-h">
A.37. LPCencode.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.37. LPEncode.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
LPCencode.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
LPEncode.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_LPCENCOD_H #define __iLBC_LPCENCOD_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_LPCENCOD_H #define __iLBC_LPCENCOD_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void LPCencode(
       float *syntdenum,   /* (i/o) synthesis filter coefficients
                                  before/after encoding */
       float *weightdenum, /* (i/o) weighting denumerator coefficients
                                  before/after encoding */
       int *lsf_index,     /* (o) lsf quantization index */
       float *data,    /* (i) lsf coefficients to quantize */
       iLBC_Enc_Inst_t *iLBCenc_inst
                           /* (i/o) the encoder state structure */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-38--LPCencode-c">
A.38. LPCencode.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.38. LPエンコード.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
LPCencode.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
LPエンコード.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;string.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;helpfun.h&#34; #include &#34;lsf.h&#34; #include &#34;constants.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;helpfun.h&#34; #include &#34;lsf.h&#34; #include &#34;constants.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  lpc analysis (subrutine to LPCencode)
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void SimpleAnalysis(
       float *lsf,         /* (o) lsf coefficients */
       float *data,    /* (i) new data vector */
       iLBC_Enc_Inst_t *iLBCenc_inst
                           /* (i/o) the encoder state structure */
   ){
       int k, is;
       float temp[BLOCKL_MAX], lp[LPC_FILTERORDER + 1];
       float lp2[LPC_FILTERORDER + 1];
       float r[LPC_FILTERORDER + 1];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       is=LPC_LOOKBACK+BLOCKL_MAX-iLBCenc_inst-&gt;blockl;
       memcpy(iLBCenc_inst-&gt;lpc_buffer+is,data,
           iLBCenc_inst-&gt;blockl*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* No lookahead, last window is asymmetric */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (k = 0; k &lt; iLBCenc_inst-&gt;lpc_n; k++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
is = LPC_LOOKBACK;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
= LPC_LOOKBACK;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (k &lt; (iLBCenc_inst-&gt;lpc_n - 1)) {
               window(temp, lpc_winTbl,
                   iLBCenc_inst-&gt;lpc_buffer, BLOCKL_MAX);
           } else {
               window(temp, lpc_asymwinTbl,
                   iLBCenc_inst-&gt;lpc_buffer + is, BLOCKL_MAX);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           autocorr(r, temp, BLOCKL_MAX, LPC_FILTERORDER);
           window(r, r, lpc_lagwinTbl, LPC_FILTERORDER + 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           levdurb(lp, temp, r, LPC_FILTERORDER);
           bwexpand(lp2, lp, LPC_CHIRP_SYNTDENUM, LPC_FILTERORDER+1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           a2lsf(lsf + k*LPC_FILTERORDER, lp2);
       }
       is=LPC_LOOKBACK+BLOCKL_MAX-iLBCenc_inst-&gt;blockl;
       memmove(iLBCenc_inst-&gt;lpc_buffer,
           iLBCenc_inst-&gt;lpc_buffer+LPC_LOOKBACK+BLOCKL_MAX-is,
           is*sizeof(float));
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
* lsf interpolator and conversion from lsf to a coefficients * (subrutine to SimpleInterpolateLSF) *---------------------------------------------------------------*/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
* LSF 補間器と LSF から係数への変換 * (サブルーチンから SimpleInterpolateLSF) *---------------------------------------------------------*/
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void LSFinterpolate2a_enc(
       float *a,       /* (o) lpc coefficients */
       float *lsf1,/* (i) first set of lsf coefficients */
       float *lsf2,/* (i) second set of lsf coefficients */
       float coef,     /* (i) weighting coefficient to use between
                              lsf1 and lsf2 */
       long length      /* (i) length of coefficient vectors */
   ){
       float  lsftmp[LPC_FILTERORDER];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       interpolate(lsftmp, lsf1, lsf2, coef, length);
       lsf2a(a, lsftmp);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  lsf interpolator (subrutine to LPCencode)
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void SimpleInterpolateLSF(
       float *syntdenum,   /* (o) the synthesis filter denominator
                                  resulting from the quantized
                                  interpolated lsf */
       float *weightdenum, /* (o) the weighting filter denominator
                                  resulting from the unquantized
                                  interpolated lsf */
       float *lsf,         /* (i) the unquantized lsf coefficients */
       float *lsfdeq,      /* (i) the dequantized lsf coefficients */
       float *lsfold,      /* (i) the unquantized lsf coefficients of
                                  the previous signal frame */
       float *lsfdeqold, /* (i) the dequantized lsf coefficients of
                                  the previous signal frame */
       int length,         /* (i) should equate LPC_FILTERORDER */
       iLBC_Enc_Inst_t *iLBCenc_inst
                           /* (i/o) the encoder state structure */
   ){
       int    i, pos, lp_length;
       float  lp[LPC_FILTERORDER + 1], *lsf2, *lsfdeq2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       lsf2 = lsf + length;
       lsfdeq2 = lsfdeq + length;
       lp_length = length + 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (iLBCenc_inst-&gt;mode==30) {
           /* sub-frame 1: Interpolation between old and first
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              set of lsf coefficients */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           LSFinterpolate2a_enc(lp, lsfdeqold, lsfdeq,
               lsf_weightTbl_30ms[0], length);
           memcpy(syntdenum,lp,lp_length*sizeof(float));
           LSFinterpolate2a_enc(lp, lsfold, lsf,
               lsf_weightTbl_30ms[0], length);
           bwexpand(weightdenum, lp, LPC_CHIRP_WEIGHTDENUM, lp_length);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* sub-frame 2 to 6: Interpolation between first
              and second set of lsf coefficients */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           pos = lp_length;
           for (i = 1; i &lt; iLBCenc_inst-&gt;nsub; i++) {
               LSFinterpolate2a_enc(lp, lsfdeq, lsfdeq2,
                   lsf_weightTbl_30ms[i], length);
               memcpy(syntdenum + pos,lp,lp_length*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               LSFinterpolate2a_enc(lp, lsf, lsf2,
                   lsf_weightTbl_30ms[i], length);
               bwexpand(weightdenum + pos, lp,
                   LPC_CHIRP_WEIGHTDENUM, lp_length);
               pos += lp_length;
           }
       }
       else {
           pos = 0;
           for (i = 0; i &lt; iLBCenc_inst-&gt;nsub; i++) {
               LSFinterpolate2a_enc(lp, lsfdeqold, lsfdeq,
                   lsf_weightTbl_20ms[i], length);
               memcpy(syntdenum+pos,lp,lp_length*sizeof(float));
               LSFinterpolate2a_enc(lp, lsfold, lsf,
                   lsf_weightTbl_20ms[i], length);
               bwexpand(weightdenum+pos, lp,
                   LPC_CHIRP_WEIGHTDENUM, lp_length);
               pos += lp_length;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* update memory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (iLBCenc_inst-&gt;mode==30) {
           memcpy(lsfold, lsf2, length*sizeof(float));
           memcpy(lsfdeqold, lsfdeq2, length*sizeof(float));
       }
       else {
           memcpy(lsfold, lsf, length*sizeof(float));
           memcpy(lsfdeqold, lsfdeq, length*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  lsf quantizer (subrutine to LPCencode)
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void SimplelsfQ(
       float *lsfdeq,    /* (o) dequantized lsf coefficients
                              (dimension FILTERORDER) */
       int *index,     /* (o) quantization index */
       float *lsf,      /* (i) the lsf coefficient vector to be
                              quantized (dimension FILTERORDER ) */
       int lpc_n     /* (i) number of lsf sets to quantize */
   ){
       /* Quantize first LSF with memoryless split VQ */
       SplitVQ(lsfdeq, index, lsf, lsfCbTbl, LSF_NSPLIT,
           dim_lsfCbTbl, size_lsfCbTbl);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (lpc_n==2) {
           /* Quantize second LSF with memoryless split VQ */
           SplitVQ(lsfdeq + LPC_FILTERORDER, index + LSF_NSPLIT,
               lsf + LPC_FILTERORDER, lsfCbTbl, LSF_NSPLIT,
               dim_lsfCbTbl, size_lsfCbTbl);
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  lpc encoder
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void LPCencode(
       float *syntdenum, /* (i/o) synthesis filter coefficients
                                  before/after encoding */
       float *weightdenum, /* (i/o) weighting denumerator
                                  coefficients before/after
                                  encoding */
       int *lsf_index,     /* (o) lsf quantization index */
       float *data,    /* (i) lsf coefficients to quantize */
       iLBC_Enc_Inst_t *iLBCenc_inst
                           /* (i/o) the encoder state structure */
   ){
       float lsf[LPC_FILTERORDER * LPC_N_MAX];
       float lsfdeq[LPC_FILTERORDER * LPC_N_MAX];
       int change=0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       SimpleAnalysis(lsf, data, iLBCenc_inst);
       SimplelsfQ(lsfdeq, lsf_index, lsf, iLBCenc_inst-&gt;lpc_n);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       change=LSF_check(lsfdeq, LPC_FILTERORDER, iLBCenc_inst-&gt;lpc_n);
       SimpleInterpolateLSF(syntdenum, weightdenum,
           lsf, lsfdeq, iLBCenc_inst-&gt;lsfold,
           iLBCenc_inst-&gt;lsfdeqold, LPC_FILTERORDER, iLBCenc_inst);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-39--lsf-h">
A.39. lsf.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.39. lsf.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
lsf.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
lsf.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_LSF_H #define __iLBC_LSF_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_LSF_H #define __iLBC_LSF_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void a2lsf(
       float *freq,/* (o) lsf coefficients */
       float *a    /* (i) lpc coefficients */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void lsf2a(
       float *a_coef,  /* (o) lpc coefficients */
       float *freq     /* (i) lsf coefficients */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-40--lsf-c">
A.40. lsf.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.40. lsf.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
lsf.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
lsf.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;string.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;math.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  conversion from lpc coefficients to lsf coefficients
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void a2lsf(
       float *freq,/* (o) lsf coefficients */
       float *a    /* (i) lpc coefficients */
   ){
       float steps[LSF_NUMBER_OF_STEPS] =
           {(float)0.00635, (float)0.003175, (float)0.0015875,
           (float)0.00079375};
       float step;
       int step_idx;
       int lsp_index;
       float p[LPC_HALFORDER];
       float q[LPC_HALFORDER];
       float p_pre[LPC_HALFORDER];
       float q_pre[LPC_HALFORDER];
       float old_p, old_q, *old;
       float *pq_coef;
       float omega, old_omega;
       int i;
       float hlp, hlp1, hlp2, hlp3, hlp4, hlp5;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i=0; i&lt;LPC_HALFORDER; i++) {
           p[i] = (float)-1.0 * (a[i + 1] + a[LPC_FILTERORDER - i]);
           q[i] = a[LPC_FILTERORDER - i] - a[i + 1];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       p_pre[0] = (float)-1.0 - p[0];
       p_pre[1] = - p_pre[0] - p[1];
       p_pre[2] = - p_pre[1] - p[2];
       p_pre[3] = - p_pre[2] - p[3];
       p_pre[4] = - p_pre[3] - p[4];
       p_pre[4] = p_pre[4] / 2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       q_pre[0] = (float)1.0 - q[0];
       q_pre[1] = q_pre[0] - q[1];
       q_pre[2] = q_pre[1] - q[2];
       q_pre[3] = q_pre[2] - q[3];
       q_pre[4] = q_pre[3] - q[4];
       q_pre[4] = q_pre[4] / 2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
omega = 0.0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
オメガ = 0.0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
old_omega = 0.0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
古いオメガ = 0.0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       old_p = FLOAT_MAX;
       old_q = FLOAT_MAX;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Here we loop through lsp_index to find all the
          LPC_FILTERORDER roots for omega. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (lsp_index = 0; lsp_index&lt;LPC_FILTERORDER; lsp_index++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Depending on lsp_index being even or odd, we
           alternatively solve the roots for the two LSP equations. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if ((lsp_index &amp; 0x1) == 0) {
               pq_coef = p_pre;
               old = &amp;old_p;
           } else {
               pq_coef = q_pre;
               old = &amp;old_q;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Start with low resolution grid */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (step_idx = 0, step = steps[step_idx];
               step_idx &lt; LSF_NUMBER_OF_STEPS;){
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /*  cos(10piw) + pq(0)cos(8piw) + pq(1)cos(6piw) +
               pq(2)cos(4piw) + pq(3)cod(2piw) + pq(4) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               hlp = (float)cos(omega * TWO_PI);
               hlp1 = (float)2.0 * hlp + pq_coef[0];
               hlp2 = (float)2.0 * hlp * hlp1 - (float)1.0 +
                   pq_coef[1];
               hlp3 = (float)2.0 * hlp * hlp2 - hlp1 + pq_coef[2];
               hlp4 = (float)2.0 * hlp * hlp3 - hlp2 + pq_coef[3];
               hlp5 = hlp * hlp4 - hlp3 + pq_coef[4];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (((hlp5 * (*old)) &lt;= 0.0) || (omega &gt;= 0.5)){
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   if (step_idx == (LSF_NUMBER_OF_STEPS - 1)){
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       if (fabs(hlp5) &gt;= fabs(*old)) {
                           freq[lsp_index] = omega - step;
                       } else {
                           freq[lsp_index] = omega;
                       }
                                              if ((*old) &gt;= 0.0){
                           *old = (float)-1.0 * FLOAT_MAX;
                       } else {
                           *old = FLOAT_MAX;
                       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       omega = old_omega;
                       step_idx = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       step_idx = LSF_NUMBER_OF_STEPS;
                   } else {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       if (step_idx == 0) {
                           old_omega = omega;
                       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       step_idx++;
                       omega -= steps[step_idx];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       /* Go back one grid step */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       step = steps[step_idx];
                   }
               } else {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* increment omega until they are of different sign,
               and we know there is at least one root between omega
               and old_omega */
                   *old = hlp5;
                   omega += step;
               }
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i = 0; i&lt;LPC_FILTERORDER; i++) {
           freq[i] = freq[i] * TWO_PI;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  conversion from lsf coefficients to lpc coefficients
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void lsf2a(
       float *a_coef,  /* (o) lpc coefficients */
       float *freq     /* (i) lsf coefficients */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ){
       int i, j;
       float hlp;
       float p[LPC_HALFORDER], q[LPC_HALFORDER];
       float a[LPC_HALFORDER + 1], a1[LPC_HALFORDER],
           a2[LPC_HALFORDER];
       float b[LPC_HALFORDER + 1], b1[LPC_HALFORDER],
           b2[LPC_HALFORDER];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i=0; i&lt;LPC_FILTERORDER; i++) {
           freq[i] = freq[i] * PI2;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Check input for ill-conditioned cases.  This part is not
       found in the TIA standard.  It involves the following 2 IF
       blocks.  If &#34;freq&#34; is judged ill-conditioned, then we first
       modify freq[0] and freq[LPC_HALFORDER-1] (normally
       LPC_HALFORDER = 10 for LPC applications), then we adjust
       the other &#34;freq&#34; values slightly */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if ((freq[0] &lt;= 0.0) || (freq[LPC_FILTERORDER - 1] &gt;= 0.5)){
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (freq[0] &lt;= 0.0) {
               freq[0] = (float)0.022;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (freq[LPC_FILTERORDER - 1] &gt;= 0.5) {
               freq[LPC_FILTERORDER - 1] = (float)0.499;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           hlp = (freq[LPC_FILTERORDER - 1] - freq[0]) /
               (float) (LPC_FILTERORDER - 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (i=1; i&lt;LPC_FILTERORDER; i++) {
               freq[i] = freq[i - 1] + hlp;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memset(a1, 0, LPC_HALFORDER*sizeof(float));
       memset(a2, 0, LPC_HALFORDER*sizeof(float));
       memset(b1, 0, LPC_HALFORDER*sizeof(float));
       memset(b2, 0, LPC_HALFORDER*sizeof(float));
       memset(a, 0, (LPC_HALFORDER+1)*sizeof(float));
       memset(b, 0, (LPC_HALFORDER+1)*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* p[i] and q[i] compute cos(2*pi*omega_{2j}) and
       cos(2*pi*omega_{2j-1} in eqs. 4.2.2.2-1 and 4.2.2.2-2.
       Note that for this code p[i] specifies the coefficients
       used in .Q_A(z) while q[i] specifies the coefficients used
       in .P_A(z) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i=0; i&lt;LPC_HALFORDER; i++) {
           p[i] = (float)cos(TWO_PI * freq[2 * i]);
           q[i] = (float)cos(TWO_PI * freq[2 * i + 1]);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       a[0] = 0.25;
       b[0] = 0.25;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i= 0; i&lt;LPC_HALFORDER; i++) {
           a[i + 1] = a[i] - 2 * p[i] * a1[i] + a2[i];
           b[i + 1] = b[i] - 2 * q[i] * b1[i] + b2[i];
           a2[i] = a1[i];
           a1[i] = a[i];
           b2[i] = b1[i];
           b1[i] = b[i];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (j=0; j&lt;LPC_FILTERORDER; j++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (j == 0) {
               a[0] = 0.25;
               b[0] = -0.25;
           } else {
               a[0] = b[0] = 0.0;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (i=0; i&lt;LPC_HALFORDER; i++) {
               a[i + 1] = a[i] - 2 * p[i] * a1[i] + a2[i];
               b[i + 1] = b[i] - 2 * q[i] * b1[i] + b2[i];
               a2[i] = a1[i];
               a1[i] = a[i];
               b2[i] = b1[i];
               b1[i] = b[i];
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           a_coef[j + 1] = 2 * (a[LPC_HALFORDER] + b[LPC_HALFORDER]);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 a_coef[0] = 1.0; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a_coef[0] = 1.0;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-41--packing-h">
A.41. packing.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.41. パッキング.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
packing.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
パッキング.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __PACKING_H #define __PACKING_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __PACKING_H #define __PACKING_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void packsplit(
       int *index,                 /* (i) the value to split */
       int *firstpart,             /* (o) the value specified by most
                                          significant bits */
       int *rest,                  /* (o) the value specified by least
                                          significant bits */
       int bitno_firstpart,    /* (i) number of bits in most
                                          significant part */
       int bitno_total             /* (i) number of bits in full range
                                          of value */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void packcombine(
       int *index,                 /* (i/o) the msb value in the
                                          combined value out */
       int rest,                   /* (i) the lsb value */
       int bitno_rest              /* (i) the number of bits in the
                                          lsb part */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void dopack(
       unsigned char **bitstream,  /* (i/o) on entrance pointer to
                                          place in bitstream to pack
                                          new data, on exit pointer
                                          to place in bitstream to
                                          pack future data */
       int index,                  /* (i) the value to pack */
       int bitno,                  /* (i) the number of bits that the
                                          value will fit within */
       int *pos                /* (i/o) write position in the
                                          current byte */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void unpack(
       unsigned char **bitstream,  /* (i/o) on entrance pointer to
                                          place in bitstream to
                                          unpack new data from, on
                                          exit pointer to place in
                                          bitstream to unpack future
                                          data from */
       int *index,                 /* (o) resulting value */
       int bitno,                  /* (i) number of bits used to
                                          represent the value */
       int *pos                /* (i/o) read position in the
                                          current byte */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-42--packing-c">
A.42. packing.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.42. 梱包.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
packing.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
梱包.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;math.h&gt;
   #include &lt;stdlib.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;constants.h&#34; #include &#34;helpfun.h&#34; #include &#34;string.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;constants.h&#34; #include &#34;helpfun.h&#34; #include &#34;string.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  splitting an integer into first most significant bits and
    *  remaining least significant bits
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void packsplit(
       int *index,                 /* (i) the value to split */
       int *firstpart,             /* (o) the value specified by most
                                          significant bits */
       int *rest,                  /* (o) the value specified by least
                                          significant bits */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int bitno_firstpart,    /* (i) number of bits in most
                                          significant part */
       int bitno_total             /* (i) number of bits in full range
                                          of value */
   ){
       int bitno_rest = bitno_total-bitno_firstpart;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       *firstpart = *index&gt;&gt;(bitno_rest);
       *rest = *index-(*firstpart&lt;&lt;(bitno_rest));
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  combining a value corresponding to msb&#39;s with a value
    *  corresponding to lsb&#39;s
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void packcombine(
       int *index,                 /* (i/o) the msb value in the
                                          combined value out */
       int rest,                   /* (i) the lsb value */
       int bitno_rest              /* (i) the number of bits in the
                                          lsb part */
   ){
       *index = *index&lt;&lt;bitno_rest;
       *index += rest;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  packing of bits into bitstream, i.e., vector of bytes
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void dopack(
       unsigned char **bitstream,  /* (i/o) on entrance pointer to
                                          place in bitstream to pack
                                          new data, on exit pointer
                                          to place in bitstream to
                                          pack future data */
       int index,                  /* (i) the value to pack */
       int bitno,                  /* (i) the number of bits that the
                                          value will fit within */
       int *pos                /* (i/o) write position in the
                                          current byte */
   ){
       int posLeft;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Clear the bits before starting in a new byte */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if ((*pos)==0) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           **bitstream=0;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
while (bitno&gt;0) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
while (ビット番号 &gt; 0) {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Jump to the next byte if end of this byte is reached*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (*pos==8) {
               *pos=0;
               (*bitstream)++;
               **bitstream=0;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           posLeft=8-(*pos);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Insert index into the bitstream */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (bitno &lt;= posLeft) {
               **bitstream |= (unsigned char)(index&lt;&lt;(posLeft-bitno));
               *pos+=bitno;
               bitno=0;
           } else {
               **bitstream |= (unsigned char)(index&gt;&gt;(bitno-posLeft));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               *pos=8;
               index-=((index&gt;&gt;(bitno-posLeft))&lt;&lt;(bitno-posLeft));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               bitno-=posLeft;
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  unpacking of bits from bitstream, i.e., vector of bytes
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void unpack(
       unsigned char **bitstream,  /* (i/o) on entrance pointer to
                                          place in bitstream to
                                          unpack new data from, on
                                          exit pointer to place in
                                          bitstream to unpack future
                                          data from */
       int *index,                 /* (o) resulting value */
       int bitno,                  /* (i) number of bits used to
                                          represent the value */
       int *pos                /* (i/o) read position in the
                                          current byte */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
){ int BitsLeft;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
){ int BitsLeft;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       *index=0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
while (bitno&gt;0) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
while (ビット番号 &gt; 0) {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* move forward in bitstream when the end of the
              byte is reached */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (*pos==8) {
               *pos=0;
               (*bitstream)++;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           BitsLeft=8-(*pos);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* Extract bits to index */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (BitsLeft&gt;=bitno) {
               *index+=((((**bitstream)&lt;&lt;(*pos)) &amp; 0xFF)&gt;&gt;(8-bitno));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               *pos+=bitno;
               bitno=0;
           } else {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if ((8-bitno)&gt;0) {
                   *index+=((((**bitstream)&lt;&lt;(*pos)) &amp; 0xFF)&gt;&gt;
                       (8-bitno));
                   *pos=8;
               } else {
                   *index+=(((int)(((**bitstream)&lt;&lt;(*pos)) &amp; 0xFF))&lt;&lt;
                       (bitno-8));
                   *pos=8;
               }
               bitno-=BitsLeft;
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-43--StateConstructW-h">
A.43. StateConstructW.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.43. StateConstructWh.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
StateConstructW.h Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
StateConstructW.h 著作権 (C) The Internet Society (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_STATECONSTRUCTW_H #define __iLBC_STATECONSTRUCTW_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_STATECONSTRUCTW_H #define __iLBC_STATECONSTRUCTW_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void StateConstructW(
       int idxForMax,      /* (i) 6-bit index for the quantization of
                                  max amplitude */
       int *idxVec,    /* (i) vector of quantization indexes */
       float *syntDenum,   /* (i) synthesis filter denumerator */
       float *out,         /* (o) the decoded state vector */
       int len             /* (i) length of a state vector */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-44--StateConstructW-c">
A.44. StateConstructW.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.44. StateConstructW.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
StateConstructW.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
StateConstructW.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;math.h&gt;
   #include &lt;string.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;constants.h&#34; #include &#34;filter.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;constants.h&#34; #include &#34;filter.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  decoding of the start state
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void StateConstructW(
       int idxForMax,      /* (i) 6-bit index for the quantization of
                                  max amplitude */
       int *idxVec,    /* (i) vector of quantization indexes */
       float *syntDenum,   /* (i) synthesis filter denumerator */
          float *out,         /* (o) the decoded state vector */
       int len             /* (i) length of a state vector */
   ){
       float maxVal, tmpbuf[LPC_FILTERORDER+2*STATE_LEN], *tmp,
           numerator[LPC_FILTERORDER+1];
       float foutbuf[LPC_FILTERORDER+2*STATE_LEN], *fout;
       int k,tmpi;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* decoding of the maximum value */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       maxVal = state_frgqTbl[idxForMax];
       maxVal = (float)pow(10,maxVal)/(float)4.5;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* initialization of buffers and coefficients */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memset(tmpbuf, 0, LPC_FILTERORDER*sizeof(float));
       memset(foutbuf, 0, LPC_FILTERORDER*sizeof(float));
       for (k=0; k&lt;LPC_FILTERORDER; k++) {
           numerator[k]=syntDenum[LPC_FILTERORDER-k];
       }
       numerator[LPC_FILTERORDER]=syntDenum[0];
       tmp = &amp;tmpbuf[LPC_FILTERORDER];
       fout = &amp;foutbuf[LPC_FILTERORDER];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* decoding of the sample values */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (k=0; k&lt;len; k++) {
           tmpi = len-1-k;
           /* maxVal = 1/scal */
           tmp[k] = maxVal*state_sq3Tbl[idxVec[tmpi]];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* circular convolution with all-pass filter */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memset(tmp+len, 0, len*sizeof(float));
       ZeroPoleFilter(tmp, numerator, syntDenum, 2*len,
           LPC_FILTERORDER, fout);
       for (k=0;k&lt;len;k++) {
           out[k] = fout[len-1-k]+fout[2*len-1-k];
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-45--StateSearchW-h">
A.45. StateSearchW.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.45. 州検索WH
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
StateSearchW.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
州検索WH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_STATESEARCHW_H #define __iLBC_STATESEARCHW_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_STATESEARCHW_H #define __iLBC_STATESEARCHW_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void AbsQuantW(
       iLBC_Enc_Inst_t *iLBCenc_inst,
                           /* (i) Encoder instance */
       float *in,          /* (i) vector to encode */
       float *syntDenum,   /* (i) denominator of synthesis filter */
       float *weightDenum, /* (i) denominator of weighting filter */
       int *out,           /* (o) vector of quantizer indexes */
       int len,        /* (i) length of vector to encode and
                                  vector of quantizer indexes */
       int state_first     /* (i) position of start state in the
                                  80 vec */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void StateSearchW(
       iLBC_Enc_Inst_t *iLBCenc_inst,
                           /* (i) Encoder instance */
       float *residual,/* (i) target residual vector */
       float *syntDenum,   /* (i) lpc synthesis filter */
       float *weightDenum, /* (i) weighting filter denuminator */
       int *idxForMax,     /* (o) quantizer index for maximum
                                  amplitude */
       int *idxVec,    /* (o) vector of quantization indexes */
       int len,        /* (i) length of all vectors */
       int state_first     /* (i) position of start state in the
                                  80 vec */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-46--StateSearchW-c">
A.46. StateSearchW.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.46. 州検索W.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
StateSearchW.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
州検索W.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #include &lt;math.h&gt;
   #include &lt;string.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;constants.h&#34; #include &#34;filter.h&#34; #include &#34;helpfun.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34; #include &#34;constants.h&#34; #include &#34;filter.h&#34; #include &#34;helpfun.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  predictive noise shaping encoding of scaled start state
    *  (subrutine for StateSearchW)
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void AbsQuantW(
       iLBC_Enc_Inst_t *iLBCenc_inst,
                           /* (i) Encoder instance */
       float *in,          /* (i) vector to encode */
       float *syntDenum,   /* (i) denominator of synthesis filter */
       float *weightDenum, /* (i) denominator of weighting filter */
       int *out,           /* (o) vector of quantizer indexes */
       int len,        /* (i) length of vector to encode and
                                  vector of quantizer indexes */
       int state_first     /* (i) position of start state in the
                                  80 vec */
   ){
       float *syntOut;
       float syntOutBuf[LPC_FILTERORDER+STATE_SHORT_LEN_30MS];
       float toQ, xq;
       int n;
       int index;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* initialization of buffer for filtering */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memset(syntOutBuf, 0, LPC_FILTERORDER*sizeof(float));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* initialization of pointer for filtering */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       syntOut = &amp;syntOutBuf[LPC_FILTERORDER];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* synthesis and weighting filters on input */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (state_first) {
           AllPoleFilter (in, weightDenum, SUBL, LPC_FILTERORDER);
       } else {
           AllPoleFilter (in, weightDenum,
               iLBCenc_inst-&gt;state_short_len-SUBL,
               LPC_FILTERORDER);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* encoding loop */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (n=0; n&lt;len; n++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* time update of filter coefficients */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if ((state_first)&amp;&amp;(n==SUBL)){
               syntDenum += (LPC_FILTERORDER+1);
               weightDenum += (LPC_FILTERORDER+1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* synthesis and weighting filters on input */
               AllPoleFilter (&amp;in[n], weightDenum, len-n,
                   LPC_FILTERORDER);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           } else if ((state_first==0)&amp;&amp;
               (n==(iLBCenc_inst-&gt;state_short_len-SUBL))) {
               syntDenum += (LPC_FILTERORDER+1);
               weightDenum += (LPC_FILTERORDER+1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* synthesis and weighting filters on input */
               AllPoleFilter (&amp;in[n], weightDenum, len-n,
                   LPC_FILTERORDER);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* prediction of synthesized and weighted input */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
syntOut[n] = 0.0; AllPoleFilter (&amp;syntOut[n], weightDenum, 1, LPC_FILTERORDER);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
syntOut[n] = 0.0;AllPoleFilter (&amp;syntOut[n]、weightDenum、1、LPC_FILTERORDER);
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* quantization */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
toQ = in[n]-syntOut[n];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
toQ = in[n]-syntOut[n];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           sort_sq(&amp;xq, &amp;index, toQ, state_sq3Tbl, 8);
           out[n]=index;
           syntOut[n] = state_sq3Tbl[out[n]];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* update of the prediction filter */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           AllPoleFilter(&amp;syntOut[n], weightDenum, 1,
               LPC_FILTERORDER);
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  encoding of start state
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void StateSearchW(
       iLBC_Enc_Inst_t *iLBCenc_inst,
                           /* (i) Encoder instance */
       float *residual,/* (i) target residual vector */
       float *syntDenum,   /* (i) lpc synthesis filter */
       float *weightDenum, /* (i) weighting filter denuminator */
       int *idxForMax,     /* (o) quantizer index for maximum
                                  amplitude */
       int *idxVec,    /* (o) vector of quantization indexes */
       int len,        /* (i) length of all vectors */
       int state_first     /* (i) position of start state in the
                                  80 vec */
   ){
       float dtmp, maxVal;
       float tmpbuf[LPC_FILTERORDER+2*STATE_SHORT_LEN_30MS];
       float *tmp, numerator[1+LPC_FILTERORDER];
       float foutbuf[LPC_FILTERORDER+2*STATE_SHORT_LEN_30MS], *fout;
       int k;
       float qmax, scal;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* initialization of buffers and filter coefficients */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memset(tmpbuf, 0, LPC_FILTERORDER*sizeof(float));
       memset(foutbuf, 0, LPC_FILTERORDER*sizeof(float));
       for (k=0; k&lt;LPC_FILTERORDER; k++) {
           numerator[k]=syntDenum[LPC_FILTERORDER-k];
       }
       numerator[LPC_FILTERORDER]=syntDenum[0];
       tmp = &amp;tmpbuf[LPC_FILTERORDER];
       fout = &amp;foutbuf[LPC_FILTERORDER];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* circular convolution with the all-pass filter */
              memcpy(tmp, residual, len*sizeof(float));
       memset(tmp+len, 0, len*sizeof(float));
       ZeroPoleFilter(tmp, numerator, syntDenum, 2*len,
           LPC_FILTERORDER, fout);
       for (k=0; k&lt;len; k++) {
           fout[k] += fout[k+len];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* identification of the maximum amplitude value */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       maxVal = fout[0];
       for (k=1; k&lt;len; k++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (fout[k]*fout[k] &gt; maxVal*maxVal){
               maxVal = fout[k];
           }
       }
       maxVal=(float)fabs(maxVal);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* encoding of the maximum amplitude value */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (maxVal &lt; 10.0) {
           maxVal = 10.0;
       }
       maxVal = (float)log10(maxVal);
       sort_sq(&amp;dtmp, idxForMax, maxVal, state_frgqTbl, 64);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* decoding of the maximum amplitude representation value,
          and corresponding scaling of start state */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       maxVal=state_frgqTbl[*idxForMax];
       qmax = (float)pow(10,maxVal);
       scal = (float)(4.5)/qmax;
       for (k=0; k&lt;len; k++){
           fout[k] *= scal;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* predictive noise shaping encoding of scaled start state */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 AbsQuantW(iLBCenc_inst, fout,syntDenum, weightDenum,idxVec, len, state_first); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AbsQuantW(iLBCenc_inst, fout,syntDenum,weightDenum,idxVec, len, state_first);}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-47--syntFilter-h">
A.47. syntFilter.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.47. syntFilter.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
syntFilter.h
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
syntFilter.h
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_SYNTFILTER_H #define __iLBC_SYNTFILTER_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef __iLBC_SYNTFILTER_H #define __iLBC_SYNTFILTER_H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void syntFilter(
       float *Out,     /* (i/o) Signal to be filtered */
       float *a,       /* (i) LP parameters */
       int len,    /* (i) Length of signal */
       float *mem      /* (i/o) Filter state */
   );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-48--syntFilter-c">
A.48. syntFilter.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.48. syntFilter.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /******************************************************************
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC Speech Coder ANSI-C Source Code
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
iLBC スピーチ コーダー ANSI-C ソース コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
syntFilter.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
syntFilter.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
著作権 (C) インターネット協会 (2004)。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ******************************************************************/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#include &#34;iLBC_define.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*----------------------------------------------------------------*
    *  LP synthesis filter.
    *---------------------------------------------------------------*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void syntFilter(
       float *Out,     /* (i/o) Signal to be filtered */
       float *a,       /* (i) LP parameters */
       int len,    /* (i) Length of signal */
          float *mem      /* (i/o) Filter state */
   ){
       int i, j;
       float *po, *pi, *pa, *pm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
po=Out;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
po=アウト;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Filter first part using memory from past */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i=0; i&lt;LPC_FILTERORDER; i++) {
           pi=&amp;Out[i-1];
           pa=&amp;a[1];
           pm=&amp;mem[LPC_FILTERORDER-1];
           for (j=1; j&lt;=i; j++) {
               *po-=(*pa++)*(*pi--);
           }
           for (j=i+1; j&lt;LPC_FILTERORDER+1; j++) {
               *po-=(*pa++)*(*pm--);
           }
           po++;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Filter last part where the state is entirely in
          the output vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       for (i=LPC_FILTERORDER; i&lt;len; i++) {
           pi=&amp;Out[i-1];
           pa=&amp;a[1];
           for (j=1; j&lt;LPC_FILTERORDER+1; j++) {
               *po-=(*pa++)*(*pi--);
           }
           po++;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Update state vector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       memcpy(mem, &amp;Out[len-LPC_FILTERORDER],
           LPC_FILTERORDER*sizeof(float));
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者の住所
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Soren Vang Andersen Department of Communication Technology Aalborg University Fredrik Bajers Vej 7A 9200 Aalborg Denmark
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Soren Vang Andersen コミュニケーション技術学部 オールボー大学 Fredrik Bajers Vej 7A 9200 オールボー デンマーク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone:  ++45 9 6358627
   EMail:  sva@kom.auc.dk
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alan Duric Telio AS Stoperigt. 2 Oslo, N-0250 Norway
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アラン・デュリック・テリオ AS ストペリグト。2 オスロ、N-0250 ノルウェー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone:  +47 21673555
   EMail:  alan.duric@telio.no
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Henrik Astrom Global IP Sound AB Olandsgatan 42 Stockholm, S-11663 Sweden
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Henrik Astrom Global IP Sound AB Olandsgatan 42 Stockholm, S-11663 スウェーデン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone:  +46 8 54553040
   EMail:  henrik.astrom@globalipsound.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Roar Hagen Global IP Sound AB Olandsgatan 42 Stockholm, S-11663 Sweden
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Roar Hagen Global IP Sound AB Olandsgatan 42 Stockholm, S-11663 スウェーデン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +46 8 54553040 EMail: roar.hagen@globalipsound.com W. Bastiaan Kleijn Global IP Sound AB Olandsgatan 42 Stockholm, S-11663 Sweden
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話: 46 8 54553040 電子メール: Roar.hagen@globalipsound.com W. Bastiaan Kleijn Global IP Sound AB Olandsgatan 42 Stockholm, S-11663 スウェーデン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone:  +46 8 54553040
   EMail:  bastiaan.kleijn@globalipsound.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jan Linden Global IP Sound Inc. 900 Kearny Street, suite 500 San Francisco, CA-94133 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jan Linden Global IP Sound Inc. 900 Kearny Street, suite 500 San Francisco, CA-94133 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 415 397 2555
   EMail: jan.linden@globalipsound.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完全な著作権に関する声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2004).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権 (C) インターネット協会 (2004)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78 に含まれる権利、ライセンス、および制限の対象となり、そこに規定されている場合を除き、著者はすべての権利を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書およびここに含まれる情報は「現状のまま」で提供され、寄稿者、寄稿者が代表または後援する組織（存在する場合）、インターネット協会およびインターネット エンジニアリング タスク フォースは、明示的または明示的または明示的に、すべての保証を否認します。ここに記載された情報の使用がいかなる権利も侵害しないことの黙示的な保証、または商品性や特定の目的への適合性の黙示的な保証を含みますが、これに限定されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知的財産
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the IETF&#39;s procedures with respect to rights in IETF Documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF は、本書に記載されているテクノロジの実装または使用に関連すると主張される知的財産権またはその他の権利の有効性や範囲、あるいはそのような権利に基づくライセンスが適用されるかどうかの範囲に関して、いかなる立場も負いません。利用可能であること。また、かかる権利を特定するために独自の努力を行ったことを示すものでもありません。IETF 文書の権利に関する IETF の手順に関する情報は、BCP 78 および BCP 79 に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF 事務局に提出された IPR 開示のコピー、および利用可能になるライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような所有権の使用に対する一般ライセンスまたは許可を取得しようとする試みの結果を入手できます。IETF オンライン IPR リポジトリ (http://www.ietf.org/ipr) から入手してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF は、利害関係者に対し、この規格の実装に必要とされる可能性のある技術をカバーする著作権、特許、特許出願、またはその他の所有権について注意を喚起するよう呼びかけています。情報は IETF (ietf-ipr@ietf.org) に送信してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC エディター機能の資金は現在、インターネット協会によって提供されています。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
