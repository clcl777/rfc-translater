<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 9113 - HTTP/2 (RFC 9113) 日本語訳</title>
  <meta name="description" content="RFC 9113は、HTTP/2プロトコルに関する文書で、HTTP/1.1の効率性とパフォーマンスを改善することを目的としています。このプロトコルは、ウェブページの読み込み速度を向上させるために、ヘッダー圧縮やサーバープッシュ機能、単一のTCP接続上での複数のリクエストとレスポンスの多重化を導入しています。主にウェブブラウザやサーバー間の通信に利用され、より効率的なデータ転送を実現します。関連するRFCには、HTTP/2を補完するHPACKヘッダー圧縮に関するRFC 7541や、後継プロトコルであるHTTP/3に関するRFC 9114などがあります。">
  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">9113</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://www.rfc-editor.org/rfc/rfc9113.html">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 9113 - HTTP/2 (RFC 9113) 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://www.rfc-editor.org/rfc/rfc9113.html">
            https://www.rfc-editor.org/rfc/rfc9113.html
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 9113 - HTTP/2（RFC 9113）</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] RFC 9113は、HTTP/2プロトコルに関する文書で、HTTP/1.1の効率性とパフォーマンスを改善することを目的としています。このプロトコルは、ウェブページの読み込み速度を向上させるために、ヘッダー圧縮やサーバープッシュ機能、単一のTCP接続上での複数のリクエストとレスポンスの多重化を導入しています。主にウェブブラウザやサーバー間の通信に利用され、より効率的なデータ転送を実現します。関連するRFCには、HTTP/2を補完するHPACKヘッダー圧縮に関するRFC 7541や、後継プロトコルであるHTTP/3に関するRFC 9114などがあります。</p>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                   M. Thomson, Ed.
Request for Comments: 9113                                       Mozilla
Obsoletes: 7540, 8740                                   C. Benfield, Ed.
Category: Standards Track                                     Apple Inc.
ISSN: 2070-1721                                                June 2022
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
HTTP/2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
HTTP/2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more efficient use of network resources and a reduced latency by introducing field compression and allowing multiple concurrent exchanges on the same connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、HTTPバージョン2（HTTP/2）と呼ばれるハイパーテキスト転送プロトコル（HTTP）のセマンティクスの最適化された式を説明しています。HTTP/2は、フィールド圧縮を導入し、同じ接続で複数の同時交換を許可することにより、ネットワークリソースのより効率的な使用とレイテンシの削減を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document obsoletes RFCs 7540 and 8740.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、RFCS 7540および8740を廃止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、インターネット標準トラックドキュメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9113.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9113で取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（c）2022 IETF Trustおよび文書著者として特定された人。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、修正されたBSDライセンスで説明されているように保証なしで提供される修正されたBSDライセンステキストを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction
   2.  HTTP/2 Protocol Overview
     2.1.  Document Organization
     2.2.  Conventions and Terminology
   3.  Starting HTTP/2
     3.1.  HTTP/2 Version Identification
     3.2.  Starting HTTP/2 for &#34;https&#34; URIs
     3.3.  Starting HTTP/2 with Prior Knowledge
     3.4.  HTTP/2 Connection Preface
   4.  HTTP Frames
     4.1.  Frame Format
     4.2.  Frame Size
     4.3.  Field Section Compression and Decompression
       4.3.1.  Compression State
   5.  Streams and Multiplexing
     5.1.  Stream States
       5.1.1.  Stream Identifiers
       5.1.2.  Stream Concurrency
     5.2.  Flow Control
       5.2.1.  Flow-Control Principles
       5.2.2.  Appropriate Use of Flow Control
       5.2.3.  Flow-Control Performance
     5.3.  Prioritization
       5.3.1.  Background on Priority in RFC 7540
       5.3.2.  Priority Signaling in This Document
     5.4.  Error Handling
       5.4.1.  Connection Error Handling
       5.4.2.  Stream Error Handling
       5.4.3.  Connection Termination
     5.5.  Extending HTTP/2
   6.  Frame Definitions
     6.1.  DATA
     6.2.  HEADERS
     6.3.  PRIORITY
     6.4.  RST_STREAM
     6.5.  SETTINGS
       6.5.1.  SETTINGS Format
       6.5.2.  Defined Settings
       6.5.3.  Settings Synchronization
     6.6.  PUSH_PROMISE
     6.7.  PING
     6.8.  GOAWAY
     6.9.  WINDOW_UPDATE
       6.9.1.  The Flow-Control Window
       6.9.2.  Initial Flow-Control Window Size
       6.9.3.  Reducing the Stream Window Size
     6.10. CONTINUATION
   7.  Error Codes
   8.  Expressing HTTP Semantics in HTTP/2
     8.1.  HTTP Message Framing
       8.1.1.  Malformed Messages
     8.2.  HTTP Fields
       8.2.1.  Field Validity
       8.2.2.  Connection-Specific Header Fields
       8.2.3.  Compressing the Cookie Header Field
     8.3.  HTTP Control Data
       8.3.1.  Request Pseudo-Header Fields
       8.3.2.  Response Pseudo-Header Fields
     8.4.  Server Push
       8.4.1.  Push Requests
       8.4.2.  Push Responses
     8.5.  The CONNECT Method
     8.6.  The Upgrade Header Field
     8.7.  Request Reliability
     8.8.  Examples
       8.8.1.  Simple Request
       8.8.2.  Simple Response
       8.8.3.  Complex Request
       8.8.4.  Response with Body
       8.8.5.  Informational Responses
   9.  HTTP/2 Connections
     9.1.  Connection Management
       9.1.1.  Connection Reuse
     9.2.  Use of TLS Features
       9.2.1.  TLS 1.2 Features
       9.2.2.  TLS 1.2 Cipher Suites
       9.2.3.  TLS 1.3 Features
   10. Security Considerations
     10.1.  Server Authority
     10.2.  Cross-Protocol Attacks
     10.3.  Intermediary Encapsulation Attacks
     10.4.  Cacheability of Pushed Responses
     10.5.  Denial-of-Service Considerations
       10.5.1.  Limits on Field Block Size
       10.5.2.  CONNECT Issues
     10.6.  Use of Compression
     10.7.  Use of Padding
     10.8.  Privacy Considerations
     10.9.  Remote Timing Attacks
   11. IANA Considerations
     11.1.  HTTP2-Settings Header Field Registration
     11.2.  The h2c Upgrade Token
   12. References
     12.1.  Normative References
     12.2.  Informative References
   Appendix A.  Prohibited TLS 1.2 Cipher Suites
   Appendix B.  Changes from RFC 7540
   Acknowledgments
   Contributors
   Authors&#39; Addresses
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The performance of applications using the Hypertext Transfer Protocol (HTTP, [HTTP]) is linked to how each version of HTTP uses the underlying transport, and the conditions under which the transport operates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HyperText Transfer Protocol（HTTP、[HTTP]）を使用したアプリケーションのパフォーマンスは、HTTPの各バージョンが基礎となる輸送を使用する方法と、輸送が動作する条件にリンクされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Making multiple concurrent requests can reduce latency and improve application performance. HTTP/1.0 allowed only one request to be outstanding at a time on a given TCP [TCP] connection. HTTP/1.1 [HTTP/1.1] added request pipelining, but this only partially addressed request concurrency and still suffers from application-layer head-of-line blocking. Therefore, HTTP/1.0 and HTTP/1.1 clients use multiple connections to a server to make concurrent requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数の同時リクエストを行うと、遅延を軽減し、アプリケーションのパフォーマンスを向上させることができます。HTTP/1.0では、特定のTCP [TCP]接続で一度に1つのリクエストのみが未払いであることを許可しました。http/1.1 [http/1.1]リクエストパイプラインが追加されましたが、これは部分的にのみ対処されたリクエストの並行性のみであり、アプリケーション層のヘッドオブラインブロッキングに苦しんでいます。したがって、HTTP/1.0およびHTTP/1.1クライアントは、サーバーへの複数の接続を使用して、同時リクエストを行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, HTTP fields are often repetitive and verbose, causing unnecessary network traffic as well as causing the initial TCP congestion window to quickly fill. This can result in excessive latency when multiple requests are made on a new TCP connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、HTTPフィールドはしばしば反復的かつ冗長であり、不必要なネットワークトラフィックを引き起こし、最初のTCP輻輳ウィンドウをすばやく埋めます。これにより、新しいTCP接続で複数のリクエストが行われると、過度の遅延が発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 addresses these issues by defining an optimized mapping of HTTP&#39;s semantics to an underlying connection. Specifically, it allows interleaving of messages on the same connection and uses an efficient coding for HTTP fields. It also allows prioritization of requests, letting more important requests complete more quickly, further improving performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2は、HTTPのセマンティクスの最適化されたマッピングを基礎となる接続に定義することにより、これらの問題に対処します。具体的には、同じ接続上のメッセージのインターリーブを可能にし、HTTPフィールドの効率的なコーディングを使用します。また、リクエストの優先順位付けも可能になり、より重要なリクエストをより迅速に完了させ、パフォーマンスをさらに向上させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resulting protocol is more friendly to the network because fewer TCP connections can be used in comparison to HTTP/1.x. This means less competition with other flows and longer-lived connections, which in turn lead to better utilization of available network capacity. Note, however, that TCP head-of-line blocking is not addressed by this protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果として得られるプロトコルは、HTTP/1.xと比較して使用できるTCP接続が少ないため、ネットワークにより親しみやすいです。これは、他のフローと長寿命の接続との競争が少なくなり、利用可能なネットワーク容量の利用が向上することを意味します。ただし、TCPヘッドオブラインブロッキングはこのプロトコルでは対処されていないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, HTTP/2 also enables more efficient processing of messages through use of binary message framing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、HTTP/2は、バイナリメッセージフレーミングを使用して、メッセージのより効率的な処理も可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document obsoletes RFCs 7540 and 8740. Appendix B lists notable changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、RFCS 7540および8740を廃止します。付録Bには顕著な変更が記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--HTTP2-Protocol-Overview">
2. HTTP/2 Protocol Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. HTTP/2プロトコルの概要
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 provides an optimized transport for HTTP semantics. HTTP/2 supports all of the core features of HTTP but aims to be more efficient than HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2は、HTTPセマンティクスの最適化された輸送を提供します。HTTP/2は、HTTPのすべてのコア機能をサポートしていますが、HTTP/1.1よりも効率的であることを目指しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 is a connection-oriented application-layer protocol that runs over a TCP connection ([TCP]). The client is the TCP connection initiator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2は、TCP接続（[TCP]）を介して実行される接続指向のアプリケーション層プロトコルです。クライアントはTCP接続イニシエーターです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic protocol unit in HTTP/2 is a frame (Section 4.1). Each frame type serves a different purpose. For example, HEADERS and DATA frames form the basis of HTTP requests and responses (Section 8.1); other frame types like SETTINGS, WINDOW_UPDATE, and PUSH_PROMISE are used in support of other HTTP/2 features.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2の基本プロトコルユニットはフレームです（セクション4.1）。各フレームタイプは異なる目的を果たします。たとえば、ヘッダーとデータフレームは、HTTP要求と応答の基礎を形成します（セクション8.1）。設定、window_update、push_promiseなどの他のフレームタイプは、他のHTTP/2機能をサポートするために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiplexing of requests is achieved by having each HTTP request/ response exchange associated with its own stream (Section 5). Streams are largely independent of each other, so a blocked or stalled request or response does not prevent progress on other streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストの多重化は、各HTTPリクエスト/応答交換を独自のストリームに関連付けていることによって達成されます（セクション5）。ストリームは大部分が互いに独立しているため、ブロックされた要求または失速したリクエストまたは応答は、他のストリームの進捗を防ぎません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Effective use of multiplexing depends on flow control and prioritization. Flow control (Section 5.2) ensures that it is possible to efficiently use multiplexed streams by restricting data that is transmitted to what the receiver is able to handle. Prioritization (Section 5.3) ensures that limited resources are used most effectively. This revision of HTTP/2 deprecates the priority signaling scheme from [RFC7540].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多重化の効果的な使用は、フロー制御と優先順位付けに依存します。フロー制御（セクション5.2）は、受信機が処理できるものに送信されるデータを制限することにより、多重化されたストリームを効率的に使用できるようにすることができます。優先順位付け（セクション5.3）は、限られたリソースが最も効果的に使用されることを保証します。HTTP/2のこの改訂は、[RFC7540]から優先シグナル伝達スキームを非難します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because HTTP fields used in a connection can contain large amounts of redundant data, frames that contain them are compressed (Section 4.3). This has especially advantageous impact upon request sizes in the common case, allowing many requests to be compressed into one packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続で使用されるHTTPフィールドには大量の冗長データが含まれる可能性があるため、それらを含むフレームが圧縮されます（セクション4.3）。これは、一般的なケースのリクエストサイズに応じて特に有利な影響を及ぼし、多くのリクエストを1つのパケットに圧縮できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, HTTP/2 adds a new, optional interaction mode whereby a server can push responses to a client (Section 8.4). This is intended to allow a server to speculatively send data to a client that the server anticipates the client will need, trading off some network usage against a potential latency gain. The server does this by synthesizing a request, which it sends as a PUSH_PROMISE frame. The server is then able to send a response to the synthetic request on a separate stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、HTTP/2は、サーバーがクライアントに応答をプッシュできる新しいオプションのインタラクションモードを追加します（セクション8.4）。これは、サーバーがクライアントがクライアントに必要とすると予想するクライアントに投機的に送信できるようにすることを目的としており、潜在的な遅延ゲインに対してネットワークの使用を取引します。サーバーは、Push_Promiseフレームとして送信するリクエストを合成することによりこれを行います。サーバーは、別のストリーム上の合成要求への応答を送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1--Document-Organization">
2.1. Document Organization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. ドキュメント組織
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HTTP/2 specification is split into four parts:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2仕様は4つの部分に分割されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Starting HTTP/2 (Section 3) covers how an HTTP/2 connection is initiated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* HTTP/2の開始（セクション3）は、HTTP/2接続の開始方法をカバーしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The frame (Section 4) and stream (Section 5) layers describe the way HTTP/2 frames are structured and formed into multiplexed streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* フレーム（セクション4）およびストリーム（セクション5）レイヤーは、HTTP/2フレームが構造化され、多重化されたストリームに形成される方法を説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Frame (Section 6) and error (Section 7) definitions include details of the frame and error types used in HTTP/2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* フレーム（セクション6）とエラー（セクション7）の定義には、HTTP/2で使用されるフレームとエラータイプの詳細が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* HTTP mappings (Section 8) and additional requirements (Section 9) describe how HTTP semantics are expressed using frames and streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* HTTPマッピング（セクション8）および追加要件（セクション9）は、HTTPセマンティクスがフレームとストリームを使用してどのように表現されるかについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While some of the frame- and stream-layer concepts are isolated from HTTP, this specification does not define a completely generic frame layer. The frame and stream layers are tailored to the needs of HTTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレームレイヤーと河川層の概念の一部はHTTPから分離されていますが、この仕様は完全に一般的なフレームレイヤーを定義しません。フレームレイヤーとストリームレイヤーは、HTTPのニーズに合わせて調整されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2--Conventions-and-Terminology">
2.2. Conventions and Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. 慣習と用語
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, および &#34;OPTIONAL&#34; はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All numeric values are in network byte order. Values are unsigned unless otherwise indicated. Literal values are provided in decimal or hexadecimal as appropriate. Hexadecimal literals are prefixed with &#34;0x&#34; to distinguish them from decimal literals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての数値はネットワークバイトの順序です。特に示されない限り、値は署名されていません。リテラル値は、必要に応じて10進数または16進数で提供されます。16進数リテラルには、小数リテラルと区別するために「0x」が付いています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification describes binary formats using the conventions described in Section 1.3 of RFC 9000 [QUIC]. Note that this format uses network byte order and that high-valued bits are listed before low-valued bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様では、RFC 9000 [QUIC]のセクション1.3で説明されている規則を使用して、バイナリ形式について説明します。この形式では、ネットワークバイトの順序を使用し、高価値ビットが低価値ビットの前にリストされていることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following terms are used:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の用語が使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client: The endpoint that initiates an HTTP/2 connection. Clients send HTTP requests and receive HTTP responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント：HTTP/2接続を開始するエンドポイント。クライアントはHTTPリクエストを送信し、HTTP応答を受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
connection: A transport-layer connection between two endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続：2つのエンドポイント間の輸送層接続。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
connection error: An error that affects the entire HTTP/2 connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続エラー：HTTP/2接続全体に影響するエラー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
endpoint: Either the client or server of the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイント：接続のクライアントまたはサーバーのいずれか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
frame: The smallest unit of communication within an HTTP/2 connection, consisting of a header and a variable-length sequence of octets structured according to the frame type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレーム：HTTP/2接続内の通信の最小単位。ヘッダーと、フレームタイプに従って構成されたオクテットの可変長さのシーケンスで構成される。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
peer: An endpoint. When discussing a particular endpoint, &#34;peer&#34; refers to the endpoint that is remote to the primary subject of discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピア：エンドポイント。特定のエンドポイントについて議論するとき、「ピア」とは、議論の主要な主題にremote延するエンドポイントを指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
receiver: An endpoint that is receiving frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信機：フレームを受信しているエンドポイント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sender: An endpoint that is transmitting frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者：フレームを送信しているエンドポイント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server: The endpoint that accepts an HTTP/2 connection. Servers receive HTTP requests and send HTTP responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー：HTTP/2接続を受け入れるエンドポイント。サーバーはHTTPリクエストを受信し、HTTP応答を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stream: A bidirectional flow of frames within the HTTP/2 connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリーム：HTTP/2接続内のフレームの双方向の流れ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stream error: An error on the individual HTTP/2 stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリームエラー：個々のHTTP/2ストリームのエラー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, the terms &#34;gateway&#34;, &#34;intermediary&#34;, &#34;proxy&#34;, and &#34;tunnel&#34; are defined in Section 3.7 of [HTTP]. Intermediaries act as both client and server at different times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、「ゲートウェイ」、「仲介者」、「プロキシ」、および「トンネル」という用語は、[HTTP]のセクション3.7で定義されています。仲介者は、異なる時間にクライアントとサーバーの両方として機能します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The term &#34;content&#34; as it applies to message bodies is defined in Section 6.4 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージ本文に適用される「コンテンツ」という用語は、[HTTP]のセクション6.4で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Starting-HTTP2">
3. Starting HTTP/2
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. HTTP/2の開始
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations that generate HTTP requests need to discover whether a server supports HTTP/2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPリクエストを生成する実装は、サーバーがHTTP/2をサポートするかどうかを発見する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 uses the &#34;http&#34; and &#34;https&#34; URI schemes defined in Section 4.2 of [HTTP], with the same default port numbers as HTTP/1.1 [HTTP/1.1]. These URIs do not include any indication about what HTTP versions an upstream server (the immediate peer to which the client wishes to establish a connection) supports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2は、[HTTP]のセクション4.2で定義されている「HTTP」および「HTTPS」URIスキームを使用し、HTTP/1.1 [HTTP/1.1]と同じデフォルトポート番号を使用します。これらのURIには、上流サーバー（クライアントが接続の確立を希望する即時のピア）がサポートするHTTPバージョンについての兆候は含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The means by which support for HTTP/2 is determined is different for &#34;http&#34; and &#34;https&#34; URIs. Discovery for &#34;https&#34; URIs is described in Section 3.2. HTTP/2 support for &#34;http&#34; URIs can only be discovered by out-of-band means and requires prior knowledge of the support as described in Section 3.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2のサポートが決定される手段は、「HTTP」と「HTTPS」URIで異なります。「HTTPS」URIの発見については、セクション3.2で説明しています。「HTTP」のHTTP/2サポートは、帯域外の手段によってのみ発見でき、セクション3.3で説明されているようにサポートの事前知識を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--HTTP2-Version-Identification">
3.1. HTTP/2 Version Identification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. HTTP/2バージョン識別
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol defined in this document has two identifiers. Creating a connection based on either implies the use of the transport, framing, and message semantics described in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで定義されているプロトコルには、2つの識別子があります。いずれかに基づいて接続を作成すると、このドキュメントで説明されている輸送、フレーミング、およびメッセージセマンティクスの使用が意味されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The string &#34;h2&#34; identifies the protocol where HTTP/2 uses Transport Layer Security (TLS); see Section 9.2. This identifier is used in the TLS Application-Layer Protocol Negotiation (ALPN) extension [TLS-ALPN] field and in any place where HTTP/2 over TLS is identified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 文字列「H2」は、HTTP/2がトランスポートレイヤーセキュリティ（TLS）を使用するプロトコルを識別します。セクション9.2を参照してください。この識別子は、TLSアプリケーション層プロトコルネゴシエーション（ALPN）拡張[TLS-ALPN]フィールドおよびTLS上のHTTP/2が識別される任意の場所で使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The &#34;h2&#34; string is serialized into an ALPN protocol identifier as the two-octet sequence: 0x68, 0x32.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
「H2」文字列は、2オクテットのシーケンスとしてALPNプロトコル識別子にシリアル化されています：0x68、0x32。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The &#34;h2c&#34; string was previously used as a token for use in the HTTP Upgrade mechanism&#39;s Upgrade header field (Section 7.8 of [HTTP]). This usage was never widely deployed and is deprecated by this document. The same applies to the HTTP2-Settings header field, which was used with the upgrade to &#34;h2c&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 「H2C」文字列は、以前はHTTPアップグレードメカニズムのアップグレードヘッダーフィールド（[HTTP]のセクション7.8）で使用するためのトークンとして使用されていました。この使用は決して広く展開されず、この文書によって非推奨されます。同じことが、「H2C」へのアップグレードとともに使用されたHTTP2-Settingsヘッダーフィールドにも当てはまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--Starting-HTTP2-for-https-URIs">
3.2. Starting HTTP/2 for &#34;https&#34; URIs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 「https」urisのHTTP/2を開始します
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client that makes a request to an &#34;https&#34; URI uses TLS [TLS13] with the ALPN extension [TLS-ALPN].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「HTTPS」URIにリクエストを行うクライアントは、ALPN拡張[TLS-ALPN]を使用してTLS [TLS13]を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 over TLS uses the &#34;h2&#34; protocol identifier. The &#34;h2c&#34; protocol identifier MUST NOT be sent by a client or selected by a server; the &#34;h2c&#34; protocol identifier describes a protocol that does not use TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 Over TLSは、「H2」プロトコル識別子を使用します。「H2C」プロトコル識別子は、クライアントによって送信されたり、サーバーによって選択されたりしないでください。「H2C」プロトコル識別子は、TLSを使用しないプロトコルを記述します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once TLS negotiation is complete, both the client and the server MUST send a connection preface (Section 3.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS交渉が完了すると、クライアントとサーバーの両方が接続序文を送信する必要があります（セクション3.4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--Starting-HTTP2-with-Prior-Knowledge">
3.3. Starting HTTP/2 with Prior Knowledge
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 事前知識でHTTP/2を開始します
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client can learn that a particular server supports HTTP/2 by other means. For example, a client could be configured with knowledge that a server supports HTTP/2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、特定のサーバーが他の手段でHTTP/2をサポートしていることを知ることができます。たとえば、クライアントは、サーバーがHTTP/2をサポートするという知識を持って構成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client that knows that a server supports HTTP/2 can establish a TCP connection and send the connection preface (Section 3.4) followed by HTTP/2 frames. Servers can identify these connections by the presence of the connection preface. This only affects the establishment of HTTP/2 connections over cleartext TCP; HTTP/2 connections over TLS MUST use protocol negotiation in TLS [TLS-ALPN].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがHTTP/2をサポートしていることを知っているクライアントは、TCP接続を確立し、接続序文（セクション3.4）を送信し、その後HTTP/2フレームを送信できます。サーバーは、接続序文の存在によりこれらの接続を識別できます。これは、クリアテキストTCPを介したHTTP/2接続の確立にのみ影響します。TLSを介したHTTP/2接続は、TLS [TLS-ALPN]でプロトコルネゴシエーションを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Likewise, the server MUST send a connection preface (Section 3.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、サーバーは接続序文を送信する必要があります（セクション3.4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Without additional information, prior support for HTTP/2 is not a strong signal that a given server will support HTTP/2 for future connections. For example, it is possible for server configurations to change, for configurations to differ between instances in clustered servers, or for network conditions to change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加情報がなければ、HTTP/2の事前サポートは、特定のサーバーが将来の接続に対してHTTP/2をサポートするという強力な信号ではありません。たとえば、サーバー構成が変更されたり、クラスター化されたサーバーのインスタンス間で構成が異なる場合、またはネットワーク条件が変更される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-4--HTTP2-Connection-Preface">
3.4. HTTP/2 Connection Preface
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. HTTP/2接続序文
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In HTTP/2, each endpoint is required to send a connection preface as a final confirmation of the protocol in use and to establish the initial settings for the HTTP/2 connection. The client and server each send a different connection preface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2では、使用中のプロトコルの最終確認として接続序文を送信し、HTTP/2接続の初期設定を確立するために、各エンドポイントが必要です。クライアントとサーバーはそれぞれ、異なる接続序文を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client connection preface starts with a sequence of 24 octets, which in hex notation is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント接続の序文は、24オクテットのシーケンスで始まります。これは、16進表記で次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
That is, the connection preface starts with the string &#34;PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n&#34;. This sequence MUST be followed by a SETTINGS frame (Section 6.5), which MAY be empty. The client sends the client connection preface as the first application data octets of a connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
つまり、接続序文は文字列「pri * http/2.0 \ r \ n \ r \ nsm \ r \ n \ r \ n &#34;から始まります。このシーケンスの後に、空の設定フレーム（セクション6.5）が続く必要があります。クライアントは、接続の最初のアプリケーションデータオクテットとしてクライアント接続序文を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
 Note: The client connection preface is selected so that a large proportion of HTTP/1.1 or HTTP/1.0 servers and intermediaries do not attempt to process further frames. Note that this does not address the concerns raised in [TALKING].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
注：クライアント接続序文が選択されているため、HTTP/1.1またはHTTP/1.0サーバーと仲介者の大部分がさらにフレームを処理しようとしないようにします。これは、[話す]で提起された懸念に対処していないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server connection preface consists of a potentially empty SETTINGS frame (Section 6.5) that MUST be the first frame the server sends in the HTTP/2 connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー接続序文は、サーバーがHTTP/2接続で送信する最初のフレームでなければならない潜在的に空の設定フレーム（セクション6.5）で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SETTINGS frames received from a peer as part of the connection preface MUST be acknowledged (see Section 6.5.3) after sending the connection preface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続序文の一部としてピアから受信した設定フレームは、接続序文を送信した後に確認する必要があります（セクション6.5.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid unnecessary latency, clients are permitted to send additional frames to the server immediately after sending the client connection preface, without waiting to receive the server connection preface. It is important to note, however, that the server connection preface SETTINGS frame might include settings that necessarily alter how a client is expected to communicate with the server. Upon receiving the SETTINGS frame, the client is expected to honor any settings established. In some configurations, it is possible for the server to transmit SETTINGS before the client sends additional frames, providing an opportunity to avoid this issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不必要な遅延を回避するために、クライアントは、サーバー接続の序文を受信するのを待つことなく、クライアント接続序文を送信した直後に追加のフレームをサーバーに送信することができます。ただし、サーバー接続序文設定フレームには、クライアントがサーバーと通信することが予想される方法を必ず変更する設定が含まれる場合があることに注意することが重要です。設定フレームを受信すると、クライアントは確立された設定を尊重することが期待されます。一部の構成では、クライアントが追加のフレームを送信する前にサーバーが設定を送信することができ、この問題を回避する機会を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients and servers MUST treat an invalid connection preface as a connection error (Section 5.4.1) of type PROTOCOL_ERROR. A GOAWAY frame (Section 6.8) MAY be omitted in this case, since an invalid preface indicates that the peer is not using HTTP/2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーは、タイプprotocol_errorの接続エラー（セクション5.4.1）として無効な接続序文を扱う必要があります。この場合は、この場合は、ピアがHTTP/2を使用していないことを示しているため、この場合は省略フレーム（セクション6.8）を省略できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--HTTP-Frames">
4. HTTP Frames
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. HTTPフレーム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the HTTP/2 connection is established, endpoints can begin exchanging frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2接続が確立されると、エンドポイントはフレームの交換を開始できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Frame-Format">
4.1. Frame Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. フレーム形式
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All frames begin with a fixed 9-octet header followed by a variable-length frame payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのフレームは、固定された9オクテットヘッダーと、可変長フレームペイロードを使用して始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP Frame { Length (24), Type (8),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
httpフレーム{長さ（24）、タイプ（8）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Flags (8),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
フラグ（8）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Reserved (1), Stream Identifier (31),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
予約済み（1）、ストリーム識別子（31）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Frame Payload (..), }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレームペイロード（..）、}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
Figure 1: Frame Layout
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
図1：フレームレイアウト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fields of the frame header are defined as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレームヘッダーのフィールドは、次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Length: The length of the frame payload expressed as an unsigned 24-bit integer in units of octets. Values greater than 2^14 (16,384) MUST NOT be sent unless the receiver has set a larger value for SETTINGS_MAX_FRAME_SIZE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ：オクテットの単位で署名されていない24ビット整数として表されるフレームペイロードの長さ。2^14（16,384）を超える値は、受信者がsettings_max_frame_sizeに対してより大きな値を設定していない限り、送信しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The 9 octets of the frame header are not included in this value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
フレームヘッダーの9オクテットは、この値に含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type: The 8-bit type of the frame. The frame type determines the format and semantics of the frame. Frames defined in this document are listed in Section 6. Implementations MUST ignore and discard frames of unknown types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプ：フレームの8ビットタイプ。フレームタイプは、フレームの形式とセマンティクスを決定します。このドキュメントで定義されているフレームは、セクション6にリストされています。実装は、未知のタイプのフレームを無視して破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flags: An 8-bit field reserved for boolean flags specific to the frame type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグ：フレームタイプに固有のブールフラグ専用の8ビットフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Flags are assigned semantics specific to the indicated frame type. Unused flags are those that have no defined semantics for a particular frame type. Unused flags MUST be ignored on receipt and MUST be left unset (0x00) when sending.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
フラグには、示されたフレームタイプに固有のセマンティクスが割り当てられます。未使用のフラグは、特定のフレームタイプの定義されたセマンティクスを持たないフラグです。未使用のフラグは、受領時に無視する必要があり、送信中は解除（0x00）のままにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reserved: A reserved 1-bit field. The semantics of this bit are undefined, and the bit MUST remain unset (0x00) when sending and MUST be ignored when receiving.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予約済み：予約された1ビットフィールド。このビットのセマンティクスは未定義であり、送信中はビットが解除されたままである必要があり、受け取るときは無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stream Identifier: A stream identifier (see Section 5.1.1) expressed as an unsigned 31-bit integer. The value 0x00 is reserved for frames that are associated with the connection as a whole as opposed to an individual stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリーム識別子：署名されていない31ビット整数として表されたストリーム識別子（セクション5.1.1を参照）。値0x00は、個々のストリームとは対照的に、接続全体に関連付けられているフレーム用に予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The structure and content of the frame payload are dependent entirely on the frame type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレームペイロードの構造と内容は、フレームタイプに完全に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Frame-Size">
4.2. Frame Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. フレームサイズ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The size of a frame payload is limited by the maximum size that a receiver advertises in the SETTINGS_MAX_FRAME_SIZE setting. This setting can have any value between 2^14 (16,384) and 2^24-1 (16,777,215) octets, inclusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレームペイロードのサイズは、settings_max_frame_size設定で受信者が宣伝する最大サイズによって制限されます。この設定は、2^14（16,384）から2^24-1（16,777,215）のオクテットの間の任意の値を持つことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All implementations MUST be capable of receiving and minimally processing frames up to 2^14 octets in length, plus the 9-octet frame header (Section 4.1). The size of the frame header is not included when describing frame sizes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての実装は、長さが最大2^14オクテットのフレームを受信し、最小限の処理フレームに加えて、9-OCTETフレームヘッダー（セクション4.1）を最小限に抑えることができなければなりません。フレームヘッダーのサイズは、フレームサイズを記述するときは含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
 Note: Certain frame types, such as PING (Section 6.7), impose additional limits on the amount of frame payload data allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
注：Ping（セクション6.7）などの特定のフレームタイプは、許可されているフレームペイロードデータの量に追加の制限を課します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint MUST send an error code of FRAME_SIZE_ERROR if a frame exceeds the size defined in SETTINGS_MAX_FRAME_SIZE, exceeds any limit defined for the frame type, or is too small to contain mandatory frame data. A frame size error in a frame that could alter the state of the entire connection MUST be treated as a connection error (Section 5.4.1); this includes any frame carrying a field block (Section 4.3) (that is, HEADERS, PUSH_PROMISE, and CONTINUATION), a SETTINGS frame, and any frame with a stream identifier of 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、フレームがsettings_max_frame_sizeで定義されているサイズを超える場合、フレームタイプの定義された制限を超える、または必須のフレームデータを含めるには小さすぎる場合、frame_size_errorのエラーコードを送信する必要があります。接続全体の状態を変更できるフレームのフレームサイズエラーは、接続エラーとして扱う必要があります（セクション5.4.1）。これには、フィールドブロック（セクション4.3）（つまり、ヘッダー、push_promise、および継続）を運ぶフレーム、設定フレーム、および0のストリーム識別子を持つフレームが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints are not obligated to use all available space in a frame. Responsiveness can be improved by using frames that are smaller than the permitted maximum size. Sending large frames can result in delays in sending time-sensitive frames (such as RST_STREAM, WINDOW_UPDATE, or PRIORITY), which, if blocked by the transmission of a large frame, could affect performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、フレーム内のすべての使用可能なスペースを使用する義務はありません。応答性は、許可された最大サイズよりも小さいフレームを使用することで改善できます。大きなフレームを送信すると、時間に敏感なフレーム（RST_STREAM、WINDOW_UPDATE、PRIORITYなど）の送信が遅れ、大きなフレームの送信によってブロックされた場合、パフォーマンスに影響を与える可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--Field-Section-Compression-and-Decompression">
4.3. Field Section Compression and Decompression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. フィールドセクションの圧縮と減圧
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Field section compression is the process of compressing a set of field lines (Section 5.2 of [HTTP]) to form a field block. Field section decompression is the process of decoding a field block into a set of field lines. Details of HTTP/2 field section compression and decompression are defined in [COMPRESSION], which, for historical reasons, refers to these processes as header compression and decompression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドセクション圧縮は、フィールドラインのセット（[HTTP]のセクション5.2）を圧縮してフィールドブロックを形成するプロセスです。フィールドセクション減圧は、フィールドブロックを一連のフィールドラインにデコードするプロセスです。HTTP/2フィールドセクションの圧縮と減圧の詳細は、[圧縮]で定義されています。これは、歴史的な理由で、これらのプロセスをヘッダー圧縮と減圧と呼びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each field block carries all of the compressed field lines of a single field section. Header sections also include control data associated with the message in the form of pseudo-header fields (Section 8.3) that use the same format as a field line.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各フィールドブロックには、単一のフィールドセクションのすべての圧縮フィールドラインが含まれています。ヘッダーセクションには、フィールドラインと同じ形式を使用する擬似ヘッダーフィールド（セクション8.3）の形式のメッセージに関連付けられたコントロールデータも含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
 Note: RFC 7540 [RFC7540] used the term &#34;header block&#34; in place of the more generic &#34;field block&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
注：RFC 7540 [RFC7540]は、より一般的な「フィールドブロック」の代わりに「ヘッダーブロック」という用語を使用しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Field blocks carry control data and header sections for requests, responses, promised requests, and pushed responses (see Section 8.4). All these messages, except for interim responses and requests contained in PUSH_PROMISE (Section 6.6) frames, can optionally include a field block that carries a trailer section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドブロックには、リクエスト、応答、約束されたリクエスト、およびプッシュされた応答のために、制御データとヘッダーセクションがあります（セクション8.4を参照）。Push_promise（セクション6.6）フレームに含まれる暫定的な応答とリクエストを除くこれらのすべてのメッセージには、トレーラーセクションを運ぶフィールドブロックをオプションで含めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A field section is a collection of field lines. Each of the field lines in a field block carries a single value. The serialized field block is then divided into one or more octet sequences, called field block fragments. The first field block fragment is transmitted within the frame payload of HEADERS (Section 6.2) or PUSH_PROMISE (Section 6.6), each of which could be followed by CONTINUATION (Section 6.10) frames to carry subsequent field block fragments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドセクションは、フィールドラインのコレクションです。フィールドブロック内の各フィールドラインには、単一の値があります。シリアル化されたフィールドブロックは、フィールドブロックフラグメントと呼ばれる1つ以上のOctetシーケンスに分割されます。最初のフィールドブロックフラグメントは、ヘッダーのフレームペイロード（セクション6.2）またはPUSH_PROMISE（セクション6.6）内に送信され、それぞれに続いて続くフィールドブロックフラグメントを運ぶために継続（セクション6.10）フレームが続く可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Cookie header field [COOKIE] is treated specially by the HTTP mapping (see Section 8.2.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cookieヘッダーフィールド[Cookie]は、HTTPマッピングによって特別に処理されます（セクション8.2.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiving endpoint reassembles the field block by concatenating its fragments and then decompresses the block to reconstruct the field section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信エンドポイントは、そのフラグメントを連結してフィールドブロックを再構築し、ブロックを減圧してフィールドセクションを再構築します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A complete field section consists of either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完全なフィールドセクションは、次のいずれかで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* a single HEADERS or PUSH_PROMISE frame, with the END_HEADERS flag set, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* end_headersフラグが設定された単一のヘッダーまたはpush_promiseフレーム、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* a HEADERS or PUSH_PROMISE frame with the END_HEADERS flag unset and one or more CONTINUATION frames, where the last CONTINUATION frame has the END_HEADERS flag set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* End_headersフラグが解消されたヘッダーまたはPush_promiseフレームと1つ以上の継続フレーム。最後の継続フレームにはend_headersフラグが設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each field block is processed as a discrete unit. Field blocks MUST be transmitted as a contiguous sequence of frames, with no interleaved frames of any other type or from any other stream. The last frame in a sequence of HEADERS or CONTINUATION frames has the END_HEADERS flag set. The last frame in a sequence of PUSH_PROMISE or CONTINUATION frames has the END_HEADERS flag set. This allows a field block to be logically equivalent to a single frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各フィールドブロックは、離散ユニットとして処理されます。フィールドブロックは、他のタイプまたは他のストリームからのインターリーブフレームなしで、隣接する一連のフレームとして送信する必要があります。一連のヘッダーまたは継続フレームの最後のフレームには、end_headersフラグが設定されています。Push_promiseまたは継続フレームのシーケンスの最後のフレームには、end_headersフラグが設定されています。これにより、フィールドブロックが単一のフレームと論理的に同等になることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Field block fragments can only be sent as the frame payload of HEADERS, PUSH_PROMISE, or CONTINUATION frames because these frames carry data that can modify the compression context maintained by a receiver. An endpoint receiving HEADERS, PUSH_PROMISE, or CONTINUATION frames needs to reassemble field blocks and perform decompression even if the frames are to be discarded. A receiver MUST terminate the connection with a connection error (Section 5.4.1) of type COMPRESSION_ERROR if it does not decompress a field block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドブロックフラグメントは、ヘッダー、Push_Promise、または継続フレームのフレームペイロードとしてのみ送信できます。これらのフレームは、受信機によって維持される圧縮コンテキストを変更できるデータを運ぶためです。ヘッダー、Push_Promise、または継続フレームを受信するエンドポイントは、フレームを破棄してもフィールドブロックを再組み立てし、減圧を実行する必要があります。受信機は、フィールドブロックを解凍しない場合、型圧縮_Errorの接続エラー（セクション5.4.1）で接続を終了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A decoding error in a field block MUST be treated as a connection error (Section 5.4.1) of type COMPRESSION_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドブロックのデコードエラーは、型圧縮_errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3-1--Compression-State">
4.3.1. Compression State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. 圧縮状態
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Field compression is stateful. Each endpoint has an HPACK encoder context and an HPACK decoder context that are used for encoding and decoding all field blocks on a connection. Section 4 of [COMPRESSION] defines the dynamic table, which is the primary state for each context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールド圧縮はステートフルです。各エンドポイントには、HPACKエンコーダーコンテキストと、接続上のすべてのフィールドブロックのエンコードとデコードに使用されるHPACKデコーダーコンテキストがあります。[圧縮]のセクション4は、各コンテキストの主要状態である動的テーブルを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The dynamic table has a maximum size that is set by an HPACK decoder. An endpoint communicates the size chosen by its HPACK decoder context using the SETTINGS_HEADER_TABLE_SIZE setting; see Section 6.5.2. When a connection is established, the dynamic table size for the HPACK decoder and encoder at both endpoints starts at 4,096 bytes, the initial value of the SETTINGS_HEADER_TABLE_SIZE setting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
動的テーブルの最大サイズは、HPACKデコーダーによって設定されています。エンドポイントは、settings_header_table_size設定を使用して、HPACKデコーダーコンテキストによって選択されたサイズを通知します。セクション6.5.2を参照してください。接続が確立されると、両方のエンドポイントでのHPACKデコーダーとエンコーダーの動的テーブルサイズは4,096バイトから始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any change to the maximum value set using SETTINGS_HEADER_TABLE_SIZE takes effect when the endpoint acknowledges settings (Section 6.5.3). The HPACK encoder at that endpoint can set the dynamic table to any size up to the maximum value set by the decoder. An HPACK encoder declares the size of the dynamic table with a Dynamic Table Size Update instruction (Section 6.3 of [COMPRESSION]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
settings_header_table_sizeを使用して最大値セットを変更すると、エンドポイントが設定を確認すると有効になります（セクション6.5.3）。そのエンドポイントのHPACKエンコーダーは、デコーダーによって設定された最大値まで任意のサイズに動的テーブルを設定できます。HPACKエンコーダーは、動的テーブルサイズの更新命令（[圧縮]のセクション6.3）を備えた動的テーブルのサイズを宣言します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once an endpoint acknowledges a change to SETTINGS_HEADER_TABLE_SIZE that reduces the maximum below the current size of the dynamic table, its HPACK encoder MUST start the next field block with a Dynamic Table Size Update instruction that sets the dynamic table to a size that is less than or equal to the reduced maximum; see Section 4.2 of [COMPRESSION]. An endpoint MUST treat a field block that follows an acknowledgment of the reduction to the maximum dynamic table size as a connection error (Section 5.4.1) of type COMPRESSION_ERROR if it does not start with a conformant Dynamic Table Size Update instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントが動的テーブルの現在のサイズ以下の最大値を減らすsettings_header_table_sizeの変更を認めたら、そのHPACKエンコーダーは、動的テーブルサイズの更新命令を使用して次のフィールドブロックを開始する必要があります。最大値の削減に等しい。[圧縮]のセクション4.2を参照してください。エンドポイントは、適合ダイナミックテーブルサイズの更新命令で開始しない場合、タイプCompression_Errorの接続エラー（セクション5.4.1）として、最大動的テーブルサイズへの削減の認識に従うフィールドブロックを処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      |  Implementers are advised that reducing the value of
      |  SETTINGS_HEADER_TABLE_SIZE is not widely interoperable.  Use of
      |  the connection preface to reduce the value below the initial
      |  value of 4,096 is somewhat better supported, but this might
      |  fail with some implementations.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Streams-and-Multiplexing">
5. Streams and Multiplexing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. ストリームと多重化
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A &#34;stream&#34; is an independent, bidirectional sequence of frames exchanged between the client and server within an HTTP/2 connection. Streams have several important characteristics:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「ストリーム」は、HTTP/2接続内でクライアントとサーバーの間で交換される独立した双方向のフレームのシーケンスです。ストリームにはいくつかの重要な特性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* A single HTTP/2 connection can contain multiple concurrently open streams, with either endpoint interleaving frames from multiple streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 単一のHTTP/2接続には、複数のストリームからのエンドポイントインターリーブフレームを備えた複数の同時にオープンストリームを含めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Streams can be established and used unilaterally or shared by either endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ストリームは、一方的に確立および使用するか、いずれかのエンドポイントで共有できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Streams can be closed by either endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ストリームは、いずれかのエンドポイントで閉じることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The order in which frames are sent is significant. Recipients process frames in the order they are received. In particular, the order of HEADERS and DATA frames is semantically significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* フレームが送信される順序は重要です。受信者は、受信した順序でフレームを処理します。特に、ヘッダーとデータフレームの順序は意味的に重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Streams are identified by an integer. Stream identifiers are assigned to streams by the endpoint initiating the stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ストリームは整数によって識別されます。ストリーム識別子は、ストリームを開始するエンドポイントによってストリームに割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--Stream-States">
5.1. Stream States
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. ストリーム状態
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The lifecycle of a stream is shown in Figure 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリームのライフサイクルを図2に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                +--------+
                        send PP |        | recv PP
                       ,--------+  idle  +--------.
                      /         |        |         \
                     v          +--------+          v
              +----------+          |           +----------+
              |          |          | send H /  |          |
       ,------+ reserved |          | recv H    | reserved +------.
       |      | (local)  |          |           | (remote) |      |
       |      +---+------+          v           +------+---+      |
       |          |             +--------+             |          |
       |          |     recv ES |        | send ES     |          |
       |   send H |     ,-------+  open  +-------.     | recv H   |
       |          |    /        |        |        \    |          |
       |          v   v         +---+----+         v   v          |
       |      +----------+          |           +----------+      |
       |      |   half-  |          |           |   half-  |      |
       |      |  closed  |          | send R /  |  closed  |      |
       |      | (remote) |          | recv R    | (local)  |      |
       |      +----+-----+          |           +-----+----+      |
       |           |                |                 |           |
       |           | send ES /      |       recv ES / |           |
       |           |  send R /      v        send R / |           |
       |           |  recv R    +--------+   recv R   |           |
       | send R /  `-----------&gt;|        |&lt;-----------&#39;  send R / |
       | recv R                 | closed |               recv R   |
       `-----------------------&gt;|        |&lt;-----------------------&#39;
                                +--------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-26">
Figure 2: Stream States
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-26">
図2：ストリーム状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
send: endpoint sends this frame recv: endpoint receives this frame H: HEADERS frame (with implied CONTINUATION frames) ES: END_STREAM flag R: RST_STREAM frame PP: PUSH_PROMISE frame (with implied CONTINUATION frames); state transitions are for the promised stream
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信：エンドポイントはこのフレームを送信しますRecv：エンドポイントはこのフレームH：ヘッダーフレーム（暗黙の継続フレーム）ES：END_STREAM FLAG R：RST_STREAMフレームPP：Push_Promiseフレーム（暗黙の継続フレーム付き）;州の移行は、約束されたストリーム用です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this diagram shows stream state transitions and the frames and flags that affect those transitions only. In this regard, CONTINUATION frames do not result in state transitions; they are effectively part of the HEADERS or PUSH_PROMISE that they follow. For the purpose of state transitions, the END_STREAM flag is processed as a separate event to the frame that bears it; a HEADERS frame with the END_STREAM flag set can cause two state transitions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この図は、ストリーム状態の遷移と、それらの遷移のみに影響するフレームとフラグを示していることに注意してください。この点で、継続フレームは状態の遷移につながっていません。彼らは事実上、彼らが従うヘッダーまたはPush_promiseの一部です。状態遷移の目的のために、End_streamフラグは、それを担うフレームの別のイベントとして処理されます。end_streamフラグセットを備えたヘッダーフレームは、2つの状態遷移を引き起こす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both endpoints have a subjective view of the state of a stream that could be different when frames are in transit. Endpoints do not coordinate the creation of streams; they are created unilaterally by either endpoint. The negative consequences of a mismatch in states are limited to the &#34;closed&#34; state after sending RST_STREAM, where frames might be received for some time after closing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらのエンドポイントにも、フレームが通過しているときに異なる可能性のあるストリームの状態を主観的なビューがあります。エンドポイントは、ストリームの作成を調整しません。どちらのエンドポイントによっても一方的に作成されます。州での不一致の否定的な結果は、rst_streamを送信した後、「閉じた」状態に限定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Streams have the following states:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリームには次の状態があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
idle: All streams start in the &#34;idle&#34; state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アイドル：すべてのストリームは「アイドル」状態で始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The following transitions are valid from this state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
次の遷移は、この状態から有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Sending a HEADERS frame as a client, or receiving a HEADERS frame as a server, causes the stream to become &#34;open&#34;. The stream identifier is selected as described in Section 5.1.1. The same HEADERS frame can also cause a stream to immediately become &#34;half-closed&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントとしてヘッダーフレームを送信するか、サーバーとしてヘッダーフレームを受信すると、ストリームが「オープン」になります。ストリーム識別子は、セクション5.1.1で説明されているように選択されます。同じヘッダーフレームは、ストリームをすぐに「半分閉鎖」する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Sending a PUSH_PROMISE frame on another stream reserves the idle stream that is identified for later use. The stream state for the reserved stream transitions to &#34;reserved (local)&#34;. Only a server may send PUSH_PROMISE frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 別のストリームにPush_Promiseフレームを送信すると、後で使用するために識別されるアイドルストリームが予約されます。予約済みのストリームのストリーム状態は、「予約済み（ローカル）」に移行します。Push_promiseフレームを送信できるサーバーのみができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Receiving a PUSH_PROMISE frame on another stream reserves an idle stream that is identified for later use. The stream state for the reserved stream transitions to &#34;reserved (remote)&#34;. Only a client may receive PUSH_PROMISE frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 別のストリームでPush_Promiseフレームを受信すると、後で使用するために識別されるアイドルストリームが予約されます。予約済みのストリームのストリーム状態は、「予約済み（リモート）」に移行します。Push_promiseフレームを受信できるのはクライアントのみです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Note that the PUSH_PROMISE frame is not sent on the idle stream but references the newly reserved stream in the Promised Stream ID field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Push_Promiseフレームはアイドルストリームに送信されないが、約束されたストリームIDフィールドの新しく予約されたストリームを参照することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Opening a stream with a higher-valued stream identifier causes the stream to transition immediately to a &#34;closed&#34; state; note that this transition is not shown in the diagram.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 高価値のストリーム識別子でストリームを開くと、ストリームはすぐに「閉じた」状態に移行します。この遷移は図に示されていないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Receiving any frame other than HEADERS or PRIORITY on a stream in this state MUST be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR. If this stream is initiated by the server, as described in Section 5.1.1, then receiving a HEADERS frame MUST also be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この状態のストリームでヘッダーまたは優先度以外のフレームを受信することは、型Protocol_Errorの接続エラー（セクション5.4.1）として扱わなければなりません。セクション5.1.1で説明されているように、このストリームがサーバーによって開始された場合、ヘッダーフレームを受信することも、型プロトコル_Errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
reserved (local): A stream in the &#34;reserved (local)&#34; state is one that has been promised by sending a PUSH_PROMISE frame. A PUSH_PROMISE frame reserves an idle stream by associating the stream with an open stream that was initiated by the remote peer (see Section 8.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予約済み（ローカル）：「予約済み（ローカル）」状態のストリームは、Push_promiseフレームを送信することで約束されている状態です。Push_Promiseフレームは、リモートピアによって開始されたオープンストリームにストリームを関連付けることにより、アイドルストリームを留保します（セクション8.4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In this state, only the following transitions are possible:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この状態では、次の遷移のみが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The endpoint can send a HEADERS frame. This causes the stream to open in a &#34;half-closed (remote)&#34; state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* エンドポイントはヘッダーフレームを送信できます。これにより、ストリームは「半分閉鎖された（リモート）」状態で開きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Either endpoint can send a RST_STREAM frame to cause the stream to become &#34;closed&#34;. This releases the stream reservation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* いずれかのEndPointがRST_STREAMフレームを送信して、ストリームを「閉じた」ようにすることができます。これにより、ストリーム予約がリリースされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An endpoint MUST NOT send any type of frame other than HEADERS, RST_STREAM, or PRIORITY in this state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
エンドポイントは、この状態のヘッダー、RST_stream、または優先度以外のフレームを送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A PRIORITY or WINDOW_UPDATE frame MAY be received in this state. Receiving any type of frame other than RST_STREAM, PRIORITY, or WINDOW_UPDATE on a stream in this state MUST be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この状態では、優先順位またはwindow_updateフレームが受信される場合があります。この状態のストリームでRST_STREAM、PRIORITY、またはWINDOW_UPDATE以外の任意のタイプのフレームを受信することは、タイプProtocol_Errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
reserved (remote): A stream in the &#34;reserved (remote)&#34; state has been reserved by a remote peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予約済み（リモート）：「予約済み（リモート）」状態のストリームは、リモートピアによって予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In this state, only the following transitions are possible:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この状態では、次の遷移のみが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Receiving a HEADERS frame causes the stream to transition to &#34;half-closed (local)&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ヘッダーフレームを受信すると、ストリームは「半分閉鎖（ローカル）」に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Either endpoint can send a RST_STREAM frame to cause the stream to become &#34;closed&#34;. This releases the stream reservation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* いずれかのEndPointがRST_STREAMフレームを送信して、ストリームを「閉じた」ようにすることができます。これにより、ストリーム予約がリリースされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An endpoint MUST NOT send any type of frame other than RST_STREAM, WINDOW_UPDATE, or PRIORITY in this state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
エンドポイントは、この状態のRST_STREAM、window_update、または優先度以外のフレームを送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Receiving any type of frame other than HEADERS, RST_STREAM, or PRIORITY on a stream in this state MUST be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この状態のストリームのヘッダー、RST_STREAM、または優先度以外のフレームを受信することは、型Protocol_Errorの接続エラー（セクション5.4.1）として扱わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
open: A stream in the &#34;open&#34; state may be used by both peers to send frames of any type. In this state, sending peers observe advertised stream-level flow-control limits (Section 5.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープン：「オープン」状態のストリームは、両方のピアが任意のタイプのフレームを送信するために使用できます。この状態では、送信仲間が広告されたストリームレベルのフロー制御制限を観察します（セクション5.2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
From this state, either endpoint can send a frame with an END_STREAM flag set, which causes the stream to transition into one of the &#34;half-closed&#34; states. An endpoint sending an END_STREAM flag causes the stream state to become &#34;half-closed (local)&#34;; an endpoint receiving an END_STREAM flag causes the stream state to become &#34;half-closed (remote)&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この状態から、いずれかのEndPointがEnd_Streamフラグセットを備えたフレームを送信することができます。これにより、ストリームは「半分閉鎖された」状態の1つに移行します。end_streamフラグを送信するエンドポイントにより、ストリーム状態は「半分閉鎖（ローカル）」になります。end_streamフラグを受信するエンドポイントにより、ストリーム状態は「半分閉鎖（リモート）」になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Either endpoint can send a RST_STREAM frame from this state, causing it to transition immediately to &#34;closed&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
いずれかのEndPointがこの状態からRST_STREAMフレームを送信できるため、すぐに「閉じ」に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
half-closed (local): A stream that is in the &#34;half-closed (local)&#34; state cannot be used for sending frames other than WINDOW_UPDATE, PRIORITY, and RST_STREAM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
半分閉鎖（ローカル）：window_update、priority、rst_stream以外のフレームを送信するために「半分閉じた（ローカル）」状態にあるストリームを使用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A stream transitions from this state to &#34;closed&#34; when a frame is received with the END_STREAM flag set or when either peer sends a RST_STREAM frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この状態から、end_streamフラグが設定されたフレームが受信されたとき、またはどちらかのピアがRST_streamフレームを送信するときに、この状態から「閉じた」までのストリームが移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An endpoint can receive any type of frame in this state. Providing flow-control credit using WINDOW_UPDATE frames is necessary to continue receiving flow-controlled frames. In this state, a receiver can ignore WINDOW_UPDATE frames, which might arrive for a short period after a frame with the END_STREAM flag set is sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
エンドポイントは、この状態のあらゆるタイプのフレームを受信できます。フロー制御フレームの受信を継続するには、window_updateフレームを使用してフローコントロールクレジットを提供する必要があります。この状態では、レシーバーはWindow_Updateフレームを無視できます。これは、End_streamフラグセットが送信されたフレームが送信された後、短期間到着する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PRIORITY frames can be received in this state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この状態では、優先フレームを受信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
half-closed (remote): A stream that is &#34;half-closed (remote)&#34; is no longer being used by the peer to send frames. In this state, an endpoint is no longer obligated to maintain a receiver flow-control window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
半分閉鎖（リモート）：「半分閉じた（リモート）」のストリームは、ピアがフレームを送信するために使用されなくなりました。この状態では、エンドポイントは、レシーバーフローコントロールウィンドウを維持する義務がなくなりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If an endpoint receives additional frames, other than WINDOW_UPDATE, PRIORITY, or RST_STREAM, for a stream that is in this state, it MUST respond with a stream error (Section 5.4.2) of type STREAM_CLOSED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この状態にあるストリームの場合、window_update、priority、またはrst_stream以外のエンドポイントが追加のフレームを受信する場合、type stream_closedのストリームエラー（セクション5.4.2）で応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A stream that is &#34;half-closed (remote)&#34; can be used by the endpoint to send frames of any type. In this state, the endpoint continues to observe advertised stream-level flow-control limits (Section 5.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
「半分閉鎖された（リモート）」のストリームは、エンドポイントで任意のタイプのフレームを送信するために使用できます。この状態では、エンドポイントは、広告されたストリームレベルのフローコントロール制限を観察し続けています（セクション5.2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A stream can transition from this state to &#34;closed&#34; by sending a frame with the END_STREAM flag set or when either peer sends a RST_STREAM frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
end_streamフラグセットでフレームを送信するか、いずれかのピアがRST_STREAMフレームを送信した場合、この状態から「閉じた」ストリームは、「閉じ」に移行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
closed: The &#34;closed&#34; state is the terminal state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
閉鎖：「閉じた」状態はターミナル状態です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A stream enters the &#34;closed&#34; state after an endpoint both sends and receives a frame with an END_STREAM flag set. A stream also enters the &#34;closed&#34; state after an endpoint either sends or receives a RST_STREAM frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
エンドポイントがEnd_streamフラグセットを備えたフレームを送信および受信すると、エンドポイントが「閉じた」状態に入ります。また、エンドポイントがRST_STREAMフレームを送信または受信した後、ストリームは「閉じた」状態にも入ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An endpoint MUST NOT send frames other than PRIORITY on a closed stream. An endpoint MAY treat receipt of any other type of frame on a closed stream as a connection error (Section 5.4.1) of type STREAM_CLOSED, except as noted below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
エンドポイントは、閉じたストリームで優先度以外のフレームを送信してはなりません。エンドポイントは、以下の場合を除き、閉じたストリームの他のタイプのフレームの受信を型の型ストリームの接続エラー（セクション5.4.1）として扱うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An endpoint that sends a frame with the END_STREAM flag set or a RST_STREAM frame might receive a WINDOW_UPDATE or RST_STREAM frame from its peer in the time before the peer receives and processes the frame that closes the stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
End_streamフラグセットまたはRST_STREAMフレームを備えたフレームを送信するエンドポイントは、ピアがストリームを閉じるフレームを受信および処理する前に、ピアからWindow_UpdateまたはRST_Streamフレームをピアから受信する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An endpoint that sends a RST_STREAM frame on a stream that is in the &#34;open&#34; or &#34;half-closed (local)&#34; state could receive any type of frame. The peer might have sent or enqueued for sending these frames before processing the RST_STREAM frame. An endpoint MUST minimally process and then discard any frames it receives in this state. This means updating header compression state for HEADERS and PUSH_PROMISE frames. Receiving a PUSH_PROMISE frame also causes the promised stream to become &#34;reserved (remote)&#34;, even when the PUSH_PROMISE frame is received on a closed stream. Additionally, the content of DATA frames counts toward the connection flow-control window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
「オープン」または「半分閉鎖（ローカル）」状態にあるストリームにRST_STREAMフレームを送信するエンドポイントは、あらゆるタイプのフレームを受信できます。ピアは、RST_STREAMフレームを処理する前に、これらのフレームを送信するために送信またはエンキューをした可能性があります。エンドポイントは、最小限の処理を行い、この状態で受信するフレームを破棄する必要があります。これは、ヘッダーとPush_promiseフレームのヘッダー圧縮状態を更新することを意味します。Push_Promiseフレームを受信すると、Push_Promiseフレームが閉じたストリームで受信された場合でも、約束のストリームが「予約済み（リモート）」になります。さらに、データフレームのコンテンツは、接続フローコントロールウィンドウにカウントされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An endpoint can perform this minimal processing for all streams that are in the &#34;closed&#34; state. Endpoints MAY use other signals to detect that a peer has received the frames that caused the stream to enter the &#34;closed&#34; state and treat receipt of any frame other than PRIORITY as a connection error (Section 5.4.1) of type PROTOCOL_ERROR. Endpoints can use frames that indicate that the peer has received the closing signal to drive this. Endpoints SHOULD NOT use timers for this purpose. For example, an endpoint that sends a SETTINGS frame after closing a stream can safely treat receipt of a DATA frame on that stream as an error after receiving an acknowledgment of the settings. Other things that might be used are PING frames, receiving data on streams that were created after closing the stream, or responses to requests created after closing the stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
エンドポイントは、「閉じた」状態にあるすべてのストリームに対してこの最小限の処理を実行できます。エンドポイントは、他の信号を使用して、ピアがストリームが「閉じた」状態に入り、タイプProtocol_Errorの接続エラー（セクション5.4.1）として優先順位以外のフレームの受領を処理する原因となったフレームを受信したことを検出できます。エンドポイントは、ピアがこれを駆動するために閉鎖信号を受け取ったことを示すフレームを使用できます。エンドポイントは、この目的のためにタイマーを使用しないでください。たとえば、ストリームを閉じた後に設定フレームを送信するエンドポイントは、設定の確認を受信した後、そのストリームのデータフレームの受領をエラーとして安全に処理できます。使用される可能性のあるその他のものは、Pingフレーム、ストリームを閉じた後に作成されたストリームのデータを受信すること、またはストリームを閉じた後に作成されたリクエストへの応答です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the absence of more specific rules, implementations SHOULD treat the receipt of a frame that is not expressly permitted in the description of a state as a connection error (Section 5.4.1) of type PROTOCOL_ERROR. Note that PRIORITY can be sent and received in any stream state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
より具体的なルールがない場合、実装は、状態の説明では、型Protocol_Errorの接続エラー（セクション5.4.1）として明示的に許可されていないフレームの受領を扱う必要があります。優先度は、任意のストリーム状態で送信および受信できることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules in this section only apply to frames defined in this document. Receipt of frames for which the semantics are unknown cannot be treated as an error, as the conditions for sending and receiving those frames are also unknown; see Section 5.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションのルールは、このドキュメントで定義されているフレームにのみ適用されます。セマンティクスが不明なフレームの受信は、それらのフレームを送信および受信する条件も不明であるため、エラーとして扱うことはできません。セクション5.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example of the state transitions for an HTTP request/response exchange can be found in Section 8.8. An example of the state transitions for server push can be found in Sections 8.4.1 and 8.4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP要求/応答交換の状態遷移の例は、セクション8.8に記載されています。サーバープッシュの状態遷移の例は、セクション8.4.1および8.4.2に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1-1--Stream-Identifiers">
5.1.1. Stream Identifiers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1. ストリーム識別子
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Streams are identified by an unsigned 31-bit integer. Streams initiated by a client MUST use odd-numbered stream identifiers; those initiated by the server MUST use even-numbered stream identifiers. A stream identifier of zero (0x00) is used for connection control messages; the stream identifier of zero cannot be used to establish a new stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリームは、署名されていない31ビット整数によって識別されます。クライアントによって開始されたストリームは、奇数のストリーム識別子を使用する必要があります。サーバーによって開始されたものは、均等なストリーム識別子を使用する必要があります。ゼロ（0x00）のストリーム識別子が接続制御メッセージに使用されます。ゼロのストリーム識別子を使用して新しいストリームを確立することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The identifier of a newly established stream MUST be numerically greater than all streams that the initiating endpoint has opened or reserved. This governs streams that are opened using a HEADERS frame and streams that are reserved using PUSH_PROMISE. An endpoint that receives an unexpected stream identifier MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しく確立されたストリームの識別子は、開始エンドポイントが開いたり予約したすべてのストリームよりも数値的に大きくなければなりません。これは、Headersフレームを使用して開くストリームと、Push_promiseを使用して予約されているストリームを管理します。予期しないストリーム識別子を受信するエンドポイントは、型protocol_errorの接続エラー（セクション5.4.1）で応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A HEADERS frame will transition the client-initiated stream identified by the stream identifier in the frame header from &#34;idle&#34; to &#34;open&#34;. A PUSH_PROMISE frame will transition the server-initiated stream identified by the Promised Stream ID field in the frame payload from &#34;idle&#34; to &#34;reserved (local)&#34; or &#34;reserved (remote)&#34;. When a stream transitions out of the &#34;idle&#34; state, all streams in the &#34;idle&#34; state that might have been opened by the peer with a lower-valued stream identifier immediately transition to &#34;closed&#34;. That is, an endpoint may skip a stream identifier, with the effect being that the skipped stream is immediately closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフレームは、フレームヘッダーのストリーム識別子によって識別されたクライアント開始ストリームを「アイドル」から「オープン」に遷移します。Push_Promiseフレームは、フレームペイロードの約束されたストリームIDフィールドによって「アイドル」から「予約済み（ローカル）」または「予約済み（リモート）」に識別されたサーバー開始ストリームを遷移します。ストリームが「アイドル」状態から遷移すると、ピアによって開かれた可能性のある「アイドル」状態のすべてのストリームが、すぐに「閉じ」に移行します。つまり、エンドポイントはストリーム識別子をスキップする場合があり、その効果はスキップされたストリームがすぐに閉じられることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stream identifiers cannot be reused. Long-lived connections can result in an endpoint exhausting the available range of stream identifiers. A client that is unable to establish a new stream identifier can establish a new connection for new streams. A server that is unable to establish a new stream identifier can send a GOAWAY frame so that the client is forced to open a new connection for new streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリーム識別子を再利用できません。長寿命の接続により、エンドポイントが利用可能な範囲のストリーム識別子を使い果たす可能性があります。新しいストリーム識別子を確立できないクライアントは、新しいストリームの新しい接続を確立できます。新しいストリーム識別子を確立できないサーバーは、クライアントが新しいストリームの新しい接続を開くことを余儀なくされるように、Goawayフレームを送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1-2--Stream-Concurrency">
5.1.2. Stream Concurrency
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.2. 並行性をストリーミングします
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer can limit the number of concurrently active streams using the SETTINGS_MAX_CONCURRENT_STREAMS parameter (see Section 6.5.2) within a SETTINGS frame. The maximum concurrent streams setting is specific to each endpoint and applies only to the peer that receives the setting. That is, clients specify the maximum number of concurrent streams the server can initiate, and servers specify the maximum number of concurrent streams the client can initiate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、設定フレーム内のsettings_max_concurrent_streamsパラメーター（セクション6.5.2を参照）を使用して、同時にアクティブなストリームの数を制限できます。最大同時ストリーム設定は各エンドポイントに固有であり、設定を受信するピアにのみ適用されます。つまり、クライアントはサーバーが開始できる並行ストリームの最大数を指定し、サーバーはクライアントが開始できる並行ストリームの最大数を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Streams that are in the &#34;open&#34; state or in either of the &#34;half-closed&#34; states count toward the maximum number of streams that an endpoint is permitted to open. Streams in any of these three states count toward the limit advertised in the SETTINGS_MAX_CONCURRENT_STREAMS setting. Streams in either of the &#34;reserved&#34; states do not count toward the stream limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「オープン」状態または「半分閉鎖された」状態のいずれかにあるストリームは、エンドポイントが開くことが許可されているストリームの最大数にカウントされます。これら3つの状態のいずれかのストリームは、settings_max_concurrent_streams設定で宣伝されている制限にカウントされます。「予約された」状態のいずれかのストリームは、ストリーム制限にカウントされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints MUST NOT exceed the limit set by their peer. An endpoint that receives a HEADERS frame that causes its advertised concurrent stream limit to be exceeded MUST treat this as a stream error (Section 5.4.2) of type PROTOCOL_ERROR or REFUSED_STREAM. The choice of error code determines whether the endpoint wishes to enable automatic retry (see Section 8.7 for details).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、ピアによって設定された制限を超えてはなりません。宣伝されている同時のストリーム制限を超えるヘッダーフレームを受信するエンドポイントは、これを型Protocol_Errorまたはredused_streamのストリームエラー（セクション5.4.2）として扱う必要があります。エラーコードの選択により、エンドポイントが自動再試行を有効にしたいかどうかを決定します（詳細についてはセクション8.7を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint that wishes to reduce the value of SETTINGS_MAX_CONCURRENT_STREAMS to a value that is below the current number of open streams can either close streams that exceed the new value or allow streams to complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Settings_max_concurrent_streamsの値を現在のオープンストリームの数を下回る値に削減したいエンドポイントは、新しい値を超えるクローズストリームを超えるか、ストリームを完了することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--Flow-Control">
5.2. Flow Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. フロー制御
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using streams for multiplexing introduces contention over use of the TCP connection, resulting in blocked streams. A flow-control scheme ensures that streams on the same connection do not destructively interfere with each other. Flow control is used for both individual streams and the connection as a whole.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチプレックスにストリームを使用すると、TCP接続の使用に関する競合が導入され、ブロックされたストリームが生じます。フローコントロールスキームにより、同じ接続のストリームが互いに破壊的に干渉しないことが保証されます。フロー制御は、個々のストリームと接続全体の両方に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 provides for flow control through use of the WINDOW_UPDATE frame (Section 6.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2は、window_updateフレームを使用してフロー制御を提供します（セクション6.9）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2-1--Flow-Control-Principles">
5.2.1. Flow-Control Principles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.1. フロー制御原則
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 stream flow control aims to allow a variety of flow-control algorithms to be used without requiring protocol changes. Flow control in HTTP/2 has the following characteristics:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2ストリームフロー制御は、プロトコルの変更を必要とせずに、さまざまなフローコントロールアルゴリズムを使用できるようにすることを目的としています。HTTP/2のフロー制御には、次の特性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Flow control is specific to a connection. HTTP/2 flow control operates between the endpoints of a single hop and not over the entire end-to-end path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. フロー制御は接続に固有です。HTTP/2フロー制御は、単一のホップのエンドポイント間で動作し、エンドツーエンドパス全体ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Flow control is based on WINDOW_UPDATE frames. Receivers advertise how many octets they are prepared to receive on a stream and for the entire connection. This is a credit-based scheme.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. フロー制御は、window_updateフレームに基づいています。レシーバーは、ストリームと接続全体で受信する準備ができているオクテットの数を宣伝します。これはクレジットベースのスキームです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Flow control is directional with overall control provided by the receiver. A receiver MAY choose to set any window size that it desires for each stream and for the entire connection. A sender MUST respect flow-control limits imposed by a receiver. Clients, servers, and intermediaries all independently advertise their flow-control window as a receiver and abide by the flow-control limits set by their peer when sending.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. フロー制御は、レシーバーが提供する全体的な制御により方向性があります。受信者は、各ストリームと接続全体に必要なウィンドウサイズを設定することを選択できます。送信者は、受信機によって課されるフロー制御制限を尊重する必要があります。クライアント、サーバー、および仲介者はすべて、すべて独立してフロー制御ウィンドウをレシーバーとして宣伝し、送信時にピアが設定したフロー制御制限を順守します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The initial value for the flow-control window is 65,535 octets for both new streams and the overall connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. フローコントロールウィンドウの初期値は、新しいストリームと全体的な接続の両方で65,535オクテットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. The frame type determines whether flow control applies to a frame. Of the frames specified in this document, only DATA frames are subject to flow control; all other frame types do not consume space in the advertised flow-control window. This ensures that important control frames are not blocked by flow control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. フレームタイプは、フロー制御がフレームに適用されるかどうかを決定します。このドキュメントで指定されたフレームのうち、データフレームのみがフロー制御の対象となります。他のすべてのフレームタイプは、広告されたフロー制御ウィンドウでスペースを消費しません。これにより、重要な制御フレームがフロー制御によってブロックされないようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. An endpoint can choose to disable its own flow control, but an endpoint cannot ignore flow-control signals from its peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. エンドポイントは独自のフロー制御を無効にすることを選択できますが、エンドポイントはピアからのフロー制御信号を無視することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. HTTP/2 defines only the format and semantics of the WINDOW_UPDATE frame (Section 6.9). This document does not stipulate how a receiver decides when to send this frame or the value that it sends, nor does it specify how a sender chooses to send packets. Implementations are able to select any algorithm that suits their needs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. HTTP/2は、window_updateフレームの形式とセマンティクスのみを定義します（セクション6.9）。このドキュメントでは、受信者がこのフレームをいつ送信するか、または送信する値を決定する方法を規定していません。また、送信者がパケットを送信する方法を指定しません。実装は、ニーズに合った任意のアルゴリズムを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations are also responsible for prioritizing the sending of requests and responses, choosing how to avoid head-of-line blocking for requests, and managing the creation of new streams. Algorithm choices for these could interact with any flow-control algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、実装は、リクエストと応答の送信を優先順位付けし、リクエストの頭のブロックを回避する方法を選択し、新しいストリームの作成を管理する責任があります。これらのアルゴリズムの選択は、任意のフロー制御アルゴリズムと相互作用する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2-2--Appropriate-Use-of-Flow-Control">
5.2.2. Appropriate Use of Flow Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2. フロー制御の適切な使用
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow control is defined to protect endpoints that are operating under resource constraints. For example, a proxy needs to share memory between many connections and also might have a slow upstream connection and a fast downstream one. Flow control addresses cases where the receiver is unable to process data on one stream yet wants to continue to process other streams in the same connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー制御は、リソースの制約の下で動作しているエンドポイントを保護するために定義されます。たとえば、プロキシは多くの接続間でメモリを共有する必要があり、また上流の接続が遅く、下流の接続が速い場合もあります。フロー制御は、レシーバーが1つのストリームでデータを処理できない場合に対処しますが、同じ接続で他のストリームを処理し続けたいと考えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Deployments that do not require this capability can advertise a flow-control window of the maximum size (2^31-1) and can maintain this window by sending a WINDOW_UPDATE frame when any data is received. This effectively disables flow control for that receiver. Conversely, a sender is always subject to the flow-control window advertised by the receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この機能を必要としない展開は、最大サイズ（2^31-1）のフローコントロールウィンドウを宣伝し、データを受信したときにwindow_updateフレームを送信することでこのウィンドウを維持できます。これにより、その受信機のフロー制御が効果的に無効になります。逆に、送信者は常にレシーバーによって宣伝されているフローコントロールウィンドウの対象となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Deployments with constrained resources (for example, memory) can employ flow control to limit the amount of memory a peer can consume. Note, however, that this can lead to suboptimal use of available network resources if flow control is enabled without knowledge of the bandwidth * delay product (see [RFC7323]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制約付きリソース（メモリなど）を使用した展開は、フロー制御を使用して、ピアが消費できるメモリの量を制限できます。ただし、これにより、帯域幅 *遅延積の知識なしにフロー制御が有効になっている場合、利用可能なネットワークリソースの以下の使用につながる可能性があることに注意してください（[RFC7323]を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even with full awareness of the current bandwidth * delay product, implementation of flow control can be difficult. Endpoints MUST read and process HTTP/2 frames from the TCP receive buffer as soon as data is available. Failure to read promptly could lead to a deadlock when critical frames, such as WINDOW_UPDATE, are not read and acted upon. Reading frames promptly does not expose endpoints to resource exhaustion attacks, as HTTP/2 flow control limits resource commitments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の帯域幅 *遅延製品を完全に認識していても、フロー制御の実装は困難です。エンドポイントは、データが利用可能になったらすぐにバッファを受信したHTTP/2フレームを読み取り、処理する必要があります。window_updateなどのクリティカルフレームが読み取られて行動されていない場合、すぐに読み取れないとデッドロックにつながる可能性があります。HTTP/2のフロー制御がリソースのコミットメントを制限するため、フレームを読み取りにはエンドポイントをリソースの消耗攻撃にさらしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2-3--Flow-Control-Performance">
5.2.3. Flow-Control Performance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.3. フローコントロールパフォーマンス
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an endpoint cannot ensure that its peer always has available flow-control window space that is greater than the peer&#39;s bandwidth * delay product on this connection, its receive throughput will be limited by HTTP/2 flow control. This will result in degraded performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントが、ピアが常に利用可能なフローコントロールウィンドウスペースを保証できない場合、この接続のピアの帯域幅 *遅延製品よりも大きいフローコントロールウィンドウスペースは、HTTP/2フロー制御によって制限されます。これにより、パフォーマンスが低下します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sending timely WINDOW_UPDATE frames can improve performance. Endpoints will want to balance the need to improve receive throughput with the need to manage resource exhaustion risks and should take careful note of Section 10.5 in defining their strategy to manage window sizes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイムリーなwindow_updateフレームを送信すると、パフォーマンスが向上する可能性があります。エンドポイントは、リソースの消耗リスクを管理する必要性と、受信スループットを改善する必要性のバランスをとる必要があり、ウィンドウサイズを管理する戦略を定義する際にセクション10.5に注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3--Prioritization">
5.3. Prioritization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. 優先順位付け
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a multiplexed protocol like HTTP/2, prioritizing allocation of bandwidth and computation resources to streams can be critical to attaining good performance. A poor prioritization scheme can result in HTTP/2 providing poor performance. With no parallelism at the TCP layer, performance could be significantly worse than HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2のような多重化されたプロトコルでは、帯域幅と計算リソースの割り当ての優先順位付けは、優れたパフォーマンスを達成するために重要です。優先順位付けスキームが低いと、HTTP/2がパフォーマンスの低下をもたらす可能性があります。TCP層に並列処理がないため、パフォーマンスはHTTP/1.1よりも著しく悪化する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A good prioritization scheme benefits from the application of contextual knowledge such as the content of resources, how resources are interrelated, and how those resources will be used by a peer. In particular, clients can possess knowledge about the priority of requests that is relevant to server prioritization. In those cases, having clients provide priority information can improve performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
優れた優先順位付けスキームは、リソースのコンテンツ、リソースの相互関係、およびピアがどのように使用するかなどのコンテキスト知識の適用から利益を得ます。特に、クライアントは、サーバーの優先順位付けに関連するリクエストの優先順位に関する知識を持つことができます。そのような場合、クライアントに優先情報を提供させると、パフォーマンスが向上する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3-1--Background-on-Priority-in-RFC-7540">
5.3.1. Background on Priority in RFC 7540
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1. RFC 7540の優先度に関する背景
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 7540 defined a rich system for signaling priority of requests. However, this system proved to be complex, and it was not uniformly implemented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 7540は、リクエストの優先度をシグナル伝えるための豊富なシステムを定義しました。ただし、このシステムは複雑であることが判明し、均一に実装されていませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flexible scheme meant that it was possible for clients to express priorities in very different ways, with little consistency in the approaches that were adopted. For servers, implementing generic support for the scheme was complex. Implementation of priorities was uneven in both clients and servers. Many server deployments ignored client signals when prioritizing their handling of requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
柔軟なスキームは、クライアントが非常に異なる方法で優先順位を表現することが可能であり、採用されたアプローチの一貫性はほとんどないことを意味しました。サーバーの場合、スキームの一般的なサポートの実装は複雑でした。優先順位の実装は、クライアントとサーバーの両方で不均一でした。多くのサーバーの展開は、リクエストの処理を優先する際にクライアント信号を無視しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In short, the prioritization signaling in RFC 7540 [RFC7540] was not successful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要するに、RFC 7540 [RFC7540]の優先順位付けシグナリングは成功しませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3-2--Priority-Signaling-in-This-Document">
5.3.2. Priority Signaling in This Document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.2. このドキュメントの優先信号
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This update to HTTP/2 deprecates the priority signaling defined in RFC 7540 [RFC7540]. The bulk of the text related to priority signals is not included in this document. The description of frame fields and some of the mandatory handling is retained to ensure that implementations of this document remain interoperable with implementations that use the priority signaling described in RFC 7540.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2のこの更新は、RFC 7540 [RFC7540]で定義されている優先シグナル伝達を非難します。優先信号に関連するテキストの大部分は、このドキュメントに含まれていません。フレームフィールドの説明と必須の取り扱いの一部は、RFC 7540で説明されている優先シグナル伝達を使用する実装と相互運用可能であることを保証するために保持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A thorough description of the RFC 7540 priority scheme remains in Section 5.3 of [RFC7540].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 7540優先度スキームの徹底的な説明は、[RFC7540]のセクション5.3に残っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Signaling priority information is necessary to attain good performance in many cases. Where signaling priority information is important, endpoints are encouraged to use an alternative scheme, such as the scheme described in [HTTP-PRIORITY].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの場合、優れたパフォーマンスを達成するには、シグナリングの優先情報が必要です。シグナリングの優先情報が重要な場合、エンドポイントは[http-priolity]で説明されているスキームなどの代替スキームを使用することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Though the priority signaling from RFC 7540 was not widely adopted, the information it provides can still be useful in the absence of better information. Endpoints that receive priority signals in HEADERS or PRIORITY frames can benefit from applying that information. In particular, implementations that consume these signals would not benefit from discarding these priority signals in the absence of alternatives.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 7540からの優先シグナルは広く採用されていませんでしたが、それが提供する情報は、より良い情報がない場合でも有用です。ヘッダーまたは優先フレームで優先信号を受信するエンドポイントは、その情報を適用することで利益を得ることができます。特に、これらの信号を消費する実装は、代替案がない場合にこれらの優先信号を破棄することから恩恵を受けることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers SHOULD use other contextual information in determining priority of requests in the absence of any priority signals. Servers MAY interpret the complete absence of signals as an indication that the client has not implemented the feature. The defaults described in Section 5.3.5 of [RFC7540] are known to have poor performance under most conditions, and their use is unlikely to be deliberate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、優先信号がない場合にリクエストの優先度を決定する際に、他のコンテキスト情報を使用する必要があります。サーバーは、クライアントが機能を実装していないことを示すものとして信号の完全な不在を解釈する場合があります。[RFC7540]のセクション5.3.5で説明されているデフォルトは、ほとんどの条件下でパフォーマンスが低いことが知られており、その使用は意図的ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4--Error-Handling">
5.4. Error Handling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. エラー処理
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 framing permits two classes of errors:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2フレーミングでは、2つのクラスのエラーが許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* An error condition that renders the entire connection unusable is a connection error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 接続全体を使用できないエラー条件は、接続エラーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* An error in an individual stream is a stream error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 個々のストリームのエラーは、ストリームエラーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A list of error codes is included in Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラーコードのリストはセクション7に含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible that an endpoint will encounter frames that would cause multiple errors. Implementations MAY discover multiple errors during processing, but they SHOULD report at most one stream and one connection error as a result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントが複数のエラーを引き起こすフレームに遭遇する可能性があります。実装は、処理中に複数のエラーを発見する場合がありますが、結果として最大1つのストリームと1つの接続エラーを報告する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first stream error reported for a given stream prevents any other errors on that stream from being reported. In comparison, the protocol permits multiple GOAWAY frames, though an endpoint SHOULD report just one type of connection error unless an error is encountered during graceful shutdown. If this occurs, an endpoint MAY send an additional GOAWAY frame with the new error code, in addition to any prior GOAWAY that contained NO_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のストリームについて報告された最初のストリームエラーは、そのストリームの他のエラーが報告されるのを防ぎます。それに比べて、プロトコルは複数のGOAWAYフレームを許可しますが、エンドポイントは、優雅なシャットダウン中にエラーが発生しない限り、1つのタイプの接続エラーを報告する必要があります。これが発生した場合、エンドポイントは、NO_ERRORを含む以前のGOAWAYに加えて、新しいエラーコードを使用して追加のGOAWAYフレームを送信する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an endpoint detects multiple different errors, it MAY choose to report any one of those errors. If a frame causes a connection error, that error MUST be reported. Additionally, an endpoint MAY use any applicable error code when it detects an error condition; a generic error code (such as PROTOCOL_ERROR or INTERNAL_ERROR) can always be used in place of more specific error codes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントが複数の異なるエラーを検出した場合、それらのエラーのいずれかを報告することを選択できます。フレームが接続エラーを引き起こす場合、そのエラーを報告する必要があります。さらに、エンドポイントは、エラー条件を検出するときに該当するエラーコードを使用する場合があります。より具体的なエラーコードの代わりに、一般的なエラーコード（protocol_errorやinternal_errorなど）は、いつでも使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4-1--Connection-Error-Handling">
5.4.1. Connection Error Handling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.1. 接続エラー処理
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A connection error is any error that prevents further processing of the frame layer or corrupts any connection state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続エラーは、フレームレイヤーのさらなる処理または接続状態を破損するエラーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint that encounters a connection error SHOULD first send a GOAWAY frame (Section 6.8) with the stream identifier of the last stream that it successfully received from its peer. The GOAWAY frame includes an error code (Section 7) that indicates why the connection is terminating. After sending the GOAWAY frame for an error condition, the endpoint MUST close the TCP connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続エラーに遭遇するエンドポイントは、最初にピアから正常に受け取った最後のストリームのストリーム識別子とともに、GOAWAYフレーム（セクション6.8）を送信する必要があります。GoAwayフレームには、接続が終了している理由を示すエラーコード（セクション7）が含まれています。エラー条件のためにgoawayフレームを送信した後、エンドポイントはTCP接続を閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible that the GOAWAY will not be reliably received by the receiving endpoint. In the event of a connection error, GOAWAY only provides a best-effort attempt to communicate with the peer about why the connection is being terminated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ゲーウェイが受信エンドポイントによって確実に受け取られない可能性があります。接続エラーが発生した場合、Goawayは、接続が終了する理由についてピアと通信するための最良の試みのみを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint can end a connection at any time. In particular, an endpoint MAY choose to treat a stream error as a connection error. Endpoints SHOULD send a GOAWAY frame when ending a connection, providing that circumstances permit it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、いつでも接続を終了できます。特に、エンドポイントは、ストリームエラーを接続エラーとして扱うことを選択できます。エンドポイントは、接続を終了するときにgoawayフレームを送信し、その状況がそれを許可することを提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4-2--Stream-Error-Handling">
5.4.2. Stream Error Handling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.2. ストリームエラー処理
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A stream error is an error related to a specific stream that does not affect processing of other streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリームエラーは、他のストリームの処理に影響しない特定のストリームに関連するエラーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint that detects a stream error sends a RST_STREAM frame (Section 6.4) that contains the stream identifier of the stream where the error occurred. The RST_STREAM frame includes an error code that indicates the type of error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリームエラーを検出するエンドポイントは、エラーが発生したストリームのストリーム識別子を含むRST_STREAMフレーム（セクション6.4）を送信します。RST_STREAMフレームには、エラーのタイプを示すエラーコードが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A RST_STREAM is the last frame that an endpoint can send on a stream. The peer that sends the RST_STREAM frame MUST be prepared to receive any frames that were sent or enqueued for sending by the remote peer. These frames can be ignored, except where they modify connection state (such as the state maintained for field section compression (Section 4.3) or flow control).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RST_STREAMは、エンドポイントがストリームで送信できる最後のフレームです。RST_STREAMフレームを送信するピアは、リモートピアから送信するために送信またはエンキューされたフレームを受信するために準備する必要があります。これらのフレームは、接続状態を変更する場合（フィールドセクション圧縮（セクション4.3）またはフロー制御のために維持されている状態など）を除き、無視できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Normally, an endpoint SHOULD NOT send more than one RST_STREAM frame for any stream. However, an endpoint MAY send additional RST_STREAM frames if it receives frames on a closed stream after more than a round-trip time. This behavior is permitted to deal with misbehaving implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、エンドポイントは、ストリームに対して複数のRST_STREAMフレームを送信してはなりません。ただし、エンドポイントは、往復時間を超えて閉じたストリームのフレームを受信した場合、追加のRST_STREAMフレームを送信する場合があります。この動作は、誤動作の実装に対処することが許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid looping, an endpoint MUST NOT send a RST_STREAM in response to a RST_STREAM frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ループを避けるために、エンドポイントはRST_STREAMフレームに応じてRST_STREAMを送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4-3--Connection-Termination">
5.4.3. Connection Termination
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.3. 接続終了
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the TCP connection is closed or reset while streams remain in the &#34;open&#34; or &#34;half-closed&#34; states, then the affected streams cannot be automatically retried (see Section 8.7 for details).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP接続が閉じられているか、リセットされている場合、ストリームが「開いた」または「半分閉鎖」状態のままである場合、影響を受けるストリームは自動的に再試行できません（詳細についてはセクション8.7を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-5--Extending-HTTP2">
5.5. Extending HTTP/2
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. HTTP/2を拡張します
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 permits extension of the protocol. Within the limitations described in this section, protocol extensions can be used to provide additional services or alter any aspect of the protocol. Extensions are effective only within the scope of a single HTTP/2 connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2は、プロトコルの拡張を許可します。このセクションで説明した制限内で、プロトコル拡張を使用して追加のサービスを提供したり、プロトコルのあらゆる側面を変更したりできます。拡張機能は、単一のHTTP/2接続の範囲内でのみ有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This applies to the protocol elements defined in this document. This does not affect the existing options for extending HTTP, such as defining new methods, status codes, or fields (see Section 16 of [HTTP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、このドキュメントで定義されているプロトコル要素に適用されます。これは、新しいメソッド、ステータスコード、またはフィールドの定義など、HTTPを拡張するための既存のオプションに影響しません（[HTTP]のセクション16を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Extensions are permitted to use new frame types (Section 4.1), new settings (Section 6.5), or new error codes (Section 7). Registries for managing these extension points are defined in Section 11 of [RFC7540].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張機能は、新しいフレームタイプ（セクション4.1）、新しい設定（セクション6.5）、または新しいエラーコード（セクション7）を使用することができます。これらの拡張ポイントを管理するためのレジストリは、[RFC7540]のセクション11で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MUST ignore unknown or unsupported values in all extensible protocol elements. Implementations MUST discard frames that have unknown or unsupported types. This means that any of these extension points can be safely used by extensions without prior arrangement or negotiation. However, extension frames that appear in the middle of a field block (Section 4.3) are not permitted; these MUST be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、すべての拡張可能なプロトコル要素で不明な値またはサポートされていない値を無視する必要があります。実装は、不明またはサポートされていないタイプのフレームを破棄する必要があります。これは、これらの拡張ポイントのいずれかが、事前の取り決めや交渉なしに拡張機能によって安全に使用できることを意味します。ただし、フィールドブロック（セクション4.3）の中央に表示される拡張フレームは許可されていません。これらは、型protocol_errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Extensions SHOULD avoid changing protocol elements defined in this document or elements for which no extension mechanism is defined. This includes changes to the layout of frames, additions or changes to the way that frames are composed into HTTP messages (Section 8.1), the definition of pseudo-header fields, or changes to any protocol element that a compliant endpoint might treat as a connection error (Section 5.4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張機能は、このドキュメントまたは拡張メカニズムが定義されていない要素で定義されているプロトコル要素の変更を避ける必要があります。これには、フレームのレイアウトの変更、追加またはフレームがHTTPメッセージに構成されている方法（セクション8.1）、擬似ヘッダーフィールドの定義、または準拠したエンドポイントが接続として扱う可能性のあるプロトコル要素の変更が含まれます。エラー（セクション5.4.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An extension that changes existing protocol elements or state MUST be negotiated before being used. For example, an extension that changes the layout of the HEADERS frame cannot be used until the peer has given a positive signal that this is acceptable. In this case, it could also be necessary to coordinate when the revised layout comes into effect. For example, treating frames other than DATA frames as flow controlled requires a change in semantics that both endpoints need to understand, so this can only be done through negotiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
既存のプロトコル要素または状態を変更する拡張機能は、使用する前にネゴシエートする必要があります。たとえば、ヘッダーフレームのレイアウトを変更する拡張機能は、ピアがこれが許容できるという正の信号を与えるまで使用できません。この場合、改訂されたレイアウトが有効になったときに調整する必要もあります。たとえば、データフレーム以外のフレームをフロー制御として扱うには、両方のエンドポイントが理解する必要があるセマンティクスの変更が必要であるため、これは交渉によってのみ行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document doesn&#39;t mandate a specific method for negotiating the use of an extension but notes that a setting (Section 6.5.2) could be used for that purpose. If both peers set a value that indicates willingness to use the extension, then the extension can be used. If a setting is used for extension negotiation, the initial value MUST be defined in such a fashion that the extension is initially disabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、拡張機能の使用を交渉するための特定の方法を義務付けるものではありませんが、その目的のために設定（セクション6.5.2）を使用できることに注意してください。両方のピアが拡張機能を使用する意欲を示す値を設定する場合、拡張機能を使用できます。拡張交渉に設定が使用される場合、初期値は、拡張が最初に無効にされるような方法で定義する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Frame-Definitions">
6. Frame Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. フレーム定義
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification defines a number of frame types, each identified by a unique 8-bit type code. Each frame type serves a distinct purpose in the establishment and management of either the connection as a whole or individual streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様では、それぞれが一意の8ビットタイプコードで識別される多くのフレームタイプを定義します。各フレームタイプは、接続全体または個々のストリームの確立と管理において明確な目的を果たします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transmission of specific frame types can alter the state of a connection. If endpoints fail to maintain a synchronized view of the connection state, successful communication within the connection will no longer be possible. Therefore, it is important that endpoints have a shared comprehension of how the state is affected by the use of any given frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のフレームタイプの送信は、接続の状態を変更できます。エンドポイントが接続状態の同期ビューを維持できない場合、接続内での通信の成功は不可能になります。したがって、エンドポイントは、特定のフレームの使用によって状態がどのように影響を受けるかについて共有されることが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1--DATA">
6.1. DATA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. データ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DATA frames (type=0x00) convey arbitrary, variable-length sequences of octets associated with a stream. One or more DATA frames are used, for instance, to carry HTTP request or response message contents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データフレーム（Type = 0x00）は、ストリームに関連付けられたオクテットの任意の可変長シーケンスを伝えます。たとえば、1つ以上のデータフレームがHTTP要求または応答メッセージの内容を掲載するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DATA frames MAY also contain padding. Padding can be added to DATA frames to obscure the size of messages. Padding is a security feature; see Section 10.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データフレームにはパディングも含まれている場合があります。パディングをデータフレームに追加して、メッセージのサイズを不明瞭にすることができます。パディングはセキュリティ機能です。セクション10.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DATA Frame { Length (24), Type (8) = 0x00,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データフレーム{長さ（24）、タイプ（8）= 0x00、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Unused Flags (4), PADDED Flag (1), Unused Flags (2), END_STREAM Flag (1),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
未使用のフラグ（4）、パッド入りフラグ（1）、未使用フラグ（2）、end_streamフラグ（1）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Reserved (1), Stream Identifier (31),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
予約済み（1）、ストリーム識別子（31）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 [Pad Length (8)], Data (..), Padding (..2040), }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[パッド長（8）]、データ（..）、パディング（..2040）、}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
Figure 3: DATA Frame Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
図3：データフレーム形式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in Section 4. The DATA frame contains the following additional fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ、タイプ、未使用のフラグ、予約済み、およびストリーム識別子フィールドは、セクション4で説明されています。データフレームには、次の追加フィールドが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pad Length: An 8-bit field containing the length of the frame padding in units of octets. This field is conditional and is only present if the PADDED flag is set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パッドの長さ：オクテットのユニットにフレームパディングの長さを含む8ビットフィールド。このフィールドは条件付きであり、パッド入りフラグが設定されている場合にのみ存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data: Application data. The amount of data is the remainder of the frame payload after subtracting the length of the other fields that are present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ：アプリケーションデータ。データの量は、存在する他のフィールドの長さを差し引いた後のフレームペイロードの残りです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Padding: Padding octets that contain no application semantic value. Padding octets MUST be set to zero when sending. A receiver is not obligated to verify padding but MAY treat non-zero padding as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディング：アプリケーションセマンティック値を含むパディングオクテット。パディングオクテットは、送信中はゼロに設定する必要があります。受信機は、パディングを確認する義務はありませんが、ゼロ以外のパディングをタイプProtocol_Errorの接続エラー（セクション5.4.1）として扱うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DATA frame defines the following flags:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データフレームは次のフラグを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PADDED (0x08): When set, the PADDED flag indicates that the Pad Length field and any padding that it describes are present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PADDED（0x08）：設定すると、パッド付きフラグは、パッドの長さフィールドとそれが説明するパディングが存在することを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
END_STREAM (0x01): When set, the END_STREAM flag indicates that this frame is the last that the endpoint will send for the identified stream. Setting this flag causes the stream to enter one of the &#34;half-closed&#34; states or the &#34;closed&#34; state (Section 5.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
end_stream（0x01）：設定すると、end_streamフラグは、このフレームが識別されたストリームを送信する最後のフレームであることを示します。このフラグを設定すると、ストリームは「半分閉鎖された」状態の1つまたは「閉じた」状態（セクション5.1）に入ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
 Note: An endpoint that learns of stream closure after sending all data can close a stream by sending a STREAM frame with a zero-length Data field and the END_STREAM flag set. This is only possible if the endpoint does not send trailers, as the END_STREAM flag appears on a HEADERS frame in that case; see Section 8.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
注：すべてのデータを送信した後にストリーム閉鎖を学習するエンドポイントは、ゼロ長データフィールドとEND_STREAMフラグセットを備えたストリームフレームを送信することにより、ストリームを閉じることができます。これは、エンドポイントがトレーラーを送信しない場合にのみ可能です。その場合、End_streamフラグはヘッダーフレームに表示されます。セクション8.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DATA frames MUST be associated with a stream. If a DATA frame is received whose Stream Identifier field is 0x00, the recipient MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データフレームは、ストリームに関連付けられている必要があります。ストリーム識別子フィールドが0x00であるデータフレームが受信された場合、受信者は型Protocol_Errorの接続エラー（セクション5.4.1）で応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DATA frames are subject to flow control and can only be sent when a stream is in the &#34;open&#34; or &#34;half-closed (remote)&#34; state. The entire DATA frame payload is included in flow control, including the Pad Length and Padding fields if present. If a DATA frame is received whose stream is not in the &#34;open&#34; or &#34;half-closed (local)&#34; state, the recipient MUST respond with a stream error (Section 5.4.2) of type STREAM_CLOSED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データフレームはフロー制御の対象となり、ストリームが「オープン」または「半分閉鎖（リモート）」状態にある場合にのみ送信できます。データフレームのペイロード全体は、存在する場合はパッドの長さやパディングフィールドを含むフロー制御に含まれています。ストリームが「オープン」または「半分閉鎖（ローカル）」状態にないデータフレームが受信された場合、受信者はStream_Closedの型のストリームエラー（セクション5.4.2）で応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The total number of padding octets is determined by the value of the Pad Length field. If the length of the padding is the length of the frame payload or greater, the recipient MUST treat this as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディングオクテットの総数は、パッドの長さフィールドの値によって決まります。パディングの長さがフレームペイロード以下の長さである場合、受信者はこれをタイプProtocol_Errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
 Note: A frame can be increased in size by one octet by including a Pad Length field with a value of zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
注：ゼロの値を持つパッドの長さフィールドを含めることにより、フレームのサイズは1オクテットのサイズを増加させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2--HEADERS">
6.2. HEADERS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. ヘッダー
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HEADERS frame (type=0x01) is used to open a stream (Section 5.1), and additionally carries a field block fragment. Despite the name, a HEADERS frame can carry a header section or a trailer section. HEADERS frames can be sent on a stream in the &#34;idle&#34;, &#34;reserved (local)&#34;, &#34;open&#34;, or &#34;half-closed (remote)&#34; state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフレーム（Type = 0x01）は、ストリームを開くために使用され（セクション5.1）、さらにフィールドブロックフラグメントが搭載されています。名前にもかかわらず、ヘッダーフレームはヘッダーセクションまたはトレーラーセクションを搭載できます。ヘッダーフレームは、「アイドル」、「予約済み（ローカル）」、「オープン」、または「半分閉鎖（リモート）」状態のストリームで送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HEADERS Frame { Length (24), Type (8) = 0x01,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフレーム{長さ（24）、タイプ（8）= 0x01、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Unused Flags (2), PRIORITY Flag (1), Unused Flag (1), PADDED Flag (1), END_HEADERS Flag (1), Unused Flag (1), END_STREAM Flag (1),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
未使用フラグ（2）、優先フラグ（1）、未使用フラグ（1）、パッド入りフラグ（1）、end_headersフラグ（1）、未使用フラグ（1）、end_streamフラグ（1）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Reserved (1), Stream Identifier (31),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
予約済み（1）、ストリーム識別子（31）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     [Pad Length (8)],
     [Exclusive (1)],
     [Stream Dependency (31)],
     [Weight (8)],
     Field Block Fragment (..),
     Padding (..2040),
   }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
Figure 4: HEADERS Frame Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
図4：ヘッダーフレーム形式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in Section 4. The HEADERS frame payload has the following additional fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ、タイプ、未使用のフラグ、予約済み、およびストリーム識別子フィールドについては、セクション4で説明します。ヘッダーフレームペイロードには、次の追加フィールドがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pad Length: An 8-bit field containing the length of the frame padding in units of octets. This field is only present if the PADDED flag is set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パッドの長さ：オクテットのユニットにフレームパディングの長さを含む8ビットフィールド。このフィールドは、パッド入りフラグが設定されている場合にのみ存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Exclusive: A single-bit flag. This field is only present if the PRIORITY flag is set. Priority signals in HEADERS frames are deprecated; see Section 5.3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
排他的：単一ビットフラグ。このフィールドは、優先フラグが設定されている場合にのみ存在します。ヘッダーフレームの優先信号は非推奨です。セクション5.3.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stream Dependency: A 31-bit stream identifier. This field is only present if the PRIORITY flag is set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリーム依存関係：31ビットストリーム識別子。このフィールドは、優先フラグが設定されている場合にのみ存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Weight: An unsigned 8-bit integer. This field is only present if the PRIORITY flag is set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重量：署名されていない8ビット整数。このフィールドは、優先フラグが設定されている場合にのみ存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Field Block Fragment: A field block fragment (Section 4.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドブロックフラグメント：フィールドブロックフラグメント（セクション4.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Padding: Padding octets that contain no application semantic value. Padding octets MUST be set to zero when sending. A receiver is not obligated to verify padding but MAY treat non-zero padding as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディング：アプリケーションセマンティック値を含むパディングオクテット。パディングオクテットは、送信中はゼロに設定する必要があります。受信機は、パディングを確認する義務はありませんが、ゼロ以外のパディングをタイプProtocol_Errorの接続エラー（セクション5.4.1）として扱うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HEADERS frame defines the following flags:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフレームは次のフラグを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRIORITY (0x20): When set, the PRIORITY flag indicates that the Exclusive, Stream Dependency, and Weight fields are present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
優先度（0x20）：設定すると、優先フラグは、排他的、ストリーム依存関係、および重量フィールドが存在することを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PADDED (0x08): When set, the PADDED flag indicates that the Pad Length field and any padding that it describes are present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PADDED（0x08）：設定すると、パッド付きフラグは、パッドの長さフィールドとそれが説明するパディングが存在することを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
END_HEADERS (0x04): When set, the END_HEADERS flag indicates that this frame contains an entire field block (Section 4.3) and is not followed by any CONTINUATION frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
End_headers（0x04）：設定すると、End_headersフラグは、このフレームにフィールドブロック全体（セクション4.3）が含まれており、続いて継続フレームが続いていないことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A HEADERS frame without the END_HEADERS flag set MUST be followed by a CONTINUATION frame for the same stream. A receiver MUST treat the receipt of any other type of frame or a frame on a different stream as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
end_headersフラグが設定されていないヘッダーフレームの後に、同じストリームの継続フレームが続く必要があります。受信者は、タイプProtocol_Errorの接続エラー（セクション5.4.1）として、他のタイプのフレームまたはフレームの受信または異なるストリームのフレームの受領を処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
END_STREAM (0x01): When set, the END_STREAM flag indicates that the field block (Section 4.3) is the last that the endpoint will send for the identified stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
end_stream（0x01）：設定すると、end_streamフラグは、フィールドブロック（セクション4.3）が識別されたストリームのエンドポイントが送信する最後のものであることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A HEADERS frame with the END_STREAM flag set signals the end of a stream. However, a HEADERS frame with the END_STREAM flag set can be followed by CONTINUATION frames on the same stream. Logically, the CONTINUATION frames are part of the HEADERS frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
end_streamフラグセットを備えたヘッダーフレームは、ストリームの終わりを信号します。ただし、END_STREAMフラグセットを備えたヘッダーフレームの後に、同じストリームに継続フレームが続くことができます。論理的には、継続フレームはヘッダーフレームの一部です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The frame payload of a HEADERS frame contains a field block fragment (Section 4.3). A field block that does not fit within a HEADERS frame is continued in a CONTINUATION frame (Section 6.10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフレームのフレームペイロードには、フィールドブロックフラグメントが含まれています（セクション4.3）。ヘッダーフレーム内に収まらないフィールドブロックは、継続フレームで継続されます（セクション6.10）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HEADERS frames MUST be associated with a stream. If a HEADERS frame is received whose Stream Identifier field is 0x00, the recipient MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフレームは、ストリームに関連付けられている必要があります。ストリーム識別子フィールドが0x00であるヘッダーフレームが受信された場合、受信者は型Protocol_Errorの接続エラー（セクション5.4.1）で応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HEADERS frame changes the connection state as described in Section 4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフレームは、セクション4.3で説明されているように接続状態を変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The total number of padding octets is determined by the value of the Pad Length field. If the length of the padding is the length of the frame payload or greater, the recipient MUST treat this as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディングオクテットの総数は、パッドの長さフィールドの値によって決まります。パディングの長さがフレームペイロード以下の長さである場合、受信者はこれをタイプProtocol_Errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
 Note: A frame can be increased in size by one octet by including a Pad Length field with a value of zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
注：ゼロの値を持つパッドの長さフィールドを含めることにより、フレームのサイズは1オクテットのサイズを増加させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3--PRIORITY">
6.3. PRIORITY
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. 優先順位
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PRIORITY frame (type=0x02) is deprecated; see Section 5.3.2. A PRIORITY frame can be sent in any stream state, including idle or closed streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
優先フレーム（Type = 0x02）は非推奨です。セクション5.3.2を参照してください。IDLEまたは閉じたストリームを含む、任意のストリーム状態で優先フレームを送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRIORITY Frame { Length (24) = 0x05, Type (8) = 0x02,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
優先フレーム{長さ（24）= 0x05、タイプ（8）= 0x02、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Unused Flags (8),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
未使用のフラグ（8）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Reserved (1), Stream Identifier (31),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
予約済み（1）、ストリーム識別子（31）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Exclusive (1), Stream Dependency (31), Weight (8), }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
排他的（1）、ストリーム依存関係（31）、重量（8）、}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
Figure 5: PRIORITY Frame Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
図5：優先フレーム形式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in Section 4. The frame payload of a PRIORITY frame contains the following additional fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ、タイプ、未使用フラグ、予約済み、およびストリーム識別子フィールドについては、セクション4で説明します。優先フレームのフレームペイロードには、次の追加フィールドが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Exclusive: A single-bit flag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
排他的：単一ビットフラグ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stream Dependency: A 31-bit stream identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリーム依存関係：31ビットストリーム識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Weight: An unsigned 8-bit integer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重量：署名されていない8ビット整数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PRIORITY frame does not define any flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
優先フレームはフラグを定義しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PRIORITY frame always identifies a stream. If a PRIORITY frame is received with a stream identifier of 0x00, the recipient MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
優先フレームは常にストリームを識別します。0x00のストリーム識別子で優先フレームが受信された場合、受信者は型Protocol_Errorの接続エラー（セクション5.4.1）で応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sending or receiving a PRIORITY frame does not affect the state of any stream (Section 5.1). The PRIORITY frame can be sent on a stream in any state, including &#34;idle&#34; or &#34;closed&#34;. A PRIORITY frame cannot be sent between consecutive frames that comprise a single field block (Section 4.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
優先フレームを送信または受信しても、ストリームの状態には影響しません（セクション5.1）。優先フレームは、「アイドル」または「閉じた」など、どの州のストリームでも送信できます。優先フレームは、単一のフィールドブロックを構成する連続したフレーム間で送信することはできません（セクション4.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PRIORITY frame with a length other than 5 octets MUST be treated as a stream error (Section 5.4.2) of type FRAME_SIZE_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5オクテット以外の長さの優先フレームは、型frame_size_errorのストリームエラー（セクション5.4.2）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4--RSTSTREAM">
6.4. RST_STREAM
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. RST_STREAM
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RST_STREAM frame (type=0x03) allows for immediate termination of a stream. RST_STREAM is sent to request cancellation of a stream or to indicate that an error condition has occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RST_STREAMフレーム（Type = 0x03）により、ストリームの即時終了が可能になります。RST_STREAMは、ストリームのキャンセルを要求するか、エラー条件が発生したことを示すために送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RST_STREAM Frame { Length (24) = 0x04, Type (8) = 0x03,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rst_streamフレーム{length（24）= 0x04、type（8）= 0x03、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Unused Flags (8),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
未使用のフラグ（8）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Reserved (1), Stream Identifier (31),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
予約済み（1）、ストリーム識別子（31）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Error Code (32), }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラーコード（32）、}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
Figure 6: RST_STREAM Frame Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
図6：RST_STREAMフレーム形式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in Section 4. Additionally, the RST_STREAM frame contains a single unsigned, 32-bit integer identifying the error code (Section 7). The error code indicates why the stream is being terminated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ、タイプ、未使用のフラグ、予約済み、およびストリーム識別子フィールドは、セクション4で説明されています。さらに、RST_STREAMフレームには、エラーコードを識別する単一の署名されていない32ビット整数が含まれています（セクション7）。エラーコードは、ストリームが終了している理由を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RST_STREAM frame does not define any flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RST_STREAMフレームは、フラグを定義しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RST_STREAM frame fully terminates the referenced stream and causes it to enter the &#34;closed&#34; state. After receiving a RST_STREAM on a stream, the receiver MUST NOT send additional frames for that stream, except for PRIORITY. However, after sending the RST_STREAM, the sending endpoint MUST be prepared to receive and process additional frames sent on the stream that might have been sent by the peer prior to the arrival of the RST_STREAM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RST_STREAMフレームは、参照されるストリームを完全に終了し、「閉じた」状態に入ります。ストリームでRST_STREAMを受信した後、受信機は優先度を除いて、そのストリームに追加のフレームを送信してはなりません。ただし、RST_STREAMを送信した後、送信エンドポイントは、RST_STREAMが到着する前にピアによって送信された可能性のあるストリームに送信される追加のフレームを受信して処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RST_STREAM frames MUST be associated with a stream. If a RST_STREAM frame is received with a stream identifier of 0x00, the recipient MUST treat this as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RST_STREAMフレームは、ストリームに関連付けられている必要があります。RST_STREAMフレームが0x00のストリーム識別子で受信された場合、受信者はこれを型Protocol_Errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RST_STREAM frames MUST NOT be sent for a stream in the &#34;idle&#34; state. If a RST_STREAM frame identifying an idle stream is received, the recipient MUST treat this as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RST_STREAMフレームは、「アイドル」状態のストリームに送信してはなりません。アイドルストリームを識別するRST_STREAMフレームが受信された場合、受信者はこれをタイプProtocol_Errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A RST_STREAM frame with a length other than 4 octets MUST be treated as a connection error (Section 5.4.1) of type FRAME_SIZE_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4オクテット以外の長さのRST_STREAMフレームは、型frame_size_errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-5--SETTINGS">
6.5. SETTINGS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. 設定
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SETTINGS frame (type=0x04) conveys configuration parameters that affect how endpoints communicate, such as preferences and constraints on peer behavior. The SETTINGS frame is also used to acknowledge the receipt of those settings. Individually, a configuration parameter from a SETTINGS frame is referred to as a &#34;setting&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定フレーム（Type = 0x04）は、ピアの動作に対する好みや制約など、エンドポイントの通信方法に影響する構成パラメーターを伝えます。設定フレームは、それらの設定の受領を確認するためにも使用されます。個別に、設定フレームからの構成パラメーターは「設定」と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Settings are not negotiated; they describe characteristics of the sending peer, which are used by the receiving peer. Different values for the same setting can be advertised by each peer. For example, a client might set a high initial flow-control window, whereas a server might set a lower value to conserve resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定は交渉されません。彼らは、受信ピアによって使用される送信ピアの特性を説明しています。同じ設定の異なる値は、各ピアによって宣伝できます。たとえば、クライアントは高い初期フローコントロールウィンドウを設定する場合がありますが、サーバーはリソースを節約するために低い値を設定する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A SETTINGS frame MUST be sent by both endpoints at the start of a connection and MAY be sent at any other time by either endpoint over the lifetime of the connection. Implementations MUST support all of the settings defined by this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続の開始時に両方のエンドポイントによって設定フレームを送信する必要があり、接続の寿命にわたっていずれかのエンドポイントによって他の時間に送信できます。実装は、この仕様で定義されたすべての設定をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each parameter in a SETTINGS frame replaces any existing value for that parameter. Settings are processed in the order in which they appear, and a receiver of a SETTINGS frame does not need to maintain any state other than the current value of each setting. Therefore, the value of a SETTINGS parameter is the last value that is seen by a receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定フレーム内の各パラメーターは、そのパラメーターの既存の値を任意に置き換えます。設定は表示される順序で処理され、設定フレームの受信者は、各設定の現在の値以外の状態を維持する必要はありません。したがって、設定パラメーターの値は、受信機によって表示される最後の値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETTINGS frames are acknowledged by the receiving peer. To enable this, the SETTINGS frame defines the ACK flag:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定フレームは、受信ピアによって認められます。これを有効にするために、設定フレームはACKフラグを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACK (0x01): When set, the ACK flag indicates that this frame acknowledges receipt and application of the peer&#39;s SETTINGS frame. When this bit is set, the frame payload of the SETTINGS frame MUST be empty. Receipt of a SETTINGS frame with the ACK flag set and a length field value other than 0 MUST be treated as a connection error (Section 5.4.1) of type FRAME_SIZE_ERROR. For more information, see Section 6.5.3 (&#34;Settings Synchronization&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACK（0x01）：設定すると、ACKフラグは、このフレームがピアの設定フレームの領収書と適用を認めていることを示します。このビットが設定されている場合、設定フレームのフレームペイロードは空でなければなりません。ACKフラグセットを使用した設定フレームの受信および0以外の長さフィールド値は、型frame_size_errorの接続エラー（セクション5.4.1）として扱う必要があります。詳細については、セクション6.5.3（「設定同期」）を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETTINGS frames always apply to a connection, never a single stream. The stream identifier for a SETTINGS frame MUST be zero (0x00). If an endpoint receives a SETTINGS frame whose Stream Identifier field is anything other than 0x00, the endpoint MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定フレームは常に接続に適用され、単一のストリームではありません。設定フレームのストリーム識別子はゼロ（0x00）でなければなりません。エンドポイントが、ストリーム識別子フィールドが0x00以外のものである設定フレームを受信する場合、エンドポイントは型Protocol_Errorの接続エラー（セクション5.4.1）で応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SETTINGS frame affects connection state. A badly formed or incomplete SETTINGS frame MUST be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定フレームは接続状態に影響します。ひどく形成されたまたは不完全な設定フレームは、型protocol_errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A SETTINGS frame with a length other than a multiple of 6 octets MUST be treated as a connection error (Section 5.4.1) of type FRAME_SIZE_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6オクテットの倍数以外の長さの設定フレームは、型frame_size_errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-5-1--SETTINGS-Format">
6.5.1. SETTINGS Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1. 設定形式
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The frame payload of a SETTINGS frame consists of zero or more settings, each consisting of an unsigned 16-bit setting identifier and an unsigned 32-bit value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定フレームのフレームペイロードは、ゼロ以上の設定で構成され、それぞれが符号なしの16ビット設定識別子と符号なしの32ビット値で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETTINGS Frame { Length (24), Type (8) = 0x04,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定フレーム{長さ（24）、タイプ（8）= 0x04、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Unused Flags (7), ACK Flag (1),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
未使用のフラグ（7）、ackフラグ（1）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Reserved (1), Stream Identifier (31) = 0,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
予約済み（1）、ストリーム識別子（31）= 0、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Setting (48) ..., }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定（48）...、}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Setting {
     Identifier (16),
     Value (32),
   }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
Figure 7: SETTINGS Frame Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
図7：設定フレーム形式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in Section 4. The frame payload of a SETTINGS frame contains any number of Setting fields, each of which consists of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ、タイプ、未使用のフラグ、予約済み、およびストリーム識別子フィールドは、セクション4で説明されています。設定フレームのフレームペイロードには、任意の数の設定フィールドが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Identifier: A 16-bit setting identifier; see Section 6.5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
識別子：16ビット設定識別子。セクション6.5.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Value: A 32-bit value for the setting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値：設定の32ビット値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-5-2--Defined-Settings">
6.5.2. Defined Settings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.2. 定義された設定
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following settings are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の設定が定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETTINGS_HEADER_TABLE_SIZE (0x01): This setting allows the sender to inform the remote endpoint of the maximum size of the compression table used to decode field blocks, in units of octets. The encoder can select any size equal to or less than this value by using signaling specific to the compression format inside a field block (see [COMPRESSION]). The initial value is 4,096 octets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
settings_header_table_size（0x01）：この設定により、送信者は、オクテットの単位でフィールドブロックをデコードするために使用される圧縮テーブルの最大サイズのリモートエンドポイントを通知できます。エンコーダは、フィールドブロック内の圧縮形式に固有のシグナルを使用することにより、この値以下のサイズまたはそれ以下を選択できます（[圧縮]を参照）。初期値は4,096オクテットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETTINGS_ENABLE_PUSH (0x02): This setting can be used to enable or disable server push. A server MUST NOT send a PUSH_PROMISE frame if it receives this parameter set to a value of 0; see Section 8.4. A client that has both set this parameter to 0 and had it acknowledged MUST treat the receipt of a PUSH_PROMISE frame as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
settings_enable_push（0x02）：この設定は、サーバーのプッシュを有効または無効にするために使用できます。サーバーは、このパラメーターセットを0の値に受信した場合、Push_Promiseフレームを送信してはなりません。セクション8.4を参照してください。両方ともこのパラメーターを0に設定し、それを認めたクライアントは、Push_promiseフレームの受信をタイプprotocol_errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The initial value of SETTINGS_ENABLE_PUSH is 1. For a client, this value indicates that it is willing to receive PUSH_PROMISE frames. For a server, this initial value has no effect, and is equivalent to the value 0. Any value other than 0 or 1 MUST be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
settings_enable_pushの初期値は1です。クライアントの場合、この値はpush_promiseフレームを受け取る意思があることを示しています。サーバーの場合、この初期値には効果がなく、値0に相当します。0または1以外の値は、型プロトコル_Errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A server MUST NOT explicitly set this value to 1. A server MAY choose to omit this setting when it sends a SETTINGS frame, but if a server does include a value, it MUST be 0. A client MUST treat receipt of a SETTINGS frame with SETTINGS_ENABLE_PUSH set to 1 as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーはこの値を1に明示的に設定してはなりません。サーバーは、設定フレームを送信するときにこの設定を省略することを選択できますが、サーバーに値が含まれている場合は、クライアントが設定フレームの受信を扱う必要があります。settings_enable_pushタイプprotocol_errorの接続エラー（セクション5.4.1）として1に設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETTINGS_MAX_CONCURRENT_STREAMS (0x03): This setting indicates the maximum number of concurrent streams that the sender will allow. This limit is directional: it applies to the number of streams that the sender permits the receiver to create. Initially, there is no limit to this value. It is recommended that this value be no smaller than 100, so as to not unnecessarily limit parallelism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
settings_max_concurrent_streams（0x03）：この設定は、送信者が許可する並行ストリームの最大数を示します。この制限は方向性です。送信者が受信者が作成することを許可するストリームの数に適用されます。当初、この値に制限はありません。不必要に並列性を制限しないように、この値は100以下ではないことをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A value of 0 for SETTINGS_MAX_CONCURRENT_STREAMS SHOULD NOT be treated as special by endpoints. A zero value does prevent the creation of new streams; however, this can also happen for any limit that is exhausted with active streams. Servers SHOULD only set a zero value for short durations; if a server does not wish to accept requests, closing the connection is more appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
settings_max_concurrent_streamsの値は、エンドポイントによって特別なものとして扱われるべきではありません。ゼロ値は、新しいストリームの作成を防ぎます。ただし、これは、アクティブなストリームで使い果たされる制限に対しても発生する可能性があります。サーバーは、短期間でゼロ値のみを設定する必要があります。サーバーがリクエストを受け入れたくない場合、接続を閉じる方が適切です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETTINGS_INITIAL_WINDOW_SIZE (0x04): This setting indicates the sender&#39;s initial window size (in units of octets) for stream-level flow control. The initial value is 2^16-1 (65,535) octets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
settings_initial_window_size（0x04）：この設定は、ストリームレベルのフロー制御のための送信者の初期ウィンドウサイズ（オクテットの単位）を示しています。初期値は2^16-1（65,535）オクテットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This setting affects the window size of all streams (see Section 6.9.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この設定は、すべてのストリームのウィンドウサイズに影響します（セクション6.9.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Values above the maximum flow-control window size of 2^31-1 MUST be treated as a connection error (Section 5.4.1) of type FLOW_CONTROL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2^31-1の最大フローコントロールウィンドウサイズを上回る値は、Flow_Control_Errorのタイプの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETTINGS_MAX_FRAME_SIZE (0x05): This setting indicates the size of the largest frame payload that the sender is willing to receive, in units of octets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
settings_max_frame_size（0x05）：この設定は、オクテットの単位で、送信者が受け取る最大のフレームペイロードのサイズを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The initial value is 2^14 (16,384) octets. The value advertised by an endpoint MUST be between this initial value and the maximum allowed frame size (2^24-1 or 16,777,215 octets), inclusive. Values outside this range MUST be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
初期値は2^14（16,384）オクテットです。エンドポイントによって宣伝されている値は、この初期値と、許可された最大フレームサイズ（2^24-1または16,777,215オクテット）の間で、包括的でなければなりません。この範囲外の値は、型Protocol_Errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETTINGS_MAX_HEADER_LIST_SIZE (0x06): This advisory setting informs a peer of the maximum field section size that the sender is prepared to accept, in units of octets. The value is based on the uncompressed size of field lines, including the length of the name and value in units of octets plus an overhead of 32 octets for each field line.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
settings_max_header_list_size（0x06）：このアドバイザリー設定は、オクテットの単位で、送信者が受け入れる準備ができている最大フィールドセクションサイズをピアに通知します。値は、オクテットの単位の名前と値の長さと各フィールドラインの32オクテットのオーバーヘッドを含む、フィールドラインの非圧縮サイズに基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
For any given request, a lower limit than what is advertised MAY be enforced. The initial value of this setting is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
特定のリクエストでは、宣伝されているものよりも下限が強制される場合があります。この設定の初期値は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint that receives a SETTINGS frame with any unknown or unsupported identifier MUST ignore that setting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不明またはサポートされていない識別子を含む設定フレームを受信するエンドポイントは、その設定を無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-5-3--Settings-Synchronization">
6.5.3. Settings Synchronization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.3. 設定同期
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most values in SETTINGS benefit from or require an understanding of when the peer has received and applied the changed parameter values. In order to provide such synchronization timepoints, the recipient of a SETTINGS frame in which the ACK flag is not set MUST apply the updated settings as soon as possible upon receipt. SETTINGS frames are acknowledged in the order in which they are received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定のほとんどの値は、PEERが変更されたパラメーター値を受信して適用したことから利益を得るか、理解する必要があります。このような同期タイムポイントを提供するために、ACKフラグが設定されていない設定フレームの受信者は、受領時にできるだけ早く更新された設定を適用する必要があります。設定フレームは、受信した順序で確認されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The values in the SETTINGS frame MUST be processed in the order they appear, with no other frame processing between values. Unsupported settings MUST be ignored. Once all values have been processed, the recipient MUST immediately emit a SETTINGS frame with the ACK flag set. Upon receiving a SETTINGS frame with the ACK flag set, the sender of the altered settings can rely on the values from the oldest unacknowledged SETTINGS frame having been applied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定フレームの値は、表示される順序で処理する必要があり、値間のフレーム処理はありません。サポートされていない設定は無視する必要があります。すべての値が処理されると、受信者はACKフラグセットを使用してすぐに設定フレームを発する必要があります。ACKフラグセットを使用して設定フレームを受信すると、変更された設定の送信者は、適用された最古の非概要設定フレームの値に依存できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the sender of a SETTINGS frame does not receive an acknowledgment within a reasonable amount of time, it MAY issue a connection error (Section 5.4.1) of type SETTINGS_TIMEOUT. In setting a timeout, some allowance needs to be made for processing delays at the peer; a timeout that is solely based on the round-trip time between endpoints might result in spurious errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定フレームの送信者が妥当な時間内に確認を受け取らない場合、タイプSettings_Timeoutの接続エラー（セクション5.4.1）を発行する場合があります。タイムアウトを設定する際には、ピアでの遅延を処理するためにいくつかの手当を作成する必要があります。エンドポイント間の往復時間のみに基づいているタイムアウトは、スプリアスエラーにつながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-6--PUSHPROMISE">
6.6. PUSH_PROMISE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6. push_promise
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PUSH_PROMISE frame (type=0x05) is used to notify the peer endpoint in advance of streams the sender intends to initiate. The PUSH_PROMISE frame includes the unsigned 31-bit identifier of the stream the endpoint plans to create along with a field section that provides additional context for the stream. Section 8.4 contains a thorough description of the use of PUSH_PROMISE frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Push_Promiseフレーム（Type = 0x05）は、送信者が開始する予定のストリームの前にピアエンドポイントに通知するために使用されます。Push_Promiseフレームには、エンドポイントが作成するストリームの署名されていない31ビット識別子と、ストリームの追加コンテキストを提供するフィールドセクションを作成することが含まれます。セクション8.4には、Push_promiseフレームの使用に関する徹底的な説明が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUSH_PROMISE Frame { Length (24), Type (8) = 0x05,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
push_promiseフレーム{長さ（24）、タイプ（8）= 0x05、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Unused Flags (4), PADDED Flag (1), END_HEADERS Flag (1), Unused Flags (2),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
未使用のフラグ（4）、パッド入りフラグ（1）、end_headersフラグ（1）、未使用フラグ（2）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Reserved (1), Stream Identifier (31),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
予約済み（1）、ストリーム識別子（31）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 [Pad Length (8)], Reserved (1), Promised Stream ID (31), Field Block Fragment (..), Padding (..2040), }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[パッド長（8）]、予約済み（1）、約束のストリームID（31）、フィールドブロックフラグメント（..）、パディング（..2040）、}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
Figure 8: PUSH_PROMISE Frame Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
図8：Push_Promiseフレーム形式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in Section 4. The PUSH_PROMISE frame payload has the following additional fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ、タイプ、未使用のフラグ、予約済み、およびストリーム識別子フィールドについては、セクション4で説明します。Push_Promiseフレームペイロードには、次の追加フィールドがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pad Length: An 8-bit field containing the length of the frame padding in units of octets. This field is only present if the PADDED flag is set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パッドの長さ：オクテットのユニットにフレームパディングの長さを含む8ビットフィールド。このフィールドは、パッド入りフラグが設定されている場合にのみ存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Promised Stream ID: An unsigned 31-bit integer that identifies the stream that is reserved by the PUSH_PROMISE. The promised stream identifier MUST be a valid choice for the next stream sent by the sender (see &#34;new stream identifier&#34; in Section 5.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
約束されたストリームID：Push_promiseによって予約されているストリームを識別する署名されていない31ビット整数。約束されたストリーム識別子は、送信者から送信された次のストリームの有効な選択でなければなりません（セクション5.1.1の「新しいストリーム識別子」を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Field Block Fragment: A field block fragment (Section 4.3) containing the request control data and a header section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドブロックフラグメント：リクエスト制御データとヘッダーセクションを含むフィールドブロックフラグメント（セクション4.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Padding: Padding octets that contain no application semantic value. Padding octets MUST be set to zero when sending. A receiver is not obligated to verify padding but MAY treat non-zero padding as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディング：アプリケーションセマンティック値を含むパディングオクテット。パディングオクテットは、送信中はゼロに設定する必要があります。受信機は、パディングを確認する義務はありませんが、ゼロ以外のパディングをタイプProtocol_Errorの接続エラー（セクション5.4.1）として扱うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PUSH_PROMISE frame defines the following flags:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
push_promiseフレームは、次のフラグを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PADDED (0x08): When set, the PADDED flag indicates that the Pad Length field and any padding that it describes are present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PADDED（0x08）：設定すると、パッド付きフラグは、パッドの長さフィールドとそれが説明するパディングが存在することを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
END_HEADERS (0x04): When set, the END_HEADERS flag indicates that this frame contains an entire field block (Section 4.3) and is not followed by any CONTINUATION frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
End_headers（0x04）：設定すると、End_headersフラグは、このフレームにフィールドブロック全体（セクション4.3）が含まれており、続いて継続フレームが続いていないことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A PUSH_PROMISE frame without the END_HEADERS flag set MUST be followed by a CONTINUATION frame for the same stream. A receiver MUST treat the receipt of any other type of frame or a frame on a different stream as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
end_headersフラグを設定していないpush_promiseフレームには、同じストリームの継続フレームが続く必要があります。受信者は、タイプProtocol_Errorの接続エラー（セクション5.4.1）として、他のタイプのフレームまたはフレームの受信または異なるストリームのフレームの受領を処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUSH_PROMISE frames MUST only be sent on a peer-initiated stream that is in either the &#34;open&#34; or &#34;half-closed (remote)&#34; state. The stream identifier of a PUSH_PROMISE frame indicates the stream it is associated with. If the Stream Identifier field specifies the value 0x00, a recipient MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Push_Promiseフレームは、「オープン」または「半分閉鎖（リモート）」状態のいずれかにあるピア開始ストリームでのみ送信する必要があります。push_promiseフレームのストリーム識別子は、関連付けられているストリームを示します。ストリーム識別子フィールドが値0x00を指定する場合、受信者は型Protocol_Errorの接続エラー（セクション5.4.1）で応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Promised streams are not required to be used in the order they are promised. The PUSH_PROMISE only reserves stream identifiers for later use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
約束されたストリームは、約束されている順序で使用する必要はありません。Push_Promiseは、後で使用するためにストリーム識別子のみを留保します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUSH_PROMISE MUST NOT be sent if the SETTINGS_ENABLE_PUSH setting of the peer endpoint is set to 0. An endpoint that has set this setting and has received acknowledgment MUST treat the receipt of a PUSH_PROMISE frame as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Push_promiseは、ピアエンドポイントの設定設定設定が0に設定されている場合は送信しないでください。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recipients of PUSH_PROMISE frames can choose to reject promised streams by returning a RST_STREAM referencing the promised stream identifier back to the sender of the PUSH_PROMISE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Push_promiseフレームの受信者は、Push_promiseの送信者に約束されたストリーム識別子を参照するRST_STREAMを返すことにより、約束のストリームを拒否することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PUSH_PROMISE frame modifies the connection state in two ways. First, the inclusion of a field block (Section 4.3) potentially modifies the state maintained for field section compression. Second, PUSH_PROMISE also reserves a stream for later use, causing the promised stream to enter the &#34;reserved (local)&#34; or &#34;reserved (remote)&#34; state. A sender MUST NOT send a PUSH_PROMISE on a stream unless that stream is either &#34;open&#34; or &#34;half-closed (remote)&#34;; the sender MUST ensure that the promised stream is a valid choice for a new stream identifier (Section 5.1.1) (that is, the promised stream MUST be in the &#34;idle&#34; state).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
push_promiseフレームは、2つの方法で接続状態を変更します。まず、フィールドブロック（セクション4.3）を含めると、フィールドセクション圧縮のために維持されている状態を潜在的に変更します。第二に、Push_Promiseは後で使用するためのストリームも予約し、約束されたストリームが「予約済み（ローカル）」または「予約済み（リモート）」状態に入ります。送信者は、そのストリームが「開いている」または「半分閉じた（リモート）」のいずれかでない限り、ストリームにpush_promiseを送信してはなりません。送信者は、約束されたストリームが新しいストリーム識別子（セクション5.1.1）に対して有効な選択であることを確認する必要があります（つまり、約束されたストリームは「アイドル」状態でなければなりません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since PUSH_PROMISE reserves a stream, ignoring a PUSH_PROMISE frame causes the stream state to become indeterminate. A receiver MUST treat the receipt of a PUSH_PROMISE on a stream that is neither &#34;open&#34; nor &#34;half-closed (local)&#34; as a connection error (Section 5.4.1) of type PROTOCOL_ERROR. However, an endpoint that has sent RST_STREAM on the associated stream MUST handle PUSH_PROMISE frames that might have been created before the RST_STREAM frame is received and processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
push_promiseはストリームを留保するため、push_promiseフレームを無視すると、ストリーム状態が不確定になります。受信者は、タイプProtocol_Errorの接続エラー（セクション5.4.1）として「開いている」または「半分閉鎖（ローカル）」でもないストリームでPush_Promiseの受信を処理する必要があります。ただし、関連するストリームでRST_STREAMを送信したエンドポイントは、RST_STREAMフレームを受信および処理する前に作成された可能性のあるPush_Promiseフレームを処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiver MUST treat the receipt of a PUSH_PROMISE that promises an illegal stream identifier (Section 5.1.1) as a connection error (Section 5.4.1) of type PROTOCOL_ERROR. Note that an illegal stream identifier is an identifier for a stream that is not currently in the &#34;idle&#34; state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信者は、違法ストリーム識別子（セクション5.1.1）をタイプProtocol_Errorの接続エラー（セクション5.4.1）として約束するPush_promiseの受領を処理する必要があります。違法ストリーム識別子は、現在「アイドル」状態にないストリームの識別子であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The total number of padding octets is determined by the value of the Pad Length field. If the length of the padding is the length of the frame payload or greater, the recipient MUST treat this as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディングオクテットの総数は、パッドの長さフィールドの値によって決まります。パディングの長さがフレームペイロード以下の長さである場合、受信者はこれをタイプProtocol_Errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
 Note: A frame can be increased in size by one octet by including a Pad Length field with a value of zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
注：ゼロの値を持つパッドの長さフィールドを含めることにより、フレームのサイズは1オクテットのサイズを増加させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-7--PING">
6.7. PING
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7. ping
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PING frame (type=0x06) is a mechanism for measuring a minimal round-trip time from the sender, as well as determining whether an idle connection is still functional. PING frames can be sent from any endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pingフレーム（Type = 0x06）は、送信者からの最小限の往復時間を測定するメカニズムと、アイドル接続がまだ機能しているかどうかを判断するメカニズムです。Pingフレームは、任意のエンドポイントから送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PING Frame { Length (24) = 0x08, Type (8) = 0x06,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pingフレーム{長さ（24）= 0x08、タイプ（8）= 0x06、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Unused Flags (7), ACK Flag (1),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
未使用のフラグ（7）、ackフラグ（1）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Reserved (1), Stream Identifier (31) = 0,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
予約済み（1）、ストリーム識別子（31）= 0、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Opaque Data (64), }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不透明なデータ（64）、}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
Figure 9: PING Frame Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
図9：Pingフレーム形式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in Section 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ、タイプ、未使用のフラグ、予約済み、およびストリーム識別子フィールドについては、セクション4で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to the frame header, PING frames MUST contain 8 octets of opaque data in the frame payload. A sender can include any value it chooses and use those octets in any fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレームヘッダーに加えて、Pingフレームには、フレームペイロードに8オクターの不透明データを含める必要があります。送信者には、選択した任意の価値を含めることができ、それらのオクテットをあらゆる方法で使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Receivers of a PING frame that does not include an ACK flag MUST send a PING frame with the ACK flag set in response, with an identical frame payload. PING responses SHOULD be given higher priority than any other frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACKフラグが含まれていないPINGフレームの受信機は、同一のフレームペイロードを使用して、ACKフラグを応答して設定したPingフレームを送信する必要があります。ping応答は、他のどのフレームよりも優先度が高い場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PING frame defines the following flags:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pingフレームは次のフラグを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACK (0x01): When set, the ACK flag indicates that this PING frame is a PING response. An endpoint MUST set this flag in PING responses. An endpoint MUST NOT respond to PING frames containing this flag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACK（0x01）：設定すると、ACKフラグは、このpingフレームがping応答であることを示します。エンドポイントは、このフラグをping応答に設定する必要があります。エンドポイントは、このフラグを含むPingフレームに応答してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PING frames are not associated with any individual stream. If a PING frame is received with a Stream Identifier field value other than 0x00, the recipient MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pingフレームは、個々のストリームに関連付けられていません。Pingフレームが0x00以外のストリーム識別子フィールド値で受信された場合、受信者は型Protocol_Errorの接続エラー（セクション5.4.1）で応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Receipt of a PING frame with a length field value other than 8 MUST be treated as a connection error (Section 5.4.1) of type FRAME_SIZE_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8以外の長さフィールド値を持つPingフレームの受信は、型frame_size_errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-8--GOAWAY">
6.8. GOAWAY
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.8. どこかに行って
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The GOAWAY frame (type=0x07) is used to initiate shutdown of a connection or to signal serious error conditions. GOAWAY allows an endpoint to gracefully stop accepting new streams while still finishing processing of previously established streams. This enables administrative actions, like server maintenance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Goawayフレーム（Type = 0x07）を使用して、接続のシャットダウンを開始するか、深刻なエラー条件を通知します。Goawayにより、エンドポイントは、以前に確立されたストリームの処理を完了しながら、新しいストリームの受け入れを優雅に停止することができます。これにより、サーバーのメンテナンスなどの管理アクションが可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is an inherent race condition between an endpoint starting new streams and the remote peer sending a GOAWAY frame. To deal with this case, the GOAWAY contains the stream identifier of the last peer-initiated stream that was or might be processed on the sending endpoint in this connection. For instance, if the server sends a GOAWAY frame, the identified stream is the highest-numbered stream initiated by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいストリームを開始するエンドポイントと、Goawayフレームを送信するリモートピアの間には、固有の人種条件があります。このケースに対処するために、Goawayには、これに関連して送信エンドポイントで処理された、または処理される可能性のある最後のピア開始ストリームのストリーム識別子が含まれています。たとえば、サーバーがgoawayフレームを送信する場合、識別されたストリームは、クライアントによって開始された最高の数のストリームです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the GOAWAY is sent, the sender will ignore frames sent on streams initiated by the receiver if the stream has an identifier higher than the included last stream identifier. Receivers of a GOAWAY frame MUST NOT open additional streams on the connection, although a new connection can be established for new streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Goawayが送信されると、送信者は、ストリームに含まれる最終ストリーム識別子よりも高い識別子がある場合、受信機によって開始されたストリームで送信されるフレームを無視します。Goawayフレームの受信機は、新しいストリーム用に新しい接続を確立できますが、接続に追加のストリームを開くことはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the receiver of the GOAWAY has sent data on streams with a higher stream identifier than what is indicated in the GOAWAY frame, those streams are not or will not be processed. The receiver of the GOAWAY frame can treat the streams as though they had never been created at all, thereby allowing those streams to be retried later on a new connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Goawayの受信者が、Goawayフレームに示されているものよりも高いストリーム識別子を持つストリームのデータを送信した場合、それらのストリームは処理されないか、処理されません。Goawayフレームの受信機は、ストリームをまったく作成したことがないかのように扱うことができ、それにより、それらのストリームを後で新しい接続で再試行することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints SHOULD always send a GOAWAY frame before closing a connection so that the remote peer can know whether a stream has been partially processed or not. For example, if an HTTP client sends a POST at the same time that a server closes a connection, the client cannot know if the server started to process that POST request if the server does not send a GOAWAY frame to indicate what streams it might have acted on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、リモートピアがストリームが部分的に処理されているかどうかを知ることができるように、接続を閉じる前に常にgoawayフレームを送信する必要があります。たとえば、HTTPクライアントがサーバーが接続を閉じると同時に投稿を送信した場合、クライアントはサーバーがその要求を処理し始めたかどうかを知りません。行動した。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint might choose to close a connection without sending a GOAWAY for misbehaving peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、誤動作の仲間のためにgoawayを送信せずに接続を閉じることを選択する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A GOAWAY frame might not immediately precede closing of the connection; a receiver of a GOAWAY that has no more use for the connection SHOULD still send a GOAWAY frame before terminating the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続の閉鎖の直前にはないかもしれません。接続に使用しなくなったゲーウェイのレシーバーは、接続を終了する前に、goawayフレームを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GOAWAY Frame { Length (24), Type (8) = 0x07,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
goaway frame {length（24）、type（8）= 0x07、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Unused Flags (8),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
未使用のフラグ（8）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Reserved (1), Stream Identifier (31) = 0,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
予約済み（1）、ストリーム識別子（31）= 0、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Reserved (1), Last-Stream-ID (31), Error Code (32), Additional Debug Data (..), }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予約（1）、Last-Stream-ID（31）、エラーコード（32）、追加のデバッグデータ（..）、}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
Figure 10: GOAWAY Frame Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
図10：Goaway Frameフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in Section 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ、タイプ、未使用のフラグ、予約済み、およびストリーム識別子フィールドについては、セクション4で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The GOAWAY frame does not define any flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Goawayフレームはフラグを定義しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The GOAWAY frame applies to the connection, not a specific stream. An endpoint MUST treat a GOAWAY frame with a stream identifier other than 0x00 as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Goawayフレームは、特定のストリームではなく、接続に適用されます。エンドポイントは、タイプProtocol_Errorの接続エラー（セクション5.4.1）として、0x00以外のストリーム識別子を使用してGoawayフレームを処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The last stream identifier in the GOAWAY frame contains the highest-numbered stream identifier for which the sender of the GOAWAY frame might have taken some action on or might yet take action on. All streams up to and including the identified stream might have been processed in some way. The last stream identifier can be set to 0 if no streams were processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Goawayフレームの最後のストリーム識別子には、Goawayフレームの送信者が何らかのアクションを実行したか、まだ行動を起こしている可能性がある、最高の数のストリーム識別子が含まれています。特定されたストリームを含むすべてのストリームは、何らかの方法で処理されている可能性があります。ストリームが処理されていない場合、最後のストリーム識別子は0に設定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
 Note: In this context, &#34;processed&#34; means that some data from the stream was passed to some higher layer of software that might have taken some action as a result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
注：このコンテキストでは、「処理済み」とは、ストリームからの一部のデータが、結果として何らかのアクションをとった可能性のあるソフトウェアのより高い層に渡されたことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a connection terminates without a GOAWAY frame, the last stream identifier is effectively the highest possible stream identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続がGoAwayフレームなしで終了する場合、最後のストリーム識別子は事実上、可能な限り最高のストリーム識別子です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On streams with lower- or equal-numbered identifiers that were not closed completely prior to the connection being closed, reattempting requests, transactions, or any protocol activity is not possible, except for idempotent actions like HTTP GET, PUT, or DELETE. Any protocol activity that uses higher-numbered streams can be safely retried using a new connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続が閉じられる前に完全に閉じられていない低いまたは等しい識別子を持つストリームでは、HTTP GET、PUT、または削除などの等身アクションを除き、リクエスト、トランザクション、またはプロトコルアクティビティを再試行することは不可能です。より多くのストリームを使用するプロトコルアクティビティは、新しい接続を使用して安全に再試行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Activity on streams numbered lower than or equal to the last stream identifier might still complete successfully. The sender of a GOAWAY frame might gracefully shut down a connection by sending a GOAWAY frame, maintaining the connection in an &#34;open&#34; state until all in-progress streams complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後のストリーム識別子以下の数字以下のストリームでのアクティビティは、まだ正常に完了する可能性があります。Goawayフレームの送信者は、Goawayフレームを送信することにより、接続を優雅にシャットダウンし、すべての進行中のストリームが完了するまで「開いた」状態で接続を維持することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint MAY send multiple GOAWAY frames if circumstances change. For instance, an endpoint that sends GOAWAY with NO_ERROR during graceful shutdown could subsequently encounter a condition that requires immediate termination of the connection. The last stream identifier from the last GOAWAY frame received indicates which streams could have been acted upon. Endpoints MUST NOT increase the value they send in the last stream identifier, since the peers might already have retried unprocessed requests on another connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、状況が変化した場合に複数のゲーウェイフレームを送信する場合があります。たとえば、優雅なシャットダウン中にNO_ERRORでGoAwayを送信するエンドポイントは、その後、接続の即時終了を必要とする条件に遭遇する可能性があります。受信した最後のGoawayフレームからの最後のストリーム識別子は、どのストリームが動作したかを示します。エンドポイントは、ピアがすでに別の接続で未処理のリクエストを再試行している可能性があるため、最後のストリーム識別子に送信される値を増やしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client that is unable to retry requests loses all requests that are in flight when the server closes the connection. This is especially true for intermediaries that might not be serving clients using HTTP/2. A server that is attempting to gracefully shut down a connection SHOULD send an initial GOAWAY frame with the last stream identifier set to 2^31-1 and a NO_ERROR code. This signals to the client that a shutdown is imminent and that initiating further requests is prohibited. After allowing time for any in-flight stream creation (at least one round-trip time), the server MAY send another GOAWAY frame with an updated last stream identifier. This ensures that a connection can be cleanly shut down without losing requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストを再試行できないクライアントは、サーバーが接続を閉じるときに飛行中のすべての要求を失います。これは、HTTP/2を使用してクライアントにサービスを提供していない仲介者に特に当てはまります。接続を優雅にシャットダウンしようとしているサーバーは、最後のストリーム識別子が2^31-1に設定された最初のGoAwayフレームとNO_ERRORコードを送信する必要があります。これは、クライアントにシャットダウンが差し迫っており、さらなるリクエストを開始することが禁止されていることを示しています。飛行中のストリーム作成の時間を許可した後（少なくとも1回の往復時間）、サーバーは更新された最後のストリーム識別子を備えた別のGOAWAYフレームを送信する場合があります。これにより、リクエストを失うことなく接続をきれいにシャットダウンできるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After sending a GOAWAY frame, the sender can discard frames for streams initiated by the receiver with identifiers higher than the identified last stream. However, any frames that alter connection state cannot be completely ignored. For instance, HEADERS, PUSH_PROMISE, and CONTINUATION frames MUST be minimally processed to ensure that the state maintained for field section compression is consistent (see Section 4.3); similarly, DATA frames MUST be counted toward the connection flow-control window. Failure to process these frames can cause flow control or field section compression state to become unsynchronized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Goawayフレームを送信した後、送信者は、識別された最後のストリームよりも高い識別子を持つレシーバーによって開始されたストリームのフレームを破棄できます。ただし、接続状態を変更するフレームは完全に無視できません。たとえば、ヘッダー、Push_Promise、および継続フレームを最小限に処理して、フィールドセクションの圧縮のために維持されている状態が一貫していることを確認する必要があります（セクション4.3を参照）。同様に、データフレームは接続フロー制御ウィンドウにカウントする必要があります。これらのフレームの処理に失敗すると、フロー制御またはフィールドセクションの圧縮状態が無効化される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The GOAWAY frame also contains a 32-bit error code (Section 7) that contains the reason for closing the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Goawayフレームには、接続を閉じる理由を含む32ビットエラーコード（セクション7）も含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints MAY append opaque data to the frame payload of any GOAWAY frame. Additional debug data is intended for diagnostic purposes only and carries no semantic value. Debug information could contain security- or privacy-sensitive data. Logged or otherwise persistently stored debug data MUST have adequate safeguards to prevent unauthorized access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、goawayフレームのフレームペイロードに不透明なデータを追加する場合があります。追加のデバッグデータは、診断目的のみを目的としており、セマンティック値はありません。デバッグ情報には、セキュリティまたはプライバシーに敏感なデータが含まれる場合があります。不正アクセスを防ぐために、記録されたデバッグデータには、適切な保護手段が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-9--WINDOWUPDATE">
6.9. WINDOW_UPDATE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.9. window_update
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WINDOW_UPDATE frame (type=0x08) is used to implement flow control; see Section 5.2 for an overview.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
window_updateフレーム（type = 0x08）は、フロー制御を実装するために使用されます。概要については、セクション5.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow control operates at two levels: on each individual stream and on the entire connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー制御は、個々のストリームと接続全体の2つのレベルで動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both types of flow control are hop by hop, that is, only between the two endpoints. Intermediaries do not forward WINDOW_UPDATE frames between dependent connections. However, throttling of data transfer by any receiver can indirectly cause the propagation of flow-control information toward the original sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
両方のタイプのフロー制御は、ホップによるホップです。つまり、2つのエンドポイント間のみです。仲介者は、window_updateフレームを従属接続間で転送しません。ただし、レシーバーによるデータ転送のスロットリングは、元の送信者に対するフローコントロール情報の伝播を間接的に引き起こす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow control only applies to frames that are identified as being subject to flow control. Of the frame types defined in this document, this includes only DATA frames. Frames that are exempt from flow control MUST be accepted and processed, unless the receiver is unable to assign resources to handling the frame. A receiver MAY respond with a stream error (Section 5.4.2) or connection error (Section 5.4.1) of type FLOW_CONTROL_ERROR if it is unable to accept a frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー制御は、フロー制御の対象となると識別されるフレームにのみ適用されます。このドキュメントで定義されているフレームタイプのうち、これにはデータフレームのみが含まれます。レシーバーがフレームの処理にリソースを割り当てることができない場合を除き、フロー制御を免除されるフロー制御を受け入れて処理する必要があります。受信機は、フレームを受け入れられない場合は、flow_control_errorタイプのストリームエラー（セクション5.4.2）または接続エラー（セクション5.4.1）で応答できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WINDOW_UPDATE Frame { Length (24) = 0x04, Type (8) = 0x08,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
window_updateフレーム{長さ（24）= 0x04、type（8）= 0x08、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Unused Flags (8),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
未使用のフラグ（8）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Reserved (1), Stream Identifier (31),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
予約済み（1）、ストリーム識別子（31）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Reserved (1), Window Size Increment (31), }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予約済み（1）、ウィンドウサイズの増分（31）、}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
Figure 11: WINDOW_UPDATE Frame Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
図11：window_updateフレーム形式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in Section 4. The frame payload of a WINDOW_UPDATE frame is one reserved bit plus an unsigned 31-bit integer indicating the number of octets that the sender can transmit in addition to the existing flow-control window. The legal range for the increment to the flow-control window is 1 to 2^31-1 (2,147,483,647) octets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ、タイプ、未使用のフラグ、予約済み、およびストリーム識別子フィールドは、セクション4で説明されています。Window_Updateフレームのフレームペイロードは、予約されたビットに加えて、送信者ができるオクテットの数を示す署名されていない31ビット整数です。既存のフロー制御ウィンドウに加えて送信します。フローコントロールウィンドウへの増分の法的範囲は、1〜2^31-1（2,147,483,647）オクテットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WINDOW_UPDATE frame does not define any flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
window_updateフレームはフラグを定義しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WINDOW_UPDATE frame can be specific to a stream or to the entire connection. In the former case, the frame&#39;s stream identifier indicates the affected stream; in the latter, the value &#34;0&#34; indicates that the entire connection is the subject of the frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
window_updateフレームは、ストリームまたは接続全体に固有のものです。前者の場合、フレームのストリーム識別子は、影響を受けるストリームを示します。後者では、値「0」は、接続全体がフレームの主題であることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiver MUST treat the receipt of a WINDOW_UPDATE frame with a flow-control window increment of 0 as a stream error (Section 5.4.2) of type PROTOCOL_ERROR; errors on the connection flow-control window MUST be treated as a connection error (Section 5.4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信者は、型doctocol_errorのストリームエラー（セクション5.4.2）として、フローコントロールウィンドウの増分を0のwindow_updateフレームの受信を処理する必要があります。接続フローコントロールウィンドウのエラーは、接続エラーとして扱う必要があります（セクション5.4.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WINDOW_UPDATE can be sent by a peer that has sent a frame with the END_STREAM flag set. This means that a receiver could receive a WINDOW_UPDATE frame on a stream in a &#34;half-closed (remote)&#34; or &#34;closed&#34; state. A receiver MUST NOT treat this as an error (see Section 5.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
window_updateは、end_streamフラグセットでフレームを送信したピアによって送信できます。これは、レシーバーが「半分閉鎖された（リモート）」または「閉じた」状態のストリーム上のwindow_updateフレームを受信できることを意味します。レシーバーはこれをエラーとして扱ってはなりません（セクション5.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiver that receives a flow-controlled frame MUST always account for its contribution against the connection flow-control window, unless the receiver treats this as a connection error (Section 5.4.1). This is necessary even if the frame is in error. The sender counts the frame toward the flow-control window, but if the receiver does not, the flow-control window at the sender and receiver can become different.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー制御されたフレームを受信するレシーバーは、受信機がこれを接続エラーとして扱わない限り、接続フローコントロールウィンドウに対する寄与を常に説明する必要があります（セクション5.4.1）。フレームが誤っている場合でも、これが必要です。送信者はフレームをフローコントロールウィンドウにカウントしますが、受信機がそうでない場合、送信者とレシーバーのフローコントロールウィンドウが異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A WINDOW_UPDATE frame with a length other than 4 octets MUST be treated as a connection error (Section 5.4.1) of type FRAME_SIZE_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4オクテット以外の長さのwindow_updateフレームは、型frame_size_errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-9-1--The-Flow-Control-Window">
6.9.1. The Flow-Control Window
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.9.1. フロー制御ウィンドウ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow control in HTTP/2 is implemented using a window kept by each sender on every stream. The flow-control window is a simple integer value that indicates how many octets of data the sender is permitted to transmit; as such, its size is a measure of the buffering capacity of the receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2のフロー制御は、すべてのストリームに各送信者が保持しているウィンドウを使用して実装されます。フローコントロールウィンドウは、送信者が送信することが許可されているデータのオクテットの数を示す単純な整数値です。そのため、そのサイズはレシーバーのバッファリング容量の尺度です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two flow-control windows are applicable: the stream flow-control window and the connection flow-control window. The sender MUST NOT send a flow-controlled frame with a length that exceeds the space available in either of the flow-control windows advertised by the receiver. Frames with zero length with the END_STREAM flag set (that is, an empty DATA frame) MAY be sent if there is no available space in either flow-control window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのフローコントロールウィンドウが適用されます。ストリームフロー制御ウィンドウと接続フローコントロールウィンドウです。送信者は、レシーバーが宣伝するフロー制御ウィンドウのいずれかで利用可能なスペースを超える長さのフロー制御フレームを送信してはなりません。end_streamフラグセット（つまり、空のデータフレーム）を使用してゼロの長さのフレームは、どちらのフローコントロールウィンドウに利用可能なスペースがない場合に送信される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For flow-control calculations, the 9-octet frame header is not counted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローコントロール計算では、9-OCTETフレームヘッダーはカウントされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After sending a flow-controlled frame, the sender reduces the space available in both windows by the length of the transmitted frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー制御されたフレームを送信した後、送信者は、送信されたフレームの長さによって両方のウィンドウで使用可能なスペースを縮小します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receiver of a frame sends a WINDOW_UPDATE frame as it consumes data and frees up space in flow-control windows. Separate WINDOW_UPDATE frames are sent for the stream- and connection-level flow-control windows. Receivers are advised to have mechanisms in place to avoid sending WINDOW_UPDATE frames with very small increments; see Section 4.2.3.3 of [RFC1122].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレームの受信機は、データを消費し、フロー制御ウィンドウでスペースを解放するため、window_updateフレームを送信します。StreamおよびConnection-Level Flow-Control Windowsには、個別のWindow_Updateフレームが送信されます。受信機は、非常に少ない刻みでWindow_Updateフレームを送信しないようにメカニズムを整えることをお勧めします。[RFC1122]のセクション4.2.3.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender that receives a WINDOW_UPDATE frame updates the corresponding window by the amount specified in the frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
window_updateフレームを受信する送信者は、フレームで指定された量で対応するウィンドウを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender MUST NOT allow a flow-control window to exceed 2^31-1 octets. If a sender receives a WINDOW_UPDATE that causes a flow-control window to exceed this maximum, it MUST terminate either the stream or the connection, as appropriate. For streams, the sender sends a RST_STREAM with an error code of FLOW_CONTROL_ERROR; for the connection, a GOAWAY frame with an error code of FLOW_CONTROL_ERROR is sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は、フローコントロールウィンドウを2^31-1オクテットを超えることを許可してはなりません。送信者がこの最大値を超えるwindow_updateを受信した場合、必要に応じて、ストリームまたは接続を終了する必要があります。ストリームの場合、送信者はRST_STREAMにflow_control_errorのエラーコードを送信します。接続の場合、flow_control_errorのエラーコードを備えたgoawayフレームが送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow-controlled frames from the sender and WINDOW_UPDATE frames from the receiver are completely asynchronous with respect to each other. This property allows a receiver to aggressively update the window size kept by the sender to prevent streams from stalling.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者からのフロー制御フレームとレシーバーからのwindow_updateフレームは、互いに完全に非同期です。このプロパティを使用すると、レシーバーは、送信者が保持しているウィンドウサイズを積極的に更新して、ストリームが失速するのを防ぎます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-9-2--Initial-Flow-Control-Window-Size">
6.9.2. Initial Flow-Control Window Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.9.2. 初期フローコントロールウィンドウサイズ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an HTTP/2 connection is first established, new streams are created with an initial flow-control window size of 65,535 octets. The connection flow-control window is also 65,535 octets. Both endpoints can adjust the initial window size for new streams by including a value for SETTINGS_INITIAL_WINDOW_SIZE in the SETTINGS frame. The connection flow-control window can only be changed using WINDOW_UPDATE frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2接続が最初に確立されると、65,535オクテットの初期フローコントロールウィンドウサイズで新しいストリームが作成されます。接続フローコントロールウィンドウも65,535オクテットです。両方のエンドポイントは、設定フレームにsettings_initial_window_sizeの値を含めることにより、新しいストリームの初期ウィンドウサイズを調整できます。接続フローコントロールウィンドウは、window_updateフレームを使用してのみ変更できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Prior to receiving a SETTINGS frame that sets a value for SETTINGS_INITIAL_WINDOW_SIZE, an endpoint can only use the default initial window size when sending flow-controlled frames. Similarly, the connection flow-control window is set based on the default initial window size until a WINDOW_UPDATE frame is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
settings_initial_window_sizeの値を設定する設定フレームを受信する前に、エンドポイントは、フロー制御フレームを送信するときにデフォルトの初期ウィンドウサイズを使用することができます。同様に、接続フローコントロールウィンドウは、Window_Updateフレームが受信されるまで、デフォルトの初期ウィンドウサイズに基づいて設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to changing the flow-control window for streams that are not yet active, a SETTINGS frame can alter the initial flow-control window size for streams with active flow-control windows (that is, streams in the &#34;open&#34; or &#34;half-closed (remote)&#34; state). When the value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the size of all stream flow-control windows that it maintains by the difference between the new value and the old value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まだアクティブではないストリームのフローコントロールウィンドウを変更することに加えて、設定フレームは、アクティブフローコントロールウィンドウ（つまり、「オープン」または「半分」のストリームのストリームの初期フローコントロールウィンドウサイズを変更できます。-closed（remote） &#34;state）。settings_initial_window_sizeの値が変更された場合、レシーバーは、新しい値と古い値の違いによって維持されるすべてのストリームフローコントロールウィンドウのサイズを調整する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A change to SETTINGS_INITIAL_WINDOW_SIZE can cause the available space in a flow-control window to become negative. A sender MUST track the negative flow-control window and MUST NOT send new flow-controlled frames until it receives WINDOW_UPDATE frames that cause the flow-control window to become positive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
settings_initial_window_sizeの変更により、フローコントロールウィンドウ内の使用可能なスペースがネガティブになる可能性があります。送信者は、負のフローコントロールウィンドウを追跡する必要があり、フローコントロールウィンドウが正確になるwindow_updateフレームを受信するまで、新しいフロー制御フレームを送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, if the client sends 60 KB immediately on connection establishment and the server sets the initial window size to be 16 KB, the client will recalculate the available flow-control window to be -44 KB on receipt of the SETTINGS frame. The client retains a negative flow-control window until WINDOW_UPDATE frames restore the window to being positive, after which the client can resume sending.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、クライアントが接続確立ですぐに60 kBを送信し、サーバーが初期ウィンドウサイズを16 kBに設定する場合、クライアントは、設定フレームを受け取ったときに使用可能なフローコントロールウィンドウを-44 kbに再計算します。クライアントは、window_updateフレームがウィンドウを復元するまでネガティブフローコントロールウィンドウを保持します。その後、クライアントは送信を再開できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A SETTINGS frame cannot alter the connection flow-control window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定フレームでは、接続フローコントロールウィンドウを変更できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint MUST treat a change to SETTINGS_INITIAL_WINDOW_SIZE that causes any flow-control window to exceed the maximum size as a connection error (Section 5.4.1) of type FLOW_CONTROL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、flow_control_errorのタイプの接続エラー（セクション5.4.1）としてフローコントロールウィンドウを超えるsettings_initial_window_sizeの変更を扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-9-3--Reducing-the-Stream-Window-Size">
6.9.3. Reducing the Stream Window Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.9.3. ストリームウィンドウサイズの縮小
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiver that wishes to use a smaller flow-control window than the current size can send a new SETTINGS frame. However, the receiver MUST be prepared to receive data that exceeds this window size, since the sender might send data that exceeds the lower limit prior to processing the SETTINGS frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のサイズよりも小さなフローコントロールウィンドウを使用したいレシーバーは、新しい設定フレームを送信できます。ただし、送信者は設定フレームを処理する前に下限を超えるデータを送信する可能性があるため、受信者はこのウィンドウサイズを超えるデータを受信する準備をする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After sending a SETTINGS frame that reduces the initial flow-control window size, a receiver MAY continue to process streams that exceed flow-control limits. Allowing streams to continue does not allow the receiver to immediately reduce the space it reserves for flow-control windows. Progress on these streams can also stall, since WINDOW_UPDATE frames are needed to allow the sender to resume sending. The receiver MAY instead send a RST_STREAM with an error code of FLOW_CONTROL_ERROR for the affected streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期のフローコントロールウィンドウサイズを縮小する設定フレームを送信した後、受信機はフローコントロール制限を超えるストリームを処理し続けることができます。ストリームが継続できるようにしても、レシーバーがフローコントロールウィンドウ用のスペースをすぐに削減できません。送信者が送信を再開できるようにするには、window_updateフレームが必要であるため、これらのストリームの進行も失速する可能性があります。代わりに、受信者は、影響を受けるストリームのflow_control_errorのエラーコードを備えたRST_STREAMを送信する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-10--CONTINUATION">
6.10. CONTINUATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.10. 継続
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CONTINUATION frame (type=0x09) is used to continue a sequence of field block fragments (Section 4.3). Any number of CONTINUATION frames can be sent, as long as the preceding frame is on the same stream and is a HEADERS, PUSH_PROMISE, or CONTINUATION frame without the END_HEADERS flag set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
継続フレーム（Type = 0x09）は、フィールドブロックフラグメントのシーケンスを続行するために使用されます（セクション4.3）。前のフレームが同じストリーム上にあり、end_headersフラグが設定されていないヘッダー、push_promise、または継続フレームである限り、任意の数の継続フレームを送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONTINUATION Frame { Length (24), Type (8) = 0x09,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
継続フレーム{長さ（24）、タイプ（8）= 0x09、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Unused Flags (5), END_HEADERS Flag (1), Unused Flags (2),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
未使用フラグ（5）、end_headersフラグ（1）、未使用フラグ（2）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Reserved (1), Stream Identifier (31),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
予約済み（1）、ストリーム識別子（31）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Field Block Fragment (..), }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドブロックフラグメント（..）、}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
Figure 12: CONTINUATION Frame Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
図12：継続フレーム形式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Length, Type, Unused Flag(s), Reserved, and Stream Identifier fields are described in Section 4. The CONTINUATION frame payload contains a field block fragment (Section 4.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ、タイプ、未使用フラグ、予約済み、およびストリーム識別子フィールドは、セクション4で説明されています。継続フレームペイロードには、フィールドブロックフラグメントが含まれています（セクション4.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CONTINUATION frame defines the following flag:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
継続フレームは、次のフラグを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
END_HEADERS (0x04): When set, the END_HEADERS flag indicates that this frame ends a field block (Section 4.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
End_headers（0x04）：設定すると、End_headersフラグは、このフレームがフィールドブロックで終了することを示します（セクション4.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the END_HEADERS flag is not set, this frame MUST be followed by another CONTINUATION frame. A receiver MUST treat the receipt of any other type of frame or a frame on a different stream as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
end_headersフラグが設定されていない場合、このフレームの後に別の継続フレームが続く必要があります。受信者は、タイプProtocol_Errorの接続エラー（セクション5.4.1）として、他のタイプのフレームまたはフレームの受信または異なるストリームのフレームの受領を処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CONTINUATION frame changes the connection state as defined in Section 4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
継続フレームは、セクション4.3で定義されているように接続状態を変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONTINUATION frames MUST be associated with a stream. If a CONTINUATION frame is received with a Stream Identifier field of 0x00, the recipient MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
継続フレームは、ストリームに関連付けられている必要があります。0x00のストリーム識別子フィールドで継続フレームが受信された場合、受信者は型Protocol_Errorの接続エラー（セクション5.4.1）で応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A CONTINUATION frame MUST be preceded by a HEADERS, PUSH_PROMISE or CONTINUATION frame without the END_HEADERS flag set. A recipient that observes violation of this rule MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
継続フレームの前には、end_headersフラグが設定されていないヘッダー、push_promise、または継続フレームが必要です。このルールの違反を観察する受信者は、型protocol_errorの接続エラー（セクション5.4.1）で応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Error-Codes">
7. Error Codes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. エラーコード
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error codes are 32-bit fields that are used in RST_STREAM and GOAWAY frames to convey the reasons for the stream or connection error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラーコードは、ストリームまたは接続エラーの理由を伝えるためにRST_STREAMおよびGOAWAYフレームで使用される32ビットフィールドです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error codes share a common code space. Some error codes apply only to either streams or the entire connection and have no defined semantics in the other context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラーコードは共通のコード空間を共有します。一部のエラーコードは、ストリームまたは接続全体のいずれかにのみ適用され、他のコンテキストでは定義されたセマンティクスがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following error codes are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のエラーコードが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NO_ERROR (0x00): The associated condition is not a result of an error. For example, a GOAWAY might include this code to indicate graceful shutdown of a connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NO_ERROR（0x00）：関連する条件はエラーの結果ではありません。たとえば、接続の優雅なシャットダウンを示すために、このコードが含まれる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PROTOCOL_ERROR (0x01): The endpoint detected an unspecific protocol error. This error is for use when a more specific error code is not available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Protocol_Error（0x01）：エンドポイントは非特異的なプロトコルエラーを検出しました。このエラーは、より具体的なエラーコードが利用できない場合に使用するためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
INTERNAL_ERROR (0x02): The endpoint encountered an unexpected internal error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
internal_error（0x02）：エンドポイントに予期しない内部エラーが発生しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FLOW_CONTROL_ERROR (0x03): The endpoint detected that its peer violated the flow-control protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flow_control_error（0x03）：エンドポイントは、そのピアがフローコントロールプロトコルに違反したことを検出しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETTINGS_TIMEOUT (0x04): The endpoint sent a SETTINGS frame but did not receive a response in a timely manner. See Section 6.5.3 (&#34;Settings Synchronization&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
settings_timeout（0x04）：エンドポイントは設定フレームを送信しましたが、タイムリーな方法で応答を受け取りませんでした。セクション6.5.3（ &#34;設定同期&#34;）を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STREAM_CLOSED (0x05): The endpoint received a frame after a stream was half-closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stream_Closed（0x05）：エンドポイントは、ストリームが半分閉じられた後にフレームを受け取りました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FRAME_SIZE_ERROR (0x06): The endpoint received a frame with an invalid size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
frame_size_error（0x06）：エンドポイントは、無効なサイズのフレームを受け取りました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REFUSED_STREAM (0x07): The endpoint refused the stream prior to performing any application processing (see Section 8.7 for details).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Refused_stream（0x07）：エンドポイントは、アプリケーション処理を実行する前にストリームを拒否しました（詳細についてはセクション8.7を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CANCEL (0x08): The endpoint uses this error code to indicate that the stream is no longer needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キャンセル（0x08）：エンドポイントはこのエラーコードを使用して、ストリームが不要になったことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPRESSION_ERROR (0x09): The endpoint is unable to maintain the field section compression context for the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Compression_Error（0x09）：エンドポイントは、接続のフィールドセクション圧縮コンテキストを維持できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONNECT_ERROR (0x0a): The connection established in response to a CONNECT request (Section 8.5) was reset or abnormally closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Connect_Error（0x0a）：接続要求（セクション8.5）に応じて確立された接続は、リセットまたは異常に閉じられました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ENHANCE_YOUR_CALM (0x0b): The endpoint detected that its peer is exhibiting a behavior that might be generating excessive load.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Enhance_your_calm（0x0b）：エンドポイントは、そのピアが過度の負荷を生成する可能性のある動作を示していることを検出しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
INADEQUATE_SECURITY (0x0c): The underlying transport has properties that do not meet minimum security requirements (see Section 9.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inadequate_security（0x0c）：基礎となる輸送には、最小セキュリティ要件を満たさないプロパティがあります（セクション9.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP_1_1_REQUIRED (0x0d): The endpoint requires that HTTP/1.1 be used instead of HTTP/2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
http_1_1_required（0x0d）：エンドポイントでは、HTTP/2の代わりにHTTP/1.1を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unknown or unsupported error codes MUST NOT trigger any special behavior. These MAY be treated by an implementation as being equivalent to INTERNAL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不明またはサポートされていないエラーコードは、特別な動作をトリガーしてはなりません。これらは、Internal_Errorに相当するものとして実装によって扱われる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Expressing-HTTP-Semantics-in-HTTP2">
8. Expressing HTTP Semantics in HTTP/2
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. HTTP/2でHTTPセマンティクスを表現します
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 is an instantiation of the HTTP message abstraction (Section 6 of [HTTP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2は、HTTPメッセージ抽象化のインスタンス化です（[HTTP]のセクション6）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1--HTTP-Message-Framing">
8.1. HTTP Message Framing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. HTTPメッセージフレーミング
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client sends an HTTP request on a new stream, using a previously unused stream identifier (Section 5.1.1). A server sends an HTTP response on the same stream as the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、以前に使用されていないストリーム識別子（セクション5.1.1）を使用して、新しいストリームでHTTP要求を送信します。サーバーは、要求と同じストリームでHTTP応答を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An HTTP message (request or response) consists of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPメッセージ（リクエストまたは応答）は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. one HEADERS frame (followed by zero or more CONTINUATION frames) containing the header section (see Section 6.3 of [HTTP]),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. ヘッダーセクションを含む1つのヘッダーフレーム（ゼロ以上の継続フレームが続きます）（[http]のセクション6.3を参照）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. zero or more DATA frames containing the message content (see Section 6.4 of [HTTP]), and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. メッセージコンテンツを含むゼロ以上のデータフレーム（[http]のセクション6.4を参照）、および
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. optionally, one HEADERS frame (followed by zero or more CONTINUATION frames) containing the trailer section, if present (see Section 6.5 of [HTTP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. オプションで、トレーラーセクションを含む1つのヘッダーフレーム（ゼロ以上の継続フレームが続きます）（[http]のセクション6.5を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a response only, a server MAY send any number of interim responses before the HEADERS frame containing a final response. An interim response consists of a HEADERS frame (which might be followed by zero or more CONTINUATION frames) containing the control data and header section of an interim (1xx) HTTP response (see Section 15 of [HTTP]). A HEADERS frame with the END_STREAM flag set that carries an informational status code is malformed (Section 8.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答のみの場合、サーバーは、最終応答を含むヘッダーフレームの前に、任意の数の暫定応答を送信できます。暫定応答は、暫定（1xx）HTTP応答の制御データとヘッダーセクションを含むヘッダーフレーム（ゼロ以上の継続フレームが続く可能性がある）で構成されています（[HTTP]のセクション15を参照）。情報ステータスコードを搭載したEND_STREAMフラグセットを備えたヘッダーフレームは不正されています（セクション8.1.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The last frame in the sequence bears an END_STREAM flag, noting that a HEADERS frame with the END_STREAM flag set can be followed by CONTINUATION frames that carry any remaining fragments of the field block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンスの最後のフレームには、end_streamフラグがあり、end_streamフラグセットのあるヘッダーフレームに続いて、フィールドブロックの残りのフラグメントを運ぶ継続フレームが続くことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other frames (from any stream) MUST NOT occur between the HEADERS frame and any CONTINUATION frames that might follow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のフレーム（任意のストリームから）は、ヘッダーフレームと続く可能性のある継続フレームの間に発生してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 uses DATA frames to carry message content. The chunked transfer encoding defined in Section 7.1 of [HTTP/1.1] cannot be used in HTTP/2; see Section 8.2.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2は、データフレームを使用してメッセージコンテンツを掲載します。[http/1.1]のセクション7.1で定義されたチャンク転送エンコードは、HTTP/2では使用できません。セクション8.2.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Trailer fields are carried in a field block that also terminates the stream. That is, trailer fields comprise a sequence starting with a HEADERS frame, followed by zero or more CONTINUATION frames, where the HEADERS frame bears an END_STREAM flag. Trailers MUST NOT include pseudo-header fields (Section 8.3). An endpoint that receives pseudo-header fields in trailers MUST treat the request or response as malformed (Section 8.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トレーラーフィールドは、ストリームを終了するフィールドブロックに運ばれます。つまり、トレーラーフィールドは、ヘッダーフレームから始まるシーケンスを構成し、その後にゼロ以上の継続フレームが続き、ヘッダーフレームにEnd_streamフラグが付いています。トレーラーには、擬似ヘッダーフィールドを含めてはなりません（セクション8.3）。トレーラーで擬似ヘッダーフィールドを受信するエンドポイントは、要求または応答を奇形として扱う必要があります（セクション8.1.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint that receives a HEADERS frame without the END_STREAM flag set after receiving the HEADERS frame that opens a request or after receiving a final (non-informational) status code MUST treat the corresponding request or response as malformed (Section 8.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストを開いたヘッダーフレームを受信した後、または最終的な（非情報）ステータスコードを受信した後にヘッダーフレームを設定しないヘッダーフレームを受信するエンドポイントは、対応する要求または応答を奇形として扱う必要があります（セクション8.1.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An HTTP request/response exchange fully consumes a single stream. A request starts with the HEADERS frame that puts the stream into the &#34;open&#34; state. The request ends with a frame with the END_STREAM flag set, which causes the stream to become &#34;half-closed (local)&#34; for the client and &#34;half-closed (remote)&#34; for the server. A response stream starts with zero or more interim responses in HEADERS frames, followed by a HEADERS frame containing a final status code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP要求/応答交換は、単一のストリームを完全に消費します。要求は、ストリームを「オープン」状態にするヘッダーフレームから始まります。リクエストは、end_streamフラグセットを備えたフレームで終了し、クライアントのストリームは「半分閉鎖（ローカル）」になり、サーバーの「半分閉じた（リモート）」になります。応答ストリームは、ヘッダーフレームのゼロ以上の暫定応答から始まり、その後に最終的なステータスコードを含むヘッダーフレームが続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An HTTP response is complete after the server sends -- or the client receives -- a frame with the END_STREAM flag set (including any CONTINUATION frames needed to complete a field block). A server can send a complete response prior to the client sending an entire request if the response does not depend on any portion of the request that has not been sent and received. When this is true, a server MAY request that the client abort transmission of a request without error by sending a RST_STREAM with an error code of NO_ERROR after sending a complete response (i.e., a frame with the END_STREAM flag set). Clients MUST NOT discard responses as a result of receiving such a RST_STREAM, though clients can always discard responses at their discretion for other reasons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがEND_STREAMフラグセット（フィールドブロックを完了するために必要な継続フレームを含む）を送信する - またはクライアントが受信する（またはクライアントが受信）後にHTTP応答が完了します。サーバーは、送信されて受信されていないリクエストの一部に依存しない場合、クライアントがリクエスト全体を送信する前に完全な応答を送信できます。これが真実である場合、サーバーは、完全な応答を送信した後、no_errorのエラーコードを使用してRST_STREAMを送信することにより、クライアントがエラーなしでリクエストの送信を中止することを要求する場合があります（つまり、END_STREAMフラグセットのあるフレーム）。クライアントは、そのようなRST_STREAMを受け取った結果として応答を破棄してはなりませんが、クライアントは他の理由で常に裁量で回答を廃棄することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1-1--Malformed-Messages">
8.1.1. Malformed Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1. 不正なメッセージ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A malformed request or response is one that is an otherwise valid sequence of HTTP/2 frames but is invalid due to the presence of extraneous frames, prohibited fields or pseudo-header fields, the absence of mandatory pseudo-header fields, the inclusion of uppercase field names, or invalid field names and/or values (in certain circumstances; see Section 8.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不正な要求または応答は、HTTP/2フレームの特定の有効なシーケンスであるが、外部フレーム、禁止されたフィールドまたは擬似ヘッダーフィールドの存在、強制的な擬似ヘッダーフィールドの存在、uppercasesaseの包含のために無効なものとなるものとフィールド名、または無効なフィールド名および/または値（特定の状況では、セクション8.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A request or response that includes message content can include a content-length header field. A request or response is also malformed if the value of a content-length header field does not equal the sum of the DATA frame payload lengths that form the content, unless the message is defined as having no content. For example, 204 or 304 responses contain no content, as does the response to a HEAD request. A response that is defined to have no content, as described in Section 6.4.1 of [HTTP], MAY have a non-zero content-length header field, even though no content is included in DATA frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージコンテンツを含むリクエストまたは応答には、コンテンツ長ヘッダーフィールドを含めることができます。コンテンツが含まれていないと定義されていない限り、コンテンツ長ヘッダーフィールドの値がコンテンツを形成するデータフレームペイロード長の合計に等しくない場合、要求または応答も不正されます。たとえば、204または304の応答には、ヘッドリクエストへの応答と同様に、コンテンツが含まれていません。[HTTP]のセクション6.4.1で説明されているように、コンテンツがないようにコンテンツがないと定義されている応答は、データフレームに含まれていない場合でも、ゼロのコンテンツ長ヘッダーフィールドを持つ場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intermediaries that process HTTP requests or responses (i.e., any intermediary not acting as a tunnel) MUST NOT forward a malformed request or response. Malformed requests or responses that are detected MUST be treated as a stream error (Section 5.4.2) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP要求または応答を処理する仲介者（つまり、トンネルとして機能しない仲介者）は、奇形の要求または応答を転送してはなりません。検出された不正な要求または応答は、型protocol_errorのストリームエラー（セクション5.4.2）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For malformed requests, a server MAY send an HTTP response prior to closing or resetting the stream. Clients MUST NOT accept a malformed response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不正な要求の場合、サーバーは、ストリームを閉じるかリセットする前にHTTP応答を送信する場合があります。クライアントは不正な応答を受け入れてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints that progressively process messages might have performed some processing before identifying a request or response as malformed. For instance, it might be possible to generate an informational or 404 status code without having received a complete request. Similarly, intermediaries might forward incomplete messages before detecting errors. A server MAY generate a final response before receiving an entire request when the response does not depend on the remainder of the request being correct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージを徐々に処理するエンドポイントは、要求または応答を奇形として識別する前に、処理を実行した可能性があります。たとえば、完全なリクエストを受信せずに情報または404ステータスコードを生成することが可能かもしれません。同様に、仲介業者は、エラーを検出する前に、不完全なメッセージを転送する可能性があります。サーバーは、応答が残りのリクエストが正しいことに依存しない場合に、リクエスト全体を受信する前に最終的な応答を生成する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These requirements are intended to protect against several types of common attacks against HTTP; they are deliberately strict because being permissive can expose implementations to these vulnerabilities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの要件は、HTTPに対するいくつかのタイプの一般的な攻撃から保護することを目的としています。寛容であることは、これらの脆弱性に実装を公開する可能性があるため、意図的に厳格です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2--HTTP-Fields">
8.2. HTTP Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. HTTPフィールド
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP fields (Section 5 of [HTTP]) are conveyed by HTTP/2 in the HEADERS, CONTINUATION, and PUSH_PROMISE frames, compressed with HPACK [COMPRESSION].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPフィールド（[HTTP]のセクション5）は、HPACK [圧縮]で圧縮されたヘッダー、継続、およびPush_PromiseフレームのHTTP/2によって伝達されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Field names MUST be converted to lowercase when constructing an HTTP/2 message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2メッセージを作成する際には、フィールド名を小文字に変換する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2-1--Field-Validity">
8.2.1. Field Validity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.1. フィールドの妥当性
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The definitions of field names and values in HTTP prohibit some characters that HPACK might be able to convey. HTTP/2 implementations SHOULD validate field names and values according to their definitions in Sections 5.1 and 5.5 of [HTTP], respectively, and treat messages that contain prohibited characters as malformed (Section 8.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPのフィールド名と値の定義は、HPACKが伝えることができるいくつかの文字を禁止しています。HTTP/2実装は、[HTTP]のセクション5.1と5.5の定義に従ってフィールド名と値を検証し、禁止された文字を含むメッセージを奇形として扱う必要があります（セクション8.1.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Failure to validate fields can be exploited for request smuggling attacks. In particular, unvalidated fields might enable attacks when messages are forwarded using HTTP/1.1 [HTTP/1.1], where characters such as carriage return (CR), line feed (LF), and COLON are used as delimiters. Implementations MUST perform the following minimal validation of field names and values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドの検証の失敗は、密輸攻撃を要求するために悪用される可能性があります。特に、http/1.1 [http/1.1]を使用してメッセージが転送されると、攻撃が可能になる場合があります。ここで、キャリッジリターン（CR）、ラインフィード（LF）、コロンなどの文字が区切り文字として使用されます。実装は、フィールド名と値の次の最小限の検証を実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* A field name MUST NOT contain characters in the ranges 0x00-0x20, 0x41-0x5a, or 0x7f-0xff (all ranges inclusive). This specifically excludes all non-visible ASCII characters, ASCII SP (0x20), and uppercase characters (&#39;A&#39; to &#39;Z&#39;, ASCII 0x41 to 0x5a).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* フィールド名には、範囲0x00-0x20、0x41-0x5a、または0x7f-0xff（すべての範囲を含む）の文字を含めてはなりません。これは、具体的には、すべての訪問不可能なASCII文字、ASCII SP（0x20）、および大文字（ &#39;a&#39; to &#39;z&#39;、ascii 0x41〜0x5a）を除外します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* With the exception of pseudo-header fields (Section 8.3), which have a name that starts with a single colon, field names MUST NOT include a colon (ASCII COLON, 0x3a).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 単一のコロンで始まる名前を持つ擬似ヘッダーフィールド（セクション8.3）を除き、フィールド名はコロン（ASCIIコロン、0x3a）を含めてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* A field value MUST NOT contain the zero value (ASCII NUL, 0x00), line feed (ASCII LF, 0x0a), or carriage return (ASCII CR, 0x0d) at any position.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* フィールド値には、任意の位置にゼロ値（ASCII NUL、0X00）、ラインフィード（ASCII LF、0x0A）、またはキャリッジリターン（ASCII CR、0x0D）を含めてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* A field value MUST NOT start or end with an ASCII whitespace character (ASCII SP or HTAB, 0x20 or 0x09).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* フィールド値は、ASCII Whitespace文字（ASCII SPまたはHTAB、0x20または0x09）で起動または終了してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
 Note: An implementation that validates fields according to the definitions in Sections 5.1 and 5.5 of [HTTP] only needs an additional check that field names do not include uppercase characters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
注：[HTTP]のセクション5.1および5.5の定義に従ってフィールドを検証する実装には、フィールド名に大文字の文字が含まれていないという追加のチェックのみが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A request or response that contains a field that violates any of these conditions MUST be treated as malformed (Section 8.1.1). In particular, an intermediary that does not process fields when forwarding messages MUST NOT forward fields that contain any of the values that are listed as prohibited above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの条件のいずれかに違反するフィールドを含むリクエストまたは応答は、奇形として扱わなければなりません（セクション8.1.1）。特に、メッセージを転送するときにフィールドを処理しない仲介者は、上記のようにリストされている値を含むフィールドを転送してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a request message violates one of these requirements, an implementation SHOULD generate a 400 (Bad Request) status code (see Section 15.5.1 of [HTTP]), unless a more suitable status code is defined or the status code cannot be sent (e.g., because the error occurs in a trailer field).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストメッセージがこれらの要件のいずれかに違反する場合、実装は400（悪い要求）ステータスコードを生成する必要があります（[http]のセクション15.5.1を参照）、より適切なステータスコードが定義されていない場合、またはステータスコードを送信できない場合があります。たとえば、エラーがトレーラーフィールドで発生するため）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
 Note: Field values that are not valid according to the definition of the corresponding field do not cause a request to be malformed; the requirements above only apply to the generic syntax for fields as defined in Section 5 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
注：対応するフィールドの定義に従って有効でないフィールド値は、要求を不正にしないでください。上記の要件は、[http]のセクション5で定義されているフィールドの汎用構文にのみ適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2-2--Connection-Specific-Header-Fields">
8.2.2. Connection-Specific Header Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.2. 接続固有のヘッダーフィールド
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 does not use the Connection header field (Section 7.6.1 of [HTTP]) to indicate connection-specific header fields; in this protocol, connection-specific metadata is conveyed by other means. An endpoint MUST NOT generate an HTTP/2 message containing connection-specific header fields. This includes the Connection header field and those listed as having connection-specific semantics in Section 7.6.1 of [HTTP] (that is, Proxy-Connection, Keep-Alive, Transfer-Encoding, and Upgrade). Any message containing connection-specific header fields MUST be treated as malformed (Section 8.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2は、接続ヘッダーフィールド（[HTTP]のセクション7.6.1）を使用して、接続固有のヘッダーフィールドを示しません。このプロトコルでは、接続固有のメタデータは他の手段によって伝えられます。エンドポイントは、接続固有のヘッダーフィールドを含むHTTP/2メッセージを生成してはなりません。これには、[HTTP]のセクション7.6.1に接続固有のセマンティクスがあるとリストされている接続ヘッダーフィールドが含まれます（つまり、プロキシ接続、キープアライブ、転送エンコード、アップグレード）。接続固有のヘッダーフィールドを含むメッセージは、奇形として扱う必要があります（セクション8.1.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The only exception to this is the TE header field, which MAY be present in an HTTP/2 request; when it is, it MUST NOT contain any value other than &#34;trailers&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これの唯一の例外は、HTTP/2リクエストに存在する場合があるTEヘッダーフィールドです。そうである場合、「トレーラー」以外の値を含めてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An intermediary transforming an HTTP/1.x message to HTTP/2 MUST remove connection-specific header fields as discussed in Section 7.6.1 of [HTTP], or their messages will be treated by other HTTP/2 endpoints as malformed (Section 8.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/1.xメッセージをHTTP/2に変換する仲介者は、[HTTP]のセクション7.6.1で説明したように接続固有のヘッダーフィールドを削除する必要があります。.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
 Note: HTTP/2 purposefully does not support upgrade to another protocol. The handshake methods described in Section 3 are believed sufficient to negotiate the use of alternative protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
注：HTTP/2は、別のプロトコルへのアップグレードを意図的にサポートしていません。セクション3で説明されている握手方法は、代替プロトコルの使用を交渉するのに十分であると考えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2-3--Compressing-the-Cookie-Header-Field">
8.2.3. Compressing the Cookie Header Field
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.3. Cookieヘッダーフィールドの圧縮
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Cookie header field [COOKIE] uses a semicolon (&#34;;&#34;) to delimit cookie-pairs (or &#34;crumbs&#34;). This header field contains multiple values, but does not use a COMMA (&#34;,&#34;) as a separator, thereby preventing cookie-pairs from being sent on multiple field lines (see Section 5.2 of [HTTP]). This can significantly reduce compression efficiency, as updates to individual cookie-pairs would invalidate any field lines that are stored in the HPACK table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cookie Headerフィールド[Cookie]は、セミコロン（ &#34;;&#34;）を使用して、Cookie-Pairs（または「Crumbs」）を区切ります。このヘッダーフィールドには複数の値が含まれていますが、コンマ（ &#34;、&#34;）をセパレーターとして使用しないため、複数のフィールドラインでクッキーペアが送信されないようにします（[http]のセクション5.2を参照）。これにより、個々のクッキーペアの更新がHPACKテーブルに保存されているフィールドラインを無効にするため、圧縮効率を大幅に低下させる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To allow for better compression efficiency, the Cookie header field MAY be split into separate header fields, each with one or more cookie-pairs. If there are multiple Cookie header fields after decompression, these MUST be concatenated into a single octet string using the two-octet delimiter of 0x3b, 0x20 (the ASCII string &#34;; &#34;) before being passed into a non-HTTP/2 context, such as an HTTP/1.1 connection, or a generic HTTP server application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
より良い圧縮効率を可能にするために、Cookieヘッダーフィールドは、それぞれ1つ以上のCookieペアを備えた個別のヘッダーフィールドに分割できます。減圧後に複数のCookieヘッダーフィールドがある場合、これらは、0x3b、0x20（ascii string &#34;;&#34;）の2オクテットデリミターを使用して単一のオクテット文字列に連結する必要があります。HTTP/1.1接続、または汎用HTTPサーバーアプリケーションとして。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, the following two lists of Cookie header fields are semantically equivalent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、次の2つのCookieヘッダーフィールドのリストは、意味的に同等です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   cookie: a=b; c=d; e=f
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   cookie: a=b
   cookie: c=d
   cookie: e=f
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-3--HTTP-Control-Data">
8.3. HTTP Control Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. HTTP制御データ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 uses special pseudo-header fields beginning with a &#39;:&#39; character (ASCII 0x3a) to convey message control data (see Section 6.2 of [HTTP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2は、 &#39;：&#39;文字（ASCII 0x3a）で始まる特別な擬似ヘッダーフィールドを使用して、メッセージ制御データを伝達します（[http]のセクション6.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pseudo-header fields are not HTTP header fields. Endpoints MUST NOT generate pseudo-header fields other than those defined in this document. Note that an extension could negotiate the use of additional pseudo-header fields; see Section 5.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
擬似ヘッダーフィールドは、HTTPヘッダーフィールドではありません。エンドポイントは、このドキュメントで定義されているもの以外の擬似ヘッダーフィールドを生成してはなりません。拡張機能は、追加の擬似ヘッダーフィールドの使用を交渉できることに注意してください。セクション5.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pseudo-header fields are only valid in the context in which they are defined. Pseudo-header fields defined for requests MUST NOT appear in responses; pseudo-header fields defined for responses MUST NOT appear in requests. Pseudo-header fields MUST NOT appear in a trailer section. Endpoints MUST treat a request or response that contains undefined or invalid pseudo-header fields as malformed (Section 8.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
擬似ヘッダーフィールドは、定義されているコンテキストでのみ有効です。リクエストに対して定義された擬似ヘッダーフィールドは、応答に表示されてはなりません。応答のために定義された擬似ヘッダーフィールドは、リクエストに表示されてはなりません。擬似ヘッダーフィールドは、トレーラーセクションに表示されてはなりません。エンドポイントは、未定義または無効な擬似ヘッダーフィールドを含む要求または応答を奇形として扱う必要があります（セクション8.1.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All pseudo-header fields MUST appear in a field block before all regular field lines. Any request or response that contains a pseudo-header field that appears in a field block after a regular field line MUST be treated as malformed (Section 8.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての擬似ヘッダーフィールドは、すべての通常のフィールドラインの前にフィールドブロックに表示する必要があります。通常のフィールドラインの後にフィールドブロックに表示される疑似ヘッダーフィールドを含むリクエストまたは応答は、奇形として扱わなければなりません（セクション8.1.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same pseudo-header field name MUST NOT appear more than once in a field block. A field block for an HTTP request or response that contains a repeated pseudo-header field name MUST be treated as malformed (Section 8.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じ擬似ヘッダーのフィールド名は、フィールドブロックに1回以上表示されてはなりません。繰り返される擬似ヘッダーのフィールド名を含むHTTP要求または応答のフィールドブロックは、奇形として扱う必要があります（セクション8.1.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-3-1--Request-Pseudo-Header-Fields">
8.3.1. Request Pseudo-Header Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.1. 擬似ヘッダーフィールドをリクエストします
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following pseudo-header fields are defined for HTTP/2 requests:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の擬似ヘッダーフィールドは、HTTP/2リクエスト用に定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The &#34;:method&#34; pseudo-header field includes the HTTP method (Section 9 of [HTTP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 「：メソッド」疑似ヘッダーフィールドには、HTTPメソッド（[HTTP]のセクション9）が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The &#34;:scheme&#34; pseudo-header field includes the scheme portion of the request target. The scheme is taken from the target URI (Section 3.1 of [RFC3986]) when generating a request directly, or from the scheme of a translated request (for example, see Section 3.3 of [HTTP/1.1]). Scheme is omitted for CONNECT requests (Section 8.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 「：スキーム」疑似ヘッダーフィールドには、リクエストターゲットのスキーム部分が含まれます。スキームは、要求を直接生成するとき、または翻訳された要求のスキームからターゲットURI（[RFC3986]のセクション3.1）から取得されます（たとえば、[http/1.1]のセクション3.3を参照）。Connectリクエストのスキームは省略されています（セクション8.5）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&#34;:scheme&#34; is not restricted to &#34;http&#34; and &#34;https&#34; schemed URIs. A proxy or gateway can translate requests for non-HTTP schemes, enabling the use of HTTP to interact with non-HTTP services.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
「：スキーム」は、「http」および「https」のurisに制限されていません。プロキシまたはゲートウェイは、非HTTPスキームのリクエストを翻訳して、HTTPを使用して非HTTPサービスと対話できるようにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The &#34;:authority&#34; pseudo-header field conveys the authority portion (Section 3.2 of [RFC3986]) of the target URI (Section 7.1 of [HTTP]). The recipient of an HTTP/2 request MUST NOT use the Host header field to determine the target URI if &#34;:authority&#34; is present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ターゲットURI（[http]のセクション7.1）の権限部分（[rfc3986]のセクション3.2）を「[http]のセクション7.1）に「：権限」疑似ヘッダーフィールドが伝えます。http/2要求の受信者は、「：権限」が存在する場合、ホストヘッダーフィールドを使用してターゲットURIを決定してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Clients that generate HTTP/2 requests directly MUST use the &#34;:authority&#34; pseudo-header field to convey authority information, unless there is no authority information to convey (in which case it MUST NOT generate &#34;:authority&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
HTTP/2リクエストを直接生成するクライアントは、「：権限」の擬似ヘッダーフィールドを使用して、権限情報を伝える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Clients MUST NOT generate a request with a Host header field that differs from the &#34;:authority&#34; pseudo-header field. A server SHOULD treat a request as malformed if it contains a Host header field that identifies an entity that differs from the entity in the &#34;:authority&#34; pseudo-header field. The values of fields need to be normalized to compare them (see Section 6.2 of [RFC3986]). An origin server can apply any normalization method, whereas other servers MUST perform scheme-based normalization (see Section 6.2.3 of [RFC3986]) of the two fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントは、「：権威」の擬似ヘッダーフィールドとは異なるホストヘッダーフィールドでリクエストを生成してはなりません。サーバーは、「：権限」の擬似ヘッダーフィールドのエンティティとは異なるエンティティを識別するホストヘッダーフィールドを含む場合、要求を奇形として扱う必要があります。フィールドの値は、それらを比較するために正規化する必要があります（[RFC3986]のセクション6.2を参照）。Origin Serverは任意の正規化方法を適用できますが、他のサーバーは、2つのフィールドのスキームベースの正規化（[RFC3986]のセクション6.2.3を参照）を実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An intermediary that forwards a request over HTTP/2 MUST construct an &#34;:authority&#34; pseudo-header field using the authority information from the control data of the original request, unless the original request&#39;s target URI does not contain authority information (in which case it MUST NOT generate &#34;:authority&#34;). Note that the Host header field is not the sole source of this information; see Section 7.2 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
HTTP/2よりもリクエストを転送する仲介者は、元のリクエストのターゲットURIに権限情報が含まれていない場合を除き、元のリクエストの制御データからの権限情報を使用して「：権限」擬似ヘッダーフィールドを構築する必要があります（この場合はIT生成してはならない &#34;：authority&#34;）。ホストヘッダーフィールドは、この情報の唯一のソースではないことに注意してください。[http]のセクション7.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An intermediary that needs to generate a Host header field (which might be necessary to construct an HTTP/1.1 request) MUST use the value from the &#34;:authority&#34; pseudo-header field as the value of the Host field, unless the intermediary also changes the request target. This replaces any existing Host field to avoid potential vulnerabilities in HTTP routing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ホストヘッダーフィールドを生成する必要がある仲介者（HTTP/1.1リクエストを構築するために必要な場合がある場合）は、仲介者も変更されない限り、ホストフィールドの値として「：権限」の擬似ヘッダーフィールドから値を使用する必要があります。リクエストターゲット。これにより、HTTPルーティングの潜在的な脆弱性を回避するために、既存のホストフィールドに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An intermediary that forwards a request over HTTP/2 MAY retain any Host header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
HTTP/2よりもリクエストを転送する仲介者は、ホストヘッダーフィールドを保持する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note that request targets for CONNECT or asterisk-form OPTIONS requests never include authority information; see Sections 7.1 and 7.2 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
接続またはアスタリスク形式のオプションのリクエストターゲットには、権限情報が含まれないことに注意してください。[http]のセクション7.1および7.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&#34;:authority&#34; MUST NOT include the deprecated userinfo subcomponent for &#34;http&#34; or &#34;https&#34; schemed URIs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&#34;：authority&#34;は、「http」または「https」schemed urisの非推奨ユーザーインフェサブコンポーネントを含めてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The &#34;:path&#34; pseudo-header field includes the path and query parts of the target URI (the absolute-path production and, optionally, a &#39;?&#39; character followed by the query production; see Section 4.1 of [HTTP]). A request in asterisk form (for OPTIONS) includes the value &#39;*&#39; for the &#34;:path&#34; pseudo-header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 「：パス」疑似ヘッダーフィールドには、ターゲットURIのパスとクエリ部分（絶対パス生産、およびオプションではクエリ生産が続く「？」文字が含まれます。[http]のセクション4.1を参照）。アスタリスクフォームの要求（オプション用）には、「：パス」疑似ヘッダーフィールドの値「*」が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This pseudo-header field MUST NOT be empty for &#34;http&#34; or &#34;https&#34; URIs; &#34;http&#34; or &#34;https&#34; URIs that do not contain a path component MUST include a value of &#39;/&#39;. The exceptions to this rule are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この擬似ヘッダーフィールドは、「http」または「https」urisの場合は空にしてはなりません。パスコンポーネントを含まない「http」または「https」urisには、 &#39;/&#39;の値を含める必要があります。このルールの例外は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- an OPTIONS request for an &#34;http&#34; or &#34;https&#34; URI that does not include a path component; these MUST include a &#34;:path&#34; pseudo-header field with a value of &#39;*&#39; (see Section 7.1 of [HTTP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- パスコンポーネントを含まない「HTTP」または「HTTPS」URIのオプションリクエスト。これらには、「*」の値を持つ「：パス」疑似ヘッダーフィールドを含める必要があります（[http]のセクション7.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- CONNECT requests (Section 8.5), where the &#34;:path&#34; pseudo-header field is omitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- 接続要求（セクション8.5）。ここで、「：パス」疑似ヘッダーフィールドが省略されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All HTTP/2 requests MUST include exactly one valid value for the &#34;:method&#34;, &#34;:scheme&#34;, and &#34;:path&#34; pseudo-header fields, unless they are CONNECT requests (Section 8.5). An HTTP request that omits mandatory pseudo-header fields is malformed (Section 8.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのHTTP/2要求には、「メソッド」、「スキーム」、および「パス」の擬似ヘッダーフィールドの有効な値が正確に1つ含まれている必要があります。必須の擬似ヘッダーフィールドを省略するHTTP要求は奇形です（セクション8.1.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Individual HTTP/2 requests do not carry an explicit indicator of protocol version. All HTTP/2 requests implicitly have a protocol version of &#34;2.0&#34; (see Section 6.2 of [HTTP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
個々のHTTP/2リクエストには、プロトコルバージョンの明示的なインジケーターが含まれていません。すべてのHTTP/2要求には、暗黙的に「2.0」のプロトコルバージョンがあります（[HTTP]のセクション6.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-3-2--Response-Pseudo-Header-Fields">
8.3.2. Response Pseudo-Header Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2. 応答疑似ヘッダーフィールド
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For HTTP/2 responses, a single &#34;:status&#34; pseudo-header field is defined that carries the HTTP status code field (see Section 15 of [HTTP]). This pseudo-header field MUST be included in all responses, including interim responses; otherwise, the response is malformed (Section 8.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2応答の場合、HTTPステータスコードフィールドを運ぶ単一の &#34;：status&#34; pseudo-headerフィールドが定義されています（[http]のセクション15を参照）。この擬似ヘッダーフィールドは、暫定的な応答を含むすべての応答に含める必要があります。それ以外の場合、応答は奇形です（セクション8.1.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 responses implicitly have a protocol version of &#34;2.0&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2応答には、暗黙的に「2.0」のプロトコルバージョンがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-4--Server-Push">
8.4. Server Push
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. サーバープッシュ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 allows a server to preemptively send (or &#34;push&#34;) responses (along with corresponding &#34;promised&#34; requests) to a client in association with a previous client-initiated request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2では、サーバーは、以前のクライアントが開始した要求に関連して、クライアントに応答する（または「プッシュ」）応答を（または「プッシュ」）クライアントに送信（または「プッシュ」）することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server push was designed to allow a server to improve client-perceived performance by predicting what requests will follow those that it receives, thereby removing a round trip for them. For example, a request for HTML is often followed by requests for stylesheets and scripts referenced by that page. When these requests are pushed, the client does not need to wait to receive the references to them in the HTML and issue separate requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバープッシュは、サーバーが受け取ったリクエストに従うリクエストを予測することにより、クライアントに認識されたパフォーマンスを改善し、それにより往復を削除できるように設計されました。たとえば、HTMLのリクエストに続いて、そのページで参照されるスタイルシートとスクリプトのリクエストが続きます。これらのリクエストがプッシュされた場合、クライアントはHTMLでそれらへの参照を受信し、個別のリクエストを発行するのを待つ必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In practice, server push is difficult to use effectively, because it requires the server to correctly anticipate the additional requests the client will make, taking into account factors such as caching, content negotiation, and user behavior. Errors in prediction can lead to performance degradation, due to the opportunity cost that the additional data on the wire represents. In particular, pushing any significant amount of data can cause contention issues with responses that are more important.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際には、サーバーがキャッシュ、コンテンツの交渉、ユーザーの動作などの要因を考慮して、クライアントが行う追加の要求を正しく予測する必要があるため、サーバーのプッシュを効果的に使用することは困難です。予測のエラーは、ワイヤー上の追加データが表す機会コストにより、パフォーマンスの劣化につながる可能性があります。特に、かなりの量のデータをプッシュすると、より重要な応答の競合の問題を引き起こす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client can request that server push be disabled, though this is negotiated for each hop independently. The SETTINGS_ENABLE_PUSH setting can be set to 0 to indicate that server push is disabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、サーバーのプッシュを無効にすることを要求できますが、これは各ホップに対して独立してネゴシエートされます。SETTINGS_ENABLE_PUSH設定を0に設定して、サーバープッシュが無効になっていることを示すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Promised requests MUST be safe (see Section 9.2.1 of [HTTP]) and cacheable (see Section 9.2.3 of [HTTP]). Promised requests cannot include any content or a trailer section. Clients that receive a promised request that is not cacheable, that is not known to be safe, or that indicates the presence of request content MUST reset the promised stream with a stream error (Section 5.4.2) of type PROTOCOL_ERROR. Note that this could result in the promised stream being reset if the client does not recognize a newly defined method as being safe.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
約束された要求は安全でなければなりません（[http]のセクション9.2.1を参照）およびキャッシュ可能（[http]のセクション9.2.3を参照）。約束されたリクエストには、コンテンツやトレーラーセクションを含めることはできません。キャッシュ不可能ではない、安全であることが知られていない、またはリクエストコンテンツの存在が、型protocol_errorのストリームエラー（セクション5.4.2）で約束のストリームをリセットする必要があることを示す、約束された要求を受け取るクライアント。これにより、クライアントが新たに定義された方法を安全であると認識していない場合、約束されたストリームがリセットされる可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pushed responses that are cacheable (see Section 3 of [CACHING]) can be stored by the client, if it implements an HTTP cache. Pushed responses are considered successfully validated on the origin server (e.g., if the &#34;no-cache&#34; cache response directive is present; see Section 5.2.2.4 of [CACHING]) while the stream identified by the promised stream identifier is still open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キャッシュ可能なプッシュされた応答（[キャッシュ]のセクション3を参照）は、HTTPキャッシュを実装する場合、クライアントが保存できます。プッシュされた応答は、Origin Serverで正常に検証されていると見なされます（たとえば、「ノーキャッシュ」キャッシュ応答指令が存在する場合、[キャッシュ]のセクション5.2.2.4を参照）、約束されたストリーム識別子によって識別されたストリームがまだ開いています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pushed responses that are not cacheable MUST NOT be stored by any HTTP cache. They MAY be made available to the application separately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キャッシュできないプッシュされた応答は、HTTPキャッシュによって保存されてはなりません。それらは、アプリケーションで別々に利用可能になる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MUST include a value in the &#34;:authority&#34; pseudo-header field for which the server is authoritative (see Section 10.1). A client MUST treat a PUSH_PROMISE for which the server is not authoritative as a stream error (Section 5.4.2) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーには、サーバーが権威ある「：authority」疑似ヘッダーフィールドに値を含める必要があります（セクション10.1を参照）。クライアントは、タイプProtocol_Errorのストリームエラー（セクション5.4.2）としてサーバーが信頼できるPUSH_PROMISEを扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An intermediary can receive pushes from the server and choose not to forward them on to the client. In other words, how to make use of the pushed information is up to that intermediary. Equally, the intermediary might choose to make additional pushes to the client, without any action taken by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仲介者はサーバーからプッシュを受け取ることができ、クライアントに転送しないことを選択できます。言い換えれば、プッシュされた情報を利用する方法は、その仲介者までです。同様に、仲介者は、サーバーが講じないで、クライアントに追加のプッシュを行うことを選択する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client cannot push. Thus, servers MUST treat the receipt of a PUSH_PROMISE frame as a connection error (Section 5.4.1) of type PROTOCOL_ERROR. A server cannot set the SETTINGS_ENABLE_PUSH setting to a value other than 0 (see Section 6.5.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはプッシュできません。したがって、サーバーは、Push_promiseフレームの受信を、型protocol_errorの接続エラー（セクション5.4.1）として処理する必要があります。サーバーは、settings_enable_push設定を0以外の値に設定できません（セクション6.5.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-4-1--Push-Requests">
8.4.1. Push Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.1. リクエストをプッシュします
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server push is semantically equivalent to a server responding to a request; however, in this case, that request is also sent by the server, as a PUSH_PROMISE frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのプッシュは、リクエストに応答するサーバーと意味的に同等です。ただし、この場合、その要求は、Push_Promiseフレームとしてサーバーによっても送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PUSH_PROMISE frame includes a field block that contains control data and a complete set of request header fields that the server attributes to the request. It is not possible to push a response to a request that includes message content.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Push_Promiseフレームには、制御データを含むフィールドブロックと、サーバーがリクエストに起因する完全なリクエストヘッダーフィールドが含まれています。メッセージコンテンツを含むリクエストに対する応答をプッシュすることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Promised requests are always associated with an explicit request from the client. The PUSH_PROMISE frames sent by the server are sent on that explicit request&#39;s stream. The PUSH_PROMISE frame also includes a promised stream identifier, chosen from the stream identifiers available to the server (see Section 5.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
約束された要求は、常にクライアントからの明示的な要求に関連付けられています。サーバーから送信されたPush_Promiseフレームは、その明示的な要求のストリームに送信されます。Push_Promiseフレームには、サーバーが利用できるストリーム識別子から選択された約束のストリーム識別子も含まれています（セクション5.1.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The header fields in PUSH_PROMISE and any subsequent CONTINUATION frames MUST be a valid and complete set of request header fields (Section 8.3.1). The server MUST include a method in the &#34;:method&#34; pseudo-header field that is safe and cacheable. If a client receives a PUSH_PROMISE that does not include a complete and valid set of header fields or the &#34;:method&#34; pseudo-header field identifies a method that is not safe, it MUST respond on the promised stream with a stream error (Section 5.4.2) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
push_promiseのヘッダーフィールドとその後の継続フレームは、有効かつ完全な要求ヘッダーフィールドのセットでなければなりません（セクション8.3.1）。サーバーには、安全でキャッシュ可能な「メソッド」疑似ヘッダーフィールドにメソッドを含める必要があります。クライアントが、ヘッダーフィールドの完全かつ有効なセットまたは「メソッド」擬似ヘッダーフィールドを含まないPUSH_PROMISEを受信した場合、安全でないメソッドを識別する場合、ストリームエラーで約束されたストリームで応答する必要があります（セクション5.4.2）型protocol_errorの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server SHOULD send PUSH_PROMISE (Section 6.6) frames prior to sending any frames that reference the promised responses. This avoids a race where clients issue requests prior to receiving any PUSH_PROMISE frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、約束された応答を参照するフレームを送信する前に、push_promise（セクション6.6）フレームを送信する必要があります。これにより、Push_promiseフレームを受信する前にクライアントがリクエストを発行するレースが回避されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, if the server receives a request for a document containing embedded links to multiple image files and the server chooses to push those additional images to the client, sending PUSH_PROMISE frames before the DATA frames that contain the image links ensures that the client is able to see that a resource will be pushed before discovering embedded links. Similarly, if the server pushes resources referenced by the field block (for instance, in Link header fields), sending a PUSH_PROMISE before sending the header ensures that clients do not request those resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、サーバーが複数の画像ファイルへの埋め込みリンクを含むドキュメントのリクエストを受信し、サーバーがそれらの追加画像をクライアントにプッシュすることを選択し、画像リンクを含むデータフレームがクライアントができるようにする前にpush_promiseフレームを送信することを選択した場合埋め込まれたリンクを発見する前に、リソースがプッシュされることを確認します。同様に、サーバーがフィールドブロック（たとえば、リンクヘッダーフィールドで）で参照されるリソースをプッシュする場合、ヘッダーを送信する前にPush_Promiseを送信すると、クライアントがそれらのリソースを要求しないようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUSH_PROMISE frames MUST NOT be sent by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Push_Promiseフレームをクライアントから送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUSH_PROMISE frames can be sent by the server on any client-initiated stream, but the stream MUST be in either the &#34;open&#34; or &#34;half-closed (remote)&#34; state with respect to the server. PUSH_PROMISE frames are interspersed with the frames that comprise a response, though they cannot be interspersed with HEADERS and CONTINUATION frames that comprise a single field block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Push_Promiseフレームは、クライアントが開始したストリームでサーバーによって送信できますが、ストリームはサーバーに対して「オープン」または「半分閉鎖された（リモート）状態のいずれかにある必要があります。Push_Promiseフレームには、応答を構成するフレームが散在していますが、単一のフィールドブロックを構成するヘッダーと継続フレームを散在することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sending a PUSH_PROMISE frame creates a new stream and puts the stream into the &#34;reserved (local)&#34; state for the server and the &#34;reserved (remote)&#34; state for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
push_promiseフレームを送信すると、新しいストリームが作成され、サーバーの「予約済み（ローカル）」状態とクライアントの「予約済み（リモート）」状態にストリームが作成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-4-2--Push-Responses">
8.4.2. Push Responses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.2. 応答をプッシュします
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After sending the PUSH_PROMISE frame, the server can begin delivering the pushed response as a response (Section 8.3.2) on a server-initiated stream that uses the promised stream identifier. The server uses this stream to transmit an HTTP response, using the same sequence of frames as that defined in Section 8.1. This stream becomes &#34;half-closed&#34; to the client (Section 5.1) after the initial HEADERS frame is sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
push_promiseフレームを送信した後、サーバーは、約束されたストリーム識別子を使用するサーバーが開始したストリームで、応答としてプッシュ応答の配信（セクション8.3.2）を開始できます。サーバーは、このストリームを使用して、セクション8.1で定義されているフレームと同じシーケンスを使用して、HTTP応答を送信します。このストリームは、最初のヘッダーフレームが送信された後、クライアントに「半分閉鎖」されます（セクション5.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a client receives a PUSH_PROMISE frame and chooses to accept the pushed response, the client SHOULD NOT issue any requests for the promised response until after the promised stream has closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがPush_promiseフレームを受信し、プッシュされた応答を受け入れることを選択したら、約束されたストリームが閉じるまで、約束された応答のリクエストを発行しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client determines, for any reason, that it does not wish to receive the pushed response from the server or if the server takes too long to begin sending the promised response, the client can send a RST_STREAM frame, using either the CANCEL or REFUSED_STREAM code and referencing the pushed stream&#39;s identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが、何らかの理由で、サーバーからプッシュされた応答を受信したくないと判断した場合、またはサーバーが約束された応答の送信を開始するのに時間がかかりすぎると、クライアントはキャンセルまたはrexused_streamを使用してRST_streamフレームを送信できます。プッシュストリームの識別子をコードして参照します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client can use the SETTINGS_MAX_CONCURRENT_STREAMS setting to limit the number of responses that can be concurrently pushed by a server. Advertising a SETTINGS_MAX_CONCURRENT_STREAMS value of zero prevents the server from opening the streams necessary to push responses. However, this does not prevent the server from reserving streams using PUSH_PROMISE frames, because reserved streams do not count toward the concurrent stream limit. Clients that do not wish to receive pushed resources need to reset any unwanted reserved streams or set SETTINGS_ENABLE_PUSH to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、settings_max_concurrent_streams設定を使用して、サーバーによって同時にプッシュできる応答の数を制限できます。settings_max_concurrent_streams zeroのsettings_max_concurrent_streamsの広告は、サーバーが応答をプッシュするために必要なストリームを開くことを防ぎます。ただし、これは、予約済みのストリームが同時ストリームの制限にカウントされないため、Push_promiseフレームを使用してサーバーを予約することを妨げません。プッシュされたリソースを受け取りたくないクライアントは、不要な予約済みのストリームをリセットする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients receiving a pushed response MUST validate that either the server is authoritative (see Section 10.1) or the proxy that provided the pushed response is configured for the corresponding request. For example, a server that offers a certificate for only the example.com DNS-ID (see [RFC6125]) is not permitted to push a response for &lt;https://www.example.org/doc&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プッシュされた応答を受信するクライアントは、サーバーが権威あるものである（セクション10.1を参照）またはプッシュされた応答を提供したプロキシが対応するリクエストに対して構成されていることを検証する必要があります。たとえば、example.comDNS-IDのみの証明書を提供するサーバー（[rfc6125]を参照）は、&lt;https://www.example.org/doc&gt;の応答をプッシュすることは許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The response for a PUSH_PROMISE stream begins with a HEADERS frame, which immediately puts the stream into the &#34;half-closed (remote)&#34; state for the server and &#34;half-closed (local)&#34; state for the client, and ends with a frame with the END_STREAM flag set, which places the stream in the &#34;closed&#34; state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Push_Promiseストリームの応答は、ヘッダーフレームから始まり、ストリームはすぐにサーバーの「半分閉鎖（リモート）」状態になり、クライアントの「半分閉鎖（ローカル）」状態になり、フレームで終了します。end_streamフラグがセットされており、ストリームを「閉じた」状態に配置します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
 Note: The client never sends a frame with the END_STREAM flag set for a server push.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
注：クライアントは、サーバープッシュ用にEND_STREAMフラグが設定されたフレームを送信することはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-5--The-CONNECT-Method">
8.5. The CONNECT Method
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. 接続メソッド
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CONNECT method (Section 9.3.6 of [HTTP]) is used to convert an HTTP connection into a tunnel to a remote host. CONNECT is primarily used with HTTP proxies to establish a TLS session with an origin server for the purposes of interacting with &#34;https&#34; resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Connectメソッド（[HTTP]のセクション9.3.6）は、HTTP接続をトンネルにリモートホストに変換するために使用されます。Connectは主にHTTPプロキシで使用され、「HTTPS」リソースとの対話を目的として、Origin ServerとTLSセッションを確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In HTTP/2, the CONNECT method establishes a tunnel over a single HTTP/2 stream to a remote host, rather than converting the entire connection to a tunnel. A CONNECT header section is constructed as defined in Section 8.3.1 (&#34;Request Pseudo-Header Fields&#34;), with a few differences. Specifically:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2では、Connectメソッドは、接続全体をトンネルに変換するのではなく、単一のHTTP/2ストリームにリモートホストにトンネルを確立します。接続ヘッダーセクションは、セクション8.3.1（ &#34;要求の擬似ヘッダーフィールド&#34;）で定義されているように構築され、いくつかの違いがあります。具体的には：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The &#34;:method&#34; pseudo-header field is set to CONNECT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 「：メソッド」擬似ヘッダーフィールドは、接続するように設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The &#34;:scheme&#34; and &#34;:path&#34; pseudo-header fields MUST be omitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 「：スキーム」と「：パス」疑似ヘッダーフィールドは省略する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The &#34;:authority&#34; pseudo-header field contains the host and port to connect to (equivalent to the authority-form of the request-target of CONNECT requests; see Section 3.2.3 of [HTTP/1.1]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 「：authority」疑似ヘッダーフィールドには、接続するホストとポートが含まれています（接続要求の要求標的の権限形式に相当します。[http/1.1]のセクション3.2.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A CONNECT request that does not conform to these restrictions is malformed (Section 8.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの制限に準拠していない接続要求は奇形です（セクション8.1.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proxy that supports CONNECT establishes a TCP connection [TCP] to the host and port identified in the &#34;:authority&#34; pseudo-header field. Once this connection is successfully established, the proxy sends a HEADERS frame containing a 2xx-series status code to the client, as defined in Section 9.3.6 of [HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Connectをサポートするプロキシは、「：権限」の擬似ヘッダーフィールドで識別されたホストとポートにTCP接続[TCP]を確立します。この接続が正常に確立されると、プロキシは[HTTP]のセクション9.3.6で定義されているように、2xxシリーズステータスコードを含むヘッダーフレームをクライアントに送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the initial HEADERS frame sent by each peer, all subsequent DATA frames correspond to data sent on the TCP connection. The frame payload of any DATA frames sent by the client is transmitted by the proxy to the TCP server; data received from the TCP server is assembled into DATA frames by the proxy. Frame types other than DATA or stream management frames (RST_STREAM, WINDOW_UPDATE, and PRIORITY) MUST NOT be sent on a connected stream and MUST be treated as a stream error (Section 5.4.2) if received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ピアから送信された最初のヘッダーフレームの後、後続のデータフレームはすべて、TCP接続で送信されたデータに対応します。クライアントが送信したデータフレームのフレームペイロードは、プロキシによってTCPサーバーに送信されます。TCPサーバーから受信したデータは、プロキシによってデータフレームに組み立てられます。データまたはストリーム管理フレーム以外のフレームタイプ（RST_STREAM、WINDOW_UPDATE、およびPRIORITY）を接続されたストリームで送信してはならず、受信した場合はストリームエラー（セクション5.4.2）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TCP connection can be closed by either peer. The END_STREAM flag on a DATA frame is treated as being equivalent to the TCP FIN bit. A client is expected to send a DATA frame with the END_STREAM flag set after receiving a frame with the END_STREAM flag set. A proxy that receives a DATA frame with the END_STREAM flag set sends the attached data with the FIN bit set on the last TCP segment. A proxy that receives a TCP segment with the FIN bit set sends a DATA frame with the END_STREAM flag set. Note that the final TCP segment or DATA frame could be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP接続は、いずれかのピアで閉じることができます。データフレームのEND_STREAMフラグは、TCP FINビットと同等であると扱われます。クライアントは、END_STREAMフラグが設定されたフレームを受信した後、END_STREAMフラグが設定されたデータフレームを送信することが期待されます。END_STREAMフラグセットでデータフレームを受信するプロキシは、最後のTCPセグメントにFINビット設定で添付のデータを送信します。FINビットセットを使用してTCPセグメントを受信するプロキシは、END_STREAMフラグセットでデータフレームを送信します。最終的なTCPセグメントまたはデータフレームが空になる可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A TCP connection error is signaled with RST_STREAM. A proxy treats any error in the TCP connection, which includes receiving a TCP segment with the RST bit set, as a stream error (Section 5.4.2) of type CONNECT_ERROR. Correspondingly, a proxy MUST send a TCP segment with the RST bit set if it detects an error with the stream or the HTTP/2 connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP接続エラーは、RST_STREAMで信号されています。プロキシは、TCP接続のエラーを扱います。これには、connect_errorのタイプのストリームエラー（セクション5.4.2）として、RSTビットセットを使用してTCPセグメントを受信することが含まれます。それに応じて、プロキシは、ストリームまたはHTTP/2接続でエラーを検出する場合、RSTビット設定でTCPセグメントを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-6--The-Upgrade-Header-Field">
8.6. The Upgrade Header Field
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6. アップグレードヘッダーフィールド
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 does not support the 101 (Switching Protocols) informational status code (Section 15.2.2 of [HTTP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2は、101（スイッチングプロトコル）情報ステータスコード（[HTTP]のセクション15.2.2）をサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The semantics of 101 (Switching Protocols) aren&#39;t applicable to a multiplexed protocol. Similar functionality might be enabled through the use of extended CONNECT [RFC8441], and other protocols are able to use the same mechanisms that HTTP/2 uses to negotiate their use (see Section 3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
101（スイッチングプロトコル）のセマンティクスは、多重化プロトコルには適用できません。同様の機能は、拡張接続[RFC8441]を使用することで有効になる可能性があり、他のプロトコルは、HTTP/2が使用に使用するのと同じメカニズムを使用することができます（セクション3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-7--Request-Reliability">
8.7. Request Reliability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7. 信頼性を要求します
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, an HTTP client is unable to retry a non-idempotent request when an error occurs because there is no means to determine the nature of the error (see Section 9.2.2 of [HTTP]). It is possible that some server processing occurred prior to the error, which could result in undesirable effects if the request were reattempted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般に、HTTPクライアントは、エラーの性質を決定する手段がないためにエラーが発生した場合、非公開要求を再試行できません（[HTTP]のセクション9.2.2を参照）。エラーの前に何らかのサーバー処理が発生した可能性があり、リクエストが再試行された場合、望ましくない効果をもたらす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 provides two mechanisms for providing a guarantee to a client that a request has not been processed:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2は、リクエストが処理されていないことをクライアントに保証を提供するための2つのメカニズムを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The GOAWAY frame indicates the highest stream number that might have been processed. Requests on streams with higher numbers are therefore guaranteed to be safe to retry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Goawayフレームは、処理された可能性のある最高のストリーム数を示します。したがって、より高い数のストリームのリクエストは、再試行するのが安全であることが保証されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The REFUSED_STREAM error code can be included in a RST_STREAM frame to indicate that the stream is being closed prior to any processing having occurred. Any request that was sent on the reset stream can be safely retried.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Refused_streamエラーコードをRST_STREAMフレームに含めることができ、処理が発生する前にストリームが閉じられていることを示します。リセットストリームで送信されたリクエストは、安全に再試行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Requests that have not been processed have not failed; clients MAY automatically retry them, even those with non-idempotent methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
処理されていないリクエストは失敗していません。クライアントは、自動的に非難的な方法を持つ人でも自動的に再試行することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MUST NOT indicate that a stream has not been processed unless it can guarantee that fact. If frames that are on a stream are passed to the application layer for any stream, then REFUSED_STREAM MUST NOT be used for that stream, and a GOAWAY frame MUST include a stream identifier that is greater than or equal to the given stream identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、その事実を保証できない限り、ストリームが処理されていないことを示してはなりません。ストリーム上にあるフレームが任意のストリームのアプリケーションレイヤーに渡される場合、拒否された_streamをそのストリームに使用してはなりません。また、goawayフレームには、指定されたストリーム識別子以上のストリーム識別子を含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to these mechanisms, the PING frame provides a way for a client to easily test a connection. Connections that remain idle can become broken, because some middleboxes (for instance, network address translators or load balancers) silently discard connection bindings. The PING frame allows a client to safely test whether a connection is still active without sending a request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのメカニズムに加えて、Pingフレームは、クライアントが接続を簡単にテストする方法を提供します。一部のミドルボックス（たとえば、ネットワークアドレス翻訳者やロードバランサー）が静かに接続のバインディングを破棄するため、アイドル状態のままの接続は壊れる可能性があります。Pingフレームにより、クライアントはリクエストを送信せずに接続がまだアクティブかどうかを安全にテストできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-8--Examples">
8.8. Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8. 例
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section shows HTTP/1.1 requests and responses, with illustrations of equivalent HTTP/2 requests and responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、HTTP/1.1のリクエストと応答を示し、同等のHTTP/2リクエストと応答のイラストを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-8-1--Simple-Request">
8.8.1. Simple Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8.1. 簡単なリクエスト
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An HTTP GET request includes control data and a request header with no message content and is therefore transmitted as a single HEADERS frame, followed by zero or more CONTINUATION frames containing the serialized block of request header fields. The HEADERS frame in the following has both the END_HEADERS and END_STREAM flags set; no CONTINUATION frames are sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP GETリクエストには、コントロールデータとメッセージコンテンツのないリクエストヘッダーが含まれているため、単一のヘッダーフレームとして送信され、その後、リクエストヘッダーフィールドのシリアル化ブロックを含むゼロ以上の継続フレームが続きます。以下のヘッダーフレームには、end_headersとend_streamフラグの両方が設定されています。継続フレームは送信されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     GET /resource HTTP/1.1           HEADERS
     Host: example.org          ==&gt;     + END_STREAM
     Accept: image/jpeg                 + END_HEADERS
                                          :method = GET
                                          :scheme = https
                                          :authority = example.org
                                          :path = /resource
                                          host = example.org
                                          accept = image/jpeg
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-8-2--Simple-Response">
8.8.2. Simple Response
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8.2. 単純な応答
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, a response that includes only control data and a response header is transmitted as a HEADERS frame (again, followed by zero or more CONTINUATION frames) containing the serialized block of response header fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、コントロールデータと応答ヘッダーのみを含む応答は、応答ヘッダーフィールドのシリアル化ブロックを含むヘッダーフレーム（再び、ゼロ以上の継続フレームが続く）として送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
HTTP/1.1 304 Not Modified HEADERS ETag: &#34;xyzzy&#34; ==&gt; + END_STREAM Expires: Thu, 23 Jan ... + END_HEADERS :status = 304 etag = &#34;xyzzy&#34; expires = Thu, 23 Jan ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
http/1.1 304変更されていないヘッダーetag： &#34;xyzzy&#34; ==&gt; end_streamの有効期限：木、1月23日... end_headers：status = 304 etag = &#34;xyzzy&#34; expires = thu、23 Jan ...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-8-3--Complex-Request">
8.8.3. Complex Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8.3. 複雑なリクエスト
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An HTTP POST request that includes control data and a request header with message content is transmitted as one HEADERS frame, followed by zero or more CONTINUATION frames containing the request header, followed by one or more DATA frames, with the last CONTINUATION (or HEADERS) frame having the END_HEADERS flag set and the final DATA frame having the END_STREAM flag set:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コントロールデータとメッセージコンテンツを含むリクエストヘッダーを含むHTTP POSTリクエストは、1つのヘッダーフレームとして送信され、その後、リクエストヘッダーを含むゼロ以上の継続フレームが続き、その後に1つ以上のデータフレームが続き、最後の継続（またはヘッダー）が続きます。end_headersフラグが設定されているフレームと、end_streamフラグセットを持つ最終データフレームフレーム：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     POST /resource HTTP/1.1          HEADERS
     Host: example.org          ==&gt;     - END_STREAM
     Content-Type: image/jpeg           - END_HEADERS
     Content-Length: 123                  :method = POST
                                          :authority = example.org
                                          :path = /resource
     {binary data}                        :scheme = https
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-38">
CONTINUATION + END_HEADERS content-type = image/jpeg host = example.org content-length = 123
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-38">
継続end_headers content-type = image/jpeg host = example.org content-length = 123
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-38">
DATA + END_STREAM {binary data}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-38">
data end_stream {バイナリデータ}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that data contributing to any given field line could be spread between field block fragments. The allocation of field lines to frames in this example is illustrative only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のフィールドラインに寄与するデータは、フィールドブロックフラグメント間に広がる可能性があることに注意してください。この例のフレームへのフィールドラインの割り当ては例示的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-8-4--Response-with-Body">
8.8.4. Response with Body
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8.4. ボディによる応答
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A response that includes control data and a response header with message content is transmitted as a HEADERS frame, followed by zero or more CONTINUATION frames, followed by one or more DATA frames, with the last DATA frame in the sequence having the END_STREAM flag set:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コントロールデータとメッセージコンテンツを含む応答ヘッダーを含む応答は、ヘッダーフレームとして送信され、その後にゼロ以上の継続フレームが続き、その後に1つ以上のデータフレームが続き、シーケンスの最後のデータフレームがEND_STREAMフラグを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     HTTP/1.1 200 OK                  HEADERS
     Content-Type: image/jpeg   ==&gt;     - END_STREAM
     Content-Length: 123                + END_HEADERS
                                          :status = 200
     {binary data}                        content-type = image/jpeg
                                          content-length = 123
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-38">
DATA + END_STREAM {binary data}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-38">
data end_stream {バイナリデータ}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-8-5--Informational-Responses">
8.8.5. Informational Responses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8.5. 情報回答
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An informational response using a 1xx status code other than 101 is transmitted as a HEADERS frame, followed by zero or more CONTINUATION frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
101以外の1XXステータスコードを使用した情報応答は、ヘッダーフレームとして送信され、その後ゼロ以上の継続フレームが続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A trailer section is sent as a field block after both the request or response field block and all the DATA frames have been sent. The HEADERS frame starting the field block that comprises the trailer section has the END_STREAM flag set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストまたは応答フィールドブロックの両方とすべてのデータフレームが送信された後、トレーラーセクションがフィールドブロックとして送信されます。トレーラーセクションを構成するフィールドブロックを起動するヘッダーフレームには、end_streamフラグが設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following example includes both a 100 (Continue) status code, which is sent in response to a request containing a &#34;100-continue&#34; token in the Expect header field, and a trailer section:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例には、100（続行）ステータスコードの両方が含まれています。これには、予想ヘッダーフィールドに「100コントン」トークンを含むリクエストに応じて送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     HTTP/1.1 100 Continue            HEADERS
     Extension-Field: bar       ==&gt;     - END_STREAM
                                        + END_HEADERS
                                          :status = 100
                                          extension-field = bar
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     HTTP/1.1 200 OK                  HEADERS
     Content-Type: image/jpeg   ==&gt;     - END_STREAM
     Transfer-Encoding: chunked         + END_HEADERS
     Trailer: Foo                         :status = 200
                                          content-type = image/jpeg
     123                                  trailer = Foo
     {binary data}
     0                                DATA
     Foo: bar                           - END_STREAM
                                      {binary data}
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-38">
HEADERS + END_STREAM + END_HEADERS foo = bar
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-38">
ヘッダーend_stream end_headers foo = bar
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--HTTP2-Connections">
9. HTTP/2 Connections
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. HTTP/2接続
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section outlines attributes of HTTP that improve interoperability, reduce exposure to known security vulnerabilities, or reduce the potential for implementation variation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、相互運用性を向上させ、既知のセキュリティの脆弱性への暴露を減らす、または実装の変動の可能性を減らすHTTPの属性の概要を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1--Connection-Management">
9.1. Connection Management
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. 接続管理
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 connections are persistent. For best performance, it is expected that clients will not close connections until it is determined that no further communication with a server is necessary (for example, when a user navigates away from a particular web page) or until the server closes the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2接続は永続的です。最高のパフォーマンスのために、クライアントは、ユーザーが特定のWebページから離れてナビゲートするとき、またはサーバーが接続を閉じるまで（たとえば、ユーザーがナビゲートするとき）、サーバーとのさらなる通信が必要ないと判断されるまで接続を閉じないことが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients SHOULD NOT open more than one HTTP/2 connection to a given host and port pair, where the host is derived from a URI, a selected alternative service [ALT-SVC], or a configured proxy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、特定のホストとポートペアへの複数のHTTP/2接続を開くべきではありません。ホストは、URI、選択された代替サービス[ALT-SVC]、または構成されたプロキシから派生しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client can create additional connections as replacements, either to replace connections that are near to exhausting the available stream identifier space (Section 5.1.1), to refresh the keying material for a TLS connection, or to replace connections that have encountered errors (Section 5.4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、利用可能なストリーム識別子スペースを使い果たし（セクション5.1.1）、TLS接続用のキーイング素材を更新する、またはエラーが発生した接続を交換するために、交換として追加の接続を交換として作成できます。5.4.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client MAY open multiple connections to the same IP address and TCP port using different Server Name Indication [TLS-EXT] values or to provide different TLS client certificates but SHOULD avoid creating multiple connections with the same configuration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、異なるサーバー名表示[TLS-EXT]値を使用して、同じIPアドレスとTCPポートへの複数の接続を開くか、異なるTLSクライアント証明書を提供しますが、同じ構成で複数の接続を作成することは避けてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers are encouraged to maintain open connections for as long as possible but are permitted to terminate idle connections if necessary. When either endpoint chooses to close the transport-layer TCP connection, the terminating endpoint SHOULD first send a GOAWAY (Section 6.8) frame so that both endpoints can reliably determine whether previously sent frames have been processed and gracefully complete or terminate any necessary remaining tasks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、可能な限り開いた接続を維持することをお勧めしますが、必要に応じてアイドル接続を終了することが許可されています。いずれかのエンドポイントがトランスポート層TCP接続を閉じることを選択すると、終了エンドポイントは最初にゲーウェイ（セクション6.8）フレームを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1-1--Connection-Reuse">
9.1.1. Connection Reuse
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.1. 接続の再利用
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Connections that are made to an origin server, either directly or through a tunnel created using the CONNECT method (Section 8.5), MAY be reused for requests with multiple different URI authority components. A connection can be reused as long as the origin server is authoritative (Section 10.1). For TCP connections without TLS, this depends on the host having resolved to the same IP address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Origin Serverに直接またはConnectメソッド（セクション8.5）を使用して作成されたトンネルを介して作成された接続は、複数の異なるURI機関コンポーネントを含むリクエストに対して再利用できます。Origin Serverが信頼できる限り、接続を再利用できます（セクション10.1）。TLSのないTCP接続の場合、これはホストが同じIPアドレスに解決したことによって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For &#34;https&#34; resources, connection reuse additionally depends on having a certificate that is valid for the host in the URI. The certificate presented by the server MUST satisfy any checks that the client would perform when forming a new TLS connection for the host in the URI. A single certificate can be used to establish authority for multiple origins. Section 4.3 of [HTTP] describes how a client determines whether a server is authoritative for a URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「HTTPS」リソースの場合、接続の再利用は、URIのホストに有効な証明書を持つことに依存します。サーバーが提示した証明書は、URIのホストの新しいTLS接続を形成するときにクライアントが実行するチェックを満たす必要があります。単一の証明書を使用して、複数の起源の権限を確立できます。[HTTP]のセクション4.3では、クライアントがサーバーがURIの権威あるかどうかをどのように決定するかについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some deployments, reusing a connection for multiple origins can result in requests being directed to the wrong origin server. For example, TLS termination might be performed by a middlebox that uses the TLS Server Name Indication [TLS-EXT] extension to select an origin server. This means that it is possible for clients to send requests to servers that might not be the intended target for the request, even though the server is otherwise authoritative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部の展開では、複数の起源の接続を再利用すると、リクエストが間違ったOriginサーバーに向けられる可能性があります。たとえば、TLS終了は、TLSサーバー名表示[TLS-EXT]拡張機能を使用してOrigin Serverを選択するミドルボックスによって実行される場合があります。これは、サーバーが権威あるものであるにもかかわらず、クライアントがリクエストの意図されたターゲットではない可能性のあるサーバーにリクエストを送信できることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that does not wish clients to reuse connections can indicate that it is not authoritative for a request by sending a 421 (Misdirected Request) status code in response to the request (see Section 15.5.20 of [HTTP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントに接続を再利用することを望まないサーバーは、要求に応じて421（誤った要求）ステータスコードを送信することにより、要求に対して権威がないことを示すことができます（[HTTP]のセクション15.5.20を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client that is configured to use a proxy over HTTP/2 directs requests to that proxy through a single connection. That is, all requests sent via a proxy reuse the connection to the proxy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2を介してプロキシを使用するように構成されているクライアントは、単一の接続を介してそのプロキシにリクエストを指示します。つまり、プロキシを介して送信されたすべての要求は、プロキシへの接続を再利用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2--Use-of-TLS-Features">
9.2. Use of TLS Features
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. TLS機能の使用
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations of HTTP/2 MUST use TLS version 1.2 [TLS12] or higher for HTTP/2 over TLS. The general TLS usage guidance in [TLSBCP] SHOULD be followed, with some additional restrictions that are specific to HTTP/2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2の実装は、TLSを超えるHTTP/2に対してTLSバージョン1.2 [TLS12]以下を使用する必要があります。[TLSBCP]の一般的なTLS使用ガイダンスに従う必要があり、HTTP/2に固有の追加の制限があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS implementation MUST support the Server Name Indication (SNI) [TLS-EXT] extension to TLS. If the server is identified by a domain name [DNS-TERMS], clients MUST send the server_name TLS extension unless an alternative mechanism to indicate the target host is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS実装は、サーバー名表示（SNI）[TLS-EXT] TLSの拡張をサポートする必要があります。サーバーがドメイン名[DNS-TERMS]によって識別される場合、クライアントはターゲットホストを示すための代替メカニズムを使用しない限り、Server_Name TLS拡張機能を送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Requirements for deployments of HTTP/2 that negotiate TLS 1.3 [TLS13] are included in Section 9.2.3. Deployments of TLS 1.2 are subject to the requirements in Sections 9.2.1 and 9.2.2. Implementations are encouraged to provide defaults that comply, but it is recognized that deployments are ultimately responsible for compliance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS 1.3 [TLS13]を交渉するHTTP/2の展開の要件は、セクション9.2.3に含まれています。TLS 1.2の展開は、セクション9.2.1および9.2.2の要件の対象となります。実装は、準拠するデフォルトを提供することをお勧めしますが、展開は最終的にコンプライアンスに責任があることが認識されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2-1--TLS-1-2-Features">
9.2.1. TLS 1.2 Features
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.1. TLS 1.2機能
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes restrictions on the TLS 1.2 feature set that can be used with HTTP/2. Due to deployment limitations, it might not be possible to fail TLS negotiation when these restrictions are not met. An endpoint MAY immediately terminate an HTTP/2 connection that does not meet these TLS requirements with a connection error (Section 5.4.1) of type INADEQUATE_SECURITY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、HTTP/2で使用できるTLS 1.2機能セットの制限について説明します。展開の制限により、これらの制限が満たされない場合、TLS交渉に失敗することはできないかもしれません。エンドポイントは、タイプのInadequate_Securityの接続エラー（セクション5.4.1）でこれらのTLS要件を満たさないHTTP/2接続を直ちに終了する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A deployment of HTTP/2 over TLS 1.2 MUST disable compression. TLS compression can lead to the exposure of information that would not otherwise be revealed [RFC3749]. Generic compression is unnecessary, since HTTP/2 provides compression features that are more aware of context and therefore likely to be more appropriate for use for performance, security, or other reasons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS 1.2を介したHTTP/2の展開は、圧縮を無効にする必要があります。TLS圧縮は、そうでなければ明らかにされない情報の露出につながる可能性があります[RFC3749]。HTTP/2は、コンテキストをより認識しているため、パフォーマンス、セキュリティ、またはその他の理由で使用するためにより適切である可能性が高い圧縮機能を提供するため、一般的な圧縮は不要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A deployment of HTTP/2 over TLS 1.2 MUST disable renegotiation. An endpoint MUST treat a TLS renegotiation as a connection error (Section 5.4.1) of type PROTOCOL_ERROR. Note that disabling renegotiation can result in long-lived connections becoming unusable due to limits on the number of messages the underlying cipher suite can encipher.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS 1.2を介したHTTP/2の展開は、再交渉を無効にする必要があります。エンドポイントは、TLS再交渉をタイプProtocol_Errorの接続エラー（セクション5.4.1）として扱う必要があります。再交渉を無効にすると、基礎となる暗号スイートが吸収できるメッセージの数が制限されているため、長寿命の接続が使用できなくなる可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint MAY use renegotiation to provide confidentiality protection for client credentials offered in the handshake, but any renegotiation MUST occur prior to sending the connection preface. A server SHOULD request a client certificate if it sees a renegotiation request immediately after establishing a connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは再交渉を使用して、ハンドシェイクで提供されるクライアント資格情報の機密保護を提供する場合がありますが、接続序文を送信する前に再交渉は発生する必要があります。接続を確立した直後に再交渉リクエストが表示される場合、サーバーはクライアント証明書を要求する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This effectively prevents the use of renegotiation in response to a request for a specific protected resource. A future specification might provide a way to support this use case. Alternatively, a server might use an error (Section 5.4) of type HTTP_1_1_REQUIRED to request that the client use a protocol that supports renegotiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、特定の保護されたリソースの要求に応じて、再交渉の使用が効果的に防止されます。将来の仕様は、このユースケースをサポートする方法を提供する場合があります。あるいは、サーバーは、タイプhttp_1_1_requiredのエラー（セクション5.4）を使用して、クライアントが再交渉をサポートするプロトコルを使用するように要求する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MUST support ephemeral key exchange sizes of at least 2048 bits for cipher suites that use ephemeral finite field Diffie-Hellman (DHE) (Section 8.1.2 of [TLS12]) and 224 bits for cipher suites that use ephemeral elliptic curve Diffie-Hellman (ECDHE) [RFC8422]. Clients MUST accept DHE sizes of up to 4096 bits. Endpoints MAY treat negotiation of key sizes smaller than the lower limits as a connection error (Section 5.4.1) of type INADEQUATE_SECURITY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、一時的な有限フィールドdiffie-hellman（DHE）（[TLS12]のセクション8.1.2）および一時的な楕円曲線拡散曲線diffie-hellmanmanmanmanmanmanmanmanmanmanmanmanmanmanmanmanの224ビット（DHE）（[TLS12]のセクション8.1.2）を使用する暗号スイートの少なくとも2048ビットの短命キー交換サイズをサポートする必要があります。（ECDHE）[RFC8422]。クライアントは、最大4096ビットのDHEサイズを受け入れる必要があります。エンドポイントは、タイプのInadequate_Securityの接続エラー（セクション5.4.1）として、下限よりも小さいキーサイズの交渉を扱う場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2-2--TLS-1-2-Cipher-Suites">
9.2.2. TLS 1.2 Cipher Suites
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.2. TLS 1.2暗号スイート
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A deployment of HTTP/2 over TLS 1.2 SHOULD NOT use any of the prohibited cipher suites listed in Appendix A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS 1.2を介したHTTP/2の展開は、付録Aにリストされている禁止された暗号スイートのいずれを使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints MAY choose to generate a connection error (Section 5.4.1) of type INADEQUATE_SECURITY if one of the prohibited cipher suites is negotiated. A deployment that chooses to use a prohibited cipher suite risks triggering a connection error unless the set of potential peers is known to accept that cipher suite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、禁止されている暗号スイートのいずれかが交渉された場合、タイプInadequate_Securityの接続エラー（セクション5.4.1）を生成することを選択できます。潜在的なピアのセットがその暗号スイートを受け入れることが知られていない限り、禁止されている暗号スイートリスクを使用することを選択する展開。接続エラーをトリガーする。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MUST NOT generate this error in reaction to the negotiation of a cipher suite that is not prohibited. Consequently, when clients offer a cipher suite that is not prohibited, they have to be prepared to use that cipher suite with HTTP/2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、禁止されていない暗号スイートの交渉に反応してこのエラーを生成してはなりません。その結果、クライアントが禁止されていない暗号スイートを提供する場合、HTTP/2でその暗号スイートを使用する準備をする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The list of prohibited cipher suites includes the cipher suite that TLS 1.2 makes mandatory, which means that TLS 1.2 deployments could have non-intersecting sets of permitted cipher suites. To avoid this problem, which causes TLS handshake failures, deployments of HTTP/2 that use TLS 1.2 MUST support TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 [TLS-ECDHE] with the P-256 elliptic curve [RFC8422].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
禁止されている暗号スイートのリストには、TLS 1.2が必須になる暗号スイートが含まれています。つまり、TLS 1.2の展開には、許可された暗号スイートの非合成セットがあります。TLSハンドシェイクの障害を引き起こすこの問題を回避するために、TLS 1.2を使用するHTTP/2の展開は、P-256エリプティックカーブ[RFC8422]でTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 [TLS-ECDHE]をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that clients might advertise support of cipher suites that are prohibited in order to allow for connection to servers that do not support HTTP/2. This allows servers to select HTTP/1.1 with a cipher suite that is prohibited in HTTP/2. However, this can result in HTTP/2 being negotiated with a prohibited cipher suite if the application protocol and cipher suite are independently selected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、HTTP/2をサポートしていないサーバーへの接続を可能にするために、禁止されている暗号スイートのサポートを宣伝する可能性があることに注意してください。これにより、サーバーはHTTP/2で禁止されている暗号スイートでHTTP/1.1を選択できます。ただし、アプリケーションプロトコルと暗号スイートが独立して選択されている場合、これにより、HTTP/2が禁止された暗号スイートと交渉される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2-3--TLS-1-3-Features">
9.2.3. TLS 1.3 Features
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.3. TLS 1.3機能
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS 1.3 includes a number of features not available in earlier versions. This section discusses the use of these features.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS 1.3には、以前のバージョンでは利用できない多くの機能が含まれています。このセクションでは、これらの機能の使用について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 servers MUST NOT send post-handshake TLS 1.3 CertificateRequest messages. HTTP/2 clients MUST treat a TLS post-handshake CertificateRequest message as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2サーバーは、ポストハンドシェイクTLS 1.3のcermostaterequestメッセージを送信してはなりません。HTTP/2クライアントは、TLSポストハンドシェイクの証明書登録メッセージをタイプProtocol_Errorの接続エラー（セクション5.4.1）として扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The prohibition on post-handshake authentication applies even if the client offered the &#34;post_handshake_auth&#34; TLS extension. Post-handshake authentication support might be advertised independently of ALPN [TLS-ALPN]. Clients might offer the capability for use in other protocols, but inclusion of the extension cannot imply support within HTTP/2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポストハンドシェイク認証の禁止は、クライアントが「POST_HANDSHAKE_AUTH」TLS拡張機能を提供した場合でも適用されます。ポストハンドシェイク認証サポートは、ALPN [TLS-ALPN]とは無関係に宣伝される場合があります。クライアントは他のプロトコルで使用する機能を提供する場合がありますが、拡張機能を含めることはHTTP/2内でのサポートを意味することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS13] defines other post-handshake messages, NewSessionTicket and KeyUpdate, which can be used as they have no direct interaction with HTTP/2. Unless the use of a new type of TLS message depends on an interaction with the application-layer protocol, that TLS message can be sent after the handshake completes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS13]は、HTTP/2との直接的な相互作用がないために使用できる他のポストハンドシェイクメッセージ、NewsessionTicket、およびKeyUpDateを定義します。新しいタイプのTLSメッセージの使用がアプリケーション層プロトコルとの相互作用に依存しない限り、TLSメッセージをハンドシェイクが完了した後に送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS early data MAY be used to send requests, provided that the guidance in [RFC8470] is observed. Clients send requests in early data assuming initial values for all server settings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8470]のガイダンスが観察されていれば、TLSの初期データを使用してリクエストを送信することができます。クライアントは、すべてのサーバー設定の初期値を仮定して、初期データでリクエストを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--Security-Considerations">
10. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. セキュリティ上の考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of TLS is necessary to provide many of the security properties of this protocol. Many of the claims in this section do not hold unless TLS is used as described in Section 9.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSの使用は、このプロトコルの多くのセキュリティプロパティを提供するために必要です。このセクションの請求の多くは、セクション9.2で説明されているようにTLSが使用されない限り、保持されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-1--Server-Authority">
10.1. Server Authority
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. サーバー当局
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2 relies on the HTTP definition of authority for determining whether a server is authoritative in providing a given response (see Section 4.3 of [HTTP]). This relies on local name resolution for the &#34;http&#34; URI scheme and the authenticated server identity for the &#34;https&#34; scheme.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2は、サーバーが特定の応答を提供する上で権威あるかどうかを判断するための権限のHTTP定義に依存しています（[HTTP]のセクション4.3を参照）。これは、「HTTP」URIスキームのローカル名解像度と、「HTTPS」スキームの認証されたサーバーIDに依存しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-2--Cross-Protocol-Attacks">
10.2. Cross-Protocol Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. クロスプロトコル攻撃
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a cross-protocol attack, an attacker causes a client to initiate a transaction in one protocol toward a server that understands a different protocol. An attacker might be able to cause the transaction to appear as a valid transaction in the second protocol. In combination with the capabilities of the web context, this can be used to interact with poorly protected servers in private networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クロスプロトコル攻撃では、攻撃者により、クライアントは異なるプロトコルを理解しているサーバーに向かって1つのプロトコルでトランザクションを開始します。攻撃者は、2番目のプロトコルでトランザクションを有効なトランザクションとして表示できる可能性があります。Webコンテキストの機能と組み合わせて、これを使用して、プライベートネットワークで保護されていないサーバーと対話できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Completing a TLS handshake with an ALPN identifier for HTTP/2 can be considered sufficient protection against cross-protocol attacks. ALPN provides a positive indication that a server is willing to proceed with HTTP/2, which prevents attacks on other TLS-based protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2のALPN識別子でTLSの握手を完了することは、クロスプロトコル攻撃に対する十分な保護と見なすことができます。ALPNは、サーバーが他のTLSベースのプロトコルへの攻撃を防ぐHTTP/2を進める意思があることを肯定的な兆候を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The encryption in TLS makes it difficult for attackers to control the data that could be used in a cross-protocol attack on a cleartext protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSの暗号化により、攻撃者はクリアテキストプロトコルのクロスプロトコル攻撃で使用できるデータを制御することが困難になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cleartext version of HTTP/2 has minimal protection against cross-protocol attacks. The connection preface (Section 3.4) contains a string that is designed to confuse HTTP/1.1 servers, but no special protection is offered for other protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2のClearTextバージョンは、クロスプロトコル攻撃に対する保護を最小限に抑えています。接続序文（セクション3.4）には、HTTP/1.1サーバーを混同するように設計された文字列が含まれていますが、他のプロトコルには特別な保護は提供されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-3--Intermediary-Encapsulation-Attacks">
10.3. Intermediary Encapsulation Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3. 中間カプセル化攻撃
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HPACK permits encoding of field names and values that might be treated as delimiters in other HTTP versions. An intermediary that translates an HTTP/2 request or response MUST validate fields according to the rules in Section 8.2 before translating a message to another HTTP version. Translating a field that includes invalid delimiters could be used to cause recipients to incorrectly interpret a message, which could be exploited by an attacker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HPACKは、他のHTTPバージョンの区切り文字として扱われる可能性のあるフィールド名と値のエンコードを許可します。HTTP/2要求または応答を翻訳する仲介者は、メッセージを別のHTTPバージョンに翻訳する前に、セクション8.2のルールに従ってフィールドを検証する必要があります。無効な区切り文字を含むフィールドを翻訳することを使用して、受信者にメッセージを誤って解釈させます。これは攻撃者が悪用する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 8.2 does not include specific rules for validation of pseudo-header fields. If the values of these fields are used, additional validation is necessary. This is particularly important where &#34;:scheme&#34;, &#34;:authority&#34;, and &#34;:path&#34; are combined to form a single URI string [RFC3986]. Similar problems might occur when that URI or just &#34;:path&#34; is combined with &#34;:method&#34; to construct a request line (as in Section 3 of [HTTP/1.1]). Simple concatenation is not secure unless the input values are fully validated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション8.2には、擬似ヘッダーフィールドの検証に関する特定のルールは含まれていません。これらのフィールドの値を使用する場合、追加の検証が必要です。これは、「：スキーム」、「権威」、および「パス」が組み合わさって、単一のURI文字列[RFC3986]を形成する場合、特に重要です。同様の問題が、そのuriまたは単なる「：パス」が「：メソッド」と組み合わされて、[http/1.1]のセクション3のように）を構築する場合に同様の問題が発生する可能性があります。入力値が完全に検証されない限り、単純な連結は安全ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An intermediary can reject fields that contain invalid field names or values for other reasons -- in particular, those fields that do not conform to the HTTP ABNF grammar from Section 5 of [HTTP]. Intermediaries that do not perform any validation of fields other than the minimum required by Section 8.2 could forward messages that contain invalid field names or values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仲介者は、他の理由で無効なフィールド名または値を含むフィールド、特に[HTTP]セクション5からHTTP ABNF文法に適合しないフィールドを拒否できます。セクション8.2で必要な最小値以外のフィールドの検証を実行しない仲介者は、無効なフィールド名または値を含むメッセージを転送できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An intermediary that receives any fields that require removal before forwarding (see Section 7.6.1 of [HTTP]) MUST remove or replace those header fields when forwarding messages. Additionally, intermediaries should take care when forwarding messages containing Content-Length fields to ensure that the message is well-formed (Section 8.1.1). This ensures that if the message is translated into HTTP/1.1 at any point, the framing will be correct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送前に削除を必要とするフィールドを受信する仲介者（[http]のセクション7.6.1を参照）は、メッセージを転送する際にそれらのヘッダーフィールドを削除または交換する必要があります。さらに、メッセージが適切に形成されていることを確認するために、コンテンツレングスフィールドを含むメッセージを転送する際に仲介者が注意する必要があります（セクション8.1.1）。これにより、メッセージがいつでもhttp/1.1に変換されると、フレーミングが正しいことが保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-4--Cacheability-of-Pushed-Responses">
10.4. Cacheability of Pushed Responses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4. プッシュされた応答のカキアビリティ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pushed responses do not have an explicit request from the client; the request is provided by the server in the PUSH_PROMISE frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プッシュされた応答には、クライアントからの明示的な要求がありません。リクエストは、Push_Promiseフレームのサーバーによって提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Caching responses that are pushed is possible based on the guidance provided by the origin server in the Cache-Control header field. However, this can cause issues if a single server hosts more than one tenant. For example, a server might offer multiple users each a small portion of its URI space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プッシュされるキャッシュ応答は、キャッシュコントロールヘッダーフィールドでOrigin Serverが提供するガイダンスに基づいて可能です。ただし、単一のサーバーが複数のテナントをホストしている場合、これは問題を引き起こす可能性があります。たとえば、サーバーは、それぞれそれぞれURIスペースのごく一部を複数のユーザーに提供する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where multiple tenants share space on the same server, that server MUST ensure that tenants are not able to push representations of resources that they do not have authority over. Failure to enforce this would allow a tenant to provide a representation that would be served out of cache, overriding the actual representation that the authoritative tenant provides.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のテナントが同じサーバーでスペースを共有する場合、そのサーバーは、テナントが権限を持たないリソースの表現をプッシュできないことを確認する必要があります。これを実施しないと、テナントがキャッシュから提供される表現を提供し、権威あるテナントが提供する実際の表現を無効にすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pushed responses for which an origin server is not authoritative (see Section 10.1) MUST NOT be used or cached.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Origin Serverが信頼できるものではないプッシュされた応答（セクション10.1を参照）を使用またはキャッシュしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-5--Denial-of-Service-Considerations">
10.5. Denial-of-Service Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5. サービス拒否の考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An HTTP/2 connection can demand a greater commitment of resources to operate than an HTTP/1.1 connection. Both field section compression and flow control depend on a commitment of a greater amount of state. Settings for these features ensure that memory commitments for these features are strictly bounded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2接続は、HTTP/1.1接続よりも、動作するためのリソースのより大きなコミットメントを要求する場合があります。フィールドセクションの圧縮とフロー制御の両方が、より多くの状態のコミットメントに依存します。これらの機能の設定により、これらの機能のメモリコミットメントが厳密に制限されることが保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The number of PUSH_PROMISE frames is not constrained in the same fashion. A client that accepts server push SHOULD limit the number of streams it allows to be in the &#34;reserved (remote)&#34; state. An excessive number of server push streams can be treated as a stream error (Section 5.4.2) of type ENHANCE_YOUR_CALM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
push_promiseフレームの数は同じ方法で制約されていません。サーバーのプッシュを受け入れるクライアントは、「予約済み（リモート）」状態にあることができるストリームの数を制限する必要があります。過度の数のサーバープッシュストリームは、タイプenhance_your_calmのストリームエラー（セクション5.4.2）として扱うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number of HTTP/2 implementations were found to be vulnerable to denial of service [NFLX-2019-002]. Below is a list of known ways that implementations might be subject to denial-of-service attacks:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くのHTTP/2の実装は、サービスの拒否に対して脆弱であることがわかった[NFLX-2019-002]。以下は、実装がサービス拒否攻撃の対象となる可能性のある既知の方法のリストです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Inefficient tracking of outstanding outbound frames can lead to overload if an adversary can cause large numbers of frames to be enqueued for sending. A peer could use one of several techniques to cause large numbers of frames to be generated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 攻撃者が多数のフレームを送信するためにエンキューをする可能性がある場合、未解決のアウトバウンドフレームの非効率的な追跡は過負荷につながる可能性があります。ピアは、いくつかのテクニックの1つを使用して、多数のフレームを生成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Providing tiny increments to flow control in WINDOW_UPDATE frames can cause a sender to generate a large number of DATA frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- window_updateフレーム内のフロー制御のために小さな増分を提供すると、送信者が多数のデータフレームを生成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- An endpoint is required to respond to a PING frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Pingフレームに応答するには、エンドポイントが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Each SETTINGS frame requires acknowledgment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- 各設定フレームには、確認が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- An invalid request (or server push) can cause a peer to send RST_STREAM frames in response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- 無効な要求（またはサーバープッシュ）により、ピアがRST_STREAMフレームをそれに応じて送信する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* An attacker can provide large amounts of flow-control credit at the HTTP/2 layer but withhold credit at the TCP layer, preventing frames from being sent. An endpoint that constructs and remembers frames for sending without considering TCP limits might be subject to resource exhaustion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 攻撃者は、HTTP/2レイヤーで大量のフローコントロールクレジットを提供できますが、TCPレイヤーでクレジットを保留し、フレームが送信されないようにします。TCPの制限を考慮せずに送信するためのフレームを構築および覚えているエンドポイントは、リソースの疲労の影響を受ける可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Large numbers of small or empty frames can be abused to cause a peer to expend time processing frame headers. Caution is required here as some uses of small frames are entirely legitimate, such as the sending of an empty DATA or CONTINUATION frame at the end of a stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 多数の小型または空のフレームを乱用して、ピアが時間処理フレームヘッダーを消費することができます。ここでは、ストリームの終わりに空のデータや継続フレームの送信など、小さなフレームのいくつかの使用が完全に合法であるため、ここでは注意が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The SETTINGS frame might also be abused to cause a peer to expend additional processing time. This might be done by pointlessly changing settings, sending multiple undefined settings, or changing the same setting multiple times in the same frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 設定フレームは、ピアが追加の処理時間を消費するように乱用される可能性があります。これは、セットを無意味に変更したり、複数の未定義の設定を送信したり、同じ設定を同じフレームで複数回変更したりすることで実行される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Handling reprioritization with PRIORITY frames can require significant processing time and can lead to overload if many PRIORITY frames are sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 優先フレームでの再登録を処理するには、かなりの処理時間が必要になる場合があり、多くの優先フレームが送信されると過負荷につながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Field section compression also provides opportunities for an attacker to waste processing resources; see Section 7 of [COMPRESSION] for more details on potential abuses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* フィールドセクション圧縮は、攻撃者が処理リソースを無駄にする機会も提供します。潜在的な虐待の詳細については、[圧縮]のセクション7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Limits in SETTINGS cannot be reduced instantaneously, which leaves an endpoint exposed to behavior from a peer that could exceed the new limits. In particular, immediately after establishing a connection, limits set by a server are not known to clients and could be exceeded without being an obvious protocol violation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 設定の制限を瞬時に減らすことはできません。これにより、エンドポイントは、新しい制限を超える可能性のあるピアからの動作にさらされます。特に、接続を確立した直後に、サーバーによって設定された制限はクライアントに知られておらず、明らかなプロトコル違反にならずに超えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most of the features that might be exploited for denial of service -- such as SETTINGS changes, small frames, field section compression -- have legitimate uses. These features become a burden only when they are used unnecessarily or to excess.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定の変更、小型フレーム、フィールドセクション圧縮など、サービスの拒否のために悪用される可能性のある機能のほとんどには、正当な用途があります。これらの機能は、不必要に使用される場合、または過剰に使用される場合にのみ負担になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint that doesn&#39;t monitor use of these features exposes itself to a risk of denial of service. Implementations SHOULD track the use of these features and set limits on their use. An endpoint MAY treat activity that is suspicious as a connection error (Section 5.4.1) of type ENHANCE_YOUR_CALM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの機能の使用を監視しないエンドポイントは、サービスの拒否のリスクにさらされます。実装は、これらの機能の使用を追跡し、それらの使用に制限を設定する必要があります。エンドポイントは、タイプのentance_your_calmの接続エラー（セクション5.4.1）として疑わしいアクティビティを扱う場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-5-1--Limits-on-Field-Block-Size">
10.5.1. Limits on Field Block Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.1. フィールドブロックサイズの制限
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A large field block (Section 4.3) can cause an implementation to commit a large amount of state. Field lines that are critical for routing can appear toward the end of a field block, which prevents streaming of fields to their ultimate destination. This ordering and other reasons, such as ensuring cache correctness, mean that an endpoint might need to buffer the entire field block. Since there is no hard limit to the size of a field block, some endpoints could be forced to commit a large amount of available memory for field blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大きなフィールドブロック（セクション4.3）は、実装が大量の状態をコミットする可能性があります。ルーティングに重要なフィールドラインは、フィールドブロックの終わりに向かって表示される可能性があります。これにより、フィールドが最終目的地へのストリーミングを防ぎます。キャッシュの正確性を確保するなど、この順序やその他の理由は、エンドポイントがフィールドブロック全体をバッファリングする必要があることを意味します。フィールドブロックのサイズに厳しい制限がないため、一部のエンドポイントは、フィールドブロックに大量の利用可能なメモリをコミットすることを余儀なくされる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint can use the SETTINGS_MAX_HEADER_LIST_SIZE to advise peers of limits that might apply on the size of uncompressed field blocks. This setting is only advisory, so endpoints MAY choose to send field blocks that exceed this limit and risk the request or response being treated as malformed. This setting is specific to a connection, so any request or response could encounter a hop with a lower, unknown limit. An intermediary can attempt to avoid this problem by passing on values presented by different peers, but they are not obliged to do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、settings_max_header_list_sizeを使用して、非圧縮フィールドブロックのサイズに適用される可能性のある制限をピアにアドバイスすることができます。この設定はアドバイザリーのみであるため、エンドポイントはこの制限を超えるフィールドブロックを送信することを選択し、要求または応答が奇形として扱われる危険性があります。この設定は接続に固有のため、リクエストまたは応答は、より低い、未知の制限でホップに遭遇する可能性があります。仲介者は、異なるピアによって提示された値を渡すことでこの問題を回避しようとすることができますが、そうする義務はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that receives a larger field block than it is willing to handle can send an HTTP 431 (Request Header Fields Too Large) status code [RFC6585]. A client can discard responses that it cannot process. The field block MUST be processed to ensure a consistent connection state, unless the connection is closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
処理するよりも大きなフィールドブロックを受信するサーバーは、HTTP 431（リクエストヘッダーフィールドが大きすぎる）ステータスコード[RFC6585]を送信できます。クライアントは、処理できない応答を破棄できます。接続が閉じられない限り、一貫した接続状態を確保するために、フィールドブロックを処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-5-2--CONNECT-Issues">
10.5.2. CONNECT Issues
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.2. 問題を接続します
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CONNECT method can be used to create disproportionate load on a proxy, since stream creation is relatively inexpensive when compared to the creation and maintenance of a TCP connection. A proxy might also maintain some resources for a TCP connection beyond the closing of the stream that carries the CONNECT request, since the outgoing TCP connection remains in the TIME_WAIT state. Therefore, a proxy cannot rely on SETTINGS_MAX_CONCURRENT_STREAMS alone to limit the resources consumed by CONNECT requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Connectメソッドは、TCP接続の作成とメンテナンスと比較するとストリームの作成が比較的安価であるため、プロキシに不均衡な負荷を作成するために使用できます。Proxyは、発信TCP接続がTime_Wait状態に残っているため、Connect Requestを運ぶストリームの閉鎖を超えてTCP接続のリソースを維持する場合があります。したがって、プロキシはsettings_max_concurrent_streamsだけに依存して、接続要求によって消費されるリソースを制限することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-6--Use-of-Compression">
10.6. Use of Compression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.6. 圧縮の使用
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Compression can allow an attacker to recover secret data when it is compressed in the same context as data under attacker control. HTTP/2 enables compression of field lines (Section 4.3); the following concerns also apply to the use of HTTP compressed content-codings (Section 8.4.1 of [HTTP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮により、攻撃者は攻撃者制御下のデータと同じコンテキストで圧縮された場合、秘密データを回復することができます。HTTP/2は、フィールドラインの圧縮を有効にします（セクション4.3）。以下の懸念は、HTTP圧縮コンテンツコーディングの使用にも適用されます（[HTTP]のセクション8.4.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are demonstrable attacks on compression that exploit the characteristics of the Web (e.g., [BREACH]). The attacker induces multiple requests containing varying plaintext, observing the length of the resulting ciphertext in each, which reveals a shorter length when a guess about the secret is correct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Webの特性を活用する圧縮に対する実証可能な攻撃があります（例：[違反]）。攻撃者は、さまざまなプレーンテキストを含む複数のリクエストを誘導し、それぞれに結果の暗号文の長さを観察します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations communicating on a secure channel MUST NOT compress content that includes both confidential and attacker-controlled data unless separate compression dictionaries are used for each source of data. Compression MUST NOT be used if the source of data cannot be reliably determined. Generic stream compression, such as that provided by TLS, MUST NOT be used with HTTP/2 (see Section 9.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安全なチャネルで通信する実装は、データの各ソースに個別の圧縮辞書が使用されない限り、機密および攻撃者制御データの両方を含むコンテンツを圧縮してはなりません。データのソースを確実に決定できない場合、圧縮を使用しないでください。TLSによって提供されるような汎用ストリーム圧縮は、HTTP/2で使用してはなりません（セクション9.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Further considerations regarding the compression of header fields are described in [COMPRESSION].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフィールドの圧縮に関するさらなる考慮事項は、[圧縮]で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-7--Use-of-Padding">
10.7. Use of Padding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7. パディングの使用
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Padding within HTTP/2 is not intended as a replacement for general purpose padding, such as that provided by TLS [TLS13]. Redundant padding could even be counterproductive. Correct application can depend on having specific knowledge of the data that is being padded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2内のパディングは、TLS [TLS13]によって提供されるような、汎用パディングの代替として意図されていません。冗長なパディングは逆効果になる可能性があります。正しいアプリケーションは、パッドで塗られているデータの特定の知識を持つことに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To mitigate attacks that rely on compression, disabling or limiting compression might be preferable to padding as a countermeasure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮、無効化、または制限に依存する攻撃を緩和することは、対策としてパディングするよりも望ましい場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Padding can be used to obscure the exact size of frame content and is provided to mitigate specific attacks within HTTP -- for example, attacks where compressed content includes both attacker-controlled plaintext and secret data (e.g., [BREACH]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディングは、フレームコンテンツの正確なサイズを不明瞭にするために使用でき、HTTP内の特定の攻撃を緩和するために提供されます。たとえば、圧縮コンテンツには攻撃者制御されたプレーンテキストと秘密データの両方が含まれる攻撃（例：[違反]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of padding can result in less protection than might seem immediately obvious. At best, padding only makes it more difficult for an attacker to infer length information by increasing the number of frames an attacker has to observe. Incorrectly implemented padding schemes can be easily defeated. In particular, randomized padding with a predictable distribution provides very little protection; similarly, padding frame payloads to a fixed size exposes information as frame payload sizes cross the fixed-sized boundary, which could be possible if an attacker can control plaintext.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディングを使用すると、すぐに明らかに思えるよりも保護が少なくなる可能性があります。せいぜい、パディングは、攻撃者が観察しなければならないフレームの数を増やすことにより、攻撃者が長さの情報を推測することをより困難にするだけです。誤って実装されたパディングスキームは簡単に敗北する可能性があります。特に、予測可能な分布を備えたランダム化されたパディングは、ほとんど保護を提供しません。同様に、フレームのペイロードサイズが固定サイズの境界を越えると、パディングフレームのペイロードが固定サイズに情報を公開します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intermediaries SHOULD retain padding for DATA frames but MAY drop padding for HEADERS and PUSH_PROMISE frames. A valid reason for an intermediary to change the amount of padding of frames is to improve the protections that padding provides.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仲介者は、データフレームのパディングを保持する必要がありますが、ヘッダーやPush_promiseフレーム用のパディングをドロップする場合があります。仲介者がフレームのパディングの量を変更する正当な理由は、パディングが提供する保護を改善することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-8--Privacy-Considerations">
10.8. Privacy Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.8. プライバシーに関する考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several characteristics of HTTP/2 provide an observer an opportunity to correlate actions of a single client or server over time. These include the values of settings, the manner in which flow-control windows are managed, the way priorities are allocated to streams, the timing of reactions to stimulus, and the handling of any features that are controlled by settings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2のいくつかの特性は、オブザーバーに、単一のクライアントまたはサーバーのアクションを時間の経過とともに相関させる機会を提供します。これらには、設定の値、フロー制御ウィンドウの管理方法、優先順位がストリームに割り当てられる方法、刺激に対する反応のタイミング、および設定によって制御される機能の処理が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As far as these create observable differences in behavior, they could be used as a basis for fingerprinting a specific client, as defined in Section 3.2 of [PRIVACY].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらが動作の観察可能な違いを作成する限り、[プライバシー]のセクション3.2で定義されているように、特定のクライアントをフィンガープリントするための基礎として使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2&#39;s preference for using a single TCP connection allows correlation of a user&#39;s activity on a site. Reusing connections for different origins allows tracking across those origins.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一のTCP接続を使用するHTTP/2の好みにより、サイトでのユーザーのアクティビティの相関関係が可能になります。さまざまな起源の接続を再利用することで、それらの起源を追跡できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the PING and SETTINGS frames solicit immediate responses, they can be used by an endpoint to measure latency to their peer. This might have privacy implications in certain scenarios.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pingおよび設定は即時の応答を募集するため、エンドポイントで使用してピアへの遅延を測定できます。これは、特定のシナリオでプライバシーの影響を与える可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-9--Remote-Timing-Attacks">
10.9. Remote Timing Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.9. リモートタイミング攻撃
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Remote timing attacks extract secrets from servers by observing variations in the time that servers take when processing requests that use secrets. HTTP/2 enables concurrent request creation and processing, which can give attackers better control over when request processing commences. Multiple HTTP/2 requests can be included in the same IP packet or TLS record. HTTP/2 can therefore make remote timing attacks more efficient by eliminating variability in request delivery, leaving only request order and the delivery of responses as sources of timing variability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リモートタイミング攻撃は、サーバーが秘密を使用するリクエストを処理するときに取る時間のバリエーションを観察することにより、サーバーから秘密を抽出します。HTTP/2は、同時リクエストの作成と処理を有効にします。これにより、攻撃者は要求処理が開始されたときによりよく制御できます。複数のHTTP/2要求を同じIPパケットまたはTLSレコードに含めることができます。したがって、HTTP/2は、リクエスト配信のばらつきを排除することにより、リクエスト攻撃をより効率的にすることができ、リクエスト順序と回答の配信のみをタイミングの変動性のソースとして残すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ensuring that processing time is not dependent on the value of a secret is the best defense against any form of timing attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
処理時間が秘密の価値に依存しないことを保証することは、あらゆる形態のタイミング攻撃に対する最良の防御です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11--IANA-Considerations">
11. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. IANAの考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This revision of HTTP/2 marks the HTTP2-Settings header field and the h2c upgrade token, both defined in [RFC7540], as obsolete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2のこのリビジョンは、HTTP2-SettingsヘッダーフィールドとH2Cアップグレードトークンをマークします。どちらも[RFC7540]で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 11 of [RFC7540] registered the h2 and h2c ALPN identifiers along with the PRI HTTP method. RFC 7540 also established a registry for frame types, settings, and error codes. These registrations and registries apply to HTTP/2, but are not redefined in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7540]のセクション11では、PRI HTTPメソッドとともにH2およびH2C ALPN識別子を登録しました。RFC 7540は、フレームタイプ、設定、エラーコードのレジストリも確立しました。これらの登録と登録はHTTP/2に適用されますが、このドキュメントでは再定義されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has updated references to RFC 7540 in the following registries to refer to this document: &#34;TLS Application-Layer Protocol Negotiation (ALPN) Protocol IDs&#34;, &#34;HTTP/2 Frame Type&#34;, &#34;HTTP/2 Settings&#34;, &#34;HTTP/2 Error Code&#34;, and &#34;HTTP Method Registry&#34;. The registration of the PRI method has been updated to refer to Section 3.4; all other section numbers have not changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、次のレジストリでRFC 7540への参照を更新して、このドキュメントを参照しています：「TLSアプリケーションレイヤープロトコル交渉（ALPN）プロトコルID」、「HTTP/2フレームタイプ」、「HTTP/2設定」、「HTTP/2設定」エラーコード &#34;、および「httpメソッドレジストリ」。PRIメソッドの登録は、セクション3.4を参照するように更新されました。他のすべてのセクション番号は変更されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has changed the policy on those portions of the &#34;HTTP/2 Frame Type&#34; and &#34;HTTP/2 Settings&#34; registries that were reserved for Experimental Use in RFC 7540. These portions of the registries shall operate on the same policy as the remainder of each registry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、RFC 7540で実験的に使用するために予約されていた「HTTP/2フレームタイプ」および「HTTP/2設定」レジストリの部分に関するポリシーを変更しました。レジストリのこれらの部分は、残りのポリシーと同じポリシーで動作するものとします。各レジストリ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1--HTTP2-Settings-Header-Field-Registration">
11.1. HTTP2-Settings Header Field Registration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. HTTP2-Settingsヘッダーフィールド登録
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section marks the HTTP2-Settings header field registered by Section 11.5 of [RFC7540] in the &#34;Hypertext Transfer Protocol (HTTP) Field Name Registry&#34; as obsolete. This capability has been removed: see Section 3.1. The registration is updated to include the details as required by Section 18.4 of [HTTP]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、[RFC7540]のセクション11.5で登録されたHTTP2-Settingsヘッダーフィールドを、「HyperText Transfer Protocol（HTTP）フィールド名レジストリ」で時代遅れとしてマークします。この機能は削除されました。セクション3.1を参照してください。登録は更新され、[http]のセクション18.4で必要な詳細が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Field Name: HTTP2-Settings
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールド名：http2-settings
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Status: obsoleted
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステータス：廃止
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reference: Section 3.2.1 of [RFC7540]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参照：[RFC7540]のセクション3.2.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Comments: Obsolete; see Section 11.1 of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コメント：時代遅れ。このドキュメントのセクション11.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-2--The-h2c-Upgrade-Token">
11.2. The h2c Upgrade Token
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. H2Cアップグレードトークン
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section records the h2c upgrade token registered by Section 11.8 of [RFC7540] in the &#34;Hypertext Transfer Protocol (HTTP) Upgrade Token Registry&#34; as obsolete. This capability has been removed: see Section 3.1. The registration is updated as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、[RFC7540]のセクション11.8で登録されたH2Cアップグレードトークンを「HyperText Transfer Protocol（HTTP）アップグレードトークンレジストリ」に記録します。この機能は削除されました。セクション3.1を参照してください。登録は次のように更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Value: h2c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値：H2C
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Description: (OBSOLETE) Hypertext Transfer Protocol version 2 (HTTP/2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明：（廃止）ハイパーテキスト転送プロトコルバージョン2（http/2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Expected Version Tokens: None
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予想バージョントークン：なし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reference: Section 3.1 of this document
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参照：このドキュメントのセクション3.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12--References">
12. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. 参考文献
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-1--Normative-References">
12.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. 引用文献
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CACHING] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., &#34;HTTP Caching&#34;, STD 98, RFC 9111, DOI 10.17487/RFC9111, June 2022, &lt;https://www.rfc-editor.org/info/rfc9111&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[キャッシュ]フィールディング、R。、編、ノッティンガム、M.、編、J。レスケ、編、「HTTPキャッシュ」、STD 98、RFC 9111、DOI 10.17487/RFC9111、2022年6月、&lt;https：//www.rfc-editor.org/info/rfc9111&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[COMPRESSION] Peon, R. and H. Ruellan, &#34;HPACK: Header Compression for HTTP/2&#34;, RFC 7541, DOI 10.17487/RFC7541, May 2015, &lt;https://www.rfc-editor.org/info/rfc7541&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[圧縮] Peon、R。およびH. Ruellan、 &#34;HPack：HTTP/2のヘッダー圧縮、RFC 7541、DOI 10.17487/RFC7541、2015年5月&lt;https://www.rfc-editor.org/info/rfc7541&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[COOKIE] Barth, A., &#34;HTTP State Management Mechanism&#34;, RFC 6265, DOI 10.17487/RFC6265, April 2011, &lt;https://www.rfc-editor.org/info/rfc6265&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Cookie] Barth、A。、「HTTP状態管理メカニズム」、RFC 6265、DOI 10.17487/RFC6265、2011年4月、&lt;https://www.rfc-editor.org/info/rfc6265&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., &#34;HTTP Semantics&#34;, STD 97, RFC 9110, DOI 10.17487/RFC9110, June 2022, &lt;https://www.rfc-editor.org/info/rfc9110&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP] Fielding、R.、Ed。、Nottingham、M.、Ed。、およびJ. Reschke、ed。、 &#34;HTTP Semantics&#34;、Std 97、RFC 9110、DOI 10.17487/RFC9110、2022年6月、&lt;https：//www.rfc-editor.org/info/rfc9110&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[QUIC] Iyengar, J., Ed. and M. Thomson, Ed., &#34;QUIC: A UDP-Based Multiplexed and Secure Transport&#34;, RFC 9000, DOI 10.17487/RFC9000, May 2021, &lt;https://www.rfc-editor.org/info/rfc9000&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Quic] Iyengar、J.、ed。and M. Thomson、ed。、「Quic：UDPベースの多重化および安全な輸送」、RFC 9000、DOI 10.17487/RFC9000、2021年5月、&lt;https://www.rfc-editor.org/info/rfc9000&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487/RFC2119、1997年3月、&lt;https://www.rfc-editor.org/info/RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, &#34;Uniform Resource Identifier (URI): Generic Syntax&#34;, STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, &lt;https://www.rfc-editor.org/info/rfc3986&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3986] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、Std 66、RFC 3986、DOI 10.17487/RFC3986、2005年1月、&lt;https：//www.rfc-editor.org/info/rfc3986&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487/RFC8174、2017年5月、&lt;https：//www.rfc-editor.org/info/RFC8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8422] Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, &#34;Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier&#34;, RFC 8422, DOI 10.17487/RFC8422, August 2018, &lt;https://www.rfc-editor.org/info/rfc8422&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8422] Nir、Y.、Josefsson、S。、およびM. Pegourie-Gonnard、「輸送層セキュリティ（TLS）バージョン（TLS）バージョン用の楕円曲線暗号化（ECC）暗号スイート」、RFC 8422、DOI 10.17487/RFC8422、2018年8月、&lt;https://www.rfc-editor.org/info/rfc8422&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8470] Thomson, M., Nottingham, M., and W. Tarreau, &#34;Using Early Data in HTTP&#34;, RFC 8470, DOI 10.17487/RFC8470, September 2018, &lt;https://www.rfc-editor.org/info/rfc8470&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8470] Thomson、M.、Nottingham、M.、およびW. Tarreau、「HTTPで初期データを使用」、RFC 8470、DOI 10.17487/RFC8470、2018年9月、&lt;https://www.rfc-edtion.org/g/情報/RFC8470&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCP] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, &lt;https://www.rfc-editor.org/info/rfc793&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCP] Postel、J。、「伝送制御プロトコル」、STD 7、RFC 793、DOI 10.17487/RFC0793、1981年9月、&lt;https://www.rfc-editor.org/info/rfc793&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS-ALPN] Friedl, S., Popov, A., Langley, A., and E. Stephan, &#34;Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension&#34;, RFC 7301, DOI 10.17487/RFC7301, July 2014, &lt;https://www.rfc-editor.org/info/rfc7301&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS-Alpn] Friedl、S.、Popov、A.、Langley、A。、およびE. Stephan、「輸送層セキュリティ（TLS）アプリケーション層プロトコル交渉拡張」、RFC 7301、DOI 10.17487/RFC7301、2014年7月、&lt;https://www.rfc-editor.org/info/rfc7301&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS-ECDHE] Rescorla, E., &#34;TLS Elliptic Curve Cipher Suites with SHA-256/384 and AES Galois Counter Mode (GCM)&#34;, RFC 5289, DOI 10.17487/RFC5289, August 2008, &lt;https://www.rfc-editor.org/info/rfc5289&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS-Ecdhe] Rescorla、E。、「SHA-256/384およびAES Galoisカウンターモード（GCM）を備えたTLS楕円曲線暗号」、RFC 5289、DOI 10.17487/RFC5289、2008年8月、&lt;HTTPS：// WWW。rfc-editor.org/info/rfc5289&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS-EXT] Eastlake 3rd, D., &#34;Transport Layer Security (TLS) Extensions: Extension Definitions&#34;, RFC 6066, DOI 10.17487/RFC6066, January 2011, &lt;https://www.rfc-editor.org/info/rfc6066&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS-Ext] EastLake 3rd、D。、「輸送層セキュリティ（TLS）拡張：拡張定義」、RFC 6066、DOI 10.17487/RFC6066、2011年1月、&lt;https://www.rfc-editor.org/info/RFC6066&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS12] Dierks, T. and E. Rescorla, &#34;The Transport Layer Security (TLS) Protocol Version 1.2&#34;, RFC 5246, DOI 10.17487/RFC5246, August 2008, &lt;https://www.rfc-editor.org/info/rfc5246&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS12] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）プロトコルバージョン1.2」、RFC 5246、DOI 10.17487/RFC5246、2008年8月、&lt;https://www.rfc-editor.org/info/RFC5246&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS13] Rescorla, E., &#34;The Transport Layer Security (TLS) Protocol Version 1.3&#34;, RFC 8446, DOI 10.17487/RFC8446, August 2018, &lt;https://www.rfc-editor.org/info/rfc8446&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS13] Rescorla、E。、「輸送層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487/RFC8446、2018年8月、&lt;https://www.rfc-editor.org/info/rfc846&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLSBCP] Sheffer, Y., Holz, R., and P. Saint-Andre, &#34;Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)&#34;, BCP 195, RFC 7525, DOI 10.17487/RFC7525, May 2015, &lt;https://www.rfc-editor.org/info/rfc7525&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLSBCP] Sheffer、Y.、Holz、R。、およびP. Saint-Andre、「輸送層セキュリティ（TLS）およびデータグラム輸送層セキュリティ（DTLS）の安全な使用に関する推奨事項」、BCP 195、RFC 7525、DOI 10.17487/RFC7525、2015年5月、&lt;https://www.rfc-editor.org/info/rfc7525&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2--Informative-References">
12.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. 参考引用
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ALT-SVC] Nottingham, M., McManus, P., and J. Reschke, &#34;HTTP Alternative Services&#34;, RFC 7838, DOI 10.17487/RFC7838, April 2016, &lt;https://www.rfc-editor.org/info/rfc7838&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Alt-Svc] Nottingham、M.、McManus、P。、およびJ. Reschke、「HTTP代替サービス」、RFC 7838、DOI 10.17487/RFC7838、2016年4月、&lt;https://www.rfc-editor.org/情報/RFC7838&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BREACH] Gluck, Y., Harris, N., and A. Prado, &#34;BREACH: Reviving the CRIME Attack&#34;, 12 July 2013, &lt;https://breachattack.com/resources/ BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[違反] Gluck、Y.、Harris、N.、A。Prado、「違反：犯罪攻撃の復活」、2013年7月12日、&lt;https://breeachatcack.com/resources/ Breach％20-％20SSL、％20gone％20in％2030％20seconds.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DNS-TERMS] Hoffman, P., Sullivan, A., and K. Fujiwara, &#34;DNS Terminology&#34;, BCP 219, RFC 8499, DOI 10.17487/RFC8499, January 2019, &lt;https://www.rfc-editor.org/info/rfc8499&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DNS-TERMS] Hoffman、P.、Sullivan、A。、およびK. Fujiwara、「DNS用語」、BCP 219、RFC 8499、DOI 10.17487/RFC8499、2019年1月、&lt;https：//www.rfc-editor。org/info/rfc8499&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP-PRIORITY] Oku, K. and L. Pardue, &#34;Extensible Prioritization Scheme for HTTP&#34;, RFC 9218, DOI 10.17487/RFC9218, June 2022, &lt;https://www.rfc-editor.org/info/rfc9218&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP優先性] Oku、K。およびL. Pardue、「HTTPの拡張可能な優先順位付けスキーム」、RFC 9218、DOI 10.17487/RFC9218、2022年6月、&lt;https://www.rfc-editor.org/info/rfc9218&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP/1.1] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., &#34;HTTP/1.1&#34;, STD 99, RFC 9112, DOI 10.17487/RFC9112, June 2022, &lt;https://www.rfc-editor.org/info/rfc9112&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP/1.1] Fielding、R.、ed。、Nottingham、M.、ed。、およびJ. Reschke、ed。、 &#34;Http/1.1&#34;、Std 99、RFC 9112、DOI 10.17487/RFC9112、2022年6月、&lt;&lt;https://www.rfc-editor.org/info/rfc9112&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NFLX-2019-002] Netflix, &#34;HTTP/2 Denial of Service Advisory&#34;, 13 August 2019, &lt;https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NFLX-2019-002] Netflix、「HTTP/2サービスアドバイザリー拒否」、2019年8月13日、&lt;https://github.com/netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PRIVACY] Cooper, A., Tschofenig, H., Aboba, B., Peterson, J., Morris, J., Hansen, M., and R. Smith, &#34;Privacy Considerations for Internet Protocols&#34;, RFC 6973, DOI 10.17487/RFC6973, July 2013, &lt;https://www.rfc-editor.org/info/rfc6973&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[プライバシー] Cooper、A.、Tschofenig、H.、Aboba、B.、Peterson、J.、Morris、J.、Hansen、M。、およびR. Smith、「インターネットプロトコルのプライバシーに関する考慮事項」、RFC 6973、doi10.17487/rfc6973、2013年7月、&lt;https://www.rfc-editor.org/info/rfc6973&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122] Braden, R., Ed., &#34;Requirements for Internet Hosts - Communication Layers&#34;, STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, &lt;https://www.rfc-editor.org/info/rfc1122&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122] Braden、R.、ed。、「インターネットホストの要件 - 通信レイヤー」、STD 3、RFC 1122、DOI 10.17487/RFC1122、1989年10月、&lt;https://www.rfc-editor.org/info/RFC1122&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3749] Hollenbeck, S., &#34;Transport Layer Security Protocol Compression Methods&#34;, RFC 3749, DOI 10.17487/RFC3749, May 2004, &lt;https://www.rfc-editor.org/info/rfc3749&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3749] Hollenbeck、S。、「輸送層セキュリティプロトコル圧縮法」、RFC 3749、DOI 10.17487/RFC3749、2004年5月、&lt;https://www.rfc-editor.org/info/rfc3749&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6125] Saint-Andre, P. and J. Hodges, &#34;Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)&#34;, RFC 6125, DOI 10.17487/RFC6125, March 2011, &lt;https://www.rfc-editor.org/info/rfc6125&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6125] Saint-Andre、P。およびJ. Hodges、「輸送層のセキュリティ（TLS）のコンテキストでX.509（PKIX）証明書を使用したインターネット公開キーインフラストラクチャ内のドメインベースのアプリケーションサービスIDの表現と検証」、RFC 6125、DOI 10.17487/RFC6125、2011年3月、&lt;https://www.rfc-editor.org/info/rfc6125&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6585] Nottingham, M. and R. Fielding, &#34;Additional HTTP Status Codes&#34;, RFC 6585, DOI 10.17487/RFC6585, April 2012, &lt;https://www.rfc-editor.org/info/rfc6585&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6585]ノッティンガム、M。およびR.フィールディング、「追加のHTTPステータスコード」、RFC 6585、DOI 10.17487/RFC6585、2012年4月、&lt;https://www.rfc-editor.org/info/rfc6585&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7323] Borman, D., Braden, B., Jacobson, V., and R. Scheffenegger, Ed., &#34;TCP Extensions for High Performance&#34;, RFC 7323, DOI 10.17487/RFC7323, September 2014, &lt;https://www.rfc-editor.org/info/rfc7323&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7323] Borman、D.、Braden、B.、Jacobson、V.、およびR. Scheffenegger、ed。、「TCP拡張機能のためのTCP拡張」、RFC 7323、DOI 10.17487/RFC7323、2014年9月、&lt;https：/////////www.rfc-editor.org/info/rfc7323&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7540] Belshe, M., Peon, R., and M. Thomson, Ed., &#34;Hypertext Transfer Protocol Version 2 (HTTP/2)&#34;, RFC 7540, DOI 10.17487/RFC7540, May 2015, &lt;https://www.rfc-editor.org/info/rfc7540&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7540] Belshe、M.、Peon、R。、およびM. Thomson、ed。、「HyperText Transfer Protocolバージョン2（HTTP/2）」、RFC 7540、DOI 10.17487/RFC7540、2015年5月、&lt;https：///www.rfc-editor.org/info/rfc7540&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8441] McManus, P., &#34;Bootstrapping WebSockets with HTTP/2&#34;, RFC 8441, DOI 10.17487/RFC8441, September 2018, &lt;https://www.rfc-editor.org/info/rfc8441&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8441] McManus、P。、 &#34;HTTP/2でWebStrappetsをブートストラップするWebSocket、RFC 8441、DOI 10.17487/RFC8441、2018年9月、&lt;https://www.rfc-editor.org/info/rfc841&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8740] Benjamin, D., &#34;Using TLS 1.3 with HTTP/2&#34;, RFC 8740, DOI 10.17487/RFC8740, February 2020, &lt;https://www.rfc-editor.org/info/rfc8740&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8740]ベンジャミン、D。、「HTTP/2でTLS 1.3を使用して」、RFC 8740、DOI 10.17487/RFC8740、2020年2月、&lt;https://www.rfc-editor.org/info/rfc8740&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TALKING] Huang, L., Chen, E., Barth, A., Rescorla, E., and C. Jackson, &#34;Talking to Yourself for Fun and Profit&#34;, 2011, &lt;https://www.adambarth.com/papers/2011/huang-chen-barth-rescorla-jackson.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[話す] Huang、L.、Chen、E.、Barth、A.、Rescorla、E.、およびC. Jackson、「楽しみと利益のために自分自身に話しかける」、2011年、&lt;https://www.adambarth.com/papers/2011/huang-chen-barth-rescorla-jackson.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--Prohibited-TLS-1-2-Cipher-Suites">
Appendix A. Prohibited TLS 1.2 Cipher Suites
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A. TLS 1.2暗号スイートを禁止しました
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An HTTP/2 implementation MAY treat the negotiation of any of the following cipher suites with TLS 1.2 as a connection error (Section 5.4.1) of type INADEQUATE_SECURITY:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP/2の実装は、次の暗号スイートのいずれかの交渉を、TLS 1.2との交渉を、型の不自由な_securityの接続エラー（セクション5.4.1）として扱う可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* TLS_NULL_WITH_NULL_NULL * TLS_RSA_WITH_NULL_MD5 * TLS_RSA_WITH_NULL_SHA * TLS_RSA_EXPORT_WITH_RC4_40_MD5 * TLS_RSA_WITH_RC4_128_MD5 * TLS_RSA_WITH_RC4_128_SHA * TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 * TLS_RSA_WITH_IDEA_CBC_SHA * TLS_RSA_EXPORT_WITH_DES40_CBC_SHA * TLS_RSA_WITH_DES_CBC_SHA * TLS_RSA_WITH_3DES_EDE_CBC_SHA * TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA * TLS_DH_DSS_WITH_DES_CBC_SHA * TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA * TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA * TLS_DH_RSA_WITH_DES_CBC_SHA * TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA * TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA * TLS_DHE_DSS_WITH_DES_CBC_SHA * TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA * TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA * TLS_DHE_RSA_WITH_DES_CBC_SHA * TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA * TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 * TLS_DH_anon_WITH_RC4_128_MD5 * TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA * TLS_DH_anon_WITH_DES_CBC_SHA * TLS_DH_anon_WITH_3DES_EDE_CBC_SHA * TLS_KRB5_WITH_DES_CBC_SHA * TLS_KRB5_WITH_3DES_EDE_CBC_SHA * TLS_KRB5_WITH_RC4_128_SHA * TLS_KRB5_WITH_IDEA_CBC_SHA * TLS_KRB5_WITH_DES_CBC_MD5 * TLS_KRB5_WITH_3DES_EDE_CBC_MD5 * TLS_KRB5_WITH_RC4_128_MD5 * TLS_KRB5_WITH_IDEA_CBC_MD5 * TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA * TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA * TLS_KRB5_EXPORT_WITH_RC4_40_SHA * TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 * TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 * TLS_KRB5_EXPORT_WITH_RC4_40_MD5 * TLS_PSK_WITH_NULL_SHA * TLS_DHE_PSK_WITH_NULL_SHA * TLS_RSA_PSK_WITH_NULL_SHA * TLS_RSA_WITH_AES_128_CBC_SHA * TLS_DH_DSS_WITH_AES_128_CBC_SHA * TLS_DH_RSA_WITH_AES_128_CBC_SHA * TLS_DHE_DSS_WITH_AES_128_CBC_SHA * TLS_DHE_RSA_WITH_AES_128_CBC_SHA * TLS_DH_anon_WITH_AES_128_CBC_SHA * TLS_RSA_WITH_AES_256_CBC_SHA * TLS_DH_DSS_WITH_AES_256_CBC_SHA * TLS_DH_RSA_WITH_AES_256_CBC_SHA * TLS_DHE_DSS_WITH_AES_256_CBC_SHA * TLS_DHE_RSA_WITH_AES_256_CBC_SHA * TLS_DH_anon_WITH_AES_256_CBC_SHA * TLS_RSA_WITH_NULL_SHA256 * TLS_RSA_WITH_AES_128_CBC_SHA256 * TLS_RSA_WITH_AES_256_CBC_SHA256 * TLS_DH_DSS_WITH_AES_128_CBC_SHA256 * TLS_DH_RSA_WITH_AES_128_CBC_SHA256 * TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 * TLS_RSA_WITH_CAMELLIA_128_CBC_SHA * TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA * TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA * TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA * TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA * TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA * TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 * TLS_DH_DSS_WITH_AES_256_CBC_SHA256 * TLS_DH_RSA_WITH_AES_256_CBC_SHA256 * TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 * TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 * TLS_DH_anon_WITH_AES_128_CBC_SHA256 * TLS_DH_anon_WITH_AES_256_CBC_SHA256 * TLS_RSA_WITH_CAMELLIA_256_CBC_SHA * TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA * TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA * TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA * TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA * TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA * TLS_PSK_WITH_RC4_128_SHA * TLS_PSK_WITH_3DES_EDE_CBC_SHA * TLS_PSK_WITH_AES_128_CBC_SHA * TLS_PSK_WITH_AES_256_CBC_SHA * TLS_DHE_PSK_WITH_RC4_128_SHA * TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA * TLS_DHE_PSK_WITH_AES_128_CBC_SHA * TLS_DHE_PSK_WITH_AES_256_CBC_SHA * TLS_RSA_PSK_WITH_RC4_128_SHA * TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA * TLS_RSA_PSK_WITH_AES_128_CBC_SHA * TLS_RSA_PSK_WITH_AES_256_CBC_SHA * TLS_RSA_WITH_SEED_CBC_SHA * TLS_DH_DSS_WITH_SEED_CBC_SHA * TLS_DH_RSA_WITH_SEED_CBC_SHA * TLS_DHE_DSS_WITH_SEED_CBC_SHA * TLS_DHE_RSA_WITH_SEED_CBC_SHA * TLS_DH_anon_WITH_SEED_CBC_SHA * TLS_RSA_WITH_AES_128_GCM_SHA256 * TLS_RSA_WITH_AES_256_GCM_SHA384 * TLS_DH_RSA_WITH_AES_128_GCM_SHA256 * TLS_DH_RSA_WITH_AES_256_GCM_SHA384 * TLS_DH_DSS_WITH_AES_128_GCM_SHA256 * TLS_DH_DSS_WITH_AES_256_GCM_SHA384 * TLS_DH_anon_WITH_AES_128_GCM_SHA256 * TLS_DH_anon_WITH_AES_256_GCM_SHA384 * TLS_PSK_WITH_AES_128_GCM_SHA256 * TLS_PSK_WITH_AES_256_GCM_SHA384 * TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 * TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 * TLS_PSK_WITH_AES_128_CBC_SHA256 * TLS_PSK_WITH_AES_256_CBC_SHA384 * TLS_PSK_WITH_NULL_SHA256 * TLS_PSK_WITH_NULL_SHA384 * TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 * TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 * TLS_DHE_PSK_WITH_NULL_SHA256 * TLS_DHE_PSK_WITH_NULL_SHA384 * TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 * TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 * TLS_RSA_PSK_WITH_NULL_SHA256 * TLS_RSA_PSK_WITH_NULL_SHA384 * TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 * TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 * TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 * TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 * TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 * TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 * TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 * TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 * TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 * TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 * TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 * TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 * TLS_EMPTY_RENEGOTIATION_INFO_SCSV * TLS_ECDH_ECDSA_WITH_NULL_SHA * TLS_ECDH_ECDSA_WITH_RC4_128_SHA * TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA * TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA * TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA * TLS_ECDHE_ECDSA_WITH_NULL_SHA * TLS_ECDHE_ECDSA_WITH_RC4_128_SHA * TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA * TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA * TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA * TLS_ECDH_RSA_WITH_NULL_SHA * TLS_ECDH_RSA_WITH_RC4_128_SHA * TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA * TLS_ECDH_RSA_WITH_AES_128_CBC_SHA * TLS_ECDH_RSA_WITH_AES_256_CBC_SHA * TLS_ECDHE_RSA_WITH_NULL_SHA * TLS_ECDHE_RSA_WITH_RC4_128_SHA * TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA * TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA * TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA * TLS_ECDH_anon_WITH_NULL_SHA * TLS_ECDH_anon_WITH_RC4_128_SHA * TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA * TLS_ECDH_anon_WITH_AES_128_CBC_SHA * TLS_ECDH_anon_WITH_AES_256_CBC_SHA * TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA * TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA * TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA * TLS_SRP_SHA_WITH_AES_128_CBC_SHA * TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA * TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA * TLS_SRP_SHA_WITH_AES_256_CBC_SHA * TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA * TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA * TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 * TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 * TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 * TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 * TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 * TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 * TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 * TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 * TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 * TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 * TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 * TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 * TLS_ECDHE_PSK_WITH_RC4_128_SHA * TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA * TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA * TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA * TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 * TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 * TLS_ECDHE_PSK_WITH_NULL_SHA * TLS_ECDHE_PSK_WITH_NULL_SHA256 * TLS_ECDHE_PSK_WITH_NULL_SHA384 * TLS_RSA_WITH_ARIA_128_CBC_SHA256 * TLS_RSA_WITH_ARIA_256_CBC_SHA384 * TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 * TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 * TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 * TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 * TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 * TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 * TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 * TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 * TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 * TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 * TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 * TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 * TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 * TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 * TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 * TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 * TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 * TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 * TLS_RSA_WITH_ARIA_128_GCM_SHA256 * TLS_RSA_WITH_ARIA_256_GCM_SHA384 * TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 * TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 * TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 * TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 * TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 * TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 * TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 * TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 * TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 * TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 * TLS_PSK_WITH_ARIA_128_CBC_SHA256 * TLS_PSK_WITH_ARIA_256_CBC_SHA384 * TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 * TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 * TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 * TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 * TLS_PSK_WITH_ARIA_128_GCM_SHA256 * TLS_PSK_WITH_ARIA_256_GCM_SHA384 * TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 * TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 * TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 * TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 * TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 * TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 * TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 * TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 * TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 * TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 * TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 * TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 * TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 * TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 * TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 * TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 * TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 * TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 * TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 * TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 * TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 * TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 * TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 * TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 * TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 * TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 * TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 * TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 * TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 * TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 * TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 * TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 * TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 * TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 * TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 * TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 * TLS_RSA_WITH_AES_128_CCM * TLS_RSA_WITH_AES_256_CCM * TLS_RSA_WITH_AES_128_CCM_8 * TLS_RSA_WITH_AES_256_CCM_8 * TLS_PSK_WITH_AES_128_CCM * TLS_PSK_WITH_AES_256_CCM * TLS_PSK_WITH_AES_128_CCM_8 * TLS_PSK_WITH_AES_256_CCM_8
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* TLS_NULL_WITH_NULL_NULL * TLS_RSA_WITH_NULL_MD5 * TLS_RSA_WITH_NULL_SHA * TLS_RSA_EXPORT_WITH_RC4_40_MD5 * TLS_RSA_WITH_RC4_128_MD5 * TLS_RSA_WITH_RC4_128_SHA * TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 * TLS_RSA_WITH_IDEA_CBC_SHA * TLS_RSA_EXPORT_WITH_DES40_CBC_SHA * TLS_RSA_WITH_DES_CBC_SHA * TLS_RSA_WITH_3DES_EDE_CBC_SHA * TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA * TLS_DH_DSS_WITH_DES_CBC_SHA * TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA * TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA * TLS_DH_RSA_WITH_DES_CBC_SHA * TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA * TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA * TLS_DHE_DSS_WITH_DES_CBC_SHA * TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA * TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA * TLS_DHE_RSA_WITH_DES_CBC_SHA * TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA * TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 * TLS_DH_anon_WITH_RC4_128_MD5 * TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA * TLS_DH_anon_WITH_DES_CBC_SHA * TLS_DH_anon_WITH_3DES_EDE_CBC_SHA * TLS_KRB5_WITH_DES_CBC_SHA * TLS_KRB5_WITH_3DES_EDE_CBC_SHA * TLS_KRB5_WITH_RC4_128 _SHA * TLS_KRB5_WITH_IDEA_CBC_SHA * TLS_KRB5_WITH_DES_CBC_MD5 * TLS_KRB5_WITH_3DES_EDE_CBC_MD5 * TLS_KRB5_WITH_RC4_128_MD5 * TLS_KRB5_WITH_IDEA_CBC_MD5 * TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA * TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA * TLS_KRB5_EXPORT_WITH_RC4_40_SHA * TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 * TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 * TLS_KRB5_EXPORT_WITH_RC4_40_MD5 * TLS_PSK_WITH_NULL_SHA * TLS_DHE_PSK_WITH_NULL_SHA * TLS_RSA_PSK_WITH_NULL_SHA * TLS_RSA_WITH_AES_128_CBC_SHA * TLS_DH_DSS_WITH_AES_128_CBC_SHA * TLS_DH_RSA_WITH_AES_128_CBC_SHA * TLS_DHE_DSS_WITH_AES_128_CBC_SHA * TLS_DHE_RSA_WITH_AES_128_CBC_SHA * TLS_DH_anon_WITH_AES_128_CBC_SHA * TLS_RSA_WITH_AES_256_CBC_SHA * TLS_DH_DSS_WITH_AES_256_CBC_SHA * TLS_DH_RSA_WITH_AES_256_CBC_SHA * TLS_DHE_DSS_WITH_AES_256_CBC_SHA * TLS_DHE_RSA_WITH_AES_256_CBC_SHA * TLS_DH_anon_WITH_AES_256_CBC_SHA * TLS_RSA_WITH_NULL_SHA256 * TLS_RSA_WITH_AES_128_CBC_SHA256 * TLS_RSA_WITH_AES_256_CBC_SHA256 * TLS_DH_DSS_WITH_AES_128_CBC_SHA256 * TLS_DH _RSA_WITH_AES_128_CBC_SHA256 * TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 * TLS_RSA_WITH_CAMELLIA_128_CBC_SHA * TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA * TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA * TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA * TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA * TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA * TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 * TLS_DH_DSS_WITH_AES_256_CBC_SHA256 * TLS_DH_RSA_WITH_AES_256_CBC_SHA256 * TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 * TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 * TLS_DH_anon_WITH_AES_128_CBC_SHA256 * TLS_DH_anon_WITH_AES_256_CBC_SHA256 * TLS_RSA_WITH_CAMELLIA_256_CBC_SHA * TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA * TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA * TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA * TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA * TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA * TLS_PSK_WITH_RC4_128_SHA * TLS_PSK_WITH_3DES_EDE_CBC_SHA * TLS_PSK_WITH_AES_128_CBC_SHA * TLS_PSK_WITH_AES_256_CBC_SHA * tls_dhe_psk_with_rc4_128_sha * tls_dhe_psk_with_3des_ede_cbc_sha * tls_dhe_psk _WITH_AES_128_CBC_SHA * TLS_DHE_PSK_WITH_AES_256_CBC_SHA * TLS_RSA_PSK_WITH_RC4_128_SHA * TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA * TLS_RSA_PSK_WITH_AES_128_CBC_SHA * TLS_RSA_PSK_WITH_AES_256_CBC_SHA * TLS_RSA_WITH_SEED_CBC_SHA * TLS_DH_DSS_WITH_SEED_CBC_SHA * TLS_DH_RSA_WITH_SEED_CBC_SHA * TLS_DHE_DSS_WITH_SEED_CBC_SHA * TLS_DHE_RSA_WITH_SEED_CBC_SHA * TLS_DH_anon_WITH_SEED_CBC_SHA * TLS_RSA_WITH_AES_128_GCM_SHA256 * TLS_RSA_WITH_AES_256_GCM_SHA384 * TLS_DH_RSA_WITH_AES_128_GCM_SHA256 * TLS_DH_RSA_WITH_AES_256_GCM_SHA384 * TLS_DH_DSS_WITH_AES_128_GCM_SHA256 * TLS_DH_DSS_WITH_AES_256_GCM_SHA384 * TLS_DH_anon_WITH_AES_128_GCM_SHA256 * TLS_DH_anon_WITH_AES_256_GCM_SHA384 * TLS_PSK_WITH_AES_128_GCM_SHA256 * TLS_PSK_WITH_AES_256_GCM_SHA384 * TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 * TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 * TLS_PSK_WITH_AES_128_CBC_SHA256 * TLS_PSK_WITH_AES_256_CBC_SHA384 * TLS_PSK_WITH_NULL_SHA256 * TLS_PSK_WITH_NULL_SHA384 * TLS_DHE_PSK_WITH_AES_128_XBCBC_SHA256 * TLS_PSKITH_PHSE_PHSE_PHSE_PHSE_PHSE_PHITH_A 56_CBC_SHA384 * TLS_DHE_PSK_WITH_NULL_SHA256 * TLS_DHE_PSK_WITH_NULL_SHA384 * TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 * TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 * TLS_RSA_PSK_WITH_NULL_SHA256 * TLS_RSA_PSK_WITH_NULL_SHA384 * TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 * TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 * TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 * TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 * TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 * TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 * TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 * TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 * TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 * TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 * TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 * TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 * TLS_EMPTY_RENEGOTIATION_INFO_SCSV * TLS_ECDH_ECDSA_WITH_NULL_SHA * TLS_ECDH_ECDSA_WITH_RC4_128_SHA * TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA * TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA * TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA * tls_ecdhe_ecdsa_with_null_sha * tls_ecdhe_ecdsa_with_rc4_128_sha
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
 Note: This list was assembled from the set of registered TLS cipher suites when [RFC7540] was developed. This list includes those cipher suites that do not offer an ephemeral key exchange and those that are based on the TLS null, stream, or block cipher type (as defined in Section 6.2.3 of [TLS12]). Additional cipher suites with these properties could be defined; these would not be explicitly prohibited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
注：[RFC7540]が開発されたとき、このリストは登録されたTLS暗号スイートのセットから組み立てられました。このリストには、一時的なキーエクスチェンジを提供しない暗号スイートと、TLSヌル、ストリーム、またはブロック暗号タイプに基づいたスイート（[TLS12]のセクション6.2.3で定義されている）が含まれます。これらのプロパティを備えた追加の暗号スイートを定義できます。これらは明示的に禁止されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For more details, see Section 9.2.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
詳細については、セクション9.2.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-B--Changes-from-RFC-7540">
Appendix B. Changes from RFC 7540
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録B. RFC 7540からの変更
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This revision includes the following substantive changes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この改訂には、次の実質的な変更が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Use of TLS 1.3 was defined based on [RFC8740], which this document obsoletes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* TLS 1.3の使用は、[RFC8740]に基づいて定義されました。この文書は廃止されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The priority scheme defined in RFC 7540 is deprecated. Definitions for the format of the PRIORITY frame and the priority fields in the HEADERS frame have been retained, plus the rules governing when PRIORITY frames can be sent and received, but the semantics of these fields are only described in RFC 7540. The priority signaling scheme from RFC 7540 was not successful. Using the simpler signaling in [HTTP-PRIORITY] is recommended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* RFC 7540で定義されている優先スキームは非推奨です。優先順位フレームの形式とヘッダーフレームの優先フィールドの定義が保持されています。さらに、優先順位フレームを送信および受信できる場合に管理する規則がありますが、これらのフィールドのセマンティクスはRFC 7540でのみ説明されています。RFCから7540は成功しませんでした。[http-priority]でより単純なシグナル伝達を使用することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The HTTP/1.1 Upgrade mechanism is deprecated and no longer specified in this document. It was never widely deployed, with plaintext HTTP/2 users choosing to use the prior-knowledge implementation instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* HTTP/1.1アップグレードメカニズムは非推奨であり、このドキュメントでは指定されなくなりました。プレーンテキストHTTP/2ユーザーが代わりに事前知識実装を使用することを選択しているため、広く展開されることはありませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Validation for field names and values has been narrowed. The validation that is mandatory for intermediaries is precisely defined, and error reporting for requests has been amended to encourage sending 400-series status codes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* フィールド名と値の検証は狭くなっています。仲介者に必須の検証は正確に定義されており、リクエストのエラーレポートが修正され、400シリーズのステータスコードの送信が促進されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The ranges of codepoints for settings and frame types that were reserved for Experimental Use are now available for general use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 実験的に使用するために予約されていた設定とフレームタイプのコードポイントの範囲が一般的に使用できるようになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Connection-specific header fields -- which are prohibited -- are more precisely and comprehensively identified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 禁止されている接続固有のヘッダーフィールドは、より正確かつ包括的に識別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Host and &#34;:authority&#34; are no longer permitted to disagree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ホストと「：権威」は、もはや同意しないことは許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Rules for sending Dynamic Table Size Update instructions after changes in settings have been clarified in Section 4.3.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 設定の変更後の動的テーブルサイズの更新手順を送信するためのルールは、セクション4.3.1で明確にされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Editorial changes are also included. In particular, changes to terminology and document structure are in response to updates to core HTTP semantics [HTTP]. Those documents now include some concepts that were first defined in RFC 7540, such as the 421 status code or connection coalescing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
編集上の変更も含まれています。特に、用語とドキュメント構造の変更は、Core HTTPセマンティクス[HTTP]の更新に応じています。これらのドキュメントには、421ステータスコードや接続合体など、RFC 7540で最初に定義されたいくつかの概念が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Credit for non-trivial input to this document is owed to a large number of people who have contributed to the HTTP Working Group over the years. [RFC7540] contains a more extensive list of people that deserve acknowledgment for their contributions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントへの自明でない入力のクレジットは、長年にわたってHTTPワーキンググループに貢献してきた多くの人々に義務付けられています。[RFC7540]には、貢献に承認に値する人々のより広範なリストが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Contributors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
貢献者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mike Belshe and Roberto Peon authored the text that this document is based on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mike BelsheとRoberto Peonは、このドキュメントが基づいているテキストを作成しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Martin Thomson (editor) Mozilla Australia Email: mt@lowentropy.net
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Martin Thomson（編集者）Mozilla Australiaメール：mt@lowentropy.net
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cory Benfield (editor) Apple Inc. Email: cbenfield@apple.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cory Benfield（Editor）Apple Inc.メール：cbenfield@apple.com
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
