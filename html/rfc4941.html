<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 4941 - Privacy Extensions for Stateless Address Autoconfiguration in IPv6 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">4941</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc4941">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 4941 - Privacy Extensions for Stateless Address Autoconfiguration in IPv6 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc4941">
            https://datatracker.ietf.org/doc/html/rfc4941
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 4941 - IPv6におけるステートレスアドレスAutoconfigurationのプライバシー拡張</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <h6 class="card-title">要約（自動生成）</h6>
            <p class="card-text">RFC 4941は、IPv6の状態を持たないアドレス自動設定のためのプライバシー拡張に関するものであり、一時的なIPv6アドレスを使用してユーザーのプライバシーを保護することを目的としています。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                          T. Narten
Request for Comments: 4941                               IBM Corporation
Obsoletes: 3041                                                R. Draves
Category: Standards Track                             Microsoft Research
                                                             S. Krishnan
                                                       Ericsson Research
                                                          September 2007
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Privacy Extensions for Stateless Address Autoconfiguration in IPv6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6におけるステートレスアドレスAutoconfigurationのプライバシー拡張
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nodes use IPv6 stateless address autoconfiguration to generate addresses using a combination of locally available information and information advertised by routers. Addresses are formed by combining network prefixes with an interface identifier. On an interface that contains an embedded IEEE Identifier, the interface identifier is typically derived from it. On other interface types, the interface identifier is generated through other means, for example, via random number generation. This document describes an extension to IPv6 stateless address autoconfiguration for interfaces whose interface identifier is derived from an IEEE identifier. Use of the extension causes nodes to generate global scope addresses from interface identifiers that change over time, even in cases where the interface contains an embedded IEEE identifier. Changing the interface identifier (and the global scope addresses generated from it) over time makes it more difficult for eavesdroppers and other information collectors to identify when different addresses used in different transactions actually correspond to the same node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードは、IPv6のステートレスアドレスAutoconfigurationを使用して、ローカルで利用可能な情報とルーターによって宣伝された情報の組み合わせを使用してアドレスを生成します。アドレスは、ネットワークプレフィックスとインターフェイス識別子を組み合わせることによって形成されます。埋め込まれたIEEE識別子を含むインターフェイスでは、通常、インターフェイス識別子はそれから導出されます。他のインターフェイスタイプでは、インターフェイス識別子は、たとえば乱数の生成など、他の手段によって生成されます。このドキュメントでは、インターフェイス識別子がIEEE識別子から派生したインターフェイスのIPv6 StatelessアドレスアドレスAutoconfigurationの拡張について説明します。拡張機能を使用すると、ノードは、インターフェイスに埋め込みIEEE識別子が含まれている場合でも、時間とともに変化するインターフェイス識別子からグローバルスコープアドレスを生成します。インターフェイス識別子（およびそれから生成されたグローバルスコープアドレス）を時間の経過とともに変更すると、盗聴者やその他の情報コレクターが異なるトランザクションで使用される異なるアドレスが実際に同じノードに対応する場合を識別することがより困難になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
     1.1.  Conventions Used in This Document  . . . . . . . . . . . .  4
     1.2.  Problem Statement  . . . . . . . . . . . . . . . . . . . .  4
   2.  Background . . . . . . . . . . . . . . . . . . . . . . . . . .  5
     2.1.  Extended Use of the Same Identifier  . . . . . . . . . . .  5
     2.2.  Address Usage in IPv4 Today  . . . . . . . . . . . . . . .  6
     2.3.  The Concern with IPv6 Addresses  . . . . . . . . . . . . .  7
     2.4.  Possible Approaches  . . . . . . . . . . . . . . . . . . .  8
   3.  Protocol Description . . . . . . . . . . . . . . . . . . . . .  9
     3.1.  Assumptions  . . . . . . . . . . . . . . . . . . . . . . . 10
     3.2.  Generation of Randomized Interface Identifiers . . . . . . 10
       3.2.1.  When Stable Storage Is Present . . . . . . . . . . . . 11
       3.2.2.  In The Absence of Stable Storage . . . . . . . . . . . 12
       3.2.3.  Alternate Approaches . . . . . . . . . . . . . . . . . 12
     3.3.  Generating Temporary Addresses . . . . . . . . . . . . . . 13
     3.4.  Expiration of Temporary Addresses  . . . . . . . . . . . . 14
     3.5.  Regeneration of Randomized Interface Identifiers . . . . . 15
     3.6.  Deployment Considerations  . . . . . . . . . . . . . . . . 16
   4.  Implications of Changing Interface Identifiers . . . . . . . . 17
   5.  Defined Constants  . . . . . . . . . . . . . . . . . . . . . . 18
   6.  Future Work  . . . . . . . . . . . . . . . . . . . . . . . . . 18
   7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 19
   8.  Significant Changes from RFC 3041  . . . . . . . . . . . . . . 19
   9.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 20
   10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 20
     10.1. Normative References . . . . . . . . . . . . . . . . . . . 20
     10.2. Informative References . . . . . . . . . . . . . . . . . . 20
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateless address autoconfiguration [ADDRCONF] defines how an IPv6 node generates addresses without the need for a Dynamic Host Configuration Protocol for IPv6 (DHCPv6) server. Some types of network interfaces come with an embedded IEEE Identifier (i.e., a link-layer MAC address), and in those cases, stateless address autoconfiguration uses the IEEE identifier to generate a 64-bit interface identifier [ADDRARCH]. By design, the interface identifier is likely to be globally unique when generated in this fashion. The interface identifier is in turn appended to a prefix to form a 128-bit IPv6 address. Note that an IPv6 identifier does not necessarily have to be 64 bits in length, but the algorithm specified in this document is targeted towards 64-bit interface identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateless Address Autoconfiguration [addRConf]は、IPv6（DHCPV6）サーバーの動的ホスト構成プロトコルを必要とせずにIPv6ノードがアドレスを生成する方法を定義します。一部のタイプのネットワークインターフェイスには、埋め込まれたIEEE識別子（つまり、リンク層MACアドレス）が搭載されており、そのような場合、Stateless Address AutoconfigurationはIEEE識別子を使用して64ビットインターフェイス識別子[AddRarch]を生成します。設計上、この方法で生成された場合、インターフェイス識別子はグローバルに一意になる可能性があります。インターフェイス識別子は、128ビットIPv6アドレスを形成するプレフィックスに順番に追加されます。IPv6識別子の長さは必ずしも64ビットである必要はありませんが、このドキュメントで指定されているアルゴリズムは64ビットインターフェイス識別子をターゲットにしていることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All nodes combine interface identifiers (whether derived from an IEEE identifier or generated through some other technique) with the reserved link-local prefix to generate link-local addresses for their attached interfaces. Additional addresses can then be created by combining prefixes advertised in Router Advertisements via Neighbor Discovery [DISCOVERY] with the interface identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのノードは、インターフェイス識別子（IEEE識別子から派生したか、他の手法を介して生成されたかどうかにかかわらず）と予約されたリンクローカルプレフィックスを組み合わせて、添付のインターフェイスのリンクローカルアドレスを生成します。次に、Neighbor Discovery [Discovery]とインターフェイス識別子を介してルーター広告で宣伝されている接頭辞を組み合わせて、追加のアドレスを作成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Not all nodes and interfaces contain IEEE identifiers. In such cases, an interface identifier is generated through some other means (e.g., at random), and the resultant interface identifier may not be globally unique and may also change over time. The focus of this document is on addresses derived from IEEE identifiers because tracking of individual devices, the concern being addressed here, is possible only in those cases where the interface identifier is globally unique and non-changing. The rest of this document assumes that IEEE identifiers are being used, but the techniques described may also apply to interfaces with other types of globally unique and/or persistent identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのノードとインターフェイスにIEEE識別子が含まれているわけではありません。このような場合、インターフェイス識別子は他の手段（ランダムに）を通じて生成され、結果のインターフェイス識別子はグローバルに一意ではなく、時間とともに変化する場合があります。このドキュメントの焦点は、IEEE識別子から派生したアドレスにあります。なぜなら、個々のデバイスの追跡は、懸念がここで対処されていることは、インターフェイス識別子がグローバルに一意で変化していない場合にのみ可能であるためです。このドキュメントの残りの部分は、IEEE識別子が使用されていることを前提としていますが、説明されている手法は、他のタイプのグローバルな一意および/または永続的な識別子とのインターフェイスにも適用される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document discusses concerns associated with the embedding of non-changing interface identifiers within IPv6 addresses and describes extensions to stateless address autoconfiguration that can help mitigate those concerns for individual users and in environments where such concerns are significant. Section 2 provides background information on the issue. Section 3 describes a procedure for generating alternate interface identifiers and global scope addresses. Section 4 discusses implications of changing interface identifiers. The term &#34;global scope addresses&#34; is used in this document to collectively refer to &#34;Global unicast addresses&#34; as defined in [ADDRARCH] and &#34;Unique local addresses&#34; as defined in [ULA].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、IPv6アドレスに変更されていないインターフェイス識別子の埋め込みに関連する懸念について説明し、個々のユーザーやそのような懸念が重要である環境に対するこれらの懸念を軽減するのに役立つステートレスアドレスのオートコンフィギュレーションへの拡張を説明します。セクション2では、問題に関する背景情報を示します。セクション3では、代替インターフェイス識別子とグローバルスコープアドレスを生成する手順について説明します。セクション4では、インターフェイス識別子の変更の意味について説明します。「グローバルスコープアドレス」という用語は、このドキュメントで使用されて、[addrarch]で定義されている「グローバルユニキャストアドレス」と[ULA]で定義されている「一意のローカルアドレス」を集合的に参照しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-1--Conventions-Used-in-This-Document">
1.1. Conventions Used in This Document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. このドキュメントで使用されている規則
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「必須」、「そうしない」、「必須」、「shall」、「shall &#34;、&#34; ingle &#34;、&#34; should &#34;、&#34; not &#34;、&#34; becommended &#34;、&#34; bay &#34;、および「optional」は、[RFC2119]に記載されているように解釈される。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-2--Problem-Statement">
1.2. Problem Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. 問題文
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Addresses generated using stateless address autoconfiguration [ADDRCONF] contain an embedded interface identifier, which remains constant over time. Anytime a fixed identifier is used in multiple contexts, it becomes possible to correlate seemingly unrelated activity using this identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Statelessアドレスを使用して生成されたアドレスAutoconfiguration [addRConf]には、組み込みインターフェイス識別子が含まれています。固定識別子が複数のコンテキストで使用されるときはいつでも、この識別子を使用して、一見無関係なアクティビティを相関させることが可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The correlation can be performed by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相関はによって実行できます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An attacker who is in the path between the node in question and the peer(s) to which it is communicating, and who can view the IPv6 addresses present in the datagrams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 問題のノードと通信しているピアの間のパスにいる攻撃者、およびデータグラムに存在するIPv6アドレスを表示できる人。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An attacker who can access the communication logs of the peers with which the node has communicated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ノードが通信したピアの通信ログにアクセスできる攻撃者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the identifier is embedded within the IPv6 address, which is a fundamental requirement of communication, it cannot be easily hidden. This document proposes a solution to this issue by generating interface identifiers that vary over time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
識別子は、通信の基本的な要件であるIPv6アドレスに埋め込まれているため、簡単に隠すことはできません。このドキュメントは、時間とともに変化するインターフェイス識別子を生成することにより、この問題の解決策を提案します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that an attacker, who is on path, may be able to perform significant correlation based on
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パスにいる攻撃者は、に基づいて重要な相関を実行できる可能性があることに注意してください
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The payload contents of the packets on the wire
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ワイヤー上のパケットのペイロードコンテンツ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The characteristics of the packets such as packet size and timing
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o パケットサイズやタイミングなどのパケットの特性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of temporary addresses will not prevent such payload-based correlation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一時的なアドレスを使用しても、このようなペイロードベースの相関が妨げられません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Background">
2. Background
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 背景
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section discusses the problem in more detail, provides context for evaluating the significance of the concerns in specific environments and makes comparisons with existing practices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、問題をより詳細に説明し、特定の環境での懸念の重要性を評価するためのコンテキストを提供し、既存のプラクティスと比較します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1--Extended-Use-of-the-Same-Identifier">
2.1. Extended Use of the Same Identifier
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. 同じ識別子の拡張使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of a non-changing interface identifier to form addresses is a specific instance of the more general case where a constant identifier is reused over an extended period of time and in multiple independent activities. Any time the same identifier is used in multiple contexts, it becomes possible for that identifier to be used to correlate seemingly unrelated activity. For example, a network sniffer placed strategically on a link across which all traffic to/ from a particular host crosses could keep track of which destinations a node communicated with and at what times. Such information can in some cases be used to infer things, such as what hours an employee was active, when someone is at home, etc. Although it might appear that changing an address regularly in such environments would be desirable to lessen privacy concerns, it should be noted that the network prefix portion of an address also serves as a constant identifier. All nodes at, say, a home, would have the same network prefix, which identifies the topological location of those nodes. This has implications for privacy, though not at the same granularity as the concern that this document addresses. Specifically, all nodes within a home could be grouped together for the purposes of collecting information. If the network contains a very small number of nodes, say, just one, changing just the interface identifier will not enhance privacy at all, since the prefix serves as a constant identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非変更インターフェイス識別子を使用するためにアドレスを形成することは、長期間にわたって一定の識別子が再利用され、複数の独立したアクティビティで再利用されるより一般的なケースの特定のインスタンスです。同じ識別子が複数のコンテキストで使用されるときはいつでも、その識別子を使用して、一見無関係なアクティビティを相関させることが可能になります。たとえば、ネットワークスニファーは、特定のホストクロスとの間のすべてのトラフィックが、どの宛先がどのような宛先と通信したかを追跡できるリンクに戦略的に配置されました。このような情報は、場合によっては、従業員が何時間であるか、誰かが自宅にいるときなど、物事を推測するために使用できます。アドレスのネットワークプレフィックス部分は、定数識別子としても機能することに注意する必要があります。たとえば、ホームのすべてのノードには、同じネットワークプレフィックスがあり、これらのノードのトポロジカル位置を識別します。これはプライバシーに影響を与えますが、このドキュメントが対処する懸念と同じ粒度ではありません。具体的には、家庭内のすべてのノードは、情報を収集する目的でグループ化できます。ネットワークに非常に少数のノードが含まれている場合、たとえば1つだけで、接頭辞が一定の識別子として機能するため、インターフェイス識別子のみを変更してもプライバシーはまったく強化されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One of the requirements for correlating seemingly unrelated activities is the use (and reuse) of an identifier that is recognizable over time within different contexts. IP addresses provide one obvious example, but there are more. Many nodes also have DNS names associated with their addresses, in which case the DNS name serves as a similar identifier. Although the DNS name associated with an address is more work to obtain (it may require a DNS query), the information is often readily available. In such cases, changing the address on a machine over time would do little to address the concerns raised in this document, unless the DNS name is changed as well (see Section 4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一見無関係な活動を相関させるための要件の1つは、異なるコンテキスト内で時間とともに認識できる識別子の使用（および再利用）です。IPアドレスは1つの明白な例を提供しますが、それ以上あります。多くのノードには、アドレスに関連付けられたDNS名もあります。その場合、DNS名は同様の識別子として機能します。アドレスに関連付けられたDNS名は、取得するためのより多くの作業ですが（DNSクエリが必要になる場合があります）、情報は容易に入手できます。そのような場合、DNS名も変更されない限り、時間の経過とともにマシンのアドレスを変更すると、このドキュメントで提起された懸念に対処することはほとんどありません（セクション4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Web browsers and servers typically exchange &#34;cookies&#34; with each other [COOKIES]. Cookies allow Web servers to correlate a current activity with a previous activity. One common usage is to send back targeted advertising to a user by using the cookie supplied by the browser to identify what earlier queries had been made (e.g., for what type of information). Based on the earlier queries, advertisements can be targeted to match the (assumed) interests of the end user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、Webブラウザーとサーバーは「Cookie」を互いに交換します[Cookie]。Cookieにより、Webサーバーは現在のアクティビティを以前のアクティビティと相関させることができます。一般的な使用法の1つは、ブラウザから提供されたCookieを使用して、以前のクエリが作成されたものを識別することにより、ユーザーにターゲット広告を送り返すことです（たとえば、どのような種類の情報についても）。以前のクエリに基づいて、広告はエンドユーザーの（想定される）関心と一致するようにターゲットにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of a constant identifier within an address is of special concern because addresses are a fundamental requirement of communication and cannot easily be hidden from eavesdroppers and other parties. Even when higher layers encrypt their payloads, addresses in packet headers appear in the clear. Consequently, if a mobile host (e.g., laptop) accessed the network from several different locations, an eavesdropper might be able to track the movement of that mobile host from place to place, even if the upper layer payloads were encrypted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アドレス内での一定の識別子の使用は、コミュニケーションの基本的な要件であり、盗聴者や他の関係者から簡単に隠すことはできないため、特別な懸念事項があります。上位層がペイロードを暗号化する場合でも、パケットヘッダーのアドレスがクリアに表示されます。その結果、モバイルホスト（ラップトップなど）がいくつかの異なる場所からネットワークにアクセスした場合、上層のペイロードが暗号化されていても、盗聴者はそのモバイルホストの移動を場所から場所へと追跡できる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2--Address-Usage-in-IPv4-Today">
2.2. Address Usage in IPv4 Today
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. 今日のIPv4でのアドレスの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Addresses used in today&#39;s Internet are often non-changing in practice for extended periods of time. In an increasing number of sites, addresses are assigned statically and typically change infrequently. Over the last few years, sites have begun moving away from static allocation to dynamic allocation via DHCP [DHCP]. In theory, the address a client gets via DHCP can change over time, but in practice servers often return the same address to the same client (unless addresses are in such short supply that they are reused immediately by a different node when they become free). Thus, even within sites using DHCP, clients frequently end up using the same address for weeks to months at a time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
今日のインターネットで使用されるアドレスは、多くの場合、実際には長期間にわたって変化していません。ますます多くのサイトで、アドレスは静的に割り当てられ、通常はまれに変化します。ここ数年、サイトは静的割り当てからDHCP [DHCP]を介した動的割り当てへの移行を開始しました。理論的には、クライアントがDHCPを介して取得するアドレスは時間とともに変化する可能性がありますが、実際にはサーバーは同じクライアントに同じアドレスを返すことがよくあります（アドレスが無料になったときに別のノードによってすぐに再利用されるような不足している場合を除きます）。したがって、DHCPを使用しているサイト内であっても、クライアントは一度に数週間から数ヶ月間同じアドレスを使用することがよくあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For home users accessing the Internet over dial-up lines, the situation is generally different. Such users do not have permanent connections and are often assigned temporary addresses each time they connect to their ISP. Consequently, the addresses they use change frequently over time and are shared among a number of different users. Thus, an address does not reliably identify a particular device over time spans of more than a few minutes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ダイヤルアップラインでインターネットにアクセスするホームユーザーの場合、状況は一般的に異なります。そのようなユーザーには永続的な接続がなく、ISPに接続するたびに一時的なアドレスが割り当てられることがよくあります。その結果、使用するアドレスは時間とともに頻繁に変更され、さまざまなユーザーの間で共有されます。したがって、アドレスは、数分以上の時間の経過とともに特定のデバイスを確実に識別しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A more interesting case concerns always-on connections (e.g., cable modems, ISDN, DSL, etc.) that result in a home site using the same address for extended periods of time. This is a scenario that is just starting to become common in IPv4 and promises to become more of a concern as always-on Internet connectivity becomes widely available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
より興味深いケースは、常に同じアドレスを長時間使用してホームサイトを作成する、常にオンの接続（ケーブルモデム、ISDN、DSLなど）に関係しています。これは、IPv4で一般的になり始めたばかりのシナリオであり、常にインターネット接続が広く利用可能になるため、より懸念になることを約束します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, it should be noted that nodes that need a (non-changing) DNS name generally have static addresses assigned to them to simplify the configuration of DNS servers. Although Dynamic DNS [DDNS] can be used to update the DNS dynamically, it may not always be available depending on the administrative policy. In addition, changing an address but keeping the same DNS name does not really address the underlying concern, since the DNS name becomes a non-changing identifier. Servers generally require a DNS name (so clients can connect to them), and clients often do as well (e.g., some servers refuse to speak to a client whose address cannot be mapped into a DNS name that also maps back into the same address). Section 4 describes one approach to this issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、（変化しない）DNS名を必要とするノードには、一般に、DNSサーバーの構成を簡素化するためにそれらに割り当てられた静的アドレスが含まれていることに注意してください。動的DNS [DDN]を使用してDNSを動的に更新できますが、管理ポリシーに応じて常に利用できるとは限りません。さらに、アドレスを変更しますが、同じDNS名を保持しても、DNS名が非変更識別子になるため、実際には根本的な懸念に対処しません。サーバーは通常、DNS名（クライアントがそれらに接続できるように）を必要とし、クライアントも同様に行うことがよくあります（たとえば、一部のサーバーは、同じアドレスも同じアドレスにマッピングするDNS名にマッピングできないクライアントと話すことを拒否します）。セクション4では、この問題に対する1つのアプローチについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3--The-Concern-with-IPv6-Addresses">
2.3. The Concern with IPv6 Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. IPv6アドレスの懸念
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The division of IPv6 addresses into distinct topology and interface identifier portions raises an issue new to IPv6 in that a fixed portion of an IPv6 address (i.e., the interface identifier) can contain an identifier that remains constant even when the topology portion of an address changes (e.g., as the result of connecting to a different part of the Internet). In IPv4, when an address changes, the entire address (including the local part of the address) usually changes. It is this new issue that this document addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6アドレスの分割は、IPv6アドレスの固定部分（つまり、インターフェイス識別子）の固定部分が、アドレスのトポロジ部分が変更された場合でも一定のままである識別子を含めることができるという点で、IPv6に新しい問題を提起します。（たとえば、インターネットの別の部分に接続した結果として）。IPv4では、アドレスが変更されると、アドレス全体（アドレスのローカル部分を含む）が通常変更されます。このドキュメントが対処するのはこの新しい問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If addresses are generated from an interface identifier, a home user&#39;s address could contain an interface identifier that remains the same from one dial-up session to the next, even if the rest of the address changes. The way PPP is used today, however, PPP servers typically unilaterally inform the client what address they are to use (i.e., the client doesn&#39;t generate one on its own). This practice, if continued in IPv6, would avoid the concerns that are the focus of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アドレスがインターフェイス識別子から生成された場合、ホームユーザーのアドレスには、残りのアドレスが変更されたとしても、1つのダイヤルアップセッションから次のセッションまで同じままのインターフェイス識別子を含めることができます。しかし、PPPの使用方法は、通常、PPPサーバーが通常、どのアドレスを使用するかをクライアントに通知します（つまり、クライアントはそれ自体でそれを生成しません）。このプラクティスは、IPv6で継続された場合、このドキュメントの焦点である懸念を回避します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A more troubling case concerns mobile devices (e.g., laptops, PDAs, etc.) that move topologically within the Internet. Whenever they move, they form new addresses for their current topological point of attachment. This is typified today by the &#34;road warrior&#34; who has Internet connectivity both at home and at the office. While the node&#39;s address changes as it moves, the interface identifier contained within the address remains the same (when derived from an IEEE Identifier). In such cases, the interface identifier can be used to track the movement and usage of a particular machine. For example, a server that logs usage information together with source addresses, is also recording the interface identifier since it is embedded within an address. Consequently, any data-mining technique that correlates activity based on addresses could easily be extended to do the same using the interface identifier. This is of particular concern with the expected proliferation of next-generation network-connected devices (e.g., PDAs, cell phones, etc.) in which large numbers of devices are, in practice, associated with individual users (i.e., not shared). Thus, the interface identifier embedded within an address could be used to track activities of an individual, even as they move topologically within the Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
より厄介なケースは、インターネット内でトポロジカルに移動するモバイルデバイス（ラップトップ、PDAなど）に関するものです。彼らが動くたびに、彼らは彼らの現在のトポロジカルな愛着のために新しいアドレスを形成します。これは今日、自宅とオフィスの両方でインターネット接続を持っている「ロードウォリアー」によって代表されています。ノードのアドレスが移動すると変化しますが、アドレス内に含まれるインターフェイス識別子は同じままです（IEEE識別子から派生した場合）。このような場合、インターフェイス識別子を使用して、特定のマシンの動きと使用を追跡できます。たとえば、ソースアドレスと一緒に使用情報を記録するサーバーは、アドレスに埋め込まれているため、インターフェイス識別子も記録しています。その結果、アドレスに基づいてアクティビティを相関させるデータマイニング手法は、インターフェイス識別子を使用して同じことを行うように簡単に拡張できます。これは、多くのデバイスが実際には個々のユーザーに関連付けられている（つまり、共有されていない）、次世代ネットワーク接続デバイス（PDA、携帯電話など）の予想される増殖に特に懸念されています。したがって、アドレスに埋め込まれたインターフェイス識別子は、インターネット内でトポロジカルに移動する場合でも、個人のアクティビティを追跡するために使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In summary, IPv6 addresses on a given interface generated via Stateless Autoconfiguration contain the same interface identifier, regardless of where within the Internet the device connects. This facilitates the tracking of individual devices (and thus, potentially, users). The purpose of this document is to define mechanisms that eliminate this issue in those situations where it is a concern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要約すると、Stateless Autoconfigurationを介して生成された特定のインターフェイス上のIPv6アドレスは、デバイスが接続するインターネット内の場所に関係なく、同じインターフェイス識別子を含んでいます。これにより、個々のデバイス（したがって、ユーザー）の追跡が容易になります。このドキュメントの目的は、懸念事項である状況でこの問題を排除するメカニズムを定義することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-4--Possible-Approaches">
2.4. Possible Approaches
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. 考えられるアプローチ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One way to avoid having a static non-changing address is to use DHCPv6 [DHCPV6] for obtaining addresses. Section 12 of [DHCPV6] discusses the use of DHCPv6 for the assignment and management of &#34;temporary addresses&#34;, which are never renewed and provide the same property of temporary addresses described in this document with regards to the privacy concern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的な非変更アドレスを持つことを避ける1つの方法は、アドレスを取得するためにDHCPV6 [DHCPV6]を使用することです。[DHCPV6]のセクション12では、「一時的な住所」の割り当てと管理にDHCPV6の使用について説明します。これは、プライバシーの懸念に関してこのドキュメントに記載されている一時アドレスの同じプロパティを提供することはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another approach, compatible with the stateless address autoconfiguration architecture, would be to change the interface identifier portion of an address over time and generate new addresses from the interface identifier for some address scopes. Changing the interface identifier can make it more difficult to look at the IP addresses in independent transactions and identify which ones actually correspond to the same node, both in the case where the routing prefix portion of an address changes and when it does not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateless Address Autoconfigurationアーキテクチャと互換性のある別のアプローチは、アドレスのインターフェイス識別子部分を時間の経過とともに変更し、一部のアドレススコープのインターフェイス識別子から新しいアドレスを生成することです。インターフェイス識別子を変更すると、独立したトランザクションのIPアドレスを見ることがより困難になり、アドレスのルーティングプレフィックス部分が変更された場合とそうでない場合の両方で、実際に同じノードに対応するものを識別することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many machines function as both clients and servers. In such cases, the machine would need a DNS name for its use as a server. Whether the address stays fixed or changes has little privacy implication since the DNS name remains constant and serves as a constant identifier. When acting as a client (e.g., initiating communication), however, such a machine may want to vary the addresses it uses. In such environments, one may need multiple addresses: a &#34;public&#34; (i.e., non-secret) server address, registered in the DNS, that is used to accept incoming connection requests from other machines, and a &#34;temporary&#34; address used to shield the identity of the client when it initiates communication. These two cases are roughly analogous to telephone numbers and caller ID, where a user may list their telephone number in the public phone book, but disable the display of its number via caller ID when initiating calls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くのマシンは、クライアントとサーバーの両方として機能します。そのような場合、マシンはサーバーとして使用するためにDNS名が必要です。DNS名が一定であり、一定の識別子として機能するため、アドレスが固定されたままであるか変更はプライバシーの意味合いがほとんどありません。ただし、クライアントとして（たとえば、コミュニケーションを開始する）場合、そのようなマシンは、使用するアドレスを変更したい場合があります。このような環境では、DNSに登録されている「パブリック」（つまり、非秘密）サーバーアドレス、他のマシンからの着信接続要求を受け入れるために使用される複数のアドレスが必要になる場合があります。クライアントがコミュニケーションを開始したときのアイデンティティ。これらの2つのケースは、電話番号と発信者IDにほぼ類似しています。ユーザーは、電話番号に電話番号をリストすることができますが、電話を開始するときに発信者IDを介してその番号の表示を無効にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To make it difficult to make educated guesses as to whether two different interface identifiers belong to the same node, the algorithm for generating alternate identifiers must include input that has an unpredictable component from the perspective of the outside entities that are collecting information. Picking identifiers from a pseudo-random sequence suffices, so long as the specific sequence cannot be determined by an outsider examining information that is readily available or easily determinable (e.g., by examining packet contents). This document proposes the generation of a pseudo-random sequence of interface identifiers via an MD5 hash. Periodically, the next interface identifier in the sequence is generated, a new set of temporary addresses is created, and the previous temporary addresses are deprecated to discourage their further use. The precise pseudo-random sequence depends on both a random component and the globally unique interface identifier (when available), to increase the likelihood that different nodes generate different sequences.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つの異なるインターフェイス識別子が同じノードに属しているかどうかについて教育を受けた推測をすることを困難にするために、代替識別子を生成するためのアルゴリズムには、情報を収集している外部エンティティの観点から予測不可能なコンポーネントを持つ入力を含める必要があります。擬似ランダムシーケンスからの識別子を選択すると、特定のシーケンスが容易に利用可能または簡単に決定可能な情報を調べる（パケットコンテンツを調べることによって）情報を調べることによって決定できない限り、十分です。このドキュメントでは、MD5ハッシュを介した界面識別子の擬似ランダムシーケンスの生成を提案します。定期的に、シーケンス内の次のインターフェイス識別子が生成され、一時的なアドレスの新しいセットが作成され、以前の一時アドレスが廃止され、さらなる使用が妨げられます。正確な擬似ランダムシーケンスは、ランダムコンポーネントとグローバルに一意のインターフェイス識別子（利用可能な場合）の両方に依存し、異なるノードが異なるシーケンスを生成する可能性を高めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Protocol-Description">
3. Protocol Description
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. プロトコルの説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goal of this section is to define procedures that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションの目標は、次の手順を定義することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Do not result in any changes to the basic behavior of addresses generated via stateless address autoconfiguration [ADDRCONF].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. ステートレスアドレスAutoconfiguration [addrconf]を介して生成されたアドレスの基本的な動作に変更が生じないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Create additional addresses based on a random interface identifier for the purpose of initiating outgoing sessions. These &#34;random&#34; or temporary addresses would be used for a short period of time (hours to days) and would then be deprecated. Deprecated address can continue to be used for already established connections, but are not used to initiate new connections. New temporary addresses are generated periodically to replace temporary addresses that expire, with the exact time between address generation a matter of local policy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 発信セッションを開始する目的で、ランダムインターフェイス識別子に基づいて追加のアドレスを作成します。これらの「ランダム」または一時的な住所は、短期間（数時間から日）に使用され、その後非推奨になります。非推奨住所は、すでに確立された接続に使用され続けることができますが、新しい接続の開始には使用されません。新しい一時的なアドレスが定期的に生成され、期限が切れる一時的なアドレスを置き換え、住所生成の間の正確な時間はローカルポリシーの問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Produce a sequence of temporary global scope addresses from a sequence of interface identifiers that appear to be random in the sense that it is difficult for an outside observer to predict a future address (or identifier) based on a current one, and it is difficult to determine previous addresses (or identifiers) knowing only the present one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 外部の観察者が現在のアドレスに基づいて将来のアドレス（または識別子）を予測することが困難であるという意味でランダムであると思われる一連のインターフェイス識別子から一時的なグローバルスコープアドレスのシーケンスを生成します。現在のアドレスのみを知っている以前のアドレス（または識別子）を決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. By default, generate a set of addresses from the same (randomized) interface identifier, one address for each prefix for which a global address has been generated via stateless address autoconfiguration. Using the same interface identifier to generate a set of temporary addresses reduces the number of IP multicast groups a host must join. Nodes join the solicited-node multicast address for each unicast address they support, and solicited-node addresses are dependent only on the low-order bits of the corresponding address. This default behavior was made to address the concern that a node that joins a large number of multicast groups may be required to put its interface into promiscuous mode, resulting in possible reduced performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. デフォルトでは、同じ（ランダム化された）インターフェイス識別子からのアドレスのセットを生成します。これは、ステートレスアドレスAutoconfigurationを介してグローバルアドレスが生成された各プレフィックスの1つのアドレスです。同じインターフェイス識別子を使用して一時的なアドレスのセットを生成すると、ホストが結合する必要があるIPマルチキャストグループの数が減ります。ノードは、サポートするユニキャストアドレスごとに勧誘されたノードマルチキャストアドレスを結合し、勧誘されたノードアドレスは、対応するアドレスの低次ビットにのみ依存します。このデフォルトの動作は、インターフェイスを無差別モードにするために多数のマルチキャストグループに結合するノードが必要になる可能性があるという懸念に対処するために行われ、パフォーマンスが低下する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
A node highly concerned about privacy MAY use different interface identifiers on different prefixes, resulting in a set of global addresses that cannot be easily tied to each other. For example a node MAY create different interface identifiers I1, I2, and I3 for use with different prefixes P1, P2, and P3 on the same interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
プライバシーを非常に懸念するノードは、異なるプレフィックスで異なるインターフェイス識別子を使用して、互いに簡単に結び付けることができない一連のグローバルアドレスをもたらす場合があります。たとえば、ノードは、同じインターフェイスで異なるプレフィックスP1、P2、およびP3で使用するために、異なるインターフェイス識別子I1、I2、およびI3を作成する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Assumptions">
3.1. Assumptions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 仮定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following algorithm assumes that each interface maintains an associated randomized interface identifier. When temporary addresses are generated, the current value of the associated randomized interface identifier is used. While the same identifier can be used to create more than one temporary address, the value SHOULD change over time as described in Section 3.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のアルゴリズムは、各インターフェイスが関連するランダム化インターフェイス識別子を維持することを前提としています。一時的なアドレスが生成されると、関連するランダム化界面識別子の現在の値が使用されます。同じ識別子を使用して複数の一時アドレスを作成することができますが、セクション3.5で説明されているように、値は時間の経過とともに変化するはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm also assumes that, for a given temporary address, an implementation can determine the prefix from which it was generated. When a temporary address is deprecated, a new temporary address is generated. The specific valid and preferred lifetimes for the new address are dependent on the corresponding lifetime values set for the prefix from which it was generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、アルゴリズムは、特定の一時的なアドレスについて、実装が生成されたプレフィックスを決定できることを想定しています。一時的な住所が廃止されると、新しい一時アドレスが生成されます。新しいアドレスの特定の有効な寿命は、生成されたプレフィックスに設定された対応する寿命値に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, this document assumes that when a node initiates outgoing communication, temporary addresses can be given preference over public addresses when the device is configured to do so. [ADDR_SELECT] mandates implementations to provide a mechanism, which allows an application to configure its preference for temporary addresses over public addresses. It also allows for an implementation to prefer temporary addresses by default, so that the connections initiated by the node can use temporary addresses without requiring application-specific enablement. This document also assumes that an API will exist that allows individual applications to indicate whether they prefer to use temporary or public addresses and override the system defaults.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、このドキュメントでは、ノードが発信通信を開始すると、デバイスが設定されている場合に一時的なアドレスがパブリックアドレスよりも優先されることを前提としています。[addr_select]は、メカニズムを提供するための実装を義務付けます。これにより、アプリケーションは、パブリックアドレスよりも一時的なアドレスに対する優先権を構成できます。また、実装がデフォルトで一時的なアドレスを優先することを可能にするため、ノードによって開始された接続がアプリケーション固有の有効化を必要とせずに一時アドレスを使用できます。また、このドキュメントでは、個々のアプリケーションが一時的なアドレスまたはパブリックアドレスを使用し、システムのデフォルトをオーバーライドすることを好むかどうかを示すAPIが存在することを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--Generation-of-Randomized-Interface-Identifiers">
3.2. Generation of Randomized Interface Identifiers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. ランダム化界面識別子の生成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We describe two approaches for the generation and maintenance of the randomized interface identifier. The first assumes the presence of stable storage that can be used to record state history for use as input into the next iteration of the algorithm across system restarts. A second approach addresses the case where stable storage is unavailable and there is a need to generate randomized interface identifiers without previous state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ランダム化インターフェイス識別子の生成と維持に関する2つのアプローチについて説明します。最初のものは、システム全体のアルゴリズムの次の反復への入力として使用する状態履歴を記録するために使用できる安定したストレージの存在を想定しています。2番目のアプローチは、安定したストレージが利用できない場合に対処し、以前の状態なしでランダム化インターフェイス識別子を生成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The random interface identifier generation algorithm, as described in this document, uses MD5 as the hash algorithm. The node MAY use another algorithm instead of MD5 to produce the random interface identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで説明されているように、ランダムインターフェイス識別子生成アルゴリズムは、MD5をハッシュアルゴリズムとして使用します。ノードは、MD5の代わりに別のアルゴリズムを使用して、ランダムインターフェイス識別子を生成する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-1--When-Stable-Storage-Is-Present">
3.2.1. When Stable Storage Is Present
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. 安定したストレージが存在する場合
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following algorithm assumes the presence of a 64-bit &#34;history value&#34; that is used as input in generating a randomized interface identifier. The very first time the system boots (i.e., out-of-the-box), a random value SHOULD be generated using techniques that help ensure the initial value is hard to guess [RANDOM]. Whenever a new interface identifier is generated, a value generated by the computation is saved in the history value for the next iteration of the algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のアルゴリズムは、ランダム化された界面識別子の生成に入力として使用される64ビットの「履歴値」の存在を想定しています。システムが初めてブーツ（つまり、すぐに使用できるボックス）を使用して、初期値を推測するのが難しいことを確認するのに役立つテクニックを使用して、ランダムな値を生成する必要があります[ランダム]。新しいインターフェイス識別子が生成されるたびに、計算によって生成される値は、アルゴリズムの次の反復の履歴値に保存されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A randomized interface identifier is created as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ランダム化された界面識別子は次のように作成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Take the history value from the previous iteration of this algorithm (or a random value if there is no previous value) and append to it the interface identifier generated as described in [ADDRARCH].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. このアルゴリズムの以前の反復（または以前の値がない場合はランダム値）から履歴値を取得し、[addrarch]で説明されているように生成されたインターフェイス識別子を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Compute the MD5 message digest [MD5] over the quantity created in the previous step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 前のステップで作成された数量でMD5メッセージダイジェスト[MD5]を計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Take the leftmost 64-bits of the MD5 digest and set bit 6 (the leftmost bit is numbered 0) to zero. This creates an interface identifier with the universal/local bit indicating local significance only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. MD5ダイジェストの左端の64ビットを取り、ビット6（左端のビットには0）をゼロに設定します。これにより、局所的な有意性のみを示すユニバーサル/ローカルビットを持つインターフェイス識別子が作成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Compare the generated identifier against a list of reserved interface identifiers and to those already assigned to an address on the local device. In the event that an unacceptable identifier has been generated, the node MUST restart the process at step 1 above, using the rightmost 64 bits of the MD5 digest obtained in step 2 in place of the history value in step 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 生成された識別子を、予約されたインターフェイス識別子のリストと、すでにローカルデバイスのアドレスに割り当てられているインターフェース識別子のリストと比較します。容認できない識別子が生成された場合、ノードは、ステップ1の履歴値の代わりにステップ2で得られたMD5ダイジェストの右端の64ビットを使用して、上記のステップ1でプロセスを再起動する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Save the generated identifier as the associated randomized interface identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 生成された識別子を関連するランダム化界面識別子として保存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Take the rightmost 64-bits of the MD5 digest computed in step 2) and save them in stable storage as the history value to be used in the next iteration of the algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. ステップ2）で計算されたMD5ダイジェストの右端の64ビットを取得し、アルゴリズムの次の反復で使用する履歴値として安定したストレージに保存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MD5 was chosen for convenience, and because its particular properties were adequate to produce the desired level of randomization. The node MAY use another algorithm instead of MD5 to produce the random interface identifier
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MD5は利便性のために選択されました。また、その特定の特性は、望ましいレベルのランダム化を生成するのに十分であったためです。ノードは、MD5の代わりに別のアルゴリズムを使用して、ランダムインターフェイス識別子を生成することができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In theory, generating successive randomized interface identifiers using a history scheme as above has no advantages over generating them at random. In practice, however, generating truly random numbers can be tricky. Use of a history value is intended to avoid the particular scenario where two nodes generate the same randomized interface identifier, both detect the situation via DAD, but then proceed to generate identical randomized interface identifiers via the same (flawed) random number generation algorithm. The above algorithm avoids this problem by having the interface identifier (which will often be globally unique) used in the calculation that generates subsequent randomized interface identifiers. Thus, if two nodes happen to generate the same randomized interface identifier, they should generate different ones on the follow-up attempt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
理論的には、上記のように履歴スキームを使用して連続したランダム化界面識別子を生成することは、ランダムにそれらを生成することよりも利点はありません。ただし、実際には、真に乱数を生成するのは難しい場合があります。履歴値の使用は、2つのノードが同じランダム化インターフェイス識別子を生成し、DADを介して状況を検出するが、同じ（欠陥のある）乱数生成アルゴリズムを介して同一のランダム化インターフェイス識別子を生成する特定のシナリオを回避することを目的としています。上記のアルゴリズムは、インターフェイス識別子（しばしばグローバルに一意になる）を計算で使用することにより、この問題を回避します。したがって、2つのノードが同じランダム化された界面識別子を生成した場合、フォローアップの試みで異なるものを生成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-2--In-The-Absence-of-Stable-Storage">
3.2.2. In The Absence of Stable Storage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2. 安定したストレージがない場合
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the absence of stable storage, no history value will be available across system restarts to generate a pseudo-random sequence of interface identifiers. Consequently, the initial history value used above SHOULD be generated at random. A number of techniques might be appropriate. Consult [RANDOM] for suggestions on good sources for obtaining random numbers. Note that even though machines may not have stable storage for storing a history value, they will in many cases have configuration information that differs from one machine to another (e.g., user identity, security keys, serial numbers, etc.). One approach to generating a random initial history value in such cases is to use the configuration information to generate some data bits (which may remain constant for the life of the machine, but will vary from one machine to another), append some random data, and compute the MD5 digest as before.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安定したストレージがない場合、システムの再起動全体で履歴値は利用できません。インターフェイス識別子の擬似ランダムシーケンスを生成します。したがって、上記で使用される初期履歴値はランダムに生成する必要があります。多くのテクニックが適切かもしれません。乱数を取得するための適切なソースに関する提案については、[ランダム]を参照してください。マシンには履歴値を保存するための安定したストレージがない場合でも、多くの場合、マシンごとに異なる構成情報（ユーザーID、セキュリティキー、シリアル番号など）があることに注意してください。このような場合にランダムな初期履歴値を生成する1つのアプローチは、構成情報を使用していくつかのデータビットを生成することです（マシンの寿命は一定のままである可能性がありますが、マシンごとに異なります）、ランダムデータを追加します。以前のようにMD5ダイジェストを計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-3--Alternate-Approaches">
3.2.3. Alternate Approaches
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3. 代替アプローチ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that there are other approaches to generate random interface identifiers, albeit with different goals and applicability. One such approach is Cryptographically Generated Addresses (CGAs) [CGA], which generate a random interface identifier based on the public key of the node. The goal of CGAs is to prove ownership of an address and to prevent spoofing and stealing of existing IPv6 addresses. They are used for securing neighbor discovery using [SEND]. The CGA random interface identifier generation algorithm may not be suitable for privacy addresses because of the following properties: o It requires the node to have a public key. This means that the node can still be identified by its public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異なる目標と適用性がありますが、ランダムインターフェイス識別子を生成する他のアプローチがあることに注意してください。そのようなアプローチの1つは、暗号化されたアドレス（CGA）[CGA]であり、ノードの公開キーに基づいてランダムインターフェイス識別子を生成します。CGAの目標は、住所の所有権を証明し、既存のIPv6アドレスのスプーフィングと盗みを防ぐことです。[送信]を使用して隣人の発見を確保するために使用されます。CGAランダムインターフェイス識別子生成アルゴリズムは、次のプロパティのためにプライバシーアドレスに適していない場合があります。Oノードに公開キーが必要です。これは、ノードがまだ公開キーによって識別できることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The random interface identifier process is computationally intensive and hence discourages frequent regeneration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ランダムインターフェイス識別子プロセスは計算的に集中的であるため、頻繁な再生を妨げます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--Generating-Temporary-Addresses">
3.3. Generating Temporary Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 一時的なアドレスを生成します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ADDRCONF] describes the steps for generating a link-local address when an interface becomes enabled as well as the steps for generating addresses for other scopes. This document extends [ADDRCONF] as follows. When processing a Router Advertisement with a Prefix Information option carrying a global scope prefix for the purposes of address autoconfiguration (i.e., the A bit is set), the node MUST perform the following steps:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[addrconf]は、インターフェイスが有効になったときにリンクローカルアドレスを生成するための手順と、他のスコープのアドレスを生成する手順を説明します。このドキュメントは、[addrconf]を次のように拡張します。アドレスAutoconfigurationの目的でグローバルスコーププレフィックスを運ぶプレフィックス情報オプションを使用してルーター広告を処理する場合（つまり、少し設定されています）、ノードは次の手順を実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Process the Prefix Information Option as defined in [ADDRCONF], either creating a new public address or adjusting the lifetimes of existing addresses, both public and temporary. If a received option will extend the lifetime of a public address, the lifetimes of temporary addresses should be extended, subject to the overall constraint that no temporary addresses should ever remain &#34;valid&#34; or &#34;preferred&#34; for a time longer than (TEMP_VALID_LIFETIME) or (TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR), respectively. The configuration variables TEMP_VALID_LIFETIME and TEMP_PREFERRED_LIFETIME correspond to approximate target lifetimes for temporary addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. [addrconf]で定義されているプレフィックス情報オプションを処理します。新しい公開アドレスを作成するか、既存のアドレスの寿命をパブリックおよび一時的に調整します。受け取ったオプションがパブリックアドレスの寿命を延長する場合、一時的なアドレスが（temp_valid_lifetime）または（temp_valid_lifetime）よりも長い間「有効」または「優先」のままでなければならないという全体的な制約を条件として、一時的なアドレスの寿命を延長する必要があります。（temp_preferred_lifetime -desync_factor）、それぞれ。構成変数TEMP_VALID_LIFETIMEおよびTEMP_PREFERED_LIFETIMEは、一時アドレスのターゲット寿命に対応しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. One way an implementation can satisfy the above constraints is to associate with each temporary address a creation time (called CREATION_TIME) that indicates the time at which the address was created. When updating the preferred lifetime of an existing temporary address, it would be set to expire at whichever time is earlier: the time indicated by the received lifetime or (CREATION_TIME + TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR). A similar approach can be used with the valid lifetime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 実装が上記の制約を満たすことができる1つの方法は、アドレスが作成された時間を示す作成時間（Creation_Timeと呼ばれる）の各一時アドレスに関連付けることです。既存の一時アドレスの優先寿命を更新する場合、受信した寿命または（created_time temp_preferred_lifetime -desync_factor）で示される時間は、早い時間に期限切れになるように設定されます。同様のアプローチを有効な寿命で使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. When a new public address is created as described in [ADDRCONF], the node SHOULD also create a new temporary address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. [addrconf]で説明されているように新しいパブリックアドレスが作成される場合、ノードは新しい一時アドレスも作成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. When creating a temporary address, the lifetime values MUST be derived from the corresponding prefix as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 一時的なアドレスを作成する場合、生涯値は、次のように対応するプレフィックスから派生する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Its Valid Lifetime is the lower of the Valid Lifetime of the public address or TEMP_VALID_LIFETIME.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* その有効な寿命は、パブリックアドレスまたはTEMP_VALID_LIFETIMEの有効な寿命の低いことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Its Preferred Lifetime is the lower of the Preferred Lifetime of the public address or TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* その好ましい寿命は、パブリックアドレスまたはTEMP_PREFERRED_LIFETIME -DESYNC_FACTORの好ましい寿命の低いことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. A temporary address is created only if this calculated Preferred Lifetime is greater than REGEN_ADVANCE time units. In particular, an implementation MUST NOT create a temporary address with a zero Preferred Lifetime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 一時的なアドレスは、この計算された優先寿命がregen_advance時間単位よりも大きい場合にのみ作成されます。特に、実装は、ゼロの優先寿命で一時的なアドレスを作成してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. New temporary addresses MUST be created by appending the interface&#39;s current randomized interface identifier to the prefix that was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. インターフェイスの現在のランダム化インターフェイス識別子を受信したプレフィックスに追加することにより、新しい一時アドレスを作成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. The node MUST perform duplicate address detection (DAD) on the generated temporary address. If DAD indicates the address is already in use, the node MUST generate a new randomized interface identifier as described in Section 3.2 above, and repeat the previous steps as appropriate up to TEMP_IDGEN_RETRIES times. If after TEMP_IDGEN_RETRIES consecutive attempts no non-unique address was generated, the node MUST log a system error and MUST NOT attempt to generate temporary addresses for that interface. Note that DAD MUST be performed on every unicast address generated from this randomized interface identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. ノードは、生成された一時アドレスで複製アドレス検出（DAD）を実行する必要があります。お父さんがアドレスがすでに使用されていることを示している場合、ノードは上記のセクション3.2で説明されているように新しいランダム化インターフェイス識別子を生成し、適切にTEMP_IDGEN_RETRIESの時間までに前の手順を繰り返す必要があります。TEMP_IDGEN_RETRIESの連続試行の後、非ユニークアドレスが生成されなかった場合、ノードはシステムエラーをログに記録する必要があり、そのインターフェイスの一時アドレスを生成しようとしてはなりません。このランダム化された界面識別子から生成されたすべてのユニキャストアドレスでDADを実行する必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-4--Expiration-of-Temporary-Addresses">
3.4. Expiration of Temporary Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. 一時的な住所の有効期限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a temporary address becomes deprecated, a new one MUST be generated. This is done by repeating the actions described in Section 3.3, starting at step 3). Note that, except for the transient period when a temporary address is being regenerated, in normal operation at most one temporary address per prefix should be in a non-deprecated state at any given time on a given interface. Note that if a temporary address becomes deprecated as result of processing a Prefix Information Option with a zero Preferred Lifetime, then a new temporary address MUST NOT be generated. To ensure that a preferred temporary address is always available, a new temporary address SHOULD be regenerated slightly before its predecessor is deprecated. This is to allow sufficient time to avoid race conditions in the case where generating a new temporary address is not instantaneous, such as when duplicate address detection must be run. The node SHOULD start the address regeneration process REGEN_ADVANCE time units before a temporary address would actually be deprecated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一時的な住所が非推奨になると、新しいアドレスを生成する必要があります。これは、ステップ3から始まるセクション3.3で説明されているアクションを繰り返すことによって行われます。一時的なアドレスが再生されている一時的な期間を除いて、通常の操作では、プレフィックスごとに最大1つの一時的なアドレスが、特定のインターフェイスの任意の時点で非抑制状態にあるはずです。ゼロの優先寿命でプレフィックス情報オプションを処理した結果として一時的なアドレスが非推奨になった場合、新しい一時アドレスを生成する必要はありません。優先された一時的な住所が常に利用可能であることを確認するには、前任者が非推奨になる前に、新しい一時的な住所をわずかに再生する必要があります。これは、複製アドレスの検出を実行する必要がある場合など、新しい一時アドレスを生成することが瞬間的ではない場合に、人種条件を回避するのに十分な時間を確保するためです。ノードは、一時的なアドレスが実際に非推奨される前に、アドレス再生プロセスRegen_Advance時間単位を開始する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an optional optimization, an implementation MAY remove a deprecated temporary address that is not in use by applications or upper layers as detailed in Section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションの最適化として、実装は、セクション6で詳述されているように、アプリケーションまたは上層層で使用されていない非推奨の一時アドレスを削除する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5--Regeneration-of-Randomized-Interface-Identifiers">
3.5. Regeneration of Randomized Interface Identifiers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. ランダム化界面識別子の再生
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The frequency at which temporary addresses changes depends on how a device is being used (e.g., how frequently it initiates new communication) and the concerns of the end user. The most egregious privacy concerns appear to involve addresses used for long periods of time (weeks to months to years). The more frequently an address changes, the less feasible collecting or coordinating information keyed on interface identifiers becomes. Moreover, the cost of collecting information and attempting to correlate it based on interface identifiers will only be justified if enough addresses contain non-changing identifiers to make it worthwhile. Thus, having large numbers of clients change their address on a daily or weekly basis is likely to be sufficient to alleviate most privacy concerns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一時的なアドレス変更の頻度は、デバイスの使用方法（たとえば、新しいコミュニケーションを開始する頻度）とエンドユーザーの懸念によって異なります。最もひどいプライバシーの懸念は、長期にわたって使用されるアドレス（週から月から数ヶ月）を含むようです。アドレスがより頻繁に変更されるほど、インターフェイス識別子にキーが掲載されている情報の収集または調整情報が発生します。さらに、インターフェイス識別子に基づいて情報を収集して相関させようとするコストは、十分なアドレスがそれを価値のあるものにするために非変更識別子を含む場合にのみ正当化されます。したがって、多くのクライアントが毎日または毎週のベースで住所を変更するだけで、ほとんどのプライバシーの懸念を軽減するのに十分である可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are also client costs associated with having a large number of addresses associated with a node (e.g., in doing address lookups, the need to join many multicast groups, etc.). Thus, changing addresses frequently (e.g., every few minutes) may have performance implications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、ノードに関連付けられた多数のアドレスを持つことに関連するクライアントコストもあります（たとえば、アドレスルックアップを行う、多くのマルチキャストグループに参加する必要性など）。したがって、アドレスを頻繁に変更する（たとえば、数分ごとに）パフォーマンスに影響を与える可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nodes following this specification SHOULD generate new temporary addresses on a periodic basis. This can be achieved automatically by generating a new randomized interface identifier at least once every (TEMP_PREFERRED_LIFETIME - REGEN_ADVANCE - DESYNC_FACTOR) time units. As described above, generating a new temporary address REGEN_ADVANCE time units before a temporary address becomes deprecated produces addresses with a preferred lifetime no larger than TEMP_PREFERRED_LIFETIME. The value DESYNC_FACTOR is a random value (different for each client) that ensures that clients don&#39;t synchronize with each other and generate new addresses at exactly the same time. When the preferred lifetime expires, a new temporary address MUST be generated using the new randomized interface identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様に続くノードは、定期的に新しい一時アドレスを生成するはずです。これは、少なくとも1回（temp_preferred_lifetime -regen_advance -desync_factor）時間単位で新しいランダム化インターフェイス識別子を生成することで自動的に実現できます。上記のように、一時的なアドレスが非推奨になる前に、新しい一時アドレスregen_advance時間単位を生成すると、TEMP_PREFERED_LIFETIME以外の優先寿命のあるアドレスが生成されます。値desync_factorは、クライアントが互いに同期しないようにし、まったく同時に新しいアドレスを生成することを保証するランダム値（クライアントごとに異なる）です。優先寿命の有効期限が切れる場合、新しいランダム化界面識別子を使用して新しい一時アドレスを生成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the precise frequency at which it is appropriate to generate new addresses varies from one environment to another, implementations SHOULD provide end users with the ability to change the frequency at which addresses are regenerated. The default value is given in TEMP_PREFERRED_LIFETIME and is one day. In addition, the exact time at which to invalidate a temporary address depends on how applications are used by end users. Thus, the suggested default value of one week (TEMP_VALID_LIFETIME) may not be appropriate in all environments. Implementations SHOULD provide end users with the ability to override both of these default values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいアドレスを生成するのが適切である正確な頻度は環境ごとに異なるため、実装はエンドユーザーにアドレスが再生される頻度を変更する機能を提供する必要があります。デフォルト値はtemp_preferred_lifetimeで指定され、1日です。さらに、一時的なアドレスを無効にする正確な時間は、エンドユーザーがアプリケーションの使用方法によって異なります。したがって、1週間の推奨デフォルト値（TEMP_VALID_LIFETIME）は、すべての環境で適切ではない場合があります。実装は、これらのデフォルト値の両方をオーバーライドする機能をエンドユーザーに提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, when an interface connects to a new link, a new randomized interface identifier SHOULD be generated immediately together with a new set of temporary addresses. If a device moves from one ethernet to another, generating a new set of temporary addresses from a different randomized interface identifier ensures that the device uses different randomized interface identifiers for the temporary addresses associated with the two links, making it more difficult to correlate addresses from the two different links as being from the same node. The node MAY follow any process available to it, to determine that the link change has occurred. One such process is described by Detecting Network Attachment [DNA].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、インターフェイスが新しいリンクに接続する場合、新しいランダム化インターフェイス識別子を新しい一時アドレスのセットと一緒にすぐに生成する必要があります。デバイスがあるイーサネットから別のイーサネットに移動すると、異なるランダム化インターフェイス識別子から新しい一時アドレスの新しいセットを生成すると、2つのリンクに関連付けられた一時アドレスに対してデバイスが異なるランダム化インターフェイス識別子を使用することが保証され、アドレスをからのアドレスと相関させることがより困難になります同じノードからの2つの異なるリンク。ノードは、リンクの変更が発生したことを判断するために、利用可能なプロセスに従うことができます。そのようなプロセスの1つは、ネットワークアタッチメント[DNA]を検出することで説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6--Deployment-Considerations">
3.6. Deployment Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. 展開の考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Devices implementing this specification MUST provide a way for the end user to explicitly enable or disable the use of temporary addresses. In addition, a site might wish to disable the use of temporary addresses in order to simplify network debugging and operations. Consequently, implementations SHOULD provide a way for trusted system administrators to enable or disable the use of temporary addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様を実装するデバイスは、エンドユーザーが一時アドレスの使用を明示的に有効または無効にする方法を提供する必要があります。さらに、サイトは、ネットワークのデバッグと操作を簡素化するために、一時的なアドレスの使用を無効にすることをお勧めします。したがって、実装は、信頼できるシステム管理者が一時アドレスの使用を有効または無効にする方法を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, sites might wish to selectively enable or disable the use of temporary addresses for some prefixes. For example, a site might wish to disable temporary address generation for &#34;Unique local&#34; [ULA] prefixes while still generating temporary addresses for all other global prefixes. Another site might wish to enable temporary address generation only for the prefixes 2001::/16 and 2002::/16, while disabling it for all other prefixes. To support this behavior, implementations SHOULD provide a way to enable and disable generation of temporary addresses for specific prefix subranges. This per-prefix setting SHOULD override the global settings on the node with respect to the specified prefix subranges. Note that the pre-prefix setting can be applied at any granularity, and not necessarily on a per-subnet basis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、サイトは、いくつかのプレフィックスの一時アドレスの使用を選択的に有効または無効にすることを希望する場合があります。たとえば、サイトは、他のすべてのグローバルプレフィックスの一時アドレスを生成しながら、「ユニークなローカル」[ULA]プレフィックスの一時的なアドレス生成を無効にすることを望む場合があります。別のサイトでは、他のすべてのプレフィックスに対して無効にしながら、プレフィックス2001 ::/16および2002 ::/16でのみ一時的なアドレス生成を有効にしたい場合があります。この動作をサポートするために、実装は、特定のプレフィックスサブレンジの一時アドレスの生成を有効にして無効にする方法を提供する必要があります。このPrefixあたりの設定は、指定されたプレフィックスサブレンジに関してノードのグローバル設定をオーバーライドする必要があります。プレフィックス前の設定は任意の粒度で適用できることに注意してください。必ずしもスブネットごとにはそうではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of temporary addresses may cause unexpected difficulties with some applications. As described below, some servers refuse to accept communications from clients for which they cannot map the IP address into a DNS name. In addition, some applications may not behave robustly if temporary addresses are used and an address expires before the application has terminated, or if it opens multiple sessions, but expects them to all use the same addresses. Consequently, the use of temporary addresses SHOULD be disabled by default in order to minimize potential disruptions. Individual applications, which have specific knowledge about the normal duration of connections, MAY override this as appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一時的なアドレスを使用すると、一部のアプリケーションで予期せぬ困難を引き起こす可能性があります。以下で説明するように、一部のサーバーは、IPアドレスをDNS名にマップできないクライアントからの通信を受け入れることを拒否します。さらに、アプリケーションが終了する前に一時的なアドレスが使用され、アドレスが期限切れになった場合、または複数のセッションを開く場合、一部のアプリケーションは堅牢に動作しない場合がありますが、すべてが同じアドレスを使用すると予想されます。したがって、潜在的な混乱を最小限に抑えるために、一時的なアドレスの使用をデフォルトで無効にする必要があります。接続の通常の期間に関する特定の知識を持つ個々のアプリケーションは、必要に応じてこれを無効にする場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a very small number of nodes (say, only one) use a given prefix for extended periods of time, just changing the interface identifier part of the address may not be sufficient to ensure privacy, since the prefix acts as a constant identifier. The procedures described in this document are most effective when the prefix is reasonably non static or is used by a fairly large number of nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非常に少数のノード（たとえば、1つだけ）が特定のプレフィックスを長期間使用している場合、プレフィックスは一定の識別子として機能するため、アドレスのインターフェイス識別子部分をプライバシーを確保するのに十分ではない場合があります。このドキュメントで説明されている手順は、接頭辞がかなり静的であるか、かなり多数のノードで使用されている場合に最も効果的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Implications-of-Changing-Interface-Identifiers">
4. Implications of Changing Interface Identifiers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. インターフェイス識別子の変更の意味
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IPv6 addressing architecture goes to some lengths to ensure that interface identifiers are likely to be globally unique where easy to do so. The widespread use of temporary addresses may result in a significant fraction of Internet traffic not using addresses in which the interface identifier portion is globally unique. Consequently, usage of the algorithms in this document may complicate providing such a future flexibility, if global uniqueness is necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6アドレス指定アーキテクチャは、ある程度の長さになり、インターフェイス識別子が簡単にできる場合はグローバルに一意になる可能性が高いことを確認します。一時的なアドレスを広く使用すると、インターフェイス識別子部分がグローバルに一意であるアドレスを使用しないインターネットトラフィックのかなりの部分が生じる可能性があります。その結果、このドキュメントのアルゴリズムの使用は、グローバルな一意性が必要な場合、そのような将来の柔軟性を提供することを複雑にする可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The desires of protecting individual privacy versus the desire to effectively maintain and debug a network can conflict with each other. Having clients use addresses that change over time will make it more difficult to track down and isolate operational problems. For example, when looking at packet traces, it could become more difficult to determine whether one is seeing behavior caused by a single errant machine, or by a number of them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークを効果的に維持およびデバッグしたいという欲求と、互いに競合する可能性があることと、個々のプライバシーを保護するという欲求。クライアントに時間の経過とともに変更されるアドレスを使用すると、運用上の問題を追跡して隔離することがより困難になります。たとえば、パケットのトレースを見ると、単一の誤ったマシンによって引き起こされる動作を見ているのか、それとも多くの動作によって引き起こされているのかを判断するのがより困難になる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some servers refuse to grant access to clients for which no DNS name exists. That is, they perform a DNS PTR query to determine the DNS name, and may then also perform an AAAA query on the returned name to verify that the returned DNS name maps back into the address being used. Consequently, clients not properly registered in the DNS may be unable to access some services. As noted earlier, however, a node&#39;s DNS name (if non-changing) serves as a constant identifier. The wide deployment of the extension described in this document could challenge the practice of inverse-DNS-based &#34;authentication,&#34; which has little validity, though it is widely implemented. In order to meet server challenges, nodes could register temporary addresses in the DNS using random names (for example, a string version of the random address itself).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のサーバーは、DNS名が存在しないクライアントへのアクセスを付与することを拒否します。つまり、DNS PTRクエリを実行してDNS名を決定し、返された名前でAAAAクエリを実行して、返されたDNS名が使用されているアドレスに戻ることを確認することもできます。その結果、DNSに適切に登録されていないクライアントは、一部のサービスにアクセスできない場合があります。ただし、前述のように、ノードのDNS名（非変更の場合）は、一定の識別子として機能します。このドキュメントで説明されている拡張機能の幅広い展開は、広く実装されていますが、妥当性がほとんどない逆DNSベースの「認証」の実践に挑戦する可能性があります。サーバーの課題を満たすために、ノードはランダム名（たとえば、ランダムアドレス自体の文字列バージョン）を使用してDNSに一時アドレスを登録できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of the extensions defined in this document may complicate debugging and other operational troubleshooting activities. Consequently, it may be site policy that temporary addresses should not be used. Consequently, implementations MUST provide a method for the end user or trusted administrator to override the use of temporary addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで定義されている拡張機能を使用すると、デバッグやその他の運用上のトラブルシューティングアクティビティが複雑になる場合があります。したがって、一時的なアドレスを使用しないのはサイトポリシーかもしれません。したがって、実装は、エンドユーザーまたは信頼できる管理者が一時的なアドレスの使用をオーバーライドする方法を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Defined-Constants">
5. Defined Constants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 定義された定数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Constants defined in this document include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで定義されている定数は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEMP_VALID_LIFETIME -- Default value: 1 week. Users should be able to override the default value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEMP_VALID_LIFETIME-デフォルト値：1週間。ユーザーはデフォルト値をオーバーライドできる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEMP_PREFERRED_LIFETIME -- Default value: 1 day. Users should be able to override the default value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
temp_preferred_lifetime-デフォルト値：1日。ユーザーはデフォルト値をオーバーライドできる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REGEN_ADVANCE -- 5 seconds
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regen_Advance -5秒
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAX_DESYNC_FACTOR -- 10 minutes. Upper bound on DESYNC_FACTOR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAX_DESYNC_FACTOR -10分。desync_factorの上限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESYNC_FACTOR -- A random value within the range 0 - MAX_DESYNC_FACTOR. It is computed once at system start (rather than each time it is used) and must never be greater than (TEMP_VALID_LIFETIME - REGEN_ADVANCE).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
desync_factor -範囲0 -max_desync_factor内のランダム値。システム開始時に1回（使用するたびに）計算され、（temp_valid_lifetime -regen_advance）よりも大きくない必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEMP_IDGEN_RETRIES -- Default value: 3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
temp_idgen_retries-デフォルト値：3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Future-Work">
6. Future Work
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 将来の仕事
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation might want to keep track of which addresses are being used by upper layers so as to be able to remove a deprecated temporary address from internal data structures once no upper layer protocols are using it (but not before). This is in contrast to current approaches where addresses are removed from an interface when they become invalid [ADDRCONF], independent of whether or not upper layer protocols are still using them. For TCP connections, such information is available in control blocks. For UDP-based applications, it may be the case that only the applications have knowledge about what addresses are actually in use. Consequently, an implementation generally will need to use heuristics in deciding when an address is no longer in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、上層のプロトコルが使用されない場合（以前ではない）、内部データ構造から非推奨の一時アドレスを削除できるように、上層層で使用されているアドレスを追跡することをお勧めします。これは、上部層プロトコルがまだ使用しているかどうかに関係なく、アドレスが無効になったときにインターフェイスから削除される現在のアプローチとは対照的です。TCP接続の場合、そのような情報はコントロールブロックで利用できます。UDPベースのアプリケーションの場合、アプリケーションのみが実際に使用されているアドレスについての知識を持っている可能性があります。その結果、実装は一般に、アドレスが使用されなくなったときに決定する際にヒューリスティックを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The determination as to whether to use public versus temporary addresses can in some cases only be made by an application. For example, some applications may always want to use temporary addresses, while others may want to use them only in some circumstances or not at all. Suitable API extensions will likely need to be developed to enable individual applications to indicate with sufficient granularity their needs with regards to the use of temporary addresses. Recommendations on DNS practices to avoid the problem described in Section 4 when reverse DNS lookups fail may be needed. [DNSOP] contains a more detailed discussion of the DNS-related issues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パブリックと一時的な住所を使用するかどうかの決定は、場合によってはアプリケーションによってのみ行うことができます。たとえば、一部のアプリケーションは常に一時的なアドレスを使用したい場合がありますが、他のアプリケーションは状況によってのみ使用したいか、まったく使用しない場合があります。一時的なアドレスの使用に関して、個々のアプリケーションが十分な粒度を持ってニーズを示すようにするために、適切なAPI拡張機能を開発する必要があります。逆DNSルックアップが失敗する場合にセクション4で説明されている問題を回避するためのDNSプラクティスに関する推奨事項が必要になる場合があります。[DNSOP]には、DNS関連の問題に関するより詳細な議論が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While this document discusses ways of obscuring a user&#39;s permanent IP address, the method described is believed to be ineffective against sophisticated forms of traffic analysis. To increase effectiveness, one may need to consider use of more advanced techniques, such as Onion Routing [ONION].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、ユーザーの永続的なIPアドレスを不明瞭にする方法について説明しますが、説明されている方法は、洗練された形式のトラフィック分析に対して効果がないと考えられています。有効性を高めるには、オニオンルーティング[オニオン]など、より高度な技術の使用を検討する必要がある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Security-Considerations">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ingress filtering has been and is being deployed as a means of preventing the use of spoofed source addresses in Distributed Denial of Service (DDoS) attacks. In a network with a large number of nodes, new temporary addresses are created at a fairly high rate. This might make it difficult for ingress filtering mechanisms to distinguish between legitimately changing temporary addresses and spoofed source addresses, which are &#34;in-prefix&#34; (using a topologically correct prefix and non-existent interface ID). This can be addressed by using access control mechanisms on a per-address basis on the network egress point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ingressフィルタリングは、分散型サービス拒否（DDOS）攻撃におけるスプーフィングされたソースアドレスの使用を防ぐ手段として展開されています。多数のノードを備えたネットワークでは、新しい一時アドレスがかなり高いレートで作成されます。これにより、フィルタリングメカニズムを侵入すると、一時的に変更された一時的なアドレスとスプーフィングされたソースアドレス（「in-prefix」）を区別することが困難になる可能性があります（トポロジー的に正しいプレフィックスと存在しないインターフェイスIDを使用）。これは、ネットワークの出口点でアドレスごとにアクセス制御メカニズムを使用することで対処できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Significant-Changes-from-RFC-3041">
8. Significant Changes from RFC 3041
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. RFC 3041からの大幅な変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section summarizes the changes in this document relative to RFC 3041 that an implementer of RFC 3041 should be aware of.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、RFC 3041の実装者が注意する必要があるRFC 3041に対するこのドキュメントの変更を要約します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Excluded certain interface identifiers from the range of acceptable interface identifiers. Interface IDs such as those for reserved anycast addresses [RFC2526], etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 許容可能なインターフェイス識別子の範囲から特定のインターフェイス識別子を除外しました。予約済みのAnycastアドレス[RFC2526]などのインターフェイスID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Added a configuration knob that provides the end user with a way to enable or disable the use of temporary addresses on a per-prefix basis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. エンドユーザーに、PREFIXごとに一時アドレスの使用を有効または無効にする方法を提供する構成ノブを追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Added a check for denial of service attacks using low valid lifetimes in router advertisements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. ルーター広告で低い有効な寿命を使用して、サービス拒否攻撃のチェックを追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. DAD is now run on all temporary addresses, not just the first one generated from an interface identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. お父さんは、インターフェイス識別子から生成された最初のアドレスだけでなく、すべての一時的なアドレスで実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Changed the default setting for usage of temporary addresses to be disabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 一時的なアドレスを使用して無効にするためにデフォルト設定を変更しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. The node is now allowed to generate different interface identifiers for different prefixes, if it so desires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. これで、ノードが異なるプレフィックスに対して異なるインターフェイス識別子を生成できるようになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. The algorithm used for generating random interface identifiers is no longer restricted to just MD5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. ランダムインターフェイス識別子の生成に使用されるアルゴリズムは、MD5のみに制限されなくなりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Reduced default number of retries to 3 and added a configuration variable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. デフォルトのレトリ数を3に減らし、構成変数を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. Router advertisement (RA) processing algorithm is no longer included in the document, and is replaced by a reference to [ADDRCONF].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. ルーター広告（RA）処理アルゴリズムはドキュメントに含まれなくなり、[addrconf]への参照に置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--Acknowledgments">
9. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rich Draves and Thomas Narten were the authors of RFC 3041. They would like to acknowledge the contributions of the ipv6 working group and, in particular, Ran Atkinson, Matt Crawford, Steve Deering, Allison Mankin, and Peter Bieringer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rich DravesとThomas NartenはRFC 3041の著者でした。彼らはIPv6ワーキンググループの貢献を認めたいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suresh Krishnan was the sole author of this version of the document. He would like to acknowledge the contributions of the ipv6 working group and, in particular, Jari Arkko, Pekka Nikander, Pekka Savola, Francis Dupont, Brian Haberman, Tatuya Jinmei, and Margaret Wasserman for their detailed comments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suresh Krishnanは、このバージョンのドキュメントの唯一の著者でした。彼は、IPv6ワーキンググループの貢献、特にジャリ・アークコ、ペッカ・ニカンダー、ペッカ・サヴォラ、フランシス・デュポン、ブライアン・ハーバーマン、タトゥヤ・ジンメイ、マーガレット・ワッサーマンの詳細なコメントを認めたいと思っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--References">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-1--Normative-References">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ADDRARCH] Hinden, R. and S. Deering, &#34;IP Version 6 Addressing Architecture&#34;, RFC 4291, February 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Addrarch] Hinden、R。and S. Deering、「IPバージョン6アドレス指定アーキテクチャ」、RFC 4291、2006年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ADDRCONF] Thomson, S., Narten, T., and T. Jinmei, &#34;IPv6 Stateless Address Autoconfiguration&#34;, RFC 4862, September 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Addrconf] Thomson、S.、Narten、T。、およびT. Jinmei、「IPv6 Stateless Address Autoconfiguration」、RFC 4862、2007年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DISCOVERY] Narten, T., Nordmark, E., Simpson, W., and H. Soliman, &#34;Neighbor Discovery for IP version 6 (IPv6)&#34;, RFC 4861, September 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[発見] Narten、T.、Nordmark、E.、Simpson、W。、およびH. Soliman、「IPバージョン6（IPv6）の近隣発見」、RFC 4861、2007年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MD5] Rivest, R., &#34;The MD5 Message-Digest Algorithm&#34;, RFC 1321, April 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MD5] Rivest、R。、「The MD5 Message-Digest Algorithm」、RFC 1321、1992年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-2--Informative-References">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ADDR_SELECT] Draves, R., &#34;Default Address Selection for Internet Protocol version 6 (IPv6)&#34;, RFC 3484, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Addr_Select] Draves、R。、「インターネットプロトコルバージョン6（IPv6）のデフォルトアドレス選択」、RFC 3484、2003年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CGA] Aura, T., &#34;Cryptographically Generated Addresses (CGA)&#34;, RFC 3972, March 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CGA]オーラ、T。、「暗号化されたアドレス（CGA）」、RFC 3972、2005年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[COOKIES] Kristol, D. and L. Montulli, &#34;HTTP State Management Mechanism&#34;, RFC 2965, October 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Cookies] Kristol、D。およびL. Montulli、「HTTP州管理メカニズム」、RFC 2965、2000年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DDNS] Vixie, P., Thomson, S., Rekhter, Y., and J. Bound, &#34;Dynamic Updates in the Domain Name System (DNS UPDATE)&#34;, RFC 2136, April 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DDNS] Vixie、P.、Thomson、S.、Rekhter、Y.、およびJ. Bound、「ドメイン名システムの動的更新（DNSアップデート）」、RFC 2136、1997年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DHCP] Droms, R., &#34;Dynamic Host Configuration Protocol&#34;, RFC 2131, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DHCP] Droms、R。、「動的ホスト構成プロトコル」、RFC 2131、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DHCPV6] Droms, R., Bound, J., Volz, B., Lemon, T., Perkins, C., and M. Carney, &#34;Dynamic Host Configuration Protocol for IPv6 (DHCPv6)&#34;, RFC 3315, July 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Dhcpv6] Droms、R.、Bound、J.、Volz、B.、Lemon、T.、Perkins、C。、およびM. Carney、「IPv6（DHCPV6）の動的ホスト構成プロトコル」、RFC 3315、2003年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DNA] Choi, JH. and G. Daley, &#34;Goals of Detecting Network Attachment in IPv6&#34;, RFC 4135, August 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DNA]チェ、JH。G. Daley、「IPv6のネットワーク添付ファイルを検出する目標」、RFC 4135、2005年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DNSOP] Durand, A., Ihren, J., and P. Savola, &#34;Operational Considerations and Issues with IPv6 DNS&#34;, RFC 4472, April 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DNSOP] Durand、A.、Ihren、J。、およびP. Savola、「IPv6 DNSに関する運用上の考慮事項と問題」、RFC 4472、2006年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ONION] Reed, MGR., Syverson, PFS., and DMG. Goldschlag, &#34;Proxies for Anonymous Routing&#34;, Proceedings of the 12th Annual Computer Security Applications Conference, San Diego, CA, December 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[オニオン] Reed、Mgr。、Syverson、PFS。、およびDMG。Goldschlag、「匿名ルーティングのプロキシ」、1996年12月、カリフォルニア州サンディエゴの第12回年次コンピューターセキュリティアプリケーション会議の議事録。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RANDOM] Eastlake, D., Schiller, J., and S. Crocker, &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086, June 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ランダム] Eastlake、D.、Schiller、J。、およびS. Crocker、「セキュリティのランダム性要件」、BCP 106、RFC 4086、2005年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2526] Johnson, D. and S. Deering, &#34;Reserved IPv6 Subnet Anycast Addresses&#34;, RFC 2526, March 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2526] Johnson、D。およびS. Deering、「予約済みのIPv6サブネットAnycastアドレス」、RFC 2526、1999年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SEND] Arkko, J., Kempf, J., Zill, B., and P. Nikander, &#34;SEcure Neighbor Discovery (SEND)&#34;, RFC 3971, March 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[送信] Arkko、J.、Kempf、J.、Zill、B。、およびP. Nikander、「Secure Neighbor Discovery（Send）」、RFC 3971、2005年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ULA] Hinden, R. and B. Haberman, &#34;Unique Local IPv6 Unicast Addresses&#34;, RFC 4193, October 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ULA] Hinden、R。およびB. Haberman、「ユニークなローカルIPv6ユニキャストアドレス」、RFC 4193、2005年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thomas Narten IBM Corporation P.O. Box 12195 Research Triangle Park, NC USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thomas Narten IBM Corporation P.O.Box 12195 Research Triangle Park、NC USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: narten@us.ibm.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Richard Draves Microsoft Research One Microsoft Way Redmond, WA USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リチャード・ドラヴズ・マイクロソフト・リサーチワン・マイクロソフト・ウェイ・レドモンド、ワシントン州アメリカ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: richdr@microsoft.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suresh Krishnan Ericsson Research 8400 Decarie Blvd. Town of Mount Royal, QC Canada
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suresh Krishnan Ericsson Research 8400 Decarie Blvd.QCカナダのマウントロイヤルの町
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: suresh.krishnan@ericsson.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The IETF Trust (2007).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（c）The IETF Trust（2007）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供され、貢献者、彼/彼女が代表する組織（もしあれば）、インターネット協会、IETFトラスト、インターネットエンジニアリングタスクフォースがすべてを否認します。明示的または黙示的な保証。ここでの情報の使用は、特定の目的に対する商品性または適合性の権利または暗黙の保証を侵害しないという保証を含むがこれらに限定されない。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知的財産
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、知的財産権またはその他の権利の有効性または範囲に関して、本書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスに基づくライセンスの範囲に関連すると主張される可能性のある他の権利に関しては、立場を取得しません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得するための試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要な技術をカバーする可能性のあるその他の独自の権利を注意深く招待するよう招待しています。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
