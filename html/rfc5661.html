<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 5661 - Network File System (NFS) Version 4 Minor Version 1 Protocol 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">5661</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc5661">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 5661 - Network File System (NFS) Version 4 Minor Version 1 Protocol 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc5661">
            https://datatracker.ietf.org/doc/html/rfc5661
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 5661 - ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1プロトコル</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                   S. Shepler, Ed.
Request for Comments: 5661                               Storspeed, Inc.
Category: Standards Track                                 M. Eisler, Ed.
ISSN: 2070-1721                                           D. Noveck, Ed.
                                                                  NetApp
                                                            January 2010
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Network File System (NFS) Version 4 Minor Version 1 Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1プロトコル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes the Network File System (NFS) version 4 minor version 1, including features retained from the base protocol (NFS version 4 minor version 0, which is specified in RFC 3530) and protocol extensions made subsequently. Major extensions introduced in NFS version 4 minor version 1 include Sessions, Directory Delegations, and parallel NFS (pNFS). NFS version 4 minor version 1 has no dependencies on NFS version 4 minor version 0, and it is considered a separate protocol. Thus, this document neither updates nor obsoletes RFC 3530. NFS minor version 1 is deemed superior to NFS minor version 0 with no loss of functionality, and its use is preferred over version 0. Both NFS minor versions 0 and 1 can be used simultaneously on the same network, between the same client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1について説明します。これには、基本プロトコル（NFSバージョン4マイナーバージョン0、RFC 3530で指定）から保持される機能、およびその後に行われるプロトコル拡張が含まれます。 NFSバージョン4マイナーバージョン1で導入された主要な拡張機能には、セッション、ディレクトリ委任、および並列NFS（pNFS）が含まれます。 NFSバージョン4のマイナーバージョン1はNFSバージョン4のマイナーバージョン0に依存せず、別個のプロトコルと見なされます。したがって、このドキュメントはRFC 3530を更新または廃止していません。NFSマイナーバージョン1は、機能を失うことなくNFSマイナーバージョン0よりも優れていると見なされており、バージョン0よりも優先的に使用されます。NFSマイナーバージョン0と1の両方を同時に使用できます。同じクライアントとサーバー間の同じネットワーク。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはInternet Standards Trackドキュメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 5741のセクション2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc5661.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc5661で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2010 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................9
      1.1. The NFS Version 4 Minor Version 1 Protocol .................9
      1.2. Requirements Language ......................................9
      1.3. Scope of This Document .....................................9
      1.4. NFSv4 Goals ...............................................10
      1.5. NFSv4.1 Goals .............................................10
      1.6. General Definitions .......................................11
      1.7. Overview of NFSv4.1 Features ..............................13
      1.8. Differences from NFSv4.0 ..................................17
   2. Core Infrastructure ............................................18
      2.1. Introduction ..............................................18
      2.2. RPC and XDR ...............................................19
      2.3. COMPOUND and CB_COMPOUND ..................................22
      2.4. Client Identifiers and Client Owners ......................23
      2.5. Server Owners .............................................28
      2.6. Security Service Negotiation ..............................29
      2.7. Minor Versioning ..........................................34
      2.8. Non-RPC-Based Security Services ...........................37
      2.9. Transport Layers ..........................................37
      2.10. Session ..................................................40
   3. Protocol Constants and Data Types ..............................86
      3.1. Basic Constants ...........................................86
      3.2. Basic Data Types ..........................................87
      3.3. Structured Data Types .....................................89
   4. Filehandles ....................................................97
      4.1. Obtaining the First Filehandle ............................98
      4.2. Filehandle Types ..........................................99
      4.3. One Method of Constructing a Volatile Filehandle .........101
      4.4. Client Recovery from Filehandle Expiration ...............102
   5. File Attributes ...............................................103
      5.1. REQUIRED Attributes ......................................104
      5.2. RECOMMENDED Attributes ...................................104
      5.3. Named Attributes .........................................105
      5.4. Classification of Attributes .............................106
      5.5. Set-Only and Get-Only Attributes .........................107
      5.6. REQUIRED Attributes - List and Definition References .....107
      5.7. RECOMMENDED Attributes - List and Definition References ..108
      5.8. Attribute Definitions ....................................110
      5.9. Interpreting owner and owner_group .......................119
      5.10. Character Case Attributes ...............................121
      5.11. Directory Notification Attributes .......................121
      5.12. pNFS Attribute Definitions ..............................122
      5.13. Retention Attributes ....................................123
   6. Access Control Attributes .....................................126
      6.1. Goals ....................................................126
      6.2. File Attributes Discussion ...............................128
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
      6.3. Common Methods ...........................................144
      6.4. Requirements .............................................147
   7. Single-Server Namespace .......................................153
      7.1. Server Exports ...........................................153
      7.2. Browsing Exports .........................................153
      7.3. Server Pseudo File System ................................154
      7.4. Multiple Roots ...........................................155
      7.5. Filehandle Volatility ....................................155
      7.6. Exported Root ............................................155
      7.7. Mount Point Crossing .....................................156
      7.8. Security Policy and Namespace Presentation ...............156
   8. State Management ..............................................157
      8.1. Client and Session ID ....................................158
      8.2. Stateid Definition .......................................158
      8.3. Lease Renewal ............................................167
      8.4. Crash Recovery ...........................................170
      8.5. Server Revocation of Locks ...............................181
      8.6. Short and Long Leases ....................................182
      8.7. Clocks, Propagation Delay, and Calculating Lease
           Expiration ...............................................182
      8.8. Obsolete Locking Infrastructure from NFSv4.0 .............183
   9. File Locking and Share Reservations ...........................184
      9.1. Opens and Byte-Range Locks ...............................184
      9.2. Lock Ranges ..............................................188
      9.3. Upgrading and Downgrading Locks ..........................188
      9.4. Stateid Seqid Values and Byte-Range Locks ................189
      9.5. Issues with Multiple Open-Owners .........................189
      9.6. Blocking Locks ...........................................190
      9.7. Share Reservations .......................................191
      9.8. OPEN/CLOSE Operations ....................................192
      9.9. Open Upgrade and Downgrade ...............................192
      9.10. Parallel OPENs ..........................................193
      9.11. Reclaim of Open and Byte-Range Locks ....................194
   10. Client-Side Caching ..........................................194
      10.1. Performance Challenges for Client-Side Caching ..........195
      10.2. Delegation and Callbacks ................................196
      10.3. Data Caching ............................................200
      10.4. Open Delegation .........................................205
      10.5. Data Caching and Revocation .............................216
      10.6. Attribute Caching .......................................218
      10.7. Data and Metadata Caching and Memory Mapped Files .......220
      10.8. Name and Directory Caching without Directory
            Delegations .............................................222
      10.9. Directory Delegations ...................................225
   11. Multi-Server Namespace .......................................228
      11.1. Location Attributes .....................................228
      11.2. File System Presence or Absence .........................229
      11.3. Getting Attributes for an Absent File System ............230
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
      11.4. Uses of Location Information ............................232
      11.5. Location Entries and Server Identity ....................236
      11.6. Additional Client-Side Considerations ...................237
      11.7. Effecting File System Transitions .......................238
      11.8. Effecting File System Referrals .........................251
      11.9. The Attribute fs_locations ..............................258
      11.10. The Attribute fs_locations_info ........................261
      11.11. The Attribute fs_status ................................273
   12. Parallel NFS (pNFS) ..........................................277
      12.1. Introduction ............................................277
      12.2. pNFS Definitions ........................................278
      12.3. pNFS Operations .........................................284
      12.4. pNFS Attributes .........................................285
      12.5. Layout Semantics ........................................285
      12.6. pNFS Mechanics ..........................................300
      12.7. Recovery ................................................302
      12.8. Metadata and Storage Device Roles .......................307
      12.9. Security Considerations for pNFS ........................307
   13. NFSv4.1 as a Storage Protocol in pNFS: the File Layout Type ..309
      13.1. Client ID and Session Considerations ....................309
      13.2. File Layout Definitions .................................312
      13.3. File Layout Data Types ..................................312
      13.4. Interpreting the File Layout ............................317
      13.5. Data Server Multipathing ................................324
      13.6. Operations Sent to NFSv4.1 Data Servers .................325
      13.7. COMMIT through Metadata Server ..........................327
      13.8. The Layout Iomode .......................................328
      13.9. Metadata and Data Server State Coordination .............329
      13.10. Data Server Component File Size ........................332
      13.11. Layout Revocation and Fencing ..........................333
      13.12. Security Considerations for the File Layout Type .......334
   14. Internationalization .........................................334
     14.1.  Stringprep profile for the utf8str_cs type ..............336
     14.2.  Stringprep profile for the utf8str_cis type .............337
     14.3.  Stringprep profile for the utf8str_mixed type ...........338
     14.4.  UTF-8 Capabilities ......................................340
     14.5.  UTF-8 Related Errors ....................................340
   15. Error Values .................................................341
      15.1. Error Definitions .......................................341
      15.2. Operations and Their Valid Errors .......................361
      15.3. Callback Operations and Their Valid Errors ..............376
      15.4. Errors and the Operations That Use Them .................379
   16. NFSv4.1 Procedures ...........................................391
      16.1. Procedure 0: NULL - No Operation ........................392
      16.2. Procedure 1: COMPOUND - Compound Operations .............392
   17. Operations: REQUIRED, RECOMMENDED, or OPTIONAL ...............403
   18. NFSv4.1 Operations ...........................................407
      18.1. Operation 3: ACCESS - Check Access Rights ...............407
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
      18.2. Operation 4: CLOSE - Close File .........................413
      18.3. Operation 5: COMMIT - Commit Cached Data ................414
      18.4. Operation 6: CREATE - Create a Non-Regular File Object ..417
      18.5. Operation 7: DELEGPURGE - Purge Delegations
            Awaiting Recovery .......................................419
      18.6. Operation 8: DELEGRETURN - Return Delegation ............420
      18.7. Operation 9: GETATTR - Get Attributes ...................421
      18.8. Operation 10: GETFH - Get Current Filehandle ............423
      18.9. Operation 11: LINK - Create Link to a File ..............424
      18.10. Operation 12: LOCK - Create Lock .......................426
      18.11. Operation 13: LOCKT - Test for Lock ....................430
      18.12. Operation 14: LOCKU - Unlock File ......................432
      18.13. Operation 15: LOOKUP - Lookup Filename .................433
      18.14. Operation 16: LOOKUPP - Lookup Parent Directory ........435
      18.15. Operation 17: NVERIFY - Verify Difference in
             Attributes .............................................436
      18.16. Operation 18: OPEN - Open a Regular File ...............437
      18.17. Operation 19: OPENATTR - Open Named Attribute
             Directory ..............................................458
      18.18. Operation 21: OPEN_DOWNGRADE - Reduce Open File
             Access .................................................459
      18.19. Operation 22: PUTFH - Set Current Filehandle ...........461
      18.20. Operation 23: PUTPUBFH - Set Public Filehandle .........461
      18.21. Operation 24: PUTROOTFH - Set Root Filehandle ..........463
      18.22. Operation 25: READ - Read from File ....................464
      18.23. Operation 26: READDIR - Read Directory .................466
      18.24. Operation 27: READLINK - Read Symbolic Link ............469
      18.25. Operation 28: REMOVE - Remove File System Object .......470
      18.26. Operation 29: RENAME - Rename Directory Entry ..........473
      18.27. Operation 31: RESTOREFH - Restore Saved Filehandle .....477
      18.28. Operation 32: SAVEFH - Save Current Filehandle .........478
      18.29. Operation 33: SECINFO - Obtain Available Security ......479
      18.30. Operation 34: SETATTR - Set Attributes .................482
      18.31. Operation 37: VERIFY - Verify Same Attributes ..........485
      18.32. Operation 38: WRITE - Write to File ....................486
      18.33. Operation 40: BACKCHANNEL_CTL - Backchannel Control ....491
      18.34. Operation 41: BIND_CONN_TO_SESSION - Associate
             Connection with Session ................................492
      18.35. Operation 42: EXCHANGE_ID - Instantiate Client ID ......495
      18.36. Operation 43: CREATE_SESSION - Create New
             Session and Confirm Client ID ..........................513
      18.37. Operation 44: DESTROY_SESSION - Destroy a Session ......523
      18.38. Operation 45: FREE_STATEID - Free Stateid with
             No Locks ...............................................525
      18.39. Operation 46: GET_DIR_DELEGATION - Get a
             Directory Delegation ...................................526
      18.40. Operation 47: GETDEVICEINFO - Get Device Information ...530
      18.41. Operation 48: GETDEVICELIST - Get All Device
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
             Mappings for a File System .............................533
      18.42. Operation 49: LAYOUTCOMMIT - Commit Writes Made
             Using a Layout .........................................534
      18.43. Operation 50: LAYOUTGET - Get Layout Information .......538
      18.44. Operation 51: LAYOUTRETURN - Release Layout
             Information ............................................547
      18.45. Operation 52: SECINFO_NO_NAME - Get Security on
             Unnamed Object .........................................552
      18.46. Operation 53: SEQUENCE - Supply Per-Procedure
             Sequencing and Control .................................553
      18.47. Operation 54: SET_SSV - Update SSV for a Client ID .....559
      18.48. Operation 55: TEST_STATEID - Test Stateids for
             Validity ...............................................561
      18.49. Operation 56: WANT_DELEGATION - Request Delegation .....563
      18.50. Operation 57: DESTROY_CLIENTID - Destroy a Client ID ...566
      18.51. Operation 58: RECLAIM_COMPLETE - Indicates
             Reclaims Finished ......................................567
      18.52. Operation 10044: ILLEGAL - Illegal Operation ...........569
   19. NFSv4.1 Callback Procedures ..................................570
      19.1. Procedure 0: CB_NULL - No Operation .....................570
      19.2. Procedure 1: CB_COMPOUND - Compound Operations ..........571
   20. NFSv4.1 Callback Operations ..................................574
      20.1. Operation 3: CB_GETATTR - Get Attributes ................574
      20.2. Operation 4: CB_RECALL - Recall a Delegation ............575
      20.3. Operation 5: CB_LAYOUTRECALL - Recall Layout
            from Client .............................................576
      20.4. Operation 6: CB_NOTIFY - Notify Client of
            Directory Changes .......................................580
      20.5. Operation 7: CB_PUSH_DELEG - Offer Previously
            Requested Delegation to Client ..........................583
      20.6. Operation 8: CB_RECALL_ANY - Keep Any N
            Recallable Objects ......................................584
      20.7. Operation 9: CB_RECALLABLE_OBJ_AVAIL - Signal
            Resources for Recallable Objects ........................588
      20.8. Operation 10: CB_RECALL_SLOT - Change Flow
            Control Limits ..........................................588
      20.9. Operation 11: CB_SEQUENCE - Supply Backchannel
            Sequencing and Control ..................................589
      20.10. Operation 12: CB_WANTS_CANCELLED - Cancel
             Pending Delegation Wants ...............................592
      20.11. Operation 13: CB_NOTIFY_LOCK - Notify Client of
             Possible Lock Availability .............................593
      20.12. Operation 14: CB_NOTIFY_DEVICEID - Notify
             Client of Device ID Changes ............................594
      20.13. Operation 10044: CB_ILLEGAL - Illegal Callback
             Operation ..............................................596
   21. Security Considerations ......................................597
   22. IANA Considerations ..........................................598
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
      22.1. Named Attribute Definitions .............................598
      22.2. Device ID Notifications .................................600
      22.3. Object Recall Types .....................................601
      22.4. Layout Types ............................................603
      22.5. Path Variable Definitions ...............................606
   23. References ...................................................609
      23.1. Normative References ....................................609
      23.2. Informative References ..................................612
   Appendix A.  Acknowledgments  ....................................615
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-1--The-NFS-Version-4-Minor-Version-1-Protocol">
1.1. The NFS Version 4 Minor Version 1 Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. NFSバージョン4マイナーバージョン1プロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 minor version 1 (NFSv4.1) protocol is the second minor version of the NFS version 4 (NFSv4) protocol. The first minor version, NFSv4.0, is described in [30]. It generally follows the guidelines for minor versioning that are listed in Section 10 of RFC 3530. However, it diverges from guidelines 11 (&#34;a client and server that support minor version X must support minor versions 0 through X-1&#34;) and 12 (&#34;no new features may be introduced as mandatory in a minor version&#34;). These divergences are due to the introduction of the sessions model for managing non-idempotent operations and the RECLAIM_COMPLETE operation. These two new features are infrastructural in nature and simplify implementation of existing and other new features. Making them anything but REQUIRED would add undue complexity to protocol definition and implementation. NFSv4.1 accordingly updates the minor versioning guidelines (Section 2.7).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4マイナーバージョン1（NFSv4.1）プロトコルは、NFSバージョン4（NFSv4）プロトコルの2番目のマイナーバージョンです。最初のマイナーバージョン、NFSv4.0は[30]で説明されています。これは通常、RFC 3530のセクション10に記載されているマイナーバージョン管理のガイドラインに従います。ただし、ガイドライン11（「マイナーバージョンXをサポートするクライアントとサーバーはマイナーバージョン0からX-1をサポートする必要があります」）および12（ 「マイナーバージョンでは必須として新機能を導入することはできません」）。これらの相違は、非べき等操作とRECLAIM_COMPLETE操作を管理するためのセッションモデルの導入によるものです。これらの2つの新機能は本質的にインフラストラクチャであり、既存およびその他の新機能の実装を簡素化します。それらをREQUIRED以外のものにすると、プロトコルの定義と実装が過度に複雑になります。 NFSv4.1は、それに応じてマイナーバージョンのガイドラインを更新します（セクション2.7）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a minor version, NFSv4.1 is consistent with the overall goals for NFSv4, but extends the protocol so as to better meet those goals, based on experiences with NFSv4.0. In addition, NFSv4.1 has adopted some additional goals, which motivate some of the major extensions in NFSv4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイナーバージョンとして、NFSv4.1はNFSv4の全体的な目標と一致していますが、NFSv4.0の経験に基づいて、これらの目標をよりよく満たすようにプロトコルを拡張しています。さらに、NFSv4.1は、NFSv4.1の主要な拡張機能のいくつかを動機付けるいくつかの追加目標を採用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-2--Requirements-Language">
1.2. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. 要件言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [1]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-3--Scope-of-This-Document">
1.3. Scope of This Document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. このドキュメントの範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes the NFSv4.1 protocol. With respect to NFSv4.0, this document does not:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、NFSv4.1プロトコルについて説明します。 NFSv4.0に関して、このドキュメントは以下を行いません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o describe the NFSv4.0 protocol, except where needed to contrast with NFSv4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1と対比する必要がある場合を除いて、NFSv4.0プロトコルについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o modify the specification of the NFSv4.0 protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.0プロトコルの仕様を変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o clarify the NFSv4.0 protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.0プロトコルを明確にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4--NFSv4-Goals">
1.4. NFSv4 Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. NFSv4の目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4 protocol is a further revision of the NFS protocol defined already by NFSv3 [31]. It retains the essential characteristics of previous versions: easy recovery; independence of transport protocols, operating systems, and file systems; simplicity; and good performance. NFSv4 has the following goals:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4プロトコルは、NFSv3 [31]によってすでに定義されているNFSプロトコルのさらなる改訂版です。以前のバージョンの本質的な特徴を保持しています。トランスポートプロトコル、オペレーティングシステム、およびファイルシステムの独立性。シンプルさ。そして良いパフォーマンス。 NFSv4には次の目標があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Improved access and good performance on the Internet
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o インターネットでのアクセスの向上と優れたパフォーマンス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol is designed to transit firewalls easily, perform well where latency is high and bandwidth is low, and scale to very large numbers of clients per server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このプロトコルは、ファイアウォールを簡単に通過できるように設計されており、レイテンシが高く帯域幅が低い場合に良好に機能し、サーバーごとに非常に多くのクライアントに対応できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Strong security with negotiation built into the protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o プロトコルに組み込まれた交渉による強力なセキュリティ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol builds on the work of the ONCRPC working group in supporting the RPCSEC_GSS protocol. Additionally, the NFSv4.1 protocol provides a mechanism to allow clients and servers the ability to negotiate security and require clients and servers to support a minimal set of security schemes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このプロトコルは、RPCSEC_GSSプロトコルをサポートするONCRPCワーキンググループの作業に基づいています。さらに、NFSv4.1プロトコルは、クライアントとサーバーがセキュリティをネゴシエートできるようにするメカニズムを提供し、クライアントとサーバーが最小限のセキュリティスキームのセットをサポートすることを要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Good cross-platform interoperability
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 優れたクロスプラットフォームの相互運用性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol features a file system model that provides a useful, common set of features that does not unduly favor one file system or operating system over another.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
プロトコルは、ファイルシステムまたはオペレーティングシステムを過度に優先しない便利で一般的な機能セットを提供するファイルシステムモデルを備えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Designed for protocol extensions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o プロトコル拡張用に設計
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol is designed to accept standard extensions within a framework that enables and encourages backward compatibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
プロトコルは、下位互換性を有効にして促進するフレームワーク内の標準拡張を受け入れるように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-5--NFSv4-1-Goals">
1.5. NFSv4.1 Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.5. NFSv4.1の目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 has the following goals, within the framework established by the overall NFSv4 goals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1には、NFSv4全体の目標によって確立されたフレームワーク内で、次の目標があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To correct significant structural weaknesses and oversights discovered in the base protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 基本プロトコルで発見された重大な構造上の弱点と見落としを修正するため。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To add clarity and specificity to areas left unaddressed or not addressed in sufficient detail in the base protocol. However, as stated in Section 1.3, it is not a goal to clarify the NFSv4.0 protocol in the NFSv4.1 specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 基本プロトコルで十分に詳細に説明されていない、または説明されていない領域に明確さと特異性を追加するため。ただし、セクション1.3で述べたように、NFSv4.1仕様でNFSv4.0プロトコルを明確にすることは目標ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To add specific features based on experience with the existing protocol and recent industry developments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 既存のプロトコルの経験と最近の業界の発展に基づいて特定の機能を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To provide protocol support to take advantage of clustered server deployments including the ability to provide scalable parallel access to files distributed among multiple servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 複数のサーバーに分散されたファイルへのスケーラブルな並列アクセスを提供する機能を含む、クラスター化されたサーバー展開を利用するためのプロトコルサポートを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-6--General-Definitions">
1.6. General Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.6. 一般的な定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following definitions provide an appropriate context for the reader.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の定義は、読者に適切なコンテキストを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Byte: In this document, a byte is an octet, i.e., a datum exactly 8 bits in length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイト：このドキュメントでは、バイトはオクテット、つまり長さがちょうど8ビットのデータムです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client: The client is the entity that accesses the NFS server&#39;s resources. The client may be an application that contains the logic to access the NFS server directly. The client may also be the traditional operating system client that provides remote file system services for a set of applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント：クライアントは、NFSサーバーのリソースにアクセスするエンティティです。クライアントは、NFSサーバーに直接アクセスするためのロジックを含むアプリケーションである場合があります。クライアントは、一連のアプリケーションにリモートファイルシステムサービスを提供する従来のオペレーティングシステムクライアントでもかまいません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A client is uniquely identified by a client owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントは、クライアントの所有者によって一意に識別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
With reference to byte-range locking, the client is also the entity that maintains a set of locks on behalf of one or more applications. This client is responsible for crash or failure recovery for those locks it manages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
バイト範囲のロックに関して、クライアントは、1つ以上のアプリケーションのために一連のロックを維持するエンティティでもあります。このクライアントは、管理するロックのクラッシュまたは障害回復を担当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note that multiple clients may share the same transport and connection and multiple clients may exist on the same network node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
複数のクライアントが同じトランスポートと接続を共有し、複数のクライアントが同じネットワークノードに存在する場合があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client ID: The client ID is a 64-bit quantity used as a unique, short-hand reference to a client-supplied verifier and client owner. The server is responsible for supplying the client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントID：クライアントIDは64ビットの数量であり、クライアントが提供するベリファイアおよびクライアントの所有者への一意の短縮形の参照として使用されます。サーバーは、クライアントIDを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client Owner: The client owner is a unique string, opaque to the server, that identifies a client. Multiple network connections and source network addresses originating from those connections may share a client owner. The server is expected to treat requests from connections with the same client owner as coming from the same client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント所有者：クライアント所有者は、クライアントを識別する、サーバーに対して不透明な一意の文字列です。複数のネットワーク接続とそれらの接続から発信されたソースネットワークアドレスは、クライアントの所有者を共有する場合があります。サーバーは、同じクライアント所有者との接続からの要求を、同じクライアントからの要求として扱うことが期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
File System: The file system is the collection of objects on a server (as identified by the major identifier of a server owner, which is defined later in this section) that share the same fsid attribute (see Section 5.8.1.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステム：ファイルシステムは、同じfsid属性を共有するサーバー上のオブジェクトのコレクションです（このセクションの後半で定義されるサーバー所有者の主要な識別子によって識別されます）（5.8.1.9を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lease: A lease is an interval of time defined by the server for which the client is irrevocably granted locks. At the end of a lease period, locks may be revoked if the lease has not been extended. A lock must be revoked if a conflicting lock has been granted after the lease interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リース：リースは、クライアントがロックを取り返しのつかない形で許可されているサーバーによって定義される時間間隔です。リース期間の終了時に、リースが延長されていない場合、ロックが取り消されることがあります。リース期間後に競合するロックが付与されている場合は、ロックを取り消す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A server grants a client a single lease for all state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、すべての状態に対して単一のリースをクライアントに許可します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lock: The term &#34;lock&#34; is used to refer to byte-range (in UNIX environments, also known as record) locks, share reservations, delegations, or layouts unless specifically stated otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック：「ロック」という用語は、特に明記されていない限り、（UNIX環境ではレコードとも呼ばれる）バイト範囲のロック、共有予約、委任、またはレイアウトを指すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Secret State Verifier (SSV): The SSV is a unique secret key shared between a client and server. The SSV serves as the secret key for an internal (that is, internal to NFSv4.1) Generic Security Services (GSS) mechanism (the SSV GSS mechanism; see Section 2.10.9). The SSV GSS mechanism uses the SSV to compute message integrity code (MIC) and Wrap tokens. See Section 2.10.8.3 for more details on how NFSv4.1 uses the SSV and the SSV GSS mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Secret State Verifier（SSV）：SSVは、クライアントとサーバー間で共有される一意の秘密鍵です。 SSVは、内部（つまりNFSv4.1の内部）のGeneric Security Services（GSS）メカニズム（SSV GSSメカニズム。セクション2.10.9を参照）の秘密鍵として機能します。 SSV GSSメカニズムは、SSVを使用してメッセージ整合性コード（MIC）とラップトークンを計算します。 NFSv4.1がSSVおよびSSV GSSメカニズムを使用する方法の詳細については、セクション2.10.8.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server: The Server is the entity responsible for coordinating client access to a set of file systems and is identified by a server owner. A server can span multiple network addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー：サーバーは、一連のファイルシステムへのクライアントアクセスの調整を担当するエンティティであり、サーバーの所有者によって識別されます。サーバーは複数のネットワークアドレスにまたがることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server Owner: The server owner identifies the server to the client. The server owner consists of a major identifier and a minor identifier. When the client has two connections each to a peer with the same major identifier, the client assumes that both peers are the same server (the server namespace is the same via each connection) and that lock state is sharable across both connections. When each peer has both the same major and minor identifiers, the client assumes that each connection might be associable with the same session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー所有者：サーバー所有者は、クライアントに対してサーバーを識別します。サーバー所有者は、メジャーIDとマイナーIDで構成されます。クライアントが同じメジャー識別子を持つピアへの接続をそれぞれ2つ持っている場合、クライアントは両方のピアが同じサーバー（サーバーの名前空間は各接続を通じて同じ）であると想定し、ロック状態は両方の接続で共有可能です。各ピアが同じメジャーIDとマイナーIDの両方を持っている場合、クライアントは、各接続が同じセッションに関連付けられている可能性があると想定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stable Storage: Stable storage is storage from which data stored by an NFSv4.1 server can be recovered without data loss from multiple power failures (including cascading power failures, that is, several power failures in quick succession), operating system failures, and/or hardware failure of components other than the storage medium itself (such as disk, nonvolatile RAM, flash memory, etc.).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安定したストレージ：安定したストレージとは、NFSv4.1サーバーによって保存されたデータを、複数の電源障害（カスケード電源障害、つまり連続した複数の電源障害を含む）、オペレーティングシステムの障害、および/またはまたは、ストレージメディア自体以外のコンポーネント（ディスク、不揮発性RAM、フラッシュメモリなど）のハードウェア障害。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Some examples of stable storage that are allowable for an NFS server include: 1. Media commit of data; that is, the modified data has been successfully written to the disk media, for example, the disk platter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFSサーバーで許容される安定したストレージの例には、次のものがあります。1.データのメディアコミット。つまり、変更されたデータはディスクメディア（ディスクプラッターなど）に正常に書き込まれました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. An immediate reply disk drive with battery-backed, on-drive intermediate storage or uninterruptible power system (UPS).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. バッテリバックアップ式のドライブ上の中間ストレージまたは無停電電源システム（UPS）を備えた即時応答ディスクドライブ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. Server commit of data with battery-backed intermediate storage and recovery software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. バッテリバックアップ式の中間ストレージおよびリカバリソフトウェアを使用した、サーバーによるデータのコミット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4. Cache commit with uninterruptible power system (UPS) and recovery software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4. 無停電電源システム（UPS）と回復ソフトウェアによるキャッシュコミット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateid: A stateid is a 128-bit quantity returned by a server that uniquely defines the open and locking states provided by the server for a specific open-owner or lock-owner/open-owner pair for a specific file and type of lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateid：Stateidは、サーバーによって返される128ビットの数量であり、特定のファイルとロックのタイプについて、特定のオープン所有者またはロック所有者/オープン所有者のペアに対してサーバーによって提供されるオープン状態とロック状態を一意に定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Verifier: A verifier is a 64-bit quantity generated by the client that the server can use to determine if the client has restarted and lost all previous lock state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベリファイア：ベリファイアはクライアントによって生成された64ビットの量であり、サーバーがクライアントを再起動して以前のロック状態をすべて失ったかどうかを判断するために使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-7--Overview-of-NFSv4-1-Features">
1.7. Overview of NFSv4.1 Features
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.7. NFSv4.1機能の概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The major features of the NFSv4.1 protocol will be reviewed in brief. This will be done to provide an appropriate context for both the reader who is familiar with the previous versions of the NFS protocol and the reader who is new to the NFS protocols. For the reader new to the NFS protocols, there is still a set of fundamental knowledge that is expected. The reader should be familiar with the External Data Representation (XDR) and Remote Procedure Call (RPC) protocols as described in [2] and [3]. A basic knowledge of file systems and distributed file systems is expected as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1プロトコルの主な機能について簡単に説明します。これは、NFSプロトコルの以前のバージョンに精通している読者と、NFSプロトコルに不慣れな読者の両方に適切なコンテキストを提供するために行われます。 NFSプロトコルを初めて使用する読者にとって、期待される基本的な知識のセットはまだあります。 [2]および[3]で説明されているように、読者は外部データ表現（XDR）およびリモートプロシージャコール（RPC）プロトコルに精通している必要があります。ファイルシステムと分散ファイルシステムの基本的な知識も必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, this specification of NFSv4.1 will not distinguish those features added in minor version 1 from those present in the base protocol but will treat NFSv4.1 as a unified whole. See Section 1.8 for a summary of the differences between NFSv4.0 and NFSv4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般に、NFSv4.1のこの仕様は、マイナーバージョン1で追加された機能と基本プロトコルに存在する機能を区別しませんが、NFSv4.1を統一された全体として扱います。 NFSv4.0とNFSv4.1の違いの概要については、セクション1.8を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-7-1--RPC-and-Security">
1.7.1. RPC and Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.7.1. RPCとセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 As with previous versions of NFS, the External Data Representation (XDR) and Remote Procedure Call (RPC) mechanisms used for the NFSv4.1 protocol are those defined in [2] and [3]. To meet end-to-end security requirements, the RPCSEC_GSS framework [4] is used to extend the basic RPC security. With the use of RPCSEC_GSS, various mechanisms can be provided to offer authentication, integrity, and privacy to the NFSv4 protocol. Kerberos V5 is used as described in [5] to provide one security framework. With the use of RPCSEC_GSS, other mechanisms may also be specified and used for NFSv4.1 security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
以前のバージョンのNFSと同様に、NFSv4.1プロトコルに使用される外部データ表現（XDR）およびリモートプロシージャコール（RPC）メカニズムは、[2]および[3]で定義されたものです。エンドツーエンドのセキュリティ要件を満たすために、RPCSEC_GSSフレームワーク[4]を使用して、基本的なRPCセキュリティを拡張します。 RPCSEC_GSSを使用すると、NFSv4プロトコルに認証、整合性、およびプライバシーを提供するさまざまなメカニズムを提供できます。 Kerberos V5は、[5]で説明されているように使用され、1つのセキュリティフレームワークを提供します。 RPCSEC_GSSを使用すると、NFSv4.1セキュリティーのために他のメカニズムも指定および使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To enable in-band security negotiation, the NFSv4.1 protocol has operations that provide the client a method of querying the server about its policies regarding which security mechanisms must be used for access to the server&#39;s file system resources. With this, the client can securely match the security mechanism that meets the policies specified at both the client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
帯域内セキュリティネゴシエーションを有効にするために、NFSv4.1プロトコルには、サーバーのファイルシステムリソースへのアクセスに使用する必要のあるセキュリティメカニズムに関するポリシーについてサーバーに問い合わせる方法をクライアントに提供する操作があります。これにより、クライアントは、クライアントとサーバーの両方で指定されたポリシーを満たすセキュリティメカニズムに安全に一致させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 introduces parallel access (see Section 1.7.2.2), which is called pNFS. The security framework described in this section is significantly modified by the introduction of pNFS (see Section 12.9), because data access is sometimes not over RPC. The level of significance varies with the storage protocol (see Section 12.2.5) and can be as low as zero impact (see Section 13.12).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1では、pNFSと呼ばれる並列アクセス（セクション1.7.2.2を参照）が導入されています。このセクションで説明するセキュリティフレームワークは、pNFSの導入（セクション12.9を参照）によって大幅に変更されています。これは、データアクセスがRPCを経由しない場合があるためです。有意性のレベルは、ストレージプロトコル（セクション12.2.5を参照）によって異なり、影響を最小限に抑えることができます（セクション13.12を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-7-2--Protocol-Structure">
1.7.2. Protocol Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.7.2. プロトコル構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-7-2-1--Core-Protocol">
1.7.2.1. Core Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.7.2.1. コアプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike NFSv3, which used a series of ancillary protocols (e.g., NLM, NSM (Network Status Monitor), MOUNT), within all minor versions of NFSv4 a single RPC protocol is used to make requests to the server. Facilities that had been separate protocols, such as locking, are now integrated within a single unified protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一連の補助プロトコル（NLM、NSM（ネットワークステータスモニター）、MOUNTなど）を使用したNFSv3とは異なり、NFSv4のすべてのマイナーバージョンでは、単一のRPCプロトコルを使用してサーバーにリクエストを送信します。ロックなどの個別のプロトコルであった機能は、現在、単一の統合プロトコルに統合されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-7-2-2--Parallel-Access">
1.7.2.2. Parallel Access
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.7.2.2. 並列アクセス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Minor version 1 supports high-performance data access to a clustered server implementation by enabling a separation of metadata access and data access, with the latter done to multiple servers in parallel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイナーバージョン1は、メタデータアクセスとデータアクセスの分離を有効にすることにより、クラスター化されたサーバー実装への高性能データアクセスをサポートし、後者は複数のサーバーに対して並列に実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Such parallel data access is controlled by recallable objects known as &#34;layouts&#34;, which are integrated into the protocol locking model. Clients direct requests for data access to a set of data servers specified by the layout via a data storage protocol which may be NFSv4.1 or may be another protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような並列データアクセスは、「ロックアウト」と呼ばれるリコール可能なオブジェクトによって制御され、プロトコルロックモデルに統合されています。クライアントは、NFSv4.1または別のプロトコルのデータストレージプロトコルを介して、レイアウトで指定された一連のデータサーバーにデータアクセスの要求を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the protocols used for parallel data access are not necessarily RPC-based, the RPC-based security model (Section 1.7.1) is obviously impacted (see Section 12.9). The degree of impact varies with the storage protocol (see Section 12.2.5) used for data access, and can be as low as zero (see Section 13.12).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
並列データアクセスに使用されるプロトコルは必ずしもRPCベースではないため、RPCベースのセキュリティモデル（セクション1.7.1）は明らかに影響を受けます（セクション12.9を参照）。影響の程度は、データアクセスに使用されるストレージプロトコル（セクション12.2.5を参照）によって異なり、ゼロ（セクション13.12を参照）まで低くなることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-7-3--File-System-Model">
1.7.3. File System Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.7.3. ファイルシステムモデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The general file system model used for the NFSv4.1 protocol is the same as previous versions. The server file system is hierarchical with the regular files contained within being treated as opaque byte streams. In a slight departure, file and directory names are encoded with UTF-8 to deal with the basics of internationalization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1プロトコルに使用される一般的なファイルシステムモデルは、以前のバージョンと同じです。サーバーファイルシステムは階層構造になっており、通常のファイルは不透明なバイトストリームとして扱われます。わずかな出発点として、ファイル名とディレクトリ名は国際化の基本に対処するためにUTF-8でエンコードされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 protocol does not require a separate protocol to provide for the initial mapping between path name and filehandle. All file systems exported by a server are presented as a tree so that all file systems are reachable from a special per-server global root filehandle. This allows LOOKUP operations to be used to perform functions previously provided by the MOUNT protocol. The server provides any necessary pseudo file systems to bridge any gaps that arise due to unexported gaps between exported file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1プロトコルは、パス名とファイルハンドル間の初期マッピングを提供するために、別個のプロトコルを必要としません。サーバーによってエクスポートされるすべてのファイルシステムはツリーとして表示されるため、すべてのファイルシステムはサーバーごとの特別なグローバルルートファイルハンドルから到達可能です。これにより、LOOKUP操作を使用して、以前にMOUNTプロトコルで提供されていた機能を実行できます。サーバーは、エクスポートされたファイルシステム間のエクスポートされていないギャップによって生じるギャップを埋めるために必要な疑似ファイルシステムを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-7-3-1--Filehandles">
1.7.3.1. Filehandles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.7.3.1. ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As in previous versions of the NFS protocol, opaque filehandles are used to identify individual files and directories. Lookup-type and create operations translate file and directory names to filehandles, which are then used to identify objects in subsequent operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のバージョンのNFSプロトコルと同様に、不透明なファイルハンドルを使用して、個々のファイルとディレクトリを識別します。ルックアップタイプおよび作成操作は、ファイル名とディレクトリ名をファイルハンドルに変換します。これらは、その後の操作でオブジェクトを識別するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 protocol provides support for persistent filehandles, guaranteed to be valid for the lifetime of the file system object designated. In addition, it provides support to servers to provide filehandles with more limited validity guarantees, called volatile filehandles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1プロトコルは、永続的なファイルハンドルのサポートを提供し、指定されたファイルシステムオブジェクトの存続期間中有効であることを保証します。さらに、それはサーバーにサポートを提供し、揮発性ファイルハンドルと呼ばれる、より限定された有効性保証を備えたファイルハンドルを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-7-3-2--File-Attributes">
1.7.3.2. File Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.7.3.2. ファイル属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 protocol has a rich and extensible file object attribute structure, which is divided into REQUIRED, RECOMMENDED, and named attributes (see Section 5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1プロトコルには、豊富で拡張可能なファイルオブジェクトの属性構造があり、REQUIRED、RECOMMENDED、およびnamed属性に分かれています（セクション5を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several (but not all) of the REQUIRED attributes are derived from the attributes of NFSv3 (see the definition of the fattr3 data type in [31]). An example of a REQUIRED attribute is the file object&#39;s type (Section 5.8.1.2) so that regular files can be distinguished from directories (also known as folders in some operating environments) and other types of objects. REQUIRED attributes are discussed in Section 5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQUIRED属性のいくつか（すべてではない）は、NFSv3の属性から派生しています（[31]のfattr3データ型の定義を参照してください）。 REQUIRED属性の例は、ファイルオブジェクトのタイプ（5.8.1.2項）です。これにより、通常のファイルをディレクトリ（一部の動作環境ではフォルダとも呼ばれます）や他のタイプのオブジェクトと区別できます。必須属性については、セクション5.1で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 An example of three RECOMMENDED attributes are acl, sacl, and dacl. These attributes define an Access Control List (ACL) on a file object (Section 6). An ACL provides directory and file access control beyond the model used in NFSv3. The ACL definition allows for specification of specific sets of permissions for individual users and groups. In addition, ACL inheritance allows propagation of access permissions and restrictions down a directory tree as file system objects are created. RECOMMENDED attributes are discussed in Section 5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
3つのRECOMMENDED属性の例は、acl、sacl、daclです。これらの属性は、ファイルオブジェクトのアクセス制御リスト（ACL）を定義します（セクション6）。 ACLは、NFSv3で使用されるモデルを超えたディレクトリおよびファイルアクセス制御を提供します。 ACL定義では、個々のユーザーとグループに特定の権限セットを指定できます。さらに、ACLの継承により、ファイルシステムオブジェクトが作成されたときに、アクセス許可と制限をディレクトリツリーに伝達できます。推奨される属性については、セクション5.2で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A named attribute is an opaque byte stream that is associated with a directory or file and referred to by a string name. Named attributes are meant to be used by client applications as a method to associate application-specific data with a regular file or directory. NFSv4.1 modifies named attributes relative to NFSv4.0 by tightening the allowed operations in order to prevent the development of non-interoperable implementations. Named attributes are discussed in Section 5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付き属性は、ディレクトリまたはファイルに関連付けられ、文字列名で参照される不透明なバイトストリームです。名前付き属性は、アプリケーション固有のデータを通常のファイルまたはディレクトリに関連付ける方法としてクライアントアプリケーションによって使用されることを意図しています。 NFSv4.1は、相互運用性のない実装の開発を防ぐために、許可される操作を厳しくすることにより、NFSv4.0に関連する名前付き属性を変更します。名前付き属性については、セクション5.3で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-7-3-3--Multi-Server-Namespace">
1.7.3.3. Multi-Server Namespace
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.7.3.3. マルチサーバー名前空間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 contains a number of features to allow implementation of namespaces that cross server boundaries and that allow and facilitate a non-disruptive transfer of support for individual file systems between servers. They are all based upon attributes that allow one file system to specify alternate or new locations for that file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1には、サーバーの境界を越える名前空間の実装を可能にし、サーバー間の個々のファイルシステムのサポートを無停止で転送できるようにする多数の機能が含まれています。これらはすべて、1つのファイルシステムがそのファイルシステムの代替または新しい場所を指定できるようにする属性に基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These attributes may be used together with the concept of absent file systems, which provide specifications for additional locations but no actual file system content. This allows a number of important facilities:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの属性は、追加の場所の仕様を提供しますが、実際のファイルシステムのコンテンツは提供しない、存在しないファイルシステムの概念と一緒に使用できます。これにより、いくつかの重要な機能が可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Location attributes may be used with absent file systems to implement referrals whereby one server may direct the client to a file system provided by another server. This allows extensive multi-server namespaces to be constructed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ロケーション属性は、存在しないファイルシステムで使用して紹介を実装することができます。これにより、あるサーバーが別のサーバーが提供するファイルシステムにクライアントを誘導できます。これにより、広範なマルチサーバー名前空間を構築できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Location attributes may be provided for present file systems to provide the locations of alternate file system instances or replicas to be used in the event that the current file system instance becomes unavailable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 現在のファイルシステムインスタンスが使用できなくなった場合に使用される代替ファイルシステムインスタンスまたはレプリカの場所を提供するために、現在のファイルシステムに場所属性を提供できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Location attributes may be provided when a previously present file system becomes absent. This allows non-disruptive migration of file systems to alternate servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 以前に存在していたファイルシステムが存在しなくなったときに、場所属性が提供される場合があります。これにより、ファイルシステムを無停止で代替サーバーに移行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-7-4--Locking-Facilities">
1.7.4. Locking Facilities
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.7.4. ロック施設
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned previously, NFSv4.1 is a single protocol that includes locking facilities. These locking facilities include support for many types of locks including a number of sorts of recallable locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前述のように、NFSv4.1はロック機能を含む単一のプロトコルです。これらのロック機能には、さまざまな種類の再呼び出し可能なロックを含む、さまざまなタイプのロックのサポートが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recallable locks such as delegations allow the client to be assured that certain events will not occur so long as that lock is held. When circumstances change, the lock is recalled via a callback request. The assurances provided by delegations allow more extensive caching to be done safely when circumstances allow it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任などの呼び出し可能なロックにより、クライアントは、そのロックが保持されている限り、特定のイベントが発生しないことを保証できます。状況が変化すると、ロックはコールバック要求を介して呼び出されます。委任によって提供される保証により、状況によっては、より広範なキャッシュを安全に行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The types of locks are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックのタイプは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Share reservations as established by OPEN operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN操作によって確立された予約を共有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Byte-range locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイト範囲ロック。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o File delegations, which are recallable locks that assure the holder that inconsistent opens and file changes cannot occur so long as the delegation is held.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルの委任。これは、委任が保持されている限り、一貫性のないオープンとファイルの変更が発生しないことを保持者に保証するリコール可能なロックです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Directory delegations, which are recallable locks that assure the holder that inconsistent directory modifications cannot occur so long as the delegation is held.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 委任が保持されている限り、一貫性のないディレクトリ変更が発生しないことを保持者に保証する、呼び出し可能なロックであるディレクトリ委任。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Layouts, which are recallable objects that assure the holder that direct access to the file data may be performed directly by the client and that no change to the data&#39;s location that is inconsistent with that access may be made so long as the layout is held.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o レイアウトは、ファイルデータへの直接アクセスをクライアントが直接実行できること、およびレイアウトが保持されている限り、そのアクセスと矛盾するデータの場所への変更が行われないことを保証するリコール可能なオブジェクトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All locks for a given client are tied together under a single client-wide lease. All requests made on sessions associated with the client renew that lease. When the client&#39;s lease is not promptly renewed, the client&#39;s locks are subject to revocation. In the event of server restart, clients have the opportunity to safely reclaim their locks within a special grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のクライアントのすべてのロックは、単一のクライアント全体のリースの下で結合されます。クライアントに関連付けられたセッションで行われたすべての要求は、そのリースを更新します。クライアントのリースがすぐに更新されない場合、クライアントのロックは取り消されます。サーバーが再起動した場合、クライアントは特別な猶予期間内に安全にロックを取り戻すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-8--Differences-from-NFSv4-0">
1.8. Differences from NFSv4.0
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.8. NFSv4.0との違い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following summarizes the major differences between minor version 1 and the base protocol:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、マイナーバージョン1と基本プロトコルの主な違いを要約したものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Implementation of the sessions model (Section 2.10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セッションモデルの実装（セクション2.10）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Parallel access to data (Section 12).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o データへの並列アクセス（セクション12）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Addition of the RECLAIM_COMPLETE operation to better structure the lock reclamation process (Section 18.51).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RECLAIM_COMPLETE操作を追加して、ロック再利用プロセスをより適切に構成します（セクション18.51）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Enhanced delegation support as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 次のように強化された委任サポート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Delegations on directories and other file types in addition to regular files (Section 18.39, Section 18.49).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 通常のファイル（セクション18.39、セクション18.49）に加えて、ディレクトリおよびその他のファイルタイプの委任。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Operations to optimize acquisition of recalled or denied delegations (Section 18.49, Section 20.5, Section 20.7).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* リコールまたは拒否された委任の取得を最適化する操作（セクション18.49、セクション20.5、セクション20.7）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Notifications of changes to files and directories (Section 18.39, Section 20.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ファイルとディレクトリへの変更の通知（セクション18.39、セクション20.4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* A method to allow a server to indicate that it is recalling one or more delegations for resource management reasons, and thus a method to allow the client to pick which delegations to return (Section 20.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* サーバーがリソース管理上の理由で1つ以上の委任を呼び出していることを示すことができるメソッド。したがって、クライアントが返す委任を選択できるようにするメソッド（セクション20.6）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Attributes can be set atomically during exclusive file create via the OPEN operation (see the new EXCLUSIVE4_1 creation method in Section 18.16).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 属性は、OPEN操作による排他的なファイルの作成中にアトミックに設定できます（セクション18.16の新しいEXCLUSIVE4_1作成メソッドを参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Open files can be preserved if removed and the hard link count (&#34;hard link&#34; is defined in an Open Group [Section 3.191 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232&#34;&#34;&gt;6] standard) goes to zero, thus obviating the need for clients to rename deleted files to partially hidden names -- colloquially called &#34;silly rename&#34; (see the new OPEN4_RESULT_PRESERVE_UNLINKED reply flag in Section 18.16).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o オープンファイルは、削除されても保持され、ハードリンクカウント（「ハードリンク」はOpen Groupで定義されます[Open Group基本仕様のベース定義の第3章のセクション3.191、IEEE Std 1003.1、2004 Edition、HTMLバージョン（ www.opengroup.org）、ISBN 1931624232 &#34;&#34;&gt; 6]標準）はゼロになり、クライアントが削除されたファイルの名前を部分的に非表示の名前に変更する必要がなくなります。セクション18.16）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Improved compatibility with Microsoft Windows for Access Control Lists (Section 6.2.3, Section 6.2.2, Section 6.4.3.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Microsoft Windowsとのアクセス制御リストの互換性が向上しました（セクション6.2.3、セクション6.2.2、セクション6.4.3.2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Data retention (Section 5.13).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o データ保持（セクション5.13）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Identification of the implementation of the NFS client and server (Section 18.35).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSクライアントとサーバーの実装の識別（セクション18.35）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Support for notification of the availability of byte-range locks (see the new OPEN4_RESULT_MAY_NOTIFY_LOCK reply flag in Section 18.16 and see Section 20.11).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイト範囲ロックの可用性の通知のサポート（セクション18.16の新しいOPEN4_RESULT_MAY_NOTIFY_LOCK応答フラグとセクション20.11を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In NFSv4.1, LIPKEY and SPKM-3 are not required security mechanisms [32].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1では、LIPKEYとSPKM-3は必須のセキュリティメカニズムではありません[32]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Core-Infrastructure">
2. Core Infrastructure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. コアインフラストラクチャ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1--Introduction">
2.1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 relies on core infrastructure common to nearly every operation. This core infrastructure is described in the remainder of this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1は、ほぼすべての操作に共通のコアインフラストラクチャに依存しています。このコアインフラストラクチャについては、このセクションの残りの部分で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2--RPC-and-XDR">
2.2. RPC and XDR
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. RPCとXDR
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 protocol is a Remote Procedure Call (RPC) application that uses RPC version 2 and the corresponding eXternal Data Representation (XDR) as defined in [3] and [2].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1プロトコルは、RPCバージョン2と、[3]および[2]で定義されている対応する外部データ表現（XDR）を使用するリモートプロシージャコール（RPC）アプリケーションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2-1--RPC-Based-Security">
2.2.1. RPC-Based Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1. RPCベースのセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Previous NFS versions have been thought of as having a host-based authentication model, where the NFS server authenticates the NFS client, and trusts the client to authenticate all users. Actually, NFS has always depended on RPC for authentication. One of the first forms of RPC authentication, AUTH_SYS, had no strong authentication and required a host-based authentication approach. NFSv4.1 also depends on RPC for basic security services and mandates RPC support for a user-based authentication model. The user-based authentication model has user principals authenticated by a server, and in turn the server authenticated by user principals. RPC provides some basic security services that are used by NFSv4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のNFSバージョンは、NFSサーバーがNFSクライアントを認証し、クライアントを信頼してすべてのユーザーを認証するホストベースの認証モデルを持つと考えられていました。実際、NFSは常にRPCに依存して認証を行ってきました。 RPC認証の最初の形式の1つであるAUTH_SYSには強力な認証がなく、ホストベースの認証アプローチが必要でした。 NFSv4.1は、基本的なセキュリティサービスをRPCに依存し、ユーザーベースの認証モデルのRPCサポートを義務付けています。ユーザーベースの認証モデルでは、サーバーによって認証されたユーザープリンシパルがあり、サーバーはユーザープリンシパルによって認証されています。 RPCは、NFSv4.1で使用されるいくつかの基本的なセキュリティサービスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2-1-1--RPC-Security-Flavors">
2.2.1.1. RPC Security Flavors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1.1. RPCセキュリティフレーバー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 7.2 (&#34;Authentication&#34;) of [3], RPC security is encapsulated in the RPC header, via a security or authentication flavor, and information specific to the specified security flavor. Every RPC header conveys information used to identify and authenticate a client and server. As discussed in Section 2.2.1.1.1, some security flavors provide additional security services.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3]のセクション7.2（「認証」）で説明されているように、RPCセキュリティは、セキュリティまたは認証フレーバー、および指定されたセキュリティフレーバーに固有の情報を介して、RPCヘッダーにカプセル化されます。すべてのRPCヘッダーは、クライアントとサーバーの識別と認証に使用される情報を伝達します。セクション2.2.1.1.1で説明したように、一部のセキュリティフレーバーは追加のセキュリティサービスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 clients and servers MUST implement RPCSEC_GSS. (This requirement to implement is not a requirement to use.) Other flavors, such as AUTH_NONE and AUTH_SYS, MAY be implemented as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1クライアントとサーバーは、RPCSEC_GSSを実装する必要があります。 （この実装するための要件は、使用するための要件ではありません。）AUTH_NONEやAUTH_SYSなどの他のフレーバーも実装できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2-1-1-1--RPCSECGSS-and-Security-Services">
2.2.1.1.1. RPCSEC_GSS and Security Services
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1.1.1. RPCSEC_GSSおよびセキュリティサービス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSS [4] uses the functionality of GSS-API [7]. This allows for the use of various security mechanisms by the RPC layer without the additional implementation overhead of adding RPC security flavors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSS [4]は、GSS-API [7]の機能を使用します。これにより、RPCセキュリティフレーバーを追加することによる追加の実装オーバーヘッドなしで、RPCレイヤーによるさまざまなセキュリティメカニズムの使用が可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2-1-1-1-1--Identification-Authentication-Integrity-Privacy">
2.2.1.1.1.1. Identification, Authentication, Integrity, Privacy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1.1.1.1. 識別、認証、完全性、プライバシー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Via the GSS-API, RPCSEC_GSS can be used to identify and authenticate users on clients to servers, and servers to users. It can also perform integrity checking on the entire RPC message, including the RPC header, and on the arguments or results. Finally, privacy, usually via encryption, is a service available with RPCSEC_GSS. Privacy is performed on the arguments and results. Note that if privacy is selected, integrity, authentication, and identification are enabled. If privacy is not selected, but integrity is selected, authentication and identification are enabled. If integrity and privacy are not selected, but authentication is enabled, identification is enabled. RPCSEC_GSS does not provide identification as a separate service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
GSS-APIを介して、RPCSEC_GSSを使用して、クライアントからサーバーへのユーザー、およびサーバーからユーザーへのユーザーを識別および認証できます。また、RPCヘッダーを含むRPCメッセージ全体、および引数や結果に対して整合性チェックを実行できます。最後に、通常は暗号化によるプライバシーは、RPCSEC_GSSで利用可能なサービスです。プライバシーは引数と結果に基づいて実行されます。プライバシーを選択すると、整合性、認証、および識別が有効になることに注意してください。プライバシーは選択されていないが、整合性は選択されている場合、認証と識別が有効になります。整合性とプライバシーが選択されていないが、認証が有効になっている場合、識別が有効になります。 RPCSEC_GSSは、個別のサービスとして識別を提供しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although GSS-API has an authentication service distinct from its privacy and integrity services, GSS-API&#39;s authentication service is not used for RPCSEC_GSS&#39;s authentication service. Instead, each RPC request and response header is integrity protected with the GSS-API integrity service, and this allows RPCSEC_GSS to offer per-RPC authentication and identity. See [4] for more information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GSS-APIには、プライバシーサービスと整合性サービスとは異なる認証サービスがありますが、GSS-APIの認証サービスは、RPCSEC_GSSの認証サービスには使用されません。代わりに、各RPC要求および応答ヘッダーはGSS-API整合性サービスで整合性が保護されており、これによりRPCSEC_GSSはRPCごとの認証とIDを提供できます。詳細については、[4]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 client and servers MUST support RPCSEC_GSS&#39;s integrity and authentication service. NFSv4.1 servers MUST support RPCSEC_GSS&#39;s privacy service. NFSv4.1 clients SHOULD support RPCSEC_GSS&#39;s privacy service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1クライアントとサーバーは、RPCSEC_GSSの整合性と認証サービスをサポートする必要があります。 NFSv4.1サーバーは、RPCSEC_GSSのプライバシーサービスをサポートする必要があります。 NFSv4.1クライアントはRPCSEC_GSSのプライバシーサービスをサポートする必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2-1-1-1-2--Security-Mechanisms-for-NFSv4-1">
2.2.1.1.1.2. Security Mechanisms for NFSv4.1
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1.1.1.2. NFSv4.1のセキュリティメカニズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSS, via GSS-API, normalizes access to mechanisms that provide security services. Therefore, NFSv4.1 clients and servers MUST support the Kerberos V5 security mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSSは、GSS-APIを介して、セキュリティサービスを提供するメカニズムへのアクセスを正規化します。したがって、NFSv4.1クライアントとサーバーはKerberos V5セキュリティメカニズムをサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of RPCSEC_GSS requires selection of mechanism, quality of protection (QOP), and service (authentication, integrity, privacy). For the mandated security mechanisms, NFSv4.1 specifies that a QOP of zero is used, leaving it up to the mechanism or the mechanism&#39;s configuration to map QOP zero to an appropriate level of protection. Each mandated mechanism specifies a minimum set of cryptographic algorithms for implementing integrity and privacy. NFSv4.1 clients and servers MUST be implemented on operating environments that comply with the REQUIRED cryptographic algorithms of each REQUIRED mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSSを使用するには、メカニズム、保護品質（QOP）、およびサービス（認証、整合性、プライバシー）を選択する必要があります。必須のセキュリティメカニズムの場合、NFSv4.1はゼロのQOPが使用されることを指定し、メカニズムまたはメカニズムの構成に任せて、QOPゼロを適切な保護レベルにマップします。各必須メカニズムは、整合性とプライバシーを実装するための暗号化アルゴリズムの最小セットを指定します。 NFSv4.1クライアントとサーバーは、各必須メカニズムの必須暗号化アルゴリズムに準拠する動作環境に実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2-1-1-1-2-1--Kerberos-V5">
2.2.1.1.1.2.1. Kerberos V5
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1.1.1.2.1. Kerberos V5
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Kerberos V5 GSS-API mechanism as described in [5] MUST be implemented with the RPCSEC_GSS services as specified in the following table:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5]で説明されているKerberos V5 GSS-APIメカニズムは、次の表で指定されているRPCSEC_GSSサービスを使用して実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      column descriptions:
      1 == number of pseudo flavor
      2 == name of pseudo flavor
      3 == mechanism&#39;s OID
      4 == RPCSEC_GSS service
      5 == NFSv4.1 clients MUST support
      6 == NFSv4.1 servers MUST support
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      1      2        3                    4                     5   6
      ------------------------------------------------------------------
      390003 krb5     1.2.840.113554.1.2.2 rpc_gss_svc_none      yes yes
      390004 krb5i    1.2.840.113554.1.2.2 rpc_gss_svc_integrity yes yes
      390005 krb5p    1.2.840.113554.1.2.2 rpc_gss_svc_privacy    no yes
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the number and name of the pseudo flavor are presented here as a mapping aid to the implementor. Because the NFSv4.1 protocol includes a method to negotiate security and it understands the GSS-API mechanism, the pseudo flavor is not needed. The pseudo flavor is needed for the NFSv3 since the security negotiation is done via the MOUNT protocol as described in [33].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
疑似フレーバーの数と名前は、実装者へのマッピング支援としてここに示されていることに注意してください。 NFSv4.1プロトコルには、セキュリティをネゴシエートするメソッドが含まれており、GSS-APIメカニズムを理解しているため、疑似フレーバーは必要ありません。 [33]で説明されているように、セキュリティネゴシエーションはMOUNTプロトコルを介して行われるため、NFSv3には疑似フレーバーが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the time NFSv4.1 was specified, the Advanced Encryption Standard (AES) with HMAC-SHA1 was a REQUIRED algorithm set for Kerberos V5. In contrast, when NFSv4.0 was specified, weaker algorithm sets were REQUIRED for Kerberos V5, and were REQUIRED in the NFSv4.0 specification, because the Kerberos V5 specification at the time did not specify stronger algorithms. The NFSv4.1 specification does not specify REQUIRED algorithms for Kerberos V5, and instead, the implementor is expected to track the evolution of the Kerberos V5 standard if and when stronger algorithms are specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1が指定された当時、HMAC-SHA1を備えたAdvanced Encryption Standard（AES）は、Kerberos V5に必要なアルゴリズムセットでした。対照的に、NFSv4.0が指定された場合、Kerberos V5仕様はより強力なアルゴリズムを指定しなかったため、より弱いアルゴリズムセットはKerberos V5に必須であり、NFSv4.0仕様で必須でした。 NFSv4.1仕様では、Kerberos V5の必須アルゴリズムは指定されていません。代わりに、より強力なアルゴリズムが指定されている場合、実装者はKerberos V5標準の進化を追跡することが期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.2.1.1.1.2.1.1. Security Considerations for Cryptographic Algorithms in Kerberos V5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.2.1.1.1.2.1.1. Kerberos V5の暗号化アルゴリズムのセキュリティに関する考慮事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When deploying NFSv4.1, the strength of the security achieved depends on the existing Kerberos V5 infrastructure. The algorithms of Kerberos V5 are not directly exposed to or selectable by the client or server, so there is some due diligence required by the user of NFSv4.1 to ensure that security is acceptable where needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1を導入する場合、達成されるセキュリティの強度は、既存のKerberos V5インフラストラクチャに依存します。 Kerberos V5のアルゴリズムは、クライアントやサーバーに直接公開されたり、選択したりすることができないため、NFSv4.1のユーザーは、必要な場所でセキュリティを確実に受け入れるために、ある程度の注意が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2-1-1-1-3--GSS-Server-Principal">
2.2.1.1.1.3. GSS Server Principal
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1.1.1.3. GSSサーバープリンシパル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of what security mechanism under RPCSEC_GSS is being used, the NFS server MUST identify itself in GSS-API via a GSS_C_NT_HOSTBASED_SERVICE name type. GSS_C_NT_HOSTBASED_SERVICE names are of the form:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSSで使用されているセキュリティメカニズムに関係なく、NFSサーバーはGSS_C_NT_HOSTBASED_SERVICE名前タイプを介してGSS-APIで自身を識別しなければなりません（MUST）。 GSS_C_NT_HOSTBASED_SERVICEの名前の形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
service@hostname
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
service @ hostname
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For NFS, the &#34;service&#34; element is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSの場合、「サービス」要素は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
nfs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
同じ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations of security mechanisms will convert nfs@hostname to various different forms. For Kerberos V5, the following form is RECOMMENDED:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティメカニズムを実装すると、nfs @ hostnameがさまざまな形式に変換されます。 Kerberos V5の場合、次の形式が推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
nfs/hostname
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
nfs /ホスト名
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3--COMPOUND-and-CBCOMPOUND">
2.3. COMPOUND and CB_COMPOUND
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. COMPOUNDおよびCB_COMPOUND
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A significant departure from the versions of the NFS protocol before NFSv4 is the introduction of the COMPOUND procedure. For the NFSv4 protocol, in all minor versions, there are exactly two RPC procedures, NULL and COMPOUND. The COMPOUND procedure is defined as a series of individual operations and these operations perform the sorts of functions performed by traditional NFS procedures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4より前のバージョンのNFSプロトコルとの大きな違いは、COMPOUNDプロシージャの導入です。 NFSv4プロトコルの場合、すべてのマイナーバージョンには、NULLとCOMPOUNDの2つのRPCプロシージャがあります。 COMPOUNDプロシージャは一連の個別の操作として定義され、これらの操作は従来のNFSプロシージャによって実行される種類の機能を実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operations combined within a COMPOUND request are evaluated in order by the server, without any atomicity guarantees. A limited set of facilities exist to pass results from one operation to another. Once an operation returns a failing result, the evaluation ends and the results of all evaluated operations are returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND要求内で結合された操作は、原子性の保証なしに、サーバーによって順番に評価されます。ある操作の結果を別の操作に渡すための限られたセットの機能が存在します。操作が失敗した結果を返すと、評価は終了し、評価されたすべての操作の結果がクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the use of the COMPOUND procedure, the client is able to build simple or complex requests. These COMPOUND requests allow for a reduction in the number of RPCs needed for logical file system operations. For example, multi-component look up requests can be constructed by combining multiple LOOKUP operations. Those can be further combined with operations such as GETATTR, READDIR, or OPEN plus READ to do more complicated sets of operation without incurring additional latency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャを使用すると、クライアントは単純または複雑な要求を作成できます。これらのCOMPOUND要求により、論理ファイルシステム操作に必要なRPCの数を減らすことができます。たとえば、複数コンポーネントのルックアップ要求は、複数のLOOKUP操作を組み合わせることで構築できます。これらをGETATTR、READDIR、またはOPENとREADなどの操作とさらに組み合わせて、追加のレイテンシを発生させることなく、より複雑な操作のセットを実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 also contains a considerable set of callback operations in which the server makes an RPC directed at the client. Callback RPCs have a similar structure to that of the normal server requests. In all minor versions of the NFSv4 protocol, there are two callback RPC procedures: CB_NULL and CB_COMPOUND. The CB_COMPOUND procedure is defined in an analogous fashion to that of COMPOUND with its own set of callback operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1には、サーバーがRPCをクライアントに向けるコールバック操作のかなりのセットも含まれています。コールバックRPCは、通常のサーバー要求と同様の構造を持っています。 NFSv4プロトコルのすべてのマイナーバージョンには、CB_NULLとCB_COMPOUNDの2つのコールバックRPCプロシージャがあります。 CB_COMPOUNDプロシージャは、独自のコールバック操作のセットを持つCOMPOUNDのプロシージャと同様に定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The addition of new server and callback operations within the COMPOUND and CB_COMPOUND request framework provides a means of extending the protocol in subsequent minor versions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDおよびCB_COMPOUND要求フレームワーク内に新しいサーバーとコールバック操作を追加すると、後続のマイナーバージョンでプロトコルを拡張する手段が提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Except for a small number of operations needed for session creation, server requests and callback requests are performed within the context of a session. Sessions provide a client context for every request and support robust reply protection for non-idempotent requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションの作成に必要な少数の操作を除いて、サーバー要求とコールバック要求はセッションのコンテキスト内で実行されます。セッションは、すべての要求にクライアントコンテキストを提供し、べき等でない要求に対する堅牢な応答保護をサポートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-4--Client-Identifiers-and-Client-Owners">
2.4. Client Identifiers and Client Owners
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. クライアント識別子とクライアント所有者
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each operation that obtains or depends on locking state, the specific client needs to be identifiable by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック状態を取得または依存する各操作について、特定のクライアントがサーバーによって識別可能である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each distinct client instance is represented by a client ID. A client ID is a 64-bit identifier representing a specific client at a given time. The client ID is changed whenever the client re-initializes, and may change when the server re-initializes. Client IDs are used to support lock identification and crash recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
個別のクライアントインスタンスはそれぞれクライアントIDで表されます。クライアントIDは、特定の時点での特定のクライアントを表す64ビットの識別子です。クライアントIDは、クライアントが再初期化されるたびに変更され、サーバーが再初期化されるときに変更される場合があります。クライアントIDは、ロックの識別とクラッシュの回復をサポートするために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During steady state operation, the client ID associated with each operation is derived from the session (see Section 2.10) on which the operation is sent. A session is associated with a client ID when the session is created.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定常状態の操作中、各操作に関連付けられたクライアントIDは、操作が送信されるセッション（セクション2.10を参照）から取得されます。セッションは、作成時にクライアントIDに関連付けられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike NFSv4.0, the only NFSv4.1 operations possible before a client ID is established are those needed to establish the client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.0とは異なり、クライアントIDが確​​立される前に可能なNFSv4.1操作は、クライアントIDの確立に必要なものだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sequence of an EXCHANGE_ID operation followed by a CREATE_SESSION operation using that client ID (eir_clientid as returned from EXCHANGE_ID) is required to establish and confirm the client ID on the server. Establishment of identification by a new incarnation of the client also has the effect of immediately releasing any locking state that a previous incarnation of that same client might have had on the server. Such released state would include all byte-range lock, share reservation, layout state, and -- where the server supports neither the CLAIM_DELEGATE_PREV nor CLAIM_DELEG_CUR_FH claim types -- all delegation state associated with the same client with the same identity. For discussion of delegation state recovery, see Section 10.2.1. For discussion of layout state recovery, see Section 12.7.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー上でクライアントIDを確立して確認するには、EXCHANGE_ID操作とそれに続くそのクライアントID（EXCHANGE_IDから返されたeir_clientid）を使用したCREATE_SESSION操作のシーケンスが必要です。クライアントの新しいインカネーションによる識別の確立には、その同じクライアントの以前のインカネーションがサーバー上で持っていた可能性があるロック状態を即座に解放する効果もあります。そのような解放された状態には、すべてのバイト範囲ロック、共有予約、レイアウト状態、およびサーバーがCLAIM_DELEGATE_PREVクレームタイプもCLAIM_DELEG_CUR_FHクレームタイプもサポートしない場合、同じIDを持つ同じクライアントに関連付けられたすべての委任状態が含まれます。委任状態の回復については、10.2.1項を参照してください。レイアウト状態の回復については、セクション12.7.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Releasing such state requires that the server be able to determine that one client instance is the successor of another. Where this cannot be done, for any of a number of reasons, the locking state will remain for a time subject to lease expiration (see Section 8.3) and the new client will need to wait for such state to be removed, if it makes conflicting lock requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような状態を解除するには、サーバーが、あるクライアントインスタンスが別のクライアントインスタンスの後継であると判断できる必要があります。これが実行できない場合、いくつかの理由のいずれかにより、ロック状態はリースの有効期限の対象となる時間の間維持され（セクション8.3を参照）、競合する場合、新しいクライアントはその状態が削除されるのを待つ必要があります。ロック要求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Client identification is encapsulated in the following client owner
   data type:
   struct client_owner4 {
           verifier4       co_verifier;
           opaque          co_ownerid&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first field, co_verifier, is a client incarnation verifier. The server will start the process of canceling the client&#39;s leased state if co_verifier is different than what the server has previously recorded for the identified client (as specified in the co_ownerid field).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のフィールドco_verifierは、クライアントインカネーションベリファイアです。 co_verifierが、識別されたクライアントに対してサーバーが以前に記録したもの（co_owneridフィールドで指定）と異なる場合、サーバーはクライアントのリース状態をキャンセルするプロセスを開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second field, co_ownerid, is a variable length string that uniquely defines the client so that subsequent instances of the same client bear the same co_ownerid with a different verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目のフィールドco_owneridは可変長文字列で、クライアントを一意に定義するため、同じクライアントの後続のインスタンスは、異なるベリファイアを使用して同じco_owneridを保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several considerations for how the client generates the co_ownerid string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがco_ownerid文字列を生成する方法には、いくつかの考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The string should be unique so that multiple clients do not present the same string. The consequences of two clients presenting the same string range from one client getting an error to one client having its leased state abruptly and unexpectedly cancelled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 複数のクライアントが同じ文字列を提示しないように、文字列は一意である必要があります。 2つのクライアントが同じ文字列を提示することによる影響は、1つのクライアントがエラーを取得することから、1つのクライアントがリース状態を突然予期せずにキャンセルすることまでさまざまです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The string should be selected so that subsequent incarnations (e.g., restarts) of the same client cause the client to present the same string. The implementor is cautioned from an approach that requires the string to be recorded in a local file because this precludes the use of the implementation in an environment where there is no local disk and all file access is from an NFSv4.1 server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 同じクライアントの後続のインカネーション（たとえば、再起動）がクライアントに同じ文字列を提示させるように、文字列を選択する必要があります。ローカルディスクがなく、すべてのファイルアクセスがNFSv4.1サーバーからである環境で実装を使用できないため、実装者は、文字列をローカルファイルに記録する必要があるアプローチから警告を受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The string should be the same for each server network address that the client accesses. This way, if a server has multiple interfaces, the client can trunk traffic over multiple network paths as described in Section 2.10.5. (Note: the precise opposite was advised in the NFSv4.0 specification [30].)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 文字列は、クライアントがアクセスする各サーバーネットワークアドレスで同じである必要があります。このようにして、サーバーに複数のインターフェースがある場合、クライアントはセクション2.10.5で説明されているように複数のネットワークパスを介してトラフィックをトランクできます。 （注：NFSv4.0仕様[30]では、正反対が推奨されていました。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o The algorithm for generating the string should not assume that the client&#39;s network address will not change, unless the client implementation knows it is using statically assigned network addresses. This includes changes between client incarnations and even changes while the client is still running in its current incarnation. Thus, with dynamic address assignment, if the client includes just the client&#39;s network address in the co_ownerid string, there is a real risk that after the client gives up the network address, another client, using a similar algorithm for generating the co_ownerid string, would generate a conflicting co_ownerid string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
文字列を生成するアルゴリズムは、静的に割り当てられたネットワークアドレスを使用していることをクライアントの実装が認識していない限り、クライアントのネットワークアドレスが変更されないことを前提としてはなりません。これには、クライアントインカネーション間の変更や、クライアントが現在のインカネーションでまだ実行されている間の変更も含まれます。したがって、動的アドレス割り当てを使用して、クライアントがco_ownerid文字列にクライアントのネットワークアドレスのみを含める場合、クライアントがネットワークアドレスを放棄した後、co_ownerid文字列を生成するための同様のアルゴリズムを使用する別のクライアントが、競合するco_ownerid文字列を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given the above considerations, an example of a well-generated co_ownerid string is one that includes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の考慮事項を踏まえて、適切に生成されたco_ownerid文字列の例は、次のものを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If applicable, the client&#39;s statically assigned network address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 該当する場合、クライアントに静的に割り当てられたネットワークアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Additional information that tends to be unique, such as one or more of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 以下の1つ以上など、一意になる傾向がある追加情報。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The client machine&#39;s serial number (for privacy reasons, it is best to perform some one-way function on the serial number).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントマシンのシリアル番号（プライバシー上の理由から、シリアル番号に対して一方向の機能を実行することをお勧めします）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* A Media Access Control (MAC) address (again, a one-way function should be performed).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* メディアアクセスコントロール（MAC）アドレス（ここでも、一方向の機能を実行する必要があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The timestamp of when the NFSv4.1 software was first installed on the client (though this is subject to the previously mentioned caution about using information that is stored in a file, because the file might only be accessible over NFSv4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* NFSv4.1ソフトウェアがクライアントに最初にインストールされたときのタイムスタンプ（ただし、ファイルにはNFSv4.1からしかアクセスできないため、ファイルに格納されている情報の使用に関する前述の注意が必要です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* A true random number. However, since this number ought to be the same between client incarnations, this shares the same problem as that of using the timestamp of the software installation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 真の乱数。ただし、この数はクライアントのインカネーション間で同じである必要があるため、ソフトウェアインストールのタイムスタンプを使用する場合と同じ問題を共有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For a user-level NFSv4.1 client, it should contain additional information to distinguish the client from other user-level clients running on the same host, such as a process identifier or other unique sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ユーザーレベルのNFSv4.1クライアントの場合は、プロセス識別子や他の一意のシーケンスなど、同じホスト上で実行されている他のユーザーレベルのクライアントからクライアントを区別するための追加情報を含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client ID is assigned by the server (the eir_clientid result from EXCHANGE_ID) and should be chosen so that it will not conflict with a client ID previously assigned by the server. This applies across server restarts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントIDはサーバーによって割り当てられ（EXCHANGE_IDからのeir_clientid結果）、サーバーによって以前に割り当てられたクライアントIDと競合しないように選択する必要があります。これは、サーバーの再起動全体に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event of a server restart, a client may find out that its current client ID is no longer valid when it receives an NFS4ERR_STALE_CLIENTID error. The precise circumstances depend on the characteristics of the sessions involved, specifically whether the session is persistent (see Section 2.10.6.5), but in each case the client will receive this error when it attempts to establish a new session with the existing client ID and receives the error NFS4ERR_STALE_CLIENTID, indicating that a new client ID needs to be obtained via EXCHANGE_ID and the new session established with that client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが再起動した場合、NFS4ERR_STALE_CLIENTIDエラーを受信すると、クライアントは現在のクライアントIDが無効であることを検出する場合があります。正確な状況は、関連するセッションの特性、特にセッションが永続的であるかどうか（セクション2.10.6.5を参照）によって異なりますが、いずれの場合も、既存のクライアントIDで新しいセッションを確立しようとすると、クライアントはこのエラーを受け取ります。エラーNFS4ERR_STALE_CLIENTIDを受け取ります。これは、EXCHANGE_IDを介して新しいクライアントIDを取得し、そのクライアントIDで確立された新しいセッションを示す必要があることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a session is not persistent, the client will find out that it needs to create a new session as a result of getting an NFS4ERR_BADSESSION, since the session in question was lost as part of a server restart. When the existing client ID is presented to a server as part of creating a session and that client ID is not recognized, as would happen after a server restart, the server will reject the request with the error NFS4ERR_STALE_CLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションが永続的でない場合、クライアントは、問題のセッションがサーバーの再起動の一部として失われたため、NFS4ERR_BADSESSIONを取得した結果、新しいセッションを作成する必要があることがわかります。セッションの作成の一部として既存のクライアントIDがサーバーに提示され、そのクライアントIDが認識されない場合、サーバーの再起動後に発生するように、サーバーはエラーNFS4ERR_STALE_CLIENTIDで要求を拒否します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of the session being persistent, the client will re-establish communication using the existing session after the restart. This session will be associated with the existing client ID but may only be used to retransmit operations that the client previously transmitted and did not see replies to. Replies to operations that the server previously performed will come from the reply cache; otherwise, NFS4ERR_DEADSESSION will be returned. Hence, such a session is referred to as &#34;dead&#34;. In this situation, in order to perform new operations, the client needs to establish a new session. If an attempt is made to establish this new session with the existing client ID, the server will reject the request with NFS4ERR_STALE_CLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションが永続的である場合、クライアントは再起動後に既存のセッションを使用して通信を再確立します。このセッションは既存のクライアントIDに関連付けられますが、クライアントが以前に送信し、応答を確認しなかった操作を再送信するためにのみ使用できます。サーバーが以前に実行した操作への応答は、応答キャッシュから送られます。それ以外の場合は、NFS4ERR_DEADSESSIONが返されます。したがって、そのようなセッションは「デッド」と呼ばれます。この状況では、新しい操作を実行するために、クライアントは新しいセッションを確立する必要があります。既存のクライアントIDでこの新しいセッションを確立しようとすると、サーバーはNFS4ERR_STALE_CLIENTIDで要求を拒否します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When NFS4ERR_STALE_CLIENTID is received in either of these situations, the client needs to obtain a new client ID by use of the EXCHANGE_ID operation, then use that client ID as the basis of a new session, and then proceed to any other necessary recovery for the server restart case (see Section 8.4.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの状況のいずれかでNFS4ERR_STALE_CLIENTIDが受信された場合、クライアントはEXCHANGE_ID操作を使用して新しいクライアントIDを取得し、そのクライアントIDを新しいセッションの基礎として使用してから、サーバーに必要なその他のリカバリに進む必要があります。ケースを再起動します（セクション8.4.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See the descriptions of EXCHANGE_ID (Section 18.35) and CREATE_SESSION (Section 18.36) for a complete specification of these operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの操作の完全な仕様については、EXCHANGE_ID（セクション18.35）およびCREATE_SESSION（セクション18.36）の説明を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-4-1--Upgrade-from-NFSv4-0-to-NFSv4-1">
2.4.1. Upgrade from NFSv4.0 to NFSv4.1
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.1. NFSv4.0からNFSv4.1へのアップグレード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 To facilitate upgrade from NFSv4.0 to NFSv4.1, a server may compare a value of data type client_owner4 in an EXCHANGE_ID with a value of data type nfs_client_id4 that was established using the SETCLIENTID operation of NFSv4.0. A server that does so will allow an upgraded client to avoid waiting until the lease (i.e., the lease established by the NFSv4.0 instance client) expires. This requires that the value of data type client_owner4 be constructed the same way as the value of data type nfs_client_id4. If the latter&#39;s contents included the server&#39;s network address (per the recommendations of the NFSv4.0 specification [30]), and the NFSv4.1 client does not wish to use a client ID that prevents trunking, it should send two EXCHANGE_ID operations. The first EXCHANGE_ID will have a client_owner4 equal to the nfs_client_id4. This will clear the state created by the NFSv4.0 client. The second EXCHANGE_ID will not have the server&#39;s network address. The state created for the second EXCHANGE_ID will not have to wait for lease expiration, because there will be no state to expire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFSv4.0からNFSv4.1へのアップグレードを容易にするために、サーバーはEXCHANGE_IDのデータ型client_owner4の値を、NFSv4.0のSETCLIENTID操作を使用して確立されたデータ型nfs_client_id4の値と比較する場合があります。これを行うサーバーにより、アップグレードされたクライアントは、リース（つまり、NFSv4.0インスタンスクライアントによって確立されたリース）が期限切れになるまで待機する必要がなくなります。これには、データ型client_owner4の値がデータ型nfs_client_id4の値と同じ方法で構築される必要があります。後者のコンテンツにサーバーのネットワークアドレスが含まれている場合（NFSv4.0仕様[30]の推奨に従って）、NFSv4.1クライアントはトランキングを妨げるクライアントIDを使用したくない場合、2つのEXCHANGE_ID操作を送信する必要があります。最初のEXCHANGE_IDには、nfs_client_id4と等しいclient_owner4があります。これにより、NFSv4.0クライアントによって作成された状態がクリアされます。 2番目のEXCHANGE_IDには、サーバーのネットワークアドレスは含まれません。 2番目のEXCHANGE_IDに対して作成された状態は、期限切れになる状態がないため、リースの期限切れを待つ必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-4-2--Server-Release-of-Client-ID">
2.4.2. Server Release of Client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.2. クライアントIDのサーバーリリース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 introduces a new operation called DESTROY_CLIENTID (Section 18.50), which the client SHOULD use to destroy a client ID it no longer needs. This permits graceful, bilateral release of a client ID. The operation cannot be used if there are sessions associated with the client ID, or state with an unexpired lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1はDESTROY_CLIENTID（セクション18.50）と呼ばれる新しい操作を導入します。クライアントはこれを使用して、不要になったクライアントIDを破棄する必要があります（SHOULD）。これにより、クライアントIDの適切な双方向リリースが可能になります。クライアントIDに関連付けられたセッションがある場合、またはリースが期限切れになっていない状態の場合、この操作は使用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server determines that the client holds no associated state for its client ID (associated state includes unrevoked sessions, opens, locks, delegations, layouts, and wants), the server MAY choose to unilaterally release the client ID in order to conserve resources. If the client contacts the server after this release, the server MUST ensure that the client receives the appropriate error so that it will use the EXCHANGE_ID/CREATE_SESSION sequence to establish a new client ID. The server ought to be very hesitant to release a client ID since the resulting work on the client to recover from such an event will be the same burden as if the server had failed and restarted. Typically, a server would not release a client ID unless there had been no activity from that client for many minutes. As long as there are sessions, opens, locks, delegations, layouts, or wants, the server MUST NOT release the client ID. See Section 2.10.13.1.4 for discussion on releasing inactive sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがそのクライアントIDに関連付けられた状態を保持していないとサーバーが判断した場合（関連付けられた状態には、取り消されていないセッション、オープン、ロック、委任、レイアウト、および要求が含まれます）、サーバーはリソースを節約するために一方的にクライアントIDを解放することを選択できます（MAY）。このリリース後にクライアントがサーバーに接続する場合、サーバーは、クライアントが適切なエラーを受信し、EXCHANGE_ID / CREATE_SESSIONシーケンスを使用して新しいクライアントIDを確立するようにする必要があります。そのようなイベントから回復するためのクライアントでの結果的な作業は、サーバーに障害が発生して再起動した場合と同じ負担になるため、サーバーはクライアントIDを解放することを非常にためらう必要があります。通常、サーバーは、そのクライアントから何分間もアクティビティがない場合を除いて、クライアントIDを解放しません。セッション、オープン、ロック、委任、レイアウト、または要求がある限り、サーバーはクライアントIDを解放してはなりません（MUST NOT）。非アクティブなセッションの解放については、2.10.13.1.4項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-4-3--Resolving-Client-Owner-Conflicts">
2.4.3. Resolving Client Owner Conflicts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.3. クライアント所有者の競合を解決する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server gets an EXCHANGE_ID for a client owner that currently has no state, or that has state but the lease has expired, the server MUST allow the EXCHANGE_ID and confirm the new client ID if followed by the appropriate CREATE_SESSION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが、現在状態がないか、状態はあるがリースの期限が切れているクライアント所有者のEXCHANGE_IDを取得する場合、適切なCREATE_SESSIONが続く場合、サーバーはEXCHANGE_IDを許可し、新しいクライアントIDを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server gets an EXCHANGE_ID for a new incarnation of a client owner that currently has an old incarnation with state and an unexpired lease, the server is allowed to dispose of the state of the previous incarnation of the client owner if one of the following is true:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがクライアント所有者の新しいインカネーションのEXCHANGE_IDを取得しているが、現在状態が古いインカネーションと有効期限が切れていないリースがある場合、次のいずれかが当てはまる場合、サーバーはクライアント所有者の以前のインカネーションの状態を破棄できます。真：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o The principal that created the client ID for the client owner is the same as the principal that is sending the EXCHANGE_ID operation. Note that if the client ID was created with SP4_MACH_CRED state protection (Section 18.35), the principal MUST be based on RPCSEC_GSS authentication, the RPCSEC_GSS service used MUST be integrity or privacy, and the same GSS mechanism and principal MUST be used as that used when the client ID was created.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
oクライアント所有者のクライアントIDを作成したプリンシパルは、EXCHANGE_ID操作を送信しているプリンシパルと同じです。クライアントIDがSP4_MACH_CRED状態保護（セクション18.35）で作成された場合、プリンシパルはRPCSEC_GSS認証に基づく必要があり、使用されるRPCSEC_GSSサービスは整合性またはプライバシーでなければならず、同じGSSメカニズムとプリンシパルは、クライアントIDが作成されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client ID was established with SP4_SSV protection (Section 18.35, Section 2.10.8.3) and the client sends the EXCHANGE_ID with the security flavor set to RPCSEC_GSS using the GSS SSV mechanism (Section 2.10.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントIDはSP4_SSV保護で確立され（セクション18.35、セクション2.10.8.3）、クライアントはGSS SSVメカニズムを使用してセキュリティフレーバーをRPCSEC_GSSに設定したEXCHANGE_IDを送信します（セクション2.10.9）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client ID was established with SP4_SSV protection, and under the conditions described herein, the EXCHANGE_ID was sent with SP4_MACH_CRED state protection. Because the SSV might not persist across client and server restart, and because the first time a client sends EXCHANGE_ID to a server it does not have an SSV, the client MAY send the subsequent EXCHANGE_ID without an SSV RPCSEC_GSS handle. Instead, as with SP4_MACH_CRED protection, the principal MUST be based on RPCSEC_GSS authentication, the RPCSEC_GSS service used MUST be integrity or privacy, and the same GSS mechanism and principal MUST be used as that used when the client ID was created.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントIDはSP4_SSV保護で確立され、ここで説明されている条件下で、EXCHANGE_IDはSP4_MACH_CRED状態保護で送信されました。 SSVはクライアントとサーバーの再起動後は保持されない可能性があり、クライアントが初めてEXCHANGE_IDをサーバーに送信するときにSSVがないため、クライアントはSSV RPCSEC_GSSハンドルなしで後続のEXCHANGE_IDを送信できます（MAY）。代わりに、SP4_MACH_CRED保護と同様に、プリンシパルはRPCSEC_GSS認証に基づく必要があり、使用するRPCSEC_GSSサービスは整合性またはプライバシーである必要があり、クライアントIDの作成時に使用したものと同じGSSメカニズムとプリンシパルを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If none of the above situations apply, the server MUST return NFS4ERR_CLID_INUSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の状況のいずれにも該当しない場合、サーバーはNFS4ERR_CLID_INUSEを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server accepts the principal and co_ownerid as matching that which created the client ID, and the co_verifier in the EXCHANGE_ID differs from the co_verifier used when the client ID was created, then after the server receives a CREATE_SESSION that confirms the client ID, the server deletes state. If the co_verifier values are the same (e.g., the client either is updating properties of the client ID (Section 18.35) or is attempting trunking (Section 2.10.5), the server MUST NOT delete state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがプリンシパルとco_owneridをクライアントIDを作成したものと一致するものとして受け入れ、EXCHANGE_IDのco_verifierがクライアントIDの作成時に使用されたco_verifierと異なる場合、サーバーはクライアントIDを確認するCREATE_SESSIONを受信した後、サーバー状態を削除します。 co_verifierの値が同じ場合（たとえば、クライアントがクライアントIDのプロパティを更新している場合（セクション18.35）、またはトランキングを試行している場合（セクション2.10.5）、サーバーは状態を削除してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-5--Server-Owners">
2.5. Server Owners
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5. サーバー所有者
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server owner is similar to a client owner (Section 2.4), but unlike the client owner, there is no shorthand server ID. The server owner is defined in the following data type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの所有者はクライアントの所有者（セクション2.4）に似ていますが、クライアントの所有者とは異なり、省略形のサーバーIDはありません。サーバーの所有者は、次のデータ型で定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct server_owner4 {
    uint64_t       so_minor_id;
    opaque         so_major_id&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The server owner is returned from EXCHANGE_ID. When the so_major_id fields are the same in two EXCHANGE_ID results, the connections that each EXCHANGE_ID were sent over can be assumed to address the same server (as defined in Section 1.6). If the so_minor_id fields are also the same, then not only do both connections connect to the same server, but the session can be shared across both connections. The reader is cautioned that multiple servers may deliberately or accidentally claim to have the same so_major_id or so_major_id/ so_minor_id; the reader should examine Sections 2.10.5 and 18.35 in order to avoid acting on falsely matching server owner values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーの所有者はEXCHANGE_IDから返されます。 2つのEXCHANGE_ID結果でso_major_idフィールドが同じである場合、各EXCHANGE_IDが送信された接続は、同じサーバーをアドレス指定していると見なすことができます（セクション1.6で定義）。 so_minor_idフィールドも同じ場合、両方の接続が同じサーバーに接続するだけでなく、セッションを両方の接続間で共有できます。複数のサーバーが故意にまたは誤って同じso_major_idまたはso_major_id / so_minor_idを持っていると主張する可能性があることに注意してください。読者は、誤って一致するサーバー所有者の値に基づいて行動しないように、セクション2.10.5および18.35を調べる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The considerations for generating a so_major_id are similar to that for generating a co_ownerid string (see Section 2.4). The consequences of two servers generating conflicting so_major_id values are less dire than they are for co_ownerid conflicts because the client can use RPCSEC_GSS to compare the authenticity of each server (see Section 2.10.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
so_major_idを生成するための考慮事項は、co_ownerid文字列を生成する場合と同様です（2.4項を参照）。クライアントがRPCSEC_GSSを使用して各サーバーの信頼性を比較できるため（セクション2.10.5を参照）、2つのサーバーが競合するso_major_id値を生成する結果は、co_owneridの競合よりも悲惨ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-6--Security-Service-Negotiation">
2.6. Security Service Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6. セキュリティサービスの交渉
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the NFSv4.1 server potentially offering multiple security mechanisms, the client needs a method to determine or negotiate which mechanism is to be used for its communication with the server. The NFS server may have multiple points within its file system namespace that are available for use by NFS clients. These points can be considered security policy boundaries, and, in some NFS implementations, are tied to NFS export points. In turn, the NFS server may be configured such that each of these security policy boundaries may have different or multiple security mechanisms in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1サーバーが複数のセキュリティメカニズムを提供する可能性がある場合、クライアントは、サーバーとの通信に使用するメカニズムを決定またはネゴシエートする方法を必要とします。 NFSサーバーのファイルシステム名前空間内には、NFSクライアントが使用できる複数のポイントがある場合があります。これらのポイントはセキュリティポリシーの境界と見なすことができ、一部のNFS実装では、NFSエクスポートポイントに関連付けられています。次に、NFSサーバーは、これらのセキュリティポリシー境界のそれぞれが、異なるまたは複数のセキュリティメカニズムを使用するように構成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security negotiation between client and server SHOULD be done with a secure channel to eliminate the possibility of a third party intercepting the negotiation sequence and forcing the client and server to choose a lower level of security than required or desired. See Section 21 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバー間のセキュリティネゴシエーションは、第三者がネゴシエーションシーケンスを傍受し、クライアントとサーバーが必要または望ましいレベルよりも低いセキュリティレベルを選択する可能性を排除するために、安全なチャネルで行う必要があります。詳細については、セクション21を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-6-1--NFSv4-1-Security-Tuples">
2.6.1. NFSv4.1 Security Tuples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.1. NFSv4.1セキュリティタプル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An NFS server can assign one or more &#34;security tuples&#34; to each security policy boundary in its namespace. Each security tuple consists of a security flavor (see Section 2.2.1.1) and, if the flavor is RPCSEC_GSS, a GSS-API mechanism Object Identifier (OID), a GSS-API quality of protection, and an RPCSEC_GSS service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSサーバーは、その名前空間の各セキュリティポリシー境界に1つ以上の「セキュリティタプル」を割り当てることができます。各セキュリティタプルは、セキュリティフレーバー（セクション2.2.1.1を参照）で構成され、フレーバーがRPCSEC_GSSの場合、GSS-APIメカニズムのオブジェクト識別子（OID）、GSS-APIの保護品質、およびRPCSEC_GSSサービスで構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-6-2--SECINFO-and-SECINFONONAME">
2.6.2. SECINFO and SECINFO_NO_NAME
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.2. SECINFOおよびSECINFO_NO_NAME
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SECINFO and SECINFO_NO_NAME operations allow the client to determine, on a per-filehandle basis, what security tuple is to be used for server access. In general, the client will not have to use either operation except during initial communication with the server or when the client crosses security policy boundaries at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFOおよびSECINFO_NO_NAME操作を使用すると、クライアントはファイルハンドルごとに、サーバーアクセスに使用するセキュリティタプルを決定できます。一般に、クライアントは、サーバーとの最初の通信中、またはクライアントがサーバーのセキュリティポリシーの境界を越えるときを除いて、どちらの操作も使用する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, the server&#39;s policies may also change at any time and force the client to negotiate a new security tuple.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、サーバーのポリシーはいつでも変更され、クライアントに新しいセキュリティタプルのネゴシエーションを強制する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the use of different security tuples would affect the type of access that would be allowed if a request was sent over the same connection used for the SECINFO or SECINFO_NO_NAME operation (e.g., read-only vs. read-write) access, security tuples that allow greater access should be presented first. Where the general level of access is the same and different security flavors limit the range of principals whose privileges are recognized (e.g., allowing or disallowing root access), flavors supporting the greatest range of principals should be listed first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異なるセキュリティタプルの使用が、SECINFOまたはSECINFO_NO_NAME操作（たとえば、読み取り専用アクセスと読み取り/書き込みアクセス）アクセスに使用される同じ接続を介して要求が送信された場合に許可されるアクセスのタイプに影響する場合、セキュリティタプルより大きなアクセスを許可することを最初に提示する必要があります。一般的なアクセスレベルが同じで、異なるセキュリティフレーバーが権限が認識されるプリンシパルの範囲を制限している場合（ルートアクセスの許可または拒否など）、最も広い範囲のプリンシパルをサポートするフレーバーを最初にリストする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-6-3--Security-Error">
2.6.3. Security Error
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.3. セキュリティエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the assumption that each NFSv4.1 client and server MUST support a minimum set of security (i.e., Kerberos V5 under RPCSEC_GSS), the NFS client will initiate file access to the server with one of the minimal security tuples. During communication with the server, the client may receive an NFS error of NFS4ERR_WRONGSEC. This error allows the server to notify the client that the security tuple currently being used contravenes the server&#39;s security policy. The client is then responsible for determining (see Section 2.6.3.1) what security tuples are available at the server and choosing one that is appropriate for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各NFSv4.1クライアントとサーバーは最低限のセキュリティセット（つまり、RPCSEC_GSSでのKerberos V5）をサポートする必要があるという想定に基づいて、NFSクライアントは最小限のセキュリティタプルの1つでサーバーへのファイルアクセスを開始します。サーバーとの通信中に、クライアントはNFS4ERR_WRONGSECのNFSエラーを受け取る場合があります。このエラーにより、サーバーは、現在使用されているセキュリティタプルがサーバーのセキュリティポリシーに違反していることをクライアントに通知できます。次に、クライアントは、サーバーで使用可能なセキュリティタプルを決定し（セクション2.6.3.1を参照）、クライアントに適したセキュリティタプルを選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-6-3-1--Using-NFS4ERRWRONGSEC-SECINFO-and-SECINFONONAME">
2.6.3.1. Using NFS4ERR_WRONGSEC, SECINFO, and SECINFO_NO_NAME
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.3.1. NFS4ERR_WRONGSEC、SECINFO、SECINFO_NO_NAMEの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section explains the mechanics of NFSv4.1 security negotiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、NFSv4.1セキュリティネゴシエーションのメカニズムについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-6-3-1-1--Put-Filehandle-Operations">
2.6.3.1.1. Put Filehandle Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.3.1.1. ファイルハンドル操作を置く
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The term &#34;put filehandle operation&#34; refers to PUTROOTFH, PUTPUBFH, PUTFH, and RESTOREFH. Each of the subsections herein describes how the server handles a subseries of operations that starts with a put filehandle operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「put filehandle操作」という用語は、PUTROOTFH、PUTPUBFH、PUTFH、およびRESTOREFHを指します。本書の各サブセクションでは、サーバーがput filehandle操作で始まる一連の操作を処理する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-6-3-1-1-1--Put-Filehandle-Operation--SAVEFH">
2.6.3.1.1.1. Put Filehandle Operation + SAVEFH
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.3.1.1.1. ファイルハンドル操作+ SAVEFHを置く
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client is saving a filehandle for a future RESTOREFH, LINK, or RENAME. SAVEFH MUST NOT return NFS4ERR_WRONGSEC. To determine whether or not the put filehandle operation returns NFS4ERR_WRONGSEC, the server implementation pretends SAVEFH is not in the series of operations and examines which of the situations described in the other subsections of Section 2.6.3.1.1 apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、将来のRESTOREFH、LINK、またはRENAMEのためにファイルハンドルを保存しています。 SAVEFHはNFS4ERR_WRONGSECを返してはなりません。 put filehandle操作がNFS4ERR_WRONGSECを返すかどうかを判断するために、サーバー実装はSAVEFHが一連の操作に含まれていないように見せかけ、セクション2.6.3.1.1の他のサブセクションで説明されている状況のどれが当てはまるかを調べます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-6-3-1-1-2--Two-or-More-Put-Filehandle-Operations">
2.6.3.1.1.2. Two or More Put Filehandle Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.3.1.1.2. 2つ以上のPut Filehandle操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a series of N put filehandle operations, the server MUST NOT return NFS4ERR_WRONGSEC to the first N-1 put filehandle operations. The Nth put filehandle operation is handled as if it is the first in a subseries of operations. For example, if the server received a COMPOUND request with this series of operations -- PUTFH, PUTROOTFH, LOOKUP -- then the PUTFH operation is ignored for NFS4ERR_WRONGSEC purposes, and the PUTROOTFH, LOOKUP subseries is processed as according to Section 2.6.3.1.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一連のN putファイルハンドル操作の場合、サーバーは最初のN-1 putファイルハンドル操作にNFS4ERR_WRONGSECを返してはなりません（MUST NOT）。 N番目のファイルハンドル操作は、一連の操作の最初の操作であるかのように処理されます。たとえば、サーバーがこの一連の操作（PUTFH、PUTROOTFH、LOOKUP）でCOMPOUND要求を受信した場合、NFS4ERR_WRONGSECの目的ではPUTFH操作は無視され、PUTROOTFH、LOOKUPサブシリーズはセクション2.6.3.1に従って処理されます。 1.3。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.6.3.1.1.3. Put Filehandle Operation + LOOKUP (or OPEN of an Existing Name)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.6.3.1.1.3. ファイルハンドル操作+ LOOKUP（または既存の名前のOPEN）を置く
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This situation also applies to a put filehandle operation followed by a LOOKUP or an OPEN operation that specifies an existing component name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この状況は、既存のコンポーネント名を指定するLOOKUPまたはOPEN操作が後に続くファイルハンドル操作のputにも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this situation, the client is potentially crossing a security policy boundary, and the set of security tuples the parent directory supports may differ from those of the child. The server implementation may decide whether to impose any restrictions on security policy administration. There are at least three approaches (sec_policy_child is the tuple set of the child export, sec_policy_parent is that of the parent).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この状況では、クライアントがセキュリティポリシーの境界を越えている可能性があり、親ディレクトリがサポートするセキュリティタプルのセットが子のタプルと異なる場合があります。サーバーの実装では、セキュリティポリシーの管理に制限を課すかどうかを決定できます。少なくとも3つの方法があります（sec_policy_childは子エクスポートのタプルセット、sec_policy_parentは親エクスポートのタプルセットです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(a) sec_policy_child &lt;= sec_policy_parent (&lt;= for subset). This means that the set of security tuples specified on the security policy of a child directory is always a subset of its parent directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（a）sec_policy_child &lt;= sec_policy_parent（&lt;=サブセットの場合）。つまり、子ディレクトリのセキュリティポリシーで指定されたセキュリティタプルのセットは、常にその親ディレクトリのサブセットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (b)  sec_policy_child ^ sec_policy_parent != {} (^ for intersection,
        {} for the empty set).  This means that the set of security
        tuples specified on the security policy of a child directory
        always has a non-empty intersection with that of the parent.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (c)  sec_policy_child ^ sec_policy_parent == {}.  This means that the
        set of security tuples specified on the security policy of a
        child directory may not intersect with that of the parent.  In
        other words, there are no restrictions on how the system
        administrator may set up these tuples.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order for a server to support approaches (b) (for the case when a client chooses a flavor that is not a member of sec_policy_parent) and (c), the put filehandle operation cannot return NFS4ERR_WRONGSEC when there is a security tuple mismatch. Instead, it should be returned from the LOOKUP (or OPEN by existing component name) that follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがアプローチ（b）（クライアントがsec_policy_parentのメンバーではないフレーバーを選択した場合）と（c）をサポートするために、セキュリティタプルの不一致がある場合、put filehandle操作はNFS4ERR_WRONGSECを返すことができません。代わりに、後続のLOOKUP（または既存のコンポーネント名によるOPEN）から返される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the above guideline does not contradict approach (a), it should be followed in general. Even if approach (a) is implemented, it is possible for the security tuple used to be acceptable for the target of LOOKUP but not for the filehandles used in the put filehandle operation. The put filehandle operation could be a PUTROOTFH or PUTPUBFH, where the client cannot know the security tuples for the root or public filehandle. Or the security policy for the filehandle used by the put filehandle operation could have changed since the time the filehandle was obtained.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のガイドラインは（a）のアプローチと矛盾しないため、一般にそれに従う必要があります。アプローチ（a）が実装されている場合でも、使用されているセキュリティタプルがLOOKUPのターゲットに受け入れられる可能性がありますが、put filehandle操作で使用されるファイルハンドルには受け入れられません。 put filehandle操作は、PUTROOTFHまたはPUTPUBFHである可能性があります。クライアントは、ルートまたはパブリックファイルハンドルのセキュリティタプルを認識できません。または、ファイルハンドルが取得されたときから、ファイルハンドルの書き込み操作で使用されるファイルハンドルのセキュリティポリシーが変更されている可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, an NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC in response to the put filehandle operation if the operation is immediately followed by a LOOKUP or an OPEN by component name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、操作の直後にコンポーネント名によるLOOKUPまたはOPENが続く場合、NFSv4.1サーバーはput filehandle操作に応答してNFS4ERR_WRONGSECを返してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-6-3-1-1-4--Put-Filehandle-Operation--LOOKUPP">
2.6.3.1.1.4. Put Filehandle Operation + LOOKUPP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.3.1.1.4. ファイルハンドル操作+ LOOKUPの配置
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since SECINFO only works its way down, there is no way LOOKUPP can return NFS4ERR_WRONGSEC without SECINFO_NO_NAME. SECINFO_NO_NAME solves this issue via style SECINFO_STYLE4_PARENT, which works in the opposite direction as SECINFO. As with Section 2.6.3.1.1.3, a put filehandle operation that is followed by a LOOKUPP MUST NOT return NFS4ERR_WRONGSEC. If the server does not support SECINFO_NO_NAME, the client&#39;s only recourse is to send the put filehandle operation, LOOKUPP, GETFH sequence of operations with every security tuple it supports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFOはその機能を停止するだけなので、LOOKUPPがSECINFO_NO_NAMEなしでNFS4ERR_WRONGSECを返すことはできません。 SECINFO_NO_NAMEは、SECINFO_STYLE4_PARENTスタイルを介してこの問題を解決します。これは、SECINFOとは逆方向に機能します。セクション2.6.3.1.1.3と同様に、LOOKUPPが後に続くput filehandle操作はNFS4ERR_WRONGSECを返してはなりません。サーバーがSECINFO_NO_NAMEをサポートしていない場合、クライアントの唯一の手段は、サポートするすべてのセキュリティタプルとともにput filehandle操作、LOOKUPP、GETFHシーケンスの操作を送信することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of whether SECINFO_NO_NAME is supported, an NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC in response to a put filehandle operation if the operation is immediately followed by a LOOKUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFO_NO_NAMEがサポートされているかどうかに関係なく、操作の直後にLOOKUPPが続く場合、NFSv4.1サーバーはputfilehandle操作に応答してNFS4ERR_WRONGSECを返してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-6-3-1-1-5--Put-Filehandle-Operation--SECINFOSECINFONONAME">
2.6.3.1.1.5. Put Filehandle Operation + SECINFO/SECINFO_NO_NAME
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.3.1.1.5. ファイルハンドル操作+ SECINFO / SECINFO_NO_NAME
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A security-sensitive client is allowed to choose a strong security tuple when querying a server to determine a file object&#39;s permitted security tuples. The security tuple chosen by the client does not have to be included in the tuple list of the security policy of either the parent directory indicated in the put filehandle operation or the child file object indicated in SECINFO (or any parent directory indicated in SECINFO_NO_NAME). Of course, the server has to be configured for whatever security tuple the client selects; otherwise, the request will fail at the RPC layer with an appropriate authentication error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティを重視するクライアントは、サーバーにクエリを実行してファイルオブジェクトの許可されたセキュリティタプルを決定するときに、強力なセキュリティタプルを選択できます。クライアントによって選択されたセキュリティタプルは、putfilehandle操作で示された親ディレクトリまたはSECINFOで示された子ファイルオブジェクト（またはSECINFO_NO_NAMEで示された親ディレクトリ）のセキュリティポリシーのタプルリストに含まれている必要はありません。もちろん、サーバーは、クライアントが選択するセキュリティタプルに合わせて構成する必要があります。そうでない場合、要求は適切な認証エラーでRPC層で失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In theory, there is no connection between the security flavor used by SECINFO or SECINFO_NO_NAME and those supported by the security policy. But in practice, the client may start looking for strong flavors from those supported by the security policy, followed by those in the REQUIRED set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
理論的には、SECINFOまたはSECINFO_NO_NAMEによって使用されるセキュリティフレーバーと、セキュリティポリシーによってサポートされるセキュリティフレーバーとの間には関係がありません。しかし実際には、クライアントはセキュリティポリシーでサポートされているものから強いフレーバーを探し始め、その後にREQUIREDセットのフレーバーを探します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC to a put filehandle operation that is immediately followed by SECINFO or SECINFO_NO_NAME. The NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC from SECINFO or SECINFO_NO_NAME.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1サーバーは、直後にSECINFOまたはSECINFO_NO_NAMEが続くput filehandle操作にNFS4ERR_WRONGSECを返してはなりません（MUST NOT）。 NFSv4.1サーバーは、SECINFOまたはSECINFO_NO_NAMEからNFS4ERR_WRONGSECを返してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-6-3-1-1-6--Put-Filehandle-Operation--Nothing">
2.6.3.1.1.6. Put Filehandle Operation + Nothing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.3.1.1.6. ファイルハンドル操作を置く+何もしない
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1サーバーはNFS4ERR_WRONGSECを返してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-6-3-1-1-7--Put-Filehandle-Operation--Anything-Else">
2.6.3.1.1.7. Put Filehandle Operation + Anything Else
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.3.1.1.7. ファイルハンドル操作とその他のものを置く
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;Anything Else&#34; includes OPEN by filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「その他」には、ファイルハンドルによるOPENが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security policy enforcement applies to the filehandle specified in the put filehandle operation. Therefore, the put filehandle operation MUST return NFS4ERR_WRONGSEC when there is a security tuple mismatch. This avoids the complexity of adding NFS4ERR_WRONGSEC as an allowable error to every other operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティポリシーの適用は、ファイルハンドルの配置操作で指定されたファイルハンドルに適用されます。したがって、セキュリティタプルの不一致がある場合、ファイルハンドルの書き込み操作はNFS4ERR_WRONGSECを返す必要があります。これにより、NFS4ERR_WRONGSECを許容されるエラーとして他のすべての操作に追加する複雑さが回避されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A COMPOUND containing the series put filehandle operation + SECINFO_NO_NAME (style SECINFO_STYLE4_CURRENT_FH) is an efficient way for the client to recover from NFS4ERR_WRONGSEC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
series putファイルハンドル操作+ SECINFO_NO_NAME（スタイルSECINFO_STYLE4_CURRENT_FH）を含むCOMPOUNDは、クライアントがNFS4ERR_WRONGSECから回復するための効率的な方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC to any operation other than a put filehandle operation, LOOKUP, LOOKUPP, and OPEN (by component name).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1サーバーは、ファイルハンドルのput操作、LOOKUP、LOOKUPP、およびOPEN（コンポーネント名による）以外の操作にNFS4ERR_WRONGSECを返してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-6-3-1-1-8--Operations-after-SECINFO-and-SECINFONONAME">
2.6.3.1.1.8. Operations after SECINFO and SECINFO_NO_NAME
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.3.1.1.8. SECINFOおよびSECINFO_NO_NAMEの後の操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suppose a client sends a COMPOUND procedure containing the series SEQUENCE, PUTFH, SECINFO_NONAME, READ, and suppose the security tuple used does not match that required for the target file. By rule (see Section 2.6.3.1.1.5), neither PUTFH nor SECINFO_NO_NAME can return NFS4ERR_WRONGSEC. By rule (see Section 2.6.3.1.1.7), READ cannot return NFS4ERR_WRONGSEC. The issue is resolved by the fact that SECINFO and SECINFO_NO_NAME consume the current filehandle (note that this is a change from NFSv4.0). This leaves no current filehandle for READ to use, and READ returns NFS4ERR_NOFILEHANDLE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがシリーズSEQUENCE、PUTFH、SECINFO_NONAME、READを含むCOMPOUNDプロシージャを送信し、使用されるセキュリティタプルがターゲットファイルに必要なものと一致しないと仮定します。規則（2.6.3.1.1.5を参照）では、PUTFHもSECINFO_NO_NAMEもNFS4ERR_WRONGSECを返すことができません。ルール（セクション2.6.3.1.1.7を参照）では、READはNFS4ERR_WRONGSECを返すことができません。この問題は、SECINFOおよびSECINFO_NO_NAMEが現在のファイルハンドルを消費するという事実によって解決されます（これはNFSv4.0からの変更であることに注意してください）。これは、READが使用する現在のファイルハンドルを残さず、READはNFS4ERR_NOFILEHANDLEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-6-3-1-2--LINK-and-RENAME">
2.6.3.1.2. LINK and RENAME
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.3.1.2. リンクと名前の変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The LINK and RENAME operations use both the current and saved filehandles. Technically, the server MAY return NFS4ERR_WRONGSEC from LINK or RENAME if the security policy of the saved filehandle rejects the security flavor used in the COMPOUND request&#39;s credentials. If the server does so, then if there is no intersection between the security policies of saved and current filehandles, this means that it will be impossible for the client to perform the intended LINK or RENAME operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
LINKおよびRENAME操作は、現在のファイルハンドルと保存されたファイルハンドルの両方を使用します。技術的には、保存されたファイルハンドルのセキュリティポリシーがCOMPOUNDリクエストの認証情報で使用されているセキュリティフレーバーを拒否した場合、サーバーはLINKまたはRENAMEからNFS4ERR_WRONGSECを返す場合があります。サーバーがそうする場合、保存されたファイルハンドルと現在のファイルハンドルのセキュリティポリシーの間に交差がない場合、これはクライアントが意図されたLINKまたはRENAME操作を実行できないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, suppose the client sends this COMPOUND request: SEQUENCE, PUTFH bFH, SAVEFH, PUTFH aFH, RENAME &#34;c&#34; &#34;d&#34;, where filehandles bFH and aFH refer to different directories. Suppose no common security tuple exists between the security policies of aFH and bFH. If the client sends the request using credentials acceptable to bFH&#39;s security policy but not aFH&#39;s policy, then the PUTFH aFH operation will fail with NFS4ERR_WRONGSEC. After a SECINFO_NO_NAME request, the client sends SEQUENCE, PUTFH bFH, SAVEFH, PUTFH aFH, RENAME &#34;c&#34; &#34;d&#34;, using credentials acceptable to aFH&#39;s security policy but not bFH&#39;s policy. The server returns NFS4ERR_WRONGSEC on the RENAME operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、クライアントが次のCOMPOUNDリクエストを送信するとします。SEQUENCE、PUTFH bFH、SAVEFH、PUTFH aFH、RENAME &#34;c&#34; &#34;d&#34;。ここで、ファイルハンドルbFHとaFHは異なるディレクトリを参照します。 aFHとbFHのセキュリティポリシーの間に共通のセキュリティタプルが存在しないとします。クライアントがbFHのセキュリティポリシーでは受け入れられるが、aFHのポリシーでは受け入れられない資格情報を使用して要求を送信すると、PUTFH aFH操作はNFS4ERR_WRONGSECで失敗します。 SECINFO_NO_NAME要求の後、クライアントは、aFHのセキュリティポリシーでは受け入れられるがbFHのポリシーでは受け入れられない資格情報を使用して、SEQUENCE、PUTFH bFH、SAVEFH、PUTFH aFH、RENAME &#34;c&#34; &#34;d&#34;を送信します。サーバーは、RENAME操作でNFS4ERR_WRONGSECを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To prevent a client from an endless sequence of a request containing LINK or RENAME, followed by a request containing SECINFO_NO_NAME or SECINFO, the server MUST detect when the security policies of the current and saved filehandles have no mutually acceptable security tuple, and MUST NOT return NFS4ERR_WRONGSEC from LINK or RENAME in that situation. Instead the server MUST do one of two things:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがLINKまたはRENAMEを含むリクエストとそれに続くSECINFO_NO_NAMEまたはSECINFOを含むリクエストの無限シーケンスからクライアントを保護するために、サーバーは現在のファイルハンドルと保存されたファイルハンドルのセキュリティポリシーに相互に受け入れ可能なセキュリティタプルがないことを検出しなければならず、返さないでくださいその状況では、LINKまたはRENAMEからのNFS4ERR_WRONGSEC。代わりに、サーバーは次の2つのいずれかを実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server can return NFS4ERR_XDEV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーはNFS4ERR_XDEVを返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server can allow the security policy of the current filehandle to override that of the saved filehandle, and so return NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、現在のファイルハンドルのセキュリティポリシーが保存されたファイルハンドルのセキュリティポリシーを上書きすることを許可して、NFS4_OKを返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-7--Minor-Versioning">
2.7. Minor Versioning
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.7. マイナーバージョン管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To address the requirement of an NFS protocol that can evolve as the need arises, the NFSv4.1 protocol contains the rules and framework to allow for future minor changes or versioning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必要に応じて進化できるNFSプロトコルの要件に対処するために、NFSv4.1プロトコルには、将来のマイナーな変更やバージョン管理を可能にするルールとフレームワークが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The base assumption with respect to minor versioning is that any future accepted minor version will be documented in one or more Standards Track RFCs. Minor version 0 of the NFSv4 protocol is represented by [30], and minor version 1 is represented by this RFC. The COMPOUND and CB_COMPOUND procedures support the encoding of the minor version being requested by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイナーバージョニングに関する基本的な前提は、将来受け入れられるマイナーバージョンは、1つ以上のStandards Track RFCに文書化されることです。 NFSv4プロトコルのマイナーバージョン0は[30]で表され、マイナーバージョン1はこのRFCで表されます。 COMPOUNDおよびCB_COMPOUNDプロシージャは、クライアントによって要求されているマイナーバージョンのエンコーディングをサポートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following items represent the basic rules for the development of minor versions. Note that a future minor version may modify or add to the following rules as part of the minor version definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の項目は、マイナーバージョンの開発に関する基本的な規則を表しています。将来のマイナーバージョンは、マイナーバージョン定義の一部として、次のルールを変更または追加する可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Procedures are not added or deleted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. プロシージャは追加または削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
To maintain the general RPC model, NFSv4 minor versions will not add to or delete procedures from the NFS program.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
一般的なRPCモデルを維持するために、NFSv4マイナーバージョンは、NFSプログラムにプロシージャを追加または削除しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Minor versions may add operations to the COMPOUND and CB_COMPOUND procedures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. マイナーバージョンでは、COMPOUNDおよびCB_COMPOUNDプロシージャに操作が追加される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
The addition of operations to the COMPOUND and CB_COMPOUND procedures does not affect the RPC model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
COMPOUNDおよびCB_COMPOUNDプロシージャに操作を追加しても、RPCモデルには影響しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
* Minor versions may append attributes to the bitmap4 that represents sets of attributes and to the fattr4 that represents sets of attribute values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
* マイナーバージョンでは、属性のセットを表すビットマップ4と属性値のセットを表すfattr4に属性を追加できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
This allows for the expansion of the attribute model to allow for future growth or adaptation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
これにより、属性モデルを拡張して、将来の成長または適応を可能にすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
* Minor version X must append any new attributes after the last documented attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
* マイナーバージョンXでは、ドキュメント化された最後の属性の後に新しい属性を追加する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
Since attribute results are specified as an opaque array of per-attribute, XDR-encoded results, the complexity of adding new attributes in the midst of the current definitions would be too burdensome.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
属性の結果は属性ごとの不透明な配列として指定されるため、XDRでエンコードされた結果なので、現在の定義の最中に新しい属性を追加することの複雑さは非常に面倒です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Minor versions must not modify the structure of an existing operation&#39;s arguments or results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. マイナーバージョンは、既存の操作の引数または結果の構造を変更してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Again, the complexity of handling multiple structure definitions for a single operation is too burdensome. New operations should be added instead of modifying existing structures for a minor version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
繰り返しになりますが、1回の操作で複数の構造定義を処理することの複雑さは、負担が大きすぎます。マイナーバージョンの既存の構造を変更する代わりに、新しい操作を追加する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
This rule does not preclude the following adaptations in a minor version:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
このルールは、マイナーバージョンでの以下の適応を排除しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
* adding bits to flag fields, such as new attributes to GETATTR&#39;s bitmap4 data type, and providing corresponding variants of opaque arrays, such as a notify4 used together with such bitmaps
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
* GETATTRのbitmap4データ型への新しい属性などのフラグフィールドにビットを追加し、そのようなビットマップと一緒に使用されるnotify4などの不透明な配列の対応するバリアントを提供する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
* adding bits to existing attributes like ACLs that have flag words
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
* フラグワードを持つACLなどの既存の属性にビットを追加する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
* extending enumerated types (including NFS4ERR_*) with new values
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
* 列挙型（NFS4ERR_ *を含む）を新しい値で拡張する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
* adding cases to a switched union
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
* スイッチドユニオンへのケースの追加
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Minor versions must not modify the structure of existing attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. マイナーバージョンは、既存の属性の構造を変更してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Minor versions must not delete operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. マイナーバージョンは操作を削除してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
This prevents the potential reuse of a particular operation &#34;slot&#34; in a future minor version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
これにより、将来のマイナーバージョンで特定の操作「スロット」が再利用される可能性がなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Minor versions must not delete attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. マイナーバージョンは属性を削除してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Minor versions must not delete flag bits or enumeration values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. マイナーバージョンは、フラグビットまたは列挙値を削除してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Minor versions may declare an operation MUST NOT be implemented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. マイナーバージョンは、操作を実装してはならないことを宣言できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Specifying that an operation MUST NOT be implemented is equivalent to obsoleting an operation. For the client, it means that the operation MUST NOT be sent to the server. For the server, an NFS error can be returned as opposed to &#34;dropping&#34; the request as an XDR decode error. This approach allows for the obsolescence of an operation while maintaining its structure so that a future minor version can reintroduce the operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
操作を実装してはならないことを指定することは、操作を廃止することと同じです。クライアントの場合、操作をサーバーに送信してはならないことを意味します。サーバーの場合、XDRデコードエラーとして要求を「ドロップ」するのではなく、NFSエラーを返すことができます。このアプローチにより、構造を維持しながら操作を廃止できるため、将来のマイナーバージョンで操作を再導入できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
1. Minor versions may declare that an attribute MUST NOT be implemented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
1. マイナーバージョンは、属性を実装してはならないことを宣言する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
2. Minor versions may declare that a flag bit or enumeration value MUST NOT be implemented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
2. マイナーバージョンは、フラグビットまたは列挙値を実装してはならないことを宣言する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. Minor versions may downgrade features from REQUIRED to RECOMMENDED, or RECOMMENDED to OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. マイナーバージョンは、機能をREQUIREDからRECOMMENDEDに、またはRECOMMENDEDからOPTIONALにダウングレードする場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. Minor versions may upgrade features from OPTIONAL to RECOMMENDED, or RECOMMENDED to REQUIRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. マイナーバージョンは、機能をOPTIONALからRECOMMENDEDに、またはRECOMMENDEDからREQUIREDにアップグレードする場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. A client and server that support minor version X SHOULD support minor versions zero through X-1 as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. マイナーバージョンXをサポートするクライアントとサーバーは、マイナーバージョン0からX-1までもサポートする必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12. Except for infrastructural changes, a minor version must not introduce REQUIRED new features.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12. インフラストラクチャの変更を除いて、マイナーバージョンは必須の新機能を導入してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
This rule allows for the introduction of new functionality and forces the use of implementation experience before designating a feature as REQUIRED. On the other hand, some classes of features are infrastructural and have broad effects. Allowing infrastructural features to be RECOMMENDED or OPTIONAL complicates implementation of the minor version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
このルールにより、新しい機能の導入が可能になり、機能を必須として指定する前に実装エクスペリエンスを強制的に使用できます。一方、機能の一部のクラスはインフラストラクチャであり、幅広い効果があります。インフラストラクチャの機能を推奨またはオプションとして許可すると、マイナーバージョンの実装が複雑になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
13. A client MUST NOT attempt to use a stateid, filehandle, or similar returned object from the COMPOUND procedure with minor version X for another COMPOUND procedure with minor version Y, where X != Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
13. クライアントは、マイナーバージョンXのCOMPOUNDプロシージャから返された状態ID、ファイルハンドル、または類似のオブジェクトを、マイナーバージョンYの別のCOMPOUNDプロシージャ（X！= Y）に使用してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-8--Non-RPC-Based-Security-Services">
2.8. Non-RPC-Based Security Services
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.8. 非RPCベースのセキュリティサービス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 2.2.1.1.1.1, NFSv4.1 relies on RPC for identification, authentication, integrity, and privacy. NFSv4.1 itself provides or enables additional security services as described in the next several subsections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション2.2.1.1.1.1で説明されているように、NFSv4.1は、識別、認証、整合性、およびプライバシーをRPCに依存しています。次のいくつかのサブセクションで説明するように、NFSv4.1自体が追加のセキュリティサービスを提供または有効にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-8-1--Authorization">
2.8.1. Authorization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.8.1. 認可
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Authorization to access a file object via an NFSv4.1 operation is ultimately determined by the NFSv4.1 server. A client can predetermine its access to a file object via the OPEN (Section 18.16) and the ACCESS (Section 18.1) operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1操作を介してファイルオブジェクトにアクセスする承認は、最終的にNFSv4.1サーバーによって決定されます。クライアントは、OPEN（セクション18.16）およびACCESS（セクション18.1）操作を介して、ファイルオブジェクトへのアクセスを事前に決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Principals with appropriate access rights can modify the authorization on a file object via the SETATTR (Section 18.30) operation. Attributes that affect access rights include mode, owner, owner_group, acl, dacl, and sacl. See Section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
適切なアクセス権を持つプリンシパルは、SETATTR（セクション18.30）操作を介してファイルオブジェクトの承認を変更できます。アクセス権に影響を与える属性には、モード、所有者、owner_group、acl、dacl、saclなどがあります。セクション5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-8-2--Auditing">
2.8.2. Auditing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.8.2. 監査
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 provides auditing on a per-file object basis, via the acl and sacl attributes as described in Section 6. It is outside the scope of this specification to specify audit log formats or management policies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1は、セクション6で説明されているように、aclおよびsacl属性を介してファイルごとのオブジェクトベースで監査を提供します。監査ログ形式または管理ポリシーを指定することは、この仕様の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-8-3--Intrusion-Detection">
2.8.3. Intrusion Detection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.8.3. 侵入検知
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 provides alarm control on a per-file object basis, via the acl and sacl attributes as described in Section 6. Alarms may serve as the basis for intrusion detection. It is outside the scope of this specification to specify heuristics for detecting intrusion via alarms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1は、セクション6で説明されているaclおよびsacl属性を介して、ファイルごとのオブジェクトベースでアラーム制御を提供します。アラームは侵入検知のベースとして機能する場合があります。アラームを介して侵入を検出するためのヒューリスティックを指定することは、この仕様の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-9--Transport-Layers">
2.9. Transport Layers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.9. トランスポート層
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-9-1--REQUIRED-and-RECOMMENDED-Properties-of-Transports">
2.9.1. REQUIRED and RECOMMENDED Properties of Transports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.9.1. トランスポートの必須および推奨プロパティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 NFSv4.1 works over Remote Direct Memory Access (RDMA) and non-RDMA-based transports with the following attributes: o The transport supports reliable delivery of data, which NFSv4.1 requires but neither NFSv4.1 nor RPC has facilities for ensuring [34].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFSv4.1は、次の属性を持つリモートダイレクトメモリアクセス（RDMA）および非RDMAベースのトランスポート上で動作します。 34]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The transport delivers data in the order it was sent. Ordered delivery simplifies detection of transmit errors, and simplifies the sending of arbitrary sized requests and responses via the record marking protocol [3].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o トランスポートは、送信された順序でデータを配信します。順序付けられた配信は、送信エラーの検出を簡素化し、レコードマーキングプロトコルを介した任意のサイズの要求および応答の送信を簡素化します[3]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where an NFSv4.1 implementation supports operation over the IP network protocol, any transport used between NFS and IP MUST be among the IETF-approved congestion control transport protocols. At the time this document was written, the only two transports that had the above attributes were TCP and the Stream Control Transmission Protocol (SCTP). To enhance the possibilities for interoperability, an NFSv4.1 implementation MUST support operation over the TCP transport protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1実装がIPネットワークプロトコルを介した操作をサポートする場合、NFSとIPの間で使用されるトランスポートは、IETF承認の輻輳制御トランスポートプロトコルに含まれる必要があります。このドキュメントが書かれた時点で、上記の属性を持つ2つのトランスポートは、TCPとストリーム制御伝送プロトコル（SCTP）だけでした。相互運用性の可能性を高めるために、NFSv4.1実装は、TCPトランスポートプロトコルを介した操作をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even if NFSv4.1 is used over a non-IP network protocol, it is RECOMMENDED that the transport support congestion control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1が非IPネットワークプロトコルで使用されている場合でも、トランスポートが輻輳制御をサポートすることが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is permissible for a connectionless transport to be used under NFSv4.1; however, reliable and in-order delivery of data combined with congestion control by the connectionless transport is REQUIRED. As a consequence, UDP by itself MUST NOT be used as an NFSv4.1 transport. NFSv4.1 assumes that a client transport address and server transport address used to send data over a transport together constitute a connection, even if the underlying transport eschews the concept of a connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コネクションレス型トランスポートをNFSv4.1で使用することは許可されています。ただし、コネクションレス型トランスポートによる輻輳制御と組み合わせた信頼性の高い順序どおりのデータ配信が必要です。その結果、UDP自体をNFSv4.1トランスポートとして使用してはなりません（MUST NOT）。 NFSv4.1は、トランスポートを介してデータを送信するために使用されるクライアントトランスポートアドレスとサーバートランスポートアドレスが接続を構成すると想定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-9-2--Client-and-Server-Transport-Behavior">
2.9.2. Client and Server Transport Behavior
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.9.2. クライアントとサーバーのトランスポート動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a connection-oriented transport (e.g., TCP) is used, the client and server SHOULD use long-lived connections for at least three reasons:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続指向のトランスポート（TCPなど）が使用されている場合、クライアントとサーバーは、少なくとも3つの理由で、長寿命の接続を使用する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. This will prevent the weakening of the transport&#39;s congestion control mechanisms via short-lived connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. これにより、短命の接続によるトランスポートの輻輳制御メカニズムの弱体化が防止されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. This will improve performance for the WAN environment by eliminating the need for connection setup handshakes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. これにより、接続設定のハンドシェイクが不要になるため、WAN環境のパフォーマンスが向上します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The NFSv4.1 callback model differs from NFSv4.0, and requires the client and server to maintain a client-created backchannel (see Section 2.10.3.1) for the server to use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. NFSv4.1コールバックモデルはNFSv4.0とは異なり、サーバーが使用できるようにクライアントとサーバーがクライアント作成のバックチャネル（セクション2.10.3.1を参照）を維持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In order to reduce congestion, if a connection-oriented transport is used, and the request is not the NULL procedure: o A requester MUST NOT retry a request unless the connection the request was sent over was lost before the reply was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
コネクション指向のトランスポートが使用され、リクエストがNULLプロシージャではない場合、輻輳を減らすために、oリクエスタは、リクエストが送信された接続が応答を受信する前に失われない限り、リクエストを再試行してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A replier MUST NOT silently drop a request, even if the request is a retry. (The silent drop behavior of RPCSEC_GSS [4] does not apply because this behavior happens at the RPCSEC_GSS layer, a lower layer in the request processing.) Instead, the replier SHOULD return an appropriate error (see Section 2.10.6.1), or it MAY disconnect the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 要求が再試行であっても、リプライヤは要求を黙って破棄してはなりません。 （RPCSEC_GSS [4]のサイレントドロップ動作は適用されません。この動作は、要求処理の下位層であるRPCSEC_GSS層で発生するためです。）代わりに、返信者は適切なエラーを返す必要があります（セクション2.10.6.1を参照）。接続を切断することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When sending a reply, the replier MUST send the reply to the same full network address (e.g., if using an IP-based transport, the source port of the requester is part of the full network address) from which the requester sent the request. If using a connection-oriented transport, replies MUST be sent on the same connection from which the request was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
返信を送信するとき、返信者はリクエスターがリクエストを送信した元の同じ完全なネットワークアドレスに返信を送信する必要があります（たとえば、IPベースのトランスポートを使用している場合、リクエスターのソースポートは完全なネットワークアドレスの一部です）。接続指向のトランスポートを使用している場合は、要求を受信したのと同じ接続で応答を送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a connection is dropped after the replier receives the request but before the replier sends the reply, the replier might have a pending reply. If a connection is established with the same source and destination full network address as the dropped connection, then the replier MUST NOT send the reply until the requester retries the request. The reason for this prohibition is that the requester MAY retry a request over a different connection (provided that connection is associated with the original request&#39;s session).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答者が要求を受信した後、応答者が応答を送信する前に接続がドロップされた場合、応答者は応答を保留している可能性があります。ドロップされた接続と同じ送信元および宛先の完全なネットワークアドレスを使用して接続が確立された場合、リクエスタは要求者が要求を再試行するまで応答を送信してはなりません（MUST NOT）。この禁止の理由は、リクエスターが別の接続を介して要求を再試行する可能性があるためです（接続が元の要求のセッションに関連付けられている場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When using RDMA transports, there are other reasons for not tolerating retries over the same connection:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RDMAトランスポートを使用する場合、同じ接続での再試行を許容しない他の理由があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RDMA transports use &#34;credits&#34; to enforce flow control, where a credit is a right to a peer to transmit a message. If one peer were to retransmit a request (or reply), it would consume an additional credit. If the replier retransmitted a reply, it would certainly result in an RDMA connection loss, since the requester would typically only post a single receive buffer for each request. If the requester retransmitted a request, the additional credit consumed on the server might lead to RDMA connection failure unless the client accounted for it and decreased its available credit, leading to wasted resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RDMAトランスポートは、「クレジット」を使用してフロー制御を実施します。クレジットは、ピアがメッセージを送信する権利です。 1つのピアが要求を再送信（または応答）した場合、追加のクレジットが消費されます。リプライアが応答を再送信した場合、リクエスタは通常、各リクエストに対して単一の受信バッファのみをポストするため、RDMA接続が失われます。リクエスターが要求を再送信した場合、サーバーで消費された追加のクレジットは、クライアントがそれを考慮に入れて使用可能なクレジットを減らし、リソースを浪費しない限り、RDMA接続の失敗につながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RDMA credits present a new issue to the reply cache in NFSv4.1. The reply cache may be used when a connection within a session is lost, such as after the client reconnects. Credit information is a dynamic property of the RDMA connection, and stale values must not be replayed from the cache. This implies that the reply cache contents must not be blindly used when replies are sent from it, and credit information appropriate to the channel must be refreshed by the RPC layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RDMAクレジットは、NFSv4.1の応答キャッシュに新しい問題をもたらします。応答キャッシュは、クライアントが再接続した後など、セッション内の接続が失われたときに使用できます。クレジット情報はRDMA接続の動的プロパティであり、古い値をキャッシュから再生することはできません。これは、返信が送信されるときに返信キャッシュの内容を盲目的に使用してはならず、チャネルに適切なクレジット情報をRPCレイヤーで更新する必要があることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, as described in Section 2.10.6.2, while a session is active, the NFSv4.1 requester MUST NOT stop waiting for a reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、セクション2.10.6.2で説明されているように、セッションがアクティブな間、NFSv4.1リクエスタは応答の待機を停止してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-9-3--Ports">
2.9.3. Ports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.9.3. ポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Historically, NFSv3 servers have listened over TCP port 2049. The registered port 2049 [35] for the NFS protocol should be the default configuration. NFSv4.1 clients SHOULD NOT use the RPC binding protocols as described in [36].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
歴史的に、NFSv3サーバーはTCPポート2049でリッスンしてきました。NFSプロトコル用の登録済みポート2049 [35]がデフォルトの構成である必要があります。 NFSv4.1クライアントは、[36]で説明されているRPCバインディングプロトコルを使用してはなりません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10--Session">
2.10. Session
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10. セッション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 clients and servers MUST support and MUST use the session feature as described in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションで説明するように、NFSv4.1クライアントとサーバーは、セッション機能をサポートし、使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-1--Motivation-and-Overview">
2.10.1. Motivation and Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.1. 動機と概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Previous versions and minor versions of NFS have suffered from the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSの以前のバージョンとマイナーバージョンには、次の問題があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Lack of support for Exactly Once Semantics (EOS). This includes lack of support for EOS through server failure and recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Exactly Once Semantics（EOS）のサポートの欠如。これには、サーバーの障害と回復によるEOSのサポートの欠如が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Limited callback support, including no support for sending callbacks through firewalls, and races between replies to normal requests and callbacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイアウォールを介したコールバックの送信のサポートを含まない限定的なコールバックサポート、および通常のリクエストへの返信とコールバック間の競合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Limited trunking over multiple network paths.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 複数のネットワークパスでの限定的なトランキング。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Requiring machine credentials for fully secure operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 完全に安全な操作のためにマシンの資格情報が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Through the introduction of a session, NFSv4.1 addresses the above shortfalls with practical solutions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションの導入を通じて、NFSv4.1は上記の不足を実用的なソリューションで解決します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o EOS is enabled by a reply cache with a bounded size, making it feasible to keep the cache in persistent storage and enable EOS through server failure and recovery. One reason that previous revisions of NFS did not support EOS was because some EOS approaches often limited parallelism. As will be explained in Section 2.10.6, NFSv4.1 supports both EOS and unlimited parallelism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o EOSは、サイズが制限された応答キャッシュによって有効にされるため、永続的なストレージにキャッシュを保持し、サーバーの障害と回復を通じてEOSを有効にすることが可能になります。以前のリビジョンのNFSがEOSをサポートしなかった理由の1つは、一部のEOSアプローチが並列処理を制限することが多かったためです。セクション2.10.6で説明するように、NFSv4.1はEOSと無制限の並列処理の両方をサポートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The NFSv4.1 client (defined in Section 1.6, Paragraph 2) creates transport connections and provides them to the server to use for sending callback requests, thus solving the firewall issue (Section 18.34). Races between responses from client requests and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1クライアント（セクション1.6、段落2で定義）はトランスポート接続を作成し、それらをサーバーに提供してコールバック要求の送信に使用することで、ファイアウォールの問題を解決します（セクション18.34）。クライアント要求からの応答と、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
callbacks caused by the requests are detected via the session&#39;s sequencing properties that are a consequence of EOS (Section 2.10.6.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
要求によって引き起こされるコールバックは、EOSの結果であるセッションのシーケンスプロパティを介して検出されます（セクション2.10.6.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The NFSv4.1 client can associate an arbitrary number of connections with the session, and thus provide trunking (Section 2.10.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1クライアントは、任意の数の接続をセッションに関連付けることができるため、トランキングを提供できます（2.10.5節）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The NFSv4.1 client and server produces a session key independent of client and server machine credentials which can be used to compute a digest for protecting critical session management operations (Section 2.10.8.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1クライアントおよびサーバーは、重要なセッション管理操作を保護するためのダイジェストを計算するために使用できるクライアントおよびサーバーマシンの認証情報とは独立したセッションキーを生成します（セクション2.10.8.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The NFSv4.1 client can also create secure RPCSEC_GSS contexts for use by the session&#39;s backchannel that do not require the server to authenticate to a client machine principal (Section 2.10.8.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1クライアントは、サーバーがクライアントマシンプリンシパルへの認証を必要としない、セッションのバックチャネルで使用する安全なRPCSEC_GSSコンテキストを作成することもできます（セクション2.10.8.2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A session is a dynamically created, long-lived server object created by a client and used over time from one or more transport connections. Its function is to maintain the server&#39;s state relative to the connection(s) belonging to a client instance. This state is entirely independent of the connection itself, and indeed the state exists whether or not the connection exists. A client may have one or more sessions associated with it so that client-associated state may be accessed using any of the sessions associated with that client&#39;s client ID, when connections are associated with those sessions. When no connections are associated with any of a client ID&#39;s sessions for an extended time, such objects as locks, opens, delegations, layouts, etc. are subject to expiration. The session serves as an object representing a means of access by a client to the associated client state on the server, independent of the physical means of access to that state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションは、クライアントによって作成され、1つ以上のトランスポート接続から長期にわたって使用される、動的に作成された長期間有効なサーバーオブジェクトです。その機能は、クライアントインスタンスに属する接続に対するサーバーの状態を維持することです。この状態は、接続自体から完全に独立しており、実際には、接続が存在するかどうかに関係なく存在します。クライアントには1つ以上のセッションが関連付けられている可能性があるため、接続がそれらのセッションに関連付けられている場合、そのクライアントのクライアントIDに関連付けられている任意のセッションを使用してクライアント関連状態にアクセスできます。長時間クライアントIDのセッションのいずれにも接続が関連付けられていない場合、ロック、オープン、委任、レイアウトなどのオブジェクトは有効期限が切れます。セッションは、その状態への物理的なアクセス手段とは関係なく、クライアントがサーバー上の関連付けられたクライアント状態にアクセスする手段を表すオブジェクトとして機能します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A single client may create multiple sessions. A single session MUST NOT serve multiple clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一のクライアントが複数のセッションを作成する場合があります。単一のセッションが複数のクライアントにサービスを提供してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-2--NFSv4-Integration">
2.10.2. NFSv4 Integration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.2. NFSv4統合
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sessions are part of NFSv4.1 and not NFSv4.0. Normally, a major infrastructure change such as sessions would require a new major version number to an Open Network Computing (ONC) RPC program like NFS. However, because NFSv4 encapsulates its functionality in a single procedure, COMPOUND, and because COMPOUND can support an arbitrary number of operations, sessions have been added to NFSv4.1 with little difficulty. COMPOUND includes a minor version number field, and for NFSv4.1 this minor version is set to 1. When the NFSv4 server processes a COMPOUND with the minor version set to 1, it expects a different set of operations than it does for NFSv4.0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションはNFSv4.1ではなくNFSv4.0の一部です。通常、セッションなどの大きなインフラストラクチャの変更には、NFSのようなOpen Network Computing（ONC）RPCプログラムの新しいメジャーバージョン番号が必要です。ただし、NFSv4はその機能を単一の手順COMPOUNDにカプセル化し、COMPOUNDは任意の数の操作をサポートできるため、セッションはほとんど問題なくNFSv4.1に追加されました。 COMPOUNDにはマイナーバージョン番号フィールドが含まれ、NFSv4.1の場合、このマイナーバージョンは1に設定されます。NFSv4サーバーは、マイナーバージョンが1に設定されたCOMPOUNDを処理するときに、NFSv4.0の場合とは異なる操作のセットを予期します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 defines the SEQUENCE operation, which is required for every COMPOUND that operates over an established session, with the exception of some session administration operations, such as DESTROY_SESSION (Section 18.37).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1は、DESTROY_SESSION（セクション18.37）などの一部のセッション管理操作を除いて、確立されたセッションで動作するすべてのCOMPOUNDに必要なSEQUENCE操作を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-2-1--SEQUENCE-and-CBSEQUENCE">
2.10.2.1. SEQUENCE and CB_SEQUENCE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.2.1. SEQUENCEおよびCB_SEQUENCE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In NFSv4.1, when the SEQUENCE operation is present, it MUST be the first operation in the COMPOUND procedure. The primary purpose of SEQUENCE is to carry the session identifier. The session identifier associates all other operations in the COMPOUND procedure with a particular session. SEQUENCE also contains required information for maintaining EOS (see Section 2.10.6). Session-enabled NFSv4.1 COMPOUND requests thus have the form:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1では、SEQUENCE操作が存在する場合、それはCOMPOUNDプロシージャの最初の操作でなければなりません。 SEQUENCEの主な目的は、セッション識別子を運ぶことです。セッション識別子は、COMPOUNDプロシージャ内の他のすべての操作を特定のセッションに関連付けます。 SEQUENCEには、EOSを維持するために必要な情報も含まれています（セクション2.10.6を参照）。したがって、セッション対応のNFSv4.1 COMPOUNDリクエストは次の形式になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       +-----+--------------+-----------+------------+-----------+----
       | tag | minorversion | numops    |SEQUENCE op | op + args | ...
       |     |   (== 1)     | (limited) |  + args    |           |
       +-----+--------------+-----------+------------+-----------+----
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and the replies have the form:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
返信の形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       +------------+-----+--------+-------------------------------+--//
       |last status | tag | numres |status + SEQUENCE op + results |  //
       +------------+-----+--------+-------------------------------+--//
               //-----------------------+----
               // status + op + results | ...
               //-----------------------+----
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A CB_COMPOUND procedure request and reply has a similar form to COMPOUND, but instead of a SEQUENCE operation, there is a CB_SEQUENCE operation. CB_COMPOUND also has an additional field called &#34;callback_ident&#34;, which is superfluous in NFSv4.1 and MUST be ignored by the client. CB_SEQUENCE has the same information as SEQUENCE, and also includes other information needed to resolve callback races (Section 2.10.6.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUNDプロシージャの要求と応答はCOMPOUNDと同様の形式ですが、SEQUENCE操作の代わりにCB_SEQUENCE操作があります。 CB_COMPOUNDには、「callback_ident」と呼ばれる追加のフィールドもあります。これは、NFSv4.1では不要であり、クライアントによって無視される必要があります。 CB_SEQUENCEにはSEQUENCEと同じ情報があり、コールバックの競合を解決するために必要なその他の情報も含まれています（セクション2.10.6.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-2-2--Client-ID-and-Session-Association">
2.10.2.2. Client ID and Session Association
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.2.2. クライアントIDとセッションの関連付け
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each client ID (Section 2.4) can have zero or more active sessions. A client ID and associated session are required to perform file access in NFSv4.1. Each time a session is used (whether by a client sending a request to the server or the client replying to a callback request from the server), the state leased to its associated client ID is automatically renewed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各クライアントID（2.4節）は、0個以上のアクティブセッションを持つことができます。 NFSv4.1でファイルアクセスを実行するには、クライアントIDと関連するセッションが必要です。セッションが使用されるたびに（クライアントがサーバーに要求を送信するか、クライアントがサーバーからのコールバック要求に応答するかに関係なく）、関連するクライアントIDにリースされた状態が自動的に更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
State (which can consist of share reservations, locks, delegations, and layouts (Section 1.7.4)) is tied to the client ID. Client state is not tied to any individual session. Successive state changing operations from a given state owner MAY go over different sessions, provided the session is associated with the same client ID. A callback MAY arrive over a different session than that of the request that originally acquired the state pertaining to the callback. For example, if session A is used to acquire a delegation, a request to recall the delegation MAY arrive over session B if both sessions are associated with the same client ID. Sections 2.10.8.1 and 2.10.8.2 discuss the security considerations around callbacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態（共有の予約、ロック、委任、およびレイアウト（セクション1.7.4）で構成できます）は、クライアントIDに関連付けられています。クライアントの状態は、個々のセッションに関連付けられていません。セッションが同じクライアントIDに関連付けられている場合、特定の状態所有者からの連続する状態変更操作は、異なるセッションを通過する場合があります。コールバックは、コールバックに関連する状態を最初に取得したリクエストのセッションとは異なるセッションを介して到着する場合があります。たとえば、セッションAを使用して委任を取得する場合、両方のセッションが同じクライアントIDに関連付けられていると、委任を取り消す要求がセッションBを介して到着する場合があります。セクション2.10.8.1および2.10.8.2では、コールバックに関するセキュリティの考慮事項について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-3--Channels">
2.10.3. Channels
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.3. チャンネル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A channel is not a connection. A channel represents the direction ONC RPC requests are sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャネルは接続ではありません。チャネルは、ONC RPC要求が送信される方向を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each session has one or two channels: the fore channel and the backchannel. Because there are at most two channels per session, and because each channel has a distinct purpose, channels are not assigned identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各セッションには、1つまたは2つのチャネル（フォアチャネルとバックチャネル）があります。セッションごとに最大2つのチャネルがあり、各チャネルには明確な目的があるため、チャネルには識別子が割り当てられません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fore channel is used for ordinary requests from the client to the server, and carries COMPOUND requests and responses. A session always has a fore channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
foreチャネルは、クライアントからサーバーへの通常の要求に使用され、COMPOUND要求と応答を伝送します。セッションには常にフォアチャネルがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The backchannel is used for callback requests from server to client, and carries CB_COMPOUND requests and responses. Whether or not there is a backchannel is a decision made by the client; however, many features of NFSv4.1 require a backchannel. NFSv4.1 servers MUST support backchannels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バックチャネルは、サーバーからクライアントへのコールバック要求に使用され、CB_COMPOUND要求と応答を伝送します。バックチャネルがあるかどうかは、クライアントが決定します。ただし、NFSv4.1の多くの機能にはバックチャネルが必要です。 NFSv4.1サーバーはバックチャネルをサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each session has resources for each channel, including separate reply caches (see Section 2.10.6.1). Note that even the backchannel requires a reply cache (or, at least, a slot table in order to detect retries) because some callback operations are nonidempotent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各セッションには、個別の応答キャッシュを含む各チャネルのリソースがあります（セクション2.10.6.1を参照）。一部のコールバック操作は非べき等であるため、バックチャネルでも応答キャッシュ（または、少なくとも再試行を検出するためにスロットテーブル）が必要であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-3-1--Association-of-Connections-Channels-and-Sessions">
2.10.3.1. Association of Connections, Channels, and Sessions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.3.1. 接続、チャネル、およびセッションの関連付け
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Each channel is associated with zero or more transport connections (whether of the same transport protocol or different transport protocols). A connection can be associated with one channel or both channels of a session; the client and server negotiate whether a connection will carry traffic for one channel or both channels via the CREATE_SESSION (Section 18.36) and the BIND_CONN_TO_SESSION (Section 18.34) operations. When a session is created via CREATE_SESSION, the connection that transported the CREATE_SESSION request is automatically associated with the fore channel, and optionally the backchannel. If the client specifies no state protection (Section 18.35) when the session is created, then when SEQUENCE is transmitted on a different connection, the connection is automatically associated with the fore channel of the session specified in the SEQUENCE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
各チャネルは、ゼロまたはそれ以上のトランスポート接続に関連付けられます（同じトランスポートプロトコルでも異なるトランスポートプロトコルでも）。接続は、セッションの1つのチャネルまたは両方のチャネルに関連付けることができます。クライアントとサーバーは、接続がCREATE_SESSION（セクション18.36）およびBIND_CONN_TO_SESSION（セクション18.34）操作を介して1つのチャネルまたは両方のチャネルのトラフィックを伝送するかどうかについてネゴシエートします。 CREATE_SESSIONを介してセッションが作成されると、CREATE_SESSION要求を転送した接続は、フォアチャネルと、オプションでバックチャネルに自動的に関連付けられます。セッションの作成時にクライアントが状態保護を指定しない場合（セクション18.35）、SEQUENCEが別の接続で送信されると、接続はSEQUENCE操作で指定されたセッションのフォアチャネルに自動的に関連付けられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A connection&#39;s association with a session is not exclusive. A connection associated with the channel(s) of one session may be simultaneously associated with the channel(s) of other sessions including sessions associated with other client IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続とセッションの関連付けは排他的ではありません。 1つのセッションのチャネルに関連付けられた接続は、他のクライアントIDに関連付けられたセッションを含む他のセッションのチャネルに同時に関連付けられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is permissible for connections of multiple transport types to be associated with the same channel. For example, both TCP and RDMA connections can be associated with the fore channel. In the event an RDMA and non-RDMA connection are associated with the same channel, the maximum number of slots SHOULD be at least one more than the total number of RDMA credits (Section 2.10.6.1). This way, if all RDMA credits are used, the non-RDMA connection can have at least one outstanding request. If a server supports multiple transport types, it MUST allow a client to associate connections from each transport to a channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のトランスポートタイプの接続が同じチャネルに関連付けられていても問題ありません。たとえば、TCP接続とRDMA接続の両方をフォアチャネルに関連付けることができます。 RDMA接続と非RDMA接続が同じチャネルに関連付けられている場合、スロットの最大数は、RDMAクレジットの総数（セクション2.10.6.1）より少なくとも1多い必要があります（SHOULD）。このように、すべてのRDMAクレジットが使用されている場合、非RDMA接続は少なくとも1つの未処理の要求を持つことができます。サーバーが複数のトランスポートタイプをサポートしている場合、クライアントが各トランスポートからチャネルへの接続を関連付けることを許可する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is permissible for a connection of one type of transport to be associated with the fore channel, and a connection of a different type to be associated with the backchannel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あるタイプのトランスポートの接続をフォアチャネルに関連付け、別のタイプの接続をバッ​​クチャネルに関連付けることは許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-4--Server-Scope">
2.10.4. Server Scope
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.4. サーバーの範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers each specify a server scope value in the form of an opaque string eir_server_scope returned as part of the results of an EXCHANGE_ID operation. The purpose of the server scope is to allow a group of servers to indicate to clients that a set of servers sharing the same server scope value has arranged to use compatible values of otherwise opaque identifiers. Thus, the identifiers generated by one server of that set may be presented to another of that same scope.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはそれぞれ、EXCHANGE_ID操作の結果の一部として返される不透明な文字列eir_server_scopeの形式でサーバースコープ値を指定します。サーバースコープの目的は、サーバーのグループが、同じサーバースコープの値を共有する一連のサーバーが、互換性のない不透明な識別子の値を使用するように調整したことをクライアントに示すことを可能にすることです。したがって、そのセットの1つのサーバーによって生成された識別子は、同じスコープの別のサーバーに提示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of such compatible values does not imply that a value generated by one server will always be accepted by another. In most cases, it will not. However, a server will not accept a value generated by another inadvertently. When it does accept it, it will be because it is recognized as valid and carrying the same meaning as on another server of the same scope.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのような互換性のある値の使用は、あるサーバーによって生成された値が常に別のサーバーによって受け入れられることを意味しません。ほとんどの場合、そうではありません。ただし、サーバーは、別のサーバーが誤って生成した値を受け入れません。受け入れる場合は、有効であると認識され、同じスコープの別のサーバーと同じ意味を持つためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When servers are of the same server scope, this compatibility of values applies to the follow identifiers: o Filehandle values. A filehandle value accepted by two servers of the same server scope denotes the same object. A WRITE operation sent to one server is reflected immediately in a READ sent to the other, and locks obtained on one server conflict with those requested on the other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーが同じサーバースコープにある場合、この値の互換性は次の識別子に適用されます。oファイルハンドル値。同じサーバースコープの2つのサーバーが受け入れるファイルハンドル値は、同じオブジェクトを示します。一方のサーバーに送信されたWRITE操作は、他方のサーバーに送信されたREADにすぐに反映され、一方のサーバーで取得されたロックは、他方のサーバーで要求されたロックと競合します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Session ID values. A session ID value accepted by two servers of the same server scope denotes the same session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セッションID値。同じサーバースコープの2つのサーバーが受け入れるセッションID値は、同じセッションを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Client ID values. A client ID value accepted as valid by two servers of the same server scope is associated with two clients with the same client owner and verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントID値。同じサーバースコープの2つのサーバーによって有効であると受け入れられたクライアントID値は、同じクライアント所有者と検証者を持つ2つのクライアントに関連付けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o State ID values. A state ID value is recognized as valid when the corresponding client ID is recognized as valid. If the same stateid value is accepted as valid on two servers of the same scope and the client IDs on the two servers represent the same client owner and verifier, then the two stateid values designate the same set of locks and are for the same file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 州ID値。状態ID値は、対応するクライアントIDが有効であると認識されると、有効であると認識されます。同じスコープの2つのサーバーで同じ状態ID値が有効として受け入れられ、2つのサーバーのクライアントIDが同じクライアント所有者と検証者を表す場合、2つの状態ID値は同じロックのセットを指定し、同じファイルに対するものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Server owner values. When the server scope values are the same, server owner value may be validly compared. In cases where the server scope values are different, server owner values are treated as different even if they contain all identical bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバー所有者の値。サーバースコープの値が同じ場合、サーバーの所有者の値が有効に比較されることがあります。サーバースコープの値が異なる場合、サーバーの所有者の値は、同じバイトがすべて含まれている場合でも異なるものとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The coordination among servers required to provide such compatibility can be quite minimal, and limited to a simple partition of the ID space. The recognition of common values requires additional implementation, but this can be tailored to the specific situations in which that recognition is desired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような互換性を提供するために必要なサーバー間の調整は非常に最小限で済み、IDスペースの単純なパーティションに制限されます。一般的な値の認識には追加の実装が必要ですが、これはその認識が望まれる特定の状況に合わせて調整できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients will have occasion to compare the server scope values of multiple servers under a number of circumstances, each of which will be discussed under the appropriate functional section:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、さまざまな状況下で複数のサーバーのサーバースコープ値を比較する機会があります。それぞれについて、適切な機能セクションで説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When server owner values received in response to EXCHANGE_ID operations sent to multiple network addresses are compared for the purpose of determining the validity of various forms of trunking, as described in Section 2.10.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セクション2.10.5で説明されているように、複数のネットワークアドレスに送信されたEXCHANGE_ID操作に応答して受信されたサーバー所有者の値が比較され、さまざまな形式のトランキングの有効性が判断されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When network or server reconfiguration causes the same network address to possibly be directed to different servers, with the necessity for the client to determine when lock reclaim should be attempted, as described in Section 8.4.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ネットワークまたはサーバーの再構成により、同じネットワークアドレスが異なるサーバーに送信される可能性がある場合、8.4.2.1項で説明するように、クライアントはロックの再利用をいつ試行するかを決定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o When file system migration causes the transfer of responsibility for a file system between servers and the client needs to determine whether state has been transferred with the file system (as described in Section 11.7.7) or whether the client needs to reclaim state on a similar basis as in the case of server restart, as described in Section 8.4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
oファイルシステムの移行により、サーバーとクライアント間でファイルシステムの責任が移る場合、状態がファイルシステムで転送されているか（セクション11.7.7を参照）、クライアントが状態を再利用する必要があるかどうかを判断する必要があるセクション8.4.2で説明されているように、サーバーの再起動の場合と同様の基準。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When two replies from EXCHANGE_ID, each from two different server network addresses, have the same server scope, there are a number of ways a client can validate that the common server scope is due to two servers cooperating in a group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それぞれが2つの異なるサーバーネットワークアドレスからのEXCHANGE_IDからの2つの応答が同じサーバースコープを持っている場合、クライアントが共通サーバースコープの原因がグループ内での2つのサーバーの協力によるものであることを検証するには、いくつかの方法があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If both EXCHANGE_ID requests were sent with RPCSEC_GSS authentication and the server principal is the same for both targets, the equality of server scope is validated. It is RECOMMENDED that two servers intending to share the same server scope also share the same principal name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 両方のEXCHANGE_ID要求がRPCSEC_GSS認証で送信され、サーバープリンシパルが両方のターゲットで同じである場合、サーバースコープの同等性が検証されます。同じサーバースコープを共有する2つのサーバーも同じプリンシパル名を共有することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client may accept the appearance of the second server in the fs_locations or fs_locations_info attribute for a relevant file system. For example, if there is a migration event for a particular file system or there are locks to be reclaimed on a particular file system, the attributes for that particular file system may be used. The client sends the GETATTR request to the first server for the fs_locations or fs_locations_info attribute with RPCSEC_GSS authentication. It may need to do this in advance of the need to verify the common server scope. If the client successfully authenticates the reply to GETATTR, and the GETATTR request and reply containing the fs_locations or fs_locations_info attribute refers to the second server, then the equality of server scope is supported. A client may choose to limit the use of this form of support to information relevant to the specific file system involved (e.g. a file system being migrated).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは、関連するファイルシステムのfs_locationsまたはfs_locations_info属性で2番目のサーバーの外観を受け入れることができます。たとえば、特定のファイルシステムの移行イベントがある場合、または特定のファイルシステムで再利用されるロックがある場合、その特定のファイルシステムの属性を使用できます。クライアントは、RPCSEC_GSS認証を使用してfs_locationsまたはfs_locations_info属性のGETATTR要求を最初のサーバーに送信します。共通サーバーのスコープを検証する前に、これを行う必要がある場合があります。クライアントがGETATTRへの応答の認証に成功し、GETATTR要求とfs_locationsまたはfs_locations_info属性を含む応答が2番目のサーバーを参照している場合、サーバースコープの同等性がサポートされます。クライアントは、この形式のサポートの使用を、関連する特定のファイルシステム（移行されるファイルシステムなど）に関連する情報に制限することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-5--Trunking">
2.10.5. Trunking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.5. トランキング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Trunking is the use of multiple connections between a client and server in order to increase the speed of data transfer. NFSv4.1 supports two types of trunking: session trunking and client ID trunking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランキングとは、データ転送の速度を上げるために、クライアントとサーバー間の複数の接続を使用することです。 NFSv4.1は、セッショントランキングとクライアントIDトランキングの2種類のトランキングをサポートしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 servers MUST support both forms of trunking within the context of a single server network address and MUST support both forms within the context of the set of network addresses used to access a single server. NFSv4.1 servers in a clustered configuration MAY allow network addresses for different servers to use client ID trunking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1サーバーは、単一サーバーのネットワークアドレスのコンテキスト内で両方の形式のトランキングをサポートする必要があり、単一サーバーへのアクセスに使用されるネットワークアドレスのセットのコンテキスト内で両方の形式をサポートする必要があります。クラスター構成のNFSv4.1サーバーは、異なるサーバーのネットワークアドレスがクライアントIDトランキングを使用できるようにする場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Clients may use either form of trunking as long as they do not, when trunking between different server network addresses, violate the servers&#39; mandates as to the kinds of trunking to be allowed (see below). With regard to callback channels, the client MUST allow the server to choose among all callback channels valid for a given client ID and MUST support trunking when the connections supporting the backchannel allow session or client ID trunking to be used for callbacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントは、異なるサーバーネットワークアドレス間でトランキングを行う場合に、許可するトランキングの種類に関するサーバーの義務に違反しない限り、どちらの形式のトランキングも使用できます（以下を参照）。コールバックチャネルに関して、クライアントはサーバーが特定のクライアントIDに有効なすべてのコールバックチャネルから選択できるようにし、バックチャネルをサポートする接続がセッションまたはクライアントIDトランキングをコールバックに使用できる場合はトランキングをサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Session trunking is essentially the association of multiple connections, each with potentially different target and/or source network addresses, to the same session. When the target network addresses (server addresses) of the two connections are the same, the server MUST support such session trunking. When the target network addresses are different, the server MAY indicate such support using the data returned by the EXCHANGE_ID operation (see below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッショントランキングとは、基本的には、ターゲットやソースのネットワークアドレスが異なる可能性のある複数の接続を同じセッションに関連付けることです。 2つの接続のターゲットネットワークアドレス（サーバーアドレス）が同じ場合、サーバーはそのようなセッショントランキングをサポートする必要があります。ターゲットネットワークアドレスが異なる場合、サーバーは、EXCHANGE_IDオペレーションによって返されるデータを使用して、そのようなサポートを示す場合があります（下記参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client ID trunking is the association of multiple sessions to the same client ID. Servers MUST support client ID trunking for two target network addresses whenever they allow session trunking for those same two network addresses. In addition, a server MAY, by presenting the same major server owner ID (Section 2.5) and server scope (Section 2.10.4), allow an additional case of client ID trunking. When two servers return the same major server owner and server scope, it means that the two servers are cooperating on locking state management, which is a prerequisite for client ID trunking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントIDトランキングは、複数のセッションを同じクライアントIDに関連付けることです。サーバーは、同じ2つのネットワークアドレスのセッショントランキングを許可する場合は常に、2つのターゲットネットワークアドレスのクライアントIDトランキングをサポートする必要があります。さらに、サーバーは、同じメジャーサーバーオーナーID（セクション2.5）およびサーバースコープ（セクション2.10.4）を提示することにより、クライアントIDトランキングの追加のケースを許可する場合があります。 2つのサーバーが同じ主要サーバー所有者とサーバースコープを返す場合、2つのサーバーがロック状態の管理に協力していることを意味します。これは、クライアントIDトランキングの前提条件です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Distinguishing when the client is allowed to use session and client ID trunking requires understanding how the results of the EXCHANGE_ID (Section 18.35) operation identify a server. Suppose a client sends EXCHANGE_IDs over two different connections, each with a possibly different target network address, but each EXCHANGE_ID operation has the same value in the eia_clientowner field. If the same NFSv4.1 server is listening over each connection, then each EXCHANGE_ID result MUST return the same values of eir_clientid, eir_server_owner.so_major_id, and eir_server_scope. The client can then treat each connection as referring to the same server (subject to verification; see Section 2.10.5.1 later in this section), and it can use each connection to trunk requests and replies. The client&#39;s choice is whether session trunking or client ID trunking applies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがセッションとクライアントIDトランキングの使用を許可されている時期を区別するには、EXCHANGE_ID（セクション18.35）操作の結果がサーバーを識別する方法を理解する必要があります。クライアントが2つの異なる接続を介してEXCHANGE_IDを送信し、それぞれにターゲットネットワークアドレスが異なる可能性がありますが、各EXCHANGE_ID操作のeia_clientownerフィールドに同じ値があるとします。同じNFSv4.1サーバーが各接続をリッスンしている場合、各EXCHANGE_IDの結果は、eir_clientid、eir_server_owner.so_major_id、およびeir_server_scopeの同じ値を返す必要があります。その後、クライアントは各接続を同じサーバーを参照するものとして扱い（検証の対象。このセクションの後半のセクション2.10.5.1を参照）、各接続をトランクの要求と応答に使用できます。クライアントの選択は、セッショントランキングとクライアントIDトランキングのどちらを適用するかです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Session Trunking. If the eia_clientowner argument is the same in two different EXCHANGE_ID requests, and the eir_clientid, eir_server_owner.so_major_id, eir_server_owner.so_minor_id, and eir_server_scope results match in both EXCHANGE_ID results, then the client is permitted to perform session trunking. If the client has no session mapping to the tuple of eir_clientid, eir_server_owner.so_major_id, eir_server_scope, and eir_server_owner.so_minor_id, then it creates the session via a CREATE_SESSION operation over one of the connections, which associates the connection to the session. If there is a session for the tuple, the client can send BIND_CONN_TO_SESSION to associate the connection to the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
セッショントランキング。 2つの異なるEXCHANGE_IDリクエストでeia_clientowner引数が同じであり、eir_clientid、eir_server_owner.so_major_id、eir_server_owner.so_minor_id、およびeir_server_scopeの結果が両方のEXCHANGE_IDの結果で一致する場合、クライアントはセッショントランキングを実行できます。クライアントにeir_clientid、eir_server_owner.so_major_id、eir_server_scope、eir_server_owner.so_minor_idのタプルへのセッションマッピングがない場合、接続をセッションに関連付ける接続の1つを介してCREATE_SESSION操作を介してセッションを作成します。タプルのセッションがある場合、クライアントはBIND_CONN_TO_SESSIONを送信して、接続をセッションに関連付けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Of course, if the client does not desire to use session trunking, it is not required to do so. It can invoke CREATE_SESSION on the connection. This will result in client ID trunking as described below. It can also decide to drop the connection if it does not choose to use trunking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
もちろん、クライアントがセッショントランキングを使用したくない場合は、使用する必要はありません。接続でCREATE_SESSIONを呼び出すことができます。これにより、以下で説明するようにクライアントIDトランキングが発生します。また、トランキングを使用しない場合は、接続をドロップすることもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client ID Trunking. If the eia_clientowner argument is the same in two different EXCHANGE_ID requests, and the eir_clientid, eir_server_owner.so_major_id, and eir_server_scope results match in both EXCHANGE_ID results, then the client is permitted to perform client ID trunking (regardless of whether the eir_server_owner.so_minor_id results match). The client can associate each connection with different sessions, where each session is associated with the same server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントIDトランキング。 2つの異なるEXCHANGE_IDリクエストでeia_clientowner引数が同じであり、eir_clientid、eir_server_owner.so_major_id、およびeir_server_scopeの結果が両方のEXCHANGE_ID結果で一致する場合、クライアントは（eir_server_owner.so_minor_id結果が一致するかどうかに関係なく）クライアントIDトランキングを実行できます）。クライアントは、各接続を異なるセッションに関連付けることができます。各セッションは同じサーバーに関連付けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The client completes the act of client ID trunking by invoking CREATE_SESSION on each connection, using the same client ID that was returned in eir_clientid. These invocations create two sessions and also associate each connection with its respective session. The client is free to decline to use client ID trunking by simply dropping the connection at this point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントは、eir_clientidで返された同じクライアントIDを使用して、各接続でCREATE_SESSIONを呼び出すことにより、クライアントIDトランキングの動作を完了します。これらの呼び出しは2つのセッションを作成し、各接続をそれぞれのセッションに関連付けます。この時点で接続をドロップするだけで、クライアントは自由にクライアントIDトランキングの使用を拒否できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
When doing client ID trunking, locking state is shared across sessions associated with that same client ID. This requires the server to coordinate state across sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントIDトランキングを実行すると、同じクライアントIDに関連付けられているセッション間でロック状態が共有されます。これには、サーバーがセッション間で状態を調整する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client should be prepared for the possibility that eir_server_owner values may be different on subsequent EXCHANGE_ID requests made to the same network address, as a result of various sorts of reconfiguration events. When this happens and the changes result in the invalidation of previously valid forms of trunking, the client should cease to use those forms, either by dropping connections or by adding sessions. For a discussion of lock reclaim as it relates to such reconfiguration events, see Section 8.4.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、さまざまな種類の再構成イベントの結果として、同じネットワークアドレスに対して行われた後続のEXCHANGE_ID要求でeir_server_ownerの値が異なる可能性に備えて準備する必要があります。これが発生し、変更の結果として以前有効だったトランキングの形式が無効になった場合、クライアントは、接続をドロップするか、セッションを追加することにより、それらの形式の使用を中止する必要があります。このような再構成イベントに関連するロックの再利用については、8.4.2.1項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-5-1--Verifying-Claims-of-Matching-Server-Identity">
2.10.5.1. Verifying Claims of Matching Server Identity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.5.1. 一致するサーバーIDの主張の確認
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When two servers over two connections claim matching or partially matching eir_server_owner, eir_server_scope, and eir_clientid values, the client does not have to trust the servers&#39; claims. The client may verify these claims before trunking traffic in the following ways: o For session trunking, clients SHOULD reliably verify if connections between different network paths are in fact associated with the same NFSv4.1 server and usable on the same session, and servers MUST allow clients to perform reliable verification. When a client ID is created, the client SHOULD specify that BIND_CONN_TO_SESSION is to be verified according to the SP4_SSV or SP4_MACH_CRED (Section 18.35) state protection options. For SP4_SSV, reliable verification depends on a shared secret (the SSV) that is established via the SET_SSV (Section 18.47) operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2つの接続上の2つのサーバーがeir_server_owner、eir_server_scope、eir_clientidの値と一致または部分的に一致することを要求する場合、クライアントはサーバーの要求を信頼する必要はありません。クライアントは、以下の方法でトラフィックをトランキングする前にこれらのクレームを検証できます：oセッショントランキングの場合、クライアントは、異なるネットワークパス間の接続が実際に同じNFSv4.1サーバーに関連付けられており、同じセッションで使用できるかどうかを確実に検証する必要があり、サーバーはクライアントが信頼できる検証を実行できるようにします。クライアントIDが作成されると、クライアントは、SP4_SSVまたはSP4_MACH_CRED（セクション18.35）状態保護オプションに従ってBIND_CONN_TO_SESSIONを検証するように指定する必要があります（SHOULD）。 SP4_SSVの場合、信頼できる検証は、SET_SSV（セクション18.47）操作によって確立される共有シークレット（SSV）に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
When a new connection is associated with the session (via the BIND_CONN_TO_SESSION operation, see Section 18.34), if the client specified SP4_SSV state protection for the BIND_CONN_TO_SESSION operation, the client MUST send the BIND_CONN_TO_SESSION with RPCSEC_GSS protection, using integrity or privacy, and an RPCSEC_GSS handle created with the GSS SSV mechanism (Section 2.10.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
新しい接続がセッションに関連付けられている場合（BIND_CONN_TO_SESSION操作を介して、セクション18.34を参照）、クライアントがBIND_CONN_TO_SESSION操作に対してSP4_SSV状態保護を指定した場合、クライアントは整合性またはプライバシー、およびRPCSEC_GSSを使用して、RPCSEC_GSS保護付きのBIND_CONN_TO_SESSIONを送信する必要があります。 GSS SSVメカニズム（セクション2.10.9）で作成されたハンドル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the client mistakenly tries to associate a connection to a session of a wrong server, the server will either reject the attempt because it is not aware of the session identifier of the BIND_CONN_TO_SESSION arguments, or it will reject the attempt because the RPCSEC_GSS authentication fails. Even if the server mistakenly or maliciously accepts the connection association attempt, the RPCSEC_GSS verifier it computes in the response will not be verified by the client, so the client will know it cannot use the connection for trunking the specified session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントが誤って接続を間違ったサーバーのセッションに関連付けようとした場合、サーバーはBIND_CONN_TO_SESSION引数のセッション識別子を認識していないために試行を拒否するか、RPCSEC_GSS認証が失敗するために試行を拒否します。サーバーが接続アソシエーションの試みを誤ってまたは故意に受け入れたとしても、サーバーが応答で計算するRPCSEC_GSSベリファイアはクライアントによって検証されないため、クライアントは指定されたセッションのトランキングに接続を使用できないことを認識します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the client specified SP4_MACH_CRED state protection, the BIND_CONN_TO_SESSION operation will use RPCSEC_GSS integrity or privacy, using the same credential that was used when the client ID was created. Mutual authentication via RPCSEC_GSS assures the client that the connection is associated with the correct session of the correct server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントがSP4_MACH_CRED状態保護を指定した場合、BIND_CONN_TO_SESSION操作は、クライアントIDの作成時に使用されたのと同じ資格情報を使用して、RPCSEC_GSS整合性またはプライバシーを使用します。 RPCSEC_GSSによる相互認証は、接続が正しいサーバーの正しいセッションに関連付けられていることをクライアントに保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For client ID trunking, the client has at least two options for verifying that the same client ID obtained from two different EXCHANGE_ID operations came from the same server. The first option is to use RPCSEC_GSS authentication when sending each EXCHANGE_ID operation. Each time an EXCHANGE_ID is sent with RPCSEC_GSS authentication, the client notes the principal name of the GSS target. If the EXCHANGE_ID results indicate that client ID trunking is possible, and the GSS targets&#39; principal names are the same, the servers are the same and client ID trunking is allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントIDトランキングの場合、クライアントには、2つの異なるEXCHANGE_ID操作から取得された同じクライアントIDが同じサーバーからのものであることを確認するための少なくとも2つのオプションがあります。最初のオプションは、各EXCHANGE_ID操作を送信するときにRPCSEC_GSS認証を使用することです。 EXCHANGE_IDがRPCSEC_GSS認証で送信されるたびに、クライアントはGSSターゲットのプリンシパル名を記録します。 EXCHANGE_IDの結果がクライアントIDトランキングが可能であることを示し、GSSターゲットのプリンシパル名が同じである場合、サーバーは同じであり、クライアントIDトランキングは許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The second option for verification is to use SP4_SSV protection. When the client sends EXCHANGE_ID, it specifies SP4_SSV protection. The first EXCHANGE_ID the client sends always has to be confirmed by a CREATE_SESSION call. The client then sends SET_SSV. Later, the client sends EXCHANGE_ID to a second destination network address different from the one the first EXCHANGE_ID was sent to. The client checks that each EXCHANGE_ID reply has the same eir_clientid, eir_server_owner.so_major_id, and eir_server_scope. If so, the client verifies the claim by sending a CREATE_SESSION operation to the second destination address, protected with RPCSEC_GSS integrity using an RPCSEC_GSS handle returned by the second EXCHANGE_ID. If the server accepts the CREATE_SESSION request, and if the client verifies the RPCSEC_GSS verifier and integrity codes, then the client has proof the second server knows the SSV, and thus the two servers are cooperating for the purposes of specifying server scope and client ID trunking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
検証の2番目のオプションは、SP4_SSV保護を使用することです。クライアントがEXCHANGE_IDを送信するとき、クライアントはSP4_SSV保護を指定します。クライアントが常に送信する最初のEXCHANGE_IDは、CREATE_SESSION呼び出しで確認する必要があります。次に、クライアントはSET_SSVを送信します。その後、クライアントはEXCHANGE_IDを、最初のEXCHANGE_IDが送信されたアドレスとは異なる2番目の宛先ネットワークアドレスに送信します。クライアントは、各EXCHANGE_ID応答に同じeir_clientid、eir_server_owner.so_major_id、およびeir_server_scopeがあることを確認します。その場合、クライアントは、2番目のEXCHANGE_IDによって返されたRPCSEC_GSSハンドルを使用してRPCSEC_GSS整合性で保護された2番目の宛先アドレスにCREATE_SESSION操作を送信することにより、クレームを検証します。サーバーがCREATE_SESSIONリクエストを受け入れ、クライアントがRPCSEC_GSSベリファイアと整合性コードを検証する場合、クライアントは2番目のサーバーがSSVを認識していることを証明しているため、2つのサーバーはサーバースコープとクライアントIDトランキングを指定する目的で協力しています。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-6--Exactly-Once-Semantics">
2.10.6. Exactly Once Semantics
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.6. 正確に一度のセマンティクス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Via the session, NFSv4.1 offers exactly once semantics (EOS) for requests sent over a channel. EOS is supported on both the fore channel and backchannel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1は、セッションを介して、チャネルを介して送信された要求に対して正確に1回限りのセマンティクス（EOS）を提供します。 EOSは、フォアチャネルとバックチャネルの両方でサポートされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each COMPOUND or CB_COMPOUND request that is sent with a leading SEQUENCE or CB_SEQUENCE operation MUST be executed by the receiver exactly once. This requirement holds regardless of whether the request is sent with reply caching specified (see Section 2.10.6.1.3). The requirement holds even if the requester is sending the request over a session created between a pNFS data client and pNFS data server. To understand the rationale for this requirement, divide the requests into three classifications:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
先頭のSEQUENCEまたはCB_SEQUENCE操作で送信される各COMPOUNDまたはCB_COMPOUND要求は、受信者が1回だけ実行する必要があります。この要件は、要求が応答キャッシュを指定して送信されているかどうかに関係なく保持されます（2.10.6.1.3を参照）。要求者がpNFSデータクライアントとpNFSデータサーバー間で作成されたセッションを介して要求を送信している場合でも、要件は保持されます。この要件の根拠を理解するには、要求を3つの分類に分けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Non-idempotent requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 非べき等のリクエスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Idempotent modifying requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o べき等の変更要求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Idempotent non-modifying requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o べき等の非変更リクエスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example of a non-idempotent request is RENAME. Obviously, if a replier executes the same RENAME request twice, and the first execution succeeds, the re-execution will fail. If the replier returns the result from the re-execution, this result is incorrect. Therefore, EOS is required for non-idempotent requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
べき等でないリクエストの例はRENAMEです。明らかに、返信者が同じRENAME要求を2回実行し、最初の実行が成功した場合、再実行は失敗します。返信者が再実行の結果を返した場合、この結果は正しくありません。したがって、べき等でない要求にはEOSが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example of an idempotent modifying request is a COMPOUND request containing a WRITE operation. Repeated execution of the same WRITE has the same effect as execution of that WRITE a single time. Nevertheless, enforcing EOS for WRITEs and other idempotent modifying requests is necessary to avoid data corruption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
べき等変更要求の例は、WRITE操作を含むCOMPOUND要求です。同じWRITEを繰り返し実行すると、そのWRITEを1回実行するのと同じ効果があります。それでも、データの破損を回避するには、WRITEと他のべき等の変更要求にEOSを適用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suppose a client sends WRITE A to a noncompliant server that does not enforce EOS, and receives no response, perhaps due to a network partition. The client reconnects to the server and re-sends WRITE A. Now, the server has outstanding two instances of A. The server can be in a situation in which it executes and replies to the retry of A, while the first A is still waiting in the server&#39;s internal I/O system for some resource. Upon receiving the reply to the second attempt of WRITE A, the client believes its WRITE is done so it is free to send WRITE B, which overlaps the byte-range of A. When the original A is dispatched from the server&#39;s I/O system and executed (thus the second time A will have been written), then what has been written by B can be overwritten and thus corrupted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがEOSを適用しない非準拠サーバーにWRITE Aを送信し、おそらくネットワークパーティションが原因で応答を受信しないとします。クライアントはサーバーに再接続してWRITE Aを再送信します。これで、サーバーにはAの未解決の2つのインスタンスがあります。サーバーは、最初のAがまだ待機している間に、サーバーが実行されてAの再試行に応答する状況になる可能性があります。サーバーの内部I / Oシステムの一部のリソース。 WRITE Aの2回目の試行に対する応答を受信すると、クライアントはそのWRITEが完了したと信じているため、Aのバイト範囲と重複するWRITE Bを自由に送信できます。元のAがサーバーのI / Oシステムからディスパッチされるとき実行されると（Aが2回目に書き込まれるため）、Bによって書き込まれたものが上書きされ、破損する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example of an idempotent non-modifying request is a COMPOUND containing SEQUENCE, PUTFH, READLINK, and nothing else. The re-execution of such a request will not cause data corruption or produce an incorrect result. Nonetheless, to keep the implementation simple, the replier MUST enforce EOS for all requests, whether or not idempotent and non-modifying.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
べき等の非変更要求の例は、SEQUENCE、PUTFH、READLINKなどを含むCOMPOUNDです。このような要求を再実行しても、データが破損したり、誤った結果が生成されたりすることはありません。それにもかかわらず、実装を単純に保つために、リプライヤは、べき等で非変更であるかどうかに関係なく、すべての要求に対してEOSを実施する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that true and complete EOS is not possible unless the server persists the reply cache in stable storage, and unless the server is somehow implemented to never require a restart (indeed, if such a server exists, the distinction between a reply cache kept in stable storage versus one that is not is one without meaning). See Section 2.10.6.5 for a discussion of persistence in the reply cache. Regardless, even if the server does not persist the reply cache, EOS improves robustness and correctness over previous versions of NFS because the legacy duplicate request/reply caches were based on the ONC RPC transaction identifier (XID). Section 2.10.6.1 explains the shortcomings of the XID as a basis for a reply cache and describes how NFSv4.1 sessions improve upon the XID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが安定したストレージに応答キャッシュを永続化しない限り、そしてサーバーが何らかの方法で再起動を必要としないように実装されていない限り、真の完全なEOSは不可能であることに注意してくださいストレージとそうでないものは意味のないものです）。応答キャッシュでの永続性については、2.10.6.5項を参照してください。とにかく、サーバーが応答キャッシュを永続化しない場合でも、レガシーの重複する要求/応答キャッシュはONC RPCトランザクション識別子（XID）に基づいていたため、EOSは以前のバージョンのNFSよりも堅牢性と正確性を向上させます。セクション2.10.6.1では、応答キャッシュの基礎としてのXIDの欠点について説明し、NFSv4.1セッションがXIDをどのように改善するかについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-6-1--Slot-Identifiers-and-Reply-Cache">
2.10.6.1. Slot Identifiers and Reply Cache
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.6.1. スロット識別子と応答キャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The RPC layer provides a transaction ID (XID), which, while required to be unique, is not convenient for tracking requests for two reasons. First, the XID is only meaningful to the requester; it cannot be interpreted by the replier except to test for equality with previously sent requests. When consulting an RPC-based duplicate request cache, the opaqueness of the XID requires a computationally expensive look up (often via a hash that includes XID and source address). NFSv4.1 requests use a non-opaque slot ID, which is an index into a slot table, which is far more efficient. Second, because RPC requests can be executed by the replier in any order, there is no bound on the number of requests that may be outstanding at any time. To achieve perfect EOS, using ONC RPC would require storing all replies in the reply cache. XIDs are 32 bits; storing over four billion (2^32) replies in the reply cache is not practical. In practice, previous versions of NFS have chosen to store a fixed number of replies in the cache, and to use a least recently used (LRU) approach to replacing cache entries with new entries when the cache is full. In NFSv4.1, the number of outstanding requests is bounded by the size of the slot table, and a sequence ID per slot is used to tell the replier when it is safe to delete a cached reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
RPCレイヤーはトランザクションID（XID）を提供しますが、これは一意である必要がありますが、2つの理由で要求の追跡には適していません。まず、XIDはリクエスタにとってのみ意味があります。以前に送信されたリクエストと等しいかどうかをテストする場合を除いて、返信者が解釈することはできません。 RPCベースの重複リクエストキャッシュを参照する場合、XIDの不透明性により、計算に負荷のかかるルックアップが必要になります（多くの場合、XIDと送信元アドレスを含むハッシュを介して）。 NFSv4.1要求は、不透明ではないスロットIDを使用します。これはスロットテーブルへのインデックスであり、はるかに効率的です。第2に、RPC要求はリプライヤによって任意の順序で実行できるため、いつでも未解決の可能性がある要求の数に制限はありません。完全なEOSを実現するには、ONC RPCを使用するには、すべての応答を応答キャッシュに格納する必要があります。 XIDは32ビットです。 40億（2 ^ 32）を超える応答を応答キャッシュに格納することは現実的ではありません。実際には、NFSの以前のバージョンでは、固定数の応答をキャッシュに保存し、キャッシュがいっぱいになったときにキャッシュエントリを新しいエントリに置き換えるために、Leastly Used（LRU）アプローチを使用することを選択しました。 NFSv4.1では、未解決の要求の数はスロットテーブルのサイズによって制限され、スロットごとのシーケンスIDを使用して、キャッシュされた応答を安全に削除できる場合に応答者に通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the NFSv4.1 reply cache, when the requester sends a new request, it selects a slot ID in the range 0..N, where N is the replier&#39;s current maximum slot ID granted to the requester on the session over which the request is to be sent. The value of N starts out as equal to ca_maxrequests - 1 (Section 18.36), but can be adjusted by the response to SEQUENCE or CB_SEQUENCE as described later in this section. The slot ID must be unused by any of the requests that the requester has already active on the session. &#34;Unused&#34; here means the requester has no outstanding request for that slot ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1応答キャッシュでは、リクエスターが新しい要求を送信すると、0からNの範囲のスロットIDを選択します。ここで、Nは、要求が行われたセッションでリクエスターに付与されたリプライアの現在の最大スロットIDです。送信されます。 Nの値は、ca_maxrequests-1（セクション18.36）と同じですが、このセクションで後述するように、SEQUENCEまたはCB_SEQUENCEへの応答によって調整できます。スロットIDは、リクエスターがセッションですでにアクティブになっているすべての要求で未使用でなければなりません。ここで「未使用」とは、リクエスターがそのスロットIDに対して未解決のリクエストをしていないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A slot contains a sequence ID and the cached reply corresponding to the request sent with that sequence ID. The sequence ID is a 32-bit unsigned value, and is therefore in the range 0..0xFFFFFFFF (2^32 - 1). The first time a slot is used, the requester MUST specify a sequence ID of one (Section 18.36). Each time a slot is reused, the request MUST specify a sequence ID that is one greater than that of the previous request on the slot. If the previous sequence ID was 0xFFFFFFFF, then the next request for the slot MUST have the sequence ID set to zero (i.e., (2^32 - 1) + 1 mod 2^32).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スロットには、シーケンスIDと、そのシーケンスIDで送信された要求に対応するキャッシュされた応答が含まれます。シーケンスIDは32ビットの符号なしの値であるため、範囲は0..0xFFFFFFFF（2 ^ 32-1）です。スロットが初めて使用されるとき、リクエスタは1のシーケンスIDを指定する必要があります（セクション18.36）。スロットが再利用されるたびに、リクエストは、スロットでの前のリクエストのシーケンスIDよりも1つ大きいシーケンスIDを指定する必要があります。以前のシーケンスIDが0xFFFFFFFFの場合、スロットの次のリクエストではシーケンスIDをゼロに設定する必要があります（つまり、（2 ^ 32-1）+ 1 mod 2 ^ 32）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sequence ID accompanies the slot ID in each request. It is for the critical check at the replier: it used to efficiently determine whether a request using a certain slot ID is a retransmit or a new, never-before-seen request. It is not feasible for the requester to assert that it is retransmitting to implement this, because for any given request the requester cannot know whether the replier has seen it unless the replier actually replies. Of course, if the requester has seen the reply, the requester would not retransmit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンスIDは、各リクエストのスロットIDに付随しています。これは、返信者の重要なチェック用です。特定のスロットIDを使用するリクエストが再送信であるか、これまでにない新しいリクエストであるかを効率的に判断するために使用されていました。リクエスタが実際に返信しない限り、リクエスタはリプライアがそれを確認したかどうかを知ることができないため、リクエスタはこれを実装するために再送信していると断言することはできません。もちろん、リクエスタが返信を見た場合、リクエスタは再送信しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The replier compares each received request&#39;s sequence ID with the last one previously received for that slot ID, to see if the new request is: o A new request, in which the sequence ID is one greater than that previously seen in the slot (accounting for sequence wraparound). The replier proceeds to execute the new request, and the replier MUST increase the slot&#39;s sequence ID by one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
リプライヤは、受信した各リクエストのシーケンスIDをそのスロットIDについて以前に受信した最後のリクエストと比較して、新しいリクエストが次のいずれであるかを確認します。o新しいリクエスト。シーケンスラップアラウンド）。リプライヤは新しいリクエストの実行に進み、リプライヤはスロットのシーケンスIDを1だけ増やす必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A retransmitted request, in which the sequence ID is equal to that currently recorded in the slot. If the original request has executed to completion, the replier returns the cached reply. See Section 2.10.6.2 for direction on how the replier deals with retries of requests that are still in progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o シーケンスIDが現在スロットに記録されているものと等しい、再送信された要求。元のリクエストが完了するまで実行された場合、返信者はキャッシュされた返信を返します。応答者がまだ進行中の要求の再試行をどのように処理するかについては、セクション2.10.6.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A misordered retry, in which the sequence ID is less than (accounting for sequence wraparound) that previously seen in the slot. The replier MUST return NFS4ERR_SEQ_MISORDERED (as the result from SEQUENCE or CB_SEQUENCE).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o シーケンスIDが以前にスロットで見られたものよりも小さい（シーケンスラップアラウンドを考慮して）順序が間違っている再試行。リプライヤはNFS4ERR_SEQ_MISORDEREDを返さなければなりません（SEQUENCEまたはCB_SEQUENCEの結果として）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A misordered new request, in which the sequence ID is two or more than (accounting for sequence wraparound) that previously seen in the slot. Note that because the sequence ID MUST wrap around to zero once it reaches 0xFFFFFFFF, a misordered new request and a misordered retry cannot be distinguished. Thus, the replier MUST return NFS4ERR_SEQ_MISORDERED (as the result from SEQUENCE or CB_SEQUENCE).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o シーケンスIDが以前にスロットで見られたもの（シーケンスラップアラウンドを考慮したもの）の2以上である、誤った順序の新しいリクエスト。シーケンスIDは0xFFFFFFFFに到達するとゼロにラップアラウンドする必要があるため、順序が正しくない新しい要求と順序が間違っている再試行を区別できないことに注意してください。したがって、返信者はNFS4ERR_SEQ_MISORDEREDを（SEQUENCEまたはCB_SEQUENCEからの結果として）返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike the XID, the slot ID is always within a specific range; this has two implications. The first implication is that for a given session, the replier need only cache the results of a limited number of COMPOUND requests. The second implication derives from the first, which is that unlike XID-indexed reply caches (also known as duplicate request caches - DRCs), the slot ID-based reply cache cannot be overflowed. Through use of the sequence ID to identify retransmitted requests, the replier does not need to actually cache the request itself, reducing the storage requirements of the reply cache further. These facilities make it practical to maintain all the required entries for an effective reply cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XIDとは異なり、スロットIDは常に特定の範囲内にあります。これには2つの意味があります。最初の意味は、特定のセッションでは、リプライアは限られた数のCOMPOUNDリクエストの結果をキャッシュするだけでよいことです。 2番目の影響は1番目の影響から派生します。つまり、XIDインデックス付きの応答キャッシュ（重複要求キャッシュ-DRCとも呼ばれます）とは異なり、スロットIDベースの応答キャッシュはオーバーフローできません。シーケンスIDを使用して再送信された要求を識別することにより、応答者は実際に要求自体をキャッシュする必要がなくなり、応答キャッシュのストレージ要件をさらに削減できます。これらの機能により、効果的な応答キャッシュに必要なすべてのエントリを維持することが現実的になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The slot ID, sequence ID, and session ID therefore take over the traditional role of the XID and source network address in the replier&#39;s reply cache implementation. This approach is considerably more portable and completely robust -- it is not subject to the reassignment of ports as clients reconnect over IP networks. In addition, the RPC XID is not used in the reply cache, enhancing robustness of the cache in the face of any rapid reuse of XIDs by the requester. While the replier does not care about the XID for the purposes of reply cache management (but the replier MUST return the same XID that was in the request), nonetheless there are considerations for the XID in NFSv4.1 that are the same as all other previous versions of NFS. The RPC XID remains in each message and needs to be formulated in NFSv4.1 requests as in any other ONC RPC request. The reasons include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
したがって、スロットID、シーケンスID、およびセッションIDは、返信者の返信キャッシュ実装におけるXIDおよび送信元ネットワークアドレスの従来の役割を引き継ぎます。このアプローチは、移植性が非常に高く、完全に堅牢です。クライアントがIPネットワークを介して再接続するときに、ポートを再割り当てする必要はありません。さらに、RPC XIDは応答キャッシュで使用されないため、リクエスターによるXIDの迅速な再利用に直面してキャッシュの堅牢性が向上します。返信者は返信キャッシュ管理の目的でXIDを気にしません（ただし、返信者はリクエストに含まれていたものと同じXIDを返す必要があります）が、NFSv4.1のXIDには他のすべてと同じ考慮事項があります以前のバージョンのNFS。 RPC XIDは各メッセージに残り、他のONC RPC要求と同様にNFSv4.1要求で定式化する必要があります。理由は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The RPC layer retains its existing semantics and implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RPCレイヤーは、既存のセマンティクスと実装を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The requester and replier must be able to interoperate at the RPC layer, prior to the NFSv4.1 decoding of the SEQUENCE or CB_SEQUENCE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o リクエスタとリプライヤは、SEQUENCEまたはCB_SEQUENCE操作のNFSv4.1デコードの前に、RPCレイヤで相互運用できる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If an operation is being used that does not start with SEQUENCE or CB_SEQUENCE (e.g., BIND_CONN_TO_SESSION), then the RPC XID is needed for correct operation to match the reply to the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SEQUENCEまたはCB_SEQUENCEで始まらない操作（BIND_CONN_TO_SESSIONなど）が使用されている場合、RPC XIDは、正しい操作が要求への応答と一致するために必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The SEQUENCE or CB_SEQUENCE operation may generate an error. If so, the embedded slot ID, sequence ID, and session ID (if present) in the request will not be in the reply, and the requester has only the XID to match the reply to the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SEQUENCEまたはCB_SEQUENCE操作はエラーを生成する場合があります。その場合、要求に埋め込まれたスロットID、シーケンスID、およびセッションID（存在する場合）は応答に含まれず、要求者は要求への応答と一致するXIDしか持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given that well-formulated XIDs continue to be required, this begs the question: why do SEQUENCE and CB_SEQUENCE replies have a session ID, slot ID, and sequence ID? Having the session ID in the reply means that the requester does not have to use the XID to look up the session ID, which would be necessary if the connection were associated with multiple sessions. Having the slot ID and sequence ID in the reply means that the requester does not have to use the XID to look up the slot ID and sequence ID. Furthermore, since the XID is only 32 bits, it is too small to guarantee the re-association of a reply with its request [37]; having session ID, slot ID, and sequence ID in the reply allows the client to validate that the reply in fact belongs to the matched request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
適切に定式化されたXIDが引き続き必要であることを考えると、これは疑問を投げかけます。SEQUENCEおよびCB_SEQUENCE応答にセッションID、スロットID、およびシーケンスIDがある理由応答にセッションIDがあることは、リクエスターがセッションIDを検索するためにXIDを使用する必要がないことを意味します。これは、接続が複数のセッションに関連付けられている場合に必要です。応答にスロットIDとシーケンスIDがあることは、リクエスターがスロットIDとシーケンスIDを検索するためにXIDを使用する必要がないことを意味します。さらに、XIDは32ビットしかないため、小さすぎて応答と要求の再関連付けを保証できません[37]。応答にセッションID、スロットID、およびシーケンスIDを含めると、クライアントは、応答が実際に一致した要求に属していることを検証できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SEQUENCE (and CB_SEQUENCE) operation also carries a &#34;highest_slotid&#34; value, which carries additional requester slot usage information. The requester MUST always indicate the slot ID representing the outstanding request with the highest-numbered slot value. The requester should in all cases provide the most conservative value possible, although it can be increased somewhat above the actual instantaneous usage to maintain some minimum or optimal level. This provides a way for the requester to yield unused request slots back to the replier, which in turn can use the information to reallocate resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQUENCE（およびCB_SEQUENCE）操作は、 &#34;highest_slotid&#34;値も伝送します。この値は、追加のリクエスタースロットの使用情報を伝送します。リクエスターは常に、最も大きい番号のスロット値を持つ未解決の要求を表すスロットIDを示さなければなりません（MUST）。リクエスタは、可能な限り最も保守的な値を提供する必要がありますが、実際の瞬間的な使用量よりもいくらか増やして、最小または最適なレベルを維持することができます。これは、リクエスタが未使用のリクエストスロットをリプライヤに返す方法を提供します。リプライヤは、情報を使用してリソースを再割り当てできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The replier responds with both a new target highest_slotid and an enforced highest_slotid, described as follows: o The target highest_slotid is an indication to the requester of the highest_slotid the replier wishes the requester to be using. This permits the replier to withdraw (or add) resources from a requester that has been found to not be using them, in order to more fairly share resources among a varying level of demand from other requesters. The requester must always comply with the replier&#39;s value updates, since they indicate newly established hard limits on the requester&#39;s access to session resources. However, because of request pipelining, the requester may have active requests in flight reflecting prior values; therefore, the replier must not immediately require the requester to comply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
リプライアは、新しいターゲットのhighest_slotidと強制されたhighest_slotidの両方で応答します。以下に説明します。oターゲットのhighest_slotidは、リクエスタがリクエスタで使用することを望んでいるhighest_slotidをリクエスタに示します。これにより、他のリクエスタからのさまざまなレベルの要求間でリソースをより公平に共有するために、リプライアはリソースを使用していないことが判明したリクエスタからリソースを撤回（または追加）できます。リクエスタはセッションリソースへのリクエスタのアクセスに対して新しく確立されたハード制限を示すため、リクエスタは常にリプライヤの値の更新に準拠する必要があります。ただし、リクエストのパイプライン処理により、リクエスタは以前の値を反映したアクティブなリクエストを処理中の場合があります。したがって、リプライヤは要求者にすぐに準拠することを要求してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The enforced highest_slotid indicates the highest slot ID the requester is permitted to use on a subsequent SEQUENCE or CB_SEQUENCE operation. The replier&#39;s enforced highest_slotid SHOULD be no less than the highest_slotid the requester indicated in the SEQUENCE or CB_SEQUENCE arguments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 実施されるhighest_slotidは、リクエスターが後続のSEQUENCEまたはCB_SEQUENCE操作で使用することを許可されている最高のスロットIDを示します。リプライヤの実施されるhighest_slotidは、SEQUENCEまたはCB_SEQUENCE引数で要求者が示したhighest_slotid以上である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A requester can be intransigent with respect to lowering its highest_slotid argument to a Sequence operation, i.e. the requester continues to ignore the target highest_slotid in the response to a Sequence operation, and continues to set its highest_slotid argument to be higher than the target highest_slotid. This can be considered particularly egregious behavior when the replier knows there are no outstanding requests with slot IDs higher than its target highest_slotid. When faced with such intransigence, the replier is free to take more forceful action, and MAY reply with a new enforced highest_slotid that is less than its previous enforced highest_slotid. Thereafter, if the requester continues to send requests with a highest_slotid that is greater than the replier&#39;s new enforced highest_slotid, the server MAY return NFS4ERR_BAD_HIGH_SLOT, unless the slot ID in the request is greater than the new enforced highest_slotid and the request is a retry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
リクエスタは、sequenceオペレーションへのmaximum_slotid引数の引き下げに関して非透過的である可能性があります。つまり、リクエスタは、Sequenceオペレーションへの応答でターゲットのhighest_slotidを無視し続け、highest_slotid引数をターゲットのhighest_slotidより高く設定し続けます。これは、ターゲットのhighest_slotidよりも大きいスロットIDを持つ未解決のリクエストがないことをリプライアが知っている場合、特に悪質な動作と見なすことができます。そのような非透過性に直面した場合、リプライヤはより強力なアクションを自由にとることができ、以前の強制されたhighest_slotidより小さい新しい強制されたhighest_slotidで応答するかもしれません。その後、リクエスタがリプライアの新しい強制されたhighest_slotidより大きいhighest_slotidでリクエストを送信し続ける場合、リクエスト内のスロットIDが新しく適用されたhighest_slotidより大きく、リクエストが再試行でない限り、サーバーはNFS4ERR_BAD_HIGH_SLOTを返すかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The replier SHOULD retain the slots it wants to retire until the requester sends a request with a highest_slotid less than or equal to the replier&#39;s new enforced highest_slotid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
リプライアは、リクエスタがリプライヤの新しい強制されたhighest_slotid以下のhighest_slotidでリクエストを送信するまで、リタイアしたいスロットを保持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The requester can also be intransigent with respect to sending non-retry requests that have a slot ID that exceeds the replier&#39;s highest_slotid. Once the replier has forcibly lowered the enforced highest_slotid, the requester is only allowed to send retries on slots that exceed the replier&#39;s highest_slotid. If a request is received with a slot ID that is higher than the new enforced highest_slotid, and the sequence ID is one higher than what is in the slot&#39;s reply cache, then the server can both retire the slot and return NFS4ERR_BADSLOT (however, the server MUST NOT do one and not the other). The reason it is safe to retire the slot is because by using the next sequence ID, the requester is indicating it has received the previous reply for the slot.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
リクエスタは、リプライヤのhighest_slotidを超えるスロットIDを持つ非再試行リクエストの送信に関して非透過的である場合もあります。リプライアが強制されたhighest_slotidを強制的に下げたら、リクエスタはリプライアのhighest_slotidを超えるスロットでのみ再試行を送信できます。新しい強制されたhighest_slotidよりも大きいスロットIDでリクエストが受信され、シーケンスIDがスロットの応答キャッシュにあるものよりも1つ大きい場合、サーバーはスロットをリタイアし、NFS4ERR_BADSLOTを返すことができます（ただし、サーバーどちらか一方を実行してはなりません）。スロットをリタイアしても安全な理由は、次のシーケンスIDを使用することにより、リクエスタがスロットに対する以前の応答を受信したことを示しているためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The requester SHOULD use the lowest available slot when sending a new request. This way, the replier may be able to retire slot entries faster. However, where the replier is actively adjusting its granted highest_slotid, it will not be able to use only the receipt of the slot ID and highest_slotid in the request. Neither the slot ID nor the highest_slotid used in a request may reflect the replier&#39;s current idea of the requester&#39;s session limit, because the request may have been sent from the requester before the update was received. Therefore, in the downward adjustment case, the replier may have to retain a number of reply cache entries at least as large as the old value of maximum requests outstanding, until it can infer that the requester has seen a reply containing the new granted highest_slotid. The replier can infer that the requester has seen such a reply when it receives a new request with the same slot ID as the request replied to and the next higher sequence ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o リクエスタは、新しいリクエストを送信するときに、利用可能な最小のスロットを使用する必要があります（SHOULD）。このように、返信者はスロットエントリをより早くリタイアできる場合があります。ただし、リプライアが許可されたhighest_slotidをアクティブに調整している場合、リクエストでスロットIDとhighest_slotidの受信のみを使用することはできません。リクエストで使用されたスロットIDも、highest_slotidも、リクエスタのセッション制限に関するリプライアの現在の考えを反映していない可能性があります。更新が受信される前にリクエスタからリクエストが送信された可能性があるためです。したがって、下方調整の場合、リプライアは、リクエスタが新しく付与されたhighest_slotidを含む応答を確認できるまで、少なくとも未処理の最大リクエスト数の古い値と同じ数のリプライキャッシュエントリを保持する必要があります。リプライアは、リクエスタが応答したのと同じスロットIDと次に高いシーケンスIDを持つ新しいリクエストを受信したときに、リクエスタがそのような応答を見たことを推測できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-6-1-1--Caching-of-SEQUENCE-and-CBSEQUENCE-Replies">
2.10.6.1.1. Caching of SEQUENCE and CB_SEQUENCE Replies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.6.1.1. SEQUENCEおよびCB_SEQUENCE応答のキャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a SEQUENCE or CB_SEQUENCE operation is successfully executed, its reply MUST always be cached. Specifically, session ID, sequence ID, and slot ID MUST be cached in the reply cache. The reply from SEQUENCE also includes the highest slot ID, target highest slot ID, and status flags. Instead of caching these values, the server MAY re-compute the values from the current state of the fore channel, session, and/or client ID as appropriate. Similarly, the reply from CB_SEQUENCE includes a highest slot ID and target highest slot ID. The client MAY re-compute the values from the current state of the session as appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQUENCEまたはCB_SEQUENCE操作が正常に実行された場合、その応答は常にキャッシュされる必要があります。具体的には、セッションID、シーケンスID、およびスロットIDを応答キャッシュにキャッシュする必要があります。 SEQUENCEからの応答には、最大のスロットID、ターゲットの最大のスロットID、およびステータスフラグも含まれます。これらの値をキャッシュする代わりに、サーバーは、必要に応じて、フォアチャネル、セッション、クライアントIDの現在の状態から値を再計算できます（MAY）。同様に、CB_SEQUENCEからの応答には、最高のスロットIDとターゲットの最高のスロットIDが含まれます。クライアントは、必要に応じてセッションの現在の状態から値を再計算できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of whether or not a replier is re-computing highest slot ID, target slot ID, and status on replies to retries, the requester MUST NOT assume that the values are being re-computed whenever it receives a reply after a retry is sent, since it has no way of knowing whether the reply it has received was sent by the replier in response to the retry or is a delayed response to the original request. Therefore, it may be the case that highest slot ID, target slot ID, or status bits may reflect the state of affairs when the request was first executed. Although acting based on such delayed information is valid, it may cause the receiver of the reply to do unneeded work. Requesters MAY choose to send additional requests to get the current state of affairs or use the state of affairs reported by subsequent requests, in preference to acting immediately on data that might be out of date.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リプライヤが最高のスロットID、ターゲットスロットID、および再試行に対する返信のステータスを再計算しているかどうかに関係なく、リクエスタは、再試行が送信された後に応答を受信するたびに値が再計算されていると想定してはなりません。これは、受け取った応答が再試行に応答して応答者によって送信されたものか、元の要求に対する遅延応答かを知る方法がないためです。したがって、リクエストが最初に実行されたときの最大のスロットID、ターゲットスロットID、またはステータスビットが状況を反映している場合があります。このような遅延した情報に基づいて行動することは有効ですが、応答の受信者が不要な作業を行う可能性があります。要求者は、最新の状況を取得するために追加の要求を送信するか、または古くなっている可能性のあるデータにすぐに対処するよりも、後続の要求によって報告された状況を使用することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-6-1-2--Errors-from-SEQUENCE-and-CBSEQUENCE">
2.10.6.1.2. Errors from SEQUENCE and CB_SEQUENCE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.6.1.2. SEQUENCEおよびCB_SEQUENCEからのエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any time SEQUENCE or CB_SEQUENCE returns an error, the sequence ID of the slot MUST NOT change. The replier MUST NOT modify the reply cache entry for the slot whenever an error is returned from SEQUENCE or CB_SEQUENCE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQUENCEまたはCB_SEQUENCEがエラーを返すときは常に、スロットのシーケンスIDを変更してはなりません（MUST NOT）。 SEQUENCEまたはCB_SEQUENCEからエラーが返された場合、リプライヤはスロットの応答キャッシュエントリを変更してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-6-1-3--Optional-Reply-Caching">
2.10.6.1.3. Optional Reply Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.6.1.3. オプションの返信キャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On a per-request basis, the requester can choose to direct the replier to cache the reply to all operations after the first operation (SEQUENCE or CB_SEQUENCE) via the sa_cachethis or csa_cachethis fields of the arguments to SEQUENCE or CB_SEQUENCE. The reason it would not direct the replier to cache the entire reply is that the request is composed of all idempotent operations [34]. Caching the reply may offer little benefit. If the reply is too large (see Section 2.10.6.4), it may not be cacheable anyway. Even if the reply to idempotent request is small enough to cache, unnecessarily caching the reply slows down the server and increases RPC latency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求ごとに、リクエスタは、SEQUENCEまたはCB_SEQUENCEへの引数のsa_cachethisまたはcsa_cachethisフィールドを介して、最初の操作（SEQUENCEまたはCB_SEQUENCE）の後のすべての操作に対する応答をキャッシュするようにリプライアに指示することを選択できます。返信者に返信全体をキャッシュするように指示しない理由は、要求がすべてのべき等演算で構成されているためです[34]。返信をキャッシュしてもほとんどメリットはありません。応答が大きすぎる場合（セクション2.10.6.4を参照）、とにかくキャッシュできない可能性があります。べき等要求への応答がキャッシュするのに十分小さい場合でも、応答を不必要にキャッシュすると、サーバーの速度が低下し、RPCレイテンシが増加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whether or not the requester requests the reply to be cached has no effect on the slot processing. If the results of SEQUENCE or CB_SEQUENCE are NFS4_OK, then the slot&#39;s sequence ID MUST be incremented by one. If a requester does not direct the replier to cache the reply, the replier MUST do one of following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスタが応答のキャッシュを要求するかどうかは、スロット処理には影響しません。 SEQUENCEまたはCB_SEQUENCEの結果がNFS4_OKの場合、スロットのシーケンスIDは1ずつ増加する必要があります。リクエスタが返信をキャッシュするように返信者に指示しない場合、返信者は次のいずれかを実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The replier can cache the entire original reply. Even though sa_cachethis or csa_cachethis is FALSE, the replier is always free to cache. It may choose this approach in order to simplify implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 返信者は元の返信全体をキャッシュできます。 sa_cachethisまたはcsa_cachethisがFALSEであっても、リプライヤは常に自由にキャッシュできます。実装を簡素化するために、このアプローチを選択する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The replier enters into its reply cache a reply consisting of the original results to the SEQUENCE or CB_SEQUENCE operation, and with the next operation in COMPOUND or CB_COMPOUND having the error NFS4ERR_RETRY_UNCACHED_REP. Thus, if the requester later retries the request, it will get NFS4ERR_RETRY_UNCACHED_REP. If a replier receives a retried Sequence operation where the reply to the COMPOUND or CB_COMPOUND was not cached, then the replier,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 返信者は、SEQUENCEまたはCB_SEQUENCE操作に対する元の結果からなる返信を返信キャッシュに入力し、COMPOUNDまたはCB_COMPOUNDの次の操作でエラーNFS4ERR_RETRY_UNCACHED_REPが発生します。したがって、リクエスターが後で要求を再試行すると、NFS4ERR_RETRY_UNCACHED_REPが取得されます。返信者がCOMPOUNDまたはCB_COMPOUNDへの返信がキャッシュされていない再試行されたシーケンス操作を受け取った場合、返信者は、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* MAY return NFS4ERR_RETRY_UNCACHED_REP in reply to a Sequence operation if the Sequence operation is not the first operation (granted, a requester that does so is in violation of the NFSv4.1 protocol).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* シーケンス操作が最初の操作ではない場合、シーケンス操作への応答としてNFS4ERR_RETRY_UNCACHED_REPを返す場合があります（許可されている場合、リクエスターはNFSv4.1プロトコルに違反しています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* MUST NOT return NFS4ERR_RETRY_UNCACHED_REP in reply to a Sequence operation if the Sequence operation is the first operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* シーケンス操作が最初の操作である場合、シーケンス操作への応答としてNFS4ERR_RETRY_UNCACHED_REPを返してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the second operation is an illegal operation, or an operation that was legal in a previous minor version of NFSv4 and MUST NOT be supported in the current minor version (e.g., SETCLIENTID), the replier MUST NOT ever return NFS4ERR_RETRY_UNCACHED_REP. Instead the replier MUST return NFS4ERR_OP_ILLEGAL or NFS4ERR_BADXDR or NFS4ERR_NOTSUPP as appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2番目の操作が不正な操作である場合、またはNFSv4の以前のマイナーバージョンで合法であり、現在のマイナーバージョン（たとえば、SETCLIENTID）でサポートされてはならない操作の場合、返信者はNFS4ERR_RETRY_UNCACHED_REPを返してはなりません。代わりに、返信者はNFS4ERR_OP_ILLEGALまたはNFS4ERR_BADXDRまたはNFS4ERR_NOTSUPPを必要に応じて返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the second operation can result in another error status, the replier MAY return a status other than NFS4ERR_RETRY_UNCACHED_REP, provided the operation is not executed in such a way that the state of the replier is changed. Examples of such an error status include: NFS4ERR_NOTSUPP returned for an operation that is legal but not REQUIRED in the current minor versions, and thus not supported by the replier; NFS4ERR_SEQUENCE_POS; and NFS4ERR_REQ_TOO_BIG.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2番目の操作で別のエラーステータスが発生する可能性がある場合、リプライアの状態が変更されるような方法で操作が実行されない限り、リプライアはNFS4ERR_RETRY_UNCACHED_REP以外のステータスを返す可能性があります。このようなエラーステータスの例は次のとおりです。NFS4ERR_NOTSUPPは、現在のマイナーバージョンでは正当であるが必須ではない操作に対して返されたため、返信者によってサポートされていません。 NFS4ERR_SEQUENCE_POS;およびNFS4ERR_REQ_TOO_BIG。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The discussion above assumes that the retried request matches the original one. Section 2.10.6.1.3.1 discusses what the replier might do, and MUST do when original and retried requests do not match. Since the replier may only cache a small amount of the information that would be required to determine whether this is a case of a false retry, the replier may send to the client any of the following responses:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の説明では、再試行されたリクエストが元のリクエストと一致することを前提としています。セクション2.10.6.1.3.1は、返信者が何をすべきかを説明し、元のリクエストと再試行されたリクエストが一致しない場合は必ず実行する必要があります。リプライヤは、これが誤った再試行のケースであるかどうかを判断するために必要な少量の情報しかキャッシュしない場合があるため、クライアントに次の応答のいずれかを送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The cached reply to the original request (if the replier has cached it in its entirety and the users of the original request and retry match).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 元の要求に対するキャッシュされた応答（応答者が全体をキャッシュし、元の要求のユーザーと再試行が一致した場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A reply that consists only of the Sequence operation with the error NFS4ERR_FALSE_RETRY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o エラーNFS4ERR_FALSE_RETRYを持つシーケンス操作のみで構成される応答。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A reply consisting of the response to Sequence with the status NFS4_OK, together with the second operation as it appeared in the retried request with an error of NFS4ERR_RETRY_UNCACHED_REP or other error as described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ステータスがNFS4_OKのシーケンスへの応答と、NFS4ERR_RETRY_UNCACHED_REPのエラーまたは上記のその他のエラーで再試行された要求に表示された2番目の操作からなる応答。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A reply that consists of the response to Sequence with the status NFS4_OK, together with the second operation as it appeared in the original request with an error of NFS4ERR_RETRY_UNCACHED_REP or other error as described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ステータスがNFS4_OKのSequenceへの応答と、NFS4ERR_RETRY_UNCACHED_REPのエラーまたは上記のその他のエラーを含む元の要求に表示された2番目の操作からなる応答。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-6-1-3-1--False-Retry">
2.10.6.1.3.1. False Retry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.6.1.3.1. 誤った再試行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If a requester sent a Sequence operation with a slot ID and sequence ID that are in the reply cache but the replier detected that the retried request is not the same as the original request, including a retry that has different operations or different arguments in the operations from the original and a retry that uses a different principal in the RPC request&#39;s credential field that translates to a different user, then this is a false retry. When the replier detects a false retry, it is permitted (but not always obligated) to return NFS4ERR_FALSE_RETRY in response to the Sequence operation when it detects a false retry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
リクエスタが応答キャッシュにあるスロットIDとシーケンスIDのシーケンスオペレーションを送信したが、リプライヤが、再試行されたリクエストが元のリクエストと同じではないことを検出した場合（オペレーションに異なるオペレーションまたは異なる引数を持つリトライを含む）オリジナルと、別のユーザーに変換されるRPCリクエストの認証情報フィールドで別のプリンシパルを使用する再試行から、これは誤った再試行になります。リプライヤが誤った再試行を検出した場合、それが誤った再試行を検出したときに、シーケンス操作に応答してNFS4ERR_FALSE_RETRYを返すことが許可されます（ただし、常に義務付けられているわけではありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Translations of particularly privileged user values to other users due to the lack of appropriately secure credentials, as configured on the replier, should be applied before determining whether the users are the same or different. If the replier determines the users are different between the original request and a retry, then the replier MUST return NFS4ERR_FALSE_RETRY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーが同じか異なるかを判断する前に、リプライヤで構成されているように、適切に保護された資格情報がないために特に特権のあるユーザーの値を他のユーザーに翻訳する必要があります。ユーザーが元の要求と再試行の間で異なると応答者が判断した場合、応答者はNFS4ERR_FALSE_RETRYを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an operation of the retry is an illegal operation, or an operation that was legal in a previous minor version of NFSv4 and MUST NOT be supported in the current minor version (e.g., SETCLIENTID), the replier MAY return NFS4ERR_FALSE_RETRY (and MUST do so if the users of the original request and retry differ). Otherwise, the replier MAY return NFS4ERR_OP_ILLEGAL or NFS4ERR_BADXDR or NFS4ERR_NOTSUPP as appropriate. Note that the handling is in contrast for how the replier deals with retries requests with no cached reply. The difference is due to NFS4ERR_FALSE_RETRY being a valid error for only Sequence operations, whereas NFS4ERR_RETRY_UNCACHED_REP is a valid error for all operations except illegal operations and operations that MUST NOT be supported in the current minor version of NFSv4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再試行の操作が不正な操作であるか、NFSv4の以前のマイナーバージョンで合法であり、現在のマイナーバージョン（たとえば、SETCLIENTID）でサポートされてはならない操作である場合、リプライアはNFS4ERR_FALSE_RETRYを返すことができます（そうする必要があります）元のリクエストと再試行のユーザーが異なる場合）。それ以外の場合、リプライアはNFS4ERR_OP_ILLEGALまたはNFS4ERR_BADXDRまたはNFS4ERR_NOTSUPPを必要に応じて返します。この処理は、リプライヤがキャッシュされた応答なしで再試行要求を処理する方法と対照的であることに注意してください。 NFS4ERR_RETRY_UNCACHED_REPは、NFSv4の現在のマイナーバージョンでサポートされてはならない不正な操作と操作を除くすべての操作で有効なエラーですが、NFS4ERR_FALSE_RETRYはシーケンス操作でのみ有効なエラーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-6-2--Retry-and-Replay-of-Reply">
2.10.6.2. Retry and Replay of Reply
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.6.2. 返信の再試行と再生
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A requester MUST NOT retry a request, unless the connection it used to send the request disconnects. The requester can then reconnect and re-send the request, or it can re-send the request over a different connection that is associated with the same session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスタは、リクエストの送信に使用した接続が切断されない限り、リクエストを再試行してはなりません（MUST NOT）。その後、リクエスタは再接続してリクエストを再送信するか、同じセッションに関連付けられている別の接続を介してリクエストを再送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the requester is a server wanting to re-send a callback operation over the backchannel of a session, the requester of course cannot reconnect because only the client can associate connections with the backchannel. The server can re-send the request over another connection that is bound to the same session&#39;s backchannel. If there is no such connection, the server MUST indicate that the session has no backchannel by setting the SEQ4_STATUS_CB_PATH_DOWN_SESSION flag bit in the response to the next SEQUENCE operation from the client. The client MUST then associate a connection with the session (or destroy the session).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスタがセッションのバックチャネルを介してコールバック操作を再送信したいサーバーである場合、クライアントのみがバックチャネルに接続を関連付けることができるため、リクエスタはもちろん再接続できません。サーバーは、同じセッションのバックチャネルにバインドされている別の接続を介して要求を再送信できます。そのような接続がない場合、サーバーは、クライアントからの次のSEQUENCE操作への応答でSEQ4_STATUS_CB_PATH_DOWN_SESSIONフラグビットを設定して、セッションにバックチャネルがないことを示さなければなりません（MUST）。次に、クライアントは接続をセッションに関連付ける（またはセッションを破棄する）必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Note that it is not fatal for a requester to retry without a disconnect between the request and retry. However, the retry does consume resources, especially with RDMA, where each request, retry or not, consumes a credit. Retries for no reason, especially retries sent shortly after the previous attempt, are a poor use of network bandwidth and defeat the purpose of a transport&#39;s inherent congestion control system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
リクエスタが接続を切断せずに再試行しても致命的ではないことに注意してください。ただし、再試行はリソースを消費します。特にRDMAでは、再試行の有無にかかわらず、各要求がクレジットを消費します。理由のない再試行、特に前回の試行の直後に送信された再試行は、ネットワーク帯域幅の不適切な使用であり、トランスポート固有の輻輳制御システムの目的を無効にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A requester MUST wait for a reply to a request before using the slot for another request. If it does not wait for a reply, then the requester does not know what sequence ID to use for the slot on its next request. For example, suppose a requester sends a request with sequence ID 1, and does not wait for the response. The next time it uses the slot, it sends the new request with sequence ID 2. If the replier has not seen the request with sequence ID 1, then the replier is not expecting sequence ID 2, and rejects the requester&#39;s new request with NFS4ERR_SEQ_MISORDERED (as the result from SEQUENCE or CB_SEQUENCE).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスタは、別のリクエストにスロットを使用する前に、リクエストへの応答を待つ必要があります。応答を待たない場合、リクエスタは次のリクエストでスロットに使用するシーケンスIDを知りません。たとえば、リクエスタがシーケンスID 1のリクエストを送信し、応答を待たないとします。次にスロットを使用するときに、シーケンスID 2の新しいリクエストを送信します。返信者がシーケンスID 1のリクエストを確認していない場合、返信者はシーケンスID 2を予期しておらず、NFS4ERR_SEQ_MISORDERED（ SEQUENCEまたはCB_SEQUENCEの結果として）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RDMA fabrics do not guarantee that the memory handles (Steering Tags) within each RPC/RDMA &#34;chunk&#34; [8] are valid on a scope outside that of a single connection. Therefore, handles used by the direct operations become invalid after connection loss. The server must ensure that any RDMA operations that must be replayed from the reply cache use the newly provided handle(s) from the most recent request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RDMAファブリックは、各RPC / RDMA &#34;チャンク&#34; [8]内のメモリハンドル（ステアリングタグ）が単一接続のスコープ外のスコープで有効であることを保証しません。したがって、直接操作で使用されるハンドルは、接続が失われた後に無効になります。サーバーは、応答キャッシュから再生する必要のあるすべてのRDMA操作が、最新の要求から新しく提供されたハンドルを使用することを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A retry might be sent while the original request is still in progress on the replier. The replier SHOULD deal with the issue by returning NFS4ERR_DELAY as the reply to SEQUENCE or CB_SEQUENCE operation, but implementations MAY return NFS4ERR_MISORDERED. Since errors from SEQUENCE and CB_SEQUENCE are never recorded in the reply cache, this approach allows the results of the execution of the original request to be properly recorded in the reply cache (assuming that the requester specified the reply to be cached).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
元の要求がリプライアでまだ進行中に、再試行が送信される場合があります。リプライヤは、SEQUENCEまたはCB_SEQUENCE操作への応答としてNFS4ERR_DELAYを返すことで問題に対処する必要がありますが、実装はNFS4ERR_MISORDEREDを返す場合があります。 SEQUENCEおよびCB_SEQUENCEからのエラーが応答キャッシュに記録されることはないため、このアプローチにより、元の要求の実行結果を応答キャッシュに適切に記録できます（要求者が応答をキャッシュするように指定したと想定）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-6-3--Resolving-Server-Callback-Races">
2.10.6.3. Resolving Server Callback Races
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.6.3. サーバーコールバックレースの解決
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible for server callbacks to arrive at the client before the reply from related fore channel operations. For example, a client may have been granted a delegation to a file it has opened, but the reply to the OPEN (informing the client of the granting of the delegation) may be delayed in the network. If a conflicting operation arrives at the server, it will recall the delegation using the backchannel, which may be on a different transport connection, perhaps even a different network, or even a different session associated with the same client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関連するフォアチャネル操作からの応答の前に、サーバーコールバックがクライアントに到着する可能性があります。たとえば、クライアントは開いたファイルへの委任を許可されていても、OPENへの応答（クライアントに委任の許可を通知する）がネットワークで遅延する場合があります。競合する操作がサーバーに到着すると、バックチャネルを使用して委任が呼び戻されます。これは、異なるトランスポート接続、異なるネットワーク、または同じクライアントIDに関連付けられた異なるセッションにある場合もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The presence of a session between the client and server alleviates this issue. When a session is in place, each client request is uniquely identified by its { session ID, slot ID, sequence ID } triple. By the rules under which slot entries (reply cache entries) are retired, the server has knowledge whether the client has &#34;seen&#34; each of the server&#39;s replies. The server can therefore provide sufficient information to the client to allow it to disambiguate between an erroneous or conflicting callback race condition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントとサーバー間のセッションの存在は、この問題を軽減します。セッションが確立されている場合、各クライアント要求は、その{セッションID、スロットID、シーケンスID}トリプルによって一意に識別されます。スロットエントリ（応答キャッシュエントリ）を廃止するルールにより、サーバーは、クライアントが各サーバーの応答を &#34;確認&#34;したかどうかを認識します。したがって、サーバーはクライアントに十分な情報を提供して、誤ったまたは競合するコールバックの競合状態を明確にすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each client operation that might result in some sort of server callback, the server SHOULD &#34;remember&#34; the { session ID, slot ID, sequence ID } triple of the client request until the slot ID retirement rules allow the server to determine that the client has, in fact, seen the server&#39;s reply. Until the time the { session ID, slot ID, sequence ID } request triple can be retired, any recalls of the associated object MUST carry an array of these referring identifiers (in the CB_SEQUENCE operation&#39;s arguments), for the benefit of the client. After this time, it is not necessary for the server to provide this information in related callbacks, since it is certain that a race condition can no longer occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何らかのサーバーコールバックが発生する可能性のあるクライアント操作ごとに、サーバーは、スロットIDの廃止ルールによってサーバーがクライアントを決定できるようになるまで、クライアントリクエストの{セッションID、スロットID、シーケンスID}の3倍を「記憶」する必要があります（SHOULD）。実際には、サーバーの応答を見てきました。 {セッションID、スロットID、シーケンスID}のリクエストトリプルが廃止されるまで、関連オブジェクトのリコールは、クライアントの利益のために、これらの参照識別子の配列（CB_SEQUENCE操作の引数内）を運ぶ必要があります。この後は、サーバーがこの情報を関連するコールバックで提供する必要はありません。これは、競合状態が発生しなくなることが確実であるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_SEQUENCE operation that begins each server callback carries a list of &#34;referring&#34; { session ID, slot ID, sequence ID } triples. If the client finds the request corresponding to the referring session ID, slot ID, and sequence ID to be currently outstanding (i.e., the server&#39;s reply has not been seen by the client), it can determine that the callback has raced the reply, and act accordingly. If the client does not find the request corresponding to the referring triple to be outstanding (including the case of a session ID referring to a destroyed session), then there is no race with respect to this triple. The server SHOULD limit the referring triples to requests that refer to just those that apply to the objects referred to in the CB_COMPOUND procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各サーバーのコールバックを開始するCB_SEQUENCEオペレーションは、「参照」{セッションID、スロットID、シーケンスID}トリプルのリストを伝達します。クライアントは、参照セッションID、スロットID、およびシーケンスIDに対応する要求が現在未解決である（つまり、サーバーの応答がクライアントに表示されていない）場合、コールバックが応答を競合したと判断できます。それに応じて行動します。クライアントが、参照しているトリプルに対応するリクエストが未解決であることを検出しない場合（破壊されたセッションを参照しているセッションIDの場合を含む）、このトリプルに関して競合はありません。サーバーは、CB_COMPOUNDプロシージャで参照されるオブジェクトに適用されるリクエストのみを参照するリクエストに、参照トリプルを制限する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client must not simply wait forever for the expected server reply to arrive before responding to the CB_COMPOUND that won the race, because it is possible that it will be delayed indefinitely. The client should assume the likely case that the reply will arrive within the average round-trip time for COMPOUND requests to the server, and wait that period of time. If that period of time expires, it can respond to the CB_COMPOUND with NFS4ERR_DELAY. There are other scenarios under which callbacks may race replies. Among them are pNFS layout recalls as described in Section 12.5.5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、レースに勝ったCB_COMPOUNDに応答する前に、予期されるサーバー応答が到着するのを単に永遠に待つ必要はありません。無限に遅延する可能性があるためです。クライアントは、サーバーへのCOMPOUND要求の平均往復時間内に応答が到着する可能性が高いと想定して、その期間待機する必要があります。その期間が満了すると、NFS4ERR_DELAYでCB_COMPOUNDに応答できます。コールバックが応答を競合させる他のシナリオがあります。その中には、12.5.5.2で説明されているpNFSレイアウトのリコールがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-6-4--COMPOUND-and-CBCOMPOUND-Construction-Issues">
2.10.6.4. COMPOUND and CB_COMPOUND Construction Issues
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.6.4. COMPOUNDおよびCB_COMPOUNDの構築に関する問題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Very large requests and replies may pose both buffer management issues (especially with RDMA) and reply cache issues. When the session is created (Section 18.36), for each channel (fore and back), the client and server negotiate the maximum-sized request they will send or process (ca_maxrequestsize), the maximum-sized reply they will return or process (ca_maxresponsesize), and the maximum-sized reply they will store in the reply cache (ca_maxresponsesize_cached).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求と応答が非常に大きいと、バッファ管理の問題（特にRDMAの場合）と応答キャッシュの問題の両方が発生する可能性があります。セッションが作成されると（セクション18.36）、各チャネル（前後）で、クライアントとサーバーは、それらが送信または処理する最大サイズのリクエスト（ca_maxrequestsize）、それらが返すまたは処理する最大サイズの応答（ca_maxresponsesize）についてネゴシエートします。 ）、および返信キャッシュに保存される最大サイズの返信（ca_maxresponsesize_cached）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a request exceeds ca_maxrequestsize, the reply will have the status NFS4ERR_REQ_TOO_BIG. A replier MAY return NFS4ERR_REQ_TOO_BIG as the status for the first operation (SEQUENCE or CB_SEQUENCE) in the request (which means that no operations in the request executed and that the state of the slot in the reply cache is unchanged), or it MAY opt to return it on a subsequent operation in the same COMPOUND or CB_COMPOUND request (which means that at least one operation did execute and that the state of the slot in the reply cache does change). The replier SHOULD set NFS4ERR_REQ_TOO_BIG on the operation that exceeds ca_maxrequestsize.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求がca_maxrequestsizeを超えると、応答のステータスはNFS4ERR_REQ_TOO_BIGになります。応答者は、要求の最初の操作（SEQUENCEまたはCB_SEQUENCE）のステータスとしてNFS4ERR_REQ_TOO_BIGを返す場合があります（つまり、要求の操作が実行されず、応答キャッシュのスロットの状態が変更されていないことを意味します）。同じCOMPOUNDまたはCB_COMPOUND要求の後続の操作でそれを返します（つまり、少なくとも1つの操作が実行され、応答キャッシュ内のスロットの状態が変化することを意味します）。リプライアは、ca_maxrequestsizeを超える操作でNFS4ERR_REQ_TOO_BIGを設定する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a reply exceeds ca_maxresponsesize, the reply will have the status NFS4ERR_REP_TOO_BIG. A replier MAY return NFS4ERR_REP_TOO_BIG as the status for the first operation (SEQUENCE or CB_SEQUENCE) in the request, or it MAY opt to return it on a subsequent operation (in the same COMPOUND or CB_COMPOUND reply). A replier MAY return NFS4ERR_REP_TOO_BIG in the reply to SEQUENCE or CB_SEQUENCE, even if the response would still exceed ca_maxresponsesize.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答がca_maxresponsesizeを超えると、応答のステータスはNFS4ERR_REP_TOO_BIGになります。リプライアは、リクエストの最初の操作（SEQUENCEまたはCB_SEQUENCE）のステータスとしてNFS4ERR_REP_TOO_BIGを返す場合があります。応答がまだca_maxresponsesizeを超える場合でも、応答者はSEQUENCEまたはCB_SEQUENCEへの応答でNFS4ERR_REP_TOO_BIGを返す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If sa_cachethis or csa_cachethis is TRUE, then the replier MUST cache a reply except if an error is returned by the SEQUENCE or CB_SEQUENCE operation (see Section 2.10.6.1.2). If the reply exceeds ca_maxresponsesize_cached (and sa_cachethis or csa_cachethis is TRUE), then the server MUST return NFS4ERR_REP_TOO_BIG_TO_CACHE. Even if NFS4ERR_REP_TOO_BIG_TO_CACHE (or any other error for that matter) is returned on an operation other than the first operation (SEQUENCE or CB_SEQUENCE), then the reply MUST be cached if sa_cachethis or csa_cachethis is TRUE. For example, if a COMPOUND has eleven operations, including SEQUENCE, the fifth operation is a RENAME, and the tenth operation is a READ for one million bytes, the server may return NFS4ERR_REP_TOO_BIG_TO_CACHE on the tenth operation. Since the server executed several operations, especially the non-idempotent RENAME, the client&#39;s request to cache the reply needs to be honored in order for the correct operation of exactly once semantics. If the client retries the request, the server will have cached a reply that contains results for ten of the eleven requested operations, with the tenth operation having a status of NFS4ERR_REP_TOO_BIG_TO_CACHE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sa_cachethisまたはcsa_cachethisがTRUEの場合、SEQUENCEまたはCB_SEQUENCE操作によってエラーが返された場合を除いて、返信者は返信をキャッシュする必要があります（2.10.6.1.2を参照）。応答がca_maxresponsesize_cachedを超えている（そしてsa_cachethisまたはcsa_cachethisがTRUEである）場合、サーバーはNFS4ERR_REP_TOO_BIG_TO_CACHEを返す必要があります。 NFS4ERR_REP_TOO_BIG_TO_CACHE（またはその他のエラー）が最初の操作（SEQUENCEまたはCB_SEQUENCE）以外の操作で返された場合でも、sa_cachethisまたはcsa_cachethisがTRUEの場合、応答をキャッシュする必要があります。たとえば、COMPOUNDにSEQUENCEを含む11の操作があり、5番目の操作がRENAMEであり、10番目の操作が100万バイトのREADである場合、サーバーは10番目の操作でNFS4ERR_REP_TOO_BIG_TO_CACHEを返すことがあります。サーバーがいくつかの操作、特に非べき等のRENAMEを実行したため、正確に1回だけのセマンティクスの正しい操作を行うには、クライアントの応答をキャッシュする要求を尊重する必要があります。クライアントが要求を再試行する場合、サーバーは11の要求された操作のうち10の結果を含む応答をキャッシュし、10番目の操作のステータスはNFS4ERR_REP_TOO_BIG_TO_CACHEになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A client needs to take care that when sending operations that change the current filehandle (except for PUTFH, PUTPUBFH, PUTROOTFH, and RESTOREFH), it not exceed the maximum reply buffer before the GETFH operation. Otherwise, the client will have to retry the operation that changed the current filehandle, in order to obtain the desired filehandle. For the OPEN operation (see Section 18.16), retry is not always available as an option. The following guidelines for the handling of filehandle-changing operations are advised: o Within the same COMPOUND procedure, a client SHOULD send GETFH immediately after a current filehandle-changing operation. A client MUST send GETFH after a current filehandle-changing operation that is also non-idempotent (e.g., the OPEN operation), unless the operation is RESTOREFH. RESTOREFH is an exception, because even though it is non-idempotent, the filehandle RESTOREFH produced originated from an operation that is either idempotent (e.g., PUTFH, LOOKUP), or non-idempotent (e.g., OPEN, CREATE). If the origin is non-idempotent, then because the client MUST send GETFH after the origin operation, the client can recover if RESTOREFH returns an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントは、現在のファイルハンドルを変更する操作（PUTFH、PUTPUBFH、PUTROOTFH、およびRESTOREFHを除く）を送信するときに、GETFH操作前の最大応答バッファーを超えないように注意する必要があります。それ以外の場合、クライアントは、目的のファイルハンドルを取得するために、現在のファイルハンドルを変更した操作を再試行する必要があります。 OPEN操作（セクション18.16を参照）の場合、再試行は常にオプションとして使用できるわけではありません。ファイルハンドル変更操作の処理に関する次のガイドラインをお勧めします。o同じCOMPOUNDプロシージャ内で、クライアントは現在のファイルハンドル変更操作の直後にGETFHを送信する必要があります（SHOULD）。操作がRESTOREFHでない限り、クライアントは、現在のファイルハンドル変更操作（べき等ではない操作（OPEN操作など））の後にGETFHを送信する必要があります。 RESTOREFHは例外です。なぜなら、それがべき等ではない場合でも、生成されるファイルハンドルRESTOREFHは、べき等（PUTFH、LOOKUPなど）またはべき等ではない（OPEN、CREATEなど）の操作から発生したものだからです。オリジンがべき等でない場合、クライアントはオリジン操作の後にGETFHを送信する必要があるため、RESTOREFHがエラーを返した場合、クライアントは回復できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A server MAY return NFS4ERR_REP_TOO_BIG or NFS4ERR_REP_TOO_BIG_TO_CACHE (if sa_cachethis is TRUE) on a filehandle-changing operation if the reply would be too large on the next operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 次の操作で応答が大きすぎる場合、サーバーはファイルハンドル変更操作でNFS4ERR_REP_TOO_BIGまたはNFS4ERR_REP_TOO_BIG_TO_CACHE（sa_cachethisがTRUEの場合）を返す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A server SHOULD return NFS4ERR_REP_TOO_BIG or NFS4ERR_REP_TOO_BIG_TO_CACHE (if sa_cachethis is TRUE) on a filehandle-changing, non-idempotent operation if the reply would be too large on the next operation, especially if the operation is OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 次の操作で応答が大きすぎる場合、特に操作がOPENの場合、サーバーはファイルハンドルを変更する、べき等ではない操作でNFS4ERR_REP_TOO_BIGまたはNFS4ERR_REP_TOO_BIG_TO_CACHE（sa_cachethisがTRUEの場合）を返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A server MAY return NFS4ERR_UNSAFE_COMPOUND to a non-idempotent current filehandle-changing operation, if it looks at the next operation (in the same COMPOUND procedure) and finds it is not GETFH. The server SHOULD do this if it is unable to determine in advance whether the total response size would exceed ca_maxresponsesize_cached or ca_maxresponsesize.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、次の操作（同じCOMPOUNDプロシージャ内）を調べ、GETFHではないことを検出した場合、NFS4ERR_UNSAFE_COMPOUNDをべき等でない現在のファイルハンドル変更操作に返すことができます（MAY）。合計応答サイズがca_maxresponsesize_cachedまたはca_maxresponsesizeを超えるかどうかを事前に判断できない場合、サーバーはこれを行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-6-5--Persistence">
2.10.6.5. Persistence
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.6.5. 持続性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the reply cache is bounded, it is practical for the reply cache to persist across server restarts. The replier MUST persist the following information if it agreed to persist the session (when the session was created; see Section 18.36):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答キャッシュは制限されているため、サーバーの再起動後も応答キャッシュが保持されるのが現実的です。セッションを持続することに同意した場合、リプライヤは次の情報を持続しなければなりません（セッションが作成されたとき。セクション18.36を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The session ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セッションID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The slot table including the sequence ID and cached reply for each slot.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 各スロットのシーケンスIDとキャッシュされた応答を含むスロットテーブル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The above are sufficient for a replier to provide EOS semantics for any requests that were sent and executed before the server restarted. If the replier is a client, then there is no need for it to persist any more information, unless the client will be persisting all other state across client restart, in which case, the server will never see any NFSv4.1-level protocol manifestation of a client restart. If the replier is a server, with just the slot table and session ID persisting, any requests the client retries after the server restart will return the results that are cached in the reply cache, and any new requests (i.e., the sequence ID is one greater than the slot&#39;s sequence ID) MUST be rejected with NFS4ERR_DEADSESSION (returned by SEQUENCE). Such a session is considered dead. A server MAY re-animate a session after a server restart so that the session will accept new requests as well as retries. To re-animate a session, the server needs to persist additional information through server restart:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
上記は、サーバーが再起動する前に送信および実行されたすべてのリクエストに対して、返信者がEOSセマンティクスを提供するのに十分です。返信者がクライアントの場合、クライアントがクライアントの再起動後も他のすべての状態を保持しない限り、それ以上の情報を保持する必要はありません。その場合、サーバーはNFSv4.1レベルのプロトコルのマニフェストを見ることはありません。クライアントの再起動。応答者がサーバーであり、スロットテーブルとセッションIDのみが保持されている場合、サーバーの再起動後にクライアントが再試行する要求は、応答キャッシュにキャッシュされている結果と新しい要求を返します（つまり、シーケンスIDは1です）スロットのシーケンスIDより大きい）は、NFS4ERR_DEADSESSION（SEQUENCEによって返される）で拒否する必要があります。そのようなセッションは死んだと見なされます。サーバーは、サーバーが再起動した後にセッションを再度アニメーション化して、セッションが再試行と同様に新しいリクエストを受け入れるようにする場合があります。セッションを再度アニメーション化するには、サーバーはサーバーの再起動を通じて追加情報を保持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client ID. This is a prerequisite to let the client create more sessions associated with the same client ID as the re-animated session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントID。これは、クライアントが、再アニメーション化されたセッションと同じクライアントIDに関連付けられたセッションをさらに作成するための前提条件です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client ID&#39;s sequence ID that is used for creating sessions (see Sections 18.35 and 18.36). This is a prerequisite to let the client create more sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セッションの作成に使用されるクライアントIDのシーケンスID（セクション18.35および18.36を参照）。これは、クライアントがより多くのセッションを作成できるようにするための前提条件です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The principal that created the client ID. This allows the server to authenticate the client when it sends EXCHANGE_ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントIDを作成したプリンシパル。これにより、サーバーはEXCHANGE_IDを送信するときにクライアントを認証できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The SSV, if SP4_SSV state protection was specified when the client ID was created (see Section 18.35). This lets the client create new sessions, and associate connections with the new and existing sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SSV（クライアントIDの作成時にSP4_SSV状態保護が指定された場合（セクション18.35を参照））。これにより、クライアントは新しいセッションを作成し、接続を新規および既存のセッションに関連付けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The properties of the client ID as defined in Section 18.35.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セクション18.35で定義されているクライアントIDのプロパティ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A persistent reply cache places certain demands on the server. The execution of the sequence of operations (starting with SEQUENCE) and placement of its results in the persistent cache MUST be atomic. If a client retries a sequence of operations that was previously executed on the server, the only acceptable outcomes are either the original cached reply or an indication that the client ID or session has been lost (indicating a catastrophic loss of the reply cache or a session that has been deleted because the client failed to use the session for an extended period of time).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
永続的な応答キャッシュは、サーバーに特定の要求を課します。操作のシーケンスの実行（SEQUENCEで始まる）とその結果の永続キャッシュへの配置は、アトミックである必要があります。以前にサーバーで実行された一連の操作をクライアントが再試行する場合、受け入れられる結果は、キャッシュされた元の応答、またはクライアントIDまたはセッションが失われたことの表示（応答キャッシュまたはセッションの壊滅的な損失を示す）のみです。クライアントが長時間セッションを使用できなかったため、削除されました）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A server could fail and restart in the middle of a COMPOUND procedure that contains one or more non-idempotent or idempotent-but-modifying operations. This creates an even higher challenge for atomic execution and placement of results in the reply cache. One way to view the problem is as a single transaction consisting of each operation in the COMPOUND followed by storing the result in persistent storage, then finally a transaction commit. If there is a failure before the transaction is committed, then the server rolls back the transaction. If the server itself fails, then when it restarts, its recovery logic could roll back the transaction before starting the NFSv4.1 server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーは、1つ以上のべき等ではない操作またはべき等ではあるが変更する操作を含むCOMPOUNDプロシージャの途中で失敗して再起動する可能性があります。これにより、アトミック実行と結果の応答キャッシュへの配置がさらに困難になります。問題を表示する1つの方法は、COMPOUNDの各操作で構成される単一のトランザクションとして、結果を永続ストレージに保存し、最後にトランザクションをコミットすることです。トランザクションがコミットされる前に障害が発生した場合、サーバーはトランザクションをロールバックします。サーバー自体に障害が発生した場合、サーバーが再起動すると、NFSv4.1サーバーを起動する前に、その回復ロジックがトランザクションをロールバックする可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the description of the implementation for atomic execution of the request and caching of the reply is beyond the scope of this document, an example implementation for NFSv2 [38] is described in [39].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求のアトミック実行と応答のキャッシングの実装の説明はこのドキュメントの範囲を超えていますが、NFSv2 [38]の実装例は[39]で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-7--RDMA-Considerations">
2.10.7. RDMA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.7. RDMAに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A complete discussion of the operation of RPC-based protocols over RDMA transports is in [8]. A discussion of the operation of NFSv4, including NFSv4.1, over RDMA is in [9]. Where RDMA is considered, this specification assumes the use of such a layering; it addresses only the upper-layer issues relevant to making best use of RPC/RDMA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RDMAトランスポートを介したRPCベースのプロトコルの操作に関する完全な議論は[8]にあります。 RDMAを介したNFSv4.1を含むNFSv4の操作についての議論は[9]にあります。 RDMAを検討する場合、この仕様ではこのような階層化の使用を想定しています。 RPC / RDMAを最大限に活用することに関連する上位層の問題のみを扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-7-1--RDMA-Connection-Resources">
2.10.7.1. RDMA Connection Resources
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.7.1. RDMA接続リソース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RDMA requires its consumers to register memory and post buffers of a specific size and number for receive operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RDMAでは、受信操作のために特定のサイズと数のメモリとポストバッファを登録する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Registration of memory can be a relatively high-overhead operation, since it requires pinning of buffers, assignment of attributes (e.g., readable/writable), and initialization of hardware translation. Preregistration is desirable to reduce overhead. These registrations are specific to hardware interfaces and even to RDMA connection endpoints; therefore, negotiation of their limits is desirable to manage resources effectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メモリの登録は、バッファの固定、属性の割り当て（たとえば、読み取り/書き込み可能）、およびハードウェア変換の初期化を必要とするため、比較的オーバーヘッドの高い操作になる可能性があります。事前登録はオーバーヘッドを減らすために望ましいです。これらの登録は、ハードウェアインターフェイスとRDMA接続エンドポイントに固有です。したがって、リソースを効率的に管理するには、制限の交渉が望ましいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following basic registration, these buffers must be posted by the RPC layer to handle receives. These buffers remain in use by the RPC/ NFSv4.1 implementation; the size and number of them must be known to the remote peer in order to avoid RDMA errors that would cause a fatal error on the RDMA connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本的な登録に続いて、これらのバッファーは、受信を処理するためにRPCレイヤーによってポストされる必要があります。これらのバッファーは、RPC / NFSv4.1実装で引き続き使用されています。 RDMA接続で致命的なエラーを引き起こすRDMAエラーを回避するために、それらのサイズと数はリモートピアに認識されている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 manages slots as resources on a per-session basis (see Section 2.10), while RDMA connections manage credits on a per-connection basis. This means that in order for a peer to send data over RDMA to a remote buffer, it has to have both an NFSv4.1 slot and an RDMA credit. If multiple RDMA connections are associated with a session, then if the total number of credits across all RDMA connections associated with the session is X, and the number of slots in the session is Y, then the maximum number of outstanding requests is the lesser of X and Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1は、スロットをセッションごとにリソースとして管理し（セクション2.10を参照）、RDMA接続は接続ごとにクレジットを管理します。つまり、ピアがRDMA経由でリモートバッファーにデータを送信するには、NFSv4.1スロットとRDMAクレジットの両方が必要です。複数のRDMA接続がセッションに関連付けられている場合、セッションに関連付けられているすべてのRDMA接続全体のクレジットの総数がXで、セッションのスロット数がYの場合、未処理のリクエストの最大数は少なくなります。 XとY。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-7-2--Flow-Control">
2.10.7.2. Flow Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.7.2. フロー制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Previous versions of NFS do not provide flow control; instead, they rely on the windowing provided by transports like TCP to throttle requests. This does not work with RDMA, which provides no operation flow control and will terminate a connection in error when limits are exceeded. Limits such as maximum number of requests outstanding are therefore negotiated when a session is created (see the ca_maxrequests field in Section 18.36). These limits then provide the maxima within which each connection associated with the session&#39;s channel(s) must remain. RDMA connections are managed within these limits as described in Section 3.3 of [8]; if there are multiple RDMA connections, then the maximum number of requests for a channel will be divided among the RDMA connections. Put a different way, the onus is on the replier to ensure that the total number of RDMA credits across all connections associated with the replier&#39;s channel does exceed the channel&#39;s maximum number of outstanding requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSの以前のバージョンはフロー制御を提供していません。代わりに、TCPなどのトランスポートが提供するウィンドウ処理に依存して、リクエストを抑制します。これはRDMAでは機能しません。RDMAは操作フロー制御を提供せず、制限を超えるとエラーで接続を終了します。したがって、未処理のリクエストの最大数などの制限は、セッションの作成時にネゴシエートされます（セクション18.36のca_maxrequestsフィールドを参照）。これらの制限は、セッションのチャネルに関連付けられた各接続を維持する必要がある最大値を提供します。 [8]のセクション3.3で説明されているように、RDMA接続はこれらの制限内で管理されます。複数のRDMA接続がある場合、チャネルの最大リクエスト数はRDMA接続間で分割されます。別の言い方をすれば、責任はリプライヤにあり、リプライヤのチャネルに関連付けられたすべての接続にわたるRDMAクレジットの総数がチャネルの未処理の要求の最大数を超えないようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limits may also be modified dynamically at the replier&#39;s choosing by manipulating certain parameters present in each NFSv4.1 reply. In addition, the CB_RECALL_SLOT callback operation (see Section 20.8) can be sent by a server to a client to return RDMA credits to the server, thereby lowering the maximum number of requests a client can have outstanding to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制限は、各NFSv4.1応答に存在する特定のパラメーターを操作することにより、応答者の選択で動的に変更することもできます。さらに、CB_RECALL_SLOTコールバック操作（セクション20.8を参照）をサーバーからクライアントに送信して、RDMAクレジットをサーバーに返すことができるため、クライアントがサーバーに対して未処理にできるリクエストの最大数を減らすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-7-3--Padding">
2.10.7.3. Padding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.7.3. パディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Header padding is requested by each peer at session initiation (see the ca_headerpadsize argument to CREATE_SESSION in Section 18.36), and subsequently used by the RPC RDMA layer, as described in [8]. Zero padding is permitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーパディングは、セッション開始時に各ピアによって要求され（セクション18.36のCREATE_SESSIONへのca_headerpadsize引数を参照）、[8]で説明されているように、その後RPC RDMAレイヤーによって使用されます。ゼロ埋め込みが許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Padding leverages the useful property that RDMA preserve alignment of data, even when they are placed into anonymous (untagged) buffers. If requested, client inline writes will insert appropriate pad bytes within the request header to align the data payload on the specified boundary. The client is encouraged to add sufficient padding (up to the negotiated size) so that the &#34;data&#34; field of the WRITE operation is aligned. Most servers can make good use of such padding, which allows them to chain receive buffers in such a way that any data carried by client requests will be placed into appropriate buffers at the server, ready for file system processing. The receiver&#39;s RPC layer encounters no overhead from skipping over pad bytes, and the RDMA layer&#39;s high performance makes the insertion and transmission of padding on the sender a significant optimization. In this way, the need for servers to perform RDMA Read to satisfy all but the largest client writes is obviated. An added benefit is the reduction of message round trips on the network -- a potentially good trade, where latency is present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
パディングは、RDMAが匿名（タグ付けされていない）バッファーに配置されている場合でも、データの配置を保持するという有用な特性を利用します。要求された場合、クライアントのインライン書き込みは、指定された境界にデータペイロードを揃えるために、要求ヘッダー内に適切な埋め込みバイトを挿入します。クライアントは、WRITE操作の「データ」フィールドが整列するように、十分なパディング（ネゴシエートされたサイズまで）を追加することをお勧めします。ほとんどのサーバーはこのようなパディングをうまく利用できます。これにより、クライアント要求によって運ばれたデータがサーバーの適切なバッファーに配置され、ファイルシステム処理の準備ができるように、受信バッファーをチェーンできます。レシーバーのRPCレイヤーでは、パッドバイトのスキップによるオーバーヘッドは発生しません。RDMAレイヤーの高いパフォーマンスにより、センダーでのパディングの挿入と送信が大幅に最適化されます。このようにして、最大のクライアント書き込みを除くすべてを満たすためにサーバーがRDMA読み取りを実行する必要がなくなります。追加の利点は、ネットワーク上でのメッセージラウンドトリップの削減です。これは、潜在的に良好なトレードであり、レイテンシが存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value to choose for padding is subject to a number of criteria. A primary source of variable-length data in the RPC header is the authentication information, the form of which is client-determined, possibly in response to server specification. The contents of COMPOUNDs, sizes of strings such as those passed to RENAME, etc. all go into the determination of a maximal NFSv4.1 request size and therefore minimal buffer size. The client must select its offered value carefully, so as to avoid overburdening the server, and vice versa. The benefit of an appropriate padding value is higher performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディングに選択する値は、いくつかの基準に従います。 RPCヘッダー内の可変長データの主なソースは認証情報です。認証情報の形式はクライアントによって決定され、サーバーの仕様に応じている可能性があります。 COMPOUNDの内容、RENAMEに渡される文字列のサイズなどはすべて、最大のNFSv4.1リクエストサイズ、したがって最小のバッファサイズの決定に使用されます。クライアントはサーバーに過大な負荷をかけないように、またその逆も同様に、提示された値を慎重に選択する必要があります。適切なパディング値の利点は、より高いパフォーマンスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                    Sender gather:
        |RPC Request|Pad  bytes|Length| -&gt; |User data...|
        \------+----------------------/      \
                \                             \
                 \    Receiver scatter:        \-----------+- ...
            /-----+----------------\            \           \
            |RPC Request|Pad|Length|   -&gt;  |FS buffer|-&gt;|FS buffer|-&gt;...
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the above case, the server may recycle unused buffers to the next posted receive if unused by the actual received request, or may pass the now-complete buffers by reference for normal write processing. For a server that can make use of it, this removes any need for data copies of incoming data, without resorting to complicated end-to-end buffer advertisement and management. This includes most kernel-based and integrated server designs, among many others. The client may perform similar optimizations, if desired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の場合、サーバーは、実際に受信した要求で使用されていない場合、未使用のバッファーを次のポストされた受信にリサイクルするか、通常の書き込み処理の参照により完全なバッファーを渡します。これを利用できるサーバーの場合、これにより、複雑なエンドツーエンドのバッファーアドバタイズメントと管理に頼らずに、着信データのデータコピーが不要になります。これには、とりわけカーネルベースの統合サーバー設計のほとんどが含まれます。クライアントは、必要に応じて、同様の最適化を実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-7-4--Dual-RDMA-and-Non-RDMA-Transports">
2.10.7.4. Dual RDMA and Non-RDMA Transports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.7.4. デュアルRDMAおよび非RDMAトランスポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some RDMA transports (e.g., RFC 5040 [10]) permit a &#34;streaming&#34; (non-RDMA) phase, where ordinary traffic might flow before &#34;stepping up&#34; to RDMA mode, commencing RDMA traffic. Some RDMA transports start connections always in RDMA mode. NFSv4.1 allows, but does not assume, a streaming phase before RDMA mode. When a connection is associated with a session, the client and server negotiate whether the connection is used in RDMA or non-RDMA mode (see Sections 18.36 and 18.34).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のRDMAトランスポート（RFC 5040 [10]など）は、「ストリーミング」（非RDMA）フェーズを許可します。このフェーズでは、通常のトラフィックがRDMAモードに「ステップアップ」する前に流れ、RDMAトラフィックが開始されます。一部のRDMAトランスポートは、常にRDMAモードで接続を開始します。 NFSv4.1は、RDMAモードの前のストリーミングフェーズを許可しますが、想定しません。接続がセッションに関連付けられると、クライアントとサーバーは、接続がRDMAモードで使用されているか非RDMAモードで使用されているかをネゴシエートします（セクション18.36および18.34を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-8--Session-Security">
2.10.8. Session Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.8. セッションのセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-8-1--Session-Callback-Security">
2.10.8.1. Session Callback Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.8.1. セッションコールバックのセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Via session/connection association, NFSv4.1 improves security over that provided by NFSv4.0 for the backchannel. The connection is client-initiated (see Section 18.34) and subject to the same firewall and routing checks as the fore channel. At the client&#39;s option (see Section 18.35), connection association is fully authenticated before being activated (see Section 18.34). Traffic from the server over the backchannel is authenticated exactly as the client specifies (see Section 2.10.8.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション/接続の関連付けにより、NFSv4.1は、バックチャネル用にNFSv4.0によって提供されるものよりもセキュリティを向上させます。接続はクライアントによって開始され（セクション18.34を参照）、フォアチャネルと同じファイアウォールおよびルーティングチェックが適用されます。クライアントのオプションで（セクション18.35を参照）、接続の関連付けはアクティブ化される前に完全に認証されます（セクション18.34を参照）。バックチャネルを介したサーバーからのトラフィックは、クライアントが指定したとおりに認証されます（セクション2.10.8.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-8-2--Backchannel-RPC-Security">
2.10.8.2. Backchannel RPC Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.8.2. バックチャネルRPCセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the NFSv4.1 client establishes the backchannel, it informs the server of the security flavors and principals to use when sending requests. If the security flavor is RPCSEC_GSS, the client expresses the principal in the form of an established RPCSEC_GSS context. The server is free to use any of the flavor/principal combinations the client offers, but it MUST NOT use unoffered combinations. This way, the client need not provide a target GSS principal for the backchannel as it did with NFSv4.0, nor does the server have to implement an RPCSEC_GSS initiator as it did with NFSv4.0 [30].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1クライアントは、バックチャネルを確立すると、要求を送信するときに使用するセキュリティの種類とプリンシパルをサーバーに通知します。セキュリティフレーバーがRPCSEC_GSSの場合、クライアントは、確立されたRPCSEC_GSSコンテキストの形式でプリンシパルを表現します。サーバーはクライアントが提供するフレーバー/プリンシパルの組み合わせを自由に使用できますが、提供されていない組み合わせを使用してはなりません。このように、クライアントは、NFSv4.0で行ったようにバックチャネルにターゲットGSSプリンシパルを提供する必要がなく、サーバーはNFSv4.0で行ったようにRPCSEC_GSSイニシエーターを実装する必要もありません[30]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CREATE_SESSION (Section 18.36) and BACKCHANNEL_CTL (Section 18.33) operations allow the client to specify flavor/ principal combinations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATE_SESSION（セクション18.36）およびBACKCHANNEL_CTL（セクション18.33）操作により、クライアントはフレーバーとプリンシパルの組み合わせを指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Also note that the SP4_SSV state protection mode (see Sections 18.35 and 2.10.8.3) has the side benefit of providing SSV-derived RPCSEC_GSS contexts (Section 2.10.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、SP4_SSV状態保護モード（セクション18.35および2.10.8.3を参照）には、SSVから派生したRPCSEC_GSSコンテキスト（セクション2.10.9）を提供するという副次的な利点があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-8-3--Protection-from-Unauthorized-State-Changes">
2.10.8.3. Protection from Unauthorized State Changes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.8.3. 不正な状態変化からの保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 As described to this point in the specification, the state model of NFSv4.1 is vulnerable to an attacker that sends a SEQUENCE operation with a forged session ID and with a slot ID that it expects the legitimate client to use next. When the legitimate client uses the slot ID with the same sequence number, the server returns the attacker&#39;s result from the reply cache, which disrupts the legitimate client and thus denies service to it. Similarly, an attacker could send a CREATE_SESSION with a forged client ID to create a new session associated with the client ID. The attacker could send requests using the new session that change locking state, such as LOCKU operations to release locks the legitimate client has acquired. Setting a security policy on the file that requires RPCSEC_GSS credentials when manipulating the file&#39;s state is one potential work around, but has the disadvantage of preventing a legitimate client from releasing state when RPCSEC_GSS is required to do so, but a GSS context cannot be obtained (possibly because the user has logged off the client).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
仕様のこの時点まで説明したように、NFSv4.1の状態モデルは、正規のクライアントが次に使用することを期待するスロットIDと偽造されたセッションIDでSEQUENCE操作を送信する攻撃者に対して脆弱です。正当なクライアントが同じシーケンス番号のスロットIDを使用すると、サーバーは攻撃者の結果を応答キャッシュから返します。これにより、正当なクライアントが妨害され、サービスが拒否されます。同様に、攻撃者は偽造されたクライアントIDとともにCREATE_SESSIONを送信して、クライアントIDに関連付けられた新しいセッションを作成する可能性があります。攻撃者は、正当なクライアントが取得したロックを解放するLOCKU操作など、ロック状態を変更する新しいセッションを使用してリクエストを送信する可能性があります。ファイルの状態を操作するときにRPCSEC_GSS資格情報を必要とするファイルにセキュリティポリシーを設定することは1つの潜在的な回避策ですが、RPCSEC_GSSが必要なときに正当なクライアントが状態を解放できないようにする欠点がありますが、GSSコンテキストを取得できません（おそらくユーザーがクライアントからログオフしたことが原因です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 provides three options to a client for state protection, which are specified when a client creates a client ID via EXCHANGE_ID (Section 18.35).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1は、状態保護のためにクライアントに3つのオプションを提供します。これらのオプションは、クライアントがEXCHANGE_IDを介してクライアントIDを作成するときに指定されます（セクション18.35）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first (SP4_NONE) is to simply waive state protection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の（SP4_NONE）は、単に状態保護を放棄することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The other two options (SP4_MACH_CRED and SP4_SSV) share several traits:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他の2つのオプション（SP4_MACH_CREDおよびSP4_SSV）は、いくつかの特性を共有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An RPCSEC_GSS-based credential is used to authenticate client ID and session maintenance operations, including creating and destroying a session, associating a connection with the session, and destroying the client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RPCSEC_GSSベースの資格情報は、セッションの作成と破棄、接続とセッションの関連付け、クライアントIDの破棄など、クライアントIDとセッションメンテナンス操作を認証するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Because RPCSEC_GSS is used to authenticate client ID and session maintenance, the attacker cannot associate a rogue connection with a legitimate session, or associate a rogue session with a legitimate client ID in order to maliciously alter the client ID&#39;s lock state via CLOSE, LOCKU, DELEGRETURN, LAYOUTRETURN, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RPCSEC_GSSはクライアントIDとセッションメンテナンスの認証に使用されるため、攻撃者は不正な接続を正当なセッションに関連付けたり、不正なセッションを正当なクライアントIDに関連付けたりして、CLOSE、LOCKU、DELEGRETURNを介してクライアントIDのロック状態を故意に変更することはできません。 、LAYOUTRETURNなど
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In cases where the server&#39;s security policies on a portion of its namespace require RPCSEC_GSS authentication, a client may have to use an RPCSEC_GSS credential to remove per-file state (e.g., LOCKU, CLOSE, etc.). The server may require that the principal that removes the state match certain criteria (e.g., the principal might have to be the same as the one that acquired the state). However, the client might not have an RPCSEC_GSS context for such a principal, and might not be able to create such a context (perhaps because the user has logged off). When the client establishes SP4_MACH_CRED or SP4_SSV protection, it can specify a list of operations that the server MUST allow using the machine credential (if SP4_MACH_CRED is used) or the SSV credential (if SP4_SSV is used).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 名前空間の一部に対するサーバーのセキュリティポリシーでRPCSEC_GSS認証が必要な場合、クライアントはRPCSEC_GSS資格を使用してファイルごとの状態（LOCKU、CLOSEなど）を削除する必要がある場合があります。サーバーは、状態を削除するプリンシパルが特定の基準に一致することを要求する場合があります（たとえば、プリンシパルは状態を取得したものと同じである必要がある場合があります）。ただし、クライアントには、そのようなプリンシパル用のRPCSEC_GSSコンテキストがない可能性があり、そのようなコンテキストを作成できない可能性があります（おそらくユーザーがログオフしたため）。クライアントがSP4_MACH_CREDまたはSP4_SSV保護を確立すると、サーバーは、マシン資格情報（SP4_MACH_CREDが使用されている場合）またはSSV資格情報（SP4_SSVが使用されている場合）の使用を許可する必要がある操作のリストを指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The SP4_MACH_CRED state protection option uses a machine credential where the principal that creates the client ID MUST also be the principal that performs client ID and session maintenance operations. The security of the machine credential state protection approach depends entirely on safe guarding the per-machine credential. Assuming a proper safeguard using the per-machine credential for operations like CREATE_SESSION, BIND_CONN_TO_SESSION, DESTROY_SESSION, and DESTROY_CLIENTID will prevent an attacker from associating a rogue connection with a session, or associating a rogue session with a client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
SP4_MACH_CRED状態保護オプションは、マシンIDを使用して、クライアントIDを作成するプリンシパルが、クライアントIDとセッションメンテナンス操作を実行するプリンシパルでもある必要があります。マシン資格情報の状態保護アプローチのセキュリティは、マシンごとの資格情報を安全に保護することに完全に依存しています。 CREATE_SESSION、BIND_CONN_TO_SESSION、DESTROY_SESSION、およびDESTROY_CLIENTIDなどの操作にマシンごとの認証情報を使用する適切な保護手段を想定すると、攻撃者は不正な接続をセッションに関連付けたり、不正なセッションをクライアントIDに関連付けたりできなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are at least three scenarios for the SP4_MACH_CRED option:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SP4_MACH_CREDオプションには、少なくとも3つのシナリオがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The system administrator configures a unique, permanent per-machine credential for one of the mandated GSS mechanisms (e.g., if Kerberos V5 is used, a &#34;keytab&#34; containing a principal derived from a client host name could be used).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. システム管理者は、必須のGSSメカニズムの1つに対して、マシンごとに固有の永続的な資格情報を構成します（たとえば、Kerberos V5が使用されている場合、クライアントのホスト名から派生したプリンシパルを含む「キータブ」を使用できます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The client is used by a single user, and so the client ID and its sessions are used by just that user. If the user&#39;s credential expires, then session and client ID maintenance cannot occur, but since the client has a single user, only that user is inconvenienced.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. クライアントは単一のユーザーによって使用されるため、クライアントIDとそのセッションはそのユーザーだけが使用します。ユーザーの資格情報の有効期限が切れた場合、セッションとクライアントIDのメンテナンスは発生しませんが、クライアントには単一のユーザーがいるため、そのユーザーのみが不便になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The physical client has multiple users, but the client implementation has a unique client ID for each user. This is effectively the same as the second scenario, but a disadvantage is that each user needs to be allocated at least one session each, so the approach suffers from lack of economy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 物理クライアントには複数のユーザーがいますが、クライアントの実装にはユーザーごとに一意のクライアントIDがあります。これは実質的に2番目のシナリオと同じですが、欠点は、各ユーザーに少なくとも1つのセッションを割り当てる必要があるため、このアプローチでは経済性が損なわれることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SP4_SSV protection option uses the SSV (Section 1.6), via RPCSEC_GSS and the SSV GSS mechanism (Section 2.10.9), to protect state from attack. The SP4_SSV protection option is intended for the situation comprised of a client that has multiple active users and a system administrator who wants to avoid the burden of installing a permanent machine credential on each client. The SSV is established and updated on the server via SET_SSV (see Section 18.47). To prevent eavesdropping, a client SHOULD send SET_SSV via RPCSEC_GSS with the privacy service. Several aspects of the SSV make it intractable for an attacker to guess the SSV, and thus associate rogue connections with a session, and rogue sessions with a client ID:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SP4_SSV保護オプションは、RPCSEC_GSSおよびSSV GSSメカニズム（セクション2.10.9）を介してSSV（セクション1.6）を使用して、状態を攻撃から保護します。 SP4_SSV保護オプションは、複数のアクティブユーザーがいるクライアントと、各クライアントに永続的なマシン資格情報をインストールする負担を避けたいシステム管理者で構成される状況を対象としています。 SSVは、SET_SSVを介してサーバー上で確立および更新されます（セクション18.47を参照）。盗聴を防止するために、クライアントはプライバシーサービスと共にRPCSEC_GSSを介してSET_SSVを送信する必要があります（SHOULD）。 SSVのいくつかの側面により、攻撃者がSSVを推測することが困難になり、不正な接続をセッションに関連付け、不正なセッションをクライアントIDに関連付けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The arguments to and results of SET_SSV include digests of the old and new SSV, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SET_SSVの引数と結果には、それぞれ新旧のSSVのダイジェストが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Because the initial value of the SSV is zero, therefore known, the client that opts for SP4_SSV protection and opts to apply SP4_SSV protection to BIND_CONN_TO_SESSION and CREATE_SESSION MUST send at least one SET_SSV operation before the first BIND_CONN_TO_SESSION operation or before the second CREATE_SESSION operation on a client ID. If it does not, the SSV mechanism will not generate tokens (Section 2.10.9). A client SHOULD send SET_SSV as soon as a session is created.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SSVの初期値はゼロであるため、既知であるため、SP4_SSV保護を選択し、SP4_SSV保護をBIND_CONN_TO_SESSIONおよびCREATE_SESSIONに適用することを選択したクライアントは、最初のBIND_CONN_TO_SESSION操作の前、またはクライアントID。そうでない場合、SSVメカニズムはトークンを生成しません（セクション2.10.9）。クライアントは、セッションが作成されるとすぐにSET_SSVを送信する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A SET_SSV request does not replace the SSV with the argument to SET_SSV. Instead, the current SSV on the server is logically exclusive ORed (XORed) with the argument to SET_SSV. Each time a new principal uses a client ID for the first time, the client SHOULD send a SET_SSV with that principal&#39;s RPCSEC_GSS credentials, with RPCSEC_GSS service set to RPC_GSS_SVC_PRIVACY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SET_SSV要求は、SSVをSET_SSVへの引数で置き換えません。代わりに、サーバー上の現在のSSVは、SET_SSVへの引数と論理的に排他的OR（XOR）されます。新しいプリンシパルがクライアントIDを初めて使用するたびに、クライアントは、RPCSEC_GSSサービスがRPC_GSS_SVC_PRIVACYに設定されたプリンシパルのRPCSEC_GSS資格情報を使用してSET_SSVを送信する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here are the types of attacks that can be attempted by an attacker named Eve on a victim named Bob, and how SP4_SSV protection foils each attack:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、Eveという攻撃者がBobという犠牲者に対して試みることができる攻撃のタイプと、SP4_SSV保護が各攻撃を阻止する方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Suppose Eve is the first user to log into a legitimate client. Eve&#39;s use of an NFSv4.1 file system will cause the legitimate client to create a client ID with SP4_SSV protection, specifying that the BIND_CONN_TO_SESSION operation MUST use the SSV credential. Eve&#39;s use of the file system also causes an SSV to be created. The SET_SSV operation that creates the SSV will be protected by the RPCSEC_GSS context created by the legitimate client, which uses Eve&#39;s GSS principal and credentials. Eve can eavesdrop on the network while her RPCSEC_GSS context is created and the SET_SSV using her context is sent. Even if the legitimate client sends the SET_SSV with RPC_GSS_SVC_PRIVACY, because Eve knows her own credentials, she can decrypt the SSV. Eve can compute an RPCSEC_GSS credential that BIND_CONN_TO_SESSION will accept, and so associate a new connection with the legitimate session. Eve can change the slot ID and sequence state of a legitimate session, and/or the SSV state, in such a way that when Bob accesses the server via the same legitimate client, the legitimate client will be unable to use the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Eveが正当なクライアントにログインする最初のユーザーであるとします。 EveがNFSv4.1ファイルシステムを使用すると、正当なクライアントがSP4_SSV保護を備えたクライアントIDを作成し、BIND_CONN_TO_SESSION操作でSSV資格情報を使用する必要があることを指定します。 Eveがファイルシステムを使用すると、SSVも作成されます。 SSVを作成するSET_SSV操作は、EveのGSSプリンシパルと資格情報を使用する正当なクライアントによって作成されたRPCSEC_GSSコンテキストによって保護されます。 Eveは、RPCSEC_GSSコンテキストが作成され、そのコンテキストを使用するSET_SSVが送信されている間、ネットワークを盗聴できます。正当なクライアントがRPC_GSS_SVC_PRIVACYを使用してSET_SSVを送信した場合でも、イブは自分の資格情報を知っているため、SSVを復号化できます。 Eveは、BIND_CONN_TO_SESSIONが受け入れるRPCSEC_GSS資格情報を計算して、新しい接続を正当なセッションに関連付けることができます。 Eveは、ボブが同じ正当なクライアントを介してサーバーにアクセスしたときに、正当なクライアントがセッションを使用できないように、正当なセッションのスロットIDとシーケンス状態、SSV状態を変更できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The client&#39;s only recourse is to create a new client ID for Bob to use, and establish a new SSV for the client ID. The client will be unable to delete the old client ID, and will let the lease on the old client ID expire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントの唯一の手段は、Bobが使用する新しいクライアントIDを作成し、そのクライアントIDの新しいSSVを確立することです。クライアントは古いクライアントIDを削除できず、古いクライアントIDのリースが期限切れになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Once the legitimate client establishes an SSV over the new session using Bob&#39;s RPCSEC_GSS context, Eve can use the new session via the legitimate client, but she cannot disrupt Bob. Moreover, because the client SHOULD have modified the SSV due to Eve using the new session, Bob cannot get revenge on Eve by associating a rogue connection with the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
正当なクライアントがボブのRPCSEC_GSSコンテキストを使用して新しいセッションでSSVを確立すると、イブは正当なクライアントを介して新しいセッションを使用できますが、ボブを妨害することはできません。さらに、イブが新しい​​セッションを使用しているため、クライアントはSSVを変更する必要があるため（SHOULD）、ボブは不正な接続をセッションに関連付けることによってイブに復讐することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The question is how did the legitimate client detect that Eve has hijacked the old session? When the client detects that a new principal, Bob, wants to use the session, it SHOULD have sent a SET_SSV, which leads to the following sub-scenarios:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
問題は、イブが古いセッションをハイジャックしたことを正当なクライアントがどのように検出したかです。クライアントが新しいプリンシパルBobがセッションを使用することを望んでいることを検出すると、次のサブシナリオにつながるSET_SSVを送信する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Let us suppose that from the rogue connection, Eve sent a SET_SSV with the same slot ID and sequence ID that the legitimate client later uses. The server will assume the SET_SSV sent with Bob&#39;s credentials is a retry, and return to the legitimate client the reply it sent Eve. However, unless Eve can correctly guess the SSV the legitimate client will use, the digest verification checks in the SET_SSV response will fail. That is an indication to the client that the session has apparently been hijacked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 不正な接続から、イブが正当なクライアントが後で使用するのと同じスロットIDとシーケンスIDを使用してSET_SSVを送信したとします。サーバーは、ボブの資格情報とともに送信されたSET_SSVが再試行であると想定し、イブが送信した応答を正当なクライアントに返します。ただし、イブが正当なクライアントが使用するSSVを正しく推測できない限り、SET_SSV応答のダイジェスト検証チェックは失敗します。これは、セッションが明らかにハイジャックされたことをクライアントに示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Alternatively, Eve sent a SET_SSV with a different slot ID than the legitimate client uses for its SET_SSV. Then the digest verification of the SET_SSV sent with Bob&#39;s credentials fails on the server, and the error returned to the client makes it apparent that the session has been hijacked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* または、イブは、正当なクライアントがSET_SSVに使用するのとは異なるスロットIDでSET_SSVを送信しました。次に、Bobの資格情報とともに送信されたSET_SSVのダイジェスト検証がサーバーで失敗し、クライアントに返されたエラーにより、セッションが乗っ取られたことが明らかになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Alternatively, Eve sent an operation other than SET_SSV, but with the same slot ID and sequence that the legitimate client uses for its SET_SSV. The server returns to the legitimate client the response it sent Eve. The client sees that the response is not at all what it expects. The client assumes either session hijacking or a server bug, and either way destroys the old session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* または、イブはSET_SSV以外の操作を送信しましたが、正当なクライアントがSET_SSVに使用するのと同じスロットIDとシーケンスを使用しています。サーバーは、イブに送信した応答を正当なクライアントに返します。クライアントは、応答が期待どおりではないことを確認します。クライアントは、セッションの乗っ取りまたはサーバーのバグのいずれかを想定し、どちらの方法でも古いセッションを破棄します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Eve associates a rogue connection with the session as above, and then destroys the session. Again, Bob goes to use the server from the legitimate client, which sends a SET_SSV using Bob&#39;s credentials. The client receives an error that indicates that the session does not exist. When the client tries to create a new session, this will fail because the SSV it has does not match that which the server has, and now the client knows the session was hijacked. The legitimate client establishes a new client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Eveは上記のように不正な接続をセッションに関連付けてから、セッションを破棄します。ここでも、ボブはボブの資格情報を使用してSET_SSVを送信する正当なクライアントからサーバーを使用します。クライアントは、セッションが存在しないことを示すエラーを受け取ります。クライアントが新しいセッションを作成しようとすると、そのSSVがサーバーが持っているものと一致せず、セッションがハイジャックされたことがクライアントで認識されるため、これは失敗します。正当なクライアントが新しいクライアントIDを確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If Eve creates a connection before the legitimate client establishes an SSV, because the initial value of the SSV is zero and therefore known, Eve can send a SET_SSV that will pass the digest verification check. However, because the new connection has not been associated with the session, the SET_SSV is rejected for that reason.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 正当なクライアントがSSVを確立する前にイブが接続を作成する場合、SSVの初期値はゼロであり、したがって既知であるため、イブは、ダイジェスト検証チェックに合格するSET_SSVを送信できます。ただし、新しい接続はセッションに関連付けられていないため、SET_SSVはその理由で拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In summary, an attacker&#39;s disruption of state when SP4_SSV protection is in use is limited to the formative period of a client ID, its first session, and the establishment of the SSV. Once a non-malicious user uses the client ID, the client quickly detects any hijack and rectifies the situation. Once a non-malicious user successfully modifies the SSV, the attacker cannot use NFSv4.1 operations to disrupt the non-malicious user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要約すると、SP4_SSV保護が使用されている場合の攻撃者の状態の混乱は、クライアントIDの形成期間、最初のセッション、およびSSVの確立に限定されます。悪意のないユーザーがクライアントIDを使用すると、クライアントはハイジャックをすばやく検出し、状況を修正します。悪意のないユーザーがSSVの変更に成功すると、攻撃者はNFSv4.1の操作を使用して、悪意のないユーザーを妨害することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that neither the SP4_MACH_CRED nor SP4_SSV protection approaches prevent hijacking of a transport connection that has previously been associated with a session. If the goal of a counter-threat strategy is to prevent connection hijacking, the use of IPsec is RECOMMENDED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SP4_MACH_CREDもSP4_SSV保護アプローチも、以前にセッションに関連付けられていたトランスポート接続のハイジャックを防止しないことに注意してください。カウンター脅威戦略の目的が接続の乗っ取りを防ぐことである場合、IPsecの使用が推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a connection hijack occurs, the hijacker could in theory change locking state and negatively impact the service to legitimate clients. However, if the server is configured to require the use of RPCSEC_GSS with integrity or privacy on the affected file objects, and if EXCHGID4_FLAG_BIND_PRINC_STATEID capability (Section 18.35) is in force, this will thwart unauthorized attempts to change locking state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続ハイジャックが発生した場合、ハイジャッカーは理論的にはロック状態を変更し、正当なクライアントへのサービスに悪影響を及ぼす可能性があります。ただし、影響を受けるファイルオブジェクトに対して整合性またはプライバシーを備えたRPCSEC_GSSの使用を要求するようにサーバーが構成されており、EXCHGID4_FLAG_BIND_PRINC_STATEID機能（セクション18.35）が有効になっている場合、これにより、ロック状態を変更する不正な試みが阻止されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-9--The-Secret-State-Verifier-SSV-GSS-Mechanism">
2.10.9. The Secret State Verifier (SSV) GSS Mechanism
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.9. 秘密状態検証（SSV）GSSメカニズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SSV provides the secret key for a GSS mechanism internal to NFSv4.1 that NFSv4.1 uses for state protection. Contexts for this mechanism are not established via the RPCSEC_GSS protocol. Instead, the contexts are automatically created when EXCHANGE_ID specifies SP4_SSV protection. The only tokens defined are the PerMsgToken (emitted by GSS_GetMIC) and the SealedMessage token (emitted by GSS_Wrap).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSVは、NFSv4.1が状態保護に使用するNFSv4.1内部のGSSメカニズムに秘密鍵を提供します。このメカニズムのコンテキストは、RPCSEC_GSSプロトコルを介して確立されません。代わりに、EXCHANGE_IDがSP4_SSV保護を指定すると、コンテキストが自動的に作成されます。定義されているトークンは、PerMsgToken（GSS_GetMICによって発行された）とSealedMessageトークン（GSS_Wrapによって発行された）だけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mechanism OID for the SSV mechanism is iso.org.dod.internet.private.enterprise.Michael Eisler.nfs.ssv_mech (1.3.6.1.4.1.28882.1.1). While the SSV mechanism does not define any initial context tokens, the OID can be used to let servers indicate that the SSV mechanism is acceptable whenever the client sends a SECINFO or SECINFO_NO_NAME operation (see Section 2.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSVメカニズムのメカニズムOIDは、iso.org.dod.internet.private.enterprise.Michael Eisler.nfs.ssv_mech（1.3.6.1.4.1.28882.1.1）です。 SSVメカニズムは初期コンテキストトークンを定義しませんが、OIDを使用して、クライアントがSECINFOまたはSECINFO_NO_NAMEオペレーションを送信するたびに、SSVメカニズムが受け入れ可能であることをサーバーに示すことができます（セクション2.6を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SSV mechanism defines four subkeys derived from the SSV value. Each time SET_SSV is invoked, the subkeys are recalculated by the client and server. The calculation of each of the four subkeys depends on each of the four respective ssv_subkey4 enumerated values. The calculation uses the HMAC [11] algorithm, using the current SSV as the key, the one-way hash algorithm as negotiated by EXCHANGE_ID, and the input text as represented by the XDR encoded enumeration value for that subkey of data type ssv_subkey4. If the length of the output of the HMAC algorithm exceeds the length of key of the encryption algorithm (which is also negotiated by EXCHANGE_ID), then the subkey MUST be truncated from the HMAC output, i.e., if the subkey is of N bytes long, then the first N bytes of the HMAC output MUST be used for the subkey. The specification of EXCHANGE_ID states that the length of the output of the HMAC algorithm MUST NOT be less than the length of subkey needed for the encryption algorithm (see Section 18.35).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSVメカニズムは、SSV値から派生した4つのサブキーを定義します。 SET_SSVが呼び出されるたびに、サブキーはクライアントとサーバーによって再計算されます。 4つのサブキーのそれぞれの計算は、4つのそれぞれのssv_subkey4列挙値のそれぞれに依存します。この計算では、HMAC [11]アルゴリズムを使用し、現在のSSVをキー、一方向ハッシュアルゴリズムをEXCHANGE_IDでネゴシエートし、入力テキストをデータ型ssv_subkey4のそのサブキーのXDRエンコード列挙値で表しています。 HMACアルゴリズムの出力の長さが暗号化アルゴリズムのキーの長さ（これもEXCHANGE_IDによってネゴシエートされる）を超える場合、サブキーはHMAC出力から切り捨てられなければなりません（つまり、サブキーの長さがNバイトの場合）。次に、HMAC出力の最初のNバイトをサブキーに使用する必要があります。 EXCHANGE_IDの仕様では、HMACアルゴリズムの出力の長さは、暗号化アルゴリズムに必要なサブキーの長さよりも短くてはならない（MUST 18.35を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Input for computing subkeys */
   enum ssv_subkey4 {
           SSV4_SUBKEY_MIC_I2T     = 1,
           SSV4_SUBKEY_MIC_T2I     = 2,
           SSV4_SUBKEY_SEAL_I2T    = 3,
           SSV4_SUBKEY_SEAL_T2I    = 4
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The subkey derived from SSV4_SUBKEY_MIC_I2T is used for calculating message integrity codes (MICs) that originate from the NFSv4.1 client, whether as part of a request over the fore channel or a response over the backchannel. The subkey derived from SSV4_SUBKEY_MIC_T2I is used for MICs originating from the NFSv4.1 server. The subkey derived from SSV4_SUBKEY_SEAL_I2T is used for encryption text originating from the NFSv4.1 client, and the subkey derived from SSV4_SUBKEY_SEAL_T2I is used for encryption text originating from the NFSv4.1 server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSV4_SUBKEY_MIC_I2Tから派生したサブキーは、NFSv4.1クライアントから発信されたメッセージ整合性コード（MIC）を計算するために使用されます（フォアチャネルを介した要求の一部としても、バックチャネルを介した応答の一部としても）。 SSV4_SUBKEY_MIC_T2Iから派生したサブキーは、NFSv4.1サーバーからのMICに使用されます。 SSV4_SUBKEY_SEAL_I2Tから派生したサブキーは、NFSv4.1クライアントからの暗号化テキストに使用され、SSV4_SUBKEY_SEAL_T2Iから派生したサブキーは、NFSv4.1サーバーからの暗号化テキストに使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PerMsgToken description is based on an XDR definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PerMsgTokenの説明は、XDR定義に基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Input for computing smt_hmac */
   struct ssv_mic_plain_tkn4 {
     uint32_t        smpt_ssv_seq;
     opaque          smpt_orig_plain&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* SSV GSS PerMsgToken token */
   struct ssv_mic_tkn4 {
     uint32_t        smt_ssv_seq;
     opaque          smt_hmac&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The field smt_hmac is an HMAC calculated by using the subkey derived from SSV4_SUBKEY_MIC_I2T or SSV4_SUBKEY_MIC_T2I as the key, the one-way hash algorithm as negotiated by EXCHANGE_ID, and the input text as represented by data of type ssv_mic_plain_tkn4. The field smpt_ssv_seq is the same as smt_ssv_seq. The field smpt_orig_plain is the &#34;message&#34; input passed to GSS_GetMIC() (see Section 2.3.1 of [7]). The caller of GSS_GetMIC() provides a pointer to a buffer containing the plain text. The SSV mechanism&#39;s entry point for GSS_GetMIC() encodes this into an opaque array, and the encoding will include an initial four-byte length, plus any necessary padding. Prepended to this will be the XDR encoded value of smpt_ssv_seq, thus making up an XDR encoding of a value of data type ssv_mic_plain_tkn4, which in turn is the input into the HMAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドsmt_hmacは、SSV4_SUBKEY_MIC_I2TまたはSSV4_SUBKEY_MIC_T2Iから派生したサブキーをキーとして使用し、EXCHANGE_IDによってネゴシエートされた一方向ハッシュアルゴリズムと、タイプssv_mic_plain_tkn4のデータによって表される入力テキストを使用して計算されたHMACです。フィールドsmpt_ssv_seqは、smt_ssv_seqと同じです。フィールドsmpt_orig_plainは、GSS_GetMIC()に渡される「メッセージ」入力です（[7]のセクション2.3.1を参照）。 GSS_GetMIC()の呼び出し元は、プレーンテキストを含むバッファへのポインタを提供します。 SSVメカニズムのGSS_GetMIC()のエントリポイントは、これを不透明な配列にエンコードします。エンコードには、最初の4バイトの長さと必要なパディングが含まれます。これに付加されるのは、smpt_ssv_seqのXDRエンコードされた値であり、したがって、HMACへの入力であるデータ型ssv_mic_plain_tkn4の値のXDRエンコードを構成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The token emitted by GSS_GetMIC() is XDR encoded and of XDR data type ssv_mic_tkn4. The field smt_ssv_seq comes from the SSV sequence number, which is equal to one after SET_SSV (Section 18.47) is called the first time on a client ID. Thereafter, the SSV sequence number is incremented on each SET_SSV. Thus, smt_ssv_seq represents the version of the SSV at the time GSS_GetMIC() was called. As noted in Section 18.35, the client and server can maintain multiple concurrent versions of the SSV. This allows the SSV to be changed without serializing all RPC calls that use the SSV mechanism with SET_SSV operations. Once the HMAC is calculated, it is XDR encoded into smt_hmac, which will include an initial four-byte length, and any necessary padding. Prepended to this will be the XDR encoded value of smt_ssv_seq.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GSS_GetMIC()によって発行されたトークンは、XDRエンコードされ、XDRデータ型ssv_mic_tkn4です。フィールドsmt_ssv_seqはSSVシーケンス番号から取得されます。これは、SET_SSV（セクション18.47）がクライアントIDで初めて呼び出された後の1に等しいです。その後、SSVシーケンス番号が各SET_SSVで増分されます。したがって、smt_ssv_seqは、GSS_GetMIC()が呼び出されたときのSSVのバージョンを表します。セクション18.35で説明したように、クライアントとサーバーは、SSVの複数の同時バージョンを維持できます。これにより、SET_SSV操作でSSVメカニズムを使用するすべてのRPC呼び出しをシリアル化することなく、SSVを変更できます。 HMACが計算されると、HDRはsmt_hmacにXDRエンコードされ、初期の4バイトの長さと必要なパディングが含まれます。これに付加されるのは、smd_ssv_seqのXDRエンコードされた値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SealedMessage description is based on an XDR definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SealedMessageの説明は、XDR定義に基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Input for computing ssct_encr_data and ssct_hmac */
   struct ssv_seal_plain_tkn4 {
     opaque          sspt_confounder&lt;&gt;;
     uint32_t        sspt_ssv_seq;
     opaque          sspt_orig_plain&lt;&gt;;
     opaque          sspt_pad&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* SSV GSS SealedMessage token */
   struct ssv_seal_cipher_tkn4 {
     uint32_t      ssct_ssv_seq;
     opaque        ssct_iv&lt;&gt;;
     opaque        ssct_encr_data&lt;&gt;;
     opaque        ssct_hmac&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The token emitted by GSS_Wrap() is XDR encoded and of XDR data type ssv_seal_cipher_tkn4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GSS_Wrap()によって発行されたトークンはXDRエンコードされ、XDRデータ型はssv_seal_cipher_tkn4です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ssct_ssv_seq field has the same meaning as smt_ssv_seq.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ssct_ssv_seqフィールドは、smt_ssv_seqと同じ意味です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ssct_encr_data field is the result of encrypting a value of the XDR encoded data type ssv_seal_plain_tkn4. The encryption key is the subkey derived from SSV4_SUBKEY_SEAL_I2T or SSV4_SUBKEY_SEAL_T2I, and the encryption algorithm is that negotiated by EXCHANGE_ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ssct_encr_dataフィールドは、XDRエンコードされたデータ型ssv_seal_plain_tkn4の値を暗号化した結果です。暗号化キーはSSV4_SUBKEY_SEAL_I2TまたはSSV4_SUBKEY_SEAL_T2Iから派生したサブキーであり、暗号化アルゴリズムはEXCHANGE_IDによってネゴシエートされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The ssct_iv field is the initialization vector (IV) for the encryption algorithm (if applicable) and is sent in clear text. The content and size of the IV MUST comply with the specification of the encryption algorithm. For example, the id-aes256-CBC algorithm MUST use a 16-byte initialization vector (IV), which MUST be unpredictable for each instance of a value of data type ssv_seal_plain_tkn4 that is encrypted with a particular SSV key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ssct_ivフィールドは、暗号化アルゴリズム（該当する場合）の初期化ベクトル（IV）であり、クリアテキストで送信されます。 IVのコンテンツとサイズは、暗号化アルゴリズムの仕様に準拠する必要があります。たとえば、id-aes256-CBCアルゴリズムは、16バイトの初期化ベクトル（IV）を使用する必要があります。これは、特定のSSVキーで暗号化されたデータ型ssv_seal_plain_tkn4の値のインスタンスごとに予測不可能でなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ssct_hmac field is the result of computing an HMAC using the value of the XDR encoded data type ssv_seal_plain_tkn4 as the input text. The key is the subkey derived from SSV4_SUBKEY_MIC_I2T or SSV4_SUBKEY_MIC_T2I, and the one-way hash algorithm is that negotiated by EXCHANGE_ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ssct_hmacフィールドは、XDRエンコードされたデータ型ssv_seal_plain_tkn4の値を入力テキストとして使用してHMACを計算した結果です。キーはSSV4_SUBKEY_MIC_I2TまたはSSV4_SUBKEY_MIC_T2Iから派生したサブキーであり、一方向ハッシュアルゴリズムはEXCHANGE_IDによってネゴシエートされたものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sspt_confounder field is a random value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sspt_confounderフィールドはランダムな値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sspt_ssv_seq field is the same as ssvt_ssv_seq.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sspt_ssv_seqフィールドはssvt_ssv_seqと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The field sspt_orig_plain field is the original plaintext and is the &#34;input_message&#34; input passed to GSS_Wrap() (see Section 2.3.3 of [7]). As with the handling of the plaintext by the SSV mechanism&#39;s GSS_GetMIC() entry point, the entry point for GSS_Wrap() expects a pointer to the plaintext, and will XDR encode an opaque array into sspt_orig_plain representing the plain text, along with the other fields of an instance of data type ssv_seal_plain_tkn4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドsspt_orig_plainフィールドは元の平文であり、GSS_Wrap()に渡される「input_message」入力です（[7]のセクション2.3.3を参照）。 SSVメカニズムのGSS_GetMIC()エントリポイントによるプレーンテキストの処理と同様に、GSS_Wrap()のエントリポイントはプレーンテキストへのポインタを予期し、XDRは不透明な配列をプレーンテキストを表すsspt_orig_plainにエンコードします。データ型ssv_seal_plain_tkn4のインスタンスの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sspt_pad field is present to support encryption algorithms that require inputs to be in fixed-sized blocks. The content of sspt_pad is zero filled except for the length. Beware that the XDR encoding of ssv_seal_plain_tkn4 contains three variable-length arrays, and so each array consumes four bytes for an array length, and each array that follows the length is always padded to a multiple of four bytes per the XDR standard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sspt_padフィールドは、入力を固定サイズのブロックにする必要がある暗号化アルゴリズムをサポートするために存在します。 sspt_padの内容は、長さを除いてゼロで埋められます。 ssv_seal_plain_tkn4のXDRエンコーディングには3つの可変長配列が含まれているため、各配列は配列の長さとして4バイトを消費し、長さに続く各配列はXDR標準に従って常に4バイトの倍数にパディングされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, suppose the encryption algorithm uses 16-byte blocks, and the sspt_confounder is three bytes long, and the sspt_orig_plain field is 15 bytes long. The XDR encoding of sspt_confounder uses eight bytes (4 + 3 + 1 byte pad), the XDR encoding of sspt_ssv_seq uses four bytes, the XDR encoding of sspt_orig_plain uses 20 bytes (4 + 15 + 1 byte pad), and the smallest XDR encoding of the sspt_pad field is four bytes. This totals 36 bytes. The next multiple of 16 is 48; thus, the length field of sspt_pad needs to be set to 12 bytes, or a total encoding of 16 bytes. The total number of XDR encoded bytes is thus 8 + 4 + 20 + 16 = 48.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、暗号化アルゴリズムが16バイトのブロックを使用し、sspt_confounderが3バイトの長さで、sspt_orig_plainフィールドが15バイトの長さであるとします。 sspt_confounderのXDRエンコーディングは8バイト（4 + 3 + 1バイトパッド）を使用し、sspt_ssv_seqのXDRエンコーディングは4バイトを使用し、sspt_orig_plainのXDRエンコーディングは20バイト（4 + 15 + 1バイトパッド）を使用し、最小のXDRエンコーディングsspt_padフィールドの4バイトです。これは合計36バイトです。次の16の倍数は48です。したがって、sspt_padの長さフィールドは、12バイト、または合計16バイトのエンコードに設定する必要があります。したがって、XDRエンコードされたバイトの総数は8 + 4 + 20 + 16 = 48です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GSS_Wrap() emits a token that is an XDR encoding of a value of data type ssv_seal_cipher_tkn4. Note that regardless of whether or not the caller of GSS_Wrap() requests confidentiality, the token always has confidentiality. This is because the SSV mechanism is for RPCSEC_GSS, and RPCSEC_GSS never produces GSS_wrap() tokens without confidentiality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GSS_Wrap()は、データ型ssv_seal_cipher_tkn4の値のXDRエンコーディングであるトークンを発行します。 GSS_Wrap()の呼び出し元が機密性を要求するかどうかに関係なく、トークンには常に機密性があることに注意してください。これは、SSVメカニズムがRPCSEC_GSS用であり、RPCSEC_GSSが機密性なしにGSS_wrap()トークンを生成することはないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is one SSV per client ID. There is a single GSS context for a client ID / SSV pair. All SSV mechanism RPCSEC_GSS handles of a client ID / SSV pair share the same GSS context. SSV GSS contexts do not expire except when the SSV is destroyed (causes would include the client ID being destroyed or a server restart). Since one purpose of context expiration is to replace keys that have been in use for &#34;too long&#34;, hence vulnerable to compromise by brute force or accident, the client can replace the SSV key by sending periodic SET_SSV operations, which is done by cycling through different users&#39; RPCSEC_GSS credentials. This way, the SSV is replaced without destroying the SSV&#39;s GSS contexts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントIDごとに1つのSSVがあります。クライアントIDとSSVのペアには、単一のGSSコンテキストがあります。すべてのSSVメカニズム、クライアントID / SSVペアのRPCSEC_GSSハンドルは、同じGSSコンテキストを共有します。 SSV GSSコンテキストは、SSVが破棄された場合を除いて期限切れになりません（原因としては、クライアントIDの破棄またはサーバーの再起動が含まれます）。コンテキストの有効期限の目的の1つは、「長すぎる」ために使用されていたキーを置き換えることであり、ブルートフォースや事故による侵害に対して脆弱であるため、クライアントは定期的なSET_SSV操作を送信してSSVキーを置き換えることができます。異なるユーザーのRPCSEC_GSS資格。このようにして、SSVは、SSVのGSSコンテキストを破壊することなく置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSV RPCSEC_GSS handles can be expired or deleted by the server at any time, and the EXCHANGE_ID operation can be used to create more SSV RPCSEC_GSS handles. Expiration of SSV RPCSEC_GSS handles does not imply that the SSV or its GSS context has expired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSV RPCSEC_GSSハンドルはサーバーによっていつでも期限切れまたは削除でき、EXCHANGE_ID操作を使用してさらにSSV RPCSEC_GSSハンドルを作成できます。 SSV RPCSEC_GSSハンドルの期限切れは、SSVまたはそのGSSコンテキストが期限切れであることを意味しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MUST establish an SSV via SET_SSV before the SSV GSS context can be used to emit tokens from GSS_Wrap() and GSS_GetMIC(). If SET_SSV has not been successfully called, attempts to emit tokens MUST fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、SSV GSSコンテキストを使用してGSS_Wrap()およびGSS_GetMIC()からトークンを発行する前に、SET_SSVを介してSSVを確立する必要があります。 SET_SSVが正常に呼び出されなかった場合、トークンを発行する試みは失敗する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SSV mechanism does not support replay detection and sequencing in its tokens because RPCSEC_GSS does not use those features (See Section 5.2.2, &#34;Context Creation Requests&#34;, in [4]). However, Section 2.10.10 discusses special considerations for the SSV mechanism when used with RPCSEC_GSS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSSはこれらの機能を使用しないため、SSVメカニズムはトークンのリプレイ検出とシーケンスをサポートしていません（[4]の5.2.2節「コンテキスト作成リクエスト」を参照）。ただし、セクション2.10.10では、RPCSEC_GSSと共に使用する場合のSSVメカニズムの特別な考慮事項について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.10.10. Security Considerations for RPCSEC_GSS When Using the SSV Mechanism
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.10.10. SSVメカニズムを使用する場合のRPCSEC_GSSのセキュリティに関する考慮事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client ID is created with SP4_SSV state protection (see Section 18.35), the client is permitted to associate multiple RPCSEC_GSS handles with the single SSV GSS context (see Section 2.10.9). Because of the way RPCSEC_GSS (both version 1 and version 2, see [4] and [12]) calculate the verifier of the reply, special care must be taken by the implementation of the NFSv4.1 client to prevent attacks by a man-in-the-middle. The verifier of an RPCSEC_GSS reply is the output of GSS_GetMIC() applied to the input value of the seq_num field of the RPCSEC_GSS credential (data type rpc_gss_cred_ver_1_t) (see Section 5.3.3.2 of [4]). If multiple RPCSEC_GSS handles share the same GSS context, then if one handle is used to send a request with the same seq_num value as another handle, an attacker could block the reply, and replace it with the verifier used for the other handle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントIDがSP4_SSV状態保護（セクション18.35を参照）で作成されると、クライアントは複数のRPCSEC_GSSハンドルを単一のSSV GSSコンテキストに関連付けることが許可されます（セクション2.10.9を参照）。 RPCSEC_GSS（バージョン1とバージョン2の両方）が応答のベリファイアを計算する方法のため、NFSv4.1クライアントの実装では、人による攻撃を防ぐために特別な注意が必要です途中で。 RPCSEC_GSS応答のベリファイアは、RPCSEC_GSSクレデンシャルのseq_numフィールドの入力値に適用されるGSS_GetMIC()の出力です（データ型rpc_gss_cred_ver_1_t）（[4]のセクション5.3.3.2を参照）。複数のRPCSEC_GSSハンドルが同じGSSコンテキストを共有している場合、1つのハンドルを使用して別のハンドルと同じseq_num値のリクエストを送信すると、攻撃者は応答をブロックし、それを他のハンドルに使用されているベリファイアに置き換える可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are multiple ways to prevent the attack on the SSV RPCSEC_GSS verifier in the reply. The simplest is believed to be as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答のSSV RPCSEC_GSSベリファイアへの攻撃を防ぐ方法はいくつかあります。最も単純なものは次のように考えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Each time one or more new SSV RPCSEC_GSS handles are created via EXCHANGE_ID, the client SHOULD send a SET_SSV operation to modify the SSV. By changing the SSV, the new handles will not result in the re-use of an SSV RPCSEC_GSS verifier in a reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o EXCHANGE_IDを介して1つ以上の新しいSSV RPCSEC_GSSハンドルが作成されるたびに、クライアントは、SET_SSV操作を送信してSSVを変更する必要があります（SHOULD）。 SSVを変更することにより、新しいハンドルは応答でSSV RPCSEC_GSS検証を再利用しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a requester decides to use N SSV RPCSEC_GSS handles, it SHOULD assign a unique and non-overlapping range of seq_nums to each SSV RPCSEC_GSS handle. The size of each range SHOULD be equal to MAXSEQ / N (see Section 5 of [4] for the definition of MAXSEQ). When an SSV RPCSEC_GSS handle reaches its maximum, it SHOULD force the replier to destroy the handle by sending a NULL RPC request with seq_num set to MAXSEQ + 1 (see Section 5.3.3.3 of [4]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o リクエスターがN個のSSV RPCSEC_GSSハンドルを使用することを決定すると、seq_numsの一意で重複しない範囲を各SSV RPCSEC_GSSハンドルに割り当てる必要があります（SHOULD）。各範囲のサイズは、MAXSEQ / Nに等しい必要があります（MAXSEQの定義については、[4]のセクション5を参照してください）。 SSV RPCSEC_GSSハンドルが最大値に達すると、seq_numをMAXSEQ + 1に設定してNULL RPC要求を送信することにより、応答者にハンドルを破棄するよう強制する必要があります（[4]のセクション5.3.3.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the requester wants to increase or decrease N, it SHOULD force the replier to destroy all N handles by sending a NULL RPC request on each handle with seq_num set to MAXSEQ + 1. If the requester is the client, it SHOULD send a SET_SSV operation before using new handles. If the requester is the server, then the client SHOULD send a SET_SSV operation when it detects that the server has forced it to destroy a backchannel&#39;s SSV RPCSEC_GSS handle. By sending a SET_SSV operation, the SSV will change, and so the attacker will be unavailable to successfully replay a previous verifier in a reply to the requester.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o リクエスターがNを増やしたり減らしたりしたい場合は、seq_numがMAXSEQ + 1に設定された各ハンドルでNULL RPC要求を送信することにより、リプライアーにすべてのNハンドルを強制的に破棄する必要があります（SHOULD）。リクエスターがクライアントの場合、SET_SSV操作を送信する必要があります（SHOULD）。新しいハンドルを使用する前。リクエスターがサーバーである場合、クライアントは、サーバーがバックチャネルのSSV RPCSEC_GSSハンドルの破棄を強制したことを検出したときに、SET_SSV操作を送信する必要があります（SHOULD）。 SET_SSV操作を送信することにより、SSVが変更されるため、攻撃者はリクエスターへの応答で以前のベリファイアを正常に再生できなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if the replier carefully creates the SSV RPCSEC_GSS handles, the related risk of a man-in-the-middle splicing a forged SSV RPCSEC_GSS credential with a verifier for another handle does not exist. This is because the verifier in an RPCSEC_GSS request is computed from input that includes both the RPCSEC_GSS handle and seq_num (see Section 5.3.1 of [4]). Provided the replier takes care to avoid re-using the value of an RPCSEC_GSS handle that it creates, such as by including a generation number in the handle, the man-in-the-middle will not be able to successfully replay a previous verifier in the request to a replier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
返信者がSSV RPCSEC_GSSハンドルを慎重に作成した場合、中間者が偽造SSV RPCSEC_GSS資格情報を別のハンドルのベリファイアとスプライスするという関連するリスクは存在しないことに注意してください。これは、RPCSEC_GSS要求のベリファイアが、RPCSEC_GSSハンドルとseq_numの両方を含む入力から計算されるためです（[4]のセクション5.3.1を参照）。応答番号が生成するRPCSEC_GSSハンドルの値を再利用しないように注意する場合（ハンドルに世代番号を含めるなど）、中間者は以前の検証を正常に再生できません返信者へのリクエスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-11--Session-Mechanics---Steady-State">
2.10.11. Session Mechanics - Steady State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.11. セッションの仕組み-定常状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-11-1--Obligations-of-the-Server">
2.10.11.1. Obligations of the Server
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.11.1. サーバーの義務
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server has the primary obligation to monitor the state of backchannel resources that the client has created for the server (RPCSEC_GSS contexts and backchannel connections). If these resources vanish, the server takes action as specified in Section 2.10.13.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーには、クライアントがサーバー用に作成したバックチャネルリソースの状態（RPCSEC_GSSコンテキストとバックチャネル接続）を監視する主要な義務があります。これらのリソースが消失すると、サーバーはセクション2.10.13.2で指定されたアクションを実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-11-2--Obligations-of-the-Client">
2.10.11.2. Obligations of the Client
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.11.2. クライアントの義務
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client SHOULD honor the following obligations in order to utilize the session:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、セッションを利用するために以下の義務を尊重する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Keep a necessary session from going idle on the server. A client that requires a session but nonetheless is not sending operations risks having the session be destroyed by the server. This is because sessions consume resources, and resource limitations may force the server to cull an inactive session. A server MAY consider a session to be inactive if the client has not used the session before the session inactivity timer (Section 2.10.12) has expired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーで必要なセッションがアイドル状態にならないようにします。セッションを必要とするがそれでも操作を送信していないクライアントは、サーバーによってセッションが破壊されるリスクがあります。これは、セッションがリソースを消費するためであり、リソースの制限により、サーバーが非アクティブなセッションを強制的に削除する可能性があります。セッション非アクティブタイマー（2.10.12項）が期限切れになる前にクライアントがセッションを使用しなかった場合、サーバーはセッションを非アクティブと見なしてもよい（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Destroy the session when not needed. If a client has multiple sessions, one of which has no requests waiting for replies, and has been idle for some period of time, it SHOULD destroy the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 不要なときにセッションを破棄します。クライアントに複数のセッションがあり、そのうちの1つに応答を待つ要求がなく、一定期間アイドル状態であった場合、セッションを破棄する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Maintain GSS contexts and RPCSEC_GSS handles for the backchannel. If the client requires the server to use the RPCSEC_GSS security flavor for callbacks, then it needs to be sure the RPCSEC_GSS handles and/or their GSS contexts that are handed to the server via BACKCHANNEL_CTL or CREATE_SESSION are unexpired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バックチャネルのGSSコンテキストとRPCSEC_GSSハンドルを維持します。クライアントがサーバーにコールバックにRPCSEC_GSSセキュリティフレーバーを使用することを要求する場合、BACKCHANNEL_CTLまたはCREATE_SESSIONを介してサーバーに渡されるRPCSEC_GSSハンドルまたはGSSコンテキスト、あるいはその両方が期限切れになっていないことを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Preserve a connection for a backchannel. The server requires a backchannel in order to gracefully recall recallable state or notify the client of certain events. Note that if the connection is not being used for the fore channel, there is no way for the client to tell if the connection is still alive (e.g., the server restarted without sending a disconnect). The onus is on the server, not the client, to determine if the backchannel&#39;s connection is alive, and to indicate in the response to a SEQUENCE operation when the last connection associated with a session&#39;s backchannel has disconnected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バックチャネルの接続を保持します。サーバーは、再呼び出し可能な状態を適切に呼び出したり、特定のイベントをクライアントに通知したりするためにバックチャネルを必要とします。接続がフォアチャネルに使用されていない場合、クライアントが接続がまだ生きているかどうかを確認する方法がないことに注意してください（たとえば、サーバーは切断を送信せずに再起動しました）。責任はクライアントではなくサーバー上にあり、バックチャネルの接続が有効かどうかを判断し、SEQUENCE操作への応答で、セッションのバックチャネルに関連付けられた最後の接続が切断されたことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-11-3--Steps-the-Client-Takes-to-Establish-a-Session">
2.10.11.3. Steps the Client Takes to Establish a Session
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.11.3. クライアントがセッションを確立するために実行する手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client does not have a client ID, the client sends EXCHANGE_ID to establish a client ID. If it opts for SP4_MACH_CRED or SP4_SSV protection, in the spo_must_enforce list of operations, it SHOULD at minimum specify CREATE_SESSION, DESTROY_SESSION, BIND_CONN_TO_SESSION, BACKCHANNEL_CTL, and DESTROY_CLIENTID. If it opts for SP4_SSV protection, the client needs to ask for SSV-based RPCSEC_GSS handles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントにクライアントIDがない場合、クライアントはEXCHANGE_IDを送信してクライアントIDを確立します。 SP4_MACH_CREDまたはSP4_SSV保護を選択する場合は、操作のspo_must_enforceリストで、最低でもCREATE_SESSION、DESTROY_SESSION、BIND_CONN_TO_SESSION、BACKCHANNEL_CTL、およびDESTROY_CLIENTIDを指定する必要があります。 SP4_SSV保護を選択する場合、クライアントはSSVベースのRPCSEC_GSSハンドルを要求する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client uses the client ID to send a CREATE_SESSION on a connection to the server. The results of CREATE_SESSION indicate whether or not the server will persist the session reply cache through a server that has restarted, and the client notes this for future reference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはクライアントIDを使用して、サーバーへの接続でCREATE_SESSIONを送信します。 CREATE_SESSIONの結果は、サーバーが再起動したサーバーを介してセッション応答キャッシュを永続化するかどうかを示し、クライアントはこれを後で参照できるようにメモします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client specified SP4_SSV state protection when the client ID was created, then it SHOULD send SET_SSV in the first COMPOUND after the session is created. Each time a new principal goes to use the client ID, it SHOULD send a SET_SSV again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントIDの作成時にクライアントがSP4_SSV状態保護を指定した場合、セッションの作成後、最初のCOMPOUNDでSET_SSVを送信する必要があります（SHOULD）。新しいプリンシパルがクライアントIDを使用するたびに、再度SET_SSVを送信する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client wants to use delegations, layouts, directory notifications, or any other state that requires a backchannel, then it needs to add a connection to the backchannel if CREATE_SESSION did not already do so. The client creates a connection, and calls BIND_CONN_TO_SESSION to associate the connection with the session and the session&#39;s backchannel. If CREATE_SESSION did not already do so, the client MUST tell the server what security is required in order for the client to accept callbacks. The client does this via BACKCHANNEL_CTL. If the client selected SP4_MACH_CRED or SP4_SSV protection when it called EXCHANGE_ID, then the client SHOULD specify that the backchannel use RPCSEC_GSS contexts for security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが委任、レイアウト、ディレクトリ通知、またはバックチャネルを必要とするその他の状態を使用する場合、CREATE_SESSIONがまだそうしていない場合は、バックチャネルへの接続を追加する必要があります。クライアントは接続を作成し、BIND_CONN_TO_SESSIONを呼び出して、接続をセッションおよびセッションのバックチャネルに関連付けます。 CREATE_SESSIONがまだ行っていない場合、クライアントは、クライアントがコールバックを受け入れるために必要なセキュリティをサーバーに通知する必要があります。クライアントはBACKCHANNEL_CTLを介してこれを行います。クライアントがEXCHANGE_IDを呼び出したときにSP4_MACH_CREDまたはSP4_SSV保護を選択した場合、クライアントはバックチャネルがセキュリティのためにRPCSEC_GSSコンテキストを使用することを指定する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client wants to use additional connections for the backchannel, then it needs to call BIND_CONN_TO_SESSION on each connection it wants to use with the session. If the client wants to use additional connections for the fore channel, then it needs to call BIND_CONN_TO_SESSION if it specified SP4_SSV or SP4_MACH_CRED state protection when the client ID was created.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがバックチャネルに追加の接続を使用する場合は、セッションで使用する接続ごとにBIND_CONN_TO_SESSIONを呼び出す必要があります。クライアントがフォアチャネルに追加の接続を使用する場合、クライアントIDの作成時にSP4_SSVまたはSP4_MACH_CRED状態保護を指定した場合は、BIND_CONN_TO_SESSIONを呼び出す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At this point, the session has reached steady state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この時点で、セッションは定常状態に達しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-12--Session-Inactivity-Timer">
2.10.12. Session Inactivity Timer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.12. セッション非活動タイマー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MAY maintain a session inactivity timer for each session. If the session inactivity timer expires, then the server MAY destroy the session. To avoid losing a session due to inactivity, the client MUST renew the session inactivity timer. The length of session inactivity timer MUST NOT be less than the lease_time attribute (Section 5.8.1.11). As with lease renewal (Section 8.3), when the server receives a SEQUENCE operation, it resets the session inactivity timer, and MUST NOT allow the timer to expire while the rest of the operations in the COMPOUND procedure&#39;s request are still executing. Once the last operation has finished, the server MUST set the session inactivity timer to expire no sooner than the sum of the current time and the value of the lease_time attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、各セッションのセッション非アクティブタイマーを維持する場合があります。セッション非活動タイマーが期限切れになると、サーバーはセッションを破棄する場合があります。非アクティブが原因でセッションが失われないようにするために、クライアントはセッション非アクティブタイマーを更新する必要があります。セッション非活動タイマーの長さは、lease_time属性（5.8.1.11節）より短くてはなりません（MUST NOT）。リースの更新（セクション8.3）と同様に、サーバーがSEQUENCE操作を受信すると、セッション非アクティブタイマーをリセットし、COMPOUNDプロシージャのリクエスト内の残りの操作がまだ実行されている間にタイマーが期限切れにならないようにする必要があります。最後の操作が完了すると、サーバーはセッション非アクティブタイマーが現在の時間とlease_time属性の値の合計よりも早く期限切れになるように設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-13--Session-Mechanics---Recovery">
2.10.13. Session Mechanics - Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.13. セッションの仕組み-回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-13-1--Events-Requiring-Client-Action">
2.10.13.1. Events Requiring Client Action
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.13.1. クライアントのアクションが必要なイベント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following events require client action to recover.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のイベントを回復するには、クライアントのアクションが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-13-1-1--RPCSECGSS-Context-Loss-by-Callback-Path">
2.10.13.1.1. RPCSEC_GSS Context Loss by Callback Path
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.13.1.1. コールバックパスによるRPCSEC_GSSコンテキストの損失
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If all RPCSEC_GSS handles granted by the client to the server for callback use have expired, the client MUST establish a new handle via BACKCHANNEL_CTL. The sr_status_flags field of the SEQUENCE results indicates when callback handles are nearly expired, or fully expired (see Section 18.46.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コールバック用にクライアントからサーバーに付与されたすべてのRPCSEC_GSSハンドルが期限切れになった場合、クライアントはBACKCHANNEL_CTLを介して新しいハンドルを確立する必要があります。 SEQUENCE結果のsr_status_flagsフィールドは、コールバックハンドルがほぼ期限切れになるか、完全に期限切れになる時期を示します（セクション18.46.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-13-1-2--Connection-Loss">
2.10.13.1.2. Connection Loss
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.13.1.2. 接続の喪失
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client loses the last connection of the session and wants to retain the session, then it needs to create a new connection, and if, when the client ID was created, BIND_CONN_TO_SESSION was specified in the spo_must_enforce list, the client MUST use BIND_CONN_TO_SESSION to associate the connection with the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがセッションの最後の接続を失い、セッションを保持したい場合、クライアントは新しい接続を作成する必要があり、クライアントIDが作成されたときにBIND_CONN_TO_SESSIONがspo_must_enforceリストで指定されていた場合、クライアントはBIND_CONN_TO_SESSIONを使用して接続をセッションに関連付けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there was a request outstanding at the time of connection loss, then if the client wants to continue to use the session, it MUST retry the request, as described in Section 2.10.6.2. Note that it is not necessary to retry requests over a connection with the same source network address or the same destination network address as the lost connection. As long as the session ID, slot ID, and sequence ID in the retry match that of the original request, the server will recognize the request as a retry if it executed the request prior to disconnect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続が失われたときに未処理の要求があった場合、クライアントがセッションの使用を続けたい場合は、2.10.6.2で説明されているように、要求を再試行する必要があります。失われた接続と同じ送信元ネットワークアドレスまたは同じ宛先ネットワークアドレスを持つ接続を介して要求を再試行する必要がないことに注意してください。再試行のセッションID、スロットID、シーケンスIDが元の要求のセッションID、スロットID、シーケンスIDと一致している限り、サーバーは、切断前に要求を実行した場合、その要求を再試行として認識します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the connection that was lost was the last one associated with the backchannel, and the client wants to retain the backchannel and/or prevent revocation of recallable state, the client needs to reconnect, and if it does, it MUST associate the connection to the session and backchannel via BIND_CONN_TO_SESSION. The server SHOULD indicate when it has no callback connection via the sr_status_flags result from SEQUENCE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
失われた接続がバックチャネルに関連付けられた最後の接続であり、クライアントがバックチャネルを保持したり、呼び出し可能状態の取り消しを防止したりする場合、クライアントは再接続する必要があります。再接続する場合は、接続をBIND_CONN_TO_SESSIONを介したセッションとバックチャネル。サーバーは、SEQUENCEの結果であるsr_status_flagsを介して、コールバック接続がない場合を示す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-13-1-3--Backchannel-GSS-Context-Loss">
2.10.13.1.3. Backchannel GSS Context Loss
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.13.1.3. バックチャネルGSSコンテキストの損失
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Via the sr_status_flags result of the SEQUENCE operation or other means, the client will learn if some or all of the RPCSEC_GSS contexts it assigned to the backchannel have been lost. If the client wants to retain the backchannel and/or not put recallable state subject to revocation, the client needs to use BACKCHANNEL_CTL to assign new contexts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQUENCE操作またはその他の手段のsr_status_flags結果を介して、クライアントは、バックチャネルに割り当てられたRPCSEC_GSSコンテキストの一部またはすべてが失われたかどうかを学習します。クライアントがバックチャネルを保持したり、取り消しの対象となる再呼び出し可能な状態にしたくない場合、クライアントはBACKCHANNEL_CTLを使用して新しいコンテキストを割り当てる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-13-1-4--Loss-of-Session">
2.10.13.1.4. Loss of Session
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.13.1.4. セッションの喪失
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The replier might lose a record of the session. Causes include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
返信者はセッションの記録を失う可能性があります。原因は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Replier failure and restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o リプライヤの失敗と再起動。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A catastrophe that causes the reply cache to be corrupted or lost on the media on which it was stored. This applies even if the replier indicated in the CREATE_SESSION results that it would persist the cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 格納されたメディアで応答キャッシュが破損または失われるような大災害。これは、CREATE_SESSIONに示されている返信者がキャッシュを永続化する結果になった場合でも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server purges the session of a client that has been inactive for a very extended period of time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、長期間非アクティブであったクライアントのセッションを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o As a result of configuration changes among a set of clustered servers, a network address previously connected to one server becomes connected to a different server that has no knowledge of the session in question. Such a configuration change will generally only happen when the original server ceases to function for a time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クラスター化されたサーバーのセット間の構成変更の結果、以前に1つのサーバーに接続されていたネットワークアドレスが、問題のセッションを認識していない別のサーバーに接続されます。このような構成変更は、通常、元のサーバーがしばらく機能しなくなった場合にのみ発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Loss of reply cache is equivalent to loss of session. The replier indicates loss of session to the requester by returning NFS4ERR_BADSESSION on the next operation that uses the session ID that refers to the lost session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答キャッシュの喪失は、セッションの喪失と同等です。リプライアは、失われたセッションを参照するセッションIDを使用する次の操作でNFS4ERR_BADSESSIONを返すことにより、リクエスタにセッションが失われたことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After an event like a server restart, the client may have lost its connections. The client assumes for the moment that the session has not been lost. It reconnects, and if it specified connection association enforcement when the session was created, it invokes BIND_CONN_TO_SESSION using the session ID. Otherwise, it invokes SEQUENCE. If BIND_CONN_TO_SESSION or SEQUENCE returns NFS4ERR_BADSESSION, the client knows the session is not available to it when communicating with that network address. If the connection survives session loss, then the next SEQUENCE operation the client sends over the connection will get back NFS4ERR_BADSESSION. The client again knows the session was lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの再起動などのイベントの後、クライアントが接続を失った可能性があります。クライアントは、セッションが失われていないことを想定しています。再接続し、セッションの作成時に接続の関連付けの強制を指定した場合は、セッションIDを使用してBIND_CONN_TO_SESSIONを呼び出します。それ以外の場合は、SEQUENCEを呼び出します。 BIND_CONN_TO_SESSIONまたはSEQUENCEがNFS4ERR_BADSESSIONを返す場合、クライアントは、そのネットワークアドレスと通信しているときにセッションが利用できないことを認識しています。接続がセッション損失に耐えた場合、クライアントが接続を介して送信する次のSEQUENCE操作はNFS4ERR_BADSESSIONを返します。クライアントは、セッションが失われたことを再度認識します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here is one suggested algorithm for the client when it gets NFS4ERR_BADSESSION. It is not obligatory in that, if a client does not want to take advantage of such features as trunking, it may omit parts of it. However, it is a useful example that draws attention to various possible recovery issues:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがNFS4ERR_BADSESSIONを取得する際の推奨アルゴリズムを以下に示します。クライアントがトランキングなどの機能を利用したくない場合は、その一部を省略してもかまいません。ただし、これは、考えられるさまざまな回復の問題に注意を向ける有用な例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the client has other connections to other server network addresses associated with the same session, attempt a COMPOUND with a single operation, SEQUENCE, on each of the other connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. クライアントが同じセッションに関連付けられている他のサーバーネットワークアドレスへの他の接続を持っている場合は、他の各接続で単一の操作SEQUENCEを使用してCOMPOUNDを試行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If the attempts succeed, the session is still alive, and this is a strong indicator that the server&#39;s network address has moved. The client might send an EXCHANGE_ID on the connection that returned NFS4ERR_BADSESSION to see if there are opportunities for client ID trunking (i.e., the same client ID and so_major are returned). The client might use DNS to see if the moved network address was replaced with another, so that the performance and availability benefits of session trunking can continue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 試行が成功した場合、セッションはまだ存続しており、これはサーバーのネットワークアドレスが移動したことを示す強力なインジケータです。クライアントは、NFS4ERR_BADSESSIONを返した接続でEXCHANGE_IDを送信して、クライアントIDトランキングの機会があるかどうかを確認します（つまり、同じクライアントIDとso_majorが返されます）。クライアントはDNSを使用して、移動されたネットワークアドレスが別のアドレスに置き換えられたかどうかを確認し、セッショントランキングのパフォーマンスと可用性のメリットを継続できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If the SEQUENCE requests fail with NFS4ERR_BADSESSION, then the session no longer exists on any of the server network addresses for which the client has connections associated with that session ID. It is possible the session is still alive and available on other network addresses. The client sends an EXCHANGE_ID on all the connections to see if the server owner is still listening on those network addresses. If the same server owner is returned but a new client ID is returned, this is a strong indicator of a server restart. If both the same server owner and same client ID are returned, then this is a strong indication that the server did delete the session, and the client will need to send a CREATE_SESSION if it has no other sessions for that client ID. If a different server owner is returned, the client can use DNS to find other network addresses. If it does not, or if DNS does not find any other addresses for the server, then the client will be unable to provide NFSv4.1 service, and fatal errors should be returned to processes that were using the server. If the client is using a &#34;mount&#34; paradigm, unmounting the server is advised.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. SEQUENCE要求がNFS4ERR_BADSESSIONで失敗した場合、そのセッションは、クライアントがそのセッションIDに関連付けられている接続を持つサーバーネットワークアドレスのいずれにも存在しません。セッションがまだ存続しており、他のネットワークアドレスで使用できる可能性があります。クライアントはすべての接続でEXCHANGE_IDを送信して、サーバーの所有者がそれらのネットワークアドレスをまだリッスンしているかどうかを確認します。同じサーバー所有者が返されたが、新しいクライアントIDが返された場合、これはサーバーの再起動の強力なインジケーターです。同じサーバー所有者と同じクライアントIDの両方が返された場合、これはサーバーがセッションを削除したことを強く示しており、そのクライアントIDに対して他のセッションがない場合、クライアントはCREATE_SESSIONを送信する必要があります。別のサーバー所有者が返された場合、クライアントはDNSを使用して他のネットワークアドレスを見つけることができます。そうでない場合、またはDNSがサーバーの他のアドレスを見つけられない場合、クライアントはNFSv4.1サービスを提供できず、サーバーを使用していたプロセスに致命的なエラーが返されます。クライアントが「マウント」パラダイムを使用している場合は、サーバーをアンマウントすることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If the client knows of no other connections associated with the session ID and server network addresses that are, or have been, associated with the session ID, then the client can use DNS to find other network addresses. If it does not, or if DNS does not find any other addresses for the server, then the client will be unable to provide NFSv4.1 service, and fatal errors should be returned to processes that were using the server. If the client is using a &#34;mount&#34; paradigm, unmounting the server is advised.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. クライアントが、セッションIDに関連付けられている、またはセッションIDに関連付けられている、または関連付けられているサーバーネットワークアドレスに他の接続がないことを知っている場合、クライアントはDNSを使用して他のネットワークアドレスを見つけることができます。そうでない場合、またはDNSがサーバーの他のアドレスを見つけられない場合、クライアントはNFSv4.1サービスを提供できず、サーバーを使用していたプロセスに致命的なエラーが返されます。クライアントが「マウント」パラダイムを使用している場合は、サーバーをアンマウントすることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If there is a reconfiguration event that results in the same network address being assigned to servers where the eir_server_scope value is different, it cannot be guaranteed that a session ID generated by the first will be recognized as invalid by the first. Therefore, in managing server reconfigurations among servers with different server scope values, it is necessary to make sure that all clients have disconnected from the first server before effecting the reconfiguration. Nonetheless, clients should not assume that servers will always adhere to this requirement; clients MUST be prepared to deal with unexpected effects of server reconfigurations. Even where a session ID is inappropriately recognized as valid, it is likely either that the connection will not be recognized as valid or that a sequence value for a slot will not be correct. Therefore, when a client receives results indicating such unexpected errors, the use of EXCHANGE_ID to determine the current server configuration is RECOMMENDED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
eir_server_scopeの値が異なるサーバーに同じネットワークアドレスが割り当てられる結果となる再構成イベントがある場合、最初のセッションで生成されたセッションIDが最初のセッションで無効と認識されることは保証されません。したがって、サーバースコープの値が異なるサーバー間でサーバーの再構成を管理する場合、再構成を行う前に、すべてのクライアントが最初のサーバーから切断されていることを確認する必要があります。それにもかかわらず、クライアントは、サーバーが常にこの要件に準拠すると想定するべきではありません。クライアントは、サーバーの再構成の予期しない影響に対処できるように準備する必要があります。セッションIDが有効であると不適切に認識されている場合でも、接続が有効であると認識されないか、スロットのシーケンス値が正しくない可能性があります。したがって、クライアントがこのような予期しないエラーを示す結果を受け取った場合、現在のサーバー構成を判別するためのEXCHANGE_IDの使用が推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A variation on the above is that after a server&#39;s network address moves, there is no NFSv4.1 server listening, e.g., no listener on port 2049. In this example, one of the following occur: the NFSv4 server returns NFS4ERR_MINOR_VERS_MISMATCH, the NFS server returns a PROG_MISMATCH error, the RPC listener on 2049 returns PROG_UNVAIL, or attempts to reconnect to the network address timeout. These SHOULD be treated as equivalent to SEQUENCE returning NFS4ERR_BADSESSION for these purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のバリエーションは、サーバーのネットワークアドレスが移動した後、NFSv4.1サーバーがリッスンしていない、たとえばポート2049にリスナーがないなどです。この例では、NFSv4サーバーがNFS4ERR_MINOR_VERS_MISMATCHを返し、NFSサーバーがPROG_MISMATCHエラーを返すか、2049のRPCリスナーがPROG_UNVAILを返すか、ネットワークアドレスタイムアウトへの再接続を試みます。これらは、これらの目的でNFS4ERR_BADSESSIONを返すSEQUENCEと同等に扱われる必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client detects session loss, it needs to call CREATE_SESSION to recover. Any non-idempotent operations that were in progress might have been performed on the server at the time of session loss. The client has no general way to recover from this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがセッションの損失を検出すると、クライアントはCREATE_SESSIONを呼び出して回復する必要があります。進行中の非べき等でない操作は、セッションが失われたときにサーバー上で実行された可能性があります。クライアントには、これから回復する一般的な方法はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that loss of session does not imply loss of byte-range lock, open, delegation, or layout state because locks, opens, delegations, and layouts are tied to the client ID and depend on the client ID, not the session. Nor does loss of byte-range lock, open, delegation, or layout state imply loss of session state, because the session depends on the client ID; loss of client ID however does imply loss of session, byte-range lock, open, delegation, and layout state. See Section 8.4.2. A session can survive a server restart, but lock recovery may still be needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック、オープン、委任、およびレイアウトはクライアントIDに関連付けられており、セッションではなくクライアントIDに依存しているため、セッションの喪失は、バイト範囲のロック、オープン、委任、またはレイアウト状態の喪失を意味しないことに注意してください。また、セッションがクライアントIDに依存しているため、バイト範囲のロック、オープン、委任、またはレイアウトの状態の損失は、セッション状態の損失を意味しません。ただし、クライアントIDの損失は、セッション、バイト範囲ロック、オープン、委任、およびレイアウト状態の損失を意味します。セクション8.4.2を参照してください。セッションはサーバーの再起動後も存続できますが、ロックの回復がまだ必要な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible that CREATE_SESSION will fail with NFS4ERR_STALE_CLIENTID (e.g., the server restarts and does not preserve client ID state). If so, the client needs to call EXCHANGE_ID, followed by CREATE_SESSION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATE_SESSIONがNFS4ERR_STALE_CLIENTIDで失敗する可能性があります（たとえば、サーバーが再起動し、クライアントIDの状態が保持されない）。その場合、クライアントはEXCHANGE_IDを呼び出してから、CREATE_SESSIONを呼び出す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-13-2--Events-Requiring-Server-Action">
2.10.13.2. Events Requiring Server Action
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.13.2. サーバーアクションを必要とするイベント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following events require server action to recover.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のイベントを回復するには、サーバーアクションが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-13-2-1--Client-Crash-and-Restart">
2.10.13.2.1. Client Crash and Restart
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.13.2.1. クライアントのクラッシュと再起動
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 18.35, a restarted client sends EXCHANGE_ID in such a way that it causes the server to delete any sessions it had.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション18.35で説明されているように、再起動されたクライアントは、サーバーにセッションを削除させるような方法でEXCHANGE_IDを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-13-2-2--Client-Crash-with-No-Restart">
2.10.13.2.2. Client Crash with No Restart
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.13.2.2. 再起動なしでクライアントがクラッシュする
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client crashes and never comes back, it will never send EXCHANGE_ID with its old client owner. Thus, the server has session state that will never be used again. After an extended period of time, and if the server has resource constraints, it MAY destroy the old session as well as locking state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがクラッシュして戻ってこない場合は、元のクライアント所有者にEXCHANGE_IDを送信することはありません。したがって、サーバーには、再び使用されることのないセッション状態があります。長期間経過した後、サーバーにリソースの制約がある場合は、古いセッションとロック状態が破棄される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-13-2-3--Extended-Network-Partition">
2.10.13.2.3. Extended Network Partition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.13.2.3. 拡張ネットワークパーティション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To the server, the extended network partition may be no different from a client crash with no restart (see Section 2.10.13.2.2). Unless the server can discern that there is a network partition, it is free to treat the situation as if the client has crashed permanently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーにとって、拡張ネットワークパーティションは、再起動なしのクライアントクラッシュと同じです（セクション2.10.13.2.2を参照）。サーバーがネットワークパーティションの存在を認識できない場合を除き、クライアントが永続的にクラッシュしたかのように状況を自由に扱うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-13-2-4--Backchannel-Connection-Loss">
2.10.13.2.4. Backchannel Connection Loss
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.13.2.4. バックチャネル接続の喪失
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there were callback requests outstanding at the time of a connection loss, then the server MUST retry the requests, as described in Section 2.10.6.2. Note that it is not necessary to retry requests over a connection with the same source network address or the same destination network address as the lost connection. As long as the session ID, slot ID, and sequence ID in the retry match that of the original request, the callback target will recognize the request as a retry even if it did see the request prior to disconnect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続が失われたときに未解決のコールバック要求があった場合、セクション2.1.6.2で説明されているように、サーバーは要求を再試行する必要があります。失われた接続と同じ送信元ネットワークアドレスまたは同じ宛先ネットワークアドレスを持つ接続を介して要求を再試行する必要がないことに注意してください。再試行のセッションID、スロットID、シーケンスIDが元の要求のセッションID、スロットID、シーケンスIDと一致する限り、コールバックターゲットは、切断前に要求を確認した場合でも、その要求を再試行として認識します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the connection lost is the last one associated with the backchannel, then the server MUST indicate that in the sr_status_flags field of every SEQUENCE reply until the backchannel is re-established. There are two situations, each of which uses different status flags: no connectivity for the session&#39;s backchannel and no connectivity for any session backchannel of the client. See Section 18.46 for a description of the appropriate flags in sr_status_flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
失われた接続がバックチャネルに関連付けられた最後の接続である場合、サーバーは、バックチャネルが再確立されるまで、すべてのSEQUENCE応答のsr_status_flagsフィールドでそのことを示さなければなりません（MUST）。 2つの状況があり、それぞれが異なるステータスフラグを使用します。セッションのバックチャネルへの接続がない場合と、クライアントのセッションバックチャネルへの接続がない場合です。 sr_status_flagsの適切なフラグの説明については、セクション18.46を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-13-2-5--GSS-Context-Loss">
2.10.13.2.5. GSS Context Loss
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.13.2.5. GSSコンテキストの損失
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server SHOULD monitor when the number of RPCSEC_GSS handles assigned to the backchannel reaches one, and when that one handle is near expiry (i.e., between one and two periods of lease time), and indicate so in the sr_status_flags field of all SEQUENCE replies. The server MUST indicate when all of the backchannel&#39;s assigned RPCSEC_GSS handles have expired via the sr_status_flags field of all SEQUENCE replies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、バックチャネルに割り当てられたRPCSEC_GSSハンドルの数が1に達したとき、およびその1ハンドルが満了に近づいたとき（つまり、リース期間の1と2の間）を監視し、すべてのSEQUENCE応答のsr_status_flagsフィールドにそのことを示す必要があります（SHOULD）。サーバーは、すべてのSEQUENCE応答のsr_status_flagsフィールドを介して、バックチャネルに割り当てられたすべてのRPCSEC_GSSハンドルが期限切れになったことを示す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-10-14--Parallel-NFS-and-Sessions">
2.10.14. Parallel NFS and Sessions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.14. 並列NFSおよびセッション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client and server can potentially be a non-pNFS implementation, a metadata server implementation, a data server implementation, or two or three types of implementations. The EXCHGID4_FLAG_USE_NON_PNFS, EXCHGID4_FLAG_USE_PNFS_MDS, and EXCHGID4_FLAG_USE_PNFS_DS flags (not mutually exclusive) are passed in the EXCHANGE_ID arguments and results to allow the client to indicate how it wants to use sessions created under the client ID, and to allow the server to indicate how it will allow the sessions to be used. See Section 13.1 for pNFS sessions considerations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーは、非pNFS実装、メタデータサーバー実装、データサーバー実装、または2つか3つのタイプの実装になる可能性があります。 EXCHGID4_FLAG_USE_NON_PNFS、EXCHGID4_FLAG_USE_PNFS_MDS、およびEXCHGID4_FLAG_USE_PNFS_DSフラグ（相互に排他的ではない）は、EXCHANGE_ID引数と結果で渡され、クライアントがクライアントIDで作成されたセッションをどのように使用するかを示し、サーバーがどのようにサーバーを許可できるかを示します。使用するセッション。 pNFSセッションの考慮事項については、セクション13.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Protocol-Constants-and-Data-Types">
3. Protocol Constants and Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. プロトコル定数とデータ型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The syntax and semantics to describe the data types of the NFSv4.1 protocol are defined in the XDR RFC 4506 [2] and RPC RFC 5531 [3] documents. The next sections build upon the XDR data types to define constants, types, and structures specific to this protocol. The full list of XDR data types is in [13].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1プロトコルのデータ型を記述するための構文とセマンティクスは、XDR RFC 4506 [2]およびRPC RFC 5531 [3]のドキュメントで定義されています。次のセクションでは、XDRデータ型に基づいて、このプロトコルに固有の定数、型、および構造を定義します。 XDRデータ型の完全なリストは[13]にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Basic-Constants">
3.1. Basic Constants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 基本定数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const NFS4_FHSIZE               = 128;
   const NFS4_VERIFIER_SIZE        = 8;
   const NFS4_OPAQUE_LIMIT         = 1024;
   const NFS4_SESSIONID_SIZE       = 16;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const NFS4_INT64_MAX            = 0x7fffffffffffffff;
   const NFS4_UINT64_MAX           = 0xffffffffffffffff;
   const NFS4_INT32_MAX            = 0x7fffffff;
   const NFS4_UINT32_MAX           = 0xffffffff;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const NFS4_MAXFILELEN           = 0xffffffffffffffff;
   const NFS4_MAXFILEOFF           = 0xfffffffffffffffe;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Except where noted, all these constants are defined in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に記載のない限り、これらの定数はすべてバイト単位で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_FHSIZE is the maximum size of a filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_FHSIZEは、ファイルハンドルの最大サイズです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_VERIFIER_SIZE is the fixed size of a verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_VERIFIER_SIZEは、ベリファイアの固定サイズです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_OPAQUE_LIMIT is the maximum size of certain opaque information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_OPAQUE_LIMITは、特定の不透明な情報の最大サイズです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_SESSIONID_SIZE is the fixed size of a session identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_SESSIONID_SIZEは、セッション識別子の固定サイズです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_INT64_MAX is the maximum value of a signed 64-bit integer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_INT64_MAXは、符号付き64ビット整数の最大値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_UINT64_MAX is the maximum value of an unsigned 64-bit integer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_UINT64_MAXは、符号なし64ビット整数の最大値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_INT32_MAX is the maximum value of a signed 32-bit integer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_INT32_MAXは、符号付き32ビット整数の最大値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_UINT32_MAX is the maximum value of an unsigned 32-bit integer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_UINT32_MAXは、符号なし32ビット整数の最大値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_MAXFILELEN is the maximum length of a regular file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_MAXFILELENは、通常のファイルの最大長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_MAXFILEOFF is the maximum offset into a regular file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4_MAXFILEOFFは、通常のファイルへの最大オフセットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--Basic-Data-Types">
3.2. Basic Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 基本的なデータ型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These are the base NFSv4.1 data types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらは、基本のNFSv4.1データ型です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +---------------+---------------------------------------------------+
   | Data Type     | Definition                                        |
   +---------------+---------------------------------------------------+
   | int32_t       | typedef int int32_t;                              |
   | uint32_t      | typedef unsigned int uint32_t;                    |
   | int64_t       | typedef hyper int64_t;                            |
   | uint64_t      | typedef unsigned hyper uint64_t;                  |
   | attrlist4     | typedef opaque attrlist4&lt;&gt;;                       |
   |               | Used for file/directory attributes.               |
   | bitmap4       | typedef uint32_t bitmap4&lt;&gt;;                       |
   |               | Used in attribute array encoding.                 |
   | changeid4     | typedef uint64_t changeid4;                       |
   |               | Used in the definition of change_info4.           |
   | clientid4     | typedef uint64_t clientid4;                       |
   |               | Shorthand reference to client identification.     |
   | count4        | typedef uint32_t count4;                          |
   |               | Various count parameters (READ, WRITE, COMMIT).   |
   | length4       | typedef uint64_t length4;                         |
   |               | The length of a byte-range within a file.         |
   | mode4         | typedef uint32_t mode4;                           |
   |               | Mode attribute data type.                         |
   | nfs_cookie4   | typedef uint64_t nfs_cookie4;                     |
   |               | Opaque cookie value for READDIR.                  |
   | nfs_fh4       | typedef opaque nfs_fh4&lt;NFS4_FHSIZE&gt;;              |
   |               | Filehandle definition.                            |
   | nfs_ftype4    | enum nfs_ftype4;                                  |
   |               | Various defined file types.                       |
   | nfsstat4      | enum nfsstat4;                                    |
   |               | Return value for operations.                      |
   | offset4       | typedef uint64_t offset4;                         |
   |               | Various offset designations (READ, WRITE, LOCK,   |
   |               | COMMIT).                                          |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | qop4          | typedef uint32_t qop4;                            |
   |               | Quality of protection designation in SECINFO.     |
   | sec_oid4      | typedef opaque sec_oid4&lt;&gt;;                        |
   |               | Security Object Identifier.  The sec_oid4 data    |
   |               | type is not really opaque.  Instead, it contains  |
   |               | an ASN.1 OBJECT IDENTIFIER as used by GSS-API in  |
   |               | the mech_type argument to GSS_Init_sec_context.   |
   |               | See [7] for details.                              |
   | sequenceid4   | typedef uint32_t sequenceid4;                     |
   |               | Sequence number used for various session          |
   |               | operations (EXCHANGE_ID, CREATE_SESSION,          |
   |               | SEQUENCE, CB_SEQUENCE).                           |
   | seqid4        | typedef uint32_t seqid4;                          |
   |               | Sequence identifier used for locking.             |
   | sessionid4    | typedef opaque sessionid4[NFS4_SESSIONID_SIZE];   |
   |               | Session identifier.                               |
   | slotid4       | typedef uint32_t slotid4;                         |
   |               | Sequencing artifact for various session           |
   |               | operations (SEQUENCE, CB_SEQUENCE).               |
   | utf8string    | typedef opaque utf8string&lt;&gt;;                      |
   |               | UTF-8 encoding for strings.                       |
   | utf8str_cis   | typedef utf8string utf8str_cis;                   |
   |               | Case-insensitive UTF-8 string.                    |
   | utf8str_cs    | typedef utf8string utf8str_cs;                    |
   |               | Case-sensitive UTF-8 string.                      |
   | utf8str_mixed | typedef utf8string utf8str_mixed;                 |
   |               | UTF-8 strings with a case-sensitive prefix and a  |
   |               | case-insensitive suffix.                          |
   | component4    | typedef utf8str_cs component4;                    |
   |               | Represents pathname components.                   |
   | linktext4     | typedef utf8str_cs linktext4;                     |
   |               | Symbolic link contents (&#34;symbolic link&#34; is        |
   |               | defined in an Open Group [Section 3.372 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232&#34;&#34;&gt;14] standard).          |
   | pathname4     | typedef component4 pathname4&lt;&gt;;                   |
   |               | Represents pathname for fs_locations.             |
   | verifier4     | typedef opaque verifier4[NFS4_VERIFIER_SIZE];     |
   |               | Verifier used for various operations (COMMIT,     |
   |               | CREATE, EXCHANGE_ID, OPEN, READDIR, WRITE)        |
   |               | NFS4_VERIFIER_SIZE is defined as 8.               |
   +---------------+---------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-26">
End of Base Data Types
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-26">
基本データ型の終わり
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Table 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
表1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--Structured-Data-Types">
3.3. Structured Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 構造化データタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-1--nfstime4">
3.3.1. nfstime4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. nfstime4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfstime4 {
           int64_t         seconds;
           uint32_t        nseconds;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfstime4 data type gives the number of seconds and nanoseconds since midnight or zero hour January 1, 1970 Coordinated Universal Time (UTC). Values greater than zero for the seconds field denote dates after the zero hour January 1, 1970. Values less than zero for the seconds field denote dates before the zero hour January 1, 1970. In both cases, the nseconds field is to be added to the seconds field for the final time representation. For example, if the time to be represented is one-half second before zero hour January 1, 1970, the seconds field would have a value of negative one (-1) and the nseconds field would have a value of one-half second (500000000). Values greater than 999,999,999 for nseconds are invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfstime4データ型は、1970年1月1日の午前0時またはゼロ時からの秒数およびナノ秒数を示します。協定世界時（UTC）。秒フィールドのゼロより大きい値は、1970年1月1日のゼロ時より後の日付を示します。秒フィールドのゼロより小さい値は、1970年1月1日のゼロ時より前の日付を示します。どちらの場合も、n秒フィールドが追加されます。最終時刻表現の秒フィールド。たとえば、表現される時間が1970年1月1日の0時間前の0.5秒である場合、秒フィールドの値は負の1（-1）になり、n秒フィールドの値は0.5秒（ 500000000）。 n秒の999,999,999より大きい値は無効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data type is used to pass time and date information. A server converts to and from its local representation of time when processing time values, preserving as much accuracy as possible. If the precision of timestamps stored for a file system object is less than defined, loss of precision can occur. An adjunct time maintenance protocol is RECOMMENDED to reduce client and server time skew.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータ型は、日時情報を渡すために使用されます。サーバーは、時間値を処理するときに、時間のローカル表現との間で変換を行い、可能な限り正確さを維持します。ファイルシステムオブジェクトに格納されているタイムスタンプの精度が定義されている精度よりも低い場合、精度が失われる可能性があります。付属の時間保守プロトコルは、クライアントとサーバーの時間のずれを減らすために推奨されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-2--timehow4">
3.3.2. time_how4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2. time_how4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum time_how4 {
           SET_TO_SERVER_TIME4 = 0,
           SET_TO_CLIENT_TIME4 = 1
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-3--settime4">
3.3.3. settime4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.3. 第7 4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union settime4 switch (time_how4 set_it) {
    case SET_TO_CLIENT_TIME4:
            nfstime4       time;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The time_how4 and settime4 data types are used for setting timestamps in file object attributes. If set_it is SET_TO_SERVER_TIME4, then the server uses its local representation of time for the time value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_how4およびsettime4データ型は、ファイルオブジェクト属性でタイムスタンプを設定するために使用されます。 set_itがSET_TO_SERVER_TIME4の場合、サーバーは時間の値としてローカルの時間表現を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-4--specdata4">
3.3.4. specdata4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.4. specdata4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct specdata4 {
    uint32_t specdata1; /* major device number */
    uint32_t specdata2; /* minor device number */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data type represents the device numbers for the device file types NF4CHR and NF4BLK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータタイプは、デバイスファイルタイプNF4CHRおよびNF4BLKのデバイス番号を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-5--fsid4">
3.3.5. fsid4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.5. fsid4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fsid4 {
           uint64_t        major;
           uint64_t        minor;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-6--changepolicy4">
3.3.6. change_policy4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.6. change_policy4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct change_policy4 {
           uint64_t        cp_major;
           uint64_t        cp_minor;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The change_policy4 data type is used for the change_policy RECOMMENDED attribute. It provides change sequencing indication analogous to the change attribute. To enable the server to present a value valid across server re-initialization without requiring persistent storage, two 64-bit quantities are used, allowing one to be a server instance ID and the second to be incremented non-persistently, within a given server instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
change_policy4データ型は、change_policy RECOMMENDED属性に使用されます。これは、変更属性に類似した変更順序指示を提供します。サーバーが永続的なストレージを必要とせずにサーバーの再初期化全体で有効な値を提示できるようにするために、2つの64ビット数量が使用されます。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-7--fattr4">
3.3.7. fattr4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.7. fattr4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fattr4 {
           bitmap4         attrmask;
           attrlist4       attr_vals;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fattr4 data type is used to represent file and directory attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fattr4データ型は、ファイルとディレクトリの属性を表すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bitmap is a counted array of 32-bit integers used to contain bit values. The position of the integer in the array that contains bit n can be computed from the expression (n / 32), and its bit within that integer is (n mod 32).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビットマップは、ビット値を含めるために使用される32ビット整数のカウントされた配列です。ビットnを含む配列内の整数の位置は、式（n / 32）から計算でき、その整数内のビットは（n mod 32）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   0            1
   +-----------+-----------+-----------+--
   |  count    | 31  ..  0 | 63  .. 32 |
   +-----------+-----------+-----------+--
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-8--changeinfo4">
3.3.8. change_info4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.8. change_info4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct change_info4 {
           bool            atomic;
           changeid4       before;
           changeid4       after;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data type is used with the CREATE, LINK, OPEN, REMOVE, and RENAME operations to let the client know the value of the change attribute for the directory in which the target file system object resides.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータ型はCREATE、LINK、OPEN、REMOVE、およびRENAME操作で使用され、ターゲットファイルシステムオブジェクトが存在するディレクトリの変更属性の値をクライアントに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-9--netaddr4">
3.3.9. netaddr4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.9. netaddr4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct netaddr4 {
           /* see struct rpcb in RFC 1833 */
           string na_r_netid&lt;&gt;; /* network id */
           string na_r_addr&lt;&gt;;  /* universal address */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The netaddr4 data type is used to identify network transport endpoints. The r_netid and r_addr fields respectively contain a netid and uaddr. The netid and uaddr concepts are defined in [15]. The netid and uaddr formats for TCP over IPv4 and TCP over IPv6 are defined in [15], specifically Tables 2 and 3 and Sections 5.2.3.3 and 5.2.3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
netaddr4データ型は、ネットワーク転送エンドポイントを識別するために使用されます。 r_netidおよびr_addrフィールドには、それぞれnetidおよびuaddrが含まれています。 netidとuaddrの概念は[15]で定義されています。 TCP over IPv4およびTCP over IPv6のnetidおよびuaddr形式は、[15]で定義されています。具体的には、表2および3とセクション5.2.3.3および5.2.3.4です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-10--stateowner4">
3.3.10. state_owner4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.10. state_owner4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct state_owner4 {
           clientid4       clientid;
           opaque          owner&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef state_owner4 open_owner4;
   typedef state_owner4 lock_owner4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The state_owner4 data type is the base type for the open_owner4 (Section 3.3.10.1) and lock_owner4 (Section 3.3.10.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
state_owner4データ型は、open_owner4（セクション3.3.10.1）およびlock_owner4（セクション3.3.10.2）の基本タイプです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-10-1--openowner4">
3.3.10.1. open_owner4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.10.1. open_owner4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data type is used to identify the owner of OPEN state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータ型は、OPEN状態の所有者を識別するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-10-2--lockowner4">
3.3.10.2. lock_owner4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.10.2. lock_owner4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used to identify the owner of byte-range locking state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、バイト範囲ロック状態の所有者を識別するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-11--opentolockowner4">
3.3.11. open_to_lock_owner4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.11. open_to_lock_owner4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_to_lock_owner4 {
           seqid4          open_seqid;
           stateid4        open_stateid;
           seqid4          lock_seqid;
           lock_owner4     lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data type is used for the first LOCK operation done for an open_owner4. It provides both the open_stateid and lock_owner, such that the transition is made from a valid open_stateid sequence to that of the new lock_stateid sequence. Using this mechanism avoids the confirmation of the lock_owner/lock_seqid pair since it is tied to established state in the form of the open_stateid/open_seqid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータ型は、open_owner4に対して実行される最初のLOCK操作に使用されます。有効なopen_stateidシーケンスから新しいlock_stateidシーケンスへの移行が行われるように、open_stateidとlock_ownerの両方を提供します。このメカニズムを使用すると、open_stateid / open_seqidの形式で確立された状態に関連付けられるため、lock_owner / lock_seqidペアの確認が回避されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-12--stateid4">
3.3.12. stateid4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.12. stateid4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct stateid4 {
           uint32_t        seqid;
           opaque          other[12];
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data type is used for the various state sharing mechanisms between the client and server. The client never modifies a value of data type stateid. The starting value of the &#34;seqid&#34; field is undefined. The server is required to increment the &#34;seqid&#34; field by one at each transition of the stateid. This is important since the client will inspect the seqid in OPEN stateids to determine the order of OPEN processing done by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータ型は、クライアントとサーバー間のさまざまな状態共有メカニズムに使用されます。クライアントがデータ型stateidの値を変更することはありません。 「seqid」フィールドの開始値は未定義です。サーバーは、stateidの遷移ごとに「seqid」フィールドを1つずつ増やす必要があります。クライアントはOPENステートIDのseqidを検査して、サーバーが行うOPEN処理の順序を決定するため、これは重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-13--layouttype4">
3.3.13. layouttype4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.13. layouttype4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum layouttype4 {
           LAYOUT4_NFSV4_1_FILES   = 0x1,
           LAYOUT4_OSD2_OBJECTS    = 0x2,
           LAYOUT4_BLOCK_VOLUME    = 0x3
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data type indicates what type of layout is being used. The file server advertises the layout types it supports through the fs_layout_type file system attribute (Section 5.12.1). A client asks for layouts of a particular type in LAYOUTGET, and processes those layouts in its layout-type-specific logic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータタイプは、使用されているレイアウトのタイプを示します。ファイルサーバーは、fs_layout_typeファイルシステム属性（5.12.1節）を介して、サポートするレイアウトタイプを通知します。クライアントは、LAYOUTGETで特定のタイプのレイアウトを要求し、それらのレイアウトをレイアウトタイプ固有のロジックで処理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layouttype4 data type is 32 bits in length. The range represented by the layout type is split into three parts. Type 0x0 is reserved. Types within the range 0x00000001-0x7FFFFFFF are globally unique and are assigned according to the description in Section 22.4; they are maintained by IANA. Types within the range 0x80000000-0xFFFFFFFF are site specific and for private use only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
layouttype4データ型は32ビット長です。レイアウトタイプによって表される範囲は3つの部分に分割されます。タイプ0x0は予約されています。 0x00000001-0x7FFFFFFFの範囲内のタイプはグローバルに一意であり、セクション22.4の説明に従って割り当てられます。それらはIANAによって維持されます。 0x80000000-0xFFFFFFFFの範囲内のタイプはサイト固有であり、私的使用のみを目的としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LAYOUT4_NFSV4_1_FILES enumeration specifies that the NFSv4.1 file layout type, as defined in Section 13, is to be used. The LAYOUT4_OSD2_OBJECTS enumeration specifies that the object layout, as defined in [40], is to be used. Similarly, the LAYOUT4_BLOCK_VOLUME enumeration specifies that the block/volume layout, as defined in [41], is to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUT4_NFSV4_1_FILES列挙は、セクション13で定義されているNFSv4.1ファイルレイアウトタイプが使用されることを指定します。 LAYOUT4_OSD2_OBJECTS列挙は、[40]で定義されているオブジェクトレイアウトを使用することを指定します。同様に、LAYOUT4_BLOCK_VOLUME列挙は、[41]で定義されているブロック/ボリュームレイアウトが使用されることを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-14--deviceid4">
3.3.14. deviceid4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.14. deviceid4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const NFS4_DEVICEID4_SIZE = 16;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const NFS4_DEVICEID4_SIZE = 16;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef opaque deviceid4[NFS4_DEVICEID4_SIZE];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef opaque deviceid4 [NFS4_DEVICEID4_SIZE];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Layout information includes device IDs that specify a storage device through a compact handle. Addressing and type information is obtained with the GETDEVICEINFO operation. Device IDs are not guaranteed to be valid across metadata server restarts. A device ID is unique per client ID and layout type. See Section 12.2.10 for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウト情報には、コンパクトハンドルを介してストレージデバイスを指定するデバイスIDが含まれます。アドレス指定とタイプ情報は、GETDEVICEINFO操作で取得されます。デバイスIDは、メタデータサーバーの再起動後も有効であるとは限りません。デバイスIDは、クライアントIDとレイアウトタイプごとに一意です。詳細については、セクション12.2.10を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-15--deviceaddr4">
3.3.15. device_addr4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.15. device_addr4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct device_addr4 {
           layouttype4             da_layout_type;
           opaque                  da_addr_body&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The device address is used to set up a communication channel with the storage device. Different layout types will require different data types to define how they communicate with storage devices. The opaque da_addr_body field is interpreted based on the specified da_layout_type field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デバイスアドレスは、ストレージデバイスとの通信チャネルをセットアップするために使用されます。レイアウトタイプが異なれば、ストレージデバイスとの通信方法を定義するために異なるデータタイプが必要になります。不透明なda_addr_bodyフィールドは、指定されたda_layout_typeフィールドに基づいて解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines the device address for the NFSv4.1 file layout (see Section 13.3), which identifies a storage device by network IP address and port number. This is sufficient for the clients to communicate with the NFSv4.1 storage devices, and may be sufficient for other layout types as well. Device types for object-based storage devices and block storage devices (e.g., Small Computer System Interface (SCSI) volume labels) are defined by their respective layout specifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、ネットワークIPアドレスとポート番号によってストレージデバイスを識別するNFSv4.1ファイルレイアウト（セクション13.3を参照）のデバイスアドレスを定義します。これは、クライアントがNFSv4.1ストレージデバイスと通信するのに十分であり、他のレイアウトタイプにも十分な場合があります。オブジェクトベースのストレージデバイスとブロックストレージデバイスのデバイスタイプ（SCSI（Small Computer System Interface）ボリュームラベルなど）は、それぞれのレイアウト仕様によって定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-16--layoutcontent4">
3.3.16. layout_content4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.16. layout_content4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct layout_content4 {
           layouttype4 loc_type;
           opaque      loc_body&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The loc_body field is interpreted based on the layout type (loc_type). This document defines the loc_body for the NFSv4.1 file layout type; see Section 13.3 for its definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
loc_bodyフィールドは、レイアウトタイプ（loc_type）に基づいて解釈されます。このドキュメントでは、NFSv4.1ファイルレイアウトタイプのloc_bodyを定義しています。その定義については、セクション13.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-17--layout4">
3.3.17. layout4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.17. レイアウト4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct layout4 {
           offset4                 lo_offset;
           length4                 lo_length;
           layoutiomode4           lo_iomode;
           layout_content4         lo_content;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layout4 data type defines a layout for a file. The layout type specific data is opaque within lo_content. Since layouts are sub-dividable, the offset and length together with the file&#39;s filehandle, the client ID, iomode, and layout type identify the layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
layout4データ型は、ファイルのレイアウトを定義します。レイアウトタイプ固有のデータは、lo_content内では不透明です。レイアウトは分割可能であるため、オフセットと長さ、およびファイルのファイルハンドル、クライアントID、iomode、およびレイアウトタイプによってレイアウトが識別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-18--layoutupdate4">
3.3.18. layoutupdate4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.18. layoutupdate4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct layoutupdate4 {
           layouttype4             lou_type;
           opaque                  lou_body&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The layoutupdate4 data type is used by the client to return updated layout information to the metadata server via the LAYOUTCOMMIT (Section 18.42) operation. This data type provides a channel to pass layout type specific information (in field lou_body) back to the metadata server. For example, for the block/volume layout type, this could include the list of reserved blocks that were written. The contents of the opaque lou_body argument are determined by the layout type. The NFSv4.1 file-based layout does not use this data type; if lou_type is LAYOUT4_NFSV4_1_FILES, the lou_body field MUST have a zero length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントは、layoutupdate4データ型を使用して、LAYOUTCOMMIT（セクション18.42）操作を介して、更新されたレイアウト情報をメタデータサーバーに返します。このデータ型は、レイアウト型固有の情報（フィールドlou_body）をメタデータサーバーに渡すためのチャネルを提供します。たとえば、ブロック/ボリュームレイアウトタイプの場合、これには、書き込まれた予約済みブロックのリストを含めることができます。不透明なlou_body引数の内容は、レイアウトタイプによって決まります。 NFSv4.1ファイルベースのレイアウトはこのデータ型を使用しません。 lou_typeがLAYOUT4_NFSV4_1_FILESの場合、lou_bodyフィールドの長さはゼロでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-19--layouthint4">
3.3.19. layouthint4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.19. レイアウトヒント4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct layouthint4 {
           layouttype4             loh_type;
           opaque                  loh_body&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layouthint4 data type is used by the client to pass in a hint about the type of layout it would like created for a particular file. It is the data type specified by the layout_hint attribute described in Section 5.12.4. The metadata server may ignore the hint or may selectively ignore fields within the hint. This hint should be provided at create time as part of the initial attributes within OPEN. The loh_body field is specific to the type of layout (loh_type). The NFSv4.1 file-based layout uses the nfsv4_1_file_layouthint4 data type as defined in Section 13.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、layouthint4データ型を使用して、特定のファイルに対して作成するレイアウトのタイプに関するヒントを渡します。これは、5.12.4項で説明されているlayout_hint属性で指定されたデータ型です。メタデータサーバーはヒントを無視するか、ヒント内のフィールドを選択的に無視します。このヒントは、OPEN内の初期属性の一部として作成時に提供する必要があります。 loh_bodyフィールドは、レイアウトのタイプ（loh_type）に固有です。 NFSv4.1ファイルベースのレイアウトでは、セクション13.3で定義されているnfsv4_1_file_layouthint4データ型を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-20--layoutiomode4">
3.3.20. layoutiomode4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.20. layoutiomode4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum layoutiomode4 {
           LAYOUTIOMODE4_READ      = 1,
           LAYOUTIOMODE4_RW        = 2,
           LAYOUTIOMODE4_ANY       = 3
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The iomode specifies whether the client intends to just read or both read and write the data represented by the layout. While the LAYOUTIOMODE4_ANY iomode MUST NOT be used in the arguments to the LAYOUTGET operation, it MAY be used in the arguments to the LAYOUTRETURN and CB_LAYOUTRECALL operations. The LAYOUTIOMODE4_ANY iomode specifies that layouts pertaining to both LAYOUTIOMODE4_READ and LAYOUTIOMODE4_RW iomodes are being returned or recalled, respectively. The metadata server&#39;s use of the iomode may depend on the layout type being used. The storage devices MAY validate I/O accesses against the iomode and reject invalid accesses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iomodeは、クライアントがレイアウトで表されるデータを読み取るだけか、読み取りと書き込みの両方を行うかを指定します。 LAYOUTIOMODE4_ANY iomodeは、LAYOUTGET操作の引数で使用してはなりませんが、LAYOUTRETURNおよびCB_LAYOUTRECALL操作の引数で使用できます。 LAYOUTIOMODE4_ANY iomodeは、LAYOUTIOMODE4_READとLAYOUTIOMODE4_RW iomodeの両方に関連するレイアウトがそれぞれ返されるか再呼び出しされることを指定します。メタデータサーバーによるiomodeの使用は、使用されているレイアウトタイプによって異なる場合があります。ストレージデバイスは、I / Oアクセスをiomodeに対して検証し、無効なアクセスを拒否する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-21--nfsimplid4">
3.3.21. nfs_impl_id4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.21. nfs_impl_id4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfs_impl_id4 {
           utf8str_cis   nii_domain;
           utf8str_cs    nii_name;
           nfstime4      nii_date;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data type is used to identify client and server implementation details. The nii_domain field is the DNS domain name with which the implementor is associated. The nii_name field is the product name of the implementation and is completely free form. It is RECOMMENDED that the nii_name be used to distinguish machine architecture, machine platforms, revisions, versions, and patch levels. The nii_date field is the timestamp of when the software instance was published or built.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータ型は、クライアントとサーバーの実装の詳細を識別するために使用されます。 nii_domainフィールドは、実装者が関連付けられているDNSドメイン名です。 nii_nameフィールドは実装の製品名であり、完全に自由な形式です。マシンのアーキテクチャ、マシンのプラットフォーム、リビジョン、バージョン、パッチレベルを区別するためにnii_nameを使用することをお勧めします。 nii_dateフィールドは、ソフトウェアインスタンスが公開またはビルドされたときのタイムスタンプです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-22--thresholditem4">
3.3.22. threshold_item4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.22. threshold_item4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct threshold_item4 {
           layouttype4     thi_layout_type;
           bitmap4         thi_hintset;
           opaque          thi_hintlist&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data type contains a list of hints specific to a layout type for helping the client determine when it should send I/O directly through the metadata server versus the storage devices. The data type consists of the layout type (thi_layout_type), a bitmap (thi_hintset) describing the set of hints supported by the server (they may differ based on the layout type), and a list of hints (thi_hintlist) whose content is determined by the hintset bitmap. See the mdsthreshold attribute for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータ型には、クライアントがメタデータサーバーとストレージデバイスのどちらを介してI / Oを直接送信する必要があるかをクライアントが判断するのに役立つ、レイアウトタイプに固有のヒントのリストが含まれています。データ型は、レイアウトタイプ（thi_layout_type）、サーバーがサポートするヒントのセットを記述するビットマップ（thi_hintset）（レイアウトタイプによって異なる場合があります）、および内容が次のように決定されるヒントのリスト（thi_hintlist）で構成されます。ヒントセットビットマップ。詳細については、mdsthreshold属性を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The thi_hintset field is a bitmap of the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
thi_hintsetフィールドは、次の値のビットマップです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------------------+---+---------+---------------------------+
   | name                    | # | Data    | Description               |
   |                         |   | Type    |                           |
   +-------------------------+---+---------+---------------------------+
   | threshold4_read_size    | 0 | length4 | If a file&#39;s length is     |
   |                         |   |         | less than the value of    |
   |                         |   |         | threshold4_read_size,     |
   |                         |   |         | then it is RECOMMENDED    |
   |                         |   |         | that the client read from |
   |                         |   |         | the file via the MDS and  |
   |                         |   |         | not a storage device.     |
   | threshold4_write_size   | 1 | length4 | If a file&#39;s length is     |
   |                         |   |         | less than the value of    |
   |                         |   |         | threshold4_write_size,    |
   |                         |   |         | then it is RECOMMENDED    |
   |                         |   |         | that the client write to  |
   |                         |   |         | the file via the MDS and  |
   |                         |   |         | not a storage device.     |
   | threshold4_read_iosize  | 2 | length4 | For read I/O sizes below  |
   |                         |   |         | this threshold, it is     |
   |                         |   |         | RECOMMENDED to read data  |
   |                         |   |         | through the MDS.          |
   | threshold4_write_iosize | 3 | length4 | For write I/O sizes below |
   |                         |   |         | this threshold, it is     |
   |                         |   |         | RECOMMENDED to write data |
   |                         |   |         | through the MDS.          |
   +-------------------------+---+---------+---------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-23--mdsthreshold4">
3.3.23. mdsthreshold4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.23. mdsthreshold4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct mdsthreshold4 {
           threshold_item4 mth_hints&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data type holds an array of elements of data type threshold_item4, each of which is valid for a particular layout type. An array is necessary because a server can support multiple layout types for a single file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータ型は、データ型threshold_item4の要素の配列を保持します。各要素は、特定のレイアウトタイプに対して有効です。サーバーは1つのファイルに対して複数のレイアウトタイプをサポートできるため、配列が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Filehandles">
4. Filehandles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The filehandle in the NFS protocol is a per-server unique identifier for a file system object. The contents of the filehandle are opaque to the client. Therefore, the server is responsible for translating the filehandle to an internal representation of the file system object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSプロトコルのファイルハンドルは、ファイルシステムオブジェクトのサーバーごとの一意の識別子です。ファイルハンドルの内容はクライアントに対して不透明です。したがって、サーバーはファイルハンドルをファイルシステムオブジェクトの内部表現に変換する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Obtaining-the-First-Filehandle">
4.1. Obtaining the First Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 最初のファイルハンドルを取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operations of the NFS protocol are defined in terms of one or more filehandles. Therefore, the client needs a filehandle to initiate communication with the server. With the NFSv3 protocol (RFC 1813 [31]), there exists an ancillary protocol to obtain this first filehandle. The MOUNT protocol, RPC program number 100005, provides the mechanism of translating a string-based file system pathname to a filehandle, which can then be used by the NFS protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSプロトコルの操作は、1つ以上のファイルハンドルで定義されます。したがって、クライアントはサーバーとの通信を開始するためにファイルハンドルを必要とします。 NFSv3プロトコル（RFC 1813 [31]）では、この最初のファイルハンドルを取得するための補助的なプロトコルが存在します。 MOUNTプロトコル、RPCプログラム番号100005は、文字列ベースのファイルシステムパス名をファイルハンドルに変換するメカニズムを提供します。これは、NFSプロトコルで使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MOUNT protocol has deficiencies in the area of security and use via firewalls. This is one reason that the use of the public filehandle was introduced in RFC 2054 [42] and RFC 2055 [43]. With the use of the public filehandle in combination with the LOOKUP operation in the NFSv3 protocol, it has been demonstrated that the MOUNT protocol is unnecessary for viable interaction between NFS client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MOUNTプロトコルには、セキュリティおよびファイアウォール経由の使用の分野での欠点があります。これは、パブリックファイルハンドルの使用がRFC 2054 [42]およびRFC 2055 [43]で導入された1つの理由です。 NFSv3プロトコルのLOOKUP操作と組み合わせてパブリックファイルハンドルを使用すると、NFSクライアントとサーバー間の実行可能な対話にはMOUNTプロトコルが不要であることが実証されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, the NFSv4.1 protocol will not use an ancillary protocol for translation from string-based pathnames to a filehandle. Two special filehandles will be used as starting points for the NFS client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、NFSv4.1プロトコルは、文字列ベースのパス名からファイルハンドルへの変換に補助プロトコルを使用しません。 NFSクライアントの開始点として、2つの特別なファイルハンドルが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1-1--Root-Filehandle">
4.1.1. Root Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. ルートファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first of the special filehandles is the ROOT filehandle. The ROOT filehandle is the &#34;conceptual&#34; root of the file system namespace at the NFS server. The client uses or starts with the ROOT filehandle by employing the PUTROOTFH operation. The PUTROOTFH operation instructs the server to set the &#34;current&#34; filehandle to the ROOT of the server&#39;s file tree. Once this PUTROOTFH operation is used, the client can then traverse the entirety of the server&#39;s file tree with the LOOKUP operation. A complete discussion of the server namespace is in Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の特別なファイルハンドルはROOTファイルハンドルです。 ROOTファイルハンドルは、NFSサーバーでのファイルシステム名前空間の「概念的な」ルートです。クライアントは、PUTROOTFH操作を使用して、ROOTファイルハンドルを使用するか、ROOTファイルハンドルで開始します。 PUTROOTFH操作は、「現在の」ファイルハンドルをサーバーのファイルツリーのROOTに設定するようサーバーに指示します。このPUTROOTFH操作を使用すると、クライアントはLOOKUP操作を使用してサーバーのファイルツリー全体をトラバースできます。サーバーの名前空間の詳細については、セクション7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1-2--Public-Filehandle">
4.1.2. Public Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. 公開ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second special filehandle is the PUBLIC filehandle. Unlike the ROOT filehandle, the PUBLIC filehandle may be bound or represent an arbitrary file system object at the server. The server is responsible for this binding. It may be that the PUBLIC filehandle and the ROOT filehandle refer to the same file system object. However, it is up to the administrative software at the server and the policies of the server administrator to define the binding of the PUBLIC filehandle and server file system object. The client may not make any assumptions about this binding. The client uses the PUBLIC filehandle via the PUTPUBFH operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目の特別なファイルハンドルはPUBLICファイルハンドルです。 ROOTファイルハンドルとは異なり、PUBLICファイルハンドルはバインドされるか、サーバーで任意のファイルシステムオブジェクトを表す場合があります。サーバーはこのバインディングを担当します。 PUBLICファイルハンドルとROOTファイルハンドルが同じファイルシステムオブジェクトを参照している可能性があります。ただし、PUBLICファイルハンドルとサーバーファイルシステムオブジェクトのバインディングを定義するのは、サーバーの管理ソフトウェアとサーバー管理者のポリシー次第です。クライアントは、このバインディングについて何も想定していません。クライアントは、PUTPUBFH操作を介してPUBLICファイルハンドルを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Filehandle-Types">
4.2. Filehandle Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. ファイルハンドルのタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the NFSv3 protocol, there was one type of filehandle with a single set of semantics. This type of filehandle is termed &#34;persistent&#34; in NFSv4.1. The semantics of a persistent filehandle remain the same as before. A new type of filehandle introduced in NFSv4.1 is the &#34;volatile&#34; filehandle, which attempts to accommodate certain server environments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv3プロトコルでは、単一のセマンティクスのセットを持つ1種類のファイルハンドルがありました。このタイプのファイルハンドルは、NFSv4.1では「永続的」と呼ばれています。永続ファイルハンドルのセマンティクスは以前と同じままです。 NFSv4.1で導入された新しいタイプのファイルハンドルは、「揮発性」ファイルハンドルで、特定のサーバー環境に対応しようとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The volatile filehandle type was introduced to address server functionality or implementation issues that make correct implementation of a persistent filehandle infeasible. Some server environments do not provide a file-system-level invariant that can be used to construct a persistent filehandle. The underlying server file system may not provide the invariant or the server&#39;s file system programming interfaces may not provide access to the needed invariant. Volatile filehandles may ease the implementation of server functionality such as hierarchical storage management or file system reorganization or migration. However, the volatile filehandle increases the implementation burden for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドルタイプは、永続ファイルハンドルの正しい実装を実行不可能にするサーバーの機能または実装の問題に対処するために導入されました。一部のサーバー環境では、永続的なファイルハンドルを構築するために使用できるファイルシステムレベルの不変条件を提供していません。基盤となるサーバーファイルシステムが不変条件を提供していないか、サーバーのファイルシステムプログラミングインターフェイスが必要な不変条件へのアクセスを提供していない可能性があります。揮発性ファイルハンドルにより、階層ストレージ管理やファイルシステムの再編成や移行などのサーバー機能の実装が容易になる場合があります。ただし、揮発性ファイルハンドルは、クライアントの実装負担を増やします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the client will need to handle persistent and volatile filehandles differently, a file attribute is defined that may be used by the client to determine the filehandle types being returned by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは永続的なファイルハンドルと揮発性のファイルハンドルを別々に処理する必要があるため、サーバーが返すファイルハンドルのタイプを決定するためにクライアントが使用できるファイル属性が定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-1--General-Properties-of-a-Filehandle">
4.2.1. General Properties of a Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. ファイルハンドルの一般的なプロパティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The filehandle contains all the information the server needs to distinguish an individual file. To the client, the filehandle is opaque. The client stores filehandles for use in a later request and can compare two filehandles from the same server for equality by doing a byte-by-byte comparison. However, the client MUST NOT otherwise interpret the contents of filehandles. If two filehandles from the same server are equal, they MUST refer to the same file. Servers SHOULD try to maintain a one-to-one correspondence between filehandles and files, but this is not required. Clients MUST use filehandle comparisons only to improve performance, not for correct behavior. All clients need to be prepared for situations in which it cannot be determined whether two filehandles denote the same object and in such cases, avoid making invalid assumptions that might cause incorrect behavior. Further discussion of filehandle and attribute comparison in the context of data caching is presented in Section 10.3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルハンドルには、サーバーが個々のファイルを区別するために必要なすべての情報が含まれています。クライアントにとって、ファイルハンドルは不透明です。クライアントは、後の要求で使用するためにファイルハンドルを格納し、バイトごとの比較を行うことにより、同じサーバーからの2つのファイルハンドルが等しいかどうかを比較できます。ただし、クライアントはファイルハンドルの内容を別の方法で解釈してはなりません（MUST NOT）。同じサーバーからの2つのファイルハンドルが等しい場合、それらは同じファイルを参照する必要があります。サーバーは、ファイルハンドルとファイル間の1対1の対応を維持するように努めるべきですが、これは必須ではありません。クライアントは、正しい動作ではなく、パフォーマンスを向上させるためにのみファイルハンドル比較を使用する必要があります。すべてのクライアントは、2つのファイルハンドルが同じオブジェクトを示しているかどうかを判断できない状況に備える必要があります。そのような場合は、不正な動作を引き起こす可能性のある無効な仮定を行わないでください。データキャッシュのコンテキストでのファイルハンドルと属性比較の詳細については、セクション10.3.4で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 As an example, in the case that two different pathnames when traversed at the server terminate at the same file system object, the server SHOULD return the same filehandle for each path. This can occur if a hard link (see [Section 3.191 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232&#34;&#34;&gt;6]) is used to create two file names that refer to the same underlying file object and associated data. For example, if paths /a/b/c and /a/d/c refer to the same file, the server SHOULD return the same filehandle for both pathnames&#39; traversals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
例として、サーバーでトラバースしたときに2つの異なるパス名が同じファイルシステムオブジェクトで終了する場合、サーバーは各パスに対して同じファイルハンドルを返す必要があります（SHOULD）。これは、ハードリンク（[Open Group Base Specifications Issue 6 IEEE Std 1003.1、2004 Edition、HTML Version（www.opengroup.org）、ISBN 1931624232 &#34;&#34;&gt; 6]の基本定義の第3章のセクション3.191を参照）の場合に発生する可能性があります。 ）を使用して、同じ基礎となるファイルオブジェクトと関連データを参照する2つのファイル名を作成します。たとえば、パス/ a / b / cと/ a / d / cが同じファイルを参照している場合、サーバーは両方のパス名のトラバーサルに対して同じファイルハンドルを返す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-2--Persistent-Filehandle">
4.2.2. Persistent Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. 永続的なファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A persistent filehandle is defined as having a fixed value for the lifetime of the file system object to which it refers. Once the server creates the filehandle for a file system object, the server MUST accept the same filehandle for the object for the lifetime of the object. If the server restarts, the NFS server MUST honor the same filehandle value as it did in the server&#39;s previous instantiation. Similarly, if the file system is migrated, the new NFS server MUST honor the same filehandle as the old NFS server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
永続ファイルハンドルは、それが参照するファイルシステムオブジェクトの存続期間中、固定値を持つものとして定義されます。サーバーがファイルシステムオブジェクトのファイルハンドルを作成すると、サーバーはオブジェクトの存続期間中、オブジェクトの同じファイルハンドルを受け入れる必要があります。サーバーが再起動する場合、NFSサーバーはサーバーの以前のインスタンス化と同じファイルハンドル値を尊重する必要があります。同様に、ファイルシステムが移行される場合、新しいNFSサーバーは古いNFSサーバーと同じファイルハンドルを尊重する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The persistent filehandle will be become stale or invalid when the file system object is removed. When the server is presented with a persistent filehandle that refers to a deleted object, it MUST return an error of NFS4ERR_STALE. A filehandle may become stale when the file system containing the object is no longer available. The file system may become unavailable if it exists on removable media and the media is no longer available at the server or the file system in whole has been destroyed or the file system has simply been removed from the server&#39;s namespace (i.e., unmounted in a UNIX environment).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムオブジェクトが削除されると、永続ファイルハンドルは古くなるか無効になります。サーバーが、削除されたオブジェクトを参照する永続的なファイルハンドルを提示されると、NFS4ERR_STALEのエラーを返さなければなりません（MUST）。オブジェクトを含むファイルシステムが使用できなくなると、ファイルハンドルが古くなる場合があります。ファイルシステムがリムーバブルメディアに存在し、サーバーでメディアが利用できなくなった場合、またはファイルシステム全体が破壊された場合、またはファイルシステムがサーバーの名前空間から削除された場合（つまり、UNIXでマウント解除された場合）環境）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-3--Volatile-Filehandle">
4.2.3. Volatile Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3. 揮発性ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A volatile filehandle does not share the same longevity characteristics of a persistent filehandle. The server may determine that a volatile filehandle is no longer valid at many different points in time. If the server can definitively determine that a volatile filehandle refers to an object that has been removed, the server should return NFS4ERR_STALE to the client (as is the case for persistent filehandles). In all other cases where the server determines that a volatile filehandle can no longer be used, it should return an error of NFS4ERR_FHEXPIRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドルは、永続ファイルハンドルと同じ寿命特性を共有しません。サーバーは、揮発性ファイルハンドルが多くの異なる時点で有効ではなくなったと判断する場合があります。揮発性ファイルハンドルが削除されたオブジェクトを参照しているとサーバーが明確に判断できる場合、サーバーはNFS4ERR_STALEをクライアントに返す必要があります（永続ファイルハンドルの場合と同様）。揮発性ファイルハンドルが使用できなくなったとサーバーが判断する他のすべてのケースでは、NFS4ERR_FHEXPIREDのエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The REQUIRED attribute &#34;fh_expire_type&#34; is used by the client to determine what type of filehandle the server is providing for a particular file system. This attribute is a bitmask with the following values: FH4_PERSISTENT The value of FH4_PERSISTENT is used to indicate a persistent filehandle, which is valid until the object is removed from the file system. The server will not return NFS4ERR_FHEXPIRED for this filehandle. FH4_PERSISTENT is defined as a value in which none of the bits specified below are set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
必須属性「fh_expire_type」は、サーバーが特定のファイルシステムに提供するファイルハンドルのタイプを決定するためにクライアントによって使用されます。この属性は、次の値を持つビットマスクです。FH4_PERSISTENT FH4_PERSISTENTの値は、オブジェクトがファイルシステムから削除されるまで有効な永続的なファイルハンドルを示すために使用されます。サーバーは、このファイルハンドルに対してNFS4ERR_FHEXPIREDを返しません。 FH4_PERSISTENTは、以下に指定されたビットが設定されていない値として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOLATILE_ANY The filehandle may expire at any time, except as specifically excluded (i.e., FH4_NO_EXPIRE_WITH_OPEN).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOLATILE_ANYファイルハンドルは、明確に除外されている場合（FH4_NO_EXPIRE_WITH_OPENなど）を除き、いつでも期限切れになる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_NOEXPIRE_WITH_OPEN May only be set when FH4_VOLATILE_ANY is set. If this bit is set, then the meaning of FH4_VOLATILE_ANY is qualified to exclude any expiration of the filehandle when it is open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_NOEXPIRE_WITH_OPEN FH4_VOLATILE_ANYが設定されている場合にのみ設定できます。このビットが設定されている場合、FH4_VOLATILE_ANYの意味は、ファイルハンドルが開いているときにファイルハンドルの有効期限を除外するように修飾されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_MIGRATION The filehandle will expire as a result of a file system transition (migration or replication), in those cases in which the continuity of filehandle use is not specified by handle class information within the fs_locations_info attribute. When this bit is set, clients without access to fs_locations_info information should assume that filehandles will expire on file system transitions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_MIGRATION fs_locations_info属性内のハンドルクラス情報によってファイルハンドルの使用の継続性が指定されていない場合、ファイルハンドルはファイルシステムの移行（移行またはレプリケーション）の結果として期限切れになります。このビットが設定されている場合、fs_locations_info情報にアクセスできないクライアントは、ファイルシステムの移行時にファイルハンドルが期限切れになると想定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_RENAME The filehandle will expire during rename. This includes a rename by the requesting client or a rename by any other client. If FH4_VOL_ANY is set, FH4_VOL_RENAME is redundant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_RENAMEファイルハンドルは名前変更中に期限切れになります。これには、要求元クライアントによる名前変更、または他のクライアントによる名前変更が含まれます。 FH4_VOL_ANYが設定されている場合、FH4_VOL_RENAMEは冗長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers that provide volatile filehandles that can expire while open require special care as regards handling of RENAMEs and REMOVEs. This situation can arise if FH4_VOL_MIGRATION or FH4_VOL_RENAME is set, if FH4_VOLATILE_ANY is set and FH4_NOEXPIRE_WITH_OPEN is not set, or if a non-read-only file system has a transition target in a different handle class. In these cases, the server should deny a RENAME or REMOVE that would affect an OPEN file of any of the components leading to the OPEN file. In addition, the server should deny all RENAME or REMOVE requests during the grace period, in order to make sure that reclaims of files where filehandles may have expired do not do a reclaim for the wrong file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープン中に期限切れになる可能性のある揮発性ファイルハンドルを提供するサーバーは、RENAMEとREMOVEの処理に関して特別な注意が必要です。この状況は、FH4_VOL_MIGRATIONまたはFH4_VOL_RENAMEが設定されている場合、FH4_VOLATILE_ANYが設定されていてFH4_NOEXPIRE_WITH_OPENが設定されていない場合、または読み取り専用でないファイルシステムに別のハンドルクラスの遷移ターゲットがある場合に発生する可能性があります。このような場合、サーバーは、OPENファイルにつながるコンポーネントのOPENファイルに影響を与えるRENAMEまたはREMOVEを拒否する必要があります。さらに、サーバーは、猶予期間中はすべてのRENAME要求またはREMOVE要求を拒否する必要があります。これは、ファイルハンドルの有効期限が切れている可能性のあるファイルの再利用によって、誤ったファイルが再利用されないようにするためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Volatile filehandles are especially suitable for implementation of the pseudo file systems used to bridge exports. See Section 7.5 for a discussion of this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドルは、エクスポートのブリッジに使用される疑似ファイルシステムの実装に特に適しています。これについては、セクション7.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--One-Method-of-Constructing-a-Volatile-Filehandle">
4.3. One Method of Constructing a Volatile Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 揮発性ファイルハンドルを構築する1つの方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A volatile filehandle, while opaque to the client, could contain:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドルは、クライアントには不透明ですが、以下を含むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 [volatile bit = 1 | server boot time | slot | generation number] o slot is an index in the server volatile filehandle table
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
[揮発性ビット= 1 |サーバーの起動時間|スロット|世代番号] oスロットは、サーバーの揮発性ファイルハンドルテーブルのインデックスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o generation number is the generation number for the table entry/ slot
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 世代番号は、テーブルエントリ/スロットの世代番号です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client presents a volatile filehandle, the server makes the following checks, which assume that the check for the volatile bit has passed. If the server boot time is less than the current server boot time, return NFS4ERR_FHEXPIRED. If slot is out of range, return NFS4ERR_BADHANDLE. If the generation number does not match, return NFS4ERR_FHEXPIRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが揮発性ファイルハンドルを提示すると、サーバーは次のチェックを行います。これは、揮発性ビットのチェックに合格したことを前提としています。サーバーの起動時間が現在のサーバーの起動時間よりも短い場合は、NFS4ERR_FHEXPIREDを返します。スロットが範囲外の場合は、NFS4ERR_BADHANDLEを返します。世代番号が一致しない場合は、NFS4ERR_FHEXPIREDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server restarts, the table is gone (it is volatile).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが再起動すると、テーブルはなくなります（揮発性です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the volatile bit is 0, then it is a persistent filehandle with a different structure following it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ビットが0の場合、それはその後に別の構造を持つ永続ファイルハンドルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4--Client-Recovery-from-Filehandle-Expiration">
4.4. Client Recovery from Filehandle Expiration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. ファイルハンドルの有効期限からのクライアントの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If possible, the client SHOULD recover from the receipt of an NFS4ERR_FHEXPIRED error. The client must take on additional responsibility so that it may prepare itself to recover from the expiration of a volatile filehandle. If the server returns persistent filehandles, the client does not need these additional steps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能であれば、クライアントはNFS4ERR_FHEXPIREDエラーの受信から回復する必要があります（SHOULD）。クライアントは、揮発性ファイルハンドルの期限切れから回復する準備をするために、追加の責任を負う必要があります。サーバーが永続的なファイルハンドルを返す場合、クライアントはこれらの追加手順を必要としません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For volatile filehandles, most commonly the client will need to store the component names leading up to and including the file system object in question. With these names, the client should be able to recover by finding a filehandle in the namespace that is still available or by starting at the root of the server&#39;s file system namespace.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドルの場合、最も一般的には、クライアントは問題のファイルシステムオブジェクトに至るまでのコンポーネント名を格納する必要があります。これらの名前を使用すると、クライアントは、まだ使用可能なネームスペースでファイルハンドルを見つけるか、サーバーのファイルシステムネームスペースのルートから開始することで回復できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the expired filehandle refers to an object that has been removed from the file system, obviously the client will not be able to recover from the expired filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
期限切れのファイルハンドルがファイルシステムから削除されたオブジェクトを参照している場合、明らかにクライアントは期限切れのファイルハンドルから回復することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is also possible that the expired filehandle refers to a file that has been renamed. If the file was renamed by another client, again it is possible that the original client will not be able to recover. However, in the case that the client itself is renaming the file and the file is open, it is possible that the client may be able to recover. The client can determine the new pathname based on the processing of the rename request. The client can then regenerate the new filehandle based on the new pathname. The client could also use the COMPOUND procedure to construct a series of operations like:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
期限切れのファイルハンドルが名前が変更されたファイルを参照している可能性もあります。ファイルの名前が別のクライアントによって変更された場合、元のクライアントが回復できない可能性があります。ただし、クライアント自体がファイルの名前を変更していて、ファイルが開いている場合は、クライアントが回復できる可能性があります。クライアントは、名前変更要求の処理に基づいて新しいパス名を決定できます。その後、クライアントは新しいパス名に基づいて新しいファイルハンドルを再生成できます。クライアントはCOMPOUNDプロシージャを使用して、次のような一連の操作を構築することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
RENAME A B LOOKUP B GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
A B LOOKUP B GETFHの名前を変更
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the COMPOUND procedure does not provide atomicity. This example only reduces the overhead of recovering from an expired filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャは原子性を提供しないことに注意してください。この例では、期限切れのファイルハンドルからの回復のオーバーヘッドのみを削減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--File-Attributes">
5. File Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. ファイル属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To meet the requirements of extensibility and increased interoperability with non-UNIX platforms, attributes need to be handled in a flexible manner. The NFSv3 fattr3 structure contains a fixed list of attributes that not all clients and servers are able to support or care about. The fattr3 structure cannot be extended as new needs arise and it provides no way to indicate non-support. With the NFSv4.1 protocol, the client is able to query what attributes the server supports and construct requests with only those supported attributes (or a subset thereof).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIX以外のプラットフォームとの拡張性と相互運用性の要件を満たすには、属性を柔軟に処理する必要があります。 NFSv3 fattr3構造には、すべてのクライアントとサーバーがサポートまたは処理できる属性の固定リストが含まれています。新しい必要性が生じた場合、fattr3構造は拡張できず、サポートされていないことを示す方法はありません。 NFSv4.1プロトコルを使用すると、クライアントはサーバーがサポートする属性を照会し、サポートされている属性（またはそのサブセット）のみを使用して要求を作成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To this end, attributes are divided into three groups: REQUIRED, RECOMMENDED, and named. Both REQUIRED and RECOMMENDED attributes are supported in the NFSv4.1 protocol by a specific and well-defined encoding and are identified by number. They are requested by setting a bit in the bit vector sent in the GETATTR request; the server response includes a bit vector to list what attributes were returned in the response. New REQUIRED or RECOMMENDED attributes may be added to the NFSv4 protocol as part of a new minor version by publishing a Standards Track RFC that allocates a new attribute number value and defines the encoding for the attribute. See Section 2.7 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このために、属性はREQUIRED、RECOMMENDED、およびnamedという3つのグループに分けられます。 REQUIRED属性とRECOMMENDED属性の両方が、NFSv4.1プロトコルで特定の明確に定義されたエンコーディングによってサポートされ、番号で識別されます。これらは、GETATTR要求で送信されたビットベクトルにビットを設定することによって要求されます。サーバー応答には、応答で返された属性をリストするビットベクトルが含まれています。新しい属性番号の値を割り当て、属性のエンコーディングを定義するStandards Track RFCを公開することにより、新しいREQUIREDまたはRECOMMENDED属性を新しいマイナーバージョンの一部としてNFSv4プロトコルに追加できます。詳細については、セクション2.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Named attributes are accessed by the new OPENATTR operation, which accesses a hidden directory of attributes associated with a file system object. OPENATTR takes a filehandle for the object and returns the filehandle for the attribute hierarchy. The filehandle for the named attributes is a directory object accessible by LOOKUP or READDIR and contains files whose names represent the named attributes and whose data bytes are the value of the attribute. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付き属性は、ファイルシステムオブジェクトに関連付けられた属性の非表示ディレクトリにアクセスする新しいOPENATTR操作によってアクセスされます。 OPENATTRはオブジェクトのファイルハンドルを受け取り、属性階層のファイルハンドルを返します。名前付き属性のファイルハンドルは、LOOKUPまたはREADDIRによってアクセス可能なディレクトリオブジェクトであり、名前が名前付き属性を表し、データバイトが属性の値であるファイルが含まれています。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        +----------+-----------+---------------------------------+
        | LOOKUP   | &#34;foo&#34;     | ; look up file                  |
        | GETATTR  | attrbits  |                                 |
        | OPENATTR |           | ; access foo&#39;s named attributes |
        | LOOKUP   | &#34;x11icon&#34; | ; look up specific attribute    |
        | READ     | 0,4096    | ; read stream of bytes          |
        +----------+-----------+---------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Named attributes are intended for data needed by applications rather than by an NFS client implementation. NFS implementors are strongly encouraged to define their new attributes as RECOMMENDED attributes by bringing them to the IETF Standards Track process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付き属性は、NFSクライアント実装ではなく、アプリケーションが必要とするデータを対象としています。 NFSの実装者は、IETF標準トラックプロセスにそれらを持ち込むことにより、推奨属性として新しい属性を定義することを強くお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set of attributes that are classified as REQUIRED is deliberately small since servers need to do whatever it takes to support them. A server should support as many of the RECOMMENDED attributes as possible but, by their definition, the server is not required to support all of them. Attributes are deemed REQUIRED if the data is both needed by a large number of clients and is not otherwise reasonably computable by the client when support is not provided on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQUIREDとして分類される属性のセットは、サーバーがそれらをサポートするために必要なことを何でも行う必要があるため、意図的に小さくなっています。サーバーはできる限り多くのRECOMMENDED属性をサポートする必要がありますが、その定義により、サーバーはそれらすべてをサポートする必要はありません。多数のクライアントがデータを必要とし、サーバーでサポートが提供されていない場合にクライアントが合理的に計算できない場合、属性は必須と見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the hidden directory returned by OPENATTR is a convenience for protocol processing. The client should not make any assumptions about the server&#39;s implementation of named attributes and whether or not the underlying file system at the server has a named attribute directory. Therefore, operations such as SETATTR and GETATTR on the named attribute directory are undefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENATTRによって返される隠しディレクトリは、プロトコル処理に便利です。クライアントは、サーバーの名前付き属性の実装について、およびサーバーの基盤となるファイルシステムに名前付き属性ディレクトリがあるかどうかについて、いかなる仮定も行わないでください。したがって、名前付き属性ディレクトリーに対するSETATTRやGETATTRなどの操作は未定義です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--REQUIRED-Attributes">
5.1. REQUIRED Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 必須の属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These MUST be supported by every NFSv4.1 client and server in order to ensure a minimum level of interoperability. The server MUST store and return these attributes, and the client MUST be able to function with an attribute set limited to these attributes. With just the REQUIRED attributes some client functionality may be impaired or limited in some ways. A client may ask for any of these attributes to be returned by setting a bit in the GETATTR request, and the server MUST return their value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最小レベルの相互運用性を確保するために、これらはすべてのNFSv4.1クライアントとサーバーでサポートされる必要があります。サーバーはこれらの属性を格納して返す必要があり、クライアントはこれらの属性に限定された属性セットで機能できる必要があります。 REQUIRED属性だけでは、一部のクライアント機能が何らかの方法で損なわれたり制限されたりする場合があります。クライアントは、GETATTR要求にビットを設定することにより、これらの属性のいずれかが返されるように要求する場合があり、サーバーはそれらの属性を返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--RECOMMENDED-Attributes">
5.2. RECOMMENDED Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. 推奨属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 These attributes are understood well enough to warrant support in the NFSv4.1 protocol. However, they may not be supported on all clients and servers. A client may ask for any of these attributes to be returned by setting a bit in the GETATTR request but must handle the case where the server does not return them. A client MAY ask for the set of attributes the server supports and SHOULD NOT request attributes the server does not support. A server should be tolerant of requests for unsupported attributes and simply not return them rather than considering the request an error. It is expected that servers will support all attributes they comfortably can and only fail to support attributes that are difficult to support in their operating environments. A server should provide attributes whenever they don&#39;t have to &#34;tell lies&#34; to the client. For example, a file modification time should be either an accurate time or should not be supported by the server. At times this will be difficult for clients, but a client is better positioned to decide whether and how to fabricate or construct an attribute or whether to do without the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
これらの属性は、NFSv4.1プロトコルでのサポートを保証するのに十分に理解されています。ただし、すべてのクライアントとサーバーでサポートされているとは限りません。クライアントは、GETATTR要求にビットを設定することにより、これらの属性のいずれかが返されるように要求できますが、サーバーがそれらの属性を返さない場合を処理する必要があります。クライアントは、サーバーがサポートする属性のセットを要求する場合があり、サーバーがサポートしない属性を要求してはなりません（SHOULD NOT）。サーバーは、サポートされていない属性の要求に対して寛容であり、要求をエラーと見なすのではなく、単にそれらを返さないようにする必要があります。サーバーは快適に使用できるすべての属性をサポートし、オペレーティング環境でサポートするのが難しい属性のみをサポートすることが期待されます。サーバーは、クライアントに「嘘をつく」必要がない場合はいつでも属性を提供する必要があります。たとえば、ファイルの変更時刻は正確な時刻であるか、サーバーでサポートされていない必要があります。これはクライアントにとって困難な場合がありますが、クライアントは、属性を作成または構築するかどうか、どのように作成するか、または属性なしで実行するかどうかを決定するのに適しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3--Named-Attributes">
5.3. Named Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. 名前付き属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These attributes are not supported by direct encoding in the NFSv4 protocol but are accessed by string names rather than numbers and correspond to an uninterpreted stream of bytes that are stored with the file system object. The namespace for these attributes may be accessed by using the OPENATTR operation. The OPENATTR operation returns a filehandle for a virtual &#34;named attribute directory&#34;, and further perusal and modification of the namespace may be done using operations that work on more typical directories. In particular, READDIR may be used to get a list of such named attributes, and LOOKUP and OPEN may select a particular attribute. Creation of a new named attribute may be the result of an OPEN specifying file creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの属性は、NFSv4プロトコルの直接エンコーディングではサポートされていませんが、数値ではなく文字列名でアクセスされ、ファイルシステムオブジェクトと共に格納される解釈されないバイトストリームに対応しています。これらの属性の名前空間には、OPENATTR操作を使用してアクセスできます。 OPENATTR操作は、仮想の「名前付き属性ディレクトリ」のファイルハンドルを返します。さらに一般的なディレクトリで機能する操作を使用して、名前空間の詳細を調べたり変更したりできます。特に、READDIRはそのような名前付き属性のリストを取得するために使用でき、LOOKUPとOPENは特定の属性を選択できます。新しい名前付き属性の作成は、OPENを指定したファイル作成の結果である可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once an OPEN is done, named attributes may be examined and changed by normal READ and WRITE operations using the filehandles and stateids returned by OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENが完了すると、名前付き属性は、OPENによって返されるファイルハンドルとステートIDを使用して、通常のREADおよびWRITE操作によって検査および変更できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Named attributes and the named attribute directory may have their own (non-named) attributes. Each of these objects MUST have all of the REQUIRED attributes and may have additional RECOMMENDED attributes. However, the set of attributes for named attributes and the named attribute directory need not be, and typically will not be, as large as that for other objects in that file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付き属性と名前付き属性ディレクトリは、独自の（名前なし）属性を持つことができます。これらのオブジェクトのそれぞれは、すべての必須属性を持たなければならず（MUST）、追加の推奨属性を含めることができます。ただし、名前付き属性と名前付き属性ディレクトリの一連の属性は、そのファイルシステム内の他のオブジェクトの属性と同じ大きさである必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Named attributes and the named attribute directory might be the target of delegations (in the case of the named attribute directory, these will be directory delegations). However, since granting delegations is at the server&#39;s discretion, a server need not support delegations on named attributes or the named attribute directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付き属性と名前付き属性ディレクトリが委任のターゲットになる場合があります（名前付き属性ディレクトリの場合、これらはディレクトリ委任になります）。ただし、委任の付与はサーバーの裁量に委ねられているため、サーバーは名前付き属性または名前付き属性ディレクトリの委任をサポートする必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is RECOMMENDED that servers support arbitrary named attributes. A client should not depend on the ability to store any named attributes in the server&#39;s file system. If a server does support named attributes, a client that is also able to handle them should be able to copy a file&#39;s data and metadata with complete transparency from one location to another; this would imply that names allowed for regular directory entries are valid for named attribute names as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが任意の名前付き属性をサポートすることをお勧めします。クライアントは、サーバーのファイルシステムに名前付き属性を格納する機能に依存してはなりません。サーバーが名前付き属性をサポートしている場合、それらも処理できるクライアントは、ファイルのデータとメタデータをある場所から別の場所に完全に透過的にコピーできるはずです。これは、通常のディレクトリエントリに許可されている名前が名前付き属性名にも有効であることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In NFSv4.1, the structure of named attribute directories is restricted in a number of ways, in order to prevent the development of non-interoperable implementations in which some servers support a fully general hierarchical directory structure for named attributes while others support a limited but adequate structure for named attributes. In such an environment, clients or applications might come to depend on non-portable extensions. The restrictions are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1では、一部のサーバーが名前付き属性の完全に一般的な階層ディレクトリ構造をサポートし、他のサーバーは制限付きだが名前付き属性の適切な構造。このような環境では、クライアントまたはアプリケーションは、移植できない拡張機能に依存するようになる可能性があります。制限は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o CREATE is not allowed in a named attribute directory. Thus, such objects as symbolic links and special files are not allowed to be named attributes. Further, directories may not be created in a named attribute directory, so no hierarchical structure of named attributes for a single object is allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 名前付き属性ディレクトリではCREATEは許可されていません。したがって、シンボリックリンクや特殊ファイルなどのオブジェクトを名前付き属性にすることはできません。さらに、名前付き属性ディレクトリにディレクトリを作成できないため、単一オブジェクトの名前付き属性の階層構造は許可されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If OPENATTR is done on a named attribute directory or on a named attribute, the server MUST return NFS4ERR_WRONG_TYPE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPENATTRが名前付き属性ディレクトリまたは名前付き属性で行われる場合、サーバーはNFS4ERR_WRONG_TYPEを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Doing a RENAME of a named attribute to a different named attribute directory or to an ordinary (i.e., non-named-attribute) directory is not allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 名前付き属性のRENAMEを別の名前付き属性ディレクトリまたは通常の（つまり、非名前付き属性）ディレクトリに実行することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Creating hard links between named attribute directories or between named attribute directories and ordinary directories is not allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 名前付き属性ディレクトリ間、または名前付き属性ディレクトリと通常のディレクトリ間にハードリンクを作成することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Names of attributes will not be controlled by this document or other IETF Standards Track documents. See Section 22.1 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性の名前は、このドキュメントまたは他のIETF標準トラックドキュメントによって制御されません。詳細については、セクション22.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4--Classification-of-Attributes">
5.4. Classification of Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. 属性の分類
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the REQUIRED and RECOMMENDED attributes can be classified in one of three categories: per server (i.e., the value of the attribute will be the same for all file objects that share the same server owner; see Section 2.5 for a definition of server owner), per file system (i.e., the value of the attribute will be the same for some or all file objects that share the same fsid attribute (Section 5.8.1.9) and server owner), or per file system object. Note that it is possible that some per file system attributes may vary within the file system, depending on the value of the &#34;homogeneous&#34; (Section 5.8.2.16) attribute. Note that the attributes time_access_set and time_modify_set are not listed in this section because they are write-only attributes corresponding to time_access and time_modify, and are used in a special instance of SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQUIRED属性とRECOMMENDED属性は、次の3つのカテゴリのいずれかに分類できます。サーバーごと（つまり、属性の値は、同じサーバー所有者を共有するすべてのファイルオブジェクトで同じです。サーバー所有者の定義については、セクション2.5を参照してください） ）、ファイルシステムごと（つまり、属性の値は、同じfsid属性（セクション5.8.1.9）とサーバー所有者を共有する一部またはすべてのファイルオブジェクトで同じ）、またはファイルシステムオブジェクトごとです。 「同種」（5.8.2.16節）属性の値に応じて、ファイルシステムごとの属性の一部がファイルシステム内で異なる可能性があることに注意してください。属性time_access_setおよびtime_modify_setは、time_accessおよびtime_modifyに対応する書き込み専用属性であり、SETATTRの特別なインスタンスで使用されるため、このセクションにはリストされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The per-server attribute is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーごとの属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
lease_time
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
リース時間
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The per-file system attributes are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルごとのシステム属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
supported_attrs, suppattr_exclcreat, fh_expire_type, link_support, symlink_support, unique_handles, aclsupport, cansettime, case_insensitive, case_preserving, chown_restricted, files_avail, files_free, files_total, fs_locations, homogeneous, maxfilesize, maxname, maxread, maxwrite, no_trunc, space_avail, space_free, space_total, time_delta, change_policy, fs_status, fs_layout_type, fs_locations_info, fs_charset_cap
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
supported_attrs、suppattr_exclcreat、fh_expire_type、link_support、symlink_support、unique_handles、aclsupport、cansettime、case_insensitive、case_preserving、chown_restricted、files_avail、files_free、files_total、fs_locations、smooth_space_free_space_free_space_total_space_free_space_total_space_total_space_free_space_total_avail_max_avail_space change_policy、fs_status、fs_layout_type、fs_locations_info、fs_charset_cap
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The per-file system object attributes are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルシステムオブジェクトごとの属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
type, change, size, named_attr, fsid, rdattr_error, filehandle, acl, archive, fileid, hidden, maxlink, mimetype, mode, numlinks, owner, owner_group, rawdev, space_used, system, time_access, time_backup, time_create, time_metadata, time_modify, mounted_on_fileid, dir_notif_delay, dirent_notif_delay, dacl, sacl, layout_type, layout_hint, layout_blksize, layout_alignment, mdsthreshold, retention_get, retention_set, retentevt_get, retentevt_set, retention_hold, mode_set_masked
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
タイプ、変更、サイズ、named_attr、fsid、rdattr_error、filehandle、acl、archive、fileid、hidden、maxlink、mimetype、mode、numlinks、owner、owner_group、rawdev、space_used、system、time_access、time_backup、time_create、time_metadata、time_modify、 Mounted_on_fileid、dir_notif_delay、dirent_notif_delay、dacl、sacl、layout_type、layout_hint、layout_blksize、layout_alignment、mdsthreshold、retention_get、retention_set、retentevt_get、retentevt_set、retention_hold、mode_set_masked
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For quota_avail_hard, quota_avail_soft, and quota_used, see their definitions below for the appropriate classification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_hard、quota_avail_soft、およびquota_usedの適切な分類については、以下の定義を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-5--Set-Only-and-Get-Only-Attributes">
5.5. Set-Only and Get-Only Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Set-OnlyおよびGet-Only属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some REQUIRED and RECOMMENDED attributes are set-only; i.e., they can be set via SETATTR but not retrieved via GETATTR. Similarly, some REQUIRED and RECOMMENDED attributes are get-only; i.e., they can be retrieved via GETATTR but not set via SETATTR. If a client attempts to set a get-only attribute or get a set-only attributes, the server MUST return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のREQUIREDおよびRECOMMENDED属性は設定のみです。つまり、SETATTRを介して設定できますが、GETATTRを介して取得することはできません。同様に、一部のREQUIREDおよびRECOMMENDED属性は取得専用です。つまり、GETATTRを介して取得できますが、SETATTRを介して設定することはできません。クライアントがget-only属性の設定またはset-only属性の取得を試みる場合、サーバーはNFS4ERR_INVALを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-6--REQUIRED-Attributes---List-and-Definition-References">
5.6. REQUIRED Attributes - List and Definition References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. 必須属性-リストと定義の参照
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The list of REQUIRED attributes appears in Table 2. The meaning of the columns of the table are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須属性のリストを表2に示します。表の列の意味は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Name: The name of the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 名前：属性の名前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Id: The number assigned to the attribute. In the event of conflicts between the assigned number and [13], the latter is likely authoritative, but should be resolved with Errata to this document and/or [13]. See [44] for the Errata process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Id：属性に割り当てられた番号。割り当てられた番号と[13]の間に矛盾がある場合、後者は信頼できると思われますが、このドキュメントまたは[13]へのエラッタで解決する必要があります。 Errataプロセスについては[44]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Data Type: The XDR data type of the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o データ型：属性のXDRデータ型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Acc: Access allowed to the attribute. R means read-only (GETATTR may retrieve, SETATTR may not set). W means write-only (SETATTR may set, GETATTR may not retrieve). R W means read/write (GETATTR may retrieve, SETATTR may set).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Acc：属性へのアクセスが許可されています。 Rは読み取り専用を意味します（GETATTRは取得、SETATTRは設定されない場合があります）。 Wは書き込み専用を意味します（SETATTRが設定され、GETATTRが取得されない場合があります）。 R Wは読み取り/書き込みを意味します（GETATTRは取得、SETATTRは設定可能）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Defined in: The section of this specification that describes the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 定義先：属性を説明するこの仕様のセクション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +--------------------+----+------------+-----+------------------+
     | Name               | Id | Data Type  | Acc | Defined in:      |
     +--------------------+----+------------+-----+------------------+
     | supported_attrs    | 0  | bitmap4    | R   | Section 5.8.1.1  |
     | type               | 1  | nfs_ftype4 | R   | Section 5.8.1.2  |
     | fh_expire_type     | 2  | uint32_t   | R   | Section 5.8.1.3  |
     | change             | 3  | uint64_t   | R   | Section 5.8.1.4  |
     | size               | 4  | uint64_t   | R W | Section 5.8.1.5  |
     | link_support       | 5  | bool       | R   | Section 5.8.1.6  |
     | symlink_support    | 6  | bool       | R   | Section 5.8.1.7  |
     | named_attr         | 7  | bool       | R   | Section 5.8.1.8  |
     | fsid               | 8  | fsid4      | R   | Section 5.8.1.9  |
     | unique_handles     | 9  | bool       | R   | Section 5.8.1.10 |
     | lease_time         | 10 | nfs_lease4 | R   | Section 5.8.1.11 |
     | rdattr_error       | 11 | enum       | R   | Section 5.8.1.12 |
     | filehandle         | 19 | nfs_fh4    | R   | Section 5.8.1.13 |
     | suppattr_exclcreat | 75 | bitmap4    | R   | Section 5.8.1.14 |
     +--------------------+----+------------+-----+------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Table 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
表2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-7--RECOMMENDED-Attributes---List-and-Definition-References">
5.7. RECOMMENDED Attributes - List and Definition References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7. 推奨属性-リストおよび定義の参照
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RECOMMENDED attributes are defined in Table 3. The meanings of the column headers are the same as Table 2; see Section 5.6 for the meanings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RECOMMENDED属性は、表3で定義されています。列ヘッダーの意味は、表2と同じです。意味については、5.6項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------------------+----+----------------+-----+------------------+
   | Name               | Id | Data Type      | Acc | Defined in:      |
   +--------------------+----+----------------+-----+------------------+
   | acl                | 12 | nfsace4&lt;&gt;      | R W | Section 6.2.1    |
   | aclsupport         | 13 | uint32_t       | R   | Section 6.2.1.2  |
   | archive            | 14 | bool           | R W | Section 5.8.2.1  |
   | cansettime         | 15 | bool           | R   | Section 5.8.2.2  |
   | case_insensitive   | 16 | bool           | R   | Section 5.8.2.3  |
   | case_preserving    | 17 | bool           | R   | Section 5.8.2.4  |
   | change_policy      | 60 | chg_policy4    | R   | Section 5.8.2.5  |
   | chown_restricted   | 18 | bool           | R   | Section 5.8.2.6  |
   | dacl               | 58 | nfsacl41       | R W | Section 6.2.2    |
   | dir_notif_delay    | 56 | nfstime4       | R   | Section 5.11.1   |
   | dirent_notif_delay | 57 | nfstime4       | R   | Section 5.11.2   |
   | fileid             | 20 | uint64_t       | R   | Section 5.8.2.7  |
   | files_avail        | 21 | uint64_t       | R   | Section 5.8.2.8  |
   | files_free         | 22 | uint64_t       | R   | Section 5.8.2.9  |
   | files_total        | 23 | uint64_t       | R   | Section 5.8.2.10 |
   | fs_charset_cap     | 76 | uint32_t       | R   | Section 5.8.2.11 |
   | fs_layout_type     | 62 | layouttype4&lt;&gt;  | R   | Section 5.12.1   |
   | fs_locations       | 24 | fs_locations   | R   | Section 5.8.2.12 |
   | fs_locations_info  | 67 | *              | R   | Section 5.8.2.13 |
   | fs_status          | 61 | fs4_status     | R   | Section 5.8.2.14 |
   | hidden             | 25 | bool           | R W | Section 5.8.2.15 |
   | homogeneous        | 26 | bool           | R   | Section 5.8.2.16 |
   | layout_alignment   | 66 | uint32_t       | R   | Section 5.12.2   |
   | layout_blksize     | 65 | uint32_t       | R   | Section 5.12.3   |
   | layout_hint        | 63 | layouthint4    |   W | Section 5.12.4   |
   | layout_type        | 64 | layouttype4&lt;&gt;  | R   | Section 5.12.5   |
   | maxfilesize        | 27 | uint64_t       | R   | Section 5.8.2.17 |
   | maxlink            | 28 | uint32_t       | R   | Section 5.8.2.18 |
   | maxname            | 29 | uint32_t       | R   | Section 5.8.2.19 |
   | maxread            | 30 | uint64_t       | R   | Section 5.8.2.20 |
   | maxwrite           | 31 | uint64_t       | R   | Section 5.8.2.21 |
   | mdsthreshold       | 68 | mdsthreshold4  | R   | Section 5.12.6   |
   | mimetype           | 32 | utf8str_cs     | R W | Section 5.8.2.22 |
   | mode               | 33 | mode4          | R W | Section 6.2.4    |
   | mode_set_masked    | 74 | mode_masked4   |   W | Section 6.2.5    |
   | mounted_on_fileid  | 55 | uint64_t       | R   | Section 5.8.2.23 |
   | no_trunc           | 34 | bool           | R   | Section 5.8.2.24 |
   | numlinks           | 35 | uint32_t       | R   | Section 5.8.2.25 |
   | owner              | 36 | utf8str_mixed  | R W | Section 5.8.2.26 |
   | owner_group        | 37 | utf8str_mixed  | R W | Section 5.8.2.27 |
   | quota_avail_hard   | 38 | uint64_t       | R   | Section 5.8.2.28 |
   | quota_avail_soft   | 39 | uint64_t       | R   | Section 5.8.2.29 |
   | quota_used         | 40 | uint64_t       | R   | Section 5.8.2.30 |
   | rawdev             | 41 | specdata4      | R   | Section 5.8.2.31 |
   | retentevt_get      | 71 | retention_get4 | R   | Section 5.13.3   |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | retentevt_set      | 72 | retention_set4 |   W | Section 5.13.4   |
   | retention_get      | 69 | retention_get4 | R   | Section 5.13.1   |
   | retention_hold     | 73 | uint64_t       | R W | Section 5.13.5   |
   | retention_set      | 70 | retention_set4 |   W | Section 5.13.2   |
   | sacl               | 59 | nfsacl41       | R W | Section 6.2.3    |
   | space_avail        | 42 | uint64_t       | R   | Section 5.8.2.32 |
   | space_free         | 43 | uint64_t       | R   | Section 5.8.2.33 |
   | space_total        | 44 | uint64_t       | R   | Section 5.8.2.34 |
   | space_used         | 45 | uint64_t       | R   | Section 5.8.2.35 |
   | system             | 46 | bool           | R W | Section 5.8.2.36 |
   | time_access        | 47 | nfstime4       | R   | Section 5.8.2.37 |
   | time_access_set    | 48 | settime4       |   W | Section 5.8.2.38 |
   | time_backup        | 49 | nfstime4       | R W | Section 5.8.2.39 |
   | time_create        | 50 | nfstime4       | R W | Section 5.8.2.40 |
   | time_delta         | 51 | nfstime4       | R   | Section 5.8.2.41 |
   | time_metadata      | 52 | nfstime4       | R   | Section 5.8.2.42 |
   | time_modify        | 53 | nfstime4       | R   | Section 5.8.2.43 |
   | time_modify_set    | 54 | settime4       |   W | Section 5.8.2.44 |
   +--------------------+----+----------------+-----+------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Table 3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
表3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* fs_locations_info4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* fs_locations_info4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8--Attribute-Definitions">
5.8. Attribute Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8. 属性の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-1--Definitions-of-REQUIRED-Attributes">
5.8.1. Definitions of REQUIRED Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1. 必須属性の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-1-1--Attribute-0-supportedattrs">
5.8.1.1. Attribute 0: supported_attrs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.1. 属性0：supported_attrs
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bit vector that would retrieve all REQUIRED and RECOMMENDED attributes that are supported for this object. The scope of this attribute applies to all objects with a matching fsid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトでサポートされているすべてのREQUIREDおよびRECOMMENDED属性を取得するビットベクトル。この属性のスコープは、一致するfsidを持つすべてのオブジェクトに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-1-2--Attribute-1-type">
5.8.1.2. Attribute 1: type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.2. 属性1：タイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Designates the type of an object in terms of one of a number of special constants:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの特別な定数の1つに関してオブジェクトのタイプを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4REG designates a regular file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4REGは通常のファイルを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4DIR designates a directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4DIRはディレクトリを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4BLK designates a block device special file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4BLKは、ブロックデバイス特殊ファイルを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4CHR designates a character device special file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4CHRは、キャラクタデバイススペシャルファイルを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4LNK designates a symbolic link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4LNKはシンボリックリンクを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4SOCK designates a named socket special file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4SOCKは、名前付きソケット特殊ファイルを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4FIFO designates a fifo special file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4FIFOは、FIFOスペシャルファイルを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4ATTRDIR designates a named attribute directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4ATTRDIRは、名前付き属性ディレクトリを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4NAMEDATTR designates a named attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NF4NAMEDATTRは名前付き属性を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Within the explanatory text and operation descriptions, the following phrases will be used with the meanings given below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明文と操作説明では、次の語句は以下の意味で使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The phrase &#34;is a directory&#34; means that the object&#39;s type attribute is NF4DIR or NF4ATTRDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「is a directory」という語句は、オブジェクトのtype属性がNF4DIRまたはNF4ATTRDIRであることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The phrase &#34;is a special file&#34; means that the object&#39;s type attribute is NF4BLK, NF4CHR, NF4SOCK, or NF4FIFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「特殊ファイルです」という語句は、オブジェクトのタイプ属性がNF4BLK、NF4CHR、NF4SOCK、またはNF4FIFOであることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The phrases &#34;is an ordinary file&#34; and &#34;is a regular file&#34; mean that the object&#39;s type attribute is NF4REG or NF4NAMEDATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「通常のファイルです」および「通常のファイルです」というフレーズは、オブジェクトのタイプ属性がNF4REGまたはNF4NAMEDATTRであることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-1-3--Attribute-2-fhexpiretype">
5.8.1.3. Attribute 2: fh_expire_type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.3. 属性2：fh_expire_type
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server uses this to specify filehandle expiration behavior to the client. See Section 4 for additional description.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはこれを使用して、ファイルハンドルの有効期限の動作をクライアントに指定します。詳細については、セクション4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-1-4--Attribute-3-change">
5.8.1.4. Attribute 3: change
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.4. 属性3：変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A value created by the server that the client can use to determine if file data, directory contents, or attributes of the object have been modified. The server may return the object&#39;s time_metadata attribute for this attribute&#39;s value, but only if the file system object cannot be updated more frequently than the resolution of time_metadata.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが作成した値で、クライアントがオブジェクトのファイルデータ、ディレクトリの内容、または属性が変更されているかどうかを判断するために使用できます。サーバーは、この属性の値に対してオブジェクトのtime_metadata属性を返すことがありますが、それは、ファイルシステムオブジェクトがtime_metadataの解像度よりも頻繁に更新できない場合に限られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-1-5--Attribute-4-size">
5.8.1.5. Attribute 4: size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.5. 属性4：サイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The size of the object in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトのサイズ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-1-6--Attribute-5-linksupport">
5.8.1.6. Attribute 5: link_support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.6. 属性5：link_support
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if the object&#39;s file system supports hard links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトのファイルシステムがハードリンクをサポートしている場合はTRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-1-7--Attribute-6-symlinksupport">
5.8.1.7. Attribute 6: symlink_support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.7. 属性6：symlink_support
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if the object&#39;s file system supports symbolic links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトのファイルシステムがシンボリックリンクをサポートしている場合はTRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-1-8--Attribute-7-namedattr">
5.8.1.8. Attribute 7: named_attr
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.8. 属性7：named_attr
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if this object has named attributes. In other words, object has a non-empty named attribute directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトに名前付き属性がある場合はTRUE。つまり、オブジェクトには空でない名前付き属性ディレクトリがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-1-9--Attribute-8-fsid">
5.8.1.9. Attribute 8: fsid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.9. 属性8：fsid
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unique file system identifier for the file system holding this object. The fsid attribute has major and minor components, each of which are of data type uint64_t.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトを保持するファイルシステムの一意のファイルシステム識別子。 fsid属性には、メジャーコンポーネントとマイナーコンポーネントがあり、それぞれデータタイプuint64_tです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-1-10--Attribute-9-uniquehandles">
5.8.1.10. Attribute 9: unique_handles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.10. 属性9：unique_handles
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if two distinct filehandles are guaranteed to refer to two different file system objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つの異なるファイルハンドルが2つの異なるファイルシステムオブジェクトを参照することが保証されている場合はTRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-1-11--Attribute-10-leasetime">
5.8.1.11. Attribute 10: lease_time
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.11. 属性10：lease_time
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Duration of the lease at server in seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーでのリース期間（秒単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-1-12--Attribute-11-rdattrerror">
5.8.1.12. Attribute 11: rdattr_error
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.12. 属性11：rdattr_error
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error returned from an attempt to retrieve attributes during a READDIR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR操作中に属性を取得しようとしたときに返されたエラー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-1-13--Attribute-19-filehandle">
5.8.1.13. Attribute 19: filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.13. 属性19：ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The filehandle of this object (primarily for READDIR requests).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトのファイルハンドル（主にREADDIRリクエスト用）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-1-14--Attribute-75-suppattrexclcreat">
5.8.1.14. Attribute 75: suppattr_exclcreat
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.14. 属性75：suppattr_exclcreat
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bit vector that would set all REQUIRED and RECOMMENDED attributes that are supported by the EXCLUSIVE4_1 method of file creation via the OPEN operation. The scope of this attribute applies to all objects with a matching fsid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN操作によるファイル作成のEXCLUSIVE4_1メソッドでサポートされるすべてのREQUIREDおよびRECOMMENDED属性を設定するビットベクトル。この属性のスコープは、一致するfsidを持つすべてのオブジェクトに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2--Definitions-of-Uncategorized-RECOMMENDED-Attributes">
5.8.2. Definitions of Uncategorized RECOMMENDED Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2. 未分類の推奨属性の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The definitions of most of the RECOMMENDED attributes follow. Collections that share a common category are defined in other sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどのRECOMMENDED属性の定義は次のとおりです。共通のカテゴリを共有するコレクションは、他のセクションで定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-1--Attribute-14-archive">
5.8.2.1. Attribute 14: archive
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.1. 属性14：アーカイブ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if this file has been archived since the time of last modification (deprecated in favor of time_backup).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE、このファイルが最後に変更された時刻以降にアーカイブされている場合（time_backupのために非推奨）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-2--Attribute-15-cansettime">
5.8.2.2. Attribute 15: cansettime
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.2. 属性15：cansettime
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if the server is able to change the times for a file system object as specified in a SETATTR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがSETATTR操作で指定されたファイルシステムオブジェクトの時間を変更できる場合はTRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-3--Attribute-16-caseinsensitive">
5.8.2.3. Attribute 16: case_insensitive
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.3. 属性16：case_insensitive
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if file name comparisons on this file system are case insensitive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このファイルシステムでのファイル名の比較で大文字と小文字が区別されない場合はTRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-4--Attribute-17-casepreserving">
5.8.2.4. Attribute 17: case_preserving
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.4. 属性17：case_preserving
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if file name case on this file system is preserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このファイルシステムのファイル名の大文字と小文字が保持される場合はTRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-5--Attribute-60-changepolicy">
5.8.2.5. Attribute 60: change_policy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.5. 属性60：change_policy
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A value created by the server that the client can use to determine if some server policy related to the current file system has been subject to change. If the value remains the same, then the client can be sure that the values of the attributes related to fs location and the fss_type field of the fs_status attribute have not changed. On the other hand, a change in this value does necessarily imply a change in policy. It is up to the client to interrogate the server to determine if some policy relevant to it has changed. See Section 3.3.6 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが現在のファイルシステムに関連する一部のサーバーポリシーが変更される可能性があるかどうかを判断するために使用できるサーバーによって作成された値。値が同じ場合、クライアントは、fsの場所に関連する属性の値とfs_status属性のfss_typeフィールドが変更されていないことを確認できます。一方、この値の変化は必然的にポリシーの変化を意味します。サーバーに問い合わせて、サーバーに関連するポリシーが変更されたかどうかを判断するのは、クライアントの責任です。詳細については、セクション3.3.6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This attribute MUST change when the value returned by the fs_locations or fs_locations_info attribute changes, when a file system goes from read-only to writable or vice versa, or when the allowable set of security flavors for the file system or any part thereof is changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この属性は、fs_locationsまたはfs_locations_info属性によって返される値が変更された場合、ファイルシステムが読み取り専用から書き込み可能に変更された場合、またはその逆の場合、またはファイルシステムまたはその一部のセキュリティフレーバーの許容セットが変更された場合に変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-6--Attribute-18-chownrestricted">
5.8.2.6. Attribute 18: chown_restricted
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.6. 属性18：chown_restricted
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If TRUE, the server will reject any request to change either the owner or the group associated with a file if the caller is not a privileged user (for example, &#34;root&#34; in UNIX operating environments or, in Windows 2000, the &#34;Take Ownership&#34; privilege).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUEの場合、呼び出し元が特権ユーザー（たとえば、UNIXオペレーティング環境の「root」、Windows 2000の場合は「Take Ownership」の場合、サーバーはファイルに関連付けられた所有者またはグループのいずれかを変更する要求を拒否します。 「特権）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-7--Attribute-20-fileid">
5.8.2.7. Attribute 20: fileid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.7. 属性20：fileid
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number uniquely identifying the file within the file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステム内でファイルを一意に識別する番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-8--Attribute-21-filesavail">
5.8.2.8. Attribute 21: files_avail
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.8. 属性21：files_avail
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
File slots available to this user on the file system containing this object -- this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトを含むファイルシステムでこのユーザーが使用できるファイルスロット-これは、関連する最小の制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-9--Attribute-22-filesfree">
5.8.2.9. Attribute 22: files_free
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.9. 属性22：files_free
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Free file slots on the file system containing this object -- this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトを含むファイルシステムの空きファイルスロット-これは、関連する最小の制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-10--Attribute-23-filestotal">
5.8.2.10. Attribute 23: files_total
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.10. 属性23：files_total
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Total file slots on the file system containing this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトを含むファイルシステム上の合計ファイルスロット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-11--Attribute-76-fscharsetcap">
5.8.2.11. Attribute 76: fs_charset_cap
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.11. 属性76：fs_charset_cap
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Character set capabilities for this file system. See Section 14.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このファイルシステムの文字セット機能。セクション14.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-12--Attribute-24-fslocations">
5.8.2.12. Attribute 24: fs_locations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.12. 属性24：fs_locations
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Locations where this file system may be found. If the server returns NFS4ERR_MOVED as an error, this attribute MUST be supported. See Section 11.9 for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このファイルシステムが見つかる可能性のある場所。サーバーがエラーとしてNFS4ERR_MOVEDを返す場合、この属性はサポートされている必要があります。詳細については、セクション11.9を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-13--Attribute-67-fslocationsinfo">
5.8.2.13. Attribute 67: fs_locations_info
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.13. 属性67：fs_locations_info
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Full function file system location. See Section 11.10 for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
全機能ファイルシステムの場所。詳細については、セクション11.10を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-14--Attribute-61-fsstatus">
5.8.2.14. Attribute 61: fs_status
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.14. 属性61：fs_status
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Generic file system type information. See Section 11.11 for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
汎用ファイルシステムタイプ情報。詳細については、セクション11.11を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-15--Attribute-25-hidden">
5.8.2.15. Attribute 25: hidden
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.15. 属性25：非表示
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if the file is considered hidden with respect to the Windows API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Windows APIに関してファイルが非表示と見なされる場合はTRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-16--Attribute-26-homogeneous">
5.8.2.16. Attribute 26: homogeneous
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.16. 属性26：同種
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUE, if this object&#39;s file system is homogeneous; i.e., all objects in the file system (all objects on the server with the same fsid) have common values for all per-file-system attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトのファイルシステムが同種の場合はTRUE。つまり、ファイルシステム内のすべてのオブジェクト（同じfsidを持つサーバー上のすべてのオブジェクト）は、ファイルシステムごとのすべての属性に共通の値を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-17--Attribute-27-maxfilesize">
5.8.2.17. Attribute 27: maxfilesize
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.17. 属性27：maxfilesize
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Maximum supported file size for the file system of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトのファイルシステムでサポートされる最大ファイルサイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-18--Attribute-28-maxlink">
5.8.2.18. Attribute 28: maxlink
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.18. 属性28：maxlink
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Maximum number of links for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトのリンクの最大数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-19--Attribute-29-maxname">
5.8.2.19. Attribute 29: maxname
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.19. 属性29：maxname
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Maximum file name size supported for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトでサポートされる最大ファイル名サイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-20--Attribute-30-maxread">
5.8.2.20. Attribute 30: maxread
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.20. 属性30：maxread
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Maximum amount of data the READ operation will return for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトに対してREAD操作が返すデータの最大量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-21--Attribute-31-maxwrite">
5.8.2.21. Attribute 31: maxwrite
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.21. 属性31：maxwrite
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Maximum amount of data the WRITE operation will accept for this object. This attribute SHOULD be supported if the file is writable. Lack of this attribute can lead to the client either wasting bandwidth or not receiving the best performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトに対してWRITE操作が受け入れるデータの最大量。ファイルが書き込み可能である場合、この属性はサポートされるべきです（SHOULD）。この属性がないと、クライアントが帯域幅を浪費したり、最高のパフォーマンスを受け取っていない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-22--Attribute-32-mimetype">
5.8.2.22. Attribute 32: mimetype
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.22. 属性32：mimetype
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MIME body type/subtype of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトのMIME本文タイプ/サブタイプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-23--Attribute-55-mountedonfileid">
5.8.2.23. Attribute 55: mounted_on_fileid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.23. 属性55：Mounted_on_fileid
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Like fileid, but if the target filehandle is the root of a file system, this attribute represents the fileid of the underlying directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fileidに似ていますが、ターゲットファイルハンドルがファイルシステムのルートである場合、この属性は基礎となるディレクトリのfileidを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIX-based operating environments connect a file system into the namespace by connecting (mounting) the file system onto the existing file object (the mount point, usually a directory) of an existing file system. When the mount point&#39;s parent directory is read via an API like readdir(), the return results are directory entries, each with a component name and a fileid. The fileid of the mount point&#39;s directory entry will be different from the fileid that the stat() system call returns. The stat() system call is returning the fileid of the root of the mounted file system, whereas readdir() is returning the fileid that stat() would have returned before any file systems were mounted on the mount point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIXベースのオペレーティング環境では、ファイルシステムを既存のファイルシステムの既存のファイルオブジェクト（マウントポイント、通常はディレクトリ）に接続（マウント）することにより、ファイルシステムをネームスペースに接続します。マウントポイントの親ディレクトリがreaddir()のようなAPIを介して読み取られると、返される結果はディレクトリエントリであり、それぞれにコンポーネント名とファイルIDがあります。マウントポイントのディレクトリエントリのファイルIDは、stat()システムコールが返すファイルIDとは異なります。 stat()システムコールはマウントされたファイルシステムのルートのファイルIDを返しますが、readdir()は、ファイルシステムがマウントポイントにマウントされる前にstat()が返したはずのファイルIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike NFSv3, NFSv4.1 allows a client&#39;s LOOKUP request to cross other file systems. The client detects the file system crossing whenever the filehandle argument of LOOKUP has an fsid attribute different from that of the filehandle returned by LOOKUP. A UNIX-based client will consider this a &#34;mount point crossing&#34;. UNIX has a legacy scheme for allowing a process to determine its current working directory. This relies on readdir() of a mount point&#39;s parent and stat() of the mount point returning fileids as previously described. The mounted_on_fileid attribute corresponds to the fileid that readdir() would have returned as described previously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv3とは異なり、NFSv4.1では、クライアントのLOOKUP要求が他のファイルシステムを通過することができます。クライアントは、LOOKUPのfilehandle引数に、LOOKUPから返されたファイルハンドルのfsid属性とは異なるfsid属性がある場合に、ファイルシステムの交差を検出します。 UNIXベースのクライアントは、これを「マウントポイントクロッシング」と見なします。 UNIXには、プロセスが現在の作業ディレクトリを決定できるようにするためのレガシースキームがあります。これは、前述のように、マウントポイントの親のreaddir()とマウントポイントのstat()がファイルIDを返すことに依存しています。 Mounted_on_fileid属性は、前述のようにreaddir()が返すはずのファイルIDに対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the NFSv4.1 client could simply fabricate a fileid corresponding to what mounted_on_fileid provides (and if the server does not support mounted_on_fileid, the client has no choice), there is a risk that the client will generate a fileid that conflicts with one that is already assigned to another object in the file system. Instead, if the server can provide the mounted_on_fileid, the potential for client operational problems in this area is eliminated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1クライアントは、mounted_on_fileidが提供するものに対応するファイルIDを単純に作成することができます（サーバーがMounted_on_fileidをサポートしていない場合、クライアントは選択肢がありません）。ただし、クライアントは、ファイルシステム内の別のオブジェクトに既に割り当てられています。代わりに、サーバーがMounted_on_fileidを提供できる場合、この領域でのクライアントの操作上の問題の可能性は排除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server detects that there is no mounted point at the target file object, then the value for mounted_on_fileid that it returns is the same as that of the fileid attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットファイルオブジェクトにマウントされたポイントがないことをサーバーが検出した場合、サーバーが返すMounted_on_fileidの値は、fileid属性の値と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mounted_on_fileid attribute is RECOMMENDED, so the server SHOULD provide it if possible, and for a UNIX-based server, this is straightforward. Usually, mounted_on_fileid will be requested during a READDIR operation, in which case it is trivial (at least for UNIX-based servers) to return mounted_on_fileid since it is equal to the fileid of a directory entry returned by readdir(). If mounted_on_fileid is requested in a GETATTR operation, the server should obey an invariant that has it returning a value that is equal to the file object&#39;s entry in the object&#39;s parent directory, i.e., what readdir() would have returned. Some operating environments allow a series of two or more file systems to be mounted onto a single mount point. In this case, for the server to obey the aforementioned invariant, it will need to find the base mount point, and not the intermediate mount points.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mounted_on_fileid属性は推奨されるので、サーバーは可能であればそれを提供する必要があります（SHOULD）。UNIXベースのサーバーの場合、これは簡単です。通常、mounted_on_fileidはREADDIR操作中に要求されます。その場合、readdir()によって返されるディレクトリエントリのfileidと等しいため、mounted_on_fileidを返すのは（少なくともUNIXベースのサーバーの場合）簡単です。 GETATTR操作でMounted_on_fileidが要求された場合、サーバーは、オブジェクトの親ディレクトリにあるファイルオブジェクトのエントリと等しい値を返す不変条件に従う必要があります。つまり、readdir()が返す結果になります。一部の動作環境では、一連の2つ以上のファイルシステムを単一のマウントポイントにマウントできます。この場合、サーバーが前述の不変式に従うためには、中間マウントポイントではなく、ベースマウントポイントを見つける必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-24--Attribute-34-notrunc">
5.8.2.24. Attribute 34: no_trunc
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.24. 属性34：no_trunc
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If this attribute is TRUE, then if the client uses a file name longer than name_max, an error will be returned instead of the name being truncated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この属性がTRUEの場合、クライアントがname_maxより長いファイル名を使用すると、名前が切り捨てられる代わりにエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-25--Attribute-35-numlinks">
5.8.2.25. Attribute 35: numlinks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.25. 属性35：numlinks
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Number of hard links to this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトへのハードリンクの数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-26--Attribute-36-owner">
5.8.2.26. Attribute 36: owner
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.26. 属性36：所有者
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The string name of the owner of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトの所有者の文字列名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-27--Attribute-37-ownergroup">
5.8.2.27. Attribute 37: owner_group
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.27. 属性37：owner_group
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The string name of the group ownership of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトのグループ所有権の文字列名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-28--Attribute-38-quotaavailhard">
5.8.2.28. Attribute 38: quota_avail_hard
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.28. 属性38：quota_avail_hard
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value in bytes that represents the amount of additional disk space beyond the current allocation that can be allocated to this file or directory before further allocations will be refused. It is understood that this space may be consumed by allocations to other files or directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これ以上の割り当てが拒否される前に、このファイルまたはディレクトリに割り当てることができる現在の割り当てを超える追加のディスク領域の量を表すバイト単位の値。このスペースは、他のファイルまたはディレクトリへの割り当てによって消費される可能性があることを理解してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-29--Attribute-39-quotaavailsoft">
5.8.2.29. Attribute 39: quota_avail_soft
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.29. 属性39：quota_avail_soft
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value in bytes that represents the amount of additional disk space that can be allocated to this file or directory before the user may reasonably be warned. It is understood that this space may be consumed by allocations to other files or directories though there is a rule as to which other files or directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーに警告が出る前にこのファイルまたはディレクトリに割り当てることができる追加のディスク容量を表すバイト単位の値。このスペースは、他のファイルまたはディレクトリに関する規則はありますが、他のファイルまたはディレクトリへの割り当てによって消費される可能性があることは理解されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-30--Attribute-40-quotaused">
5.8.2.30. Attribute 40: quota_used
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.30. 属性40：quota_used
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value in bytes that represents the amount of disk space used by this file or directory and possibly a number of other similar files or directories, where the set of &#34;similar&#34; meets at least the criterion that allocating space to any file or directory in the set will reduce the &#34;quota_avail_hard&#34; of every other file or directory in the set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このファイルまたはディレクトリ、および場合によっては他の類似のファイルまたはディレクトリによって使用されるディスク領域の量を表すバイト単位の値。「類似」のセットは、少なくともファイル内の任意のファイルまたはディレクトリに領域を割り当てる基準を満たします。セットは、セット内の他のすべてのファイルまたはディレクトリの「quota_avail_hard」を減らします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that there may be a number of distinct but overlapping sets of files or directories for which a quota_used value is maintained, e.g., &#34;all files with a given owner&#34;, &#34;all files with a given group owner&#34;, etc. The server is at liberty to choose any of those sets when providing the content of the quota_used attribute, but should do so in a repeatable way. The rule may be configured per file system or may be &#34;choose the set with the smallest quota&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_used値が維持されるファイルまたはディレクトリのセットは、重複している場合があります。たとえば、「特定の所有者を持つすべてのファイル」、「特定のグループ所有者を持つすべてのファイル」などです。サーバーはquota_used属性のコンテンツを提供するときに、これらのセットのいずれかを自由に選択できますが、繰り返し可能な方法で行う必要があります。ルールはファイルシステムごとに構成することも、「クォータが最小のセットを選択する」こともできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-31--Attribute-41-rawdev">
5.8.2.31. Attribute 41: rawdev
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.31. 属性41：rawdev
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Raw device number of file of type NF4BLK or NF4CHR. The device number is split into major and minor numbers. If the file&#39;s type attribute is not NF4BLK or NF4CHR, the value returned SHOULD NOT be considered useful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプNF4BLKまたはNF4CHRのファイルのrawデバイス番号。デバイス番号は、メジャー番号とマイナー番号に分かれています。ファイルのtype属性がNF4BLKまたはNF4CHRでない場合、返される値は有用であるとは見なされません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-32--Attribute-42-spaceavail">
5.8.2.32. Attribute 42: space_avail
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.32. 属性42：space_avail
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Disk space in bytes available to this user on the file system containing this object -- this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトを含むファイルシステム上でこのユーザーが使用できるディスク容量（バイト単位）-これは、関連する最小の制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-33--Attribute-43-spacefree">
5.8.2.33. Attribute 43: space_free
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.33. 属性43：space_free
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Free disk space in bytes on the file system containing this object -- this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトを含むファイルシステムの空きディスク容量（バイト単位）-これは、関連する最小の制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-34--Attribute-44-spacetotal">
5.8.2.34. Attribute 44: space_total
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.34. 属性44：space_total
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Total disk space in bytes on the file system containing this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトを含むファイルシステムの合計ディスク容量（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-35--Attribute-45-spaceused">
5.8.2.35. Attribute 45: space_used
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.35. 属性45：space_used
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Number of file system bytes allocated to this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトに割り当てられているファイルシステムのバイト数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-36--Attribute-46-system">
5.8.2.36. Attribute 46: system
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.36. 属性46：システム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This attribute is TRUE if this file is a &#34;system&#34; file with respect to the Windows operating environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このファイルがWindowsオペレーティング環境に関して「システム」ファイルである場合、この属性はTRUEです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-37--Attribute-47-timeaccess">
5.8.2.37. Attribute 47: time_access
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.37. 属性47：time_access
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The time_access attribute represents the time of last access to the object by a READ operation sent to the server. The notion of what is an &#34;access&#34; depends on the server&#39;s operating environment and/or the server&#39;s file system semantics. For example, for servers obeying Portable Operating System Interface (POSIX) semantics, time_access would be updated only by the READ and READDIR operations and not any of the operations that modify the content of the object [16], [17], [18]. Of course, setting the corresponding time_access_set attribute is another way to modify the time_access attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_access属性は、サーバーに送信されたREAD操作によるオブジェクトへの最後のアクセスの時刻を表します。 「アクセス」とは何かの概念は、サーバーの動作環境やサーバーのファイルシステムのセマンティクスによって異なります。たとえば、ポータブルオペレーティングシステムインターフェイス（POSIX）セマンティクスに従うサーバーの場合、time_accessはREADおよびREADDIR操作によってのみ更新され、オブジェクトのコンテンツを変更する操作では更新されません[16]、[17]、[18] 。もちろん、対応するtime_access_set属性を設定することは、time_access属性を変更するもう1つの方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever the file object resides on a writable file system, the server should make its best efforts to record time_access into stable storage. However, to mitigate the performance effects of doing so, and most especially whenever the server is satisfying the read of the object&#39;s content from its cache, the server MAY cache access time updates and lazily write them to stable storage. It is also acceptable to give administrators of the server the option to disable time_access updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルオブジェクトが書き込み可能なファイルシステムに存在する場合は常に、サーバーはtime_accessを安定したストレージに記録するために最善を尽くす必要があります。ただし、そうすることによるパフォーマンスへの影響を軽減するために、特にサーバーがキャッシュからのオブジェクトのコンテンツの読み取りを満たしている場合は常に、サーバーはアクセス時間の更新をキャッシュして、それらを安定したストレージに遅延書き込みする場合があります。サーバーの管理者に、time_access更新を無効にするオプションを与えることもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-38--Attribute-48-timeaccessset">
5.8.2.38. Attribute 48: time_access_set
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.38. 属性48：time_access_set
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sets the time of last access to the object. SETATTR use only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトに最後にアクセスした時刻を設定します。 SETATTRの使用のみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-39--Attribute-49-timebackup">
5.8.2.39. Attribute 49: time_backup
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.39. 属性49：time_backup
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The time of last backup of the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトの最後のバックアップの時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-40--Attribute-50-timecreate">
5.8.2.40. Attribute 50: time_create
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.40. 属性50：time_create
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The time of creation of the object. This attribute does not have any relation to the traditional UNIX file attribute &#34;ctime&#34; or &#34;change time&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトの作成時刻。この属性は、従来のUNIXファイル属性「ctime」または「change time」とは関係ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-41--Attribute-51-timedelta">
5.8.2.41. Attribute 51: time_delta
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.41. 属性51：time_delta
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Smallest useful server time granularity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最小の有用なサーバー時間の細分性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-42--Attribute-52-timemetadata">
5.8.2.42. Attribute 52: time_metadata
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.42. 属性52：time_metadata
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The time of last metadata modification of the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトのメタデータが最後に変更された時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-43--Attribute-53-timemodify">
5.8.2.43. Attribute 53: time_modify
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.43. 属性53：time_modify
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The time of last modification to the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトが最後に変更された時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8-2-44--Attribute-54-timemodifyset">
5.8.2.44. Attribute 54: time_modify_set
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.44. 属性54：time_modify_set
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sets the time of last modification to the object. SETATTR use only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトの最終変更時刻を設定します。 SETATTRの使用のみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-9--Interpreting-owner-and-ownergroup">
5.9. Interpreting owner and owner_group
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.9. ownerおよびowner_groupの解釈
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RECOMMENDED attributes &#34;owner&#34; and &#34;owner_group&#34; (and also users and groups within the &#34;acl&#34; attribute) are represented in terms of a UTF-8 string. To avoid a representation that is tied to a particular underlying implementation at the client or server, the use of the UTF-8 string has been chosen. Note that Section 6.1 of RFC 2624 [45] provides additional rationale. It is expected that the client and server will have their own local representation of owner and owner_group that is used for local storage or presentation to the end user. Therefore, it is expected that when these attributes are transferred between the client and server, the local representation is translated to a syntax of the form &#34;user@dns_domain&#34;. This will allow for a client and server that do not use the same local representation the ability to translate to a common syntax that can be interpreted by both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
推奨属性「owner」と「owner_group」（および「acl」属性内のユーザーとグループ）は、UTF-8文字列で表されます。クライアントまたはサーバーで特定の基本的な実装に関連付けられている表現を回避するために、UTF-8文字列の使用が選択されています。 RFC 2624 [45]のセクション6.1が追加の根拠を提供していることに注意してください。クライアントとサーバーは、ローカルストレージまたはエンドユーザーへの提示に使用される所有者とowner_groupの独自のローカル表現を持つことが期待されます。したがって、これらの属性がクライアントとサーバーの間で転送されると、ローカル表現が「user @ dns_domain」の形式の構文に変換されることが予想されます。これにより、同じローカル表現を使用しないクライアントとサーバーが、両方で解釈できる共通の構文に変換できるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, security principals may be represented in different ways by different security mechanisms. Servers normally translate these representations into a common format, generally that used by local storage, to serve as a means of identifying the users corresponding to these security principals. When these local identifiers are translated to the form of the owner attribute, associated with files created by such principals, they identify, in a common format, the users associated with each corresponding set of security principals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、セキュリティプリンシパルは、さまざまなセキュリティメカニズムによってさまざまな方法で表すことができます。サーバーは通常、これらの表現を一般的にローカルストレージで使用される一般的な形式に変換し、これらのセキュリティプリンシパルに対応するユーザーを識別する手段として機能します。これらのローカル識別子は、そのようなプリンシパルによって作成されたファイルに関連付けられた所有者属性の形式に変換されると、セキュリティプリンシパルの対応する各セットに関連付けられたユーザーを共通の形式で識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The translation used to interpret owner and group strings is not specified as part of the protocol. This allows various solutions to be employed. For example, a local translation table may be consulted that maps a numeric identifier to the user@dns_domain syntax. A name service may also be used to accomplish the translation. A server may provide a more general service, not limited by any particular translation (which would only translate a limited set of possible strings) by storing the owner and owner_group attributes in local storage without any translation or it may augment a translation method by storing the entire string for attributes for which no translation is available while using the local representation for those cases in which a translation is available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者とグループの文字列を解釈するために使用される変換は、プロトコルの一部として指定されていません。これにより、さまざまなソリューションを使用できます。たとえば、数値識別子をuser @ dns_domain構文にマップするローカル変換テーブルが参照される場合があります。ネームサービスを使用して、変換を行うこともできます。サーバーは、owner属性とowner_group属性をローカルストレージに翻訳なしで保存することにより、特定の翻訳に限定されない（可能な文字列の限られたセットのみを翻訳する）より一般的なサービスを提供するか、または翻訳が利用可能な場合にローカル表現を使用しているときに、翻訳が利用できない属性の文字列全体。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers that do not provide support for all possible values of the owner and owner_group attributes SHOULD return an error (NFS4ERR_BADOWNER) when a string is presented that has no translation, as the value to be set for a SETATTR of the owner, owner_group, or acl attributes. When a server does accept an owner or owner_group value as valid on a SETATTR (and similarly for the owner and group strings in an acl), it is promising to return that same string when a corresponding GETATTR is done. Configuration changes (including changes from the mapping of the string to the local representation) and ill-constructed name translations (those that contain aliasing) may make that promise impossible to honor. Servers should make appropriate efforts to avoid a situation in which these attributes have their values changed when no real change to ownership has occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者、owner_group、またはaclのSETATTRに設定する値として、変換されていない文字列が提示されると、ownerおよびowner_group属性のすべての可能な値のサポートを提供しないサーバーはエラー（NFS4ERR_BADOWNER）を返す必要があります（SHOULD）。属性。サーバーが所有者またはowner_groupの値をSETATTRで有効であると（そして同様にACLの所有者およびグループ文字列でも）受け入れる場合、対応するGETATTRが実行されたときに同じ文字列を返すことが約束されています。構成の変更（文字列のローカル表現へのマッピングからの変更を含む）および不適切な名前の変換（エイリアシングを含むもの）により、その約束を守ることが不可能になる場合があります。サーバーは、所有権に実際の変更が発生していないときにこれらの属性の値が変更される状況を回避するために、適切な努力をする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;dns_domain&#34; portion of the owner string is meant to be a DNS domain name, for example, user@example.org. Servers should accept as valid a set of users for at least one domain. A server may treat other domains as having no valid translations. A more general service is provided when a server is capable of accepting users for multiple domains, or for all domains, subject to security constraints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者文字列の「dns_domain」の部分は、user @ example.orgなどのDNSドメイン名であることを意味します。サーバーは、少なくとも1つのドメインのユーザーのセットを有効なものとして受け入れる必要があります。サーバーは他のドメインを有効な翻訳がないものとして扱う場合があります。サーバーが複数のドメインまたはすべてのドメインのユーザーを受け入れることができる場合、より一般的なサービスが提供され、セキュリティの制約を受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case where there is no translation available to the client or server, the attribute value will be constructed without the &#34;@&#34;. Therefore, the absence of the @ from the owner or owner_group attribute signifies that no translation was available at the sender and that the receiver of the attribute should not use that string as a basis for translation into its own internal format. Even though the attribute value cannot be translated, it may still be useful. In the case of a client, the attribute string may be used for local display of ownership.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントまたはサーバーで使用可能な変換がない場合、属性値は「@」なしで構築されます。したがって、ownerまたはowner_group属性に@がない場合は、送信側で変換が利用できなかったこと、および属性の受信側がその文字列を独自の内部形式への変換の基礎として使用してはならないことを意味します。属性値は変換できませんが、それでも役立つ場合があります。クライアントの場合、所有権のローカル表示に属性文字列を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide a greater degree of compatibility with NFSv3, which identified users and groups by 32-bit unsigned user identifiers and group identifiers, owner and group strings that consist of decimal numeric values with no leading zeros can be given a special interpretation by clients and servers that choose to provide such support. The receiver may treat such a user or group string as representing the same user as would be represented by an NFSv3 uid or gid having the corresponding numeric value. A server is not obligated to accept such a string, but may return an NFS4ERR_BADOWNER instead. To avoid this mechanism being used to subvert user and group translation, so that a client might pass all of the owners and groups in numeric form, a server SHOULD return an NFS4ERR_BADOWNER error when there is a valid translation for the user or owner designated in this way. In that case, the client must use the appropriate name@domain string and not the special form for compatibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32ビットの署名されていないユーザー識別子とグループ識別子によってユーザーとグループを識別したNFSv3との互換性を高めるために、先行ゼロのない10進数の数値で構成される所有者とグループの文字列に、クライアントとサーバーによる特別な解釈を与えることができます。そのようなサポートを提供することを選択します。受信者は、そのようなユーザーまたはグループ文字列を、対応する数値を持つNFSv3 uidまたはgidによって表されるのと同じユーザーを表すものとして扱うことができます。サーバーはそのような文字列を受け入れる義務はありませんが、代わりにNFS4ERR_BADOWNERを返す場合があります。このメカニズムがユーザーとグループの変換を覆すために使用されないようにして、クライアントがすべての所有者とグループを数値形式で渡すことができるように、サーバーは、これで指定されたユーザーまたは所有者の有効な変換があるときにNFS4ERR_BADOWNERエラーを返す必要があります。仕方。その場合、クライアントは、互換性のための特別な形式ではなく、適切なname @ domain文字列を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The owner string &#34;nobody&#34; may be used to designate an anonymous user, which will be associated with a file created by a security principal that cannot be mapped through normal means to the owner attribute. Users and implementations of NFSv4.1 SHOULD NOT use &#34;nobody&#34; to designate a real user whose access is not anonymous.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者文字列「nobody」は、匿名ユーザーを指定するために使用できます。匿名ユーザーは、通常の方法では所有者属性にマップできないセキュリティプリンシパルによって作成されたファイルに関連付けられます。 NFSv4.1のユーザーと実装は、「nobody」を使用して、アクセスが匿名ではない実際のユーザーを指定してはなりません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-10--Character-Case-Attributes">
5.10. Character Case Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.10. 文字ケース属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With respect to the case_insensitive and case_preserving attributes, each UCS-4 character (which UTF-8 encodes) can be mapped according to Appendix B.2 of RFC 3454 [19]. For general character handling and internationalization issues, see Section 14.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
case_insensitiveおよびcase_preserving属性に関して、各UCS-4文字（UTF-8がエンコード）は、RFC 3454 [19]の付録B.2に従ってマッピングできます。一般的な文字処理と国際化の問題については、セクション14を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-11--Directory-Notification-Attributes">
5.11. Directory Notification Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11. ディレクトリ通知属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 18.39, the client can request a minimum delay for notifications of changes to attributes, but the server is free to ignore what the client requests. The client can determine in advance what notification delays the server will accept by sending a GETATTR operation for either or both of two directory notification attributes. When the client calls the GET_DIR_DELEGATION operation and asks for attribute change notifications, it should request notification delays that are no less than the values in the server-provided attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション18.39で説明したように、クライアントは属性の変更通知の最小遅延を要求できますが、サーバーはクライアントが要求するものを自由に無視できます。クライアントは、2つのディレクトリ通知属性のいずれかまたは両方に対してGETATTR操作を送信することで、サーバーが受け入れる通知の遅延を事前に決定できます。クライアントがGET_DIR_DELEGATION操作を呼び出し、属性変更通知を要求する場合、サーバーが提供する属性の値以上の通知遅延を要求する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-11-1--Attribute-56-dirnotifdelay">
5.11.1. Attribute 56: dir_notif_delay
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.1. 属性56：dir_notif_delay
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The dir_notif_delay attribute is the minimum number of seconds the server will delay before notifying the client of a change to the directory&#39;s attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
dir_notif_delay属性は、ディレクトリの属性の変更をクライアントに通知する前にサーバーが遅延する最小秒数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-11-2--Attribute-57-direntnotifdelay">
5.11.2. Attribute 57: dirent_notif_delay
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.2. 属性57：dirent_notif_delay
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The dirent_notif_delay attribute is the minimum number of seconds the server will delay before notifying the client of a change to a file object that has an entry in the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
dirent_notif_delay属性は、ディレクトリにエントリを持つファイルオブジェクトへの変更をクライアントに通知する前にサーバーが遅延する最小秒数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-12--pNFS-Attribute-Definitions">
5.12. pNFS Attribute Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.12. pNFS属性の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-12-1--Attribute-62-fslayouttype">
5.12.1. Attribute 62: fs_layout_type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.12.1. 属性62：fs_layout_type
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_layout_type attribute (see Section 3.3.13) applies to a file system and indicates what layout types are supported by the file system. When the client encounters a new fsid, the client SHOULD obtain the value for the fs_layout_type attribute associated with the new file system. This attribute is used by the client to determine if the layout types supported by the server match any of the client&#39;s supported layout types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_layout_type属性（セクション3.3.13を参照）はファイルシステムに適用され、ファイルシステムでサポートされているレイアウトタイプを示します。クライアントが新しいfsidを検出すると、クライアントは新しいファイルシステムに関連付けられたfs_layout_type属性の値を取得する必要があります（SHOULD）。クライアントがこの属性を使用して、サーバーがサポートするレイアウトタイプが、クライアントがサポートするレイアウトタイプと一致するかどうかを判断します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-12-2--Attribute-66-layoutalignment">
5.12.2. Attribute 66: layout_alignment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.12.2. 属性66：layout_alignment
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client holds layouts on files of a file system, the layout_alignment attribute indicates the preferred alignment for I/O to files on that file system. Where possible, the client should send READ and WRITE operations with offsets that are whole multiples of the layout_alignment attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがファイルシステムのファイルのレイアウトを保持している場合、layout_alignment属性は、そのファイルシステムのファイルへのI / Oの優先配置を示します。可能であれば、クライアントは、layout_alignment属性の整数倍のオフセットを指定して、READおよびWRITE操作を送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-12-3--Attribute-65-layoutblksize">
5.12.3. Attribute 65: layout_blksize
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.12.3. 属性65：layout_blksize
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client holds layouts on files of a file system, the layout_blksize attribute indicates the preferred block size for I/O to files on that file system. Where possible, the client should send READ operations with a count argument that is a whole multiple of layout_blksize, and WRITE operations with a data argument of size that is a whole multiple of layout_blksize.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがファイルシステムのファイルのレイアウトを保持している場合、layout_blksize属性は、そのファイルシステムのファイルへのI / Oの優先ブロックサイズを示します。可能な場合、クライアントは、layout_blksizeの整数倍のcount引数を使用してREAD操作を送信し、layout_blksizeの整数倍のサイズのdata引数を使用してWRITE操作を送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-12-4--Attribute-63-layouthint">
5.12.4. Attribute 63: layout_hint
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.12.4. 属性63：layout_hint
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layout_hint attribute (see Section 3.3.19) may be set on newly created files to influence the metadata server&#39;s choice for the file&#39;s layout. If possible, this attribute is one of those set in the initial attributes within the OPEN operation. The metadata server may choose to ignore this attribute. The layout_hint attribute is a subset of the layout structure returned by LAYOUTGET. For example, instead of specifying particular devices, this would be used to suggest the stripe width of a file. The server implementation determines which fields within the layout will be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルのレイアウトに関するメタデータサーバーの選択に影響を与えるために、layout_hint属性（セクション3.3.19を参照）を新しく作成したファイルに設定できます。可能な場合、この属性は、OPEN操作の初期属性で設定された属性の1つです。メタデータサーバーは、この属性を無視することを選択できます。 layout_hint属性は、LAYOUTGETによって返されるレイアウト構造のサブセットです。たとえば、特定のデバイスを指定する代わりに、これを使用してファイルのストライプ幅を提案します。サーバーの実装により、レイアウト内のどのフィールドが使用されるかが決まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-12-5--Attribute-64-layouttype">
5.12.5. Attribute 64: layout_type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.12.5. 属性64：layout_type
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This attribute lists the layout type(s) available for a file. The value returned by the server is for informational purposes only. The client will use the LAYOUTGET operation to obtain the information needed in order to perform I/O, for example, the specific device information for the file and its layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この属性は、ファイルで使用可能なレイアウトタイプをリストします。サーバーから返される値は、情報提供のみを目的としています。クライアントは、LAYOUTGET操作を使用して、I / Oを実行するために必要な情報（ファイルの特定のデバイス情報やそのレイアウトなど）を取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-12-6--Attribute-68-mdsthreshold">
5.12.6. Attribute 68: mdsthreshold
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.12.6. 属性68：mdsthreshold
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This attribute is a server-provided hint used to communicate to the client when it is more efficient to send READ and WRITE operations to the metadata server or the data server. The two types of thresholds described are file size thresholds and I/O size thresholds. If a file&#39;s size is smaller than the file size threshold, data accesses SHOULD be sent to the metadata server. If an I/O request has a length that is below the I/O size threshold, the I/O SHOULD be sent to the metadata server. Each threshold type is specified separately for read and write.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この属性は、サーバーが提供するヒントであり、READおよびWRITE操作をメタデータサーバーまたはデータサーバーに送信する方が効率的である場合に、クライアントとの通信に使用されます。説明されている2種類のしきい値は、ファイルサイズのしきい値とI / Oサイズのしきい値です。ファイルのサイズがファイルサイズのしきい値よりも小さい場合、データアクセスはメタデータサーバーに送信される必要があります（SHOULD）。 I / O要求の長さがI / Oサイズのしきい値を下回っている場合は、I / Oをメタデータサーバーに送信する必要があります（SHOULD）。各しきい値タイプは、読み取りと書き込みに対して個別に指定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MAY provide both types of thresholds for a file. If both file size and I/O size are provided, the client SHOULD reach or exceed both thresholds before sending its read or write requests to the data server. Alternatively, if only one of the specified thresholds is reached or exceeded, the I/O requests are sent to the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ファイルに対して両方のタイプのしきい値を提供する場合があります。ファイルサイズとI / Oサイズの両方が指定されている場合、クライアントは、データサーバーに読み取り要求または書き込み要求を送信する前に、両方のしきい値に達するか超える必要があります（SHOULD）。または、指定されたしきい値の1つのみに到達または超過した場合、I / O要求はメタデータサーバーに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each threshold type, a value of zero indicates no READ or WRITE should be sent to the metadata server, while a value of all ones indicates that all READs or WRITEs should be sent to the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しきい値のタイプごとに、値0は読み取りまたは書き込みをメタデータサーバーに送信しないことを示し、値1はすべての読み取りまたは書き込みをメタデータサーバーに送信する必要があることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attribute is available on a per-filehandle basis. If the current filehandle refers to a non-pNFS file or directory, the metadata server should return an attribute that is representative of the filehandle&#39;s file system. It is suggested that this attribute is queried as part of the OPEN operation. Due to dynamic system changes, the client should not assume that the attribute will remain constant for any specific time period; thus, it should be periodically refreshed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この属性は、ファイルハンドルごとに使用できます。現在のファイルハンドルが非pNFSファイルまたはディレクトリを参照している場合、メタデータサーバーはファイルハンドルのファイルシステムを表す属性を返す必要があります。この属性は、OPEN操作の一部として照会することをお勧めします。動的なシステム変更のため、クライアントは、属性が特定の期間一定であると想定すべきではありません。したがって、定期的に更新する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-13--Retention-Attributes">
5.13. Retention Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.13. 保持属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Retention is a concept whereby a file object can be placed in an immutable, undeletable, unrenamable state for a fixed or infinite duration of time. Once in this &#34;retained&#34; state, the file cannot be moved out of the state until the duration of retention has been reached.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保存とは、ファイルオブジェクトを固定または無限の期間、不変、削除不可能、名前変更不可の状態にすることができるという概念です。この「保持」状態になると、保持期間に達するまで、ファイルをその状態から移動できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When retention is enabled, retention MUST extend to the data of the file, and the name of file. The server MAY extend retention to any other property of the file, including any subset of REQUIRED, RECOMMENDED, and named attributes, with the exceptions noted in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保存が有効になっている場合、保存はファイルのデータとファイルの名前まで拡張する必要があります。サーバーは、REQUIRED、RECOMMENDED、および名前付き属性のサブセットを含む、ファイルの他のプロパティに保持を拡張できます（MAY）。ただし、このセクションに記載されている例外は除きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers MAY support or not support retention on any file object type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、任意のファイルオブジェクトタイプの保持をサポートしてもしなくてもかまいません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The five retention attributes are explained in the next subsections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5つの保持属性については、次のサブセクションで説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-13-1--Attribute-69-retentionget">
5.13.1. Attribute 69: retention_get
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.13.1. 属性69：retention_get
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If retention is enabled for the associated file, this attribute&#39;s value represents the retention begin time of the file object. This attribute&#39;s value is only readable with the GETATTR operation and MUST NOT be modified by the SETATTR operation (Section 5.5). The value of the attribute consists of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関連ファイルの保存が有効になっている場合、この属性の値はファイルオブジェクトの保存開始時間を表します。この属性の値はGETATTR操作でのみ読み取り可能であり、SETATTR操作（セクション5.5）で変更してはなりません。属性の値は、次のもので構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const RET4_DURATION_INFINITE    = 0xffffffffffffffff;
   struct retention_get4 {
           uint64_t        rg_duration;
           nfstime4        rg_begin_time&lt;1&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The field rg_duration is the duration in seconds indicating how long the file will be retained once retention is enabled. The field rg_begin_time is an array of up to one absolute time value. If the array is zero length, no beginning retention time has been established, and retention is not enabled. If rg_duration is equal to RET4_DURATION_INFINITE, the file, once retention is enabled, will be retained for an infinite duration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドrg_durationは、保持が有効になったときにファイルが保持される期間を示す秒単位の期間です。フィールドrg_begin_timeは、最大1つの絶対時間値の配列です。アレイの長さがゼロの場合、開始保持時間が確立されておらず、保持は有効になっていません。 rg_durationがRET4_DURATION_INFINITEと等しい場合、保持が有効になると、ファイルは無期限に保持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If (as soon as) rg_duration is zero, then rg_begin_time will be of zero length, and again, retention is not (no longer) enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（すぐに）rg_durationがゼロの場合、rg_begin_timeの長さはゼロになり、繰り返しになりますが、保持は（もはや）有効になりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-13-2--Attribute-70-retentionset">
5.13.2. Attribute 70: retention_set
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.13.2. 属性70：retention_set
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This attribute is used to set the retention duration and optionally enable retention for the associated file object. This attribute is only modifiable via the SETATTR operation and MUST NOT be retrieved by the GETATTR operation (Section 5.5). This attribute corresponds to retention_get. The value of the attribute consists of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この属性を使用して、保持期間を設定し、オプションで関連ファイルオブジェクトの保持を有効にします。この属性はSETATTR操作を介してのみ変更可能であり、GETATTR操作（セクション5.5）によって取得してはなりません（MUST NOT）。この属性は、retention_getに対応しています。属性の値は、次のもので構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct retention_set4 {
           bool            rs_enable;
           uint64_t        rs_duration&lt;1&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client sets rs_enable to TRUE, then it is enabling retention on the file object with the begin time of retention starting from the server&#39;s current time and date. The duration of the retention can also be provided if the rs_duration array is of length one. The duration is the time in seconds from the begin time of retention, and if set to RET4_DURATION_INFINITE, the file is to be retained forever. If retention is enabled, with no duration specified in either this SETATTR or a previous SETATTR, the duration defaults to zero seconds. The server MAY restrict the enabling of retention or the duration of retention on the basis of the ACE4_WRITE_RETENTION ACL permission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがrs_enableをTRUEに設定すると、サーバーの現在の日付と時刻から始まる保存の開始時刻でファイルオブジェクトの保存が有効になります。 rs_duration配列の長さが1の場合、保持期間も指定できます。期間は保存の開始時刻からの秒単位の時間であり、RET4_DURATION_INFINITEに設定すると、ファイルは永久に保存されます。このSETATTRまたは以前のSETATTRで期間が指定されていない保持が有効な場合、期間はデフォルトでゼロ秒になります。サーバーは、ACE4_WRITE_RETENTION ACL権限に基づいて、保持の有効化または保持期間を制限してもよい（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The enabling of retention MUST NOT prevent the enabling of event-based retention or the modification of the retention_hold attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保持の有効化は、イベントベースの保持の有効化や、retention_hold属性の変更を妨げてはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following rules apply to both the retention_set and retentevt_set attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のルールは、retention_set属性とretentevt_set属性の両方に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o As long as retention is not enabled, the client is permitted to decrease the duration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 保持が有効になっていない限り、クライアントは期間を短縮できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The duration can always be set to an equal or higher value, even if retention is enabled. Note that once retention is enabled, the actual duration (as returned by the retention_get or retentevt_get attributes; see Section 5.13.1 or Section 5.13.3) is constantly counting down to zero (one unit per second), unless the duration was set to RET4_DURATION_INFINITE. Thus, it will not be possible for the client to precisely extend the duration on a file that has retention enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 保存期間が有効になっている場合でも、期間は常に同じかそれ以上の値に設定できます。保存が有効になると、実際の継続時間（retention_getまたはretentevt_get属性によって返されるように、セクション5.13.1またはセクション5.13.3を参照）は、継続時間が0に設定されていない限り、常にゼロまでカウントダウンされます（1秒あたり1ユニット） RET4_DURATION_INFINITE。したがって、保持が有効になっているファイルの期間をクライアントが正確に延長することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o While retention is enabled, attempts to disable retention or decrease the retention&#39;s duration MUST fail with the error NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 保存が有効になっている間、保存を無効にするか、保存期間を短縮しようとすると、エラーNFS4ERR_INVALで失敗する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the principal attempting to change retention_set or retentevt_set does not have ACE4_WRITE_RETENTION permissions, the attempt MUST fail with NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Retention_setまたはretentevt_setを変更しようとするプリンシパルにACE4_WRITE_RETENTION権限がない場合、NFS4ERR_ACCESSで失敗する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-13-3--Attribute-71-retentevtget">
5.13.3. Attribute 71: retentevt_get
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.13.3. 属性71：retentevt_get
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Gets the event-based retention duration, and if enabled, the event-based retention begin time of the file object. This attribute is like retention_get, but refers to event-based retention. The event that triggers event-based retention is not defined by the NFSv4.1 specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イベントベースの保存期間を取得します。有効になっている場合は、ファイルオブジェクトのイベントベースの保存開始時刻を取得します。この属性は、retention_getに似ていますが、イベントベースの保持を指します。イベントベースの保存をトリガーするイベントは、NFSv4.1仕様では定義されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-13-4--Attribute-72-retentevtset">
5.13.4. Attribute 72: retentevt_set
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.13.4. 属性72：retentevt_set
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sets the event-based retention duration, and optionally enables event-based retention on the file object. This attribute corresponds to retentevt_get and is like retention_set, but refers to event-based retention. When event-based retention is set, the file MUST be retained even if non-event-based retention has been set, and the duration of non-event-based retention has been reached. Conversely, when non-event-based retention has been set, the file MUST be retained even if event-based retention has been set, and the duration of event-based retention has been reached. The server MAY restrict the enabling of event-based retention or the duration of event-based retention on the basis of the ACE4_WRITE_RETENTION ACL permission. The enabling of event-based retention MUST NOT prevent the enabling of non-event-based retention or the modification of the retention_hold attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イベントベースの保存期間を設定し、オプションでファイルオブジェクトのイベントベースの保存を有効にします。この属性はretentevt_getに対応し、retention_setに似ていますが、イベントベースの保持を指します。イベントベースの保存が設定されている場合、非イベントベースの保存が設定されていて、非イベントベースの保存期間に達している場合でも、ファイルを保存する必要があります。逆に、非イベントベースの保存が設定されている場合、イベントベースの保存が設定されていて、イベントベースの保存期間に達している場合でも、ファイルを保存する必要があります。サーバーは、ACE4_WRITE_RETENTION ACL権限に基づいて、イベントベースの保持またはイベントベースの保持の期間の有効化を制限してもよい（MAY）。イベントベースの保持を有効にしても、非イベントベースの保持を有効にしたり、retention_hold属性を変更したりしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-13-5--Attribute-73-retentionhold">
5.13.5. Attribute 73: retention_hold
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.13.5. 属性73：retention_hold
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Gets or sets administrative retention holds, one hold per bit position.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビット位置ごとに1つの保留である管理保持の保留を取得または設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This attribute allows one to 64 administrative holds, one hold per bit on the attribute. If retention_hold is not zero, then the file MUST NOT be deleted, renamed, or modified, even if the duration on enabled event or non-event-based retention has been reached. The server MAY restrict the modification of retention_hold on the basis of the ACE4_WRITE_RETENTION_HOLD ACL permission. The enabling of administration retention holds does not prevent the enabling of event-based or non-event-based retention.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この属性では、1〜64の管理保留が可能で、属性のビットごとに1つの保留があります。 Retention_holdがゼロでない場合、有効なイベントまたは非イベントベースの保存期間に達した場合でも、ファイルを削除、名前変更、または変更してはなりません（MUST NOT）。サーバーは、ACE4_WRITE_RETENTION_HOLD ACL権限に基づいて、retention_holdの変更を制限してもよい（MAY）。管理保持を有効にしても、イベントベースまたは非イベントベースの保持を有効にすることはできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the principal attempting to change retention_hold does not have ACE4_WRITE_RETENTION_HOLD permissions, the attempt MUST fail with NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Retention_holdを変更しようとするプリンシパルにACE4_WRITE_RETENTION_HOLD権限がない場合、NFS4ERR_ACCESSで失敗する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Access-Control-Attributes">
6. Access Control Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. アクセス制御属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Access Control Lists (ACLs) are file attributes that specify fine-grained access control. This section covers the &#34;acl&#34;, &#34;dacl&#34;, &#34;sacl&#34;, &#34;aclsupport&#34;, &#34;mode&#34;, and &#34;mode_set_masked&#34; file attributes and their interactions. Note that file attributes may apply to any file system object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセス制御リスト（ACL）は、きめ細かいアクセス制御を指定するファイル属性です。このセクションでは、「acl」、「dacl」、「sacl」、「aclsupport」、「mode」、および「mode_set_masked」ファイルの属性とそれらの相互作用について説明します。ファイル属性は任意のファイルシステムオブジェクトに適用できることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1--Goals">
6.1. Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. ゴール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 ACLs and modes represent two well-established models for specifying permissions. This section specifies requirements that attempt to meet the following goals: o If a server supports the mode attribute, it should provide reasonable semantics to clients that only set and retrieve the mode attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ACLとモードは、権限を指定するための2つの確立されたモデルを表します。このセクションでは、次の目標を達成しようとする要件を指定します。oサーバーがモード属性をサポートしている場合、モード属性の設定と取得のみを行うクライアントに適切なセマンティクスを提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If a server supports ACL attributes, it should provide reasonable semantics to clients that only set and retrieve those attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーがACL属性をサポートする場合、それらの属性の設定と取得のみを行うクライアントに適切なセマンティクスを提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On servers that support the mode attribute, if ACL attributes have never been set on an object, via inheritance or explicitly, the behavior should be traditional UNIX-like behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o モード属性をサポートするサーバーでは、継承または明示的にオブジェクトにACL属性が設定されていない場合、動作は従来のUNIXに似た動作になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On servers that support the mode attribute, if the ACL attributes have been previously set on an object, either explicitly or via inheritance:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o モード属性をサポートするサーバーで、ACL属性がオブジェクトに以前に明示的または継承によって設定されている場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Setting only the mode attribute should effectively control the traditional UNIX-like permissions of read, write, and execute on owner, owner_group, and other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* mode属性のみを設定することで、owner、owner_groupなどに対する、従来のUNIXに似た読み取り、書き込み、実行のアクセス許可を効果的に制御できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Setting only the mode attribute should provide reasonable security. For example, setting a mode of 000 should be enough to ensure that future OPEN operations for OPEN4_SHARE_ACCESS_READ or OPEN4_SHARE_ACCESS_WRITE by any principal fail, regardless of a previously existing or inherited ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* mode属性のみを設定すると、妥当なセキュリティが提供されます。たとえば、モードを000に設定することで、以前の既存または継承されたACLに関係なく、プリンシパルによるOPEN4_SHARE_ACCESS_READまたはOPEN4_SHARE_ACCESS_WRITEの将来のOPEN操作が失敗することを保証できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1 may introduce different semantics relating to the mode and ACL attributes, but it does not render invalid any previously existing implementations. Additionally, this section provides clarifications based on previous implementations and discussions around them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1では、モードとACL属性に関連するさまざまなセマンティクスが導入される可能性がありますが、以前の既存の実装が無効になることはありません。さらに、このセクションでは、以前の実装とそれらに関する議論に基づいた説明を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On servers that support both the mode and the acl or dacl attributes, the server must keep the two consistent with each other. The value of the mode attribute (with the exception of the three high-order bits described in Section 6.2.4) must be determined entirely by the value of the ACL, so that use of the mode is never required for anything other than setting the three high-order bits. See Section 6.4.1 for exact requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o モードとaclまたはdacl属性の両方をサポートするサーバーでは、サーバーは2つを互いに一貫性のある状態に保つ必要があります。モード属性の値（セクション6.2.4で説明されている上位3ビットを除く）は、ACLの値によって完全に決定される必要があるため、モードの使用は、上位3ビット。正確な要件については、セクション6.4.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a mode attribute is set on an object, the ACL attributes may need to be modified in order to not conflict with the new mode. In such cases, it is desirable that the ACL keep as much information as possible. This includes information about inheritance, AUDIT and ALARM ACEs, and permissions granted and denied that do not conflict with the new mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o オブジェクトにモード属性が設定されている場合、新しいモードと競合しないようにACL属性を変更する必要がある場合があります。そのような場合、ACLができるだけ多くの情報を保持することが望ましいです。これには、継承、AUDITとALARM ACE、および新しいモードと競合しない許可および拒否された権限に関する情報が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2--File-Attributes-Discussion">
6.2. File Attributes Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. ファイル属性のディスカッション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-1--Attribute-12-acl">
6.2.1. Attribute 12: acl
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. 属性12：acl
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 ACL attribute contains an array of Access Control Entries (ACEs) that are associated with the file system object. Although the client can set and get the acl attribute, the server is responsible for using the ACL to perform access control. The client can use the OPEN or ACCESS operations to check access without modifying or reading data or metadata.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 ACL属性には、ファイルシステムオブジェクトに関連付けられているアクセス制御エントリ（ACE）の配列が含まれています。クライアントはacl属性を設定および取得できますが、サーバーはACLを使用してアクセス制御を実行する必要があります。クライアントは、OPENまたはACCESS操作を使用して、データやメタデータを変更したり読み取ったりせずにアクセスを確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS ACE structure is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS ACE構造は次のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t acetype4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t acetype4;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t aceflag4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t aceflag4;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t acemask4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t acemask4;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfsace4 {
           acetype4        type;
           aceflag4        flag;
           acemask4        access_mask;
           utf8str_mixed   who;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To determine if a request succeeds, the server processes each nfsace4 entry in order. Only ACEs that have a &#34;who&#34; that matches the requester are considered. Each ACE is processed until all of the bits of the requester&#39;s access have been ALLOWED. Once a bit (see below) has been ALLOWED by an ACCESS_ALLOWED_ACE, it is no longer considered in the processing of later ACEs. If an ACCESS_DENIED_ACE is encountered where the requester&#39;s access still has unALLOWED bits in common with the &#34;access_mask&#34; of the ACE, the request is denied. When the ACL is fully processed, if there are bits in the requester&#39;s mask that have not been ALLOWED or DENIED, access is denied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストが成功したかどうかを判断するために、サーバーは各nfsace4エントリを順番に処理します。要求者に一致する「who」を持つACEのみが考慮されます。各ACEは、要求者のアクセスのすべてのビットが許可されるまで処理されます。 ACCESS_ALLOWED_ACEによってビット（以下を参照）が許可されると、以降のACEの処理では考慮されなくなります。リクエスターのアクセスにACEの「access_mask」と共通のunALLOWEDビットが含まれているACCESS_DENIED_ACEが検出された場合、要求は拒否されます。 ACLが完全に処理されたときに、リクエスタのマスクに許可または拒否されていないビットがある場合、アクセスは拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike the ALLOW and DENY ACE types, the ALARM and AUDIT ACE types do not affect a requester&#39;s access, and instead are for triggering events as a result of a requester&#39;s access attempt. Therefore, AUDIT and ALARM ACEs are processed only after processing ALLOW and DENY ACEs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ALLOWおよびDENY ACEタイプとは異なり、ALARMおよびAUDIT ACEタイプはリクエスターのアクセスに影響せず、リクエスターのアクセス試行の結果としてイベントをトリガーするためのものです。したがって、AUDITおよびALARM ACEは、ALLOWおよびDENY ACEを処理した後でのみ処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The NFSv4.1 ACL model is quite rich. Some server platforms may provide access-control functionality that goes beyond the UNIX-style mode attribute, but that is not as rich as the NFS ACL model. So that users can take advantage of this more limited functionality, the server may support the acl attributes by mapping between its ACL model and the NFSv4.1 ACL model. Servers must ensure that the ACL they actually store or enforce is at least as strict as the NFSv4 ACL that was set. It is tempting to accomplish this by rejecting any ACL that falls outside the small set that can be represented accurately. However, such an approach can render ACLs unusable without special client-side knowledge of the server&#39;s mapping, which defeats the purpose of having a common NFSv4 ACL protocol. Therefore, servers should accept every ACL that they can without compromising security. To help accomplish this, servers may make a special exception, in the case of unsupported permission bits, to the rule that bits not ALLOWED or DENIED by an ACL must be denied. For example, a UNIX-style server might choose to silently allow read attribute permissions even though an ACL does not explicitly allow those permissions. (An ACL that explicitly denies permission to read attributes should still be rejected.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFSv4.1 ACLモデルは非常に豊富です。一部のサーバープラットフォームは、UNIXスタイルのモード属性を超えるアクセス制御機能を提供する場合がありますが、NFS ACLモデルほど豊富ではありません。ユーザーがこのより限定された機能を利用できるように、サーバーはACLモデルとNFSv4.1 ACLモデルの間のマッピングによってacl属性をサポートする場合があります。サーバーは、サーバーが実際に格納または実施するACLが、少なくとも設定されたNFSv4 ACLと同じくらい厳格であることを確認する必要があります。正確に表すことができる小さなセットの外にあるACLを拒否することでこれを実現したくなります。ただし、このようなアプローチでは、サーバー側のマッピングに関するクライアント側の特別な知識がなければ、ACLが使用できなくなる可能性があり、これは一般的なNFSv4 ACLプロトコルを持つ目的に反します。したがって、サーバーはセキュリティを犠牲にすることなく、可能なすべてのACLを受け入れる必要があります。これを実現するために、サーバーは、サポートされていない許可ビットの場合、ACLによって許可または拒否されていないビットを拒否する必要があるという規則に対して、特別な例外を作成する場合があります。たとえば、UNIXスタイルのサーバーは、ACLが明示的にアクセス許可を許可していなくても、読み取り属性アクセス許可をサイレントに許可することを選択する場合があります。 （属性を読み取るためのアクセス許可を明示的に拒否するACLは、引き続き拒否されます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The situation is complicated by the fact that a server may have multiple modules that enforce ACLs. For example, the enforcement for NFSv4.1 access may be different from, but not weaker than, the enforcement for local access, and both may be different from the enforcement for access through other protocols such as SMB (Server Message Block). So it may be useful for a server to accept an ACL even if not all of its modules are able to support it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーには、ACLを適用する複数のモジュールがある場合があるため、状況は複雑です。たとえば、NFSv4.1アクセスの施行は、ローカルアクセスの施行とは異なりますが、それよりも弱くはなく、どちらもSMB（サーバーメッセージブロック）などの他のプロトコルを介したアクセスの施行とは異なる場合があります。そのため、すべてのモジュールがACLをサポートできるわけではない場合でも、サーバーがACLを受け入れると便利な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The guiding principle with regard to NFSv4 access is that the server must not accept ACLs that appear to make access to the file more restrictive than it really is.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4アクセスに関する基本原則は、サーバーがファイルへのアクセスを実際よりも制限するように見えるACLを受け入れてはならないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-1-1--ACE-Type">
6.2.1.1. ACE Type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.1. ACEタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The constants used for the type field (acetype4) are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプフィールド（acetype4）に使用される定数は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;
   const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;
   const ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;
   const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Only the ALLOWED and DENIED bits may be used in the dacl attribute, and only the AUDIT and ALARM bits may be used in the sacl attribute. All four are permitted in the acl attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ALLOWEDおよびDENIEDビットのみがdacl属性で使用でき、AUDITおよびALARMビットのみがsacl属性で使用できます。 4つすべてがacl属性で許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------------------------+--------------+---------------------+
   | Value                        | Abbreviation | Description         |
   +------------------------------+--------------+---------------------+
   | ACE4_ACCESS_ALLOWED_ACE_TYPE | ALLOW        | Explicitly grants   |
   |                              |              | the access defined  |
   |                              |              | in acemask4 to the  |
   |                              |              | file or directory.  |
   | ACE4_ACCESS_DENIED_ACE_TYPE  | DENY         | Explicitly denies   |
   |                              |              | the access defined  |
   |                              |              | in acemask4 to the  |
   |                              |              | file or directory.  |
   | ACE4_SYSTEM_AUDIT_ACE_TYPE   | AUDIT        | Log (in a           |
   |                              |              | system-dependent    |
   |                              |              | way) any access     |
   |                              |              | attempt to a file   |
   |                              |              | or directory that   |
   |                              |              | uses any of the     |
   |                              |              | access methods      |
   |                              |              | specified in        |
   |                              |              | acemask4.           |
   | ACE4_SYSTEM_ALARM_ACE_TYPE   | ALARM        | Generate an alarm   |
   |                              |              | (in a               |
   |                              |              | system-dependent    |
   |                              |              | way) when any       |
   |                              |              | access attempt is   |
   |                              |              | made to a file or   |
   |                              |              | directory for the   |
   |                              |              | access methods      |
   |                              |              | specified in        |
   |                              |              | acemask4.           |
   +------------------------------+--------------+---------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;Abbreviation&#34; column denotes how the types will be referred to throughout the rest of this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「略語」の列は、このセクションの残りの部分でタイプがどのように参照されるかを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-1-2--Attribute-13-aclsupport">
6.2.1.2. Attribute 13: aclsupport
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.2. 属性13：aclsupport
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server need not support all of the above ACE types. This attribute indicates which ACE types are supported for the current file system. The bitmask constants used to represent the above definitions within the aclsupport attribute are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、上記のACEタイプのすべてをサポートする必要はありません。この属性は、現在のファイルシステムでサポートされているACEタイプを示します。 aclsupport属性内の上記の定義を表すために使用されるビットマスク定数は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;
   const ACL4_SUPPORT_DENY_ACL     = 0x00000002;
   const ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;
   const ACL4_SUPPORT_ALARM_ACL    = 0x00000008;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers that support either the ALLOW or DENY ACE type SHOULD support both ALLOW and DENY ACE types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ALLOWまたはDENY ACEタイプをサポートするサーバーは、ALLOWおよびDENY ACEタイプの両方をサポートする必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients should not attempt to set an ACE unless the server claims support for that ACE type. If the server receives a request to set an ACE that it cannot store, it MUST reject the request with NFS4ERR_ATTRNOTSUPP. If the server receives a request to set an ACE that it can store but cannot enforce, the server SHOULD reject the request with NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがそのACEタイプのサポートを要求しない限り、クライアントはACEを設定しないでください。サーバーは、格納できないACEを設定する要求を受信した場合、NFS4ERR_ATTRNOTSUPPを使用して要求を拒否する必要があります。サーバーが格納できるが強制できないACEを設定する要求を受信した場合、サーバーはNFS4ERR_ATTRNOTSUPPを使用して要求を拒否する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Support for any of the ACL attributes is optional (albeit RECOMMENDED). However, a server that supports either of the new ACL attributes (dacl or sacl) MUST allow use of the new ACL attributes to access all of the ACE types that it supports. In other words, if such a server supports ALLOW or DENY ACEs, then it MUST support the dacl attribute, and if it supports AUDIT or ALARM ACEs, then it MUST support the sacl attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACL属性のサポートはオプションです（推奨）。ただし、新しいACL属性（daclまたはsacl）のいずれかをサポートするサーバーでは、新しいACL属性を使用して、サポートするすべてのACEタイプにアクセスできるようにする必要があります。言い換えると、そのようなサーバーがALLOWまたはDENY ACEをサポートする場合は、dacl属性をサポートする必要があり、AUDITまたはALARM ACEをサポートする場合は、sacl属性をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-1-3--ACE-Access-Mask">
6.2.1.3. ACE Access Mask
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.3. ACEアクセスマスク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bitmask constants used for the access mask field are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセスマスクフィールドに使用されるビットマスク定数は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_READ_DATA            = 0x00000001;
   const ACE4_LIST_DIRECTORY       = 0x00000001;
   const ACE4_WRITE_DATA           = 0x00000002;
   const ACE4_ADD_FILE             = 0x00000002;
   const ACE4_APPEND_DATA          = 0x00000004;
   const ACE4_ADD_SUBDIRECTORY     = 0x00000004;
   const ACE4_READ_NAMED_ATTRS     = 0x00000008;
   const ACE4_WRITE_NAMED_ATTRS    = 0x00000010;
   const ACE4_EXECUTE              = 0x00000020;
   const ACE4_DELETE_CHILD         = 0x00000040;
   const ACE4_READ_ATTRIBUTES      = 0x00000080;
   const ACE4_WRITE_ATTRIBUTES     = 0x00000100;
   const ACE4_WRITE_RETENTION      = 0x00000200;
   const ACE4_WRITE_RETENTION_HOLD = 0x00000400;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_DELETE               = 0x00010000;
   const ACE4_READ_ACL             = 0x00020000;
   const ACE4_WRITE_ACL            = 0x00040000;
   const ACE4_WRITE_OWNER          = 0x00080000;
   const ACE4_SYNCHRONIZE          = 0x00100000;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Note that some masks have coincident values, for example, ACE4_READ_DATA and ACE4_LIST_DIRECTORY. The mask entries ACE4_LIST_DIRECTORY, ACE4_ADD_FILE, and ACE4_ADD_SUBDIRECTORY are intended to be used with directory objects, while ACE4_READ_DATA, ACE4_WRITE_DATA, and ACE4_APPEND_DATA are intended to be used with non-directory objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ACE4_READ_DATAとACE4_LIST_DIRECTORYなど、一部のマスクには一致する値があることに注意してください。マスクエントリACE4_LIST_DIRECTORY、ACE4_ADD_FILE、およびACE4_ADD_SUBDIRECTORYは、ディレクトリオブジェクトでの使用を目的としていますが、ACE4_READ_DATA、ACE4_WRITE_DATA、およびACE4_APPEND_DATAは、非ディレクトリオブジェクトでの使用を目的としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-1-3-1--Discussion-of-Mask-Attributes">
6.2.1.3.1. Discussion of Mask Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.3.1. マスク属性の説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_DATA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_DATA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
READ
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
読んだ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
開いた
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to read the data of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルのデータを読み取る権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Servers SHOULD allow a user the ability to read the data of the file when only the ACE4_EXECUTE access mask bit is allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
サーバーは、ACE4_EXECUTEアクセスマスクビットのみが許可されている場合に、ユーザーがファイルのデータを読み取ることができるようにする必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_LIST_DIRECTORY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_LIST_DIRECTORY
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
READDIR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
READDIR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to list the contents of a directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ディレクトリの内容を一覧表示する権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_DATA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_DATA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
WRITE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
書く
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
開いた
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
SETATTR of size
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
サイズのSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to modify a file&#39;s data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルのデータを変更する権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_ADD_FILE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_ADD_FILE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
CREATE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
作成する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
LINK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
リンク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
開いた
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
RENAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
名前を変更
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to add a new file in a directory. The CREATE operation is affected when nfs_ftype4 is NF4LNK, NF4BLK, NF4CHR, NF4SOCK, or NF4FIFO. (NF4DIR is not listed because it is covered by ACE4_ADD_SUBDIRECTORY.) OPEN is affected when used to create a regular file. LINK and RENAME are always affected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ディレクトリに新しいファイルを追加する権限。 nfs_ftype4がNF4LNK、NF4BLK、NF4CHR、NF4SOCK、またはNF4FIFOの場合、CREATE操作が影響を受けます。 （NF4DIRはACE4_ADD_SUBDIRECTORYでカバーされているため、リストに含まれていません。）OPENは、通常のファイルの作成に使用された場合に影響を受けます。 LINKとRENAMEは常に影響を受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_APPEND_DATA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_APPEND_DATA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
WRITE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
書く
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
開いた
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
SETATTR of size
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
サイズのSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The ability to modify a file&#39;s data, but only starting at EOF. This allows for the notion of append-only files, by allowing ACE4_APPEND_DATA and denying ACE4_WRITE_DATA to the same user or group. If a file has an ACL such as the one described above and a WRITE request is made for somewhere other than EOF, the server SHOULD return NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルのデータを変更する機能。ただし、EOFからのみ開始。これにより、ACE4_APPEND_DATAを許可し、同じユーザーまたはグループに対してACE4_WRITE_DATAを拒否することで、追加専用ファイルの概念が可能になります。ファイルに上記のようなACLがあり、EOF以外の場所に対してWRITE要求が行われた場合、サーバーはNFS4ERR_ACCESSを返す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_ADD_SUBDIRECTORY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_ADD_SUBDIRECTORY
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
CREATE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
作成する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
RENAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
名前を変更
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to create a subdirectory in a directory. The CREATE operation is affected when nfs_ftype4 is NF4DIR. The RENAME operation is always affected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ディレクトリにサブディレクトリを作成する権限。 nfs_ftype4がNF4DIRの場合、CREATE操作が影響を受けます。 RENAME操作は常に影響を受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_NAMED_ATTRS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_NAMED_ATTRS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPENATTR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPENATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to read the named attributes of a file or to look up the named attribute directory. OPENATTR is affected when it is not used to create a named attribute directory. This is when 1) createdir is TRUE, but a named attribute directory already exists, or 2) createdir is FALSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルの名前付き属性を読み取る権限、または名前付き属性ディレクトリを検索する権限。 OPENATTRは、名前付き属性ディレクトリの作成に使用されない場合に影響を受けます。これは、1）createdirはTRUEであるが、名前付き属性ディレクトリがすでに存在する場合、または2）createdirがFALSEの場合です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_NAMED_ATTRS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_NAMED_ATTRS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPENATTR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPENATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to write the named attributes of a file or to create a named attribute directory. OPENATTR is affected when it is used to create a named attribute directory. This is when createdir is TRUE and no named attribute directory exists. The ability to check whether or not a named attribute directory exists depends on the ability to look it up; therefore, users also need the ACE4_READ_NAMED_ATTRS permission in order to create a named attribute directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルの名前付き属性を書き込む権限、または名前付き属性ディレクトリを作成する権限。 OPENATTRを使用して名前付き属性ディレクトリを作成すると、OPENATTRが影響を受けます。これは、createdirがTRUEで、名前付き属性ディレクトリが存在しない場合です。名前付き属性ディレクトリが存在するかどうかを確認する機能は、それを検索する機能に依存します。したがって、名前付き属性ディレクトリを作成するには、ユーザーにもACE4_READ_NAMED_ATTRS権限が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_EXECUTE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_EXECUTE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
READ
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
読んだ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
開いた
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
REMOVE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
削除する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 RENAME LINK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
リンクの名前を変更
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
CREATE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
作成する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to execute a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルを実行する権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Servers SHOULD allow a user the ability to read the data of the file when only the ACE4_EXECUTE access mask bit is allowed. This is because there is no way to execute a file without reading the contents. Though a server may treat ACE4_EXECUTE and ACE4_READ_DATA bits identically when deciding to permit a READ operation, it SHOULD still allow the two bits to be set independently in ACLs, and MUST distinguish between them when replying to ACCESS operations. In particular, servers SHOULD NOT silently turn on one of the two bits when the other is set, as that would make it impossible for the client to correctly enforce the distinction between read and execute permissions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
サーバーは、ACE4_EXECUTEアクセスマスクビットのみが許可されている場合に、ユーザーがファイルのデータを読み取ることができるようにする必要があります（SHOULD）。これは、内容を読み取らずにファイルを実行する方法がないためです。サーバーはREAD操作を許可することを決定するときにACE4_EXECUTEビットとACE4_READ_DATAビットを同じように扱うことができますが、ACLで2つのビットを個別に設定できるようにする必要があり、ACCESS操作に応答するときはそれらを区別する必要があります。特に、サーバーは2つのビットのいずれかが設定されている場合、一方をオンにしないでください。これにより、クライアントが読み取りと実行のアクセス許可を正しく区別できなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
As an example, following a SETATTR of the following ACL:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
例として、次のACLのSETATTRに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
nfsuser:ACE4_EXECUTE:ALLOW
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
nfsuser：ACE4_EXECUTE：ALLOW
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
A subsequent GETATTR of ACL for that file SHOULD return:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
そのファイルのACLの後続のGETATTRは以下を返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
nfsuser:ACE4_EXECUTE:ALLOW
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
nfsuser：ACE4_EXECUTE：ALLOW
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Rather than:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
のではなく：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         nfsuser:ACE4_EXECUTE/ACE4_READ_DATA:ALLOW
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_EXECUTE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_EXECUTE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
LOOKUP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
調べる
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to traverse/search a directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ディレクトリを全探索/検索する権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_DELETE_CHILD
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_DELETE_CHILD
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 REMOVE RENAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
名前を削除
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to delete a file or directory within a directory. See Section 6.2.1.3.2 for information on ACE4_DELETE and ACE4_DELETE_CHILD interact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ディレクトリ内のファイルまたはディレクトリを削除する権限。 ACE4_DELETEとACE4_DELETE_CHILDの相互作用については、セクション6.2.1.3.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_ATTRIBUTES
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_ATTRIBUTES
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
GETATTR of file system object attributes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルシステムオブジェクト属性のGETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
VERIFY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
確認
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
NVERIFY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
確認しない
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
READDIR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
READDIR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The ability to read basic attributes (non-ACLs) of a file. On a UNIX system, basic attributes can be thought of as the stat-level attributes. Allowing this access mask bit would mean that the entity can execute &#34;ls -l&#34; and stat. If a READDIR operation requests attributes, this mask must be allowed for the READDIR to succeed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルの基本属性（非ACL）を読み取る機能。 UNIXシステムでは、基本的な属性は統計レベルの属性と考えることができます。このアクセスマスクビットを許可すると、エンティティは &#34;ls -l&#34;とstatを実行できます。 READDIR操作が属性を要求する場合、READDIRが成功するには、このマスクが許可されている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_ATTRIBUTES
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_ATTRIBUTES
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
SETATTR of time_access_set, time_backup,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
time_access_set、time_backup、のSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
time_create, time_modify_set, mimetype, hidden, system
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
time_create、time_modify_set、mimetype、hidden、system
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to change the times associated with a file or directory to an arbitrary value. Also permission to change the mimetype, hidden, and system attributes. A user having ACE4_WRITE_DATA or ACE4_WRITE_ATTRIBUTES will be allowed to set the times associated with a file to the current server time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルまたはディレクトリに関連付けられた時間を任意の値に変更する権限。また、mimetype、hidden、およびsystem属性を変更する権限。 ACE4_WRITE_DATAまたはACE4_WRITE_ATTRIBUTESを持つユーザーは、ファイルに関連付けられた時刻を現在のサーバー時刻に設定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_RETENTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_RETENTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
SETATTR of retention_set, retentevt_set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Retention_set、retentevt_setのSETATTR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to modify the durations of event and non-event-based retention. Also permission to enable event and non-event-based retention. A server MAY behave such that setting ACE4_WRITE_ATTRIBUTES allows ACE4_WRITE_RETENTION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
イベントおよび非イベントベースの保持の期間を変更する権限。また、イベントおよび非イベントベースの保持を有効にする権限。サーバーは、ACE4_WRITE_ATTRIBUTESを設定するとACE4_WRITE_RETENTIONが許可されるように動作する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_RETENTION_HOLD
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_RETENTION_HOLD
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
SETATTR of retention_hold.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Retention_holdのSETATTR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to modify the administration retention holds. A server MAY map ACE4_WRITE_ATTRIBUTES to ACE_WRITE_RETENTION_HOLD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
管理保持を変更する権限が保持されます。サーバーはACE4_WRITE_ATTRIBUTESをACE_WRITE_RETENTION_HOLDにマップしてもよい（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_DELETE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_DELETE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
REMOVE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
削除する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to delete the file or directory. See Section 6.2.1.3.2 for information on ACE4_DELETE and ACE4_DELETE_CHILD interact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ファイルまたはディレクトリを削除する権限。 ACE4_DELETEとACE4_DELETE_CHILDの相互作用については、セクション6.2.1.3.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_ACL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_READ_ACL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
GETATTR of acl, dacl, or sacl
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
acl、dacl、またはsaclのGETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
NVERIFY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
確認しない
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
VERIFY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
確認
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to read the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ACLを読み取る権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_ACL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_ACL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
SETATTR of acl and mode
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ACLとモードのSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to write the acl and mode attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
aclおよびmode属性を書き込む権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_OWNER
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_WRITE_OWNER
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
SETATTR of owner and owner_group
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
所有者とowner_groupのSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to write the owner and owner_group attributes. On UNIX systems, this is the ability to execute chown() and chgrp().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ownerおよびowner_group属性を書き込む権限。 UNIXシステムでは、これはchown()およびchgrp()を実行する機能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_SYNCHRONIZE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_SYNCHRONIZE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
影響を受ける操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
NONE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
なし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Permission to use the file object as a synchronization primitive for interprocess communication. This permission is not enforced or interpreted by the NFSv4.1 server on behalf of the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
プロセス間通信の同期プリミティブとしてファイルオブジェクトを使用する権限。この許可は、クライアントに代わってNFSv4.1サーバーによって強制または解釈されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Typically, the ACE4_SYNCHRONIZE permission is only meaningful on local file systems, i.e., file systems not accessed via NFSv4.1. The reason that the permission bit exists is that some operating environments, such as Windows, use ACE4_SYNCHRONIZE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
通常、ACE4_SYNCHRONIZE権限は、ローカルファイルシステム、つまりNFSv4.1を介してアクセスされないファイルシステムでのみ意味があります。許可ビットが存在する理由は、Windowsなどの一部のオペレーティング環境がACE4_SYNCHRONIZEを使用するためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 For example, if a client copies a file that has ACE4_SYNCHRONIZE set from a local file system to an NFSv4.1 server, and then later copies the file from the NFSv4.1 server to a local file system, it is likely that if ACE4_SYNCHRONIZE was set in the original file, the client will want it set in the second copy. The first copy will not have the permission set unless the NFSv4.1 server has the means to set the ACE4_SYNCHRONIZE bit. The second copy will not have the permission set unless the NFSv4.1 server has the means to retrieve the ACE4_SYNCHRONIZE bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
たとえば、クライアントがACE4_SYNCHRONIZEが設定されたファイルをローカルファイルシステムからNFSv4.1サーバーにコピーし、その後NFSv4.1サーバーからローカルファイルシステムにファイルをコピーした場合、ACE4_SYNCHRONIZEが元のファイルに設定した場合、クライアントは2番目のコピーに設定する必要があります。 NFSv4.1サーバーにACE4_SYNCHRONIZEビットを設定する手段がない限り、最初のコピーには権限が設定されません。 NFSv4.1サーバーにACE4_SYNCHRONIZEビットを取得する手段がない限り、2番目のコピーには権限が設定されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server implementations need not provide the granularity of control that is implied by this list of masks. For example, POSIX-based systems might not distinguish ACE4_APPEND_DATA (the ability to append to a file) from ACE4_WRITE_DATA (the ability to modify existing contents); both masks would be tied to a single &#34;write&#34; permission [20]. When such a server returns attributes to the client, it would show both ACE4_APPEND_DATA and ACE4_WRITE_DATA if and only if the write permission is enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの実装は、このマスクのリストが意味する細かい制御を提供する必要はありません。たとえば、POSIXベースのシステムでは、ACE4_APPEND_DATA（ファイルに追加する機能）とACE4_WRITE_DATA（既存のコンテンツを変更する機能）を区別できない場合があります。両方のマスクは、単一の「書き込み」権限[20]に関連付けられます。このようなサーバーが属性をクライアントに返す場合、書き込み権限が有効になっている場合にのみ、ACE4_APPEND_DATAとACE4_WRITE_DATAの両方が表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server receives a SETATTR request that it cannot accurately implement, it should err in the direction of more restricted access, except in the previously discussed cases of execute and read. For example, suppose a server cannot distinguish overwriting data from appending new data, as described in the previous paragraph. If a client submits an ALLOW ACE where ACE4_APPEND_DATA is set but ACE4_WRITE_DATA is not (or vice versa), the server should either turn off ACE4_APPEND_DATA or reject the request with NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが正確に実装できないSETATTR要求を受け取った場合、前述の実行と読み取りの場合を除いて、より制限されたアクセスの方向にエラーが発生します。たとえば、前の段落で説明したように、サーバーがデータの上書きと新しいデータの追加を区別できないとします。クライアントがACE4_APPEND_DATAが設定されているがACE4_WRITE_DATAが設定されていない（またはその逆の）ALLOW ACEを送信する場合、サーバーはACE4_APPEND_DATAをオフにするか、NFS4ERR_ATTRNOTSUPPで要求を拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-1-3-2--ACE4DELETE-vs--ACE4DELETECHILD">
6.2.1.3.2. ACE4_DELETE vs. ACE4_DELETE_CHILD
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.3.2. ACE4_DELETEとACE4_DELETE_CHILD
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two access mask bits govern the ability to delete a directory entry: ACE4_DELETE on the object itself (the &#34;target&#34;) and ACE4_DELETE_CHILD on the containing directory (the &#34;parent&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのアクセスマスクビットは、ディレクトリエントリを削除する機能を管理します。オブジェクト自体（「ターゲット」）のACE4_DELETEと、それを含むディレクトリ（「親」）のACE4_DELETE_CHILDです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many systems also take the &#34;sticky bit&#34; (MODE4_SVTX) on a directory to allow unlink only to a user that owns either the target or the parent; on some such systems the decision also depends on whether the target is writable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くのシステムでは、ディレクトリで「スティッキービット」（MODE4_SVTX）を使用して、ターゲットまたは親のいずれかを所有するユーザーのみへのリンク解除を許可します。一部のそのようなシステムでは、決定はターゲットが書き込み可能かどうかにも依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers SHOULD allow unlink if either ACE4_DELETE is permitted on the target, or ACE4_DELETE_CHILD is permitted on the parent. (Note that this is true even if the parent or target explicitly denies one of these permissions.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットでACE4_DELETEが許可されている場合、または親でACE4_DELETE_CHILDが許可されている場合、サーバーはリンク解除を許可する必要があります（SHOULD）。 （これは、親またはターゲットがこれらの権限の1つを明示的に拒否した場合でも当てはまります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the ACLs in question neither explicitly ALLOW nor DENY either of the above, and if MODE4_SVTX is not set on the parent, then the server SHOULD allow the removal if and only if ACE4_ADD_FILE is permitted. In the case where MODE4_SVTX is set, the server may also require the remover to own either the parent or the target, or may require the target to be writable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
問題のACLが上記のいずれも明示的に許可も拒否もせず、MODE4_SVTXが親で設定されていない場合、サーバーは、ACE4_ADD_FILEが許可されている場合に限り、削除を許可する必要があります（SHOULD）。 MODE4_SVTXが設定されている場合、サーバーはリムーバーが親またはターゲットのいずれかを所有することを要求するか、ターゲットが書き込み可能であることを要求する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This allows servers to support something close to traditional UNIX-like semantics, with ACE4_ADD_FILE taking the place of the write bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、サーバーは、書き込みビットの代わりにACE4_ADD_FILEを使用して、従来のUNIXに似たセマンティクスに近いものをサポートできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-1-4--ACE-flag">
6.2.1.4. ACE flag
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.4. ACEフラグ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bitmask constants used for the flag field are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグフィールドに使用されるビットマスク定数は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_FILE_INHERIT_ACE             = 0x00000001;
   const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;
   const ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;
   const ACE4_INHERIT_ONLY_ACE             = 0x00000008;
   const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;
   const ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;
   const ACE4_IDENTIFIER_GROUP             = 0x00000040;
   const ACE4_INHERITED_ACE                = 0x00000080;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server need not support any of these flags. If the server supports flags that are similar to, but not exactly the same as, these flags, the implementation may define a mapping between the protocol-defined flags and the implementation-defined flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはこれらのフラグをサポートする必要はありません。サーバーがこれらのフラグに類似しているが完全に同じではないフラグをサポートしている場合、実装はプロトコル定義のフラグと実装定義のフラグとの間のマッピングを定義できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, suppose a client tries to set an ACE with ACE4_FILE_INHERIT_ACE set but not ACE4_DIRECTORY_INHERIT_ACE. If the server does not support any form of ACL inheritance, the server should reject the request with NFS4ERR_ATTRNOTSUPP. If the server supports a single &#34;inherit ACE&#34; flag that applies to both files and directories, the server may reject the request (i.e., requiring the client to set both the file and directory inheritance flags). The server may also accept the request and silently turn on the ACE4_DIRECTORY_INHERIT_ACE flag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、クライアントがACE4_FILE_INHERIT_ACEを設定してACE4_DIRECTORY_INHERIT_ACEを設定せずにACEを設定しようとしているとします。サーバーがどの形式のACL継承もサポートしていない場合、サーバーはNFS4ERR_ATTRNOTSUPPを使用して要求を拒否する必要があります。サーバーがファイルとディレクトリの両方に適用される単一の「継承ACE」フラグをサポートしている場合、サーバーはリクエストを拒否する可能性があります（つまり、クライアントにファイルとディレクトリの両方の継承フラグを設定するよう要求する）。サーバーは要求を受け入れ、サイレントにACE4_DIRECTORY_INHERIT_ACEフラグをオンにすることもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-1-4-1--Discussion-of-Flag-Bits">
6.2.1.4.1. Discussion of Flag Bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.4.1. フラグビットの説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_FILE_INHERIT_ACE Any non-directory file in any sub-directory will get this ACE inherited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_FILE_INHERIT_ACEサブディレクトリ内の非ディレクトリファイルは、このACEを継承します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_DIRECTORY_INHERIT_ACE Can be placed on a directory and indicates that this ACE should be added to each new directory created. If this flag is set in an ACE in an ACL attribute to be set on a non-directory file system object, the operation attempting to set the ACL SHOULD fail with NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_DIRECTORY_INHERIT_ACEディレクトリに配置でき、このACEを、作成される新しい各ディレクトリに追加する必要があることを示します。このフラグが、ディレクトリ以外のファイルシステムオブジェクトに設定されるACL属性のACEで設定されている場合、ACLを設定しようとする操作はNFS4ERR_ATTRNOTSUPPで失敗する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_NO_PROPAGATE_INHERIT_ACE Can be placed on a directory. This flag tells the server that inheritance of this ACE should stop at newly created child directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_NO_PROPAGATE_INHERIT_ACEディレクトリに配置できます。このフラグは、このACEの継承が新しく作成された子ディレクトリで停止することをサーバーに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_INHERIT_ONLY_ACE Can be placed on a directory but does not apply to the directory; ALLOW and DENY ACEs with this bit set do not affect access to the directory, and AUDIT and ALARM ACEs with this bit set do not trigger log or alarm events. Such ACEs only take effect once they are applied (with this bit cleared) to newly created files and directories as specified by the ACE4_FILE_INHERIT_ACE and ACE4_DIRECTORY_INHERIT_ACE flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_INHERIT_ONLY_ACEディレクトリに配置できますが、ディレクトリには適用されません。このビットが設定されたALLOWおよびDENY ACEは、ディレクトリへのアクセスに影響を与えません。また、このビットが設定されたAUDITおよびALARM ACEは、ログまたはアラームイベントをトリガーしません。このようなACEは、ACE4_FILE_INHERIT_ACEおよびACE4_DIRECTORY_INHERIT_ACEフラグで指定されたように、新しく作成されたファイルおよびディレクトリに適用されると（このビットがクリアされて）初めて有効になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If this flag is present on an ACE, but neither ACE4_DIRECTORY_INHERIT_ACE nor ACE4_FILE_INHERIT_ACE is present, then an operation attempting to set such an attribute SHOULD fail with NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このフラグがACEに存在するが、ACE4_DIRECTORY_INHERIT_ACEもACE4_FILE_INHERIT_ACEも存在しない場合、そのような属性を設定しようとする操作はNFS4ERR_ATTRNOTSUPPで失敗する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_SUCCESSFUL_ACCESS_ACE_FLAG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_SUCCESSFUL_ACCESS_ACE_FLAG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_FAILED_ACCESS_ACE_FLAG The ACE4_SUCCESSFUL_ACCESS_ACE_FLAG (SUCCESS) and ACE4_FAILED_ACCESS_ACE_FLAG (FAILED) flag bits may be set only on ACE4_SYSTEM_AUDIT_ACE_TYPE (AUDIT) and ACE4_SYSTEM_ALARM_ACE_TYPE (ALARM) ACE types. If during the processing of the file&#39;s ACL, the server encounters an AUDIT or ALARM ACE that matches the principal attempting the OPEN, the server notes that fact, and the presence, if any, of the SUCCESS and FAILED flags encountered in the AUDIT or ALARM ACE. Once the server completes the ACL processing, it then notes if the operation succeeded or failed. If the operation succeeded, and if the SUCCESS flag was set for a matching AUDIT or ALARM ACE, then the appropriate AUDIT or ALARM event occurs. If the operation failed, and if the FAILED flag was set for the matching AUDIT or ALARM ACE, then the appropriate AUDIT or ALARM event occurs. Either or both of the SUCCESS or FAILED can be set, but if neither is set, the AUDIT or ALARM ACE is not useful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_FAILED_ACCESS_ACE_FLAG ACE4_SUCCESSFUL_ACCESS_ACE_FLAG（SUCCESS）およびACE4_FAILED_ACCESS_ACE_FLAG（FAILED）フラグビットは、ACE4_SYSTEM_AUDIT_ACE_TYPE（AUDIT）およびACE4_SYSTEM_ALARM_ACE_TYPE（.ALARM）タイプでのみ設定できます。ファイルのACLの処理中に、サーバーがOPENを試行するプリンシパルと一致するAUDITまたはALARM ACEを検出すると、サーバーはその事実と、AUDITまたはALARMで発生したSUCCESSおよびFAILEDフラグの存在（ある場合）を記録します。エース。サーバーはACL処理を完了すると、操作が成功したか失敗したかを記録します。操作が成功し、一致するAUDITまたはALARM ACEにSUCCESSフラグが設定されている場合、適切なAUDITまたはALARMイベントが発生します。操作が失敗し、一致するAUDITまたはALARM ACEにFAILEDフラグが設定されている場合、適切なAUDITまたはALARMイベントが発生します。 SUCCESSまたはFAILEDのいずれかまたは両方を設定できますが、どちらも設定されていない場合、AUDITまたはALARM ACEは役に立ちません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The previously described processing applies to ACCESS operations even when they return NFS4_OK. For the purposes of AUDIT and ALARM, we consider an ACCESS operation to be a &#34;failure&#34; if it fails to return a bit that was requested and supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
前述の処理は、NFS4_OKを返す場合でも、ACCESS操作に適用されます。 AUDITとALARMの目的のために、要求されサポートされているビットを返すことができない場合、ACCESS操作は「失敗」と見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_IDENTIFIER_GROUP Indicates that the &#34;who&#34; refers to a GROUP as defined under UNIX or a GROUP ACCOUNT as defined under Windows. Clients and servers MUST ignore the ACE4_IDENTIFIER_GROUP flag on ACEs with a who value equal to one of the special identifiers outlined in Section 6.2.1.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_IDENTIFIER_GROUP「who」がUNIXで定義されたGROUPまたはWindowsで定義されたGROUP ACCOUNTを指すことを示します。クライアントとサーバーは、セクション6.2.1.5で概説されている特別な識別子の1つに等しいwho値を持つACEのACE4_IDENTIFIER_GROUPフラグを無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_INHERITED_ACE Indicates that this ACE is inherited from a parent directory. A server that supports automatic inheritance will place this flag on any ACEs inherited from the parent directory when creating a new object. Client applications will use this to perform automatic inheritance. Clients and servers MUST clear this bit in the acl attribute; it may only be used in the dacl and sacl attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_INHERITED_ACEこのACEが親ディレクトリから継承されることを示します。自動継承をサポートするサーバーは、新しいオブジェクトを作成するときに、親ディレクトリから継承されたACEにこのフラグを配置します。クライアントアプリケーションは、これを使用して自動継承を実行します。クライアントとサーバーは、acl属性のこのビットをクリアする必要があります。 daclおよびsacl属性でのみ使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-1-5--ACE-Who">
6.2.1.5. ACE Who
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.5. エースフー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;who&#34; field of an ACE is an identifier that specifies the principal or principals to whom the ACE applies. It may refer to a user or a group, with the flag bit ACE4_IDENTIFIER_GROUP specifying which.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACEの「who」フィールドは、ACEが適用されるプリンシパルを指定する識別子です。フラグビットACE4_IDENTIFIER_GROUPがどちらを指定するかで、ユーザーまたはグループを参照する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several special identifiers that need to be understood universally, rather than in the context of a particular DNS domain. Some of these identifiers cannot be understood when an NFS client accesses the server, but have meaning when a local process accesses the file. The ability to display and modify these permissions is permitted over NFS, even if none of the access methods on the server understands the identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のDNSドメインのコンテキストではなく、普遍的に理解する必要があるいくつかの特別な識別子があります。これらの識別子の一部は、NFSクライアントがサーバーにアクセスするときには理解できませんが、ローカルプロセスがファイルにアクセスするときには意味があります。これらのアクセス許可を表示および変更する機能は、サーバー上のアクセス方法が識別子を理解していない場合でも、NFSを介して許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +---------------+--------------------------------------------------+
   | Who           | Description                                      |
   +---------------+--------------------------------------------------+
   | OWNER         | The owner of the file.                           |
   | GROUP         | The group associated with the file.              |
   | EVERYONE      | The world, including the owner and owning group. |
   | INTERACTIVE   | Accessed from an interactive terminal.           |
   | NETWORK       | Accessed via the network.                        |
   | DIALUP        | Accessed as a dialup user to the server.         |
   | BATCH         | Accessed from a batch job.                       |
   | ANONYMOUS     | Accessed without any authentication.             |
   | AUTHENTICATED | Any authenticated user (opposite of ANONYMOUS).  |
   | SERVICE       | Access from a system service.                    |
   +---------------+--------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Table 4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
表4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid conflict, these special identifiers are distinguished by an appended &#34;@&#34; and should appear in the form &#34;xxxx@&#34; (with no domain name after the &#34;@&#34;), for example, ANONYMOUS@.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
競合を回避するために、これらの特別な識別子は「@」が付加されて区別され、「xxxx @」（「@」の後にドメイン名はありません）の形式で表示されます（例：ANONYMOUS @）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ACE4_IDENTIFIER_GROUP flag MUST be ignored on entries with these special identifiers. When encoding entries with these special identifiers, the ACE4_IDENTIFIER_GROUP flag SHOULD be set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの特別な識別子を持つエントリでは、ACE4_IDENTIFIER_GROUPフラグを無視する必要があります。これらの特別な識別子でエントリをエンコードするとき、ACE4_IDENTIFIER_GROUPフラグはゼロに設定されるべきです（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-1-5-1--Discussion-of-EVERYONE">
6.2.1.5.1. Discussion of EVERYONE@
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.5.1. EVERYONE @の議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is important to note that &#34;EVERYONE@&#34; is not equivalent to the UNIX &#34;other&#34; entity. This is because, by definition, UNIX &#34;other&#34; does not include the owner or owning group of a file. &#34;EVERYONE@&#34; means literally everyone, including the owner or owning group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「EVERYONE @」はUNIXの「その他」のエンティティと同等ではないことに注意することが重要です。これは、UNIXの「その他」にファイルの所有者または所有グループが含まれていないためです。 「EVERYONE @」は、所有者または所有グループを含む文字通り全員を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-2--Attribute-58-dacl">
6.2.2. Attribute 58: dacl
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. 属性58：タックル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The dacl attribute is like the acl attribute, but dacl allows just ALLOW and DENY ACEs. The dacl attribute supports automatic inheritance (see Section 6.4.3.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
dacl属性はacl属性に似ていますが、daclはALLOWおよびDENY ACEのみを許可します。 dacl属性は自動継承をサポートします（6.4.3.2項を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-3--Attribute-59-sacl">
6.2.3. Attribute 59: sacl
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3. 属性59：sacl
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sacl attribute is like the acl attribute, but sacl allows just AUDIT and ALARM ACEs. The sacl attribute supports automatic inheritance (see Section 6.4.3.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sacl属性はacl属性に似ていますが、saclはAUDITおよびALARM ACEのみを許可します。 sacl属性は自動継承をサポートします（6.4.3.2項を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-4--Attribute-33-mode">
6.2.4. Attribute 33: mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.4. 属性33：モード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 mode attribute is based on the UNIX mode bits. The following bits are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1モード属性は、UNIXモードビットに基づいています。次のビットが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const MODE4_SUID = 0x800;  /* set user id on execution */
   const MODE4_SGID = 0x400;  /* set group id on execution */
   const MODE4_SVTX = 0x200;  /* save text even after use */
   const MODE4_RUSR = 0x100;  /* read permission: owner */
   const MODE4_WUSR = 0x080;  /* write permission: owner */
   const MODE4_XUSR = 0x040;  /* execute permission: owner */
   const MODE4_RGRP = 0x020;  /* read permission: group */
   const MODE4_WGRP = 0x010;  /* write permission: group */
   const MODE4_XGRP = 0x008;  /* execute permission: group */
   const MODE4_ROTH = 0x004;  /* read permission: other */
   const MODE4_WOTH = 0x002;  /* write permission: other */
   const MODE4_XOTH = 0x001;  /* execute permission: other */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bits MODE4_RUSR, MODE4_WUSR, and MODE4_XUSR apply to the principal identified in the owner attribute. Bits MODE4_RGRP, MODE4_WGRP, and MODE4_XGRP apply to principals identified in the owner_group attribute but who are not identified in the owner attribute. Bits MODE4_ROTH, MODE4_WOTH, and MODE4_XOTH apply to any principal that does not match that in the owner attribute and does not have a group matching that of the owner_group attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビットMODE4_RUSR、MODE4_WUSR、およびMODE4_XUSRは、所有者属性で識別されるプリンシパルに適用されます。ビットMODE4_RGRP、MODE4_WGRP、およびMODE4_XGRPは、owner_group属性で識別されるが、owner属性で識別されないプリンシパルに適用されます。ビットMODE4_ROTH、MODE4_WOTH、およびMODE4_XOTHは、所有者属性のプリンシパルと一致せず、owner_group属性のグループと一致するグループを持たないプリンシパルに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bits within a mode other than those specified above are not defined by this protocol. A server MUST NOT return bits other than those defined above in a GETATTR or READDIR operation, and it MUST return NFS4ERR_INVAL if bits other than those defined above are set in a SETATTR, CREATE, OPEN, VERIFY, or NVERIFY operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記以外のモード内のビットは、このプロトコルでは定義されていません。サーバーは、GETATTRまたはREADDIR操作で上記で定義されたもの以外のビットを返さないでください。また、SETATTR、CREATE、OPEN、VERIFY、またはNVERIFY操作で上記で定義されたもの以外のビットが設定されている場合、NFS4ERR_INVALを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-5--Attribute-74-modesetmasked">
6.2.5. Attribute 74: mode_set_masked
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.5. 属性74：mode_set_masked
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mode_set_masked attribute is a write-only attribute that allows individual bits in the mode attribute to be set or reset, without changing others. It allows, for example, the bits MODE4_SUID, MODE4_SGID, and MODE4_SVTX to be modified while leaving unmodified any of the nine low-order mode bits devoted to permissions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mode_set_masked属性は、モード属性の個々のビットを、他のビットを変更せずに設定またはリセットできる書き込み専用属性です。これにより、たとえば、ビットMODE4_SUID、MODE4_SGID、およびMODE4_SVTXを変更できる一方で、権限に割り当てられた9つの下位モードビットを変更せずに残すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In such instances that the nine low-order bits are left unmodified, then neither the acl nor the dacl attribute should be automatically modified as discussed in Section 6.4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下位9ビットが変更されないままになっている場合、セクション6.4.1で説明されているように、acl属性もdacl属性も自動的に変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mode_set_masked attribute consists of two words, each in the form of a mode4. The first consists of the value to be applied to the current mode value and the second is a mask. Only bits set to one in the mask word are changed (set or reset) in the file&#39;s mode. All other bits in the mode remain unchanged. Bits in the first word that correspond to bits that are zero in the mask are ignored, except that undefined bits are checked for validity and can result in NFS4ERR_INVAL as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mode_set_masked属性は、それぞれがmode4の形式の2つのワードで構成されます。 1つ目は現在のモード値に適用される値で構成され、2つ目はマスクです。マスクワードで1に設定されたビットのみが、ファイルのモードで変更（セットまたはリセット）されます。モードの他のすべてのビットは変更されません。未定義ビットの有効性がチェックされ、以下で説明するようにNFS4ERR_INVALになる可能性があることを除いて、マスクのゼロであるビットに対応する最初のワードのビットは無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mode_set_masked attribute is only valid in a SETATTR operation. If it is used in a CREATE or OPEN operation, the server MUST return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mode_set_masked属性は、SETATTR操作でのみ有効です。 CREATEまたはOPEN操作で使用する場合、サーバーはNFS4ERR_INVALを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bits not defined as valid in the mode attribute are not valid in either word of the mode_set_masked attribute. The server MUST return NFS4ERR_INVAL if any such bits are set to one in a SETATTR. If the mode and mode_set_masked attributes are both specified in the same SETATTR, the server MUST also return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mode属性で有効と定義されていないビットは、mode_set_masked属性のいずれのワードでも無効です。 SETATTRでそのようなビットが1に設定されている場合、サーバーはNFS4ERR_INVALを返さなければなりません。 mode属性とmode_set_masked属性の両方が同じSETATTRで指定されている場合、サーバーはNFS4ERR_INVALも返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3--Common-Methods">
6.3. Common Methods
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. 一般的な方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The requirements in this section will be referred to in future sections, especially Section 6.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションの要件は、今後のセクション、特にセクション6.4で参照されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3-1--Interpreting-an-ACL">
6.3.1. Interpreting an ACL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. ACLの解釈
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3-1-1--Server-Considerations">
6.3.1.1. Server Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1.1. サーバーに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server uses the algorithm described in Section 6.2.1 to determine whether an ACL allows access to an object. However, the ACL might not be the sole determiner of access. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、セクション6.2.1で説明されているアルゴリズムを使用して、ACLがオブジェクトへのアクセスを許可するかどうかを決定します。ただし、ACLがアクセスの唯一の決定者ではない場合があります。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the case of a file system exported as read-only, the server may deny write access even though an object&#39;s ACL grants it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 読み取り専用としてエクスポートされたファイルシステムの場合、オブジェクトのACLで許可されていても、サーバーは書き込みアクセスを拒否することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Server implementations MAY grant ACE4_WRITE_ACL and ACE4_READ_ACL permissions to prevent a situation from arising in which there is no valid way to ever modify the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーの実装は、ACE4_WRITE_ACLおよびACE4_READ_ACLアクセス許可を付与して、ACLを変更する有効な方法がない状況が発生しないようにすることができます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All servers will allow a user the ability to read the data of the file when only the execute permission is granted (i.e., if the ACL denies the user the ACE4_READ_DATA access and allows the user ACE4_EXECUTE, the server will allow the user to read the data of the file).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o すべてのサーバーは、実行権限のみが付与されている場合にユーザーがファイルのデータを読み取ることができるようにします（つまり、ACLがユーザーにACE4_READ_DATAアクセスを拒否し、ユーザーにACE4_EXECUTEを許可すると、サーバーはユーザーにデータの読み取りを許可しますファイルの）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Many servers have the notion of owner-override in which the owner of the object is allowed to override accesses that are denied by the ACL. This may be helpful, for example, to allow users continued access to open files on which the permissions have changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 多くのサーバーには、オブジェクトの所有者がACLによって拒否されたアクセスを上書きすることが許可されている所有者オーバーライドの概念があります。これは、たとえば、アクセス許可が変更された開いているファイルにユーザーが引き続きアクセスできるようにする場合に役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Many servers have the notion of a &#34;superuser&#34; that has privileges beyond an ordinary user. The superuser may be able to read or write data or metadata in ways that would not be permitted by the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 多くのサーバーには、通常のユーザー以上の特権を持つ「スーパーユーザー」という概念があります。スーパーユーザーは、ACLで許可されていない方法でデータまたはメタデータを読み書きできる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A retention attribute might also block access otherwise allowed by ACLs (see Section 5.13).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 保持属性は、ACLによって許可されたアクセスをブロックする場合もあります（セクション5.13を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3-1-2--Client-Considerations">
6.3.1.2. Client Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1.2. Client Considerations
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients SHOULD NOT do their own access checks based on their interpretation of the ACL, but rather use the OPEN and ACCESS operations to do access checks. This allows the client to act on the results of having the server determine whether or not access should be granted based on its interpretation of the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、ACLの解釈に基づいて独自のアクセスチェックを行うべきではなく、OPENおよびACCESS操作を使用してアクセスチェックを行う必要があります。これにより、クライアントは、ACLの解釈に基づいてアクセスを許可するかどうかをサーバーに決定させた結果に基づいて行動できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Clients must be aware of situations in which an object&#39;s ACL will define a certain access even though the server will not enforce it. In general, but especially in these situations, the client needs to do its part in the enforcement of access as defined by the ACL. To do this, the client MAY send the appropriate ACCESS operation prior to servicing the request of the user or application in order to determine whether the user or application should be granted the access requested. For examples in which the ACL may define accesses that the server doesn&#39;t enforce, see Section 6.3.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Clients must be aware of situations in which an object&#39;s ACL will define a certain access even though the server will not enforce it. In general, but especially in these situations, the client needs to do its part in the enforcement of access as defined by the ACL. To do this, the client MAY send the appropriate ACCESS operation prior to servicing the request of the user or application in order to determine whether the user or application should be granted the access requested. For examples in which the ACL may define accesses that the server doesn&#39;t enforce, see Section 6.3.1.1.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3-2--Computing-a-Mode-Attribute-from-an-ACL">
6.3.2. Computing a Mode Attribute from an ACL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. ACLからのモード属性の計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following method can be used to calculate the MODE4_R*, MODE4_W*, and MODE4_X* bits of a mode attribute, based upon an ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following method can be used to calculate the MODE4_R*, MODE4_W*, and MODE4_X* bits of a mode attribute, based upon an ACL.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, for each of the special identifiers OWNER@, GROUP@, and EVERYONE@, evaluate the ACL in order, considering only ALLOW and DENY ACEs for the identifier EVERYONE@ and for the identifier under consideration. The result of the evaluation will be an NFSv4 ACL mask showing exactly which bits are permitted to that identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初に、特別な識別子OWNER @、GROUP @、およびEVERYONE @のそれぞれについて、順番にACLを評価します。識別子EVERYONE @および考慮中の識別子のALLOWおよびDENY ACEのみを考慮します。評価の結果は、その識別子に許可されているビットを正確に示すNFSv4 ACLマスクになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Then translate the calculated mask for OWNER@, GROUP@, and EVERYONE@ into mode bits for, respectively, the user, group, and other, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、OWNER @、GROUP @、およびEVERYONE @の計算されたマスクを、次のように、それぞれユーザー、グループ、およびその他のモードビットに変換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Set the read bit (MODE4_RUSR, MODE4_RGRP, or MODE4_ROTH) if and only if ACE4_READ_DATA is set in the corresponding mask.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. ACE4_READ_DATAが対応するマスクで設定されている場合にのみ、読み取りビット（MODE4_RUSR、MODE4_RGRP、またはMODE4_ROTH）を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Set the write bit (MODE4_WUSR, MODE4_WGRP, or MODE4_WOTH) if and only if ACE4_WRITE_DATA and ACE4_APPEND_DATA are both set in the corresponding mask.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Set the write bit (MODE4_WUSR, MODE4_WGRP, or MODE4_WOTH) if and only if ACE4_WRITE_DATA and ACE4_APPEND_DATA are both set in the corresponding mask.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Set the execute bit (MODE4_XUSR, MODE4_XGRP, or MODE4_XOTH), if and only if ACE4_EXECUTE is set in the corresponding mask.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 対応するマスクにACE4_EXECUTEが設定されている場合にのみ、実行ビット（MODE4_XUSR、MODE4_XGRP、またはMODE4_XOTH）を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3-2-1--Discussion">
6.3.2.1. Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.1. Discussion
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some server implementations also add bits permitted to named users and groups to the group bits (MODE4_RGRP, MODE4_WGRP, and MODE4_XGRP).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のサーバー実装では、指定されたユーザーおよびグループに許可されたビットをグループビット（MODE4_RGRP、MODE4_WGRP、およびMODE4_XGRP）に追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations are discouraged from doing this, because it has been found to cause confusion for users who see members of a file&#39;s group denied access that the mode bits appear to allow. (The presence of DENY ACEs may also lead to such behavior, but DENY ACEs are expected to be more rarely used.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モードビットが許可しているように見えるファイルのグループのメンバーがアクセスを拒否しているのを見たユーザーを混乱させることが判明しているため、実装はこれを行わないようにしてください。 （DENY ACEの存在もこのような動作につながる可能性がありますが、DENY ACEが使用されることはほとんどありません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same user confusion seen when fetching the mode also results if setting the mode does not effectively control permissions for the owner, group, and other users; this motivates some of the requirements that follow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モードを取得するときに見られるのと同じユーザーの混乱は、モードの設定が所有者、グループ、および他のユーザーのアクセス許可を効果的に制御しない場合にも発生します。これにより、以下の要件の一部が動機付けられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4--Requirements">
6.4. Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. 必要条件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server that supports both mode and ACL must take care to synchronize the MODE4_*USR, MODE4_*GRP, and MODE4_*OTH bits with the ACEs that have respective who fields of &#34;OWNER@&#34;, &#34;GROUP@&#34;, and &#34;EVERYONE@&#34;. This way, the client can see if semantically equivalent access permissions exist whether the client asks for the owner, owner_group, and mode attributes or for just the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モードとACLの両方をサポートするサーバーは、MODE4_ * USR、MODE4_ * GRP、およびMODE4_ * OTHビットを、「OWNER @」、「GROUP @」、および「EVERYONE @」のそれぞれのwhoフィールドを持つACEと同期するように注意する必要があります」このようにして、クライアントは、クライアントが所有者、owner_group、およびモード属性を要求する場合でも、ACLのみを要求する場合でも、意味的に同等のアクセス許可が存在するかどうかを確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this section, much is made of the methods in Section 6.3.2. Many requirements refer to this section. But note that the methods have behaviors specified with &#34;SHOULD&#34;. This is intentional, to avoid invalidating existing implementations that compute the mode according to the withdrawn POSIX ACL draft (1003.1e draft 17), rather than by actual permissions on owner, group, and other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、セクション6.3.2のメソッドから多くのことが行われます。多くの要件がこのセクションを参照しています。ただし、メソッドには「SHOULD」で指定された動作があることに注意してください。これは、所有者、グループなどに対する実際の権限ではなく、撤回されたPOSIX ACLドラフト（1003.1eドラフト17）に従ってモードを計算する既存の実装を無効にすることを避けるための意図的なものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4-1--Setting-the-Mode-andor-ACL-Attributes">
6.4.1. Setting the Mode and/or ACL Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1. モードおよび/またはACL属性の設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case where a server supports the sacl or dacl attribute, in addition to the acl attribute, the server MUST fail a request to set the acl attribute simultaneously with a dacl or sacl attribute. The error to be given is NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case where a server supports the sacl or dacl attribute, in addition to the acl attribute, the server MUST fail a request to set the acl attribute simultaneously with a dacl or sacl attribute. The error to be given is NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4-1-1--Setting-Mode-and-not-ACL">
6.4.1.1. Setting Mode and not ACL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1.1. ACLではなく設定モード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When any of the nine low-order mode bits are subject to change, either because the mode attribute was set or because the mode_set_masked attribute was set and the mask included one or more bits from the nine low-order mode bits, and no ACL attribute is explicitly set, the acl and dacl attributes must be modified in accordance with the updated value of those bits. This must happen even if the value of the low-order bits is the same after the mode is set as before.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When any of the nine low-order mode bits are subject to change, either because the mode attribute was set or because the mode_set_masked attribute was set and the mask included one or more bits from the nine low-order mode bits, and no ACL attribute is explicitly set, the acl and dacl attributes must be modified in accordance with the updated value of those bits. This must happen even if the value of the low-order bits is the same after the mode is set as before.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that any AUDIT or ALARM ACEs (hence any ACEs in the sacl attribute) are unaffected by changes to the mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUDITまたはALARM ACE（つまり、sacl属性のACE）は、モードの変更による影響を受けないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In cases in which the permissions bits are subject to change, the acl and dacl attributes MUST be modified such that the mode computed via the method in Section 6.3.2 yields the low-order nine bits (MODE4_R*, MODE4_W*, MODE4_X*) of the mode attribute as modified by the attribute change. The ACL attributes SHOULD also be modified such that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
許可ビットが変更される可能性がある場合、セクション6.3.2のメソッドを介して計算されたモードが下位9ビット（MODE4_R *、MODE4_W *、MODE4_X *）を生成するように、aclおよびdacl属性を変更する必要があります。属性変更によって変更されたモード属性の。 ACL属性は、次のように変更する必要もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If MODE4_RGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_READ_DATA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. MODE4_RGRPが設定されていない場合、OWNER @およびEVERYONE @以外のACLに明示的にリストされているエンティティには、ACE4_READ_DATAを付与しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If MODE4_WGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_WRITE_DATA or ACE4_APPEND_DATA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. MODE4_WGRPが設定されていない場合、OWNER @およびEVERYONE @以外のACLに明示的にリストされているエンティティには、ACE4_WRITE_DATAまたはACE4_APPEND_DATAを付与しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If MODE4_XGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_EXECUTE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If MODE4_XGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_EXECUTE.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Access mask bits other than those listed above, appearing in ALLOW ACEs, MAY also be disabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ALLOW ACEに表示される上記以外のアクセスマスクビットも無効にできます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that ACEs with the flag ACE4_INHERIT_ONLY_ACE set do not affect the permissions of the ACL itself, nor do ACEs of the type AUDIT and ALARM. As such, it is desirable to leave these ACEs unmodified when modifying the ACL attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグACE4_INHERIT_ONLY_ACEが設定されたACEは、ACL自体のアクセス許可には影響せず、タイプAU​​DITおよびALARMのACEにも影響しないことに注意してください。そのため、ACL属性を変更するときは、これらのACEを変更しないでおくことが望ましいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Also note that the requirement may be met by discarding the acl and dacl, in favor of an ACL that represents the mode and only the mode. This is permitted, but it is preferable for a server to preserve as much of the ACL as possible without violating the above requirements. Discarding the ACL makes it effectively impossible for a file created with a mode attribute to inherit an ACL (see Section 6.4.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、モードとモードのみを表すACLを優先して、aclとdaclを破棄することで要件が満たされる場合があることにも注意してください。これは許可されていますが、サーバーが上記の要件に違反することなく、できるだけ多くのACLを保持することをお勧めします。 ACLを破棄すると、mode属性で作成されたファイルがACLを継承することが事実上不可能になります（6.4.3項を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4-1-2--Setting-ACL-and-Not-Mode">
6.4.1.2. Setting ACL and Not Mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1.2. ACLを設定し、モードを設定しない
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When setting the acl or dacl and not setting the mode or mode_set_masked attributes, the permission bits of the mode need to be derived from the ACL. In this case, the ACL attribute SHOULD be set as given. The nine low-order bits of the mode attribute (MODE4_R*, MODE4_W*, MODE4_X*) MUST be modified to match the result of the method in Section 6.3.2. The three high-order bits of the mode (MODE4_SUID, MODE4_SGID, MODE4_SVTX) SHOULD remain unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
aclまたはdaclを設定し、modeまたはmode_set_masked属性を設定しない場合は、モードの許可ビットをACLから取得する必要があります。この場合、ACL属性は指定されたとおりに設定する必要があります（SHOULD）。モード属性の下位9ビット（MODE4_R *、MODE4_W *、MODE4_X *）は、セクション6.3.2のメソッドの結果と一致するように変更する必要があります。モードの3つの上位ビット（MODE4_SUID、MODE4_SGID、MODE4_SVTX）は変更されないままにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4-1-3--Setting-Both-ACL-and-Mode">
6.4.1.3. Setting Both ACL and Mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1.3. ACLとモードの両方の設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When setting both the mode (includes use of either the mode attribute or the mode_set_masked attribute) and the acl or dacl attributes in the same operation, the attributes MUST be applied in this order: mode (or mode_set_masked), then ACL. The mode-related attribute is set as given, then the ACL attribute is set as given, possibly changing the final mode, as described above in Section 6.4.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じ操作でモード（mode属性またはmode_set_masked属性のいずれかの使用を含む）とaclまたはdacl属性の両方を設定する場合は、属性をモード（またはmode_set_masked）、次にACLの順に適用する必要があります。セクション6.4.1.2で説明したように、モード関連の属性が指定どおりに設定され、次にACL属性が指定どおりに設定され、最終モードが変更される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4-2--Retrieving-the-Mode-andor-ACL-Attributes">
6.4.2. Retrieving the Mode and/or ACL Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2. モードおよび/またはACL属性の取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section applies only to servers that support both the mode and ACL attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section applies only to servers that support both the mode and ACL attributes.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some server implementations may have a concept of &#34;objects without ACLs&#34;, meaning that all permissions are granted and denied according to the mode attribute and that no ACL attribute is stored for that object. If an ACL attribute is requested of such a server, the server SHOULD return an ACL that does not conflict with the mode; that is to say, the ACL returned SHOULD represent the nine low-order bits of the mode attribute (MODE4_R*, MODE4_W*, MODE4_X*) as described in Section 6.3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のサーバー実装には、「ACLのないオブジェクト」という概念がある場合があります。つまり、すべての権限はモード属性に従って付与および拒否され、そのオブジェクトのACL属性は保存されません。そのようなサーバーのACL属性が要求された場合、サーバーはモードと競合しないACLを返す必要があります（SHOULD）。つまり、セクション6.3.2で説明されているように、返されるACLはモード属性（MODE4_R *、MODE4_W *、MODE4_X *）の下位9ビットを表す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For other server implementations, the ACL attribute is always present for every object. Such servers SHOULD store at least the three high-order bits of the mode attribute (MODE4_SUID, MODE4_SGID, MODE4_SVTX). The server SHOULD return a mode attribute if one is requested, and the low-order nine bits of the mode (MODE4_R*, MODE4_W*, MODE4_X*) MUST match the result of applying the method in Section 6.3.2 to the ACL attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のサーバー実装の場合、ACL属性は常にすべてのオブジェクトに存在します。このようなサーバーは、モード属性（MODE4_SUID、MODE4_SGID、MODE4_SVTX）の少なくとも上位3ビットを格納する必要があります（SHOULD）。モード属性が要求された場合、サーバーはモード属性を返す必要があり（SHOULD）、モードの下位9ビット（MODE4_R *、MODE4_W *、MODE4_X *）は、セクション6.3.2のメソッドをACL属性に適用した結果と一致する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4-3--Creating-New-Objects">
6.4.3. Creating New Objects
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.3. 新しいオブジェクトの作成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server supports any ACL attributes, it may use the ACL attributes on the parent directory to compute an initial ACL attribute for a newly created object. This will be referred to as the inherited ACL within this section. The act of adding one or more ACEs to the inherited ACL that are based upon ACEs in the parent directory&#39;s ACL will be referred to as inheriting an ACE within this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがACL属性をサポートしている場合、サーバーは親ディレクトリのACL属性を使用して、新しく作成されたオブジェクトの初期ACL属性を計算できます。これは、このセクションでは継承されたACLと呼ばれます。親ディレクトリのACLにあるACEに基づいて、継承されたACLに1つ以上のACEを追加することを、このセクションではACEの継承と呼びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementors should standardize what the behavior of CREATE and OPEN must be depending on the presence or absence of the mode and ACL attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装者は、モードとACL属性の有無に応じて、CREATEとOPENの動作を標準化する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If just the mode is given in the call:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 呼び出しでモードのみが指定されている場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In this case, inheritance SHOULD take place, but the mode MUST be applied to the inherited ACL as described in Section 6.4.1.1, thereby modifying the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
この場合、継承が行われる必要があります（SHOULD）が、6.4.1.1項で説明されているように、継承されたACLにモードを適用して、ACLを変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If just the ACL is given in the call:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 呼び出しでACLのみが指定されている場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In this case, inheritance SHOULD NOT take place, and the ACL as defined in the CREATE or OPEN will be set without modification, and the mode modified as in Section 6.4.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In this case, inheritance SHOULD NOT take place, and the ACL as defined in the CREATE or OPEN will be set without modification, and the mode modified as in Section 6.4.1.2.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If both mode and ACL are given in the call:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 呼び出しでモードとACLの両方が指定されている場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In this case, inheritance SHOULD NOT take place, and both attributes will be set as described in Section 6.4.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
この場合、継承は行われるべきではなく（SHOULD NOT）、両方の属性がセクション6.4.1.3で説明されているように設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If neither mode nor ACL is given in the call:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If neither mode nor ACL is given in the call:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In the case where an object is being created without any initial attributes at all, e.g., an OPEN operation with an opentype4 of OPEN4_CREATE and a createmode4 of EXCLUSIVE4, inheritance SHOULD NOT take place (note that EXCLUSIVE4_1 is a better choice of createmode4, since it does permit initial attributes). Instead, the server SHOULD set permissions to deny all access to the newly created object. It is expected that the appropriate client will set the desired attributes in a subsequent SETATTR operation, and the server SHOULD allow that operation to succeed, regardless of what permissions the object is created with. For example, an empty ACL denies all permissions, but the server should allow the owner&#39;s SETATTR to succeed even though WRITE_ACL is implicitly denied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
OPEN4_CREATEのopentype4とEXCLUSIVE4のcreatemode4を使用したOPEN操作など、オブジェクトが初期属性なしで作成されている場合、継承は行われるべきではありません（EXCLUSIVE4_1がcreatemode4のより良い選択であることに注意してください。初期属性は許可されます）。代わりに、サーバーは、新しく作成されたオブジェクトへのすべてのアクセスを拒否するアクセス許可を設定する必要があります（SHOULD）。適切なクライアントが後続のSETATTR操作で必要な属性を設定することが期待されており、サーバーは、オブジェクトの作成に使用する権限に関係なく、その操作を成功させる必要があります（SHOULD）。たとえば、空のACLはすべての権限を拒否しますが、WRITE_ACLが暗黙的に拒否されている場合でも、サーバーは所有者のSETATTRを成功させる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In other cases, inheritance SHOULD take place, and no modifications to the ACL will happen. The mode attribute, if supported, MUST be as computed in Section 6.3.2, with the MODE4_SUID, MODE4_SGID, and MODE4_SVTX bits clear. If no inheritable ACEs exist on the parent directory, the rules for creating acl, dacl, or sacl attributes are implementation defined. If either the dacl or sacl attribute is supported, then the ACL4_DEFAULTED flag SHOULD be set on the newly created attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
他の場合では、継承が行われる必要があり（SHOULD）、ACLへの変更は行われません。モード属性は、サポートされている場合、MODE4_SUID、MODE4_SGID、およびMODE4_SVTXビットがクリアされた状態で、セクション6.3.2で計算されたとおりでなければなりません。継承可能なACEが親ディレクトリに存在しない場合、acl、dacl、またはsacl属性を作成するためのルールは、実装によって定義されます。 daclまたはsacl属性のいずれかがサポートされている場合は、新しく作成された属性にACL4_DEFAULTEDフラグを設定する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4-3-1--The-Inherited-ACL">
6.4.3.1. The Inherited ACL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.3.1. 継承されたACL
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the object being created is not a directory, the inherited ACL SHOULD NOT inherit ACEs from the parent directory ACL unless the ACE4_FILE_INHERIT_FLAG is set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作成されるオブジェクトがディレクトリでない場合、継承されたACLは、ACE4_FILE_INHERIT_FLAGが設定されていない限り、親ディレクトリACLからACEを継承してはなりません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the object being created is a directory, the inherited ACL should inherit all inheritable ACEs from the parent directory, that is, those that have the ACE4_FILE_INHERIT_ACE or ACE4_DIRECTORY_INHERIT_ACE flag set. If the inheritable ACE has ACE4_FILE_INHERIT_ACE set but ACE4_DIRECTORY_INHERIT_ACE is clear, the inherited ACE on the newly created directory MUST have the ACE4_INHERIT_ONLY_ACE flag set to prevent the directory from being affected by ACEs meant for non-directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作成されるオブジェクトがディレクトリの場合、継承されたACLは、親ディレクトリから継承可能なすべてのACE、つまり、ACE4_FILE_INHERIT_ACEまたはACE4_DIRECTORY_INHERIT_ACEフラグが設定されているACEを継承する必要があります。継承可能なACEにACE4_FILE_INHERIT_ACEが設定されていて、ACE4_DIRECTORY_INHERIT_ACEがクリアされている場合、新しく作成されたディレクトリの継承されたACEにACE4_INHERIT_ONLY_ACEフラグを設定して、ディレクトリがディレクトリ以外のACEの影響を受けないようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When a new directory is created, the server MAY split any inherited ACE that is both inheritable and effective (in other words, that has neither ACE4_INHERIT_ONLY_ACE nor ACE4_NO_PROPAGATE_INHERIT_ACE set), into two ACEs, one with no inheritance flags and one with ACE4_INHERIT_ONLY_ACE set. (In the case of a dacl or sacl attribute, both of those ACEs SHOULD also have the ACE4_INHERITED_ACE flag set.) This makes it simpler to modify the effective permissions on the directory without modifying the ACE that is to be inherited to the new directory&#39;s children.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
新しいディレクトリが作成されると、サーバーは、継承可能かつ有効である（つまり、ACE4_INHERIT_ONLY_ACEもACE4_NO_PROPAGATE_INHERIT_ACEも設定されていない）継承されたACEを、継承フラグのない1つとACE4_INHERIT_ONLY_ACEセットのある2つのACEに分割できます（MAY）。 （daclまたはsacl属性の場合、これらのACEの両方にACE4_INHERITED_ACEフラグも設定されている必要があります。）これにより、新しいディレクトリの子に継承されるACEを変更せずに、ディレクトリの有効なアクセス許可を簡単に変更できます。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4-3-2--Automatic-Inheritance">
6.4.3.2. Automatic Inheritance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.3.2. 自動継承
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The acl attribute consists only of an array of ACEs, but the sacl (Section 6.2.3) and dacl (Section 6.2.2) attributes also include an additional flag field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
acl属性はACEの配列のみで構成されていますが、sacl（セクション6.2.3）およびdacl（セクション6.2.2）属性にも追加のフラグフィールドが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfsacl41 {
           aclflag4        na41_flag;
           nfsace4         na41_aces&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flag field applies to the entire sacl or dacl; three flag values are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグフィールドは、saclまたはdacl全体に適用されます。 3つのフラグ値が定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACL4_AUTO_INHERIT         = 0x00000001;
   const ACL4_PROTECTED            = 0x00000002;
   const ACL4_DEFAULTED            = 0x00000004;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and all other bits must be cleared. The ACE4_INHERITED_ACE flag may be set in the ACEs of the sacl or dacl (whereas it must always be cleared in the acl).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のすべてのビットはクリアする必要があります。 ACE4_INHERITED_ACEフラグは、saclまたはdaclのACEで設定できます（これは常にaclでクリアする必要があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Together these features allow a server to support automatic inheritance, which we now explain in more detail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの機能を組み合わせることで、サーバーは自動継承をサポートできるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inheritable ACEs are normally inherited by child objects only at the time that the child objects are created; later modifications to inheritable ACEs do not result in modifications to inherited ACEs on descendants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
継承可能なACEは通常、子オブジェクトの作成時にのみ子オブジェクトに継承されます。継承可能なACEを後で変更しても、子孫の継承されたACEは変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, the dacl and sacl provide an OPTIONAL mechanism that allows a client application to propagate changes to inheritable ACEs to an entire directory hierarchy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、daclおよびsaclは、クライアントアプリケーションが継承可能なACEへの変更をディレクトリ階層全体に伝播できるようにするオプションのメカニズムを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that supports this performs inheritance at object creation time in the normal way, and SHOULD set the ACE4_INHERITED_ACE flag on any inherited ACEs as they are added to the new object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これをサポートするサーバーは、オブジェクトの作成時に通常の方法で継承を実行し、継承されたACEが新しいオブジェクトに追加されるときに、ACE4_INHERITED_ACEフラグを継承ACEに設定する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A client application such as an ACL editor may then propagate changes to inheritable ACEs on a directory by recursively traversing that directory&#39;s descendants and modifying each ACL encountered to remove any ACEs with the ACE4_INHERITED_ACE flag and to replace them by the new inheritable ACEs (also with the ACE4_INHERITED_ACE flag set). It uses the existing ACE inheritance flags in the obvious way to decide which ACEs to propagate. (Note that it may encounter further inheritable ACEs when descending the directory hierarchy and that those will also need to be taken into account when propagating inheritable ACEs to further descendants.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ACLエディタなどのクライアントアプリケーションは、そのディレクトリの子孫を再帰的にたどり、ACE4_INHERITED_ACEフラグを持つACEを削除し、それらを新しい継承可能なACEで置き換える（また、 ACE4_INHERITED_ACEフラグセット）。伝搬するACEを決定する明白な方法で、既存のACE継承フラグを使用します。 （ディレクトリ階層を降順するときに、さらに継承可能なACEが発生する可能性があること、および継承可能なACEを他の子孫に伝播するときにそれらも考慮する必要があることに注意してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reach of this propagation may be limited in two ways: first, automatic inheritance is not performed from any directory ACL that has the ACL4_AUTO_INHERIT flag cleared; and second, automatic inheritance stops wherever an ACL with the ACL4_PROTECTED flag is set, preventing modification of that ACL and also (if the ACL is set on a directory) of the ACL on any of the object&#39;s descendants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この伝播の範囲は2つの方法で制限される可能性があります。1つ目は、ACL4_AUTO_INHERITフラグがクリアされているディレクトリACLからの自動継承は実行されません。 2番目に、ACL4_PROTECTEDフラグが設定されたACLが設定されると自動継承が停止し、そのACLの変更と、ACLがディレクトリに設定されている場合はオブジェクトの子孫のACLが変更されなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This propagation is performed independently for the sacl and the dacl attributes; thus, the ACL4_AUTO_INHERIT and ACL4_PROTECTED flags may be independently set for the sacl and the dacl, and propagation of one type of acl may continue down a hierarchy even where propagation of the other acl has stopped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この伝播は、sacl属性とdacl属性に対して独立して実行されます。したがって、ACL4_AUTO_INHERITフラグとACL4_PROTECTEDフラグはsaclとdaclに個別に設定でき、あるタイプのaclの伝播は、他のaclの伝播が停止している場合でも、階層を下って続行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
New objects should be created with a dacl and a sacl that both have the ACL4_PROTECTED flag cleared and the ACL4_AUTO_INHERIT flag set to the same value as that on, respectively, the sacl or dacl of the parent object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
New objects should be created with a dacl and a sacl that both have the ACL4_PROTECTED flag cleared and the ACL4_AUTO_INHERIT flag set to the same value as that on, respectively, the sacl or dacl of the parent object.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both the dacl and sacl attributes are RECOMMENDED, and a server may support one without supporting the other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
dacl属性とsacl属性の両方が推奨され、サーバーは、一方をサポートせずに他方をサポートする場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that supports both the old acl attribute and one or both of the new dacl or sacl attributes must do so in such a way as to keep all three attributes consistent with each other. Thus, the ACEs reported in the acl attribute should be the union of the ACEs reported in the dacl and sacl attributes, except that the ACE4_INHERITED_ACE flag must be cleared from the ACEs in the acl. And of course a client that queries only the acl will be unable to determine the values of the sacl or dacl flag fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that supports both the old acl attribute and one or both of the new dacl or sacl attributes must do so in such a way as to keep all three attributes consistent with each other. Thus, the ACEs reported in the acl attribute should be the union of the ACEs reported in the dacl and sacl attributes, except that the ACE4_INHERITED_ACE flag must be cleared from the ACEs in the acl. And of course a client that queries only the acl will be unable to determine the values of the sacl or dacl flag fields.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client performs a SETATTR for the acl attribute, the server SHOULD set the ACL4_PROTECTED flag to true on both the sacl and the dacl. By using the acl attribute, as opposed to the dacl or sacl attributes, the client signals that it may not understand automatic inheritance, and thus cannot be trusted to set an ACL for which automatic inheritance would make sense.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがacl属性のSETATTRを実行すると、サーバーはsaclとdaclの両方でACL4_PROTECTEDフラグをtrueに設定する必要があります（SHOULD）。 daclまたはsacl属性ではなく、acl属性を使用すると、クライアントは自動継承を理解できない可能性があり、自動継承が意味のあるACLの設定を信頼できないことを通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When a client application queries an ACL, modifies it, and sets it again, it should leave any ACEs marked with ACE4_INHERITED_ACE unchanged, in their original order, at the end of the ACL. If the application is unable to do this, it should set the ACL4_PROTECTED flag. This behavior is not enforced by servers, but violations of this rule may lead to unexpected results when applications perform automatic inheritance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントアプリケーションがACLをクエリして変更し、再度設定すると、ACLの最後にあるACE4_INHERITED_ACEでマークされたACEが元の順序で変更されないままになります。アプリケーションがこれを実行できない場合は、ACL4_PROTECTEDフラグを設定する必要があります。この動作はサーバーによって強制されませんが、このルールに違反すると、アプリケーションが自動継承を実行するときに予期しない結果が生じる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server also supports the mode attribute, it SHOULD set the mode in such a way that leaves inherited ACEs unchanged, in their original order, at the end of the ACL. If it is unable to do so, it SHOULD set the ACL4_PROTECTED flag on the file&#39;s dacl.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがモード属性もサポートしている場合は、継承されたACEを元の順序でACLの最後に変更しないようにモードを設定する必要があります（SHOULD）。それができない場合は、ファイルのdaclにACL4_PROTECTEDフラグを設定する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, in the case where the request that creates a new file or directory does not also set permissions for that file or directory, and there are also no ACEs to inherit from the parent&#39;s directory, then the server&#39;s choice of ACL for the new object is implementation-dependent. In this case, the server SHOULD set the ACL4_DEFAULTED flag on the ACL it chooses for the new object. An application performing automatic inheritance takes the ACL4_DEFAULTED flag as a sign that the ACL should be completely replaced by one generated using the automatic inheritance rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、新しいファイルまたはディレクトリを作成するリクエストがそのファイルまたはディレクトリのアクセス許可も設定せず、親のディレクトリから継承するACEもない場合、新しいオブジェクトに対するサーバーのACLの選択は次のとおりです。実装依存。この場合、サーバーは、新しいオブジェクト用に選択したACLにACL4_DEFAULTEDフラグを設定する必要があります（SHOULD）。自動継承を実行するアプリケーションは、ACLを、自動継承ルールを使用して生成されたものに完全に置き換える必要があるというサインとしてACL4_DEFAULTEDフラグを受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Single-Server-Namespace">
7. Single-Server Namespace
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 単一サーバー名前空間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the NFSv4 single-server namespace. Single-server namespaces may be presented directly to clients, or they may be used as a basis to form larger multi-server namespaces (e.g., site-wide or organization-wide) to be presented to clients, as described in Section 11.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、NFSv4単一サーバー名前空間について説明します。単一サーバーの名前空間は、クライアントに直接提示することも、セクション11で説明するように、クライアントに提示するより大きなマルチサーバーの名前空間（サイト全体や組織全体など）を形成するための基礎として使用することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1--Server-Exports">
7.1. Server Exports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. サーバーのエクスポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On a UNIX server, the namespace describes all the files reachable by pathnames under the root directory or &#34;/&#34;. On a Windows server, the namespace constitutes all the files on disks named by mapped disk letters. NFS server administrators rarely make the entire server&#39;s file system namespace available to NFS clients. More often, portions of the namespace are made available via an &#34;export&#34; feature. In previous versions of the NFS protocol, the root filehandle for each export is obtained through the MOUNT protocol; the client sent a string that identified the export name within the namespace and the server returned the root filehandle for that export. The MOUNT protocol also provided an EXPORTS procedure that enumerated the server&#39;s exports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIXサーバーでは、ネームスペースは、ルートディレクトリまたは「/」の下のパス名によって到達可能なすべてのファイルを記述します。 Windowsサーバーでは、名前空間は、マップされたディスク文字で名前が付けられたディスク上のすべてのファイルを構成します。 NFSサーバー管理者がサーバーのファイルシステム全体の名前空間をNFSクライアントが利用できるようにすることはほとんどありません。多くの場合、名前空間の一部は、「エクスポート」機能を介して利用可能になります。以前のバージョンのNFSプロトコルでは、各エクスポートのルートファイルハンドルはMOUNTプロトコルを介して取得されました。クライアントは名前空間内のエクスポート名を識別する文字列を送信し、サーバーはそのエクスポートのルートファイルハンドルを返しました。 MOUNTプロトコルは、サーバーのエクスポートを列挙するEXPORTSプロシージャも提供しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-2--Browsing-Exports">
7.2. Browsing Exports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. エクスポートの閲覧
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The NFSv4.1 protocol provides a root filehandle that clients can use to obtain filehandles for the exports of a particular server, via a series of LOOKUP operations within a COMPOUND, to traverse a path. A common user experience is to use a graphical user interface (perhaps a file &#34;Open&#34; dialog window) to find a file via progressive browsing through a directory tree. The client must be able to move from one export to another export via single-component, progressive LOOKUP operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFSv4.1プロトコルは、ルートファイルハンドルを提供します。クライアントは、COMPOUND内の一連のLOOKUP操作を介して、特定のサーバーのエクスポートのファイルハンドルを取得し、パスをトラバースできます。一般的なユーザーエクスペリエンスは、グラフィカルユーザーインターフェイス（おそらく「ファイルを開く」ダイアログウィンドウ）を使用して、ディレクトリツリーを順次参照してファイルを見つけることです。クライアントは、単一コンポーネントのプログレッシブLOOKUP操作を介して、あるエクスポートから別のエクスポートに移動できる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This style of browsing is not well supported by the NFSv3 protocol. In NFSv3, the client expects all LOOKUP operations to remain within a single server file system. For example, the device attribute will not change. This prevents a client from taking namespace paths that span exports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このスタイルのブラウジングは、NFSv3プロトコルでは十分にサポートされていません。 NFSv3では、クライアントはすべてのLOOKUP操作が単一のサーバーファイルシステム内に留まることを期待しています。たとえば、デバイス属性は変更されません。これにより、クライアントは、複数のエクスポートにまたがる名前空間パスを取得できなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of NFSv3, an automounter on the client can obtain a snapshot of the server&#39;s namespace using the EXPORTS procedure of the MOUNT protocol. If it understands the server&#39;s pathname syntax, it can create an image of the server&#39;s namespace on the client. The parts of the namespace that are not exported by the server are filled in with directories that might be constructed similarly to an NFSv4.1 &#34;pseudo file system&#34; (see Section 7.3) that allows the user to browse from one mounted file system to another. There is a drawback to this representation of the server&#39;s namespace on the client: it is static. If the server administrator adds a new export, the client will be unaware of it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv3の場合、クライアントのオートマウンタは、MOUNTプロトコルのEXPORTSプロシージャを使用して、サーバーのネームスペースのスナップショットを取得できます。サーバーのパス名構文を理解していれば、クライアント上にサーバーの名前空間のイメージを作成できます。サーバーによってエクスポートされない名前空間の部分は、ユーザーが1つのマウントされたファイルシステムから別のファイルシステムに閲覧できるようにするNFSv4.1「疑似ファイルシステム」（セクション7.3を参照）と同様に構築されるディレクトリで埋められます。クライアント上のサーバーの名前空間のこの表現には欠点があります。それは静的なものです。サーバー管理者が新しいエクスポートを追加しても、クライアントはそれを認識しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-3--Server-Pseudo-File-System">
7.3. Server Pseudo File System
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. サーバー疑似ファイルシステム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 servers avoid this namespace inconsistency by presenting all the exports for a given server within the framework of a single namespace for that server. An NFSv4.1 client uses LOOKUP and READDIR operations to browse seamlessly from one export to another.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1サーバーは、特定のサーバーのすべてのエクスポートを、そのサーバーの単一の名前空間のフレームワーク内に提示することにより、この名前空間の不整合を回避します。 NFSv4.1クライアントは、LOOKUPおよびREADDIR操作を使用して、1つのエクスポートから別のエクスポートへシームレスにブラウズします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where there are portions of the server namespace that are not exported, clients require some way of traversing those portions to reach actual exported file systems. A technique that servers may use to provide for this is to bridge the unexported portion of the namespace via a &#34;pseudo file system&#34; that provides a view of exported directories only. A pseudo file system has a unique fsid and behaves like a normal, read-only file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エクスポートされていないサーバー名前空間の部分がある場合、クライアントは、実際にエクスポートされたファイルシステムに到達するためにそれらの部分をトラバースする何らかの方法を必要とします。サーバーがこれを提供するために使用できる手法は、エクスポートされたディレクトリのみのビューを提供する「疑似ファイルシステム」を介して名前空間のエクスポートされていない部分をブリッジすることです。疑似ファイルシステムには固有のfsidがあり、通常の読み取り専用ファイルシステムのように動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the construction of the server&#39;s namespace, it is possible that multiple pseudo file systems may exist. For example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの名前空間の構成に基づいて、複数の疑似ファイルシステムが存在する可能性があります。例えば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /a              pseudo file system
           /a/b            real file system
           /a/b/c          pseudo file system
           /a/b/c/d        real file system
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the pseudo file systems is considered a separate entity and therefore MUST have its own fsid, unique among all the fsids for that server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各疑似ファイルシステムは個別のエンティティと見なされるため、そのサーバーのすべてのfsidの中で一意の独自のfsidを持っている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-4--Multiple-Roots">
7.4. Multiple Roots
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. 複数の根
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Certain operating environments are sometimes described as having &#34;multiple roots&#34;. In such environments, individual file systems are commonly represented by disk or volume names. NFSv4 servers for these platforms can construct a pseudo file system above these root names so that disk letters or volume names are simply directory names in the pseudo root.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定の動作環境は、「複数のルート」を持っていると説明されることがあります。このような環境では、個々のファイルシステムは通常、ディスクまたはボリュームの名前で表されます。これらのプラットフォームのNFSv4サーバーは、これらのルート名の上に疑似ファイルシステムを構築して、ディスク文字またはボリューム名が疑似ルート内の単なるディレクトリ名になるようにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-5--Filehandle-Volatility">
7.5. Filehandle Volatility
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. ファイルハンドルのボラティリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nature of the server&#39;s pseudo file system is that it is a logical representation of file system(s) available from the server. Therefore, the pseudo file system is most likely constructed dynamically when the server is first instantiated. It is expected that the pseudo file system may not have an on-disk counterpart from which persistent filehandles could be constructed. Even though it is preferable that the server provide persistent filehandles for the pseudo file system, the NFS client should expect that pseudo file system filehandles are volatile. This can be confirmed by checking the associated &#34;fh_expire_type&#34; attribute for those filehandles in question. If the filehandles are volatile, the NFS client must be prepared to recover a filehandle value (e.g., with a series of LOOKUP operations) when receiving an error of NFS4ERR_FHEXPIRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの疑似ファイルシステムの性質は、サーバーから利用可能なファイルシステムの論理表現であるということです。したがって、サーバーが最初にインスタンス化されるときに、疑似ファイルシステムが動的に構築される可能性が最も高くなります。疑似ファイルシステムには、永続的なファイルハンドルを構築できるディスク上の対応物がない可能性があります。サーバーが疑似ファイルシステムに永続的なファイルハンドルを提供することが望ましい場合でも、NFSクライアントは疑似ファイルシステムファイルハンドルが揮発性であることを期待する必要があります。これは、問題のファイルハンドルの関連する「fh_expire_type」属性を確認することで確認できます。ファイルハンドルが揮発性である場合、NFS4ERR_FHEXPIREDのエラーを受信したときに、ファイルハンドル値を回復するために（たとえば、一連のLOOKUP操作を使用して）NFSクライアントを準備する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because it is quite likely that servers will implement pseudo file systems using volatile filehandles, clients need to be prepared for them, rather than assuming that all filehandles will be persistent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは揮発性ファイルハンドルを使用して疑似ファイルシステムを実装する可能性が非常に高いため、クライアントはすべてのファイルハンドルが永続的であると想定するのではなく、それらのために準備する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-6--Exported-Root">
7.6. Exported Root
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6. エクスポートされたルート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server&#39;s root file system is exported, one might conclude that a pseudo file system is unneeded. This is not necessarily so. Assume the following file systems on a server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのルートファイルシステムがエクスポートされた場合、疑似ファイルシステムは不要であると結論付けることができます。これは必ずしもそうではありません。サーバー上の次のファイルシステムを想定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /       fs1  (exported)
           /a      fs2  (not exported)
           /a/b    fs3  (exported)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because fs2 is not exported, fs3 cannot be reached with simple LOOKUPs. The server must bridge the gap with a pseudo file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs2はエクスポートされないため、単純なLOOKUPではfs3に到達できません。サーバーは、疑似ファイルシステムとのギャップを埋める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-7--Mount-Point-Crossing">
7.7. Mount Point Crossing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7. マウントポイントクロッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server file system environment may be constructed in such a way that one file system contains a directory that is &#39;covered&#39; or mounted upon by a second file system. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server file system environment may be constructed in such a way that one file system contains a directory that is &#39;covered&#39; or mounted upon by a second file system. For example:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /a/b            (file system 1)
           /a/b/c/d        (file system 2)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pseudo file system for this server may be constructed to look like:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このサーバーの疑似ファイルシステムは、次のように構築できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /               (place holder/not exported)
           /a/b            (file system 1)
           /a/b/c/d        (file system 2)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is the server&#39;s responsibility to present the pseudo file system that is complete to the client. If the client sends a LOOKUP request for the path /a/b/c/d, the server&#39;s response is the filehandle of the root of the file system /a/b/c/d. In previous versions of the NFS protocol, the server would respond with the filehandle of directory /a/b/c/d within the file system /a/b.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完全な疑似ファイルシステムをクライアントに提示するのはサーバーの責任です。クライアントがパス/ a / b / c / dのLOOKUP要求を送信する場合、サーバーの応答はファイルシステム/ a / b / c / dのルートのファイルハンドルです。以前のバージョンのNFSプロトコルでは、サーバーはファイルシステム/ a / b内のディレクトリ/ a / b / c / dのファイルハンドルで応答しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS client will be able to determine if it crosses a server mount point by a change in the value of the &#34;fsid&#34; attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSクライアントは、「fsid」属性の値を変更することで、サーバーのマウントポイントを通過するかどうかを判別できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-8--Security-Policy-and-Namespace-Presentation">
7.8. Security Policy and Namespace Presentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.8. セキュリティポリシーと名前空間の表示
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because NFSv4 clients possess the ability to change the security mechanisms used, after determining what is allowed, by using SECINFO and SECINFO_NONAME, the server SHOULD NOT present a different view of the namespace based on the security mechanism being used by a client. Instead, it should present a consistent view and return NFS4ERR_WRONGSEC if an attempt is made to access data with an inappropriate security mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4クライアントは、SECINFOおよびSECINFO_NONAMEを使用して許可されるものを決定した後、使用されるセキュリティメカニズムを変更する機能を持っているため、クライアントは、クライアントが使用しているセキュリティメカニズムに基づいてネームスペースの異なるビューを提示しないでください。代わりに、ビューに一貫性があり、不適切なセキュリティメカニズムでデータにアクセスしようとした場合は、NFS4ERR_WRONGSECを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If security considerations make it necessary to hide the existence of a particular file system, as opposed to all of the data within it, the server can apply the security policy of a shared resource in the server&#39;s namespace to components of the resource&#39;s ancestors. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティ上の考慮事項により、特定のファイルシステムの存在を、その中のすべてのデータではなく非表示にする必要がある場合、サーバーはサーバーの名前空間にある共有リソースのセキュリティポリシーをリソースの祖先のコンポーネントに適用できます。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /                           (place holder/not exported)
           /a/b                        (file system 1)
           /a/b/MySecretProject        (file system 2)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The /a/b/MySecretProject directory is a real file system and is the shared resource. Suppose the security policy for /a/b/ MySecretProject is Kerberos with integrity and it is desired to limit knowledge of the existence of this file system. In this case, the server should apply the same security policy to /a/b. This allows for knowledge of the existence of a file system to be secured when desirable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
/ a / b / MySecretProjectディレクトリは実際のファイルシステムであり、共有リソースです。 / a / b / MySecretProjectのセキュリティポリシーが整合性のあるKerberosであり、このファイルシステムの存在に関する知識を制限することが望ましいと仮定します。この場合、サーバーは同じセキュリティポリシーを/ a / bに適用する必要があります。これにより、必要に応じて、ファイルシステムの存在に関する情報を保護できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the case of the use of multiple, disjoint security mechanisms in the server&#39;s resources, applying that sort of policy would result in the higher-level file system not being accessible using any security flavor. Therefore, that sort of configuration is not compatible with hiding the existence (as opposed to the contents) from clients using multiple disjoint sets of security flavors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのリソースで複数の分離したセキュリティメカニズムを使用する場合、そのようなポリシーを適用すると、セキュリティフレーバーを使用して上位レベルのファイルシステムにアクセスできなくなります。したがって、この種の構成は、セキュリティフレーバーのばらばらのセットを複数使用してクライアントから（コンテンツではなく）存在を隠すことと互換性がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In other circumstances, a desirable policy is for the security of a particular object in the server&#39;s namespace to include the union of all security mechanisms of all direct descendants. A common and convenient practice, unless strong security requirements dictate otherwise, is to make the entire the pseudo file system accessible by all of the valid security mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他の状況では、望ましいポリシーは、サーバーの名前空間内の特定のオブジェクトのセキュリティに、すべての直接の子孫のすべてのセキュリティメカニズムの結合を含めることです。強力なセキュリティ要件で特に指示されていない限り、一般的で便利な方法は、有効なセキュリティメカニズムすべてから疑似ファイルシステム全体にアクセスできるようにすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where there is concern about the security of data on the network, clients should use strong security mechanisms to access the pseudo file system in order to prevent man-in-the-middle attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワーク上のデータのセキュリティについて懸念がある場合、クライアントは中間者攻撃を防ぐために、強力なセキュリティメカニズムを使用して疑似ファイルシステムにアクセスする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--State-Management">
8. State Management
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 国家管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Integrating locking into the NFS protocol necessarily causes it to be stateful. With the inclusion of such features as share reservations, file and directory delegations, recallable layouts, and support for mandatory byte-range locking, the protocol becomes substantially more dependent on proper management of state than the traditional combination of NFS and NLM (Network Lock Manager) [46]. These features include expanded locking facilities, which provide some measure of inter-client exclusion, but the state also offers features not readily providable using a stateless model. There are three components to making this state manageable:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックをNFSプロトコルに統合すると、必然的にそれがステートフルになります。共有の予約、ファイルとディレクトリの委任、再呼び出し可能なレイアウト、必須のバイト範囲ロックのサポートなどの機能が組み込まれているため、プロトコルは、NFSとNLM（ネットワークロックマネージャー）の従来の組み合わせよりも、状態の適切な管理に大きく依存します。 ）[46]。これらの機能には、拡張されたロック機能が含まれ、クライアント間の除外をある程度提供しますが、状態には、ステートレスモデルを使用して容易に提供できない機能もあります。この状態を管理可能にするための3つのコンポーネントがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o clear division between client and server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントとサーバーの明確な区別
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ability to reliably detect inconsistency in state between client and server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントとサーバー間の状態の不整合を確実に検出する機能
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o simple and robust recovery mechanisms In this model, the server owns the state information. The client requests changes in locks and the server responds with the changes made. Non-client-initiated changes in locking state are infrequent. The client receives prompt notification of such changes and can adjust its view of the locking state to reflect the server&#39;s changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
oシンプルで堅牢な回復メカニズムこのモデルでは、サーバーが状態情報を所有しています。クライアントはロックの変更を要求し、サーバーは行われた変更で応答します。クライアントが開始しないロック状態の変更はまれです。クライアントは、そのような変更のプロンプト通知を受け取り、サーバーの変更を反映するようにロック状態のビューを調整できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Individual pieces of state created by the server and passed to the client at its request are represented by 128-bit stateids. These stateids may represent a particular open file, a set of byte-range locks held by a particular owner, or a recallable delegation of privileges to access a file in particular ways or at a particular location.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーによって作成され、要求時にクライアントに渡される個々の状態は、128ビットの状態IDで表されます。これらの状態IDは、特定の開いているファイル、特定の所有者が保持しているバイト範囲のロックのセット、または特定の方法または特定の場所でファイルにアクセスするための呼び出し可能な特権の委任を表す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In all cases, there is a transition from the most general information that represents a client as a whole to the eventual lightweight stateid used for most client and server locking interactions. The details of this transition will vary with the type of object but it always starts with a client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての場合において、クライアント全体を表す最も一般的な情報から、ほとんどのクライアントとサーバーのロック相互作用に使用される最終的な軽量のステートIDへの移行があります。この遷移の詳細はオブジェクトのタイプによって異なりますが、常にクライアントIDから始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1--Client-and-Session-ID">
8.1. Client and Session ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. クライアントとセッションID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client must establish a client ID (see Section 2.4) and then one or more sessionids (see Section 2.10) before performing any operations to open, byte-range lock, delegate, or obtain a layout for a file object. Each session ID is associated with a specific client ID, and thus serves as a shorthand reference to an NFSv4.1 client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client must establish a client ID (see Section 2.4) and then one or more sessionids (see Section 2.10) before performing any operations to open, byte-range lock, delegate, or obtain a layout for a file object. Each session ID is associated with a specific client ID, and thus serves as a shorthand reference to an NFSv4.1 client.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For some types of locking interactions, the client will represent some number of internal locking entities called &#34;owners&#34;, which normally correspond to processes internal to the client. For other types of locking-related objects, such as delegations and layouts, no such intermediate entities are provided for, and the locking-related objects are considered to be transferred directly between the server and a unitary client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のタイプのロック相互作用では、クライアントは「所有者」と呼ばれるいくつかの内部ロックエンティティを表します。これは通常、クライアント内部のプロセスに対応します。委任やレイアウトなどの他のタイプのロック関連オブジェクトの場合、そのような中間エンティティは提供されず、ロック関連オブジェクトはサーバーと単一のクライアントの間で直接転送されると見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2--Stateid-Definition">
8.2. Stateid Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Stateidの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When the server grants a lock of any type (including opens, byte-range locks, delegations, and layouts), it responds with a unique stateid that represents a set of locks (often a single lock) for the same file, of the same type, and sharing the same ownership characteristics. Thus, opens of the same file by different open-owners each have an identifying stateid. Similarly, each set of byte-range locks on a file owned by a specific lock-owner has its own identifying stateid. Delegations and layouts also have associated stateids by which they may be referenced. The stateid is used as a shorthand reference to a lock or set of locks, and given a stateid, the server can determine the associated state-owner or state-owners (in the case of an open-owner/lock-owner pair) and the associated filehandle. When stateids are used, the current filehandle must be the one associated with that stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーが任意のタイプのロック（オープン、バイト範囲ロック、委任、およびレイアウトを含む）を許可すると、同じファイルの同じロックのセット（多くの場合、単一のロック）を表す一意のstateidで応答します。タイプ、および同じ所有権特性を共有します。したがって、異なるオープンオーナーによる同じファイルのオープンには、それぞれ識別状態IDがあります。同様に、特定のロック所有者が所有するファイルのバイト範囲ロックの各セットには、独自の識別状態IDがあります。委任とレイアウトには、それらを参照できるように関連付けられた状態IDもあります。状態IDは、ロックまたはロックのセットへの省略参照として使用され、状態IDが与えられると、サーバーは関連する状態所有者または状態所有者（オープン所有者/ロック所有者のペアの場合）および関連するファイルハンドル。状態IDを使用する場合、現在のファイルハンドルは、その状態IDに関連付けられているものでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All stateids associated with a given client ID are associated with a common lease that represents the claim of those stateids and the objects they represent to be maintained by the server. See Section 8.3 for a discussion of the lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のクライアントIDに関連付けられているすべての状態IDは、それらの状態IDとサーバーが維持するためにそれらが表すオブジェクトの主張を表す共通リースに関連付けられています。リースの説明については、セクション8.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server may assign stateids independently for different clients. A stateid with the same bit pattern for one client may designate an entirely different set of locks for a different client. The stateid is always interpreted with respect to the client ID associated with the current session. Stateids apply to all sessions associated with the given client ID, and the client may use a stateid obtained from one session on another session associated with the same client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、さまざまなクライアントに独立して状態IDを割り当てることができます。 1つのクライアントに対して同じビットパターンを持つ状態IDは、異なるクライアントに対してまったく異なるロックのセットを指定する場合があります。 stateidは常に、現在のセッションに関連付けられているクライアントIDに関して解釈されます。 Stateidは特定のクライアントIDに関連付けられたすべてのセッションに適用され、クライアントは、同じクライアントIDに関連付けられた別のセッションで1つのセッションから取得したStateidを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2-1--Stateid-Types">
8.2.1. Stateid Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.1. Stateidタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the exception of special stateids (see Section 8.2.3), each stateid represents locking objects of one of a set of types defined by the NFSv4.1 protocol. Note that in all these cases, where we speak of guarantee, it is understood there are situations such as a client restart, or lock revocation, that allow the guarantee to be voided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特別な状態ID（セクション8.2.3を参照）を除いて、各状態IDは、NFSv4.1プロトコルで定義されているタイプのセットの1つであるロックオブジェクトを表します。保証について述べるこれらすべてのケースでは、クライアントの再起動やロックの取り消しなど、保証を無効にできる状況があることを理解してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stateids may represent opens of files.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stateidはファイルのオープンを表す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Each stateid in this case represents the OPEN state for a given client ID/open-owner/filehandle triple. Such stateids are subject to change (with consequent incrementing of the stateid&#39;s seqid) in response to OPENs that result in upgrade and OPEN_DOWNGRADE operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この場合の各stateidは、特定のクライアントID / open-owner / filehandleトリプルのOPEN状態を表します。このような状態IDは、アップグレードとOPEN_DOWNGRADE操作を引き起こすOPENに応じて、変更（状態IDのseqidが増加する）の影響を受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stateids may represent sets of byte-range locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stateidは、一連のバイト範囲ロックを表す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
All locks held on a particular file by a particular owner and gotten under the aegis of a particular open file are associated with a single stateid with the seqid being incremented whenever LOCK and LOCKU operations affect that set of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
特定の所有者によって特定のファイルに保持され、特定の開いているファイルの管理下で取得されたすべてのロックは、LOCKおよびLOCKU操作が一連のロックに影響を与えるたびにseqidが増分される単一の状態IDに関連付けられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stateids may represent file delegations, which are recallable guarantees by the server to the client that other clients will not reference or modify a particular file, until the delegation is returned. In NFSv4.1, file delegations may be obtained on both regular and non-regular files.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stateidはファイル委任を表す場合があります。これは、委任が返されるまで、他のクライアントが特定のファイルを参照または変更しないことをサーバーがクライアントに呼び戻す保証です。 NFSv4.1では、ファイルの委任は通常のファイルと通常でないファイルの両方で取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A stateid represents a single delegation held by a client for a particular filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
stateidは、特定のファイルハンドルに対してクライアントが保持する単一の委任を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stateids may represent directory delegations, which are recallable guarantees by the server to the client that other clients will not modify the directory, until the delegation is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stateids may represent directory delegations, which are recallable guarantees by the server to the client that other clients will not modify the directory, until the delegation is returned.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A stateid represents a single delegation held by a client for a particular directory filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
状態IDは、特定のディレクトリファイルハンドルに対してクライアントが保持する単一の委任を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stateids may represent layouts, which are recallable guarantees by the server to the client that particular files may be accessed via an alternate data access protocol at specific locations. Such access is limited to particular sets of byte-ranges and may proceed until those byte-ranges are reduced or the layout is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stateids may represent layouts, which are recallable guarantees by the server to the client that particular files may be accessed via an alternate data access protocol at specific locations. Such access is limited to particular sets of byte-ranges and may proceed until those byte-ranges are reduced or the layout is returned.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A stateid represents the set of all layouts held by a particular client for a particular filehandle with a given layout type. The seqid is updated as the layouts of that set of byte-ranges change, via layout stateid changing operations such as LAYOUTGET and LAYOUTRETURN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
状態IDは、特定のレイアウトタイプの特定のファイルハンドルに対して特定のクライアントが保持するすべてのレイアウトのセットを表します。 seqidは、LAYOUTGETやLAYOUTRETURNなどのレイアウト状態ID変更操作によって、そのバイト範囲のセットのレイアウトが変更されると更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2-2--Stateid-Structure">
8.2.2. Stateid Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.2. Stateid構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateids are divided into two fields, a 96-bit &#34;other&#34; field identifying the specific set of locks and a 32-bit &#34;seqid&#34; sequence value. Except in the case of special stateids (see Section 8.2.3), a particular value of the &#34;other&#34; field denotes a set of locks of the same type (for example, byte-range locks, opens, delegations, or layouts), for a specific file or directory, and sharing the same ownership characteristics. The seqid designates a specific instance of such a set of locks, and is incremented to indicate changes in such a set of locks, either by the addition or deletion of locks from the set, a change in the byte-range they apply to, or an upgrade or downgrade in the type of one or more locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateidは、特定のロックセットを識別する96ビットの「その他」フィールドと、32ビットの「seqid」シーケンス値の2つのフィールドに分かれています。特別な状態ID（セクション8.2.3を参照）の場合を除いて、「その他」フィールドの特定の値は、同じタイプのロックのセットを示します（たとえば、バイト範囲ロック、オープン、委任、またはレイアウト）。特定のファイルまたはディレクトリについて、同じ所有権特性を共有します。 seqidは、そのようなロックのセットの特定のインスタンスを示し、そのセットのロックの追加または削除、それらが適用されるバイト範囲の変更のいずれかによる、そのようなロックのセットの変更を示すために増分されます。 1つ以上のロックのタイプでのアップグレードまたはダウングレード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When such a set of locks is first created, the server returns a stateid with seqid value of one. On subsequent operations that modify the set of locks, the server is required to increment the &#34;seqid&#34; field by one whenever it returns a stateid for the same state-owner/file/type combination and there is some change in the set of locks actually designated. In this case, the server will return a stateid with an &#34;other&#34; field the same as previously used for that state-owner/file/type combination, with an incremented &#34;seqid&#34; field. This pattern continues until the seqid is incremented past NFS4_UINT32_MAX, and one (not zero) is the next seqid value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのようなロックのセットが最初に作成されると、サーバーはseqid値が1のstateidを返します。ロックのセットを変更する後続の操作では、サーバーは、同じ状態所有者/ファイル/タイプの組み合わせのstateidを返し、実際にロックのセットにいくつかの変更がある場合は常に、「seqid」フィールドを1つ増やす必要があります。専用。この場合、サーバーは、以前はその状態所有者/ファイル/タイプの組み合わせに使用されていたのと同じ「その他」フィールドと、増分された「seqid」フィールドを持つ「stateid」を返します。このパターンは、seqidがNFS4_UINT32_MAXを超えて増分され、1（ゼロではない）が次のseqid値になるまで続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of the incrementing of the seqid is to allow the server to communicate to the client the order in which operations that modified locking state associated with a stateid have been processed and to make it possible for the client to send requests that are conditional on the set of locks not having changed since the stateid in question was returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
seqidの増分の目的は、stateidに関連付けられたロック状態を変更した操作が処理された順序をサーバーがクライアントに通信できるようにし、クライアントが条件付きの要求を送信できるようにすることです問題の状態IDが返されてから変更されていないロックのセット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Except for layout stateids (Section 12.5.3), when a client sends a stateid to the server, it has two choices with regard to the seqid sent. It may set the seqid to zero to indicate to the server that it wishes the most up-to-date seqid for that stateid&#39;s &#34;other&#34; field to be used. This would be the common choice in the case of a stateid sent with a READ or WRITE operation. It also may set a non-zero value, in which case the server checks if that seqid is the correct one. In that case, the server is required to return NFS4ERR_OLD_STATEID if the seqid is lower than the most current value and NFS4ERR_BAD_STATEID if the seqid is greater than the most current value. This would be the common choice in the case of stateids sent with a CLOSE or OPEN_DOWNGRADE. Because OPENs may be sent in parallel for the same owner, a client might close a file without knowing that an OPEN upgrade had been done by the server, changing the lock in question. If CLOSE were sent with a zero seqid, the OPEN upgrade would be cancelled before the client even received an indication that an upgrade had happened.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウト状態ID（セクション12.5.3）を除き、クライアントが状態IDをサーバーに送信する場合、送信されるseqidに関して2つの選択肢があります。これは、seqidをゼロに設定して、そのstateidの「その他の」フィールドの最新のseqidを使用することをサーバーに示すことを示します。これは、READまたはWRITE操作で送信された状態IDの場合の一般的な選択です。また、ゼロ以外の値を設定する場合もあります。その場合、サーバーはそのseqidが正しいかどうかを確認します。その場合、サーバーは、seqidが最新の値よりも小さい場合はNFS4ERR_OLD_STATEIDを返し、seqidが最新の値よりも大きい場合はNFS4ERR_BAD_STATEIDを返す必要があります。これは、CLOSEまたはOPEN_DOWNGRADEで送信された状態IDの場合の一般的な選択です。 OPENは同じ所有者に対して並行して送信される可能性があるため、サーバーによってOPENアップグレードが実行されたことを知らずにクライアントがファイルを閉じ、問題のロックを変更する可能性があります。ゼロがseqidでCLOSEが送信された場合、クライアントがアップグレードが発生したという指示を受け取る前に、OPENアップグレードがキャンセルされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a stateid is sent by the server to the client as part of a callback operation, it is not subject to checking for a current seqid and returning NFS4ERR_OLD_STATEID. This is because the client is not in a position to know the most up-to-date seqid and thus cannot verify it. Unless specially noted, the seqid value for a stateid sent by the server to the client as part of a callback is required to be zero with NFS4ERR_BAD_STATEID returned if it is not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コールバック操作の一部として、stateidがサーバーからクライアントに送信される場合、現在のseqidをチェックしてNFS4ERR_OLD_STATEIDを返すことはありません。これは、クライアントが最新のseqidを知ることができないため、確認できないためです。特に明記されていない限り、コールバックの一部としてサーバーからクライアントに送信されたstateidのseqid値は、NFS4ERR_BAD_STATEIDがゼロでない場合に返される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In making comparisons between seqids, both by the client in determining the order of operations and by the server in determining whether the NFS4ERR_OLD_STATEID is to be returned, the possibility of the seqid being swapped around past the NFS4_UINT32_MAX value needs to be taken into account. When two seqid values are being compared, the total count of slots for all sessions associated with the current client is used to do this. When one seqid value is less than this total slot count and another seqid value is greater than NFS4_UINT32_MAX minus the total slot count, the former is to be treated as lower than the latter, despite the fact that it is numerically greater.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作の順序を決定するクライアントとNFS4ERR_OLD_STATEIDが返されるかどうかを決定するサーバーの両方でseqid間の比較を行う際には、seqidがNFS4_UINT32_MAX値を超えてスワップされる可能性を考慮する必要があります。 2つのseqid値が比較されている場合、現在のクライアントに関連付けられているすべてのセッションのスロットの総数がこれを行うために使用されます。 1つのseqid値がこの合計スロット数よりも少なく、別のseqid値がNFS4_UINT32_MAXから合計スロット数を引いた値よりも大きい場合、数値が大きいにもかかわらず、前者は後者よりも低いものとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2-3--Special-Stateids">
8.2.3. Special Stateids
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.3. 特別国家
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateid values whose &#34;other&#34; field is either all zeros or all ones are reserved. They may not be assigned by the server but have special meanings defined by the protocol. The particular meaning depends on whether the &#34;other&#34; field is all zeros or all ones and the specific value of the &#34;seqid&#34; field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「その他」フィールドがすべてゼロまたはすべて1であるStateid値は予約されています。これらはサーバーによって割り当てられない場合がありますが、プロトコルによって定義された特別な意味があります。特定の意味は、「その他」フィールドがすべて0かすべて1か、および「seqid」フィールドの特定の値によって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following combinations of &#34;other&#34; and &#34;seqid&#34; are defined in NFSv4.1:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1では、「その他」と「seqid」の次の組み合わせが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When &#34;other&#34; and &#34;seqid&#34; are both zero, the stateid is treated as a special anonymous stateid, which can be used in READ, WRITE, and SETATTR requests to indicate the absence of any OPEN state associated with the request. When an anonymous stateid value is used and an existing open denies the form of access requested, then access will be denied to the request. This stateid MUST NOT be used on operations to data servers (Section 13.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「other」と「seqid」の両方がゼロの場合、stateidは特別な匿名のstateidとして扱われ、READ、WRITE、およびSETATTR要求で使用して、要求に関連付けられたOPEN状態がないことを示すことができます。匿名のstateid値が使用され、既存のオープンが要求されたアクセスの形式を拒否した場合、要求へのアクセスは拒否されます。この状態IDは、データサーバーへの操作に使用してはなりません（セクション13.6）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When &#34;other&#34; and &#34;seqid&#34; are both all ones, the stateid is a special READ bypass stateid. When this value is used in WRITE or SETATTR, it is treated like the anonymous value. When used in READ, the server MAY grant access, even if access would normally be denied to READ operations. This stateid MUST NOT be used on operations to data servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「other」と「seqid」が両方とも1の場合、stateidは特別なREADバイパスstateidです。この値をWRITEまたはSETATTRで使用すると、匿名値のように扱われます。 READで使用すると、サーバーは通常READ操作へのアクセスが拒否される場合でも、アクセスを許可できます（MAY）。この状態IDは、データサーバーへの操作で使用してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When &#34;other&#34; is zero and &#34;seqid&#34; is one, the stateid represents the current stateid, which is whatever value is the last stateid returned by an operation within the COMPOUND. In the case of an OPEN, the stateid returned for the open file and not the delegation is used. The stateid passed to the operation in place of the special value has its &#34;seqid&#34; value set to zero, except when the current stateid is used by the operation CLOSE or OPEN_DOWNGRADE. If there is no operation in the COMPOUND that has returned a stateid value, the server MUST return the error NFS4ERR_BAD_STATEID. As illustrated in Figure 6, if the value of a current stateid is a special stateid and the stateid of an operation&#39;s arguments has &#34;other&#34; set to zero and &#34;seqid&#34; set to one, then the server MUST return the error NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「other」がゼロで「seqid」が1の場合、stateidは現在のstateidを表します。これは、COMPOUND内の操作によって返される最後のstateidの値です。 OPENの場合、委任ではなく、開いているファイルに対して返されるstateidが使用されます。特別な値の代わりに操作に渡される状態IDは、現在の状態IDが操作CLOSEまたはOPEN_DOWNGRADEによって使用される場合を除いて、「seqid」値がゼロに設定されます。 stateid値を返したCOMPOUNDに操作がない場合、サーバーはエラーNFS4ERR_BAD_STATEIDを返す必要があります。図6に示すように、現在の状態IDの値が特別な状態IDであり、操作の引数の状態IDの「その他」がゼロに設定され、「seqid」が1に設定されている場合、サーバーはエラーNFS4ERR_BAD_STATEIDを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When &#34;other&#34; is zero and &#34;seqid&#34; is NFS4_UINT32_MAX, the stateid represents a reserved stateid value defined to be invalid. When this stateid is used, the server MUST return the error NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「other」がゼロで「seqid」がNFS4_UINT32_MAXの場合、stateidは無効と定義された予約済みのstateid値を表します。このstateidを使用する場合、サーバーはエラーNFS4ERR_BAD_STATEIDを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a stateid value is used that has all zeros or all ones in the &#34;other&#34; field but does not match one of the cases above, the server MUST return the error NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「その他」フィールドにすべて0または1が含まれているが、上記のいずれのケースにも一致しないstateid値が使用されている場合、サーバーはエラーNFS4ERR_BAD_STATEIDを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Special stateids, unlike other stateids, are not associated with individual client IDs or filehandles and can be used with all valid client IDs and filehandles. In the case of a special stateid designating the current stateid, the current stateid value substituted for the special stateid is associated with a particular client ID and filehandle, and so, if it is used where the current filehandle does not match that associated with the current stateid, the operation to which the stateid is passed will return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Special stateids, unlike other stateids, are not associated with individual client IDs or filehandles and can be used with all valid client IDs and filehandles. In the case of a special stateid designating the current stateid, the current stateid value substituted for the special stateid is associated with a particular client ID and filehandle, and so, if it is used where the current filehandle does not match that associated with the current stateid, the operation to which the stateid is passed will return NFS4ERR_BAD_STATEID.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2-4--Stateid-Lifetime-and-Validation">
8.2.4. Stateid Lifetime and Validation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.4. Stateidのライフタイムと検証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateids must remain valid until either a client restart or a server restart or until the client returns all of the locks associated with the stateid by means of an operation such as CLOSE or DELEGRETURN. If the locks are lost due to revocation, as long as the client ID is valid, the stateid remains a valid designation of that revoked state until the client frees it by using FREE_STATEID. Stateids associated with byte-range locks are an exception. They remain valid even if a LOCKU frees all remaining locks, so long as the open file with which they are associated remains open, unless the client frees the stateids via the FREE_STATEID operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateidは、クライアントが再起動するかサーバーが再起動するか、クライアントがCLOSEやDELEGRETURNなどの操作によってstateidに関連付けられたすべてのロックを返すまで、有効なままである必要があります。取り消しによってロックが失われた場合、クライアントIDが有効である限り、クライアントがFREE_STATEIDを使用して解放するまで、stateidは取り消された状態の有効な指定のままです。バイト範囲ロックに関連付けられたステートIDは例外です。 LOCKUが残りのすべてのロックを解放しても、それらが関連付けられている開いているファイルが開いたままである限り、クライアントがFREE_STATEID操作によって状態IDを解放しない限り、それらは有効なままです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that there are situations in which the client&#39;s locks become invalid, without the client requesting they be returned. These include lease expiration and a number of forms of lock revocation within the lease period. It is important to note that in these situations, the stateid remains valid and the client can use it to determine the disposition of the associated lost locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのロックの返却を要求せずに、クライアントのロックが無効になる状況があることに注意してください。これには、リースの有効期限と、リース期間内のロックの取り消しのいくつかの形式が含まれます。これらの状況では、stateidは有効なままであり、クライアントはそれを使用して、関連付けられている失われたロックの性質を判断できることに注意することが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An &#34;other&#34; value must never be reused for a different purpose (i.e., different filehandle, owner, or type of locks) within the context of a single client ID. A server may retain the &#34;other&#34; value for the same purpose beyond the point where it may otherwise be freed, but if it does so, it must maintain &#34;seqid&#34; continuity with previous values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「その他」の値は、単一のクライアントIDのコンテキスト内で、異なる目的（つまり、異なるファイルハンドル、所有者、またはロックのタイプ）に再利用してはなりません。サーバーは、他の方法で解放される可能性があるポイントを超えて、同じ目的で「その他」の値を保持できますが、解放する場合は、以前の値との「連続」連続性を維持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One mechanism that may be used to satisfy the requirement that the server recognize invalid and out-of-date stateids is for the server to divide the &#34;other&#34; field of the stateid into two fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが無効で古い状態IDを認識するという要件を満たすために使用できるメカニズムの1つは、サーバーが状態IDの「その他」フィールドを2つのフィールドに分割することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o an index into a table of locking-state structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ロッキング状態構造のテーブルへのインデックス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a generation number that is incremented on each allocation of a table entry for a particular use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 特定の用途のためのテーブルエントリの割り当てごとに増分される世代番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
And then store in each table entry,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そして、各テーブルエントリに保存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the client ID with which the stateid is associated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o stateidが関連付けられているクライアントID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the current generation number for the (at most one) valid stateid sharing this index value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o このインデックス値を共有する（最大で1つの）有効な状態IDの現在の世代番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the filehandle of the file on which the locks are taken.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ロックが行われるファイルのファイルハンドル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o an indication of the type of stateid (open, byte-range lock, file delegation, directory delegation, layout).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o an indication of the type of stateid (open, byte-range lock, file delegation, directory delegation, layout).
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the last &#34;seqid&#34; value returned corresponding to the current &#34;other&#34; value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 現在の「その他」の値に対応して返された最後の「seqid」値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o an indication of the current status of the locks associated with this stateid, in particular, whether these have been revoked and if so, for what reason.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o このstateidに関連付けられているロックの現在のステータス、特にそれらが取り消されたかどうか、取り消されている場合は、その理由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With this information, an incoming stateid can be validated and the appropriate error returned when necessary. Special and non-special stateids are handled separately. (See Section 8.2.3 for a discussion of special stateids.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この情報を使用して、受信したstateidを検証し、必要に応じて適切なエラーを返すことができます。特殊および非特殊のステートIDは個別に処理されます。 （特別なステートIDの説明については、セクション8.2.3を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that stateids are implicitly qualified by the current client ID, as derived from the client ID associated with the current session. Note, however, that the semantics of the session will prevent stateids associated with a previous client or server instance from being analyzed by this procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のセッションに関連付けられているクライアントIDから導出されるように、stateidは現在のクライアントIDによって暗黙的に修飾されることに注意してください。ただし、セッションのセマンティクスにより、前のクライアントまたはサーバーインスタンスに関連付けられたステートIDがこの手順で分析されないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If server restart has resulted in an invalid client ID or a session ID that is invalid, SEQUENCE will return an error and the operation that takes a stateid as an argument will never be processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの再起動により無効なクライアントIDまたはセッションIDが無効になった場合、SEQUENCEはエラーを返し、stateidを引数として取る操作は処理されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there has been a server restart where there is a persistent session and all leased state has been lost, then the session in question will, although valid, be marked as dead, and any operation not satisfied by means of the reply cache will receive the error NFS4ERR_DEADSESSION, and thus not be processed as indicated below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
永続的なセッションが存在するサーバーの再起動があり、すべてのリース状態が失われた場合、問題のセッションは有効であるにもかかわらず、デッドとしてマークされ、応答キャッシュによって満たされない操作は、エラーNFS4ERR_DEADSESSIONのため、以下に示すように処理されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a stateid is being tested and the &#34;other&#34; field is all zeros or all ones, a check that the &#34;other&#34; and &#34;seqid&#34; fields match a defined combination for a special stateid is done and the results determined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態IDがテストされており、「その他」フィールドがすべてゼロまたはすべて1である場合、「その他」および「シーケンス」フィールドが特別な状態IDの定義された組み合わせと一致することのチェックが行われ、結果は次のように決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the &#34;other&#34; and &#34;seqid&#34; fields do not match a defined combination associated with a special stateid, the error NFS4ERR_BAD_STATEID is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「other」フィールドと「seqid」フィールドが特別な状態IDに関連付けられた定義済みの組み合わせと一致しない場合、エラーNFS4ERR_BAD_STATEIDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the special stateid is one designating the current stateid and there is a current stateid, then the current stateid is substituted for the special stateid and the checks appropriate to non-special stateids are performed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 特別な状態IDが現在の状態IDを指定するものであり、現在の状態IDがある場合、現在の状態IDが特別な状態IDに置き換えられ、特別でない状態IDに適切なチェックが実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the combination is valid in general but is not appropriate to the context in which the stateid is used (e.g., an all-zero stateid is used when an OPEN stateid is required in a LOCK operation), the error NFS4ERR_BAD_STATEID is also returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 組み合わせは一般的には有効ですが、stateidが使用されるコンテキストに適さない場合（たとえば、LOCK操作でOPEN stateidが必要なときにすべて0のstateidが使用される場合）、エラーNFS4ERR_BAD_STATEIDも返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Otherwise, the check is completed and the special stateid is accepted as valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o それ以外の場合、チェックは完了し、特別な状態IDが有効として受け入れられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a stateid is being tested, and the &#34;other&#34; field is neither all zeros nor all ones, the following procedure could be used to validate an incoming stateid and return an appropriate error, when necessary, assuming that the &#34;other&#34; field would be divided into a table index and an entry generation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態IDがテストされており、「その他」フィールドがすべて0でもすべて1でもない場合、次の手順を使用して、受信した状態IDを検証し、必要に応じて「その他」フィールドがテーブルインデックスとエントリ生成に分かれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the table index field is outside the range of the associated table, return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o テーブルインデックスフィールドが関連するテーブルの範囲外の場合は、NFS4ERR_BAD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the selected table entry is of a different generation than that specified in the incoming stateid, return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 選択されたテーブルエントリが、受信状態IDで指定された世代とは異なる世代である場合は、NFS4ERR_BAD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the selected table entry does not match the current filehandle, return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 選択したテーブルエントリが現在のファイルハンドルと一致しない場合は、NFS4ERR_BAD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the client ID in the table entry does not match the client ID associated with the current session, return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o テーブルエントリのクライアントIDが現在のセッションに関連付けられたクライアントIDと一致しない場合は、NFS4ERR_BAD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the stateid represents revoked state, then return NFS4ERR_EXPIRED, NFS4ERR_ADMIN_REVOKED, or NFS4ERR_DELEG_REVOKED, as appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o stateidが取り消された状態を表す場合は、NFS4ERR_EXPIRED、NFS4ERR_ADMIN_REVOKED、またはNFS4ERR_DELEG_REVOKEDを適宜返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the stateid type is not valid for the context in which the stateid appears, return NFS4ERR_BAD_STATEID. Note that a stateid may be valid in general, as would be reported by the TEST_STATEID operation, but be invalid for a particular operation, as, for example, when a stateid that doesn&#39;t represent byte-range locks is passed to the non-from_open case of LOCK or to LOCKU, or when a stateid that does not represent an open is passed to CLOSE or OPEN_DOWNGRADE. In such cases, the server MUST return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the stateid type is not valid for the context in which the stateid appears, return NFS4ERR_BAD_STATEID. Note that a stateid may be valid in general, as would be reported by the TEST_STATEID operation, but be invalid for a particular operation, as, for example, when a stateid that doesn&#39;t represent byte-range locks is passed to the non-from_open case of LOCK or to LOCKU, or when a stateid that does not represent an open is passed to CLOSE or OPEN_DOWNGRADE. In such cases, the server MUST return NFS4ERR_BAD_STATEID.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the &#34;seqid&#34; field is not zero and it is greater than the current sequence value corresponding to the current &#34;other&#34; field, return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「seqid」フィールドがゼロではなく、現在の「その他」フィールドに対応する現在のシーケンス値より大きい場合は、NFS4ERR_BAD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the &#34;seqid&#34; field is not zero and it is less than the current sequence value corresponding to the current &#34;other&#34; field, return NFS4ERR_OLD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「seqid」フィールドがゼロではなく、現在の「その他」フィールドに対応する現在のシーケンス値より小さい場合は、NFS4ERR_OLD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Otherwise, the stateid is valid and the table entry should contain any additional information about the type of stateid and information associated with that particular type of stateid, such as the associated set of locks, e.g., open-owner and lock-owner information, as well as information on the specific locks, e.g., open modes and byte-ranges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o それ以外の場合、stateidは有効であり、テーブルエントリには、stateidのタイプに関する追加情報と、特定のタイプのstateidに関連付けられた情報が含まれます。オープンモードやバイト範囲など、特定のロックに関する情報も含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2-5--Stateid-Use-for-IO-Operations">
8.2.5. Stateid Use for I/O Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.5. I / O操作のステートイド使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients performing I/O operations need to select an appropriate stateid based on the locks (including opens and delegations) held by the client and the various types of state-owners sending the I/O requests. SETATTR operations that change the file size are treated like I/O operations in this regard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I / O操作を実行するクライアントは、クライアントが保持するロック（オープンと委任を含む）とI / O要求を送信するさまざまなタイプの状態所有者に基づいて、適切な状態IDを選択する必要があります。ファイルサイズを変更するSETATTR操作は、この点でI / O操作と同様に扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following rules, applied in order of decreasing priority, govern the selection of the appropriate stateid. In following these rules, the client will only consider locks of which it has actually received notification by an appropriate operation response or callback. Note that the rules are slightly different in the case of I/O to data servers when file layouts are being used (see Section 13.9.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のルールは、優先度の高い順に適用され、適切なステートIDの選択を管理します。これらのルールに従うと、クライアントは、適切な操作応答またはコールバックによって実際に通知を受け取ったロックのみを考慮します。ファイルレイアウトが使用されている場合、データサーバーへのI / Oの場合、ルールは若干異なります（セクション13.9.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the client holds a delegation for the file in question, the delegation stateid SHOULD be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the client holds a delegation for the file in question, the delegation stateid SHOULD be used.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Otherwise, if the entity corresponding to the lock-owner (e.g., a process) sending the I/O has a byte-range lock stateid for the associated open file, then the byte-range lock stateid for that lock-owner and open file SHOULD be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o それ以外の場合、I / Oを送信するロック所有者（たとえば、プロセス）に対応するエンティティに、関連付けられたオープンファイルのバイト範囲ロック状態IDがある場合、そのロック所有者とオープンファイルのバイト範囲ロック状態ID使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If there is no byte-range lock stateid, then the OPEN stateid for the open file in question SHOULD be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイト範囲のロック状態IDがない場合は、問題の開いているファイルのOPEN状態IDを使用する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Finally, if none of the above apply, then a special stateid SHOULD be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Finally, if none of the above apply, then a special stateid SHOULD be used.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ignoring these rules may result in situations in which the server does not have information necessary to properly process the request. For example, when mandatory byte-range locks are in effect, if the stateid does not indicate the proper lock-owner, via a lock stateid, a request might be avoidably rejected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのルールを無視すると、リクエストを適切に処理するために必要な情報がサーバーにない場合があります。たとえば、必須のバイト範囲ロックが有効な場合、stateidがロックのstateidを介して適切なロック所有者を示さない場合、要求が拒否される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server however should not try to enforce these ordering rules and should use whatever information is available to properly process I/O requests. In particular, when a client has a delegation for a given file, it SHOULD take note of this fact in processing a request, even if it is sent with a special stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、サーバーはこれらの順序ルールを適用しようとせず、I / O要求を適切に処理するために利用可能な情報を使用する必要があります。特に、クライアントが特定のファイルの委任を持っている場合、特別な状態IDで送信された場合でも、要求を処理するときにこの事実に注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2-6--Stateid-Use-for-SETATTR-Operations">
8.2.6. Stateid Use for SETATTR Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.6. SETATTR操作のStateidの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because each operation is associated with a session ID and from that the clientid can be determined, operations do not need to include a stateid for the server to be able to determine whether they should cause a delegation to be recalled or are to be treated as done within the scope of the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各操作はセッションIDに関連付けられており、そこからclientidを決定できるため、サーバーが状態IDを含める必要はありません。これにより、サーバーは、委任を再呼び出しさせるか、または完了したものとして扱うかを決定できます。委任の範囲内。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of SETATTR operations, a stateid is present. In cases other than those that set the file size, the client may send either a special stateid or, when a delegation is held for the file in question, a delegation stateid. While the server SHOULD validate the stateid and may use the stateid to optimize the determination as to whether a delegation is held, it SHOULD note the presence of a delegation even when a special stateid is sent, and MUST accept a valid delegation stateid when sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTR操作の場合、stateidが存在します。ファイルサイズを設定したもの以外の場合、クライアントは特別な状態IDを送信するか、問題のファイルの委任が保持されている場合は委任状態IDを送信します。サーバーは、stateidを検証する必要があり、stateidを使用して委任が保持されているかどうかの判断を最適化できますが、特別なstateidが送信された場合でも委任の存在に注意し、送信時に有効な委任stateidを受け入れる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-3--Lease-Renewal">
8.3. Lease Renewal
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. リース更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each client/server pair, as represented by a client ID, has a single lease. The purpose of the lease is to allow the client to indicate to the server, in a low-overhead way, that it is active, and thus that the server is to retain the client&#39;s locks. This arrangement allows the server to remove stale locking-related objects that are held by a client that has crashed or is otherwise unreachable, once the relevant lease expires. This in turn allows other clients to obtain conflicting locks without being delayed indefinitely by inactive or unreachable clients. It is not a mechanism for cache consistency and lease renewals may not be denied if the lease interval has not expired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントIDで表される各クライアント/サーバーのペアには、単一のリースがあります。リースの目的は、クライアントが低オーバーヘッドの方法でサーバーにアクティブであること、したがってサーバーがクライアントのロックを保持することをサーバーに示すことを可能にすることです。この配置により、サーバーは、関連するリースの有効期限が切れると、クラッシュした、またはアクセスできないクライアントによって保持されている古いロック関連オブジェクトを削除できます。これにより、他のクライアントは、非アクティブまたは到達不能なクライアントによって無期限に遅延されることなく、競合するロックを取得できます。これはキャッシュの整合性のためのメカニズムではなく、リース間隔が満了していない場合、リースの更新が拒否されない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since each session is associated with a specific client (identified by the client&#39;s client ID), any operation sent on that session is an indication that the associated client is reachable. When a request is sent for a given session, successful execution of a SEQUENCE operation (or successful retrieval of the result of SEQUENCE from the reply cache) on an unexpired lease will result in the lease being implicitly renewed, for the standard renewal period (equal to the lease_time attribute).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各セッションは特定のクライアント（クライアントのクライアントIDで識別される）に関連付けられているため、そのセッションで送信された操作は、関連付けられたクライアントが到達可能であることを示しています。特定のセッションにリクエストが送信されると、期限が切れていないリースでSEQUENCE操作が正常に実行される（または応答キャッシュからSEQUENCEの結果が正常に取得される）と、標準の更新期間（等しいlease_time属性に）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client ID&#39;s lease has not expired when the server receives a SEQUENCE operation, then the server MUST renew the lease. If the client ID&#39;s lease has expired when the server receives a SEQUENCE operation, the server MAY renew the lease; this depends on whether any state was revoked as a result of the client&#39;s failure to renew the lease before expiration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがSEQUENCE操作を受信したときにクライアントIDのリースが期限切れになっていない場合、サーバーはリースを更新する必要があります。サーバーがSEQUENCE操作を受信したときにクライアントIDのリースの有効期限が切れている場合、サーバーはリースを更新できます。これは、有効期限が切れる前にリースを更新できなかったクライアントの結果として、状態が取り消されたかどうかによって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Absent other activity that would renew the lease, a COMPOUND consisting of a single SEQUENCE operation will suffice. The client should also take communication-related delays into account and take steps to ensure that the renewal messages actually reach the server in good time. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リースを更新する他のアクティビティがない場合、単一のSEQUENCE操作で構成されるCOMPOUNDで十分です。クライアントはまた、通信関連の遅延を考慮に入れ、更新メッセージが実際に適切なタイミングでサーバーに到達するようにするための措置を講じる必要があります。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When trunking is in effect, the client should consider sending multiple requests on different connections, in order to ensure that renewal occurs, even in the event of blockage in the path used for one of those connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o トランキングが有効な場合、クライアントは異なる接続で複数の要求を送信することを検討する必要があります。これにより、これらの接続の1つに使用されているパスがブロックされた場合でも、更新が確実に行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Transport retransmission delays might become so large as to approach or exceed the length of the lease period. This may be particularly likely when the server is unresponsive due to a restart; see Section 8.4.2.1. If the client implementation is not careful, transport retransmission delays can result in the client failing to detect a server restart before the grace period ends. The scenario is that the client is using a transport with exponential backoff, such that the maximum retransmission timeout exceeds both the grace period and the lease_time attribute. A network partition causes the client&#39;s connection&#39;s retransmission interval to back off, and even after the partition heals, the next transport-level retransmission is sent after the server has restarted and its grace period ends.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o トランスポートの再送信遅延は、リース期間の長さに近づくか、それを超えるほど大きくなる可能性があります。これは、再起動のためにサーバーが応答しない場合に特に発生する可能性があります。 8.4.2.1項を参照してください。クライアントの実装が慎重でない場合、トランスポート再送信の遅延により、猶予期間が終了する前にクライアントがサーバーの再起動を検出できなくなる可能性があります。シナリオは、クライアントが指数バックオフ付きのトランスポートを使用しているため、最大再送信タイムアウトが猶予期間とlease_time属性の両方を超えている場合です。ネットワークパーティションにより、クライアントの接続の再送信間隔がバックオフされ、パーティションが回復した後でも、サーバーが再起動して猶予期間が終了すると、次のトランスポートレベルの再送信が送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The client MUST either recover from the ensuing NFS4ERR_NO_GRACE errors or it MUST ensure that, despite transport-level retransmission intervals that exceed the lease_time, a SEQUENCE operation is sent that renews the lease before expiration. The client can achieve this by associating a new connection with the session, and sending a SEQUENCE operation on it. However, if the attempt to establish a new connection is delayed for some reason (e.g., exponential backoff of the connection establishment packets), the client will have to abort the connection establishment attempt before the lease expires, and attempt to reconnect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントは、続くNFS4ERR_NO_GRACEエラーから回復するか、lease_timeを超えるトランスポートレベルの再送信間隔にもかかわらず、有効期限が切れる前にリースを更新するSEQUENCE操作が送信されるようにする必要があります。クライアントは、新しい接続をセッションに関連付け、それにSEQUENCE操作を送信することで、これを実現できます。ただし、新しい接続を確立する試みが何らかの理由（接続確立パケットの指数バックオフなど）で遅延した場合、クライアントはリースが期限切れになる前に接続確立の試みを中止し、再接続を試行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server renews the lease upon receiving a SEQUENCE operation, the server MUST NOT allow the lease to expire while the rest of the operations in the COMPOUND procedure&#39;s request are still executing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがSEQUENCE操作の受信時にリースを更新する場合、サーバーはCOMPOUNDプロシージャの要求内の残りの操作がまだ実行されている間にリースが期限切れになることを許可してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the last operation has finished, and the response to COMPOUND has been sent, the server MUST set the lease to expire no sooner than the sum of current time and the value of the lease_time attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の操作が終了し、COMPOUNDへの応答が送信されると、サーバーはリースを現在の時間とlease_time属性の値の合計よりも早く期限切れに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client ID&#39;s lease can expire when it has been at least the lease interval (lease_time) since the last lease-renewing SEQUENCE operation was sent on any of the client ID&#39;s sessions and there are no active COMPOUND operations on any such sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントIDのリースは、最後のリース更新SEQUENCE操作がクライアントIDのセッションのいずれかで送信されてから、少なくともそのリース間隔（lease_time）であり、そのようなセッションでアクティブなCOMPOUND操作がない場合、期限切れになる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the SEQUENCE operation is the basic mechanism to renew a lease, and because it must be done at least once for each lease period, it is the natural mechanism whereby the server will inform the client of changes in the lease status that the client needs to be informed of. The client should inspect the status flags (sr_status_flags) returned by sequence and take the appropriate action (see Section 18.46.3 for details).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQUENCE操作はリースを更新するための基本的なメカニズムであり、リース期間ごとに少なくとも1回実行する必要があるため、クライアントが必要とするリースステータスの変更をサーバーがクライアントに通知する自然なメカニズムです。知らされる。クライアントは、シーケンスによって返されたステータスフラグ（sr_status_flags）を検査し、適切なアクションを実行する必要があります（詳細については、セクション18.46.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The status bits SEQ4_STATUS_CB_PATH_DOWN and SEQ4_STATUS_CB_PATH_DOWN_SESSION indicate problems with the backchannel that the client may need to address in order to receive callback requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ステータスビットSEQ4_STATUS_CB_PATH_DOWNおよびSEQ4_STATUS_CB_PATH_DOWN_SESSIONは、クライアントがコールバック要求を受信するために対処する必要があるバックチャネルの問題を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The status bits SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRING and SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED indicate problems with GSS contexts or RPCSEC_GSS handles for the backchannel that the client might have to address in order to allow callback requests to be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ステータスビットSEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRINGおよびSEQ4_STATUS_CB_GSS_CONTEXTS_EXPIREDは、コールバック要求を送信できるようにするためにクライアントが対処する必要があるバックチャネルのGSSコンテキストまたはRPCSEC_GSSハンドルの問題を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The status bits SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED, SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED, SEQ4_STATUS_ADMIN_STATE_REVOKED, and SEQ4_STATUS_RECALLABLE_STATE_REVOKED notify the client of lock revocation events. When these bits are set, the client should use TEST_STATEID to find what stateids have been revoked and use FREE_STATEID to acknowledge loss of the associated state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ステータスビットSEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED、SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED、SEQ4_STATUS_ADMIN_STATE_REVOKED、およびSEQ4_STATUS_RECALLABLE_STATE_REVOKEDは、クライアントにロックの取り消しイベントを通知します。これらのビットが設定されている場合、クライアントはTEST_STATEIDを使用して取り消された状態IDを見つけ、FREE_STATEIDを使用して関連する状態の喪失を確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The status bit SEQ4_STATUS_LEASE_MOVE indicates that responsibility for lease renewal has been transferred to one or more new servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ステータスビットSEQ4_STATUS_LEASE_MOVEは、リースの更新の責任が1つ以上の新しいサーバーに転送されたことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The status bit SEQ4_STATUS_RESTART_RECLAIM_NEEDED indicates that due to server restart the client must reclaim locking state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ステータスビットSEQ4_STATUS_RESTART_RECLAIM_NEEDEDは、サーバーの再起動により、クライアントがロック状態を取り戻す必要があることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The status bit SEQ4_STATUS_BACKCHANNEL_FAULT indicates that the server has encountered an unrecoverable fault with the backchannel (e.g., it has lost track of a sequence ID for a slot in the backchannel).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ステータスビットSEQ4_STATUS_BACKCHANNEL_FAULTは、サーバーがバックチャネルで回復不可能な障害に遭遇したことを示します（たとえば、バックチャネルのスロットのシーケンスIDの追跡を失ったなど）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-4--Crash-Recovery">
8.4. Crash Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. クラッシュリカバリー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A critical requirement in crash recovery is that both the client and the server know when the other has failed. Additionally, it is required that a client sees a consistent view of data across server restarts. All READ and WRITE operations that may have been queued within the client or network buffers must wait until the client has successfully recovered the locks protecting the READ and WRITE operations. Any that reach the server before the server can safely determine that the client has recovered enough locking state to be sure that such operations can be safely processed must be rejected. This will happen because either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クラッシュリカバリの重要な要件は、クライアントとサーバーの両方が、どちらが失敗したかを知ることです。さらに、サーバーの再起動後もクライアントはデータの一貫したビューを見る必要があります。クライアントまたはネットワークバッファー内でキューに入れられた可能性のあるすべてのREADおよびWRITE操作は、クライアントがREADおよびWRITE操作を保護するロックを正常に回復するまで待機する必要があります。サーバーがクライアントが十分なロック状態を回復したことをサーバーが安全に判断できる前にサーバーに到達した場合、そのような操作を安全に処理できることを確実に拒否する必要があります。これは、次のいずれかの理由で発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The state presented is no longer valid since it is associated with a now invalid client ID. In this case, the client will receive either an NFS4ERR_BADSESSION or NFS4ERR_DEADSESSION error, and any attempt to attach a new session to that invalid client ID will result in an NFS4ERR_STALE_CLIENTID error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 提示された状態は、無効になったクライアントIDに関連付けられているため、有効ではなくなりました。この場合、クライアントはNFS4ERR_BADSESSIONまたはNFS4ERR_DEADSESSIONエラーを受け取り、その無効なクライアントIDに新しいセッションをアタッチしようとすると、NFS4ERR_STALE_CLIENTIDエラーが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Subsequent recovery of locks may make execution of the operation inappropriate (NFS4ERR_GRACE).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o その後のロックのリカバリーにより、操作の実行が不適切になる可能性があります（NFS4ERR_GRACE）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-4-1--Client-Failure-and-Recovery">
8.4.1. Client Failure and Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.1. クライアントの障害と回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event that a client fails, the server may release the client&#39;s locks when the associated lease has expired. Conflicting locks from another client may only be granted after this lease expiration. As discussed in Section 8.3, when a client has not failed and re-establishes its lease before expiration occurs, requests for conflicting locks will not be granted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントに障害が発生した場合、関連するリースの有効期限が切れると、サーバーはクライアントのロックを解放します。別のクライアントからの競合するロックは、このリースの有効期限が切れた後にのみ許可されます。セクション8.3で説明したように、クライアントが失敗せず、期限切れになる前にリースを再確立した場合、競合するロックの要求は許可されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To minimize client delay upon restart, lock requests are associated with an instance of the client by a client-supplied verifier. This verifier is part of the client_owner4 sent in the initial EXCHANGE_ID call made by the client. The server returns a client ID as a result of the EXCHANGE_ID operation. The client then confirms the use of the client ID by establishing a session associated with that client ID (see Section 18.36.3 for a description of how this is done). All locks, including opens, byte-range locks, delegations, and layouts obtained by sessions using that client ID, are associated with that client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再起動時のクライアントの遅延を最小限に抑えるために、ロック要求は、クライアントが提供するベリファイアによってクライアントのインスタンスに関連付けられます。このベリファイアは、クライアントが行った最初のEXCHANGE_ID呼び出しで送信されたclient_owner4の一部です。サーバーは、EXCHANGE_ID操作の結果としてクライアントIDを返します。次に、クライアントは、そのクライアントIDに関連付けられたセッションを確立することにより、クライアントIDの使用を確認します（これがどのように行われるかの説明については、セクション18.36.3を参照してください）。オープン、バイト範囲ロック、委任、そのクライアントIDを使用するセッションによって取得されたレイアウトを含むすべてのロックは、そのクライアントIDに関連付けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Since the verifier will be changed by the client upon each initialization, the server can compare a new verifier to the verifier associated with currently held locks and determine that they do not match. This signifies the client&#39;s new instantiation and subsequent loss (upon confirmation of the new client ID) of locking state. As a result, the server is free to release all locks held that are associated with the old client ID that was derived from the old verifier. At this point, conflicting locks from other clients, kept waiting while the lease had not yet expired, can be granted. In addition, all stateids associated with the old client ID can also be freed, as they are no longer reference-able.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ベリファイアは初期化のたびにクライアントによって変更されるため、サーバーは新しいベリファイアを現在保持されているロックに関連付けられているベリファイアと比較し、それらが一致しないことを確認できます。これは、クライアントの新しいインスタンス化と、それに続く（新しいクライアントIDの確認時に）ロック状態の喪失を意味します。その結果、サーバーは、古いベリファイアから派生した古いクライアントIDに関連付けられている、保持されているすべてのロックを解放できます。この時点で、リースがまだ期限切れになっていない間待機し続けている、他のクライアントからの競合するロックを許可できます。さらに、古いクライアントIDに関連付けられているすべての状態IDも参照できなくなるため、解放することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the verifier must have the same uniqueness properties as the verifier for the COMMIT operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベリファイアには、COMMIT操作のベリファイアと同じ一意性プロパティが必要であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-4-2--Server-Failure-and-Recovery">
8.4.2. Server Failure and Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.2. サーバーの障害と回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server loses locking state (usually as a result of a restart), it must allow clients time to discover this fact and re-establish the lost locking state. The client must be able to re-establish the locking state without having the server deny valid requests because the server has granted conflicting access to another client. Likewise, if there is a possibility that clients have not yet re-established their locking state for a file and that such locking state might make it invalid to perform READ or WRITE operations. For example, if mandatory locks are a possibility, the server must disallow READ and WRITE operations for that file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが（通常は再起動の結果として）ロック状態を失った場合、クライアントがこの事実を発見し、失われたロック状態を再確立できるようにする必要があります。サーバーは別のクライアントに競合するアクセスを許可しているため、サーバーは有効な要求を拒否せずに、クライアントはロック状態を再確立できる必要があります。同様に、クライアントがファイルのロック状態をまだ再確立していない可能性があり、そのようなロック状態により、READまたはWRITE操作の実行が無効になる可能性がある場合。たとえば、強制ロックが可能である場合、サーバーはそのファイルのREADおよびWRITE操作を禁止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client can determine that loss of locking state has occurred via several methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、いくつかの方法でロック状態の喪失が発生したと判断できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. When a SEQUENCE (most common) or other operation returns NFS4ERR_BADSESSION, this may mean that the session has been destroyed but the client ID is still valid. The client sends a CREATE_SESSION request with the client ID to re-establish the session. If CREATE_SESSION fails with NFS4ERR_STALE_CLIENTID, the client must establish a new client ID (see Section 8.1) and re-establish its lock state with the new client ID, after the CREATE_SESSION operation succeeds (see Section 8.4.2.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. SEQUENCE（最も一般的）またはその他の操作がNFS4ERR_BADSESSIONを返す場合、これはセッションが破棄されたがクライアントIDはまだ有効であることを意味する場合があります。クライアントは、セッションを再確立するために、クライアントIDを指定したCREATE_SESSION要求を送信します。 CREATE_SESSIONがNFS4ERR_STALE_CLIENTIDで失敗した場合、クライアントはCREATE_SESSION操作が成功した後（セクション8.4.2.1を参照）、新しいクライアントID（セクション8.1を参照）を確立し、そのロック状態を新しいクライアントIDで再確立する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. When a SEQUENCE (most common) or other operation on a persistent session returns NFS4ERR_DEADSESSION, this indicates that a session is no longer usable for new, i.e., not satisfied from the reply cache, operations. Once all pending operations are determined to be either performed before the retry or not performed, the client sends a CREATE_SESSION request with the client ID to re-establish the session. If CREATE_SESSION fails with NFS4ERR_STALE_CLIENTID, the client must establish a new client ID (see Section 8.1) and re-establish its lock state after the CREATE_SESSION, with the new client ID, succeeds (Section 8.4.2.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 永続セッションでのSEQUENCE（最も一般的な）またはその他の操作がNFS4ERR_DEADSESSIONを返す場合、これは、セッションが新しい操作、つまり、応答キャッシュから満足できない操作に使用できなくなったことを示します。保留中のすべての操作が再試行の前に実行されるか、実行されないと判断されると、クライアントはクライアントIDを指定してCREATE_SESSIONリクエストを送信し、セッションを再確立します。 CREATE_SESSIONがNFS4ERR_STALE_CLIENTIDで失敗した場合、クライアントは新しいクライアントIDを確立し（セクション8.1を参照）、新しいクライアントIDでCREATE_SESSIONが成功した後にロック状態を再確立する必要があります（セクション8.4.2.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. When an operation, neither SEQUENCE nor preceded by SEQUENCE (for example, CREATE_SESSION, DESTROY_SESSION), returns NFS4ERR_STALE_CLIENTID, the client MUST establish a new client ID (Section 8.1) and re-establish its lock state (Section 8.4.2.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. SEQUENCEまたはSEQUENCEが前に付いていない操作（たとえば、CREATE_SESSION、DESTROY_SESSION）がNFS4ERR_STALE_CLIENTIDを返す場合、クライアントは新しいクライアントIDを確立し（セクション8.1）、ロック状態を再確立する必要があります（セクション8.4.2.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-4-2-1--State-Reclaim">
8.4.2.1. State Reclaim
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.2.1. 州の再生
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When state information and the associated locks are lost as a result of a server restart, the protocol must provide a way to cause that state to be re-established. The approach used is to define, for most types of locking state (layouts are an exception), a request whose function is to allow the client to re-establish on the server a lock first obtained from a previous instance. Generally, these requests are variants of the requests normally used to create locks of that type and are referred to as &#34;reclaim-type&#34; requests, and the process of re-establishing such locks is referred to as &#34;reclaiming&#34; them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの再起動の結果として状態情報と関連するロックが失われた場合、プロトコルはその状態を再確立する方法を提供する必要があります。使用されるアプローチは、ほとんどのタイプのロック状態（レイアウトは例外）に対して、クライアントが前のインスタンスから最初に取得したロックをサーバー上で再確立できるようにする機能を持つ要求を定義することです。一般に、これらのリクエストは、そのタイプのロックを作成するために通常使用されるリクエストのバリアントであり、「再利用タイプ」リクエストと呼ばれ、そのようなロックを再確立するプロセスは「再利用」と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because each client must have an opportunity to reclaim all of the locks that it has without the possibility that some other client will be granted a conflicting lock, a &#34;grace period&#34; is devoted to the reclaim process. During this period, requests creating client IDs and sessions are handled normally, but locking requests are subject to special restrictions. Only reclaim-type locking requests are allowed, unless the server can reliably determine (through state persistently maintained across restart instances) that granting any such lock cannot possibly conflict with a subsequent reclaim. When a request is made to obtain a new lock (i.e., not a reclaim-type request) during the grace period and such a determination cannot be made, the server must return the error NFS4ERR_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各クライアントは、他のクライアントに競合するロックが許可される可能性なしに、すべてのロックを再利用する機会が必要であるため、「猶予期間」は再利用プロセスに費やされます。この期間中、クライアントIDとセッションを作成するリクエストは通常​​どおり処理されますが、ロックリクエストには特別な制限が適用されます。サーバーが（再起動インスタンス間で永続的に維持される状態を介して）そのようなロックの付与が後続の再利用と競合する可能性がないことを確実に判断できない限り、再利用タイプのロック要求のみが許可されます。猶予期間中に新しいロックを取得する要求（つまり、再利用タイプの要求ではない）が行われ、そのような判断ができない場合、サーバーはエラーNFS4ERR_GRACEを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a session is established using the new client ID, the client will use reclaim-type locking requests (e.g., LOCK operations with reclaim set to TRUE and OPEN operations with a claim type of CLAIM_PREVIOUS; see Section 9.11) to re-establish its locking state. Once this is done, or if there is no such locking state to reclaim, the client sends a global RECLAIM_COMPLETE operation, i.e., one with the rca_one_fs argument set to FALSE, to indicate that it has reclaimed all of the locking state that it will reclaim. Once a client sends such a RECLAIM_COMPLETE operation, it may attempt non-reclaim locking operations, although it might get an NFS4ERR_GRACE status result from each such operation until the period of special handling is over. See Section 11.7.7 for a discussion of the analogous handling lock reclamation in the case of file systems transitioning from server to server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいクライアントIDを使用してセッションが確立されると、クライアントは再利用タイプのロック要求（たとえば、再利用をTRUEに設定したLOCK操作と、CLAIM_PREVIOUSのクレームタイプのOPEN操作）を使用して、ロックを再確立します。状態。これが完了すると、または再利用するロック状態がない場合、クライアントはグローバルなRECLAIM_COMPLETE操作、つまりrca_one_fs引数をFALSEに設定した操作を送信して、再利用するすべてのロック状態を再利用したことを示します。 。クライアントがそのようなRECLAIM_COMPLETE操作を送信すると、特別な処理の期間が終了するまで、そのような各操作からNFS4ERR_GRACEステータスの結果が得られる可能性がありますが、非再利用ロック操作を試みる場合があります。サーバーからサーバーにファイルシステムが移行する場合の類似のロック再利用の処理については、セクション11.7.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During the grace period, the server must reject READ and WRITE operations and non-reclaim locking requests (i.e., other LOCK and OPEN operations) with an error of NFS4ERR_GRACE, unless it can guarantee that these may be done safely, as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
猶予期間中、サーバーはREADおよびWRITE操作と非再利用ロック要求（つまり、他のLOCKおよびOPEN操作）をNFS4ERR_GRACEのエラーで拒否する必要があります。ただし、以下で説明するように、これらが安全に行われることが保証されている場合を除きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The grace period may last until all clients that are known to possibly have had locks have done a global RECLAIM_COMPLETE operation, indicating that they have finished reclaiming the locks they held before the server restart. This means that a client that has done a RECLAIM_COMPLETE must be prepared to receive an NFS4ERR_GRACE when attempting to acquire new locks. In order for the server to know that all clients with possible prior lock state have done a RECLAIM_COMPLETE, the server must maintain in stable storage a list clients that may have such locks. The server may also terminate the grace period before all clients have done a global RECLAIM_COMPLETE. The server SHOULD NOT terminate the grace period before a time equal to the lease period in order to give clients an opportunity to find out about the server restart, as a result of sending requests on associated sessions with a frequency governed by the lease time. Note that when a client does not send such requests (or they are sent by the client but not received by the server), it is possible for the grace period to expire before the client finds out that the server restart has occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
猶予期間は、ロックが設定されている可能性があることがわかっているすべてのクライアントがグローバルなRECLAIM_COMPLETE操作を実行するまで続き、サーバーが再起動する前に保持していたロックの再利用が完了したことを示します。つまり、RECLAIM_COMPLETEを実行したクライアントは、新しいロックを取得しようとするときにNFS4ERR_GRACEを受信できるように準備する必要があります。サーバーは、前のロック状態の可能性のあるすべてのクライアントがRECLAIM_COMPLETEを実行したことを認識するために、そのようなロックを持つ可能性のあるクライアントのリストを安定したストレージに維持する必要があります。サーバーは、すべてのクライアントがグローバルなRECLAIM_COMPLETEを実行する前に猶予期間を終了する場合もあります。サーバーは、リース期間によって制御される頻度で関連付けられたセッションで要求を送信した結果として、クライアントにサーバーの再起動について知る機会を与えるために、リース期間と等しい時間の前に猶予期間を終了しないでください。クライアントがこのような要求を送信しない場合（またはクライアントが送信したがサーバーが受信しない場合）、サーバーの再起動が行われたことがクライアントにわかる前に猶予期間が満了する可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some additional time in order to allow a client to establish a new client ID and session and to effect lock reclaims may be added to the lease time. Note that analogous rules apply to file system-specific grace periods discussed in Section 11.7.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが新しいクライアントIDとセッションを確立し、ロックの再利用を実行できるようにするために、リース時間にさらに時間がかかる場合があります。セクション11.7.7で説明するファイルシステム固有の猶予期間にも同様のルールが適用されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server can reliably determine that granting a non-reclaim request will not conflict with reclamation of locks by other clients, the NFS4ERR_GRACE error does not have to be returned even within the grace period, although NFS4ERR_GRACE must always be returned to clients attempting a non-reclaim lock request before doing their own global RECLAIM_COMPLETE. For the server to be able to service READ and WRITE operations during the grace period, it must again be able to guarantee that no possible conflict could arise between a potential reclaim locking request and the READ or WRITE operation. If the server is unable to offer that guarantee, the NFS4ERR_GRACE error must be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非再利用リクエストの付与が他のクライアントによるロックの回収と競合しないことをサーバーが確実に判断できる場合、猶予期間内であってもNFS4ERR_GRACEエラーを返す必要はありませんが、NFS4ERR_GRACEは常に-独自のグローバルRECLAIM_COMPLETEを実行する前にロック要求を再利用します。サーバーが猶予期間中にREADおよびWRITE操作を処理できるようにするには、潜在的な再利用ロック要求とREADまたはWRITE操作の間に起こり得る競合が発生しないことを保証できる必要があります。サーバーがその保証を提供できない場合は、NFS4ERR_GRACEエラーをクライアントに返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a server to provide simple, valid handling during the grace period, the easiest method is to simply reject all non-reclaim locking requests and READ and WRITE operations by returning the NFS4ERR_GRACE error. However, a server may keep information about granted locks in stable storage. With this information, the server could determine if a locking, READ or WRITE operation can be safely processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが猶予期間中に単純で有効な処理を提供するための最も簡単な方法は、NFS4ERR_GRACEエラーを返すことにより、すべての非再利用ロック要求とREADおよびWRITE操作を単に拒否することです。ただし、サーバーは、許可されたロックに関する情報を安定したストレージに保持する場合があります。この情報を使用して、サーバーは、ロック、読み取り、または書き込み操作を安全に処理できるかどうかを判断できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, if the server maintained on stable storage summary information on whether mandatory locks exist, either mandatory byte-range locks, or share reservations specifying deny modes, many requests could be allowed during the grace period. If it is known that no such share reservations exist, OPEN request that do not specify deny modes may be safely granted. If, in addition, it is known that no mandatory byte-range locks exist, either through information stored on stable storage or simply because the server does not support such locks, READ and WRITE operations may be safely processed during the grace period. Another important case is where it is known that no mandatory byte-range locks exist, either because the server does not provide support for them or because their absence is known from persistently recorded data. In this case, READ and WRITE operations specifying stateids derived from reclaim-type operations may be validly processed during the grace period because of the fact that the valid reclaim ensures that no lock subsequently granted can prevent the I/O.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、サーバーが、必須ロックが存在するかどうか、必須バイト範囲ロック、または拒否モードを指定する共有予約のいずれかに関する安定したストレージサマリー情報を維持している場合、猶予期間中に多くの要求が許可される可能性があります。そのような共有予約が存在しないことがわかっている場合は、拒否モードを指定しないOPEN要求を安全に許可できます。さらに、安定したストレージに格納された情報によって、またはサーバーがそのようなロックをサポートしていないために、必須のバイト範囲ロックが存在しないことがわかっている場合、猶予期間中にREADおよびWRITE操作を安全に処理できます。もう1つの重要なケースは、サーバーがサポートを提供していないか、永続的に記録されたデータからそれらの不在がわかっているために、必須のバイト範囲ロックが存在しないことがわかっている場合です。この場合、有効な再利用によってその後に許可されるロックによってI / Oが妨げられることがないため、再利用タイプの操作から派生した状態IDを指定するREADおよびWRITE操作は、猶予期間中に有効に処理される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To reiterate, for a server that allows non-reclaim lock and I/O requests to be processed during the grace period, it MUST determine that no lock subsequently reclaimed will be rejected and that no lock subsequently reclaimed would have prevented any I/O operation processed during the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
繰り返しますが、猶予期間中に非再利用ロックとI / O要求の処理を許可するサーバーでは、その後再利用されるロックは拒否されず、その後再利用されるロックはI / O操作を妨げなかったと判断する必要があります。猶予期間中に処理されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients should be prepared for the return of NFS4ERR_GRACE errors for non-reclaim lock and I/O requests. In this case, the client should employ a retry mechanism for the request. A delay (on the order of several seconds) between retries should be used to avoid overwhelming the server. Further discussion of the general issue is included in [47]. The client must account for the server that can perform I/O and non-reclaim locking requests within the grace period as well as those that cannot do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、非再利用ロックおよびI / O要求に対してNFS4ERR_GRACEエラーが返されるように準備する必要があります。この場合、クライアントは要求に対して再試行メカニズムを採用する必要があります。サーバーが過負荷にならないように、再試行間の遅延（数秒程度）を使用する必要があります。一般的な問題の詳細については、[47]に記載されています。クライアントは、猶予期間内にI / Oおよび非再利用ロック要求を実行できるサーバーと、そうできないサーバーを考慮に入れる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reclaim-type locking request outside the server&#39;s grace period can only succeed if the server can guarantee that no conflicting lock or I/O request has been granted since restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの猶予期間外の再利用タイプのロック要求は、サーバーが再起動以降、競合するロックまたはI / O要求が許可されていないことを保証できる場合にのみ成功します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server may, upon restart, establish a new value for the lease period. Therefore, clients should, once a new client ID is established, refetch the lease_time attribute and use it as the basis for lease renewal for the lease associated with that server. However, the server must establish, for this restart event, a grace period at least as long as the lease period for the previous server instantiation. This allows the client state obtained during the previous server instance to be reliably re-established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、再起動時に、リース期間の新しい値を確立できます。したがって、クライアントは、新しいクライアントIDが確​​立されたら、lease_time属性を再フェッチして、そのサーバーに関連付けられているリースのリース更新の基礎として使用する必要があります。ただし、サーバーは、この再起動イベントに対して、少なくとも前回のサーバーのインスタンス化のリース期間と同じくらいの猶予期間を確立する必要があります。これにより、前のサーバーインスタンスで取得したクライアントの状態を確実に再確立できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The possibility exists that, because of server configuration events, the client will be communicating with a server different than the one on which the locks were obtained, as shown by the combination of eir_server_scope and eir_server_owner. This leads to the issue of if and when the client should attempt to reclaim locks previously obtained on what is being reported as a different server. The rules to resolve this question are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー構成イベントのために、eir_server_scopeとeir_server_ownerの組み合わせで示されるように、クライアントはロックが取得されたサーバーとは異なるサーバーと通信する可能性があります。これにより、別のサーバーとして報告されているもので以前に取得したロックをクライアントが再利用しようとするかどうか、いつ問題が発生するかが問題になります。この質問を解決するためのルールは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the server scope is different, the client should not attempt to reclaim locks. In this situation, no lock reclaim is possible. Any attempt to re-obtain the locks with non-reclaim operations is problematic since there is no guarantee that the existing filehandles will be recognized by the new server, or that if recognized, they denote the same objects. It is best to treat the locks as having been revoked by the reconfiguration event.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーのスコープが異なる場合、クライアントはロックの再利用を試みるべきではありません。この状況では、ロックの再利用は不可能です。非再利用操作でロックを再取得しようとすると、既存のファイルハンドルが新しいサーバーによって認識されるか、認識された場合に同じオブジェクトを示す保証がないため、問題が発生します。ロックは、再構成イベントによって取り消されたものとして扱うことをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the server scope is the same, the client should attempt to reclaim locks, even if the eir_server_owner value is different. In this situation, it is the responsibility of the server to return NFS4ERR_NO_GRACE if it cannot provide correct support for lock reclaim operations, including the prevention of edge conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーのスコープが同じ場合、eir_server_ownerの値が異なっていても、クライアントはロックの再利用を試みる必要があります。この状況では、エッジ条件の防止など、ロック再利用操作を正しくサポートできない場合にサーバーがNFS4ERR_NO_GRACEを返すのはサーバーの責任です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The eir_server_owner field is not used in making this determination. Its function is to specify trunking possibilities for the client (see Section 2.10.5) and not to control lock reclaim.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
eir_server_ownerフィールドは、この決定には使用されません。その機能は、クライアントのトランキングの可能性を指定すること（セクション2.10.5を参照）であり、ロックの再利用を制御することではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-4-2-1-1--Security-Considerations-for-State-Reclaim">
8.4.2.1.1. Security Considerations for State Reclaim
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.2.1.1. 状態再利用のセキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During the grace period, a client can reclaim state that it believes or asserts it had before the server restarted. Unless the server maintained a complete record of all the state the client had, the server has little choice but to trust the client. (Of course, if the server maintained a complete record, then it would not have to force the client to reclaim state after server restart.) While the server has to trust the client to tell the truth, such trust does not have any negative consequences for security. The fundamental rule for the server when processing reclaim requests is that it MUST NOT grant the reclaim if an equivalent non-reclaim request would not be granted during steady state due to access control or access conflict issues. For example, an OPEN request during a reclaim will be refused with NFS4ERR_ACCESS if the principal making the request does not have access to open the file according to the discretionary ACL (Section 6.2.2) on the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
猶予期間中、クライアントは、サーバーが再起動する前の状態を信じたり表明したりすることができます。サーバーがクライアントのすべての状態の完全な記録を維持していない限り、サーバーはクライアントを信頼するしかありません。 （もちろん、サーバーが完全なレコードを維持している場合、サーバーの再起動後にクライアントに状態を取り戻すよう強制する必要はありません。）サーバーはクライアントを信頼して真実を伝える必要がありますが、そのような信頼は否定的な結果をもたらしませんセキュリティのため。再利用要求を処理するときのサーバーの基本的なルールは、アクセス制御またはアクセス競合の問題のために定常状態中に同等の非再利用要求が許可されない場合、再利用を許可してはならないことです。たとえば、ファイルの裁量的ACL（セクション6.2.2）に従ってファイルを開くためのアクセス権がない場合、再要求時のOPENリクエストはNFS4ERR_ACCESSで拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Nonetheless, it is possible that a client operating in error or maliciously could, during reclaim, prevent another client from reclaiming access to state. For example, an attacker could send an OPEN reclaim operation with a deny mode that prevents another client from reclaiming the OPEN state it had before the server restarted. The attacker could perform the same denial of service during steady state prior to server restart, as long as the attacker had permissions. Given that the attack vectors are equivalent, the grace period does not offer any additional opportunity for denial of service, and any concerns about this attack vector, whether during grace or steady state, are addressed the same way: use RPCSEC_GSS for authentication and limit access to the file only to principals that the owner of the file trusts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
それでも、エラーで動作しているクライアントや悪意を持って動作しているクライアントが、再生中に別のクライアントが状態へのアクセスを再生することを妨げる可能性があります。たとえば、攻撃者は、サーバーが再起動する前に他のクライアントがOPEN状態を取り戻すことを防ぐ拒否モードでOPEN reclaim操作を送信する可能性があります。攻撃者が権限を持っている限り、攻撃者はサーバーの再起動前の定常状態中に同じサービス拒否を実行する可能性があります。攻撃ベクトルが同等であることを考えると、猶予期間はサービス拒否の追加の機会を提供せず、この攻撃ベクトルに関する懸念は、猶予状態でも定常状態でも、同じ方法で対処されます。認証とアクセスの制限にRPCSEC_GSSを使用します。ファイルの所有者が信頼するプリンシパルのみにファイルに。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if prior to restart the server had client IDs with the EXCHGID4_FLAG_BIND_PRINC_STATEID (Section 18.35) capability set, then the server SHOULD record in stable storage the client owner and the principal that established the client ID via EXCHANGE_ID. If the server does not, then there is a risk a client will be unable to reclaim state if it does not have a credential for a principal that was originally authorized to establish the state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再起動する前に、サーバーにEXCHGID4_FLAG_BIND_PRINC_STATEID（セクション18.35）機能が設定されたクライアントIDがあった場合、サーバーは安定したストレージにクライアント所有者とEXCHANGE_IDを介してクライアントIDを確立したプリンシパルを記録する必要があります。サーバーにない場合、元々状態の確立を承認されたプリンシパルの資格情報がない場合、クライアントが状態を取り戻すことができないリスクがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-4-3--Network-Partitions-and-Recovery">
8.4.3. Network Partitions and Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.3. ネットワークパーティションとリカバリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the duration of a network partition is greater than the lease period provided by the server, the server will not have received a lease renewal from the client. If this occurs, the server may free all locks held for the client or it may allow the lock state to remain for a considerable period, subject to the constraint that if a request for a conflicting lock is made, locks associated with an expired lease do not prevent such a conflicting lock from being granted but MUST be revoked as necessary so as to avoid interfering with such conflicting requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークパーティションの期間がサーバーによって提供されるリース期間よりも長い場合、サーバーはクライアントからリースの更新を受信して​​いません。これが発生した場合、サーバーはクライアントのために保持していたすべてのロックを解放するか、競合状態のロックが要求された場合に期限切れのリースに関連付けられたロックがこのような競合するロックが許可されるのを防ぐことはできませんが、このような競合する要求に干渉しないように、必要に応じて取り消す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server chooses to delay freeing of lock state until there is a conflict, it may either free all of the client&#39;s locks once there is a conflict or it may only revoke the minimum set of locks necessary to allow conflicting requests. When it adopts the finer-grained approach, it must revoke all locks associated with a given stateid, even if the conflict is with only a subset of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが競合が発生するまでロック状態の解放を遅らせることを選択した場合、競合が発生するとクライアントのすべてのロックを解放するか、競合する要求を許可するために必要な最小限のロックセットのみを取り消す可能性があります。より細かいアプローチを採用する場合、競合がロックのサブセットのみである場合でも、特定の状態IDに関連付けられたすべてのロックを取り消す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server chooses to free all of a client&#39;s lock state, either immediately upon lease expiration or as a result of the first attempt to obtain a conflicting a lock, the server may report the loss of lock state in a number of ways.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがクライアントのすべてのロック状態を解放することを選択すると、リースの有効期限が切れた直後、または競合するロックを取得しようとする最初の試みの結果として、サーバーはいくつかの方法でロック状態の喪失を報告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The server may choose to invalidate the session and the associated client ID. In this case, once the client can communicate with the server, it will receive an NFS4ERR_BADSESSION error. Upon attempting to create a new session, it would get an NFS4ERR_STALE_CLIENTID. Upon creating the new client ID and new session, the client will attempt to reclaim locks. Normally, the server will not allow the client to reclaim locks, because the server will not be in its recovery grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーは、セッションと関連するクライアントIDを無効にすることを選択できます。この場合、クライアントがサーバーと通信できるようになると、クライアントはNFS4ERR_BADSESSIONエラーを受け取ります。新しいセッションを作成しようとすると、NFS4ERR_STALE_CLIENTIDを取得します。新しいクライアントIDと新しいセッションを作成すると、クライアントはロックの再利用を試みます。通常、サーバーはリカバリー猶予期間にないため、サーバーはクライアントがロックを再利用することを許可しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another possibility is for the server to maintain the session and client ID but for all stateids held by the client to become invalid or stale. Once the client can reach the server after such a network partition, the status returned by the SEQUENCE operation will indicate a loss of locking state; i.e., the flag SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED will be set in sr_status_flags. In addition, all I/O submitted by the client with the now invalid stateids will fail with the server returning the error NFS4ERR_EXPIRED. Once the client learns of the loss of locking state, it will suitably notify the applications that held the invalidated locks. The client should then take action to free invalidated stateids, either by establishing a new client ID using a new verifier or by doing a FREE_STATEID operation to release each of the invalidated stateids.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もう1つの可能性は、サーバーがセッションとクライアントIDを維持することですが、クライアントが保持するすべての状態IDが無効または古くなる可能性があります。このようなネットワーク分割の後でクライアントがサーバーに到達すると、SEQUENCE操作によって返されるステータスはロック状態が失われたことを示します。つまり、フラグSEQ4_STATUS_EXPIRED_ALL_STATE_REVOKEDがsr_status_flagsに設定されます。さらに、現在無効な状態IDでクライアントが送信したすべてのI / Oは失敗し、サーバーはエラーNFS4ERR_EXPIREDを返します。クライアントがロック状態の喪失を知ると、無効化されたロックを保持していたアプリケーションに適切に通知します。次にクライアントは、新しいベリファイアを使用して新しいクライアントIDを確立するか、FREE_STATEID操作を実行して無効化された各ステートIDを解放することにより、無効化されたステートIDを解放するアクションを実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server adopts a finer-grained approach to revocation of locks when a client&#39;s lease has expired, only a subset of stateids will normally become invalid during a network partition. When the client can communicate with the server after such a network partition heals, the status returned by the SEQUENCE operation will indicate a partial loss of locking state (SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED). In addition, operations, including I/O submitted by the client, with the now invalid stateids will fail with the server returning the error NFS4ERR_EXPIRED. Once the client learns of the loss of locking state, it will use the TEST_STATEID operation on all of its stateids to determine which locks have been lost and then suitably notify the applications that held the invalidated locks. The client can then release the invalidated locking state and acknowledge the revocation of the associated locks by doing a FREE_STATEID operation on each of the invalidated stateids.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのリースが期限切れになったときにサーバーがロックの取り消しに細粒度のアプローチを採用する場合、通常はネットワークパーティション中にステートIDのサブセットのみが無効になります。このようなネットワークパーティションが回復した後、クライアントがサーバーと通信できる場合、SEQUENCE操作によって返されるステータスは、ロック状態の部分的な喪失を示します（SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED）。さらに、クライアントによって送信されたI / Oを含む操作が無効になったため、サーバーはエラーNFS4ERR_EXPIREDを返し、失敗します。クライアントは、ロック状態が失われたことを知ると、すべての状態IDに対してTEST_STATEID操作を使用して、失われたロックを判別し、無効になったロックを保持していたアプリケーションに適切に通知します。次に、クライアントは無効化されたロック状態を解放し、無効化された各状態IDでFREE_STATEID操作を実行することにより、関連するロックの取り消しを確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a network partition is combined with a server restart, there are edge conditions that place requirements on the server in order to avoid silent data corruption following the server restart. Two of these edge conditions are known, and are discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークパーティションをサーバーの再起動と組み合わせると、サーバーの再起動後にデータのサイレント破損を回避するためにサーバーに要件を課すエッジ条件があります。これらのエッジ条件のうち2つは既知であり、以下で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The first edge condition arises as a result of the scenarios such as the following: 1. Client A acquires a lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
最初のエッジ条件は、次のようなシナリオの結果として発生します。1.クライアントAがロックを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Client A and server experience mutual network partition, such that client A is unable to renew its lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. クライアントAとサーバーは相互ネットワークパーティションを経験しているため、クライアントAはリースを更新できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Client A&#39;s lease expires, and the server releases the lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. クライアントAのリースが期限切れになり、サーバーがロックを解放します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Client B acquires a lock that would have conflicted with that of client A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. クライアントBは、クライアントAのロックと競合するロックを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Client B releases its lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. クライアントBはロックを解放します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Server restarts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. サーバーが再起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Network partition between client A and server heals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. クライアントAとサーバー間のネットワークパーティションが修復されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Client A connects to a new server instance and finds out about server restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. クライアントAは新しいサーバーインスタンスに接続し、サーバーの再起動について調べます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. Client A reclaims its lock within the server&#39;s grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. クライアントAは、サーバーの猶予期間内にロックを取り戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, at the final step, the server has erroneously granted client A&#39;s lock reclaim. If client B modified the object the lock was protecting, client A will experience object corruption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、最後のステップで、サーバーは誤ってクライアントAのロック再利用を許可しました。ロックが保護していたオブジェクトをクライアントBが変更した場合、クライアントAはオブジェクトの破損を経験します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second known edge condition arises in situations such as the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目の既知のエッジ条件は、次のような状況で発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Client A acquires one or more locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. クライアントAは1つ以上のロックを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Server restarts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. サーバーが再起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Client A and server experience mutual network partition, such that client A is unable to reclaim all of its locks within the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. クライアントAとサーバーは相互ネットワークパーティションを経験しているため、クライアントAは猶予期間内にすべてのロックを再利用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Server&#39;s reclaim grace period ends. Client A has either no locks or an incomplete set of locks known to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. サーバーの再利用猶予期間が終了します。クライアントAには、ロックがないか、サーバーが認識しているロックのセットが不完全です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Client B acquires a lock that would have conflicted with a lock of client A that was not reclaimed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. クライアントBは、再利用されなかったクライアントAのロックと競合するロックを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Client B releases the lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. クライアントBがロックを解放します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Server restarts a second time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. サーバーがもう一度再起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Network partition between client A and server heals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. クライアントAとサーバー間のネットワークパーティションが修復されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. Client A connects to new server instance and finds out about server restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. クライアントAは新しいサーバーインスタンスに接続し、サーバーの再起動について調べます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. Client A reclaims its lock within the server&#39;s grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. クライアントAは、サーバーの猶予期間内にロックを取り戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with the first edge condition, the final step of the scenario of the second edge condition has the server erroneously granting client A&#39;s lock reclaim.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のエッジ条件と同様に、2番目のエッジ条件のシナリオの最後のステップでは、サーバーが誤ってクライアントAのロック再利用を許可します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Solving the first and second edge conditions requires either that the server always assumes after it restarts that some edge condition occurs, and thus returns NFS4ERR_NO_GRACE for all reclaim attempts, or that the server record some information in stable storage. The amount of information the server records in stable storage is in inverse proportion to how harsh the server intends to be whenever edge conditions arise. The server that is completely tolerant of all edge conditions will record in stable storage every lock that is acquired, removing the lock record from stable storage only when the lock is released. For the two edge conditions discussed above, the harshest a server can be, and still support a grace period for reclaims, requires that the server record in stable storage some minimal information. For example, a server implementation could, for each client, save in stable storage a record containing:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1番目と2番目のエッジ条件を解決するには、サーバーが再起動後、常に何らかのエッジ条件が発生すると想定し、すべての再利用試行に対してNFS4ERR_NO_GRACEを返すか、サーバーが安定したストレージに情報を記録する必要があります。サーバーが安定したストレージに記録する情報の量は、エッジ条件が発生するたびにサーバーが意図する苛酷さに比例します。すべてのエッジ条件を完全に許容するサーバーは、取得したすべてのロックを安定したストレージに記録し、ロックが解放された場合にのみ、安定したストレージからロックレコードを削除します。上記の2つのエッジ条件の場合、サーバーが最も過酷な状態になる可能性があり、再利用の猶予期間をサポートするには、サーバーが最小限の情報を安定したストレージに記録する必要があります。たとえば、サーバーの実装では、クライアントごとに、以下を含むレコードを安定したストレージに保存できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the co_ownerid field from the client_owner4 presented in the EXCHANGE_ID operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o EXCHANGE_ID操作で提示されたclient_owner4のco_owneridフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a boolean that indicates if the client&#39;s lease expired or if there was administrative intervention (see Section 8.5) to revoke a byte-range lock, share reservation, or delegation and there has been no acknowledgment, via FREE_STATEID, of such revocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントのリースが期限切れになったかどうか、またはバイト範囲ロック、共有予約、または委任を取り消すための管理者の介入（8.5を参照）があったかどうか、およびそのような取り消しのFREE_STATEIDによる確認がなかったかどうかを示すブール値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a boolean that indicates whether the client may have locks that it believes to be reclaimable in situations in which the grace period was terminated, making the server&#39;s view of lock reclaimability suspect. The server will set this for any client record in stable storage where the client has not done a suitable RECLAIM_COMPLETE (global or file system-specific depending on the target of the lock request) before it grants any new (i.e., not reclaimed) lock to any client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 猶予期間が終了した状況でクライアントが再利用可能であると考えられるロックをクライアントが持つことができるかどうかを示すブール値。これにより、ロックの再利用可能性に対するサーバーの見方が疑わしくなります。サーバーは、クライアントが新しい（つまり、再利用されていない）ロックを許可する前に、適切なRECLAIM_COMPLETE（ロックリクエストのターゲットに応じてグローバルまたはファイルシステム固有）を実行していない安定したストレージのクライアントレコードに対してこれを設定します任意のクライアント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming the above record keeping, for the first edge condition, after the server restarts, the record that client A&#39;s lease expired means that another client could have acquired a conflicting byte-range lock, share reservation, or delegation. Hence, the server must reject a reclaim from client A with the error NFS4ERR_NO_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の記録を保持すると仮定すると、最初のエッジ条件で、サーバーの再起動後、クライアントAのリースが期限切れになったという記録は、別のクライアントが競合するバイト範囲ロック、共有予約、または委任を取得した可能性があることを意味します。したがって、サーバーはエラーNFS4ERR_NO_GRACEでクライアントAからの再利用を拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the second edge condition, after the server restarts for a second time, the indication that the client had not completed its reclaims at the time at which the grace period ended means that the server must reject a reclaim from client A with the error NFS4ERR_NO_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目のエッジ条件の場合、サーバーが2回再起動した後、猶予期間が終了したときにクライアントが再利用を完了しなかったことは、サーバーがクライアントAからの再利用をエラーNFS4ERR_NO_GRACEで拒否する必要があることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When either edge condition occurs, the client&#39;s attempt to reclaim locks will result in the error NFS4ERR_NO_GRACE. When this is received, or after the client restarts with no lock state, the client will send a global RECLAIM_COMPLETE. When the RECLAIM_COMPLETE is received, the server and client are again in agreement regarding reclaimable locks and both booleans in persistent storage can be reset, to be set again only when there is a subsequent event that causes lock reclaim operations to be questionable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いずれかのエッジ条件が発生すると、クライアントがロックを再利用しようとすると、エラーNFS4ERR_NO_GRACEが発生します。これを受信した場合、またはクライアントがロック状態なしで再起動した後、クライアントはグローバルRECLAIM_COMPLETEを送信します。 RECLAIM_COMPLETEが受信されると、サーバーとクライアントは再利用可能なロックに関して再度合意し、永続的なストレージの両方のブール値をリセットして、ロックの再利用操作を疑わしいものにする後続のイベントがある場合にのみ再設定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of the level and approach to record keeping, the server MUST implement one of the following strategies (which apply to reclaims of share reservations, byte-range locks, and delegations):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
記録保持のレベルとアプローチに関係なく、サーバーは次の戦略の1つを実装する必要があります（共有予約、バイト範囲ロック、および委任の再利用に適用されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Reject all reclaims with NFS4ERR_NO_GRACE. This is extremely unforgiving, but necessary if the server does not record lock state in stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. NFS4ERR_NO_GRACEを使用してすべての再利用を拒否します。これは非常に寛容ですが、サーバーが安定したストレージにロック状態を記録しない場合に必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Record sufficient state in stable storage such that all known edge conditions involving server restart, including the two noted in this section, are detected. It is acceptable to erroneously recognize an edge condition and not allow a reclaim, when, with sufficient knowledge, it would be allowed. The error the server would return in this case is NFS4ERR_NO_GRACE. Note that it is not known if there are other edge conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. このセクションで説明した2つを含め、サーバーの再起動に関連するすべての既知のエッジ状態が検出されるように、安定したストレージに十分な状態を記録します。エッジの状態を誤って認識し、再利用を許可しないことは、十分な知識があれば許可される場合に許容されます。この場合にサーバーが返すエラーはNFS4ERR_NO_GRACEです。他のエッジ条件があるかどうかは不明であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In the event that, after a server restart, the server determines there is unrecoverable damage or corruption to the information in stable storage, then for all clients and/or locks that may be affected, the server MUST return NFS4ERR_NO_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
サーバーが再起動した後、サーバーが安定したストレージ内の情報に回復不可能な損傷または破損があると判断した場合、影響を受ける可能性のあるすべてのクライアントやロックについて、サーバーはNFS4ERR_NO_GRACEを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A mandate for the client&#39;s handling of the NFS4ERR_NO_GRACE error is outside the scope of this specification, since the strategies for such handling are very dependent on the client&#39;s operating environment. However, one potential approach is described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのNFS4ERR_NO_GRACEエラーの処理の義務は、この仕様の範囲外です。そのような処理の戦略は、クライアントの動作環境に大きく依存するためです。ただし、考えられるアプローチの1つを以下で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When the client receives NFS4ERR_NO_GRACE, it could examine the change attribute of the objects for which the client is trying to reclaim state, and use that to determine whether to re-establish the state via normal OPEN or LOCK operations. This is acceptable provided that the client&#39;s operating environment allows it. In other words, the client implementor is advised to document for his users the behavior. The client could also inform the application that its byte-range lock or share reservations (whether or not they were delegated) have been lost, such as via a UNIX signal, a Graphical User Interface (GUI) pop-up window, etc. See Section 10.5 for a discussion of what the client should do for dealing with unreclaimed delegations on client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントは、NFS4ERR_NO_GRACEを受信すると、クライアントが状態を再利用しようとしているオブジェクトの変更属性を調べ、その属性を使用して、通常のOPENまたはLOCK操作で状態を再確立するかどうかを判断できます。これは、クライアントの動作環境で許可されていれば許容されます。言い換えると、クライアントの実装者は、ユーザーの行動を文書化することをお勧めします。クライアントは、UNIX信号、グラフィカルユーザーインターフェイス（GUI）ポップアップウィンドウなどを介して、バイト範囲ロックまたは共有予約（委任されているかどうかにかかわらず）が失われたことをアプリケーションに通知することもできます。クライアントの状態に関する未回収の委任に対処するためにクライアントが行うべきことについては、セクション10.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For further discussion of revocation of locks, see Section 8.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックの取り消しの詳細については、8.5項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-5--Server-Revocation-of-Locks">
8.5. Server Revocation of Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. ロックのサーバー失効
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At any point, the server can revoke locks held by a client, and the client must be prepared for this event. When the client detects that its locks have been or may have been revoked, the client is responsible for validating the state information between itself and the server. Validating locking state for the client means that it must verify or reclaim state for each lock currently held.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At any point, the server can revoke locks held by a client, and the client must be prepared for this event. When the client detects that its locks have been or may have been revoked, the client is responsible for validating the state information between itself and the server. Validating locking state for the client means that it must verify or reclaim state for each lock currently held.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first occasion of lock revocation is upon server restart. Note that this includes situations in which sessions are persistent and locking state is lost. In this class of instances, the client will receive an error (NFS4ERR_STALE_CLIENTID) on an operation that takes client ID, usually as part of recovery in response to a problem with the current session), and the client will proceed with normal crash recovery as described in the Section 8.4.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックの取り消しの最初の機会は、サーバーの再起動時です。これには、セッションが永続的で、ロック状態が失われる状況が含まれることに注意してください。このクラスのインスタンスでは、クライアントは、クライアントIDを取得する操作でエラー（NFS4ERR_STALE_CLIENTID）を受け取ります。通常は、現在のセッションの問題に対応するリカバリの一部として行われます。クライアントは、通常のクラッシュリカバリを続行します。セクション8.4.2.1で。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second occasion of lock revocation is the inability to renew the lease before expiration, as discussed in Section 8.4.3. While this is considered a rare or unusual event, the client must be prepared to recover. The server is responsible for determining the precise consequences of the lease expiration, informing the client of the scope of the lock revocation decided upon. The client then uses the status information provided by the server in the SEQUENCE results (field sr_status_flags, see Section 18.46.3) to synchronize its locking state with that of the server, in order to recover.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション8.4.3で説明されているように、ロックの取り消しの2番目の機会は、期限切れ前にリースを更新できないことです。これはまれまたは異常なイベントと見なされますが、クライアントは回復する準備をする必要があります。サーバーはリースの期限切れの正確な結果を決定し、決定したロックの取り消しの範囲をクライアントに通知する責任があります。次にクライアントは、SEQUENCE結果でサーバーから提供されたステータス情報（フィールドsr_status_flags、セクション18.46.3を参照）を使用して、ロック状態をサーバーと同期させ、回復します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The third occasion of lock revocation can occur as a result of revocation of locks within the lease period, either because of administrative intervention or because a recallable lock (a delegation or layout) was not returned within the lease period after having been recalled. While these are considered rare events, they are possible, and the client must be prepared to deal with them. When either of these events occurs, the client finds out about the situation through the status returned by the SEQUENCE operation. Any use of stateids associated with locks revoked during the lease period will receive the error NFS4ERR_ADMIN_REVOKED or NFS4ERR_DELEG_REVOKED, as appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックの取り消しが3回目となるのは、管理者の介入または呼び出し可能なロック（委任またはレイアウト）が呼び出された後、リース期間内に返されなかったため、リース期間内のロックの取り消しの結果として発生する可能性があります。これらはまれなイベントと見なされますが、それらは可能であり、クライアントはそれらに対処する準備をする必要があります。これらのイベントのいずれかが発生すると、クライアントはSEQUENCE操作によって返されたステータスを通じて状況を確認します。リース期間中に取り消されたロックに関連付けられたステートIDを使用すると、必要に応じて、エラーNFS4ERR_ADMIN_REVOKEDまたはNFS4ERR_DELEG_REVOKEDを受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In all situations in which a subset of locking state may have been revoked, which include all cases in which locking state is revoked within the lease period, it is up to the client to determine which locks have been revoked and which have not. It does this by using the TEST_STATEID operation on the appropriate set of stateids. Once the set of revoked locks has been determined, the applications can be notified, and the invalidated stateids can be freed and lock revocation acknowledged by using FREE_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リース期間内にロック状態が取り消されるすべてのケースを含む、ロック状態のサブセットが取り消された可能性があるすべての状況で、取り消されたロックと取り消されていないロックを判別するのはクライアントの責任です。これは、適切な状態IDのセットに対してTEST_STATEID操作を使用することによって行われます。取り消されたロックのセットが決定されると、アプリケーションに通知され、FREE_STATEIDを使用して、無効化された状態IDを解放し、ロックの取り消しを確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-6--Short-and-Long-Leases">
8.6. Short and Long Leases
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6. 短期および長期リース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When determining the time period for the server lease, the usual lease tradeoffs apply. A short lease is good for fast server recovery at a cost of increased operations to effect lease renewal (when there are no other operations during the period to effect lease renewal as a side effect). A long lease is certainly kinder and gentler to servers trying to handle very large numbers of clients. The number of extra requests to effect lock renewal drops in inverse proportion to the lease time. The disadvantages of a long lease include the possibility of slower recovery after certain failures. After server failure, a longer grace period may be required when some clients do not promptly reclaim their locks and do a global RECLAIM_COMPLETE. In the event of client failure, the longer period for a lease to expire will force conflicting requests to wait longer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーリースの期間を決定するときは、通常のリーストレードオフが適用されます。短いリースは、サーバーの高速復旧に適していますが、リースの更新を行うための操作が増加します（期間中に副作用としてリースの更新を行う他の操作がない場合）。長いリースは、非常に多数のクライアントを処理しようとするサーバーにとって、確かに優しく穏やかです。リース時間に反比例してロック更新ドロップを実行するための追加リクエストの数。長いリースの短所は、特定の障害の後で回復が遅くなる可能性があることです。サーバー障害後、一部のクライアントがロックをすぐに再利用せず、グローバルなRECLAIM_COMPLETEを実行しない場合は、より長い猶予期間が必要になることがあります。クライアントに障害が発生した場合、リースの有効期限が長くなると、競合する要求の待機時間が長くなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A long lease is practical if the server can store lease state in stable storage. Upon recovery, the server can reconstruct the lease state from its stable storage and continue operation with its clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがリース状態を安定したストレージに保存できる場合、長期リースは実用的です。リカバリ時に、サーバーは安定したストレージからリース状態を再構築し、クライアントとの運用を継続できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-7--Clocks-Propagation-Delay-and-Calculating-Lease-Expiration">
8.7. Clocks, Propagation Delay, and Calculating Lease Expiration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7. クロック、伝搬遅延、およびリースの有効期限の計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid the need for synchronized clocks, lease times are granted by the server as a time delta. However, there is a requirement that the client and server clocks do not drift excessively over the duration of the lease. There is also the issue of propagation delay across the network, which could easily be several hundred milliseconds, as well as the possibility that requests will be lost and need to be retransmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同期されたクロックの必要性を回避するために、リース時間はサーバーによってタイムデルタとして付与されます。ただし、リース期間中にクライアントとサーバーのクロックが過度にドリフトしないという要件があります。また、ネットワーク全体の伝搬遅延の問題もあり、これは数百ミリ秒になりがちですが、リクエストが失われ、再送信が必要になる可能性もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 To take propagation delay into account, the client should subtract it from lease times (e.g., if the client estimates the one-way propagation delay as 200 milliseconds, then it can assume that the lease is already 200 milliseconds old when it gets it). In addition, it will take another 200 milliseconds to get a response back to the server. So the client must send a lease renewal or write data back to the server at least 400 milliseconds before the lease would expire. If the propagation delay varies over the life of the lease (e.g., the client is on a mobile host), the client will need to continuously subtract the increase in propagation delay from the lease times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
伝播遅延を考慮に入れるには、クライアントはそれをリース時間から差し引く必要があります（たとえば、クライアントが一方向の伝播遅延を200ミリ秒と推定する場合、リースを取得した時点でリースがすでに200ミリ秒経過していると想定できます）。さらに、サーバーに応答を返すまでにさらに200ミリ秒かかります。したがって、クライアントはリースの期限が切れる少なくとも400ミリ秒前に、リースの更新を送信するか、サーバーにデータを書き戻す必要があります。伝播の遅延がリースの存続期間中に変化する場合（たとえば、クライアントがモバイルホスト上にある場合）、クライアントは、伝播時間の増加をリース時間から継続的に差し引く必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server&#39;s lease period configuration should take into account the network distance of the clients that will be accessing the server&#39;s resources. It is expected that the lease period will take into account the network propagation delays and other network delay factors for the client population. Since the protocol does not allow for an automatic method to determine an appropriate lease period, the server&#39;s administrator may have to tune the lease period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのリース期間の構成では、サーバーのリソースにアクセスするクライアントのネットワーク距離を考慮する必要があります。リース期間では、クライアントの人口に対するネットワークの伝播の遅延やその他のネットワークの遅延要因が考慮されることが予想されます。プロトコルでは適切なリース期間を決定するための自動方法が許可されていないため、サーバーの管理者はリース期間を調整する必要がある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-8--Obsolete-Locking-Infrastructure-from-NFSv4-0">
8.8. Obsolete Locking Infrastructure from NFSv4.0
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8. NFSv4.0から廃止されたロックインフラストラクチャ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are a number of operations and fields within existing operations that no longer have a function in NFSv4.1. In one way or another, these changes are all due to the implementation of sessions that provide client context and exactly once semantics as a base feature of the protocol, separate from locking itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1で機能しなくなった既存の操作には、いくつかの操作とフィールドがあります。いずれにせよ、これらの変更はすべて、クライアントコンテキストを提供するセッションの実装と、プロトコル自体のロックとは別に、プロトコルの基本機能として一度だけのセマンティクスによるものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following NFSv4.0 operations MUST NOT be implemented in NFSv4.1. The server MUST return NFS4ERR_NOTSUPP if these operations are found in an NFSv4.1 COMPOUND.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のNFSv4.0操作は、NFSv4.1で実装してはなりません（MUST NOT）。これらの操作がNFSv4.1 COMPOUNDで見つかった場合、サーバーはNFS4ERR_NOTSUPPを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SETCLIENTID since its function has been replaced by EXCHANGE_ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 関数がEXCHANGE_IDに置き換えられたため、SETCLIENTID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SETCLIENTID_CONFIRM since client ID confirmation now happens by means of CREATE_SESSION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SETCLIENTID_CONFIRM since client ID confirmation now happens by means of CREATE_SESSION.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN_CONFIRM because state-owner-based seqids have been replaced by the sequence ID in the SEQUENCE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN_CONFIRMは、状態所有者ベースのseqidがSEQUENCE操作でシーケンスIDに置き換えられたためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RELEASE_LOCKOWNER because lock-owners with no associated locks do not have any sequence-related state and so can be deleted by the server at will.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RELEASE_LOCKOWNERは、関連付けられたロックを持たないロック所有者にはシーケンス関連の状態がないため、サーバーが自由に削除できるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RENEW because every SEQUENCE operation for a session causes lease renewal, making a separate operation superfluous.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RENEWは、セッションのすべてのSEQUENCE操作がリースの更新を引き起こし、個別の操作が不要になるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Also, there are a number of fields, present in existing operations, related to locking that have no use in minor version 1. They were used in minor version 0 to perform functions now provided in a different fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、マイナーバージョン1では使用されないロックに関連する既存の操作に存在するフィールドがいくつかあります。これらのフィールドは、マイナーバージョン0で使用され、現在、異なる方法で提供される機能を実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Sequence ids used to sequence requests for a given state-owner and to provide retry protection, now provided via sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 特定の状態所有者の要求をシーケンス処理し、再試行保護を提供するために使用されるシーケンスID。現在はセッションを介して提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Client IDs used to identify the client associated with a given request. Client identification is now available using the client ID associated with the current session, without needing an explicit client ID field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 特定のリクエストに関連付けられたクライアントを識別するために使用されるクライアントID。クライアントIDは、明示的なクライアントIDフィールドを必要とせずに、現在のセッションに関連付けられたクライアントIDを使用して利用できるようになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Such vestigial fields in existing operations have no function in NFSv4.1 and are ignored by the server. Note that client IDs in operations new to NFSv4.1 (such as CREATE_SESSION and DESTROY_CLIENTID) are not ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
既存の操作のそのような痕跡フィールドはNFSv4.1では機能せず、サーバーによって無視されます。 NFSv4.1の新機能（CREATE_SESSIONやDESTROY_CLIENTIDなど）のクライアントIDは無視されないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--File-Locking-and-Share-Reservations">
9. File Locking and Share Reservations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. ファイルのロックと共有の予約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To support Win32 share reservations, it is necessary to provide operations that atomically open or create files. Having a separate share/unshare operation would not allow correct implementation of the Win32 OpenFile API. In order to correctly implement share semantics, the previous NFS protocol mechanisms used when a file is opened or created (LOOKUP, CREATE, ACCESS) need to be replaced. The NFSv4.1 protocol defines an OPEN operation that is capable of atomically looking up, creating, and locking a file on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Win32共有予約をサポートするには、アトミックにファイルを開いたり作成したりする操作を提供する必要があります。個別の共有/共有解除操作があると、Win32 OpenFile APIを正しく実装できません。共有セマンティクスを正しく実装するには、ファイルを開いたり作成したりするときに使用されていた以前のNFSプロトコルメカニズム（LOOKUP、CREATE、ACCESS）を置き換える必要があります。 NFSv4.1プロトコルは、サーバー上のファイルを自動的に検索、作成、およびロックできるOPEN操作を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1--Opens-and-Byte-Range-Locks">
9.1. Opens and Byte-Range Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. オープンおよびバイト範囲ロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is assumed that manipulating a byte-range lock is rare when compared to READ and WRITE operations. It is also assumed that server restarts and network partitions are relatively rare. Therefore, it is important that the READ and WRITE operations have a lightweight mechanism to indicate if they possess a held lock. A LOCK operation contains the heavyweight information required to establish a byte-range lock and uniquely define the owner of the lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READおよびWRITE操作と比較した場合、バイト範囲ロックの操作はまれであると想定されています。また、サーバーの再起動やネットワークのパーティション化は比較的まれであると想定されています。したがって、READおよびWRITE操作には、ロックが保持されているかどうかを示す軽量のメカニズムがあることが重要です。 LOCK操作には、バイト範囲のロックを確立し、ロックの所有者を一意に定義するために必要な重い情報が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1-1--State-Owner-Definition">
9.1.1. State-Owner Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.1. 国家所有者の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When opening a file or requesting a byte-range lock, the client must specify an identifier that represents the owner of the requested lock. This identifier is in the form of a state-owner, represented in the protocol by a state_owner4, a variable-length opaque array that, when concatenated with the current client ID, uniquely defines the owner of a lock managed by the client. This may be a thread ID, process ID, or other unique value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルを開くとき、またはバイト範囲のロックを要求するとき、クライアントは、要求されたロックの所有者を表す識別子を指定する必要があります。この識別子は状態所有者の形式であり、プロトコルではstate_owner4によって表されます。state_owner4は可変長の不透明な配列で、現在のクライアントIDと連結すると、クライアントが管理するロックの所有者を一意に定義します。これは、スレッドID、プロセスID、またはその他の一意の値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Owners of opens and owners of byte-range locks are separate entities and remain separate even if the same opaque arrays are used to designate owners of each. The protocol distinguishes between open-owners (represented by open_owner4 structures) and lock-owners (represented by lock_owner4 structures).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープンの所有者とバイト範囲ロックの所有者は別々のエンティティであり、同じ不透明な配列を使用してそれぞれの所有者を指定しても、別々のままです。プロトコルは、open-owners（open_owner4構造体で表される）とlock-owners（lock_owner4構造体で表される）を区別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each open is associated with a specific open-owner while each byte-range lock is associated with a lock-owner and an open-owner, the latter being the open-owner associated with the open file under which the LOCK operation was done. Delegations and layouts, on the other hand, are not associated with a specific owner but are associated with the client as a whole (identified by a client ID).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各オープンは特定のオープンオーナーに関連付けられていますが、各バイト範囲ロックは、ロックオーナーとオープンオーナーに関連付けられています。後者は、LOCK操作が実行されたオープンファイルに関連付けられたオープンオーナーです。一方、委任とレイアウトは特定の所有者には関連付けられていませんが、クライアント全体に関連付けられています（クライアントIDで識別されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1-2--Use-of-the-Stateid-and-Locking">
9.1.2. Use of the Stateid and Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.2. Stateidとロックの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All READ, WRITE, and SETATTR operations contain a stateid. For the purposes of this section, SETATTR operations that change the size attribute of a file are treated as if they are writing the area between the old and new sizes (i.e., the byte-range truncated or added to the file by means of the SETATTR), even where SETATTR is not explicitly mentioned in the text. The stateid passed to one of these operations must be one that represents an open, a set of byte-range locks, or a delegation, or it may be a special stateid representing anonymous access or the special bypass stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのREAD、WRITE、およびSETATTR操作には、stateidが含まれます。このセクションの目的のために、ファイルのサイズ属性を変更するSETATTR操作は、古いサイズと新しいサイズの間の領域を書き込むように扱われます（つまり、バイト範囲が切り捨てられるか、SETATTRによってファイルに追加されます） ）、SETATTRがテキストで明示的に言及されていない場合でも。これらの操作の1つに渡される状態IDは、オープン、バイト範囲ロックのセット、または委任を表すものでなければなりません。または、匿名アクセスを表す特別な状態IDまたは特別なバイパス状態IDである場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the state-owner performs a READ or WRITE operation in a situation in which it has established a byte-range lock or share reservation on the server (any OPEN constitutes a share reservation), the stateid (previously returned by the server) must be used to indicate what locks, including both byte-range locks and share reservations, are held by the state-owner. If no state is established by the client, either a byte-range lock or a share reservation, a special stateid for anonymous state (zero as the value for &#34;other&#34; and &#34;seqid&#34;) is used. (See Section 8.2.3 for a description of &#39;special&#39; stateids in general.) Regardless of whether a stateid for anonymous state or a stateid returned by the server is used, if there is a conflicting share reservation or mandatory byte-range lock held on the file, the server MUST refuse to service the READ or WRITE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態所有者がサーバーでバイト範囲ロックまたは共有予約を確立した状況でREADまたはWRITE操作を実行する場合（OPENは共有予約を構成します）、stateid（以前はサーバーによって返された）である必要があります。バイト範囲のロックと共有予約の両方を含むロックが状態所有者によって保持されていることを示すために使用されます。バイト範囲ロックまたは共有予約のいずれかの状態がクライアントによって確立されていない場合、匿名状態の特別なstateid（「other」および「seqid」の値としてゼロ）が使用されます。 （「特別な」stateidの一般的な説明については、セクション8.2.3を参照してください。）競合する共有予約または必須のバイト範囲ロックが保持されている場合、匿名状態のstateidとサーバーから返されるstateidのどちらを使用するかに関係なくファイルでは、サーバーはREADまたはWRITE操作のサービスを拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Share reservations are established by OPEN operations and by their nature are mandatory in that when the OPEN denies READ or WRITE operations, that denial results in such operations being rejected with error NFS4ERR_LOCKED. Byte-range locks may be implemented by the server as either mandatory or advisory, or the choice of mandatory or advisory behavior may be determined by the server on the basis of the file being accessed (for example, some UNIX-based servers support a &#34;mandatory lock bit&#34; on the mode attribute such that if set, byte-range locks are required on the file before I/O is possible). When byte-range locks are advisory, they only prevent the granting of conflicting lock requests and have no effect on READs or WRITEs. Mandatory byte-range locks, however, prevent conflicting I/O operations. When they are attempted, they are rejected with NFS4ERR_LOCKED. When the client gets NFS4ERR_LOCKED on a file for which it knows it has the proper share reservation, it will need to send a LOCK operation on the byte-range of the file that includes the byte-range the I/O was to be performed on, with an appropriate locktype field of the LOCK operation&#39;s arguments (i.e., READ*_LT for a READ operation, WRITE*_LT for a WRITE operation).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
共有の予約はOPEN操作によって確立され、OPEN操作がREADまたはWRITE操作を拒否すると、そのような操作がエラーNFS4ERR_LOCKEDで拒否されるという点で、OPEN予約によって確立されます。バイト範囲ロックは、サーバーによって必須または助言として実装される場合があります。または、必須または助言の動作の選択は、アクセスされるファイルに基づいてサーバーによって決定される場合があります（たとえば、一部のUNIXベースのサーバーは「必須のロックビット」が設定されている場合は、I / Oが可能になる前にファイルにバイト範囲のロックが必要になります。バイト範囲ロックが助言である場合、それらは競合するロック要求の許可を防ぐだけで、READまたはWRITEには影響を与えません。ただし、必須のバイト範囲ロックは、I / O操作の競合を防ぎます。試行された場合、NFS4ERR_LOCKEDで拒否されます。クライアントは、適切な共有予約があることがわかっているファイルでNFS4ERR_LOCKEDを取得すると、I / Oが実行されるバイト範囲を含むファイルのバイト範囲でLOCK操作を送信する必要があります。 、LOCK操作の引数の適切なlocktypeフィールド（つまり、READ操作の場合はREAD * _LT、WRITE操作の場合はWRITE * _LT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that for UNIX environments that support mandatory byte-range locking, the distinction between advisory and mandatory locking is subtle. In fact, advisory and mandatory byte-range locks are exactly the same as far as the APIs and requirements on implementation. If the mandatory lock attribute is set on the file, the server checks to see if the lock-owner has an appropriate shared (READ_LT) or exclusive (WRITE_LT) byte-range lock on the byte-range it wishes to READ from or WRITE to. If there is no appropriate lock, the server checks if there is a conflicting lock (which can be done by attempting to acquire the conflicting lock on behalf of the lock-owner, and if successful, release the lock after the READ or WRITE operation is done), and if there is, the server returns NFS4ERR_LOCKED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須のバイト範囲ロックをサポートするUNIX環境の場合、アドバイザリロックと必須ロックの違いは微妙です。実際、推奨および必須のバイト範囲ロックは、APIと実装の要件に関してはまったく同じです。必須のロック属性がファイルに設定されている場合、サーバーは、ロック所有者が読み取りまたは書き込み先のバイト範囲に適切な共有（READ_LT）または排他（WRITE_LT）バイト範囲ロックを持っているかどうかを確認します。適切なロックがない場合、サーバーは競合するロックがあるかどうかをチェックします（これは、ロック所有者の代わりに競合するロックを取得しようとすることで実行できます）。成功した場合は、READまたはWRITE操作の後にロックを解放します完了）、および存在する場合、サーバーはNFS4ERR_LOCKEDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For Windows environments, byte-range locks are always mandatory, so the server always checks for byte-range locks during I/O requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For Windows environments, byte-range locks are always mandatory, so the server always checks for byte-range locks during I/O requests.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, the LOCK operation does not need to distinguish between advisory and mandatory byte-range locks. It is the server&#39;s processing of the READ and WRITE operations that introduces the distinction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、LOCK操作では、推奨ロックと必須バイト範囲ロックを区別する必要はありません。違いを導入するのは、サーバーによるREADおよびWRITE操作の処理です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every stateid that is validly passed to READ, WRITE, or SETATTR, with the exception of special stateid values, defines an access mode for the file (i.e., OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every stateid that is validly passed to READ, WRITE, or SETATTR, with the exception of special stateid values, defines an access mode for the file (i.e., OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH).
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For stateids associated with opens, this is the mode defined by the original OPEN that caused the allocation of the OPEN stateid and as modified by subsequent OPENs and OPEN_DOWNGRADEs for the same open-owner/file pair.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o オープンに関連付けられたステートIDの場合、これは、OPENステートIDの割り当てを引き起こした元のOPENによって定義され、同じオープンオーナー/ファイルペアの後続のOPENおよびOPEN_DOWNGRADEによって変更されたモードです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For stateids returned by byte-range LOCK operations, the appropriate mode is the access mode for the OPEN stateid associated with the lock set represented by the stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイト範囲のLOCK操作によって返されるステートIDの場合、適切なモードは、stateidで表されるロックセットに関連付けられたOPENステートIDのアクセスモードです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For delegation stateids, the access mode is based on the type of delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 委任状態IDの場合、アクセスモードは委任のタイプに基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a READ, WRITE, or SETATTR (that specifies the size attribute) operation is done, the operation is subject to checking against the access mode to verify that the operation is appropriate given the stateid with which the operation is associated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ、WRITE、またはSETATTR（サイズ属性を指定する）操作が実行されると、操作は、アクセスモードに対してチェックされ、操作が関連付けられている状態IDが指定されている場合、操作が適切であることを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of WRITE-type operations (i.e., WRITEs and SETATTRs that set size), the server MUST verify that the access mode allows writing and MUST return an NFS4ERR_OPENMODE error if it does not. In the case of READ, the server may perform the corresponding check on the access mode, or it may choose to allow READ on OPENs for OPEN4_SHARE_ACCESS_WRITE, to accommodate clients whose WRITE implementation may unavoidably do reads (e.g., due to buffer cache constraints). However, even if READs are allowed in these circumstances, the server MUST still check for locks that conflict with the READ (e.g., another OPEN specified OPEN4_SHARE_DENY_READ or OPEN4_SHARE_DENY_BOTH). Note that a server that does enforce the access mode check on READs need not explicitly check for conflicting share reservations since the existence of OPEN for OPEN4_SHARE_ACCESS_READ guarantees that no conflicting share reservation can exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITEタイプの操作（つまり、サイズを設定するWRITEおよびSETATTR）の場合、サーバーはアクセスモードが書き込みを許可していることを確認し、許可していない場合はNFS4ERR_OPENMODEエラーを返す必要があります。 READの場合、サーバーはアクセスモードで対応するチェックを実行するか、OPEN4_SHARE_ACCESS_WRITEのOPENでREADを許可して、WRITE実装が読み取りを不可避に実行する可能性があるクライアントに対応します（たとえば、バッファーキャッシュの制約のため）。ただし、これらの状況でREADが許可されている場合でも、サーバーはREADと競合するロックを確認する必要があります（たとえば、別のOPENで指定されたOPEN4_SHARE_DENY_READまたはOPEN4_SHARE_DENY_BOTH）。 OPEN4_SHARE_ACCESS_READにOPENが存在すると、競合する共有予約が存在しないことが保証されるため、READでアクセスモードチェックを実行するサーバーは、競合する共有予約を明示的に確認する必要がないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READ bypass special stateid (all bits of &#34;other&#34; and &#34;seqid&#34; set to one) indicates a desire to bypass locking checks. The server MAY allow READ operations to bypass locking checks at the server, when this special stateid is used. However, WRITE operations with this special stateid value MUST NOT bypass locking checks and are treated exactly the same as if a special stateid for anonymous state were used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READバイパスの特別なstateid（「other」および「seqid」のすべてのビットが1に設定されている）は、ロックチェックをバイパスしたいことを示します。サーバーは、この特別な状態IDが使用されている場合、READ操作でサーバーでのロックチェックをバイパスすることを許可する場合があります。ただし、この特別なstateid値を持つWRITE操作は、ロックチェックをバイパスしてはならず（MUST NOT）、匿名状態の特別なstateidが使用された場合とまったく同じように扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A lock may not be granted while a READ or WRITE operation using one of the special stateids is being performed and the scope of the lock to be granted would conflict with the READ or WRITE operation. This can occur when:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特別な状態IDの1つを使用するREADまたはWRITE操作が実行されている間はロックが許可されず、許可されるロックのスコープがREADまたはWRITE操作と競合する可能性があります。これは次の場合に発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A mandatory byte-range lock is requested with a byte-range that conflicts with the byte-range of the READ or WRITE operation. For the purposes of this paragraph, a conflict occurs when a shared lock is requested and a WRITE operation is being performed, or an exclusive lock is requested and either a READ or a WRITE operation is being performed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 必須のバイト範囲ロックは、READまたはWRITE操作のバイト範囲と競合するバイト範囲で要求されます。この段落では、共有ロックが要求されて書き込み操作が実行されているとき、または排他ロックが要求されて読み取り操作または書き込み操作が実行されているときに競合が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A share reservation is requested that denies reading and/or writing and the corresponding operation is being performed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 読み取りおよび/または書き込みを拒否する共有予約が要求され、対応する操作が実行されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A delegation is to be granted and the delegation type would prevent the I/O operation, i.e., READ and WRITE conflict with an OPEN_DELEGATE_WRITE delegation and WRITE conflicts with an OPEN_DELEGATE_READ delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 委任が許可され、その委任の種類によってI / O操作が防止されます。つまり、READおよびWRITEがOPEN_DELEGATE_WRITE委任と競合し、WRITEがOPEN_DELEGATE_READ委任と競合します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When a client holds a delegation, it needs to ensure that the stateid sent conveys the association of operation with the delegation, to avoid the delegation from being avoidably recalled. When the delegation stateid, a stateid open associated with that delegation, or a stateid representing byte-range locks derived from such an open is used, the server knows that the READ, WRITE, or SETATTR does not conflict with the delegation but is sent under the aegis of the delegation. Even though it is possible for the server to determine from the client ID (via the session ID) that the client does in fact have a delegation, the server is not obliged to check this, so using a special stateid can result in avoidable recall of the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントが委任を保持している場合、送信されたステートIDが操作と委任の関連付けを確実に伝え、委譲が避けられないようにリコールされるのを防ぐ必要があります。委任状態ID、その委任に関連付けられた状態IDオープン、またはそのようなオープンから派生したバイト範囲ロックを表す状態IDが使用される場合、サーバーは、READ、WRITE、またはSETATTRが委任と競合しないが、以下で送信されることを認識します。代表団の庇護。サーバーが（セッションIDを介して）クライアントIDからクライアントが実際に委任を持っていると判断することは可能ですが、サーバーはこれをチェックする義務がないため、特別な状態IDを使用すると、代表団。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2--Lock-Ranges">
9.2. Lock Ranges
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. ロック範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol allows a lock-owner to request a lock with a byte-range and then either upgrade, downgrade, or unlock a sub-range of the initial lock, or a byte-range that overlaps -- fully or partially -- either with that initial lock or a combination of a set of existing locks for the same lock-owner. It is expected that this will be an uncommon type of request. In any case, servers or server file systems may not be able to support sub-range lock semantics. In the event that a server receives a locking request that represents a sub-range of current locking state for the lock-owner, the server is allowed to return the error NFS4ERR_LOCK_RANGE to signify that it does not support sub-range lock operations. Therefore, the client should be prepared to receive this error and, if appropriate, report the error to the requesting application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルでは、ロック所有者がバイト範囲のロックを要求してから、初期ロックのサブ範囲、または完全にまたは部分的にオーバーラップするバイト範囲のアップグレード、ダウングレード、またはロック解除を行うことができます。その初期ロック、または同じロック所有者の既存のロックのセットの組み合わせ。これは珍しいタイプのリクエストになると予想されます。いずれの場合も、サーバーまたはサーバーファイルシステムは、サブレンジロックセマンティクスをサポートできない場合があります。サーバーがロック所有者の現在のロック状態のサブ範囲を表すロック要求を受信した場合、サーバーはエラーNFS4ERR_LOCK_RANGEを返して、サブ範囲のロック操作をサポートしていないことを示すことができます。したがって、クライアントはこのエラーを受信する準備をして、必要に応じて、要求元のアプリケーションにエラーを報告する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client is discouraged from combining multiple independent locking ranges that happen to be adjacent into a single request since the server may not support sub-range requests for reasons related to the recovery of byte-range locking state in the event of server failure. As discussed in Section 8.4.2, the server may employ certain optimizations during recovery that work effectively only when the client&#39;s behavior during lock recovery is similar to the client&#39;s locking behavior prior to server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、サーバーに障害が発生した場合のバイト範囲のロック状態の回復に関連する理由により、サーバーがサブ範囲のリクエストをサポートしない場合があるため、クライアントは、偶然に隣接する複数の独立したロック範囲を1つのリクエストに結合しないようにしてください。 8.4.2項で説明したように、サーバーは、ロック回復中のクライアントの動作がサーバー障害前のクライアントのロック動作と類似している場合にのみ効果的に機能する特定の最適化を回復中に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3--Upgrading-and-Downgrading-Locks">
9.3. Upgrading and Downgrading Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. ロックのアップグレードとダウングレード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client has a WRITE_LT lock on a byte-range, it can request an atomic downgrade of the lock to a READ_LT lock via the LOCK operation, by setting the type to READ_LT. If the server supports atomic downgrade, the request will succeed. If not, it will return NFS4ERR_LOCK_NOTSUPP. The client should be prepared to receive this error and, if appropriate, report the error to the requesting application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがバイト範囲にWRITE_LTロックを持っている場合、タイプをREAD_LTに設定することにより、LOCK操作を介してREAD_LTロックへのアトミックなダウングレードを要求できます。サーバーがアトミックダウングレードをサポートしている場合、リクエストは成功します。そうでない場合は、NFS4ERR_LOCK_NOTSUPPを返します。クライアントは、このエラーを受信する準備をして、必要に応じて、要求元のアプリケーションにエラーを報告する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If a client has a READ_LT lock on a byte-range, it can request an atomic upgrade of the lock to a WRITE_LT lock via the LOCK operation by setting the type to WRITE_LT or WRITEW_LT. If the server does not support atomic upgrade, it will return NFS4ERR_LOCK_NOTSUPP. If the upgrade can be achieved without an existing conflict, the request will succeed. Otherwise, the server will return either NFS4ERR_DENIED or NFS4ERR_DEADLOCK. The error NFS4ERR_DEADLOCK is returned if the client sent the LOCK operation with the type set to WRITEW_LT and the server has detected a deadlock. The client should be prepared to receive such errors and, if appropriate, report the error to the requesting application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントがバイト範囲にREAD_LTロックを持っている場合、タイプをWRITE_LTまたはWRITEW_LTに設定することにより、LOCK操作を介してロックのWRITE_LTロックへのアトミックアップグレードを要求できます。サーバーがアトミックアップグレードをサポートしていない場合、サーバーはNFS4ERR_LOCK_NOTSUPPを返します。既存の競合なしでアップグレードを達成できる場合、要求は成功します。それ以外の場合、サーバーはNFS4ERR_DENIEDまたはNFS4ERR_DEADLOCKを返します。クライアントがタイプをWRITEW_LTに設定してLOCK操作を送信し、サーバーがデッドロックを検出した場合、エラーNFS4ERR_DEADLOCKが返されます。クライアントは、このようなエラーを受け取る準備をして、必要に応じて、要求元のアプリケーションにエラーを報告する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4--Stateid-Seqid-Values-and-Byte-Range-Locks">
9.4. Stateid Seqid Values and Byte-Range Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. Stateid Seqid値とバイト範囲ロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a LOCK or LOCKU operation is performed, the stateid returned has the same &#34;other&#34; value as the argument&#39;s stateid, and a &#34;seqid&#34; value that is incremented (relative to the argument&#39;s stateid) to reflect the occurrence of the LOCK or LOCKU operation. The server MUST increment the value of the &#34;seqid&#34; field whenever there is any change to the locking status of any byte offset as described by any of the locks covered by the stateid. A change in locking status includes a change from locked to unlocked or the reverse or a change from being locked for READ_LT to being locked for WRITE_LT or the reverse.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKまたはLOCKU操作が実行されると、返されるstateidは、引数のstateidと同じ「other」値と、LOCKまたはLOCKU操作の発生を反映するために（引数のstateidに対して）増分される「seqid」値を持ちます。 。 stateidの対象となるロックのいずれかで記述されているように、バイトオフセットのロックステータスに変更がある場合は常に、サーバーは「seqid」フィールドの値をインクリメントする必要があります。ロック状態の変更には、ロックからロック解除またはその逆への変更、またはREAD_LTのロックからWRITE_LTまたはその逆のロックへの変更が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When there is no such change, as, for example, when a range already locked for WRITE_LT is locked again for WRITE_LT, the server MAY increment the &#34;seqid&#34; value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような変更がない場合、たとえば、すでにWRITE_LTに対してロックされている範囲がWRITE_LTに対して再度ロックされている場合など、サーバーは「seqid」値をインクリメントできます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-5--Issues-with-Multiple-Open-Owners">
9.5. Issues with Multiple Open-Owners
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5. 複数のオープンオーナーの問題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the same file is opened by multiple open-owners, a client will have multiple OPEN stateids for that file, each associated with a different open-owner. In that case, there can be multiple LOCK and LOCKU requests for the same lock-owner sent using the different OPEN stateids, and so a situation may arise in which there are multiple stateids, each representing byte-range locks on the same file and held by the same lock-owner but each associated with a different open-owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じファイルが複数のオープンオーナーによって開かれると、クライアントはそのファイルに対して複数のOPENステートIDを持ち、それぞれが異なるオープンオーナーに関連付けられます。その場合、異なるOPENステートIDを使用して送信された同じロック所有者に対する複数のLOCKおよびLOCKUリクエストが存在する可能性があるため、複数のステートIDがあり、それぞれが同じファイルのバイト範囲ロックを表し、保持されているという状況が発生する可能性があります。同じロック所有者によるが、それぞれが異なるオープン所有者に関連付けられている。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In such a situation, the locking status of each byte (i.e., whether it is locked, the READ_LT or WRITE_LT type of the lock, and the lock-owner holding the lock) MUST reflect the last LOCK or LOCKU operation done for the lock-owner in question, independent of the stateid through which the request was sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような状況では、各バイトのロック状態（つまり、ロックされているかどうか、ロックのREAD_LTまたはWRITE_LTタイプ、およびロックを保持しているロック所有者）は、ロックに対して行われた最後のLOCKまたはLOCKU操作を反映する必要があります。リクエストの送信に使用された状態IDとは関係なく、問題の所有者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When a byte is locked by the lock-owner in question, the open-owner to which that byte-range lock is assigned SHOULD be that of the open-owner associated with the stateid through which the last LOCK of that byte was done. When there is a change in the open-owner associated with locks for the stateid through which a LOCK or LOCKU was done, the &#34;seqid&#34; field of the stateid MUST be incremented, even if the locking, in terms of lock-owners has not changed. When there is a change to the set of locked bytes associated with a different stateid for the same lock-owner, i.e., associated with a different open-owner, the &#34;seqid&#34; value for that stateid MUST NOT be incremented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
問題のロック所有者によってバイトがロックされている場合、そのバイト範囲ロックが割り当てられるオープン所有者は、そのバイトの最後のLOCKが実行された状態IDに関連付けられたオープン所有者のものでなければなりません（SHOULD）。 LOCKまたはLOCKUが実行されたstateidのロックに関連付けられたopen-ownerに変更がある場合、ロック所有者の観点からは、ロックが行われていない場合でも、stateidの「seqid」フィールドをインクリメントする必要があります。かわった。同じロック所有者の別の状態IDに関連付けられた、つまり別のオープン所有者に関連付けられたロックされたバイトのセットに変更がある場合、その状態IDの「seqid」値はインクリメントしてはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-6--Blocking-Locks">
9.6. Blocking Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6. ロックのブロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some clients require the support of blocking locks. While NFSv4.1 provides a callback when a previously unavailable lock becomes available, this is an OPTIONAL feature and clients cannot depend on its presence. Clients need to be prepared to continually poll for the lock. This presents a fairness problem. Two of the lock types, READW_LT and WRITEW_LT, are used to indicate to the server that the client is requesting a blocking lock. When the callback is not used, the server should maintain an ordered list of pending blocking locks. When the conflicting lock is released, the server may wait for the period of time equal to lease_time for the first waiting client to re-request the lock. After the lease period expires, the next waiting client request is allowed the lock. Clients are required to poll at an interval sufficiently small that it is likely to acquire the lock in a timely manner. The server is not required to maintain a list of pending blocked locks as it is used to increase fairness and not correct operation. Because of the unordered nature of crash recovery, storing of lock state to stable storage would be required to guarantee ordered granting of blocking locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のクライアントでは、ブロックロックのサポートが必要です。 NFSv4.1は、以前は利用できなかったロックが利用可能になったときにコールバックを提供しますが、これはオプション機能であり、クライアントはその存在に依存できません。クライアントは、ロックを継続的にポーリングする準備をする必要があります。これは公平性の問題を示します。 READW_LTとWRITEW_LTの2つのロックタイプは、クライアントがブロッキングロックを要求していることをサーバーに示すために使用されます。コールバックを使用しない場合、サーバーは保留中のブロッキングロックの順序付きリストを維持する必要があります。競合するロックが解放されると、サーバーは、最初の待機中のクライアントがロックを再要求するまで、lease_timeに等しい時間待機する場合があります。リース期間が終了すると、次の待機中のクライアント要求にロックが許可されます。クライアントは、適時にロックを取得する可能性が高いほど十分に短い間隔でポーリングする必要があります。サーバーは、公平性を高めるために使用され、正しい操作ではないため、保留中のブロックされたロックのリストを維持する必要はありません。クラッシュリカバリの順序付けされていない性質のため、ブロックされたロックの順序付けられた許可を保証するには、ロック状態を安定したストレージに保存する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers may also note the lock types and delay returning denial of the request to allow extra time for a conflicting lock to be released, allowing a successful return. In this way, clients can avoid the burden of needless frequent polling for blocking locks. The server should take care in the length of delay in the event the client retransmits the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ロックのタイプを記録し、要求の拒否の拒否を遅らせて、競合するロックが解放されるまでの時間を追加して、正常な戻りを可能にすることもできます。このようにして、クライアントはロックをブロックするための不必要な頻繁なポーリングの負担を回避できます。サーバーは、クライアントが要求を再送信する場合の遅延時間に注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server receives a blocking LOCK operation, denies it, and then later receives a nonblocking request for the same lock, which is also denied, then it should remove the lock in question from its list of pending blocking locks. Clients should use such a nonblocking request to indicate to the server that this is the last time they intend to poll for the lock, as may happen when the process requesting the lock is interrupted. This is a courtesy to the server, to prevent it from unnecessarily waiting a lease period before granting other LOCK operations. However, clients are not required to perform this courtesy, and servers must not depend on them doing so. Also, clients must be prepared for the possibility that this final locking request will be accepted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがブロッキングLOCK操作を受け取り、それを拒否し、その後同じロックに対する非ブロッキング要求を受け取った場合も拒否されますが、その場合、保留中のブロッキングロックのリストから問題のロックを削除する必要があります。クライアントは、このような非ブロッキング要求を使用して、ロックを要求するプロセスが中断された場合に発生する可能性があるように、これがロックをポーリングする最後の時刻であることをサーバーに示す必要があります。これは、他のLOCK操作を許可する前にリース期間を不必要に待機しないようにするためのサーバーの礼儀です。ただし、クライアントはこの礼儀を実行する必要はなく、サーバーはクライアントに依存することはできません。また、クライアントは、この最後のロック要求が受け入れられる可能性に備える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When a server indicates, via the flag OPEN4_RESULT_MAY_NOTIFY_LOCK, that CB_NOTIFY_LOCK callbacks might be done for the current open file, the client should take notice of this, but, since this is a hint, cannot rely on a CB_NOTIFY_LOCK always being done. A client may reasonably reduce the frequency with which it polls for a denied lock, since the greater latency that might occur is likely to be eliminated given a prompt callback, but it still needs to poll. When it receives a CB_NOTIFY_LOCK, it should promptly try to obtain the lock, but it should be aware that other clients may be polling and that the server is under no obligation to reserve the lock for that particular client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーがフラグOPEN4_RESULT_MAY_NOTIFY_LOCKを介して、現在開いているファイルに対してCB_NOTIFY_LOCKコールバックが行われる可能性があることを示した場合、クライアントはこれに気付く必要がありますが、これはヒントなので、常に行われているCB_NOTIFY_LOCKに依存することはできません。クライアントは、拒否されたロックをポーリングする頻度を合理的に減らす可能性があります。これは、発生する可能性のある大きなレイテンシは、迅速なコールバックによって解消される可能性が高いためですが、ポーリングする必要があります。 CB_NOTIFY_LOCKを受信すると、すぐにロックを取得しようとしますが、他のクライアントがポーリングしている可能性があり、サーバーがその特定のクライアントのためにロックを予約する義務がないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-7--Share-Reservations">
9.7. Share Reservations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.7. 予約を共有する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A share reservation is a mechanism to control access to a file. It is a separate and independent mechanism from byte-range locking. When a client opens a file, it sends an OPEN operation to the server specifying the type of access required (READ, WRITE, or BOTH) and the type of access to deny others (OPEN4_SHARE_DENY_NONE, OPEN4_SHARE_DENY_READ, OPEN4_SHARE_DENY_WRITE, or OPEN4_SHARE_DENY_BOTH). If the OPEN fails, the client will fail the application&#39;s open request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有予約は、ファイルへのアクセスを制御するメカニズムです。これは、バイト範囲ロックとは別の独立したメカニズムです。クライアントがファイルを開くと、必要なアクセスの種類（READ、WRITE、またはBOTH）と他のアクセスを拒否するアクセスの種類（OPEN4_SHARE_DENY_NONE、OPEN4_SHARE_DENY_WRITE、またはOPEN4_SHARE_DENY_BOTH）を指定して、OPEN操作をサーバーに送信します。 OPENが失敗すると、クライアントはアプリケーションのオープンリクエストに失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pseudo-code definition of the semantics:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セマンティクスの疑似コード定義：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (request.access == 0) {
             return (NFS4ERR_INVAL)
           } else {
             if ((request.access &amp; file_state.deny)) ||
                (request.deny &amp; file_state.access)) {
               return (NFS4ERR_SHARE_DENIED)
           }
           return (NFS4ERR_OK);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When doing this checking of share reservations on OPEN, the current file_state used in the algorithm includes bits that reflect all current opens, including those for the open-owner making the new OPEN request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENで共有予約のこのチェックを行う場合、アルゴリズムで使用される現在のfile_stateには、新しいOPEN要求を行うopen-ownerのビットを含む、現在のすべてのオープンを反映するビットが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The constants used for the OPEN and OPEN_DOWNGRADE operations for the access and deny fields are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセスおよび拒否フィールドのOPENおよびOPEN_DOWNGRADE操作に使用される定数は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const OPEN4_SHARE_ACCESS_READ   = 0x00000001;
   const OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;
   const OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const OPEN4_SHARE_DENY_NONE     = 0x00000000;
   const OPEN4_SHARE_DENY_READ     = 0x00000001;
   const OPEN4_SHARE_DENY_WRITE    = 0x00000002;
   const OPEN4_SHARE_DENY_BOTH     = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-8--OPENCLOSE-Operations">
9.8. OPEN/CLOSE Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.8. OPEN / CLOSE操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide correct share semantics, a client MUST use the OPEN operation to obtain the initial filehandle and indicate the desired access and what access, if any, to deny. Even if the client intends to use a special stateid for anonymous state or READ bypass, it must still obtain the filehandle for the regular file with the OPEN operation so the appropriate share semantics can be applied. Clients that do not have a deny mode built into their programming interfaces for opening a file should request a deny mode of OPEN4_SHARE_DENY_NONE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正しい共有セマンティクスを提供するには、クライアントはOPEN操作を使用して初期ファイルハンドルを取得し、必要なアクセスと拒否するアクセス（ある場合）を示す必要があります。クライアントが匿名状態またはREADバイパスに特別な状態IDを使用する場合でも、適切な共有セマンティクスを適用できるように、OPEN操作で通常のファイルのファイルハンドルを取得する必要があります。ファイルを開くためのプログラミングインターフェイスに拒否モードが組み込まれていないクライアントは、OPEN4_SHARE_DENY_NONEの拒否モードを要求する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPEN operation with the CREATE flag also subsumes the CREATE operation for regular files as used in previous versions of the NFS protocol. This allows a create with a share to be done atomically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATEフラグを指定したOPEN操作は、NFSプロトコルの以前のバージョンで使用されていた通常のファイルのCREATE操作も含みます。これにより、共有を使用した作成をアトミックに実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CLOSE operation removes all share reservations held by the open-owner on that file. If byte-range locks are held, the client SHOULD release all locks before sending a CLOSE operation. The server MAY free all outstanding locks on CLOSE, but some servers may not support the CLOSE of a file that still has byte-range locks held. The server MUST return failure, NFS4ERR_LOCKS_HELD, if any locks would exist after the CLOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSE操作は、そのファイルのオープンオーナーによって保持されているすべての共有予約を削除します。バイト範囲のロックが保持されている場合、クライアントはCLOSE操作を送信する前にすべてのロックを解放する必要があります（SHOULD）。サーバーはCLOSEですべての未解決のロックを解放してもかまいませんが、一部のサーバーは、バイト範囲ロックが保持されているファイルのCLOSEをサポートしない場合があります。 CLOSEの後にロックが存在する場合、サーバーは失敗、NFS4ERR_LOCKS_HELDを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOOKUP operation will return a filehandle without establishing any lock state on the server. Without a valid stateid, the server will assume that the client has the least access. For example, if one client opened a file with OPEN4_SHARE_DENY_BOTH and another client accesses the file via a filehandle obtained through LOOKUP, the second client could only read the file using the special read bypass stateid. The second client could not WRITE the file at all because it would not have a valid stateid from OPEN and the special anonymous stateid would not be allowed access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOOKUP操作は、サーバーでロック状態を確立せずにファイルハンドルを返します。有効な状態IDがない場合、サーバーはクライアントのアクセスが最小であると想定します。たとえば、あるクライアントがOPEN4_SHARE_DENY_BOTHを使用してファイルを開き、別のクライアントがLOOKUPを通じて取得したファイルハンドルを介してファイルにアクセスした場合、2番目のクライアントは特別な読み取りバイパス状態IDを使用してのみファイルを読み取ることができます。 OPENからの有効な状態IDがなく、特別な匿名の状態IDがアクセスを許可されていないため、2番目のクライアントはファイルをまったく書き込むことができませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-9--Open-Upgrade-and-Downgrade">
9.9. Open Upgrade and Downgrade
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.9. オープンアップグレードとダウングレード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When an OPEN is done for a file and the open-owner for which the OPEN is being done already has the file open, the result is to upgrade the open file status maintained on the server to include the access and deny bits specified by the new OPEN as well as those for the existing OPEN. The result is that there is one open file, as far as the protocol is concerned, and it includes the union of the access and deny bits for all of the OPEN requests completed. The OPEN is represented by a single stateid whose &#34;other&#34; value matches that of the original open, and whose &#34;seqid&#34; value is incremented to reflect the occurrence of the upgrade. The increment is required in cases in which the &#34;upgrade&#34; results in no change to the open mode (e.g., an OPEN is done for read when the existing open file is opened for OPEN4_SHARE_ACCESS_BOTH). Only a single CLOSE will be done to reset the effects of both OPENs. The client may use the stateid returned by the OPEN effecting the upgrade or with a stateid sharing the same &#34;other&#34; field and a seqid of zero, although care needs to be taken as far as upgrades that happen while the CLOSE is pending. Note that the client, when sending the OPEN, may not know that the same file is in fact being opened. The above only applies if both OPENs result in the OPENed object being designated by the same filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ファイルに対してOPENが実行され、OPENが実行されているopen-ownerがすでにファイルを開いている場合、その結果は、サーバーで維持されているオープンファイルのステータスをアップグレードして、新しいファイルで指定されたアクセスおよび拒否ビットを含めることです。 OPENおよび既存のOPENのOPEN。その結果、プロトコルに関する限り、1つのオープンファイルがあり、完了したすべてのOPEN要求のアクセスおよび拒否ビットの結合が含まれます。 OPENは、「other」の値が元のオープンの値と一致し、アップグレードの発生を反映するために「seqid」の値が増加する単一のstateidで表されます。 「アップグレード」によってオープンモードが変更されない場合（たとえば、既存のオープンファイルがOPEN4_SHARE_ACCESS_BOTH用に開かれるときに、読み取りのためにOPENが実行される場合）、増分が必要です。両方のOPENの影響をリセットするために、単一のCLOSEのみが実行されます。クライアントは、OPENによって返された状態IDを使用してアップグレードを実行するか、同じ「その他」フィールドとゼロのseqidを共有する状態IDを使用できますが、CLOSEが保留中のアップグレードについては注意が必要です。クライアントは、OPENを送信するときに、同じファイルが実際に開かれていることを知らない場合があることに注意してください。上記は、両方のOPENの結果、OPENedオブジェクトが同じファイルハンドルによって指定される場合にのみ適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server chooses to export multiple filehandles corresponding to the same file object and returns different filehandles on two different OPENs of the same file object, the server MUST NOT &#34;OR&#34; together the access and deny bits and coalesce the two open files. Instead, the server must maintain separate OPENs with separate stateids and will require separate CLOSEs to free them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが同じファイルオブジェクトに対応する複数のファイルハンドルをエクスポートすることを選択し、同じファイルオブジェクトの2つの異なるOPENで異なるファイルハンドルを返す場合、サーバーはアクセスと拒否ビットを一緒に「OR」して、2つの開いているファイルを結合してはなりません（MUST NOT）。代わりに、サーバーは個別の状態IDを持つ個別のOPENを維持する必要があり、それらを解放するには個別のCLOSEが必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When multiple open files on the client are merged into a single OPEN file object on the server, the close of one of the open files (on the client) may necessitate change of the access and deny status of the open file on the server. This is because the union of the access and deny bits for the remaining opens may be smaller (i.e., a proper subset) than previously. The OPEN_DOWNGRADE operation is used to make the necessary change and the client should use it to update the server so that share reservation requests by other clients are handled properly. The stateid returned has the same &#34;other&#34; field as that passed to the server. The &#34;seqid&#34; value in the returned stateid MUST be incremented, even in situations in which there is no change to the access and deny bits for the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント上の複数のオープンファイルがサーバー上の単一のOPENファイルオブジェクトにマージされる場合、（クライアント上の）オープンファイルの1つを閉じると、アクセスの変更とサーバー上のオープンファイルのステータスの拒否が必要になる場合があります。これは、残りのオープンのアクセスおよび拒否ビットの和集合が以前よりも小さい（つまり、適切なサブセットである）可能性があるためです。 OPEN_DOWNGRADE操作は必要な変更を行うために使用され、クライアントはそれを使用してサーバーを更新し、他のクライアントによる共有予約要求が適切に処理されるようにする必要があります。返された状態IDには、サーバーに渡されたものと同じ「その他」フィールドがあります。返されたstateidの「seqid」値は、ファイルのアクセスおよび拒否ビットに変更がない状況でもインクリメントする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-10--Parallel-OPENs">
9.10. Parallel OPENs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.10. 並列OPEN
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike the case of NFSv4.0, in which OPEN operations for the same open-owner are inherently serialized because of the owner-based seqid, multiple OPENs for the same open-owner may be done in parallel. When clients do this, they may encounter situations in which, because of the existence of hard links, two OPEN operations may turn out to open the same file, with a later OPEN performed being an upgrade of the first, with this fact only visible to the client once the operations complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者ベースのseqidにより、同じオープン所有者に対するOPEN操作が本質的にシリアル化されるNFSv4.0の場合とは異なり、同じオープン所有者に対する複数のOPENは並行して実行できます。クライアントがこれを行うと、ハードリンクが存在するために、2つのOPEN操作が同じファイルを開くことが判明し、後で実行されるOPENが最初のアップグレードであるという状況に遭遇する可能性があります。操作が完了するとクライアント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this situation, clients may determine the order in which the OPENs were performed by examining the stateids returned by the OPENs. Stateids that share a common value of the &#34;other&#34; field can be recognized as having opened the same file, with the order of the operations determinable from the order of the &#34;seqid&#34; fields, mod any possible wraparound of the 32-bit field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この状況では、クライアントは、OPENによって返された状態IDを調べることにより、OPENが実行された順序を判断できます。 「other」フィールドの共通値を共有するStateidは、「seqid」フィールドの順序から決定できる操作の順序で、同じファイルを開いたと認識でき、32ビットフィールドの可能なラップアラウンドを変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the possibility exists that the client will send multiple OPENs for the same open-owner in parallel, it may be the case that an open upgrade may happen without the client knowing beforehand that this could happen. Because of this possibility, CLOSEs and OPEN_DOWNGRADEs should generally be sent with a non-zero seqid in the stateid, to avoid the possibility that the status change associated with an open upgrade is not inadvertently lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが同じオープンオーナーに対して複数のOPENを並行して送信する可能性がある場合、クライアントが事前にこれが発生する可能性があることを知らずにオープンアップグレードが発生する可能性があります。この可能性があるため、通常、CLOSEとOPEN_DOWNGRADEは、開いているアップグレードに関連するステータス変更が誤って失われない可能性を回避するために、stateidにゼロ以外のseqidを指定して送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-11--Reclaim-of-Open-and-Byte-Range-Locks">
9.11. Reclaim of Open and Byte-Range Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.11. オープンロックとバイト範囲ロックの再利用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Special forms of the LOCK and OPEN operations are provided when it is necessary to re-establish byte-range locks or opens after a server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKおよびOPEN操作の特殊な形式は、サーバーの障害後にバイト範囲ロックまたはオープンを再確立する必要がある場合に提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To reclaim existing opens, an OPEN operation is performed using a CLAIM_PREVIOUS. Because the client, in this type of situation, will have already opened the file and have the filehandle of the target file, this operation requires that the current filehandle be the target file, rather than a directory, and no file name is specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 既存のオープンを再利用するには、CLAIM_PREVIOUSを使用してOPEN操作を実行します。このタイプの状況では、クライアントはすでにファイルを開き、ターゲットファイルのファイルハンドルを持っているため、この操作では、現在のファイルハンドルがディレクトリではなくターゲットファイルであり、ファイル名が指定されていない必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To reclaim byte-range locks, a LOCK operation with the reclaim parameter set to true is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイト範囲ロックを再利用するには、reclaimパラメータをtrueに設定したLOCK操作を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reclaims of opens associated with delegations are discussed in Section 10.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任に関連するオープンの再利用については、セクション10.2.1で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--Client-Side-Caching">
10. Client-Side Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. クライアント側のキャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client-side caching of data, of file attributes, and of file names is essential to providing good performance with the NFS protocol. Providing distributed cache coherence is a difficult problem, and previous versions of the NFS protocol have not attempted it. Instead, several NFS client implementation techniques have been used to reduce the problems that a lack of coherence poses for users. These techniques have not been clearly defined by earlier protocol specifications, and it is often unclear what is valid or invalid client behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ、ファイル属性、およびファイル名のクライアント側キャッシュは、NFSプロトコルで良好なパフォーマンスを提供するために不可欠です。分散キャッシュコヒーレンスを提供することは困難な問題であり、NFSプロトコルの以前のバージョンでは試みられていませんでした。代わりに、一貫性の欠如がユーザーにもたらす問題を軽減するために、いくつかのNFSクライアント実装手法が使用されています。これらの手法は、以前のプロトコル仕様では明確に定義されておらず、有効または無効なクライアントの動作が明確でないことがよくあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 protocol uses many techniques similar to those that have been used in previous protocol versions. The NFSv4.1 protocol does not provide distributed cache coherence. However, it defines a more limited set of caching guarantees to allow locks and share reservations to be used without destructive interference from client-side caching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1プロトコルは、以前のバージョンのプロトコルで使用されていたものと同様の多くの手法を使用します。 NFSv4.1プロトコルは、分散キャッシュの一貫性を提供しません。ただし、クライアント側のキャッシングによる破壊的な干渉なしにロックと共有の予約を使用できるように、より限定的なキャッシング保証のセットを定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, the NFSv4.1 protocol introduces a delegation mechanism, which allows many decisions normally made by the server to be made locally by clients. This mechanism provides efficient support of the common cases where sharing is infrequent or where sharing is read-only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、NFSv4.1プロトコルは委任メカニズムを導入しています。これにより、サーバーが通常行う多くの決定をクライアントがローカルで行うことができます。このメカニズムは、共有頻度が低い、または共有が読み取り専用である一般的なケースを効率的にサポートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-1--Performance-Challenges-for-Client-Side-Caching">
10.1. Performance Challenges for Client-Side Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. クライアント側キャッシュのパフォーマンスの課題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Caching techniques used in previous versions of the NFS protocol have been successful in providing good performance. However, several scalability challenges can arise when those techniques are used with very large numbers of clients. This is particularly true when clients are geographically distributed, which classically increases the latency for cache revalidation requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Caching techniques used in previous versions of the NFS protocol have been successful in providing good performance. However, several scalability challenges can arise when those techniques are used with very large numbers of clients. This is particularly true when clients are geographically distributed, which classically increases the latency for cache revalidation requests.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The previous versions of the NFS protocol repeat their file data cache validation requests at the time the file is opened. This behavior can have serious performance drawbacks. A common case is one in which a file is only accessed by a single client. Therefore, sharing is infrequent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The previous versions of the NFS protocol repeat their file data cache validation requests at the time the file is opened. This behavior can have serious performance drawbacks. A common case is one in which a file is only accessed by a single client. Therefore, sharing is infrequent.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this case, repeated references to the server to find that no conflicts exist are expensive. A better option with regards to performance is to allow a client that repeatedly opens a file to do so without reference to the server. This is done until potentially conflicting operations from another client actually occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合、競合が存在しないことを見つけるためにサーバーを繰り返し参照すると、コストがかかります。パフォーマンスに関するより良いオプションは、サーバーを参照せずにファイルを繰り返し開くクライアントがファイルを開くことを許可することです。これは、別のクライアントからの潜在的に競合する操作が実際に発生するまで行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A similar situation arises in connection with byte-range locking. Sending LOCK and LOCKU operations as well as the READ and WRITE operations necessary to make data caching consistent with the locking semantics (see Section 10.3.2) can severely limit performance. When locking is used to provide protection against infrequent conflicts, a large penalty is incurred. This penalty may discourage the use of byte-range locking by applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイト範囲のロックに関しても、同様の状況が発生します。データのキャッシングとロックのセマンティクス（セクション10.3.2を参照）を一致させるために必要なREADおよびWRITE操作だけでなく、LOCKおよびLOCKU操作を送信すると、パフォーマンスが大幅に制限される可能性があります。まれな競合に対する保護を提供するためにロックを使用すると、大きなペナルティが発生します。このペナルティにより、アプリケーションによるバイト範囲ロックの使用が妨げられる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 protocol provides more aggressive caching strategies with the following design goals:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1プロトコルは、次の設計目標でより積極的なキャッシング戦略を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Compatibility with a large range of server semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 幅広いサーバーセマンティクスとの互換性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Providing the same caching benefits as previous versions of the NFS protocol when unable to support the more aggressive model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o より積極的なモデルをサポートできない場合、NFSプロトコルの以前のバージョンと同じキャッシュの利点を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Requirements for aggressive caching are organized so that a large portion of the benefit can be obtained even when not all of the requirements can be met.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o アグレッシブキャッシングの要件は、すべての要件が満たされなくても、メリットの大部分を獲得できるように編成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The appropriate requirements for the server are discussed in later sections in which specific forms of caching are covered (see Section 10.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの適切な要件については、後のセクションで説明します。このセクションでは、特定の形式のキャッシュについて説明します（セクション10.4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-2--Delegation-and-Callbacks">
10.2. Delegation and Callbacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 委任とコールバック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recallable delegation of server responsibilities for a file to a client improves performance by avoiding repeated requests to the server in the absence of inter-client conflict. With the use of a &#34;callback&#34; RPC from server to client, a server recalls delegated responsibilities when another client engages in sharing of a delegated file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルに対するサーバーの責任をクライアントに呼び戻せる委任は、クライアント間の競合がない場合にサーバーへの要求が繰り返されることを回避することにより、パフォーマンスを向上させます。サーバーからクライアントへの「コールバック」RPCを使用すると、サーバーは、他のクライアントが委任されたファイルの共有に従事するときに、委任された責任を呼び戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A delegation is passed from the server to the client, specifying the object of the delegation and the type of delegation. There are different types of delegations, but each type contains a stateid to be used to represent the delegation when performing operations that depend on the delegation. This stateid is similar to those associated with locks and share reservations but differs in that the stateid for a delegation is associated with a client ID and may be used on behalf of all the open-owners for the given client. A delegation is made to the client as a whole and not to any specific process or thread of control within it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任はサーバーからクライアントに渡され、委任のオブジェクトと委任のタイプが指定されます。委任にはさまざまなタイプがありますが、各タイプには、委任に依存する操作を実行するときに委任を表すために使用される状態IDが含まれています。この状態IDは、ロックと共有予約に関連付けられているものと似ていますが、委任の状態IDがクライアントIDに関連付けられており、特定のクライアントのすべてのオープン所有者の代わりに使用できるという点が異なります。委任はクライアント全体に対して行われ、その中の特定のプロセスや制御のスレッドに対しては行われません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The backchannel is established by CREATE_SESSION and BIND_CONN_TO_SESSION, and the client is required to maintain it. Because the backchannel may be down, even temporarily, correct protocol operation does not depend on them. Preliminary testing of backchannel functionality by means of a CB_COMPOUND procedure with a single operation, CB_SEQUENCE, can be used to check the continuity of the backchannel. A server avoids delegating responsibilities until it has determined that the backchannel exists. Because the granting of a delegation is always conditional upon the absence of conflicting access, clients MUST NOT assume that a delegation will be granted and they MUST always be prepared for OPENs, WANT_DELEGATIONs, and GET_DIR_DELEGATIONs to be processed without any delegations being granted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The backchannel is established by CREATE_SESSION and BIND_CONN_TO_SESSION, and the client is required to maintain it. Because the backchannel may be down, even temporarily, correct protocol operation does not depend on them. Preliminary testing of backchannel functionality by means of a CB_COMPOUND procedure with a single operation, CB_SEQUENCE, can be used to check the continuity of the backchannel. A server avoids delegating responsibilities until it has determined that the backchannel exists. Because the granting of a delegation is always conditional upon the absence of conflicting access, clients MUST NOT assume that a delegation will be granted and they MUST always be prepared for OPENs, WANT_DELEGATIONs, and GET_DIR_DELEGATIONs to be processed without any delegations being granted.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike locks, an operation by a second client to a delegated file will cause the server to recall a delegation through a callback. For individual operations, we will describe, under IMPLEMENTATION, when such operations are required to effect a recall. A number of points should be noted, however.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックとは異なり、委任されたファイルに対する2番目のクライアントの操作では、サーバーがコールバックを通じて委任を呼び戻します。個々の操作について、「実装」で、リコールを実行するためにそのような操作が必要な場合について説明します。ただし、いくつかの点に注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server is free to recall a delegation whenever it feels it is desirable and may do so even if no operations requiring recall are being done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、望ましいと感じたときにいつでも委任を自由にリコールできます。リコールを必要とする操作が実行されていなくても、そうすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Operations done outside the NFSv4.1 protocol, due to, for example, access by other protocols, or by local access, also need to result in delegation recall when they make analogous changes to file system data. What is crucial is if the change would invalidate the guarantees provided by the delegation. When this is possible, the delegation needs to be recalled and MUST be returned or revoked before allowing the operation to proceed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1プロトコルの外で行われた操作は、他のプロトコルによるアクセスやローカルアクセスなどが原因で、ファイルシステムデータに類似の変更を加えるときに委任の呼び出しを行う必要があります。重要なのは、変更によって代表団が提供する保証が無効になるかどうかです。これが可能な場合は、委任を取り消す必要があり、操作を続行する前に返却または取り消す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The semantics of the file system are crucial in defining when delegation recall is required. If a particular change within a specific implementation causes change to a file attribute, then delegation recall is required, whether that operation has been specifically listed as requiring delegation recall. Again, what is critical is whether the guarantees provided by the delegation are being invalidated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The semantics of the file system are crucial in defining when delegation recall is required. If a particular change within a specific implementation causes change to a file attribute, then delegation recall is required, whether that operation has been specifically listed as requiring delegation recall. Again, what is critical is whether the guarantees provided by the delegation are being invalidated.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Despite those caveats, the implementation sections for a number of operations describe situations in which delegation recall would be required under some common circumstances:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの警告にもかかわらず、いくつかの操作の実装セクションでは、一部の一般的な状況で委任の取り消しが必要になる状況について説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For GETATTR, see Section 18.7.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETATTRについては、セクション18.7.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For OPEN, see Section 18.16.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For OPEN, see Section 18.16.4.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For READ, see Section 18.22.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READについては、セクション18.22.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For REMOVE, see Section 18.25.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o REMOVEについては、セクション18.25.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For RENAME, see Section 18.26.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RENAMEについては、セクション18.26.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For SETATTR, see Section 18.30.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SETATTRについては、セクション18.30.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For WRITE, see Section 18.32.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o WRITEについては、セクション18.32.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On recall, the client holding the delegation needs to flush modified state (such as modified data) to the server and return the delegation. The conflicting request will not be acted on until the recall is complete. The recall is considered complete when the client returns the delegation or the server times its wait for the delegation to be returned and revokes the delegation as a result of the timeout. In the interim, the server will either delay responding to conflicting requests or respond to them with NFS4ERR_DELAY. Following the resolution of the recall, the server has the information necessary to grant or deny the second client&#39;s request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
呼び戻し時に、委任を保持しているクライアントは、変更された状態（変更されたデータなど）をサーバーにフラッシュし、委任を返す必要があります。競合する要求は、再呼び出しが完了するまで処理されません。クライアントが委任を返すか、サーバーが委任が返されるまでの待機時間を計り、タイムアウトの結果として委任を取り消すと、再呼び出しは完了したと見なされます。その間、サーバーは競合する要求への応答を遅らせるか、NFS4ERR_DELAYで応答します。再呼び出しの解決後、サーバーは2番目のクライアントの要求を許可または拒否するために必要な情報を取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 At the time the client receives a delegation recall, it may have substantial state that needs to be flushed to the server. Therefore, the server should allow sufficient time for the delegation to be returned since it may involve numerous RPCs to the server. If the server is able to determine that the client is diligently flushing state to the server as a result of the recall, the server may extend the usual time allowed for a recall. However, the time allowed for recall completion should not be unbounded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントが委任の取り消しを受け取った時点で、サーバーにフラッシュする必要のあるかなりの状態がある場合があります。したがって、サーバーには多数のRPCが含まれる可能性があるため、サーバーは委任が返されるのに十分な時間を確保する必要があります。サーバーが再呼び出しの結果としてクライアントがサーバーに状態を注意深くフラッシュしていると判断できる場合、サーバーは再呼び出しに許可されている通常の時間を延長することがあります。ただし、リコール完了に許可される時間には制限がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example of this is when responsibility to mediate opens on a given file is delegated to a client (see Section 10.4). The server will not know what opens are in effect on the client. Without this knowledge, the server will be unable to determine if the access and deny states for the file allow any particular open until the delegation for the file has been returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例は、特定のファイルのオープンを仲​​介する責任がクライアントに委任されている場合です（セクション10.4を参照）。サーバーは、クライアントでどのオープンが有効であるかを認識しません。この知識がないと、サーバーは、ファイルの委任が返されるまで、ファイルのアクセス状態と拒否状態が特定のオープンを許可するかどうかを判断できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client failure or a network partition can result in failure to respond to a recall callback. In this case, the server will revoke the delegation, which in turn will render useless any modified state still on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント障害またはネットワークパーティションにより、再呼び出しコールバックへの応答が失敗する可能性があります。この場合、サーバーは委任を取り消します。これにより、クライアント上で変更された状態が無効になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-2-1--Delegation-Recovery">
10.2.1. Delegation Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.1. 委任の回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are three situations that delegation recovery needs to deal with:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任の回復では、3つの状況に対処する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o client restart
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントの再起動
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o server restart
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーの再起動
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o network partition (full or backchannel-only)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ネットワークパーティション（フルまたはバックチャネルのみ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event the client restarts, the failure to renew the lease will result in the revocation of byte-range locks and share reservations. Delegations, however, may be treated a bit differently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが再起動した場合、リースの更新に失敗すると、バイト範囲ロックと共有予約が取り消されます。ただし、委任の扱いは少し異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There will be situations in which delegations will need to be re-established after a client restarts. The reason for this is that the client may have file data stored locally and this data was associated with the previously held delegations. The client will need to re-establish the appropriate file state on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの再起動後に委任を再確立する必要がある状況があります。これは、クライアントにローカルに保存されたファイルデータがあり、このデータが以前に保持されていた委任に関連付けられていたためです。クライアントはサーバー上で適切なファイル状態を再確立する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 To allow for this type of client recovery, the server MAY extend the period for delegation recovery beyond the typical lease expiration period. This implies that requests from other clients that conflict with these delegations will need to wait. Because the normal recall process may require significant time for the client to flush changed state to the server, other clients need be prepared for delays that occur because of a conflicting delegation. This longer interval would increase the window for clients to restart and consult stable storage so that the delegations can be reclaimed. For OPEN delegations, such delegations are reclaimed using OPEN with a claim type of CLAIM_DELEGATE_PREV or CLAIM_DELEG_PREV_FH (see Sections 10.5 and 18.16 for discussion of OPEN delegation and the details of OPEN, respectively).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このタイプのクライアント回復を可能にするために、サーバーは委任回復の期間を通常のリースの有効期限を超えて延長してもよい（MAY）。これは、これらの委任と競合する他のクライアントからの要求は待機する必要があることを意味します。通常の再呼び出しプロセスでは、クライアントが変更された状態をサーバーにフラッシュするのにかなりの時間がかかる場合があるため、他のクライアントは、委任の競合が原因で発生する遅延に備える必要があります。このより長い間隔は、クライアントが再起動して安定したストレージを参照し、委任を取り戻すことができる時間枠を増やします。 OPEN委任の場合、そのような委任は、クレームタイプがCLAIM_DELEGATE_PREVまたはCLAIM_DELEG_PREV_FHのOPENを使用して再利用されます（OPEN委任とOPENの詳細については、それぞれセクション10.5および18.16を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MAY support claim types of CLAIM_DELEGATE_PREV and CLAIM_DELEG_PREV_FH, and if it does, it MUST NOT remove delegations upon a CREATE_SESSION that confirm a client ID created by EXCHANGE_ID. Instead, the server MUST, for a period of time no less than that of the value of the lease_time attribute, maintain the client&#39;s delegations to allow time for the client to send CLAIM_DELEGATE_PREV and/or CLAIM_DELEG_PREV_FH requests. The server that supports CLAIM_DELEGATE_PREV and/or CLAIM_DELEG_PREV_FH MUST support the DELEGPURGE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、CLAIM_DELEGATE_PREVおよびCLAIM_DELEG_PREV_FHのクレームタイプをサポートする場合があり（MAY）、サポートする場合は、EXCHANGE_IDによって作成されたクライアントIDを確認するCREATE_SESSIONの委任を削除してはなりません（MUST NOT）。代わりに、サーバーは、lease_time属性の値の期間以上、クライアントの委任を維持して、クライアントがCLAIM_DELEGATE_PREV要求またはCLAIM_DELEG_PREV_FH要求を送信する時間を許可する必要があります。 CLAIM_DELEGATE_PREVまたはCLAIM_DELEG_PREV_FHをサポートするサーバーは、DELEGPURGE操作をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server restarts, delegations are reclaimed (using the OPEN operation with CLAIM_PREVIOUS) in a similar fashion to byte-range locks and share reservations. However, there is a slight semantic difference. In the normal case, if the server decides that a delegation should not be granted, it performs the requested action (e.g., OPEN) without granting any delegation. For reclaim, the server grants the delegation but a special designation is applied so that the client treats the delegation as having been granted but recalled by the server. Because of this, the client has the duty to write all modified state to the server and then return the delegation. This process of handling delegation reclaim reconciles three principles of the NFSv4.1 protocol:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが再起動すると、バイト範囲のロックや共有の予約と同様の方法で、委任は（CLAIM_PREVIOUSを指定したOPEN操作を使用して）再利用されます。ただし、わずかな意味上の違いがあります。通常の場合、サーバーが委任を許可しないと決定すると、サーバーは委任を許可せずに要求されたアクション（OPENなど）を実行します。再利用の場合、サーバーは委任を許可しますが、クライアントが委任を許可されたがサーバーによって呼び出されたものとして扱うように、特別な指定が適用されます。このため、クライアントには、変更されたすべての状態をサーバーに書き込んでから委任を返す義務があります。委任再利用を処理するこのプロセスは、NFSv4.1プロトコルの3つの原則を調整します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Upon reclaim, a client reporting resources assigned to it by an earlier server instance must be granted those resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 再利用時には、以前のサーバーインスタンスによって割り当てられたリソースを報告するクライアントに、それらのリソースを付与する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has unquestionable authority to determine whether delegations are to be granted and, once granted, whether they are to be continued.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーには、委任を許可するかどうかを決定し、一度許可すると、続行するかどうかを決定する疑いのない権限があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The use of callbacks should not be depended upon until the client has proven its ability to receive them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントがコールバックを受信する能力を証明するまで、コールバックの使用に依存すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client needs to reclaim a delegation and there is no associated open, the client may use the CLAIM_PREVIOUS variant of the WANT_DELEGATION operation. However, since the server is not required to support this operation, an alternative is to reclaim via a dummy OPEN together with the delegation using an OPEN of type CLAIM_PREVIOUS. The dummy open file can be released using a CLOSE to re-establish the original state to be reclaimed, a delegation without an associated open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが委任を再利用する必要があり、関連付けられたオープンがない場合、クライアントはWANT_DELEGATION操作のCLAIM_PREVIOUSバリアントを使用できます。ただし、サーバーはこの操作をサポートする必要がないため、CLAIM_PREVIOUSタイプのOPENを使用した委任とともに、ダミーのOPENを介して再利用することもできます。ダミーのオープンファイルは、CLOSEを使用して解放して、再生される元の状態、関連付けられたオープンのない委任を再確立できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client has more than a single open associated with a delegation, state for those additional opens can be established using OPEN operations of type CLAIM_DELEGATE_CUR. When these are used to establish opens associated with reclaimed delegations, the server MUST allow them when made within the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントに委任に関連付けられた複数のオープンがある場合、それらの追加のオープンの状態は、タイプCLAIM_DELEGATE_CURのOPEN操作を使用して確立できます。これらが再利用された委任に関連するオープンを確立するために使用される場合、サーバーは猶予期間内に作成されたときにそれらを許可する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a network partition occurs, delegations are subject to freeing by the server when the lease renewal period expires. This is similar to the behavior for locks and share reservations. For delegations, however, the server may extend the period in which conflicting requests are held off. Eventually, the occurrence of a conflicting request from another client will cause revocation of the delegation. A loss of the backchannel (e.g., by later network configuration change) will have the same effect. A recall request will fail and revocation of the delegation will result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a network partition occurs, delegations are subject to freeing by the server when the lease renewal period expires. This is similar to the behavior for locks and share reservations. For delegations, however, the server may extend the period in which conflicting requests are held off. Eventually, the occurrence of a conflicting request from another client will cause revocation of the delegation. A loss of the backchannel (e.g., by later network configuration change) will have the same effect. A recall request will fail and revocation of the delegation will result.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client normally finds out about revocation of a delegation when it uses a stateid associated with a delegation and receives one of the errors NFS4ERR_EXPIRED, NFS4ERR_ADMIN_REVOKED, or NFS4ERR_DELEG_REVOKED. It also may find out about delegation revocation after a client restart when it attempts to reclaim a delegation and receives that same error. Note that in the case of a revoked OPEN_DELEGATE_WRITE delegation, there are issues because data may have been modified by the client whose delegation is revoked and separately by other clients. See Section 10.5.1 for a discussion of such issues. Note also that when delegations are revoked, information about the revoked delegation will be written by the server to stable storage (as described in Section 8.4.3). This is done to deal with the case in which a server restarts after revoking a delegation but before the client holding the revoked delegation is notified about the revocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは通常、委任に関連付けられた状態IDを使用し、NFS4ERR_EXPIRED、NFS4ERR_ADMIN_REVOKED、またはNFS4ERR_DELEG_REVOKEDのいずれかのエラーを受け取ったときに、委任の取り消しについて調べます。また、クライアントを再起動した後、委任を再利用しようとして同じエラーを受け取ったときに、委任の取り消しについても知ることができます。 OPEN_DELEGATE_WRITE委任が取り消された場合、委任が取り消されたクライアントによってデータが変更され、他のクライアントによって個別に変更された可能性があるため、問題があることに注意してください。このような問題については、セクション10.5.1を参照してください。また、委任が取り消されると、取り消された委任に関する情報はサーバーによって安定したストレージに書き込まれます（8.4.3項を参照）。これは、委任を取り消した後、取り消された委任を保持しているクライアントに取り消しについて通知される前にサーバーが再起動する場合に対処するために行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-3--Data-Caching">
10.3. Data Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3. データキャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When applications share access to a set of files, they need to be implemented so as to take account of the possibility of conflicting access by another application. This is true whether the applications in question execute on different clients or reside on the same client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションが一連のファイルへのアクセスを共有する場合、別のアプリケーションによるアクセスの競合の可能性を考慮に入れるために、それらを実装する必要があります。これは、問題のアプリケーションが異なるクライアントで実行されているか、同じクライアントに存在しているかに関係なく当てはまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Share reservations and byte-range locks are the facilities the NFSv4.1 protocol provides to allow applications to coordinate access by using mutual exclusion facilities. The NFSv4.1 protocol&#39;s data caching must be implemented such that it does not invalidate the assumptions on which those using these facilities depend.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有予約とバイト範囲ロックは、NFSv4.1プロトコルが提供する機能であり、アプリケーションが相互排除機能を使用してアクセスを調整できるようにします。 NFSv4.1プロトコルのデータキャッシングは、これらの機能を使用する前提条件が無効にならないように実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-3-1--Data-Caching-and-OPENs">
10.3.1. Data Caching and OPENs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.1. データキャッシングとOPEN
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to avoid invalidating the sharing assumptions on which applications rely, NFSv4.1 clients should not provide cached data to applications or modify it on behalf of an application when it would not be valid to obtain or modify that same data via a READ or WRITE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションが依存する共有の仮定が無効になるのを防ぐために、NFSv4.1クライアントは、キャッシュされたデータをアプリケーションに提供したり、READまたはWRITEを介して同じデータを取得または変更することが有効でない場合、アプリケーションに代わってそれを変更しないでください。操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, in the absence of an OPEN delegation (see Section 10.4), two additional rules apply. Note that these rules are obeyed in practice by many NFSv3 clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、OPEN委任がない場合（セクション10.4を参照）、2つの追加ルールが適用されます。これらのルールは、実際には多くのNFSv3クライアントによって遵守されていることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o First, cached data present on a client must be revalidated after doing an OPEN. Revalidating means that the client fetches the change attribute from the server, compares it with the cached change attribute, and if different, declares the cached data (as well as the cached attributes) as invalid. This is to ensure that the data for the OPENed file is still correctly reflected in the client&#39;s cache. This validation must be done at least when the client&#39;s OPEN operation includes a deny of OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH, thus terminating a period in which other clients may have had the opportunity to open the file with OPEN4_SHARE_ACCESS_WRITE/OPEN4_SHARE_ACCESS_BOTH access. Clients may choose to do the revalidation more often (i.e., at OPENs specifying a deny mode of OPEN4_SHARE_DENY_NONE) to parallel the NFSv3 protocol&#39;s practice for the benefit of users assuming this degree of cache revalidation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o First, cached data present on a client must be revalidated after doing an OPEN. Revalidating means that the client fetches the change attribute from the server, compares it with the cached change attribute, and if different, declares the cached data (as well as the cached attributes) as invalid. This is to ensure that the data for the OPENed file is still correctly reflected in the client&#39;s cache. This validation must be done at least when the client&#39;s OPEN operation includes a deny of OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH, thus terminating a period in which other clients may have had the opportunity to open the file with OPEN4_SHARE_ACCESS_WRITE/OPEN4_SHARE_ACCESS_BOTH access. Clients may choose to do the revalidation more often (i.e., at OPENs specifying a deny mode of OPEN4_SHARE_DENY_NONE) to parallel the NFSv3 protocol&#39;s practice for the benefit of users assuming this degree of cache revalidation.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Since the change attribute is updated for data and metadata modifications, some client implementors may be tempted to use the time_modify attribute and not the change attribute to validate cached data, so that metadata changes do not spuriously invalidate clean data. The implementor is cautioned in this approach. The change attribute is guaranteed to change for each update to the file, whereas time_modify is guaranteed to change only at the granularity of the time_delta attribute. Use by the client&#39;s data cache validation logic of time_modify and not change runs the risk of the client incorrectly marking stale data as valid. Thus, any cache validation approach by the client MUST include the use of the change attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
データとメタデータの変更のために変更属性が更新されるため、一部のクライアント実装者は、キャッシュされたデータを検証するために変更属性ではなくtime_modify属性を使用したくなる場合があります。これにより、メタデータの変更がクリーンなデータを誤って無効にすることはありません。このアプローチでは、実装者に警告が出されます。 change属性は、ファイルの更新ごとに変更されることが保証されていますが、time_modifyは、time_delta属性の粒度でのみ変更されることが保証されています。クライアントのデータキャッシュ検証ロジックであるtime_modifyを使用し、変更しないと、クライアントが古いデータを有効として誤ってマークするリスクがあります。したがって、クライアントによるキャッシュ検証アプローチには、変更属性の使用を含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o Second, modified data must be flushed to the server before closing a file OPENed for OPEN4_SHARE_ACCESS_WRITE. This is complementary to the first rule. If the data is not flushed at CLOSE, the revalidation done after the client OPENs a file is unable to achieve its purpose. The other aspect to flushing the data before close is that the data must be committed to stable storage, at the server, before the CLOSE operation is requested by the client. In the case of a server restart and a CLOSEd file, it may not be possible to retransmit the data to be written to the file, hence, this requirement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
o 2番目に、OPEN4_SHARE_ACCESS_WRITEのためにOPENされたファイルを閉じる前に、変更されたデータをサーバーにフラッシュする必要があります。これは最初のルールを補足するものです。データがCLOSEでフラッシュされない場合、クライアントがファイルをOPENした後に行われる再検証は、その目的を達成できません。閉じる前にデータをフラッシュするもう1つの側面は、クライアントがCLOSE操作を要求する前に、サーバーでデータを安定したストレージにコミットする必要があることです。サーバーの再起動とファイルがCLOSEdの場合、ファイルに書き込まれるデータを再送信できない可能性があるため、この要件があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-3-2--Data-Caching-and-File-Locking">
10.3.2. Data Caching and File Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.2. データのキャッシュとファイルのロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For those applications that choose to use byte-range locking instead of share reservations to exclude inconsistent file access, there is an analogous set of constraints that apply to client-side data caching. These rules are effective only if the byte-range locking is used in a way that matches in an equivalent way the actual READ and WRITE operations executed. This is as opposed to byte-range locking that is based on pure convention. For example, it is possible to manipulate a two-megabyte file by dividing the file into two one-megabyte ranges and protecting access to the two byte-ranges by byte-range locks on bytes zero and one. A WRITE_LT lock on byte zero of the file would represent the right to perform READ and WRITE operations on the first byte-range. A WRITE_LT lock on byte one of the file would represent the right to perform READ and WRITE operations on the second byte-range. As long as all applications manipulating the file obey this convention, they will work on a local file system. However, they may not work with the NFSv4.1 protocol unless clients refrain from data caching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有予約の代わりにバイト範囲ロックを使用して、一貫性のないファイルアクセスを除外することを選択するアプリケーションには、クライアント側のデータキャッシュに適用される一連の類似した制約があります。これらのルールは、実際のREADおよびWRITE操作が実行されたのと同等の方法で一致する方法でバイト範囲ロックが使用されている場合にのみ有効です。これは、純粋な規則に基づくバイト範囲ロックとは対照的です。たとえば、ファイルを2つの1メガバイトの範囲に分割し、バイト0と1のバイト範囲ロックによって2つのバイト範囲へのアクセスを保護することにより、2メガバイトのファイルを操作できます。ファイルのバイト0のWRITE_LTロックは、最初のバイト範囲でREADおよびWRITE操作を実行する権利を表します。ファイルの1バイト目のWRITE_LTロックは、2番目のバイト範囲でREADおよびWRITE操作を実行する権利を表します。ファイルを操作するすべてのアプリケーションがこの規則に従う限り、ローカルファイルシステムで動作します。ただし、クライアントがデータのキャッシュを控えない限り、NFSv4.1プロトコルでは機能しない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules for data caching in the byte-range locking environment are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイト範囲ロック環境でのデータキャッシングのルールは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o First, when a client obtains a byte-range lock for a particular byte-range, the data cache corresponding to that byte-range (if any cache data exists) must be revalidated. If the change attribute indicates that the file may have been updated since the cached data was obtained, the client must flush or invalidate the cached data for the newly locked byte-range. A client might choose to invalidate all of the non-modified cached data that it has for the file, but the only requirement for correct operation is to invalidate all of the data in the newly locked byte-range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o まず、クライアントが特定のバイト範囲のバイト範囲ロックを取得すると、そのバイト範囲に対応するデータキャッシュ（キャッシュデータが存在する場合）を再検証する必要があります。変更された属性が、キャッシュされたデータの取得後にファイルが更新された可能性があることを示している場合、クライアントは、新しくロックされたバイト範囲のキャッシュされたデータをフラッシュまたは無効にする必要があります。クライアントは、ファイルにある変更されていないすべてのキャッシュデータを無効にすることを選択する場合がありますが、正しく動作するための唯一の要件は、新しくロックされたバイト範囲のすべてのデータを無効にすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Second, before releasing a WRITE_LT lock for a byte-range, all modified data for that byte-range must be flushed to the server. The modified data must also be written to stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 次に、バイト範囲のWRITE_LTロックを解放する前に、そのバイト範囲のすべての変更されたデータをサーバーにフラッシュする必要があります。変更されたデータも安定したストレージに書き込む必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Note that flushing data to the server and the invalidation of cached data must reflect the actual byte-ranges locked or unlocked. Rounding these up or down to reflect client cache block boundaries will cause problems if not carefully done. For example, writing a modified block when only half of that block is within an area being unlocked may cause invalid modification to the byte-range outside the unlocked area. This, in turn, may be part of a byte-range locked by another client. Clients can avoid this situation by synchronously performing portions of WRITE operations that overlap that portion (initial or final) that is not a full block. Similarly, invalidating a locked area that is not an integral number of full buffer blocks would require the client to read one or two partial blocks from the server if the revalidation procedure shows that the data that the client possesses may not be valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーへのデータのフラッシュとキャッシュデータの無効化は、ロックまたはロック解除された実際のバイト範囲を反映する必要があることに注意してください。これらを切り上げまたは切り下げてクライアントキャッシュブロックの境界を反映させると、注意深く行わないと問題が発生します。たとえば、ブロックの半分だけがロック解除されている領域内にあるときに変更されたブロックを書き込むと、ロック解除された領域外のバイト範囲が無効に変更される可能性があります。これは、別のクライアントによってロックされたバイト範囲の一部である可能性があります。クライアントは、完全なブロックではない部分（初期または最終）とオーバーラップするWRITE操作の部分を同期的に実行することにより、この状況を回避できます。同様に、完全なバッファーブロックの整数ではないロックされた領域を無効にすると、クライアントが所有するデータが有効でない可能性があることが再検証手順で示される場合、クライアントはサーバーから1つまたは2つの部分ブロックを読み取る必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The data that is written to the server as a prerequisite to the unlocking of a byte-range must be written, at the server, to stable storage. The client may accomplish this either with synchronous writes or by following asynchronous writes with a COMMIT operation. This is required because retransmission of the modified data after a server restart might conflict with a lock held by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイト範囲のロック解除の前提条件としてサーバーに書き込まれるデータは、サーバーで安定したストレージに書き込まれる必要があります。クライアントは、同期書き込みを使用するか、COMMIT操作で非同期書き込みを実行することにより、これを実行できます。これは、サーバーの再起動後の変更されたデータの再送信が別のクライアントが保持しているロックと競合する可能性があるために必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client implementation may choose to accommodate applications that use byte-range locking in non-standard ways (e.g., using a byte-range lock as a global semaphore) by flushing to the server more data upon a LOCKU than is covered by the locked range. This may include modified data within files other than the one for which the unlocks are being done. In such cases, the client must not interfere with applications whose READs and WRITEs are being done only within the bounds of byte-range locks that the application holds. For example, an application locks a single byte of a file and proceeds to write that single byte. A client that chose to handle a LOCKU by flushing all modified data to the server could validly write that single byte in response to an unrelated LOCKU operation. However, it would not be valid to write the entire block in which that single written byte was located since it includes an area that is not locked and might be locked by another client. Client implementations can avoid this problem by dividing files with modified data into those for which all modifications are done to areas covered by an appropriate byte-range lock and those for which there are modifications not covered by a byte-range lock. Any writes done for the former class of files must not include areas not locked and thus not modified on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの実装は、非標準的な方法でバイト範囲ロックを使用するアプリケーション（たとえば、グローバルセマフォとしてバイト範囲ロックを使用する）に対応することを選択できます。 。これには、ロック解除が行われているファイル以外のファイル内の変更されたデータが含まれる場合があります。このような場合、クライアントは、アプリケーションが保持するバイト範囲ロックの範囲内でのみREADおよびWRITEが実行されるアプリケーションに干渉してはなりません。たとえば、アプリケーションはファイルの1バイトをロックし、その1バイトの書き込みを続行します。変更されたすべてのデータをサーバーにフラッシュすることによってLOCKUを処理することを選択したクライアントは、無関係なLOCKU操作に応答してその1バイトを有効に書き込むことができます。ただし、ロックされていない領域が含まれていて、別のクライアントによってロックされている可能性があるため、書き込まれた単一のバイトが配置されたブロック全体を書き込むことは無効です。クライアントの実装では、データが変更されたファイルを、適切なバイト範囲ロックでカバーされる領域にすべての変更が加えられるファイルと、バイト範囲ロックでカバーされない変更があるファイルに分割することで、この問題を回避できます。前のクラスのファイルに対して行われた書き込みには、ロックされていない領域が含まれていて、クライアントで変更されていないことが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-3-3--Data-Caching-and-Mandatory-File-Locking">
10.3.3. Data Caching and Mandatory File Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.3. Data Caching and Mandatory File Locking
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Client-side data caching needs to respect mandatory byte-range locking when it is in effect. The presence of mandatory byte-range locking for a given file is indicated when the client gets back NFS4ERR_LOCKED from a READ or WRITE operation on a file for which it has an appropriate share reservation. When mandatory locking is in effect for a file, the client must check for an appropriate byte-range lock for data being read or written. If a byte-range lock exists for the range being read or written, the client may satisfy the request using the client&#39;s validated cache. If an appropriate byte-range lock is not held for the range of the read or write, the read or write request must not be satisfied by the client&#39;s cache and the request must be sent to the server for processing. When a read or write request partially overlaps a locked byte-range, the request should be subdivided into multiple pieces with each byte-range (locked or not) treated appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアント側のデータキャッシュは、有効な場合、必須のバイト範囲ロックを尊重する必要があります。特定のファイルに必須のバイト範囲ロックが存在することは、クライアントが適切な共有予約を持っているファイルの読み取りまたは書き込み操作からNFS4ERR_LOCKEDを取得したときに示されます。ファイルに対して強制ロックが有効になっている場合、クライアントはデータの読み取りまたは書き込みに対して適切なバイト範囲ロックを確認する必要があります。読み取りまたは書き込みされている範囲にバイト範囲ロックが存在する場合、クライアントは、クライアントの検証済みキャッシュを使用して要求を満たすことができます。読み取りまたは書き込みの範囲に対して適切なバイト範囲ロックが保持されていない場合、読み取りまたは書き込み要求はクライアントのキャッシュによって満たされず、要求はサーバーに送信されて処理される必要があります。読み取り要求または書き込み要求がロックされたバイト範囲と部分的にオーバーラップする場合、要求は複数の部分に分割され、各バイト範囲（ロックされているかどうかにかかわらず）が適切に処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-3-4--Data-Caching-and-File-Identity">
10.3.4. Data Caching and File Identity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.4. データキャッシングとファイルID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When clients cache data, the file data needs to be organized according to the file system object to which the data belongs. For NFSv3 clients, the typical practice has been to assume for the purpose of caching that distinct filehandles represent distinct file system objects. The client then has the choice to organize and maintain the data cache on this basis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがデータをキャッシュする場合、ファイルデータは、データが属するファイルシステムオブジェクトに従って編成する必要があります。 NFSv3クライアントの場合、典型的な慣例は、キャッシングの目的で、個別のファイルハンドルが個別のファイルシステムオブジェクトを表すと想定することでした。その後、クライアントは、これに基づいてデータキャッシュを整理および維持することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the NFSv4.1 protocol, there is now the possibility to have significant deviations from a &#34;one filehandle per object&#34; model because a filehandle may be constructed on the basis of the object&#39;s pathname. Therefore, clients need a reliable method to determine if two filehandles designate the same file system object. If clients were simply to assume that all distinct filehandles denote distinct objects and proceed to do data caching on this basis, caching inconsistencies would arise between the distinct client-side objects that mapped to the same server-side object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1プロトコルでは、ファイルハンドルがオブジェクトのパス名に基づいて構築される可能性があるため、「オブジェクトごとに1つのファイルハンドル」モデルから大幅に逸脱する可能性があります。したがって、クライアントは、2つのファイルハンドルが同じファイルシステムオブジェクトを指定しているかどうかを判断するための信頼できる方法を必要とします。クライアントがすべての個別のファイルハンドルが個別のオブジェクトを表すと単純に想定し、これに基づいてデータキャッシュを実行すると、同じサーバー側オブジェクトにマップされた個別のクライアント側オブジェクト間でキャッシュの不整合が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By providing a method to differentiate filehandles, the NFSv4.1 protocol alleviates a potential functional regression in comparison with the NFSv3 protocol. Without this method, caching inconsistencies within the same client could occur, and this has not been present in previous versions of the NFS protocol. Note that it is possible to have such inconsistencies with applications executing on multiple clients, but that is not the issue being addressed here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルハンドルを区別する方法を提供することにより、NFSv4.1プロトコルは、NFSv3プロトコルと比較して、潜在的な機能低下を緩和します。この方法がないと、同じクライアント内でキャッシュの不整合が発生する可能性があり、これは以前のバージョンのNFSプロトコルには存在しませんでした。複数のクライアントで実行されているアプリケーションとこのような不整合が生じる可能性がありますが、ここでは対処されていないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the purposes of data caching, the following steps allow an NFSv4.1 client to determine whether two distinct filehandles denote the same server-side object:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データキャッシングの目的で、次の手順により、NFSv4.1クライアントは2つの異なるファイルハンドルが同じサーバー側オブジェクトを表すかどうかを判断できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If GETATTR directed to two filehandles returns different values of the fsid attribute, then the filehandles represent distinct objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2つのファイルハンドルに向けられたGETATTRがfsid属性の異なる値を返す場合、ファイルハンドルは異なるオブジェクトを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If GETATTR for any file with an fsid that matches the fsid of the two filehandles in question returns a unique_handles attribute with a value of TRUE, then the two objects are distinct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 問題の2つのファイルハンドルのfsidと一致するfsidを持つファイルのGETATTRが値がTRUEのunique_handles属性を返す場合、2つのオブジェクトは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o If GETATTR directed to the two filehandles does not return the fileid attribute for both of the handles, then it cannot be determined whether the two objects are the same. Therefore, operations that depend on that knowledge (e.g., client-side data caching) cannot be done reliably. Note that if GETATTR does not return the fileid attribute for both filehandles, it will return it for neither of the filehandles, since the fsid for both filehandles is the same.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
o 2つのファイルハンドルに向けられたGETATTRが両方のハンドルのfileid属性を返さない場合、2つのオブジェクトが同じであるかどうかを判断できません。したがって、その知識に依存する操作（クライアント側のデータキャッシュなど）は確実に実行できません。 GETATTRが両方のファイルハンドルのfileid属性を返さない場合、両方のファイルハンドルのfsidが同じであるため、どちらのファイルハンドルにもそれを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If GETATTR directed to the two filehandles returns different values for the fileid attribute, then they are distinct objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2つのファイルハンドルに向けられたGETATTRがfileid属性に異なる値を返す場合、それらは異なるオブジェクトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Otherwise, they are the same object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o それ以外の場合は、同じオブジェクトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-4--Open-Delegation">
10.4. Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4. オープンな委任
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a file is being OPENed, the server may delegate further handling of opens and closes for that file to the opening client. Any such delegation is recallable since the circumstances that allowed for the delegation are subject to change. In particular, if the server receives a conflicting OPEN from another client, the server must recall the delegation before deciding whether the OPEN from the other client may be granted. Making a delegation is up to the server, and clients should not assume that any particular OPEN either will or will not result in an OPEN delegation. The following is a typical set of conditions that servers might use in deciding whether an OPEN should be delegated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルがOPENされているとき、サーバーはそのファイルのオープンとクローズの処理をオープンしているクライアントに委任する場合があります。委任を許可された状況は変更される可能性があるため、そのような委任はすべて再呼び出し可能です。特に、サーバーが別のクライアントから競合するOPENを受け取った場合、サーバーは他のクライアントからのOPENが許可されるかどうかを決定する前に、委任をリコールする必要があります。委任を行うかどうかはサーバー次第であり、クライアントは、特定のOPENがOPEN委任をもたらすかどうかを想定しないでください。以下は、OPENを委任する必要があるかどうかを決定する際にサーバーが使用する可能性がある典型的な一連の条件です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client must be able to respond to the server&#39;s callback requests. If a backchannel has been established, the server will send a CB_COMPOUND request, containing a single operation, CB_SEQUENCE, for a test of backchannel availability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは、サーバーのコールバック要求に応答できる必要があります。バックチャネルが確立されている場合、サーバーは、バックチャネルの可用性のテストのために、単一の操作CB_SEQUENCEを含むCB_COMPOUND要求を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client must have responded properly to previous recalls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは以前のリコールに適切に応答している必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There must be no current OPEN conflicting with the requested delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 要求された委任と競合する現在のOPENがあってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There should be no current delegation that conflicts with the delegation being requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 要求されている委任と競合する現在の委任があってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The probability of future conflicting open requests should be low based on the recent history of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルの最近の履歴に基づいて、将来の競合するオープンリクエストの可能性は低くなるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The existence of any server-specific semantics of OPEN/CLOSE that would make the required handling incompatible with the prescribed handling that the delegated client would apply (see below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 必要な処理を、委任されたクライアントが適用する規定の処理と互換性のないものにする、OPEN / CLOSEのサーバー固有のセマンティクスの存在（以下を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 There are two types of OPEN delegations: OPEN_DELEGATE_READ and OPEN_DELEGATE_WRITE. An OPEN_DELEGATE_READ delegation allows a client to handle, on its own, requests to open a file for reading that do not deny OPEN4_SHARE_ACCESS_READ access to others. Multiple OPEN_DELEGATE_READ delegations may be outstanding simultaneously and do not conflict. An OPEN_DELEGATE_WRITE delegation allows the client to handle, on its own, all opens. Only OPEN_DELEGATE_WRITE delegation may exist for a given file at a given time, and it is inconsistent with any OPEN_DELEGATE_READ delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
OPEN委任には、OPEN_DELEGATE_READとOPEN_DELEGATE_WRITEの2種類があります。 OPEN_DELEGATE_READ委任により、クライアントは、他のユーザーへのOPEN4_SHARE_ACCESS_READアクセスを拒否しない読み取り用のファイルを開く要求を、それ自体で処理できます。複数のOPEN_DELEGATE_READ委任が同時に未解決であり、競合しない場合があります。 OPEN_DELEGATE_WRITE委任により、クライアントは単独ですべてのオープンを処理できます。 OPEN_DELEGATE_WRITE委任のみが特定の時間に特定のファイルに存在する可能性があり、OPEN_DELEGATE_READ委任と矛盾しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client has an OPEN_DELEGATE_READ delegation, it is assured that neither the contents, the attributes (with the exception of time_access), nor the names of any links to the file will change without its knowledge, so long as the delegation is held. When a client has an OPEN_DELEGATE_WRITE delegation, it may modify the file data locally since no other client will be accessing the file&#39;s data. The client holding an OPEN_DELEGATE_WRITE delegation may only locally affect file attributes that are intimately connected with the file data: size, change, time_access, time_metadata, and time_modify. All other attributes must be reflected on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントにOPEN_DELEGATE_READ委任がある場合、その委任が保持されている限り、内容、属性（time_accessを除く）、ファイルへのリンク名のいずれも、知らないうちに変更されることはありません。クライアントにOPEN_DELEGATE_WRITE委任がある場合、他のクライアントがファイルのデータにアクセスしないため、クライアントはファイルデータをローカルで変更する可能性があります。 OPEN_DELEGATE_WRITE委任を保持するクライアントは、サイズ、変更、time_access、time_metadata、time_modifyなど、ファイルデータと密接に関連しているファイル属性にローカルでのみ影響を与える可能性があります。他のすべての属性はサーバーに反映する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client has an OPEN delegation, it does not need to send OPENs or CLOSEs to the server. Instead, the client may update the appropriate status internally. For an OPEN_DELEGATE_READ delegation, opens that cannot be handled locally (opens that are for OPEN4_SHARE_ACCESS_WRITE/OPEN4_SHARE_ACCESS_BOTH or that deny OPEN4_SHARE_ACCESS_READ access) must be sent to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントにOPEN委任がある場合、サーバーにOPENまたはCLOSEを送信する必要はありません。代わりに、クライアントは適切なステータスを内部的に更新します。 OPEN_DELEGATE_READ委任の場合、ローカルで処理できないオープン（OPEN4_SHARE_ACCESS_WRITE / OPEN4_SHARE_ACCESS_BOTH用のオープン、またはOPEN4_SHARE_ACCESS_READアクセスを拒否するオープン）をサーバーに送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an OPEN delegation is made, the reply to the OPEN contains an OPEN delegation structure that specifies the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN委任が行われると、OPENへの応答には、以下を指定するOPEN委任構造が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the type of delegation (OPEN_DELEGATE_READ or OPEN_DELEGATE_WRITE).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 委任のタイプ（OPEN_DELEGATE_READまたはOPEN_DELEGATE_WRITE）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o space limitation information to control flushing of data on close (OPEN_DELEGATE_WRITE delegation only; see Section 10.4.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クローズ時のデータのフラッシュを制御するスペース制限情報（OPEN_DELEGATE_WRITE委任のみ。セクション10.4.1を参照）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o an nfsace4 specifying read and write permissions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 読み取りおよび書き込み権限を指定するnfsace4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a stateid to represent the delegation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 委任を表すstateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The delegation stateid is separate and distinct from the stateid for the OPEN proper. The standard stateid, unlike the delegation stateid, is associated with a particular lock-owner and will continue to be valid after the delegation is recalled and the file remains open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任状態IDは、OPEN固有の状態IDとは別のものです。委任状態IDとは異なり、標準の状態IDは特定のロック所有者に関連付けられており、委任が呼び出されてファイルが開いたままになった後も引き続き有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a request internal to the client is made to open a file and an OPEN delegation is in effect, it will be accepted or rejected solely on the basis of the following conditions. Any requirement for other checks to be made by the delegate should result in the OPEN delegation being denied so that the checks can be made by the server itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの内部でファイルを開く要求が出され、OPEN委任が有効になっている場合、次の条件のみに基づいてその要求が受け入れられるか拒否されます。デリゲートによって行われる他のチェックの要件は、サーバー自体がチェックを行えるように、OPEN委任が拒否されることになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The access and deny bits for the request and the file as described in Section 9.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セクション9.7で説明されている、リクエストとファイルのアクセスビットと拒否ビット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The read and write permissions as determined below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 以下で決定される読み取りおよび書き込み権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfsace4 passed with delegation can be used to avoid frequent ACCESS calls. The permission check should be as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任で渡されたnfsace4は、頻繁なACCESS呼び出しを回避するために使用できます。権限チェックは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the nfsace4 indicates that the open may be done, then it should be granted without reference to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o nfsace4がオープンを実行できることを示している場合は、サーバーを参照せずに許可する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the nfsace4 indicates that the open may not be done, then an ACCESS request must be sent to the server to obtain the definitive answer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o nfsace4がオープンが実行されない可能性があることを示している場合、最終的な回答を取得するには、ACCESS要求をサーバーに送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server may return an nfsace4 that is more restrictive than the actual ACL of the file. This includes an nfsace4 that specifies denial of all access. Note that some common practices such as mapping the traditional user &#34;root&#34; to the user &#34;nobody&#34; (see Section 5.9) may make it incorrect to return the actual ACL of the file in the delegation response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ファイルの実際のACLよりも制限の厳しいnfsace4を返す場合があります。これには、すべてのアクセスの拒否を指定するnfsace4が含まれます。従来のユーザー &#34;root&#34;をユーザー &#34;nobody&#34;（5.9節を参照）にマッピングするなどの一般的な方法では、委任応答でファイルの実際のACLを返すことが正しくない場合があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of a delegation together with various other forms of caching creates the possibility that no server authentication and authorization will ever be performed for a given user since all of the user&#39;s requests might be satisfied locally. Where the client is depending on the server for authentication and authorization, the client should be sure authentication and authorization occurs for each user by use of the ACCESS operation. This should be the case even if an ACCESS operation would not be required otherwise. As mentioned before, the server may enforce frequent authentication by returning an nfsace4 denying all access with every OPEN delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のさまざまな形式のキャッシングと一緒に委任を使用すると、ユーザーのすべての要求がローカルで満たされる可能性があるため、特定のユーザーに対してサーバー認証および承認が実行されない可能性があります。クライアントが認証と承認をサーバーに依存している場合、クライアントはACCESS操作を使用して、ユーザーごとに認証と承認が行われるようにする必要があります。これは、ACCESS操作が必要でない場合でも当てはまります。前述のように、サーバーは、すべてのOPEN委任ですべてのアクセスを拒否するnfsace4を返すことにより、頻繁な認証を実施する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-4-1--Open-Delegation-and-Data-Caching">
10.4.1. Open Delegation and Data Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.1. オープンな委任とデータキャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 An OPEN delegation allows much of the message overhead associated with the opening and closing files to be eliminated. An open when an OPEN delegation is in effect does not require that a validation message be sent to the server. The continued endurance of the &#34;OPEN_DELEGATE_READ delegation&#34; provides a guarantee that no OPEN for OPEN4_SHARE_ACCESS_WRITE/OPEN4_SHARE_ACCESS_BOTH, and thus no write, has occurred. Similarly, when closing a file opened for OPEN4_SHARE_ACCESS_WRITE/OPEN4_SHARE_ACCESS_BOTH and if an OPEN_DELEGATE_WRITE delegation is in effect, the data written does not have to be written to the server until the OPEN delegation is recalled. The continued endurance of the OPEN delegation provides a guarantee that no open, and thus no READ or WRITE, has been done by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
OPEN委任により、ファイルのオープンとクローズに関連するメッセージのオーバーヘッドの多くを排除できます。 OPEN委任が有効な場合のオープンでは、検証メッセージをサーバーに送信する必要はありません。 「OPEN_DELEGATE_READ委任」の継続的な耐久性により、OPEN4_SHARE_ACCESS_WRITE / OPEN4_SHARE_ACCESS_BOTHに対するOPENが発生せず、したがって書き込みも発生しないことが保証されます。同様に、OPEN4_SHARE_ACCESS_WRITE / OPEN4_SHARE_ACCESS_BOTHのために開かれたファイルを閉じるときに、OPEN_DELEGATE_WRITE委任が有効な場合、書き込まれたデータは、OPEN委任が呼び出されるまでサーバーに書き込まれる必要はありません。 OPEN委任の継続的な耐久性により、別のクライアントによって開かれていない、つまり読み取りや書き込みが行われていないことが保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the purposes of OPEN delegation, READs and WRITEs done without an OPEN are treated as the functional equivalents of a corresponding type of OPEN. Although a client SHOULD NOT use special stateids when an open exists, delegation handling on the server can use the client ID associated with the current session to determine if the operation has been done by the holder of the delegation (in which case, no recall is necessary) or by another client (in which case, the delegation must be recalled and I/O not proceed until the delegation is recalled or revoked).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN委任の目的のために、OPENなしで行われるREADおよびWRITEは、対応するタイプのOPENと機能的に同等のものとして扱われます。オープンが存在する場合、クライアントは特別な状態IDを使用してはいけません（SHOULD NOT）が、サーバーでの委任処理は、現在のセッションに関連付けられたクライアントIDを使用して、操作が委任の所有者によって行われたかどうかを判断できます（この場合、再呼び出しは行われません）必要）または別のクライアント（この場合、委任は取り消される必要があり、委任が取り消されるか取り消されるまでI / Oは続行されません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With delegations, a client is able to avoid writing data to the server when the CLOSE of a file is serviced. The file close system call is the usual point at which the client is notified of a lack of stable storage for the modified file data generated by the application. At the close, file data is written to the server and, through normal accounting, the server is able to determine if the available file system space for the data has been exceeded (i.e., the server returns NFS4ERR_NOSPC or NFS4ERR_DQUOT). This accounting includes quotas. The introduction of delegations requires that an alternative method be in place for the same type of communication to occur between client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任を使用すると、クライアントは、ファイルのCLOSEが処理されるときに、サーバーへのデータの書き込みを回避できます。ファイルクローズシステムコールは、アプリケーションによって生成された変更されたファイルデータ用の安定したストレージの不足をクライアントに通知する通常のポイントです。終了時に、ファイルデータがサーバーに書き込まれ、通常のアカウンティングを通じて、サーバーはデータに使用可能なファイルシステム領域を超えているかどうかを判別できます（つまり、サーバーはNFS4ERR_NOSPCまたはNFS4ERR_DQUOTを返します）。このアカウンティングには割り当てが含まれます。委任を導入するには、クライアントとサーバー間で同じ種類の通信を行うための代替方法を用意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the delegation response, the server provides either the limit of the size of the file or the number of modified blocks and associated block size. The server must ensure that the client will be able to write modified data to the server of a size equal to that provided in the original delegation. The server must make this assurance for all outstanding delegations. Therefore, the server must be careful in its management of available space for new or modified data, taking into account available file system space and any applicable quotas. The server can recall delegations as a result of managing the available file system space. The client should abide by the server&#39;s state space limits for delegations. If the client exceeds the stated limits for the delegation, the server&#39;s behavior is undefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任応答では、サーバーはファイルのサイズの制限、または変更されたブロックの数と関連するブロックサイズのいずれかを提供します。サーバーは、クライアントが変更されたデータを元の委任で提供されたサイズと同じサイズでサーバーに書き込めることを確認する必要があります。サーバーは、すべての未解決の委任に対してこの保証を行う必要があります。したがって、サーバーは、使用可能なファイルシステムのスペースと適用可能なクォータを考慮して、新規または変更されたデータ用の使用可能なスペースの管理に注意する必要があります。サーバーは、使用可能なファイルシステム領域を管理した結果、委任を呼び出すことができます。クライアントは、委任に関するサーバーの状態スペース制限を遵守する必要があります。クライアントが指定された委任の制限を超えると、サーバーの動作は未定義になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on server conditions, quotas, or available file system space, the server may grant OPEN_DELEGATE_WRITE delegations with very restrictive space limitations. The limitations may be defined in a way that will always force modified data to be flushed to the server on close.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの状態、割り当て、または使用可能なファイルシステム領域に基づいて、サーバーはOPEN_DELEGATE_WRITE委任を非常に制限された領域制限で許可する場合があります。制限は、変更されたデータを常に閉じるときに強制的にサーバーにフラッシュするように定義できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With respect to authentication, flushing modified data to the server after a CLOSE has occurred may be problematic. For example, the user of the application may have logged off the client, and unexpired authentication credentials may not be present. In this case, the client may need to take special care to ensure that local unexpired credentials will in fact be available. This may be accomplished by tracking the expiration time of credentials and flushing data well in advance of their expiration or by making private copies of credentials to assure their availability when needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認証に関しては、CLOSEが発生した後に変更されたデータをサーバーにフラッシュすることは問題となる場合があります。たとえば、アプリケーションのユーザーがクライアントからログオフし、有効期限が切れていない認証資格情報が存在しない場合があります。この場合、クライアントは、有効期限が切れていないローカルの資格情報が実際に使用可能になるように特別な注意を払う必要がある場合があります。これは、資格情報の有効期限を追跡し、有効期限の前にデータをフラッシュするか、資格情報のプライベートコピーを作成して、必要なときに可用性を保証することで実現できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-4-2--Open-Delegation-and-File-Locks">
10.4.2. Open Delegation and File Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.2. 委任とファイルロックを開く
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client holds an OPEN_DELEGATE_WRITE delegation, lock operations are performed locally. This includes those required for mandatory byte-range locking. This can be done since the delegation implies that there can be no conflicting locks. Similarly, all of the revalidations that would normally be associated with obtaining locks and the flushing of data associated with the releasing of locks need not be done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがOPEN_DELEGATE_WRITE委任を保持している場合、ロック操作はローカルで実行されます。これには、必須のバイト範囲ロックに必要なものが含まれます。委任は競合するロックがないことを暗示しているため、これを行うことができます。同様に、通常はロックの取得に関連するすべての再検証と、ロックの解放に関連するデータのフラッシュを実行する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client holds an OPEN_DELEGATE_READ delegation, lock operations are not performed locally. All lock operations, including those requesting non-exclusive locks, are sent to the server for resolution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがOPEN_DELEGATE_READ委任を保持している場合、ロック操作はローカルでは実行されません。非排他的ロックを要求するものを含むすべてのロック操作は、解決のためにサーバーに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-4-3--Handling-of-CBGETATTR">
10.4.3. Handling of CB_GETATTR
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.3. CB_GETATTRの処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server needs to employ special handling for a GETATTR where the target is a file that has an OPEN_DELEGATE_WRITE delegation in effect. The reason for this is that the client holding the OPEN_DELEGATE_WRITE delegation may have modified the data, and the server needs to reflect this change to the second client that submitted the GETATTR. Therefore, the client holding the OPEN_DELEGATE_WRITE delegation needs to be interrogated. The server will use the CB_GETATTR operation. The only attributes that the server can reliably query via CB_GETATTR are size and change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ターゲットがOPEN_DELEGATE_WRITE委任が有効になっているファイルであるGETATTRに対して特別な処理を採用する必要があります。これは、OPEN_DELEGATE_WRITE委任を保持しているクライアントがデータを変更した可能性があり、サーバーがこの変更をGETATTRを送信した2番目のクライアントに反映する必要があるためです。したがって、OPEN_DELEGATE_WRITE委任を保持しているクライアントに問い合わせる必要があります。サーバーはCB_GETATTR操作を使用します。サーバーがCB_GETATTRを介して確実に照会できる属性は、サイズと変更のみです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since CB_GETATTR is being used to satisfy another client&#39;s GETATTR request, the server only needs to know if the client holding the delegation has a modified version of the file. If the client&#39;s copy of the delegated file is not modified (data or size), the server can satisfy the second client&#39;s GETATTR request from the attributes stored locally at the server. If the file is modified, the server only needs to know about this modified state. If the server determines that the file is currently modified, it will respond to the second client&#39;s GETATTR as if the file had been modified locally at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_GETATTRは別のクライアントのGETATTR要求を満たすために使用されているため、サーバーは、委任を保持しているクライアントが変更されたバージョンのファイルを持っているかどうかを知るだけで済みます。委任されたファイルのクライアントのコピーが変更されていない場合（データまたはサイズ）、サーバーは、サーバーにローカルに格納されている属性からの2番目のクライアントのGETATTR要求を満たすことができます。ファイルが変更された場合、サーバーはこの変更された状態についてのみ知る必要があります。ファイルが現在変更されているとサーバーが判断すると、サーバーでファイルがローカルで変更されたかのように、2番目のクライアントのGETATTRに応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the form of the change attribute is determined by the server and is opaque to the client, the client and server need to agree on a method of communicating the modified state of the file. For the size attribute, the client will report its current view of the file size. For the change attribute, the handling is more involved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更属性の形式はサーバーによって決定され、クライアントに対して不透明であるため、クライアントとサーバーは、ファイルの変更された状態を通信する方法について合意する必要があります。 size属性の場合、クライアントはファイルサイズの現在のビューを報告します。変更属性の場合、処理はより複雑になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the client, the following steps will be taken when receiving an OPEN_DELEGATE_WRITE delegation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの場合、OPEN_DELEGATE_WRITE委任を受信すると、次の手順が実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value of the change attribute will be obtained from the server and cached. Let this value be represented by c.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 変更属性の値はサーバーから取得され、キャッシュされます。この値をcで表すとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client will create a value greater than c that will be used for communicating that modified data is held at the client. Let this value be represented by d.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは、変更されたデータがクライアントで保持されていることを伝えるために使用されるcより大きい値を作成します。この値をdで表すとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the client is queried via CB_GETATTR for the change attribute, it checks to see if it holds modified data. If the file is modified, the value d is returned for the change attribute value. If this file is not currently modified, the client returns the value c for the change attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは、CB_GETATTRを介して変更属性を照会されると、変更されたデータを保持しているかどうかを確認します。ファイルが変更されると、変更属性値として値dが返されます。このファイルが現在変更されていない場合、クライアントは、変更属性の値cを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For simplicity of implementation, the client MAY for each CB_GETATTR return the same value d. This is true even if, between successive CB_GETATTR operations, the client again modifies the file&#39;s data or metadata in its cache. The client can return the same value because the only requirement is that the client be able to indicate to the server that the client holds modified data. Therefore, the value of d may always be c + 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装を簡単にするために、各CB_GETATTRのクライアントは同じ値dを返す場合があります。これは、連続するCB_GETATTR操作の間に、クライアントがキャッシュ内のファイルのデータまたはメタデータを再度変更した場合でも当てはまります。クライアントが変更されたデータを保持していることをクライアントがサーバーに示すことができることが唯一の要件であるため、クライアントは同じ値を返すことができます。したがって、dの値は常にc + 1になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the change attribute is opaque to the client in the sense that it has no idea what units of time, if any, the server is counting change with, it is not opaque in that the client has to treat it as an unsigned integer, and the server has to be able to see the results of the client&#39;s changes to that integer. Therefore, the server MUST encode the change attribute in network order when sending it to the client. The client MUST decode it from network order to its native order when receiving it, and the client MUST encode it in network order when sending it to the server. For this reason, change is defined as an unsigned integer rather than an opaque array of bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更属性は、サーバーが変更をカウントしている時間単位がある場合、その単位が分からないという意味でクライアントに対して不透明ですが、クライアントがそれを符号なし整数として処理する必要があるという点では不透明ではありません。サーバーは、その整数に対するクライアントの変更の結果を見ることができる必要があります。したがって、サーバーは、クライアントに送信するときに、変更属性をネットワーク順にエンコードする必要があります。クライアントはそれを受信するときに、それをネットワーク順序からそのネイティブの順序にデコードする必要があり、クライアントは、サーバーに送信するときにネットワーク順序でエンコードする必要があります。このため、変更は、不透明なバイト配列ではなく、符号なし整数として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the server, the following steps will be taken when providing an OPEN_DELEGATE_WRITE delegation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの場合、OPEN_DELEGATE_WRITE委任を提供するときに次の手順が実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Upon providing an OPEN_DELEGATE_WRITE delegation, the server will cache a copy of the change attribute in the data structure it uses to record the delegation. Let this value be represented by sc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN_DELEGATE_WRITE委任を提供すると、サーバーは、変更属性のコピーを、委任の記録に使用するデータ構造にキャッシュします。この値をscで表すとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a second client sends a GETATTR operation on the same file to the server, the server obtains the change attribute from the first client. Let this value be cc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2番目のクライアントが同じファイルのGETATTR操作をサーバーに送信すると、サーバーは最初のクライアントから変更属性を取得します。この値をccとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the value cc is equal to sc, the file is not modified and the server returns the current values for change, time_metadata, and time_modify (for example) to the second client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 値ccがscと等しい場合、ファイルは変更されず、サーバーは変更、time_metadata、time_modifyなどの現在の値を2番目のクライアントに返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the value cc is NOT equal to sc, the file is currently modified at the first client and most likely will be modified at the server at a future time. The server then uses its current time to construct attribute values for time_metadata and time_modify. A new value of sc, which we will call nsc, is computed by the server, such that nsc &gt;= sc + 1. The server then returns the constructed time_metadata, time_modify, and nsc values to the requester. The server replaces sc in the delegation record with nsc. To prevent the possibility of time_modify, time_metadata, and change from appearing to go backward (which would happen if the client holding the delegation fails to write its modified data to the server before the delegation is revoked or returned), the server SHOULD update the file&#39;s metadata record with the constructed attribute values. For reasons of reasonable performance, committing the constructed attribute values to stable storage is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 値ccがscと等しくない場合、ファイルは現在最初のクライアントで変更されており、おそらくサーバーで将来変更されます。次に、サーバーは現在の時刻を使用して、time_metadataおよびtime_modifyの属性値を作成します。 nscと呼ばれる新しいscの値は、nsc&gt; = sc + 1のようにサーバーによって計算されます。サーバーは、構築されたtime_metadata、time_modify、およびnscの値をリクエスターに返します。サーバーは、委任レコードのscをnscに置き換えます。 time_modify、time_metadata、およびchangeが後退しているように見える可能性を回避するには（委任が取り消されるか戻される前に、委任を保持しているクライアントが変更されたデータをサーバーに書き込めなかった場合に発生します）、サーバーはファイルの更新を行う必要があります（SHOULD）構築された属性値を持つメタデータレコード。妥当なパフォーマンスの理由から、構築された属性値を安定したストレージにコミットすることはオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed earlier in this section, the client MAY return the same cc value on subsequent CB_GETATTR calls, even if the file was modified in the client&#39;s cache yet again between successive CB_GETATTR calls. Therefore, the server must assume that the file has been modified yet again, and MUST take care to ensure that the new nsc it constructs and returns is greater than the previous nsc it returned. An example implementation&#39;s delegation record would satisfy this mandate by including a boolean field (let us call it &#34;modified&#34;) that is set to FALSE when the delegation is granted, and an sc value set at the time of grant to the change attribute value. The modified field would be set to TRUE the first time cc != sc, and would stay TRUE until the delegation is returned or revoked. The processing for constructing nsc, time_modify, and time_metadata would use this pseudo code:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションの前半で説明したように、連続するCB_GETATTR呼び出しの間にファイルがクライアントのキャッシュで変更されていても、クライアントは後続のCB_GETATTR呼び出しで同じcc値を返す場合があります。したがって、サーバーはファイルが再び変更されたと想定する必要があり、サーバーが構築して返す新しいnscが以前に返されたnscよりも大きくなるように注意する必要があります。実装例の委任レコードは、委任が許可されたときにFALSEに設定されたブールフィールド（「変更済み」と呼ぶ）と、変更属性値への許可時に設定されたsc値を含めることにより、この要件を満たします。変更されたフィールドは、初めてcc！= scにTRUEに設定され、委任が返されるか取り消されるまでTRUEのままになります。 nsc、time_modify、およびtime_metadataを作成する処理では、次の疑似コードを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (!modified) {
           do CB_GETATTR for change and size;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (cc != sc)
               modified = TRUE;
       } else {
           do CB_GETATTR for size;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (modified) {
           sc = sc + 1;
           time_modify = time_metadata = current_time;
           update sc, time_modify, time_metadata into file&#39;s metadata;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This would return to the client (that sent GETATTR) the attributes it requested, but make sure size comes from what CB_GETATTR returned. The server would not update the file&#39;s metadata with the client&#39;s modified size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、クライアント（GETATTRを送信したクライアント）が要求した属性が返されますが、サイズがCB_GETATTRが返したものであることを確認してください。サーバーは、クライアントの変更されたサイズでファイルのメタデータを更新しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that the file attribute size is different than the server&#39;s current value, the server treats this as a modification regardless of the value of the change attribute retrieved via CB_GETATTR and responds to the second client as in the last step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイル属性のサイズがサーバーの現在の値と異なる場合、サーバーは、CB_GETATTRを介して取得した変更属性の値に関係なく、これを変更として扱い、最後の手順と同様に2番目のクライアントに応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This methodology resolves issues of clock differences between client and server and other scenarios where the use of CB_GETATTR break down.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この方法論は、クライアントとサーバー間のクロックの違いの問題と、CB_GETATTRの使用が失敗する他のシナリオを解決します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that the server is under no obligation to use CB_GETATTR, and therefore the server MAY simply recall the delegation to avoid its use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはCB_GETATTRを使用する義務がないので、サーバーはその使用を回避するために委任を単に呼び出してもよいことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-4-4--Recall-of-Open-Delegation">
10.4.4. Recall of Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.4. オープンな委任の想起
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following events necessitate recall of an OPEN delegation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のイベントでは、OPEN委任の再呼び出しが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o potentially conflicting OPEN request (or a READ or WRITE operation done with a special stateid)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 競合する可能性のあるOPEN要求（または特別な状態IDで実行されるREADまたはWRITE操作）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SETATTR sent by another client
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 別のクライアントによって送信されたSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o REMOVE request for the file
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルのREMOVEリクエスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RENAME request for the file as either the source or target of the RENAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RENAMEのソースまたはターゲットとしてのファイルのRENAME要求
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whether a RENAME of a directory in the path leading to the file results in recall of an OPEN delegation depends on the semantics of the server&#39;s file system. If that file system denies such RENAMEs when a file is open, the recall must be performed to determine whether the file in question is, in fact, open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルへのパスにあるディレクトリのRENAMEがOPEN委任を呼び戻すかどうかは、サーバーのファイルシステムのセマンティクスによって異なります。ファイルが開いているときにそのファイルシステムがそのようなRENAMEを拒否した場合、問題のファイルが実際に開いているかどうかを判断するために再呼び出しを実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to the situations above, the server may choose to recall OPEN delegations at any time if resource constraints make it advisable to do so. Clients should always be prepared for the possibility of recall.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の状況に加えて、サーバーは、リソースの制約によりOPEN委任を呼び戻すことを推奨する場合、いつでも呼び戻すことを選択できます。クライアントは常にリコールの可能性に備える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client receives a recall for an OPEN delegation, it needs to update state on the server before returning the delegation. These same updates must be done whenever a client chooses to return a delegation voluntarily. The following items of state need to be dealt with:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがOPEN委任の再呼び出しを受信した場合、クライアントは委任を返す前にサーバーの状態を更新する必要があります。これらの同じ更新は、クライアントが自発的に委任を返すことを選択するたびに実行する必要があります。以下の状態の項目を処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the file associated with the delegation is no longer open and no previous CLOSE operation has been sent to the server, a CLOSE operation must be sent to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 委任に関連付けられているファイルが開かれておらず、以前のCLOSE操作がサーバーに送信されていない場合は、CLOSE操作をサーバーに送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If a file has other open references at the client, then OPEN operations must be sent to the server. The appropriate stateids will be provided by the server for subsequent use by the client since the delegation stateid will no longer be valid. These OPEN requests are done with the claim type of CLAIM_DELEGATE_CUR. This will allow the presentation of the delegation stateid so that the client can establish the appropriate rights to perform the OPEN. (see Section 18.16, which describes the OPEN operation, for details.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルにクライアントで他の開いている参照がある場合、OPEN操作をサーバーに送信する必要があります。委任状態IDは有効でなくなるため、サーバーが適切な状態IDを提供し、クライアントが後で使用できるようにします。これらのOPEN要求は、CLAIM_DELEGATE_CURのクレームタイプで実行されます。これにより、クライアントがOPENを実行するための適切な権限を確立できるように、委任状態IDを提示できます。 （詳細については、OPEN操作について説明しているセクション18.16を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If there are granted byte-range locks, the corresponding LOCK operations need to be performed. This applies to the OPEN_DELEGATE_WRITE delegation case only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 許可されたバイト範囲ロックがある場合、対応するLOCK操作を実行する必要があります。これは、OPEN_DELEGATE_WRITE委任の場合にのみ適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For an OPEN_DELEGATE_WRITE delegation, if at the time of recall the file is not open for OPEN4_SHARE_ACCESS_WRITE/ OPEN4_SHARE_ACCESS_BOTH, all modified data for the file must be flushed to the server. If the delegation had not existed, the client would have done this data flush before the CLOSE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN_DELEGATE_WRITE委任の場合、再呼び出しの時点でファイルがOPEN4_SHARE_ACCESS_WRITE / OPEN4_SHARE_ACCESS_BOTHに対して開いていない場合、ファイルのすべての変更済みデータをサーバーにフラッシュする必要があります。委任が存在しなかった場合、クライアントはCLOSE操作の前にこのデータフラッシュを実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For an OPEN_DELEGATE_WRITE delegation when a file is still open at the time of recall, any modified data for the file needs to be flushed to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN_DELEGATE_WRITE委任の場合、再呼び出し時にファイルがまだ開いているときは、ファイルの変更されたデータをサーバーにフラッシュする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o With the OPEN_DELEGATE_WRITE delegation in place, it is possible that the file was truncated during the duration of the delegation. For example, the truncation could have occurred as a result of an OPEN UNCHECKED with a size attribute value of zero. Therefore, if a truncation of the file has occurred and this operation has not been propagated to the server, the truncation must occur before any modified data is written to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
o OPEN_DELEGATE_WRITE委任が設定されている場合、委任の実行中にファイルが切り捨てられた可能性があります。たとえば、サイズ属性値がゼロのOPEN UNCHECKEDの結果として切り捨てが発生した可能性があります。したがって、ファイルの切り捨てが発生し、この操作がサーバーに伝達されていない場合、変更されたデータがサーバーに書き込まれる前に切り捨てが行われる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of OPEN_DELEGATE_WRITE delegation, byte-range locking imposes some additional requirements. To precisely maintain the associated invariant, it is required to flush any modified data in any byte-range for which a WRITE_LT lock was released while the OPEN_DELEGATE_WRITE delegation was in effect. However, because the OPEN_DELEGATE_WRITE delegation implies no other locking by other clients, a simpler implementation is to flush all modified data for the file (as described just above) if any WRITE_LT lock has been released while the OPEN_DELEGATE_WRITE delegation was in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN_DELEGATE_WRITE委任の場合、バイト範囲ロックはいくつかの追加要件を課します。関連する不変条件を正確に維持するには、OPEN_DELEGATE_WRITE委任が有効である間にWRITE_LTロックが解放されたバイト範囲の変更データをフラッシュする必要があります。ただし、OPEN_DELEGATE_WRITE委任が他のクライアントによる他のロックを意味しないため、OPEN_DELEGATE_WRITE委任が有効である間にWRITE_LTロックが解放された場合、より簡単な実装は、（上記のように）ファイルのすべての変更データをフラッシュすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation need not wait until delegation recall (or the decision to voluntarily return a delegation) to perform any of the above actions, if implementation considerations (e.g., resource availability constraints) make that desirable. Generally, however, the fact that the actual OPEN state of the file may continue to change makes it not worthwhile to send information about opens and closes to the server, except as part of delegation return. An exception is when the client has no more internal opens of the file. In this case, sending a CLOSE is useful because it reduces resource utilization on the client and server. Regardless of the client&#39;s choices on scheduling these actions, all must be performed before the delegation is returned, including (when applicable) the close that corresponds to the OPEN that resulted in the delegation. These actions can be performed either in previous requests or in previous operations in the same COMPOUND request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装の考慮事項（リソースの可用性の制約など）により望ましい場合は、実装は、委任の取り消し（または委任を自発的に返す決定）まで待機して、上記のアクションを実行する必要はありません。ただし、一般的には、ファイルの実際のOPEN状態が変化し続ける可能性があるため、委任の返却の場合を除いて、オープンとクローズに関する情報をサーバーに送信する価値はありません。例外は、クライアントがファイルの内部オープンをもう持っていない場合です。この場合、CLOSEを送信すると、クライアントとサーバーのリソース使用率が低下するため便利です。これらのアクションのスケジュールに関するクライアントの選択に関係なく、委任が発生したOPENに対応するクローズ（該当する場合）を含め、すべてが委任が返される前に実行する必要があります。これらのアクションは、同じCOMPOUNDリクエストの以前のリクエストまたは以前の操作で実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-4-5--Clients-That-Fail-to-Honor-Delegation-Recalls">
10.4.5. Clients That Fail to Honor Delegation Recalls
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.5. 委任取り消しを受け入れられないクライアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client may fail to respond to a recall for various reasons, such as a failure of the backchannel from server to the client. The client may be unaware of a failure in the backchannel. This lack of awareness could result in the client finding out long after the failure that its delegation has been revoked, and another client has modified the data for which the client had a delegation. This is especially a problem for the client that held an OPEN_DELEGATE_WRITE delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、サーバーからクライアントへのバックチャネルの障害など、さまざまな理由でリコールに応答できない場合があります。クライアントは、バックチャネルの障害に気付かない可能性があります。この認識の欠如により、クライアントは、委任が取り消されたことが障害のずっと後に判明し、別のクライアントがクライアントが委任したデータを変更した可能性があります。これは、OPEN_DELEGATE_WRITE委任を保持していたクライアントにとって特に問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Status bits returned by SEQUENCE operations help to provide an alternate way of informing the client of issues regarding the status of the backchannel and of recalled delegations. When the backchannel is not available, the server returns the status bit SEQ4_STATUS_CB_PATH_DOWN on SEQUENCE operations. The client can react by attempting to re-establish the backchannel and by returning recallable objects if a backchannel cannot be successfully re-established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
SEQUENCE操作によって返されるステータスビットは、バックチャネルのステータスに関する問題と呼び出された委任についてクライアントに通知する代替方法を提供するのに役立ちます。バックチャネルが使用できない場合、サーバーはSEQUENCE操作でステータスビットSEQ4_STATUS_CB_PATH_DOWNを返します。クライアントは、バックチャネルの再確立を試み、バックチャネルを正常に再確立できない場合は、再呼び出し可能なオブジェクトを返すことで対応できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whether the backchannel is functioning or not, it may be that the recalled delegation is not returned. Note that the client&#39;s lease might still be renewed, even though the recalled delegation is not returned. In this situation, servers SHOULD revoke delegations that are not returned in a period of time equal to the lease period. This period of time should allow the client time to note the backchannel-down status and re-establish the backchannel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バックチャネルが機能しているかどうかに関係なく、呼び出された委任が返されない場合があります。呼び出された委任が返されない場合でも、クライアントのリースは更新される可能性があることに注意してください。この状況では、サーバーはリース期間と同じ期間に返されない委任を取り消す必要があります（SHOULD）。この期間は、クライアントがバックチャネルダウンステータスを確認し、バックチャネルを再確立できるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When delegations are revoked, the server will return with the SEQ4_STATUS_RECALLABLE_STATE_REVOKED status bit set on subsequent SEQUENCE operations. The client should note this and then use TEST_STATEID to find which delegations have been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任が取り消されると、サーバーは後続のSEQUENCE操作でSEQ4_STATUS_RECALLABLE_STATE_REVOKEDステータスビットを設定して戻ります。クライアントはこれに注意し、TEST_STATEIDを使用して、どの委任が取り消されたかを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-4-6--Delegation-Revocation">
10.4.6. Delegation Revocation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.6. 委任の取り消し
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the point a delegation is revoked, if there are associated opens on the client, these opens may or may not be revoked. If no byte-range lock or open is granted that is inconsistent with the existing open, the stateid for the open may remain valid and be disconnected from the revoked delegation, just as would be the case if the delegation were returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任が取り消された時点で、クライアントに関連付けられたオープンがある場合、これらのオープンは取り消される場合と取り消されない場合があります。既存のオープンと矛盾するバイト範囲ロックまたはオープンが許可されていない場合、委任が返された場合と同様に、オープンの状態IDは有効なままであり、取り消された委任から切断される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, if an OPEN for OPEN4_SHARE_ACCESS_BOTH with a deny of OPEN4_SHARE_DENY_NONE is associated with the delegation, granting of another such OPEN to a different client will revoke the delegation but need not revoke the OPEN, since the two OPENs are consistent with each other. On the other hand, if an OPEN denying write access is granted, then the existing OPEN must be revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、OPEN4_SHARE_DENY_NONEの拒否を伴うOPEN4_SHARE_ACCESS_BOTHのOPENが委任に関連付けられている場合、別のクライアントにそのようなOPENを許可すると委任は取り消されますが、2つのOPENは互いに整合しているため、OPENを取り消す必要はありません。一方、書き込みアクセスを拒否するOPENが許可されている場合は、既存のOPENを取り消す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When opens and/or locks are revoked, the applications holding these opens or locks need to be notified. This notification usually occurs by returning errors for READ/WRITE operations or when a close is attempted for the open file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープンやロックが取り消されると、これらのオープンやロックを保持しているアプリケーションに通知する必要があります。この通知は通常、READ / WRITE操作のエラーを返すことによって、または開いているファイルに対してクローズが試行されたときに発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If no opens exist for the file at the point the delegation is revoked, then notification of the revocation is unnecessary. However, if there is modified data present at the client for the file, the user of the application should be notified. Unfortunately, it may not be possible to notify the user since active applications may not be present at the client. See Section 10.5.1 for additional details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任が取り消された時点でファイルのオープンが存在しない場合、取り消しの通知は不要です。ただし、ファイルにクライアントで変更されたデータが存在する場合は、アプリケーションのユーザーに通知する必要があります。残念ながら、アクティブなアプリケーションがクライアントに存在しない可能性があるため、ユーザーに通知することができない場合があります。詳細については、セクション10.5.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-4-7--Delegations-via-WANTDELEGATION">
10.4.7. Delegations via WANT_DELEGATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.7. WANT_DELEGATIONによる委任
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to providing delegations as part of the reply to OPEN operations, servers MAY provide delegations separate from open, via the OPTIONAL WANT_DELEGATION operation. This allows delegations to be obtained in advance of an OPEN that might benefit from them, for objects that are not a valid target of OPEN, or to deal with cases in which a delegation has been recalled and the client wants to make an attempt to re-establish it if the absence of use by other clients allows that.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN操作への応答の一部として委任を提供することに加えて、サーバーは、OPTIONAL WANT_DELEGATION操作を介して、オープンとは別に委任を提供する場合があります。これにより、OPENの有効なターゲットではないオブジェクトについて、OPENの前にデリゲートを取得できます。または、デリゲートがリコールされ、クライアントが再試行を試みた場合に対処できます。 -他のクライアントによる使用の欠如がそれを可能にする場合、それを確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WANT_DELEGATION operation may be performed on any type of file object other than a directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WANT_DELEGATION操作は、ディレクトリ以外の任意のタイプのファイルオブジェクトに対して実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a delegation is obtained using WANT_DELEGATION, any open files for the same filehandle held by that client are to be treated as subordinate to the delegation, just as if they had been created using an OPEN of type CLAIM_DELEGATE_CUR. They are otherwise unchanged as to seqid, access and deny modes, and the relationship with byte-range locks. Similarly, because existing byte-range locks are subordinate to an open, those byte-range locks also become indirectly subordinate to that new delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WANT_DELEGATIONを使用して委任を取得すると、そのクライアントが保持する同じファイルハンドルの開いているファイルは、CLAIM_DELEGATE_CURタイプのOPENを使用して作成された場合と同様に、委任に従属するものとして扱われます。それ以外は、seqid、アクセス、拒否モード、およびバイト範囲ロックとの関係については変更されていません。同様に、既存のバイト範囲ロックはオープンに従属しているため、それらのバイト範囲ロックも間接的にその新しい委任に従属します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WANT_DELEGATION operation provides for delivery of delegations via callbacks, when the delegations are not immediately available. When a requested delegation is available, it is delivered to the client via a CB_PUSH_DELEG operation. When this happens, open files for the same filehandle become subordinate to the new delegation at the point at which the delegation is delivered, just as if they had been created using an OPEN of type CLAIM_DELEGATE_CUR. Similarly, this occurs for existing byte-range locks subordinate to an open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WANT_DELEGATION操作は、委任がすぐに利用できない場合に、コールバックを介して委任の配信を提供します。要求された委任が利用可能な場合、それはCB_PUSH_DELEG操作を介してクライアントに配信されます。これが発生すると、同じファイルハンドルの開いているファイルは、CLAIM_DELEGATE_CURタイプのOPENを使用して作成された場合と同様に、委任が配信された時点で新しい委任に従属します。同様に、これはオープンに従属する既存のバイト範囲ロックでも発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-5--Data-Caching-and-Revocation">
10.5. Data Caching and Revocation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5. データのキャッシュと失効
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When locks and delegations are revoked, the assumptions upon which successful caching depends are no longer guaranteed. For any locks or share reservations that have been revoked, the corresponding state-owner needs to be notified. This notification includes applications with a file open that has a corresponding delegation that has been revoked. Cached data associated with the revocation must be removed from the client. In the case of modified data existing in the client&#39;s cache, that data must be removed from the client without being written to the server. As mentioned, the assumptions made by the client are no longer valid at the point when a lock or delegation has been revoked. For example, another client may have been granted a conflicting byte-range lock after the revocation of the byte-range lock at the first client. Therefore, the data within the lock range may have been modified by the other client. Obviously, the first client is unable to guarantee to the application what has occurred to the file in the case of revocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ロックと委任が取り消されると、キャッシュが成功するかどうかの前提は保証されなくなります。取り消されたロックまたは共有予約については、対応する状態所有者に通知する必要があります。この通知には、取り消された対応する委任を持つファイルが開かれているアプリケーションが含まれます。失効に関連付けられたキャッシュデータは、クライアントから削除する必要があります。クライアントのキャッシュに変更されたデータが存在する場合、そのデータはサーバーに書き込まれずにクライアントから削除する必要があります。前述のように、クライアントが行った前提は、ロックまたは委任が取り消された時点では無効になります。たとえば、別のクライアントは、最初のクライアントでバイト範囲ロックが取り消された後、競合するバイト範囲ロックを許可されている場合があります。したがって、ロック範囲内のデータが他のクライアントによって変更された可能性があります。明らかに、最初のクライアントは、失効の場合にファイルに何が起こったかをアプリケーションに保証することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notification to a state-owner will in many cases consist of simply returning an error on the next and all subsequent READs/WRITEs to the open file or on the close. Where the methods available to a client make such notification impossible because errors for certain operations may not be returned, more drastic action such as signals or process termination may be appropriate. The justification here is that an invariant on which an application depends may be violated. Depending on how errors are typically treated for the client-operating environment, further levels of notification including logging, console messages, and GUI pop-ups may be appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態所有者への通知は、多くの場合、開いているファイルへの次の、およびその後のすべての読み取り/書き込み、または閉じたときにエラーを返すだけで構成されます。特定の操作のエラーが返されない可能性があるため、クライアントが使用できるメソッドがそのような通知を不可能にする場合、シグナルやプロセスの終了などのより徹底的なアクションが適切な場合があります。ここでの正当化は、アプリケーションが依存する不変条件に違反する可能性があることです。クライアント操作環境でエラーが通常どのように処理されるかに応じて、ログ、コンソールメッセージ、およびGUIポップアップを含む、さらに高いレベルの通知が適切な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-5-1--Revocation-Recovery-for-Write-Open-Delegation">
10.5.1. Revocation Recovery for Write Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.1. 書き込みオープン委任の失効回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Revocation recovery for an OPEN_DELEGATE_WRITE delegation poses the special issue of modified data in the client cache while the file is not open. In this situation, any client that does not flush modified data to the server on each close must ensure that the user receives appropriate notification of the failure as a result of the revocation. Since such situations may require human action to correct problems, notification schemes in which the appropriate user or administrator is notified may be necessary. Logging and console messages are typical examples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN_DELEGATE_WRITE委任の失効回復は、ファイルが開いていないときにクライアントキャッシュに変更されたデータの特別な問題を引き起こします。この状況では、閉じるたびに変更されたデータをサーバーにフラッシュしないクライアントは、失効の結果としてユーザーが失敗の適切な通知を確実に受け取るようにする必要があります。このような状況では、問題を修正するために人間のアクションが必要になる場合があるため、適切なユーザーまたは管理者に通知する通知スキームが必要になる場合があります。ロギングおよびコンソールメッセージは典型的な例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there is modified data on the client, it must not be flushed normally to the server. A client may attempt to provide a copy of the file data as modified during the delegation under a different name in the file system namespace to ease recovery. Note that when the client can determine that the file has not been modified by any other client, or when the client has a complete cached copy of the file in question, such a saved copy of the client&#39;s view of the file may be of particular value for recovery. In another case, recovery using a copy of the file based partially on the client&#39;s cached data and partially on the server&#39;s copy as modified by other clients will be anything but straightforward, so clients may avoid saving file contents in these situations or specially mark the results to warn users of possible problems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント上に変更されたデータがある場合、それをサーバーに正常にフラッシュしてはなりません。クライアントは、委任中に変更されたファイルデータのコピーを、回復を容易にするためにファイルシステムの名前空間の別の名前で提供しようとする場合があります。クライアントがファイルが他のクライアントによって変更されていないことを判別できる場合、またはクライアントに問題のファイルの完全なキャッシュされたコピーがある場合、ファイルのクライアントのビューのそのような保存されたコピーは特定の値である可能性があることに注意してください回復のため。別のケースでは、クライアントのキャッシュデータに部分的に基づいたファイルのコピーと、他のクライアントによって変更されたサーバーのコピーに部分的に基づいたファイルを使用したリカバリは簡単ではないため、クライアントはこれらの状況でファイルの内容を保存しないか、結果に特別なマークを付けることができます。ユーザーに問題の可能性を警告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Saving of such modified data in delegation revocation situations may be limited to files of a certain size or might be used only when sufficient disk space is available within the target file system. Such saving may also be restricted to situations when the client has sufficient buffering resources to keep the cached copy available until it is properly stored to the target file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任の取り消し状況でのこのような変更されたデータの保存は、特定のサイズのファイルに制限されるか、ターゲットファイルシステム内に十分なディスク領域がある場合にのみ使用される場合があります。このような保存は、ターゲットファイルシステムに適切に保存されるまで、キャッシュされたコピーを利用可能な状態に保つのに十分なバッファリングリソースがクライアントにある場合にも制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-6--Attribute-Caching">
10.6. Attribute Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.6. 属性キャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section pertains to the caching of a file&#39;s attributes on a client when that client does not hold a delegation on the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションは、クライアントがファイルの委任を保持していない場合の、クライアントでのファイルの属性のキャッシングに関するものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attributes discussed in this section do not include named attributes. Individual named attributes are analogous to files, and caching of the data for these needs to be handled just as data caching is for ordinary files. Similarly, LOOKUP results from an OPENATTR directory (as well as the directory&#39;s contents) are to be cached on the same basis as any other pathnames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションで説明する属性には、名前付き属性は含まれていません。個々の名前付き属性はファイルに類似しており、これらのデータのキャッシュは、通常のファイルのデータキャッシュと同様に処理する必要があります。同様に、OPENATTRディレクトリからのLOOKUP結果（およびディレクトリの内容）は、他のパス名と同じ基準でキャッシュされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients may cache file attributes obtained from the server and use them to avoid subsequent GETATTR requests. Such caching is write through in that modification to file attributes is always done by means of requests to the server and should not be done locally and should not be cached. The exception to this are modifications to attributes that are intimately connected with data caching. Therefore, extending a file by writing data to the local data cache is reflected immediately in the size as seen on the client without this change being immediately reflected on the server. Normally, such changes are not propagated directly to the server, but when the modified data is flushed to the server, analogous attribute changes are made on the server. When OPEN delegation is in effect, the modified attributes may be returned to the server in reaction to a CB_RECALL call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはサーバーから取得したファイル属性をキャッシュし、それを使用して後続のGETATTR要求を回避できます。このようなキャッシングは、ファイル属性の変更が常にサーバーへの要求によって行われるため、ローカルで行われるべきではなく、キャッシュされるべきではないため、ライトスルーです。これの例外は、データキャッシングと密接に関連している属性の変更です。したがって、ローカルデータキャッシュにデータを書き込んでファイルを拡張すると、この変更がサーバーにすぐに反映されることなく、クライアントに表示されるサイズにすぐに反映されます。通常、このような変更はサーバーに直接伝達されませんが、変更されたデータがサーバーにフラッシュされると、サーバーで同様の属性の変更が行われます。 OPEN委任が有効な場合、CB_RECALL呼び出しに反応して、変更された属性がサーバーに返されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The result of local caching of attributes is that the attribute caches maintained on individual clients will not be coherent. Changes made in one order on the server may be seen in a different order on one client and in a third order on another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性のローカルキャッシングの結果、個々のクライアントで維持される属性キャッシュは一貫しなくなります。サーバーで1つの順序で行われた変更は、1つのクライアントでは別の順序で、別のクライアントでは3番目の順序で表示される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The typical file system application programming interfaces do not provide means to atomically modify or interrogate attributes for multiple files at the same time. The following rules provide an environment where the potential incoherencies mentioned above can be reasonably managed. These rules are derived from the practice of previous NFS protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
典型的なファイルシステムアプリケーションプログラミングインターフェイスは、複数のファイルの属性を同時にアトミックに変更または照会する手段を提供しません。以下のルールは、上記の潜在的な矛盾を合理的に管理できる環境を提供します。これらのルールは、以前のNFSプロトコルの慣習から派生しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All attributes for a given file (per-fsid attributes excepted) are cached as a unit at the client so that no non-serializability can arise within the context of a single file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 特定のファイルのすべての属性（fsidごとの属性を除く）は、単一のファイルのコンテキスト内で非直列化が発生しないように、クライアントでユニットとしてキャッシュされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An upper time boundary is maintained on how long a client cache entry can be kept without being refreshed from the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントのキャッシュエントリをサーバーから更新せずに保持できる時間の上限は維持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When operations are performed that change attributes at the server, the updated attribute set is requested as part of the containing RPC. This includes directory operations that update attributes indirectly. This is accomplished by following the modifying operation with a GETATTR operation and then using the results of the GETATTR to update the client&#39;s cached attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーで属性を変更する操作が実行されると、含まれているRPCの一部として更新された属性セットが要求されます。これには、属性を間接的に更新するディレクトリ操作が含まれます。これは、GETATTR操作で変更操作を実行し、GETATTRの結果を使用してクライアントのキャッシュされた属性を更新することで実現されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if the full set of attributes to be cached is requested by READDIR, the results can be cached by the client on the same basis as attributes obtained via GETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キャッシュする属性の完全なセットがREADDIRによって要求された場合、GETATTRを介して取得した属性と同じ基準で、クライアントが結果をキャッシュできることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client may validate its cached version of attributes for a file by fetching both the change and time_access attributes and assuming that if the change attribute has the same value as it did when the attributes were cached, then no attributes other than time_access have changed. The reason why time_access is also fetched is because many servers operate in environments where the operation that updates change does not update time_access. For example, POSIX file semantics do not update access time when a file is modified by the write system call [18]. Therefore, the client that wants a current time_access value should fetch it with change during the attribute cache validation processing and update its cached time_access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、change属性とtime_access属性の両方をフェッチし、属性がキャッシュされたときと同じ値がchange属性にある場合、time_access以外の属性は変更されていないと想定することにより、ファイルの属性のキャッシュバージョンを検証できます。 time_accessもフェッチされるのは、更新を変更する操作ではtime_accessが更新されない環境で多くのサーバーが動作するためです。たとえば、POSIXファイルセマンティクスは、ファイルが書き込みシステムコールによって変更されたときにアクセス時間を更新しません[18]。したがって、現在のtime_access値を必要とするクライアントは、属性キャッシュの検証処理中に変更を加えてフェッチし、キャッシュされたtime_accessを更新する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client may maintain a cache of modified attributes for those attributes intimately connected with data of modified regular files (size, time_modify, and change). Other than those three attributes, the client MUST NOT maintain a cache of modified attributes. Instead, attribute changes are immediately sent to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、変更された通常のファイル（サイズ、time_modify、および変更）のデータと密接に関連している属性の変更された属性のキャッシュを維持できます。これらの3つの属性以外では、クライアントは変更された属性のキャッシュを維持してはなりません（MUST NOT）。代わりに、属性の変更はすぐにサーバーに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In some operating environments, the equivalent to time_access is expected to be implicitly updated by each read of the content of the file object. If an NFS client is caching the content of a file object, whether it is a regular file, directory, or symbolic link, the client SHOULD NOT update the time_access attribute (via SETATTR or a small READ or READDIR request) on the server with each read that is satisfied from cache. The reason is that this can defeat the performance benefits of caching content, especially since an explicit SETATTR of time_access may alter the change attribute on the server. If the change attribute changes, clients that are caching the content will think the content has changed, and will re-read unmodified data from the server. Nor is the client encouraged to maintain a modified version of time_access in its cache, since the client either would eventually have to write the access time to the server with bad performance effects or never update the server&#39;s time_access, thereby resulting in a situation where an application that caches access time between a close and open of the same file observes the access time oscillating between the past and present. The time_access attribute always means the time of last access to a file by a read that was satisfied by the server. This way clients will tend to see only time_access changes that go forward in time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
一部のオペレーティング環境では、time_accessに相当するものが、ファイルオブジェクトのコンテンツを読み取るたびに暗黙的に更新されることが期待されます。 NFSクライアントがファイルオブジェクトのコンテンツをキャッシュしている場合、それが通常のファイル、ディレクトリ、シンボリックリンクのいずれであっても、クライアントは、サーバーのtime_access属性を（SETATTRまたは小さなREADまたはREADDIRリクエストを介して）更新しないでください。キャッシュから満たされる読み取り。その理由は、特にtime_accessの明示的なSETATTRがサーバーの変更属性を変更する可能性があるため、コンテンツをキャッシュすることによるパフォーマンス上の利点が損なわれる可能性があるためです。変更属性が変更されると、コンテンツをキャッシュしているクライアントは、コンテンツが変更されたと見なし、変更されていないデータをサーバーから再読み取りします。クライアントは、変更されたバージョンのtime_accessをキャッシュに保持することも推奨されていません。クライアントは、最終的にはパフォーマンスに悪い影響を与えてアクセス時間をサーバーに書き込む必要があるか、サーバーのtime_accessを更新しないため、アプリケーションが同じファイルのクローズとオープンの間のアクセス時間をキャッシュすることにより、過去と現在の間で変動するアクセス時間が観察されます。 time_access属性は常に、サーバーによって満たされた読み取りによってファイルに最後にアクセスした時刻を意味します。このようにして、クライアントは時間とともに進むtime_accessの変更のみを確認する傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-7--Data-and-Metadata-Caching-and-Memory-Mapped-Files">
10.7. Data and Metadata Caching and Memory Mapped Files
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7. データとメタデータのキャッシュとメモリマップファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some operating environments include the capability for an application to map a file&#39;s content into the application&#39;s address space. Each time the application accesses a memory location that corresponds to a block that has not been loaded into the address space, a page fault occurs and the file is read (or if the block does not exist in the file, the block is allocated and then instantiated in the application&#39;s address space).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のオペレーティング環境には、アプリケーションがファイルのコンテンツをアプリケーションのアドレス空間にマップする機能が含まれています。アプリケーションがアドレス空間にロードされていないブロックに対応するメモリ位置にアクセスするたびに、ページフォールトが発生し、ファイルが読み取られます（または、ブロックがファイルに存在しない場合は、ブロックが割り当てられてからアプリケーションのアドレス空間でインスタンス化されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As long as each memory-mapped access to the file requires a page fault, the relevant attributes of the file that are used to detect access and modification (time_access, time_metadata, time_modify, and change) will be updated. However, in many operating environments, when page faults are not required, these attributes will not be updated on reads or updates to the file via memory access (regardless of whether the file is local or is accessed remotely). A client or server MAY fail to update attributes of a file that is being accessed via memory-mapped I/O. This has several implications:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルへの各メモリマップアクセスにページフォールトが必要である限り、アクセスと変更の検出に使用されるファイルの関連属性（time_access、time_metadata、time_modify、およびchange）が更新されます。ただし、多くのオペレーティング環境では、ページフォールトが必要ない場合、これらの属性は、メモリアクセスを介したファイルの読み取りまたは更新時に更新されません（ファイルがローカルであるかリモートでアクセスされるかに関係なく）。クライアントまたはサーバーは、メモリマップI / Oを介してアクセスされているファイルの属性の更新に失敗する場合があります。これにはいくつかの意味があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If there is an application on the server that has memory mapped a file that a client is also accessing, the client may not be able to get a consistent value of the change attribute to determine whether or not its cache is stale. A server that knows that the file is memory-mapped could always pessimistically return updated values for change so as to force the application to always get the most up-to-date data and metadata for the file. However, due to the negative performance implications of this, such behavior is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントがアクセスしているファイルをメモリマップしたサーバー上のアプリケーションがある場合、クライアントは変更属性の一貫した値を取得できず、キャッシュが古いかどうかを判断できない場合があります。ファイルがメモリマップされていることを認識しているサーバーは、常に変更について更新された値を悲観的に返し、アプリケーションに常にファイルの最新のデータとメタデータを取得させることができます。ただし、これはパフォーマンスに悪影響を及ぼすため、このような動作はオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the memory-mapped file is not being modified on the server, and instead is just being read by an application via the memory-mapped interface, the client will not see an updated time_access attribute. However, in many operating environments, neither will any process running on the server. Thus, NFS clients are at no disadvantage with respect to local processes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーでメモリマップファイルが変更されておらず、メモリマップインターフェイスを介してアプリケーションによって読み取られているだけの場合、クライアントには更新されたtime_access属性が表示されません。ただし、多くのオペレーティング環境では、サーバーで実行されるプロセスもありません。したがって、NFSクライアントは、ローカルプロセスに関して不利になることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o If there is another client that is memory mapping the file, and if that client is holding an OPEN_DELEGATE_WRITE delegation, the same set of issues as discussed in the previous two bullet points apply. So, when a server does a CB_GETATTR to a file that the client has modified in its cache, the reply from CB_GETATTR will not necessarily be accurate. As discussed earlier, the client&#39;s obligation is to report that the file has been modified since the delegation was granted, not whether it has been modified again between successive CB_GETATTR calls, and the server MUST assume that any file the client has modified in cache has been modified again between successive CB_GETATTR calls. Depending on the nature of the client&#39;s memory management system, this weak obligation may not be possible. A client MAY return stale information in CB_GETATTR whenever the file is memory-mapped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
oファイルをメモリマッピングしている別のクライアントがあり、そのクライアントがOPEN_DELEGATE_WRITE委任を保持している場合、前の2つの箇条書きで説明したのと同じ一連の問題が適用されます。したがって、クライアントがキャッシュで変更したファイルに対してサーバーがCB_GETATTRを実行する場合、CB_GETATTRからの応答は必ずしも正確ではありません。前述のように、クライアントの義務は、委任が許可されてからファイルが変更されたことを報告することであり、連続するCB_GETATTR呼び出しの間に再度変更されたかどうかではなく、サーバーは、クライアントがキャッシュ内で変更したファイルが連続するCB_GETATTR呼び出しの間で再度変更されました。クライアントのメモリ管理システムの性質によっては、この弱い義務が不可能な場合があります。クライアントは、ファイルがメモリマップされている場合は常に、古い情報をCB_GETATTRに返す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The mixture of memory mapping and byte-range locking on the same file is problematic. Consider the following scenario, where a page size on each client is 8192 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 同じファイルでのメモリマッピングとバイト範囲ロックの混在は問題があります。各クライアントのページサイズが8192バイトである次のシナリオを考えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Client A memory maps the first page (8192 bytes) of file X.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントAのメモリは、ファイルXの最初のページ（8192バイト）をマップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Client B memory maps the first page (8192 bytes) of file X.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントBのメモリは、ファイルXの最初のページ（8192バイト）をマップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Client A WRITE_LT locks the first 4096 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントAのWRITE_LTは最初の4096バイトをロックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Client B WRITE_LT locks the second 4096 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントBのWRITE_LTは2番目の4096バイトをロックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Client A, via a STORE instruction, modifies part of its locked byte-range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントAは、STORE命令を介して、ロックされたバイト範囲の一部を変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Simultaneous to client A, client B executes a STORE on part of its locked byte-range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントAと同時に、クライアントBはロックされたバイト範囲の一部でSTOREを実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here the challenge is for each client to resynchronize to get a correct view of the first page. In many operating environments, the virtual memory management systems on each client only know a page is modified, not that a subset of the page corresponding to the respective lock byte-ranges has been modified. So it is not possible for each client to do the right thing, which is to write to the server only that portion of the page that is locked. For example, if client A simply writes out the page, and then client B writes out the page, client A&#39;s data is lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでの課題は、各クライアントが再同期して最初のページの正しいビューを取得することです。多くのオペレーティング環境では、各クライアントの仮想メモリ管理システムはページが変更されたことだけを認識し、それぞれのロックバイト範囲に対応するページのサブセットが変更されたことを認識しません。そのため、各クライアントが正しいことを行うことはできません。つまり、ロックされているページのその部分のみをサーバーに書き込みます。たとえば、クライアントAが単にページを書き込んだ後、クライアントBがそのページを書き込んだ場合、クライアントAのデータは失われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Moreover, if mandatory locking is enabled on the file, then we have a different problem. When clients A and B execute the STORE instructions, the resulting page faults require a byte-range lock on the entire page. Each client then tries to extend their locked range to the entire page, which results in a deadlock. Communicating the NFS4ERR_DEADLOCK error to a STORE instruction is difficult at best.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、ファイルで強制ロックが有効になっている場合は、別の問題があります。クライアントAとBがSTORE命令を実行すると、結果として生じるページフォールトは、ページ全体のバイト範囲ロックを必要とします。次に、各クライアントはロックされた範囲をページ全体に拡張しようとしますが、デッドロックが発生します。 NFS4ERR_DEADLOCKエラーをSTORE命令に伝達することは、せいぜい困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client is locking the entire memory-mapped file, there is no problem with advisory or mandatory byte-range locking, at least until the client unlocks a byte-range in the middle of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがメモリマップファイル全体をロックしている場合、少なくともクライアントがファイルの中央でバイト範囲をロック解除するまで、勧告的または必須のバイト範囲ロックで問題はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given the above issues, the following are permitted:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の問題を考慮すると、次のことが許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clients and servers MAY deny memory mapping a file for which they know there are byte-range locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントとサーバーは、バイト範囲のロックがあることがわかっているファイルのメモリマッピングを拒否する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clients and servers MAY deny a byte-range lock on a file they know is memory-mapped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントとサーバーは、メモリマップされていることがわかっているファイルのバイト範囲ロックを拒否する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A client MAY deny memory mapping a file that it knows requires mandatory locking for I/O. If mandatory locking is enabled after the file is opened and mapped, the client MAY deny the application further access to its mapped file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは、I / Oの必須ロックが必要であることがわかっているファイルのメモリマッピングを拒否する場合があります。ファイルが開かれてマップされた後に強制ロックが有効になっている場合、クライアントは、アプリケーションがマップされたファイルにそれ以上アクセスすることを拒否できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-8--Name-and-Directory-Caching-without-Directory-Delegations">
10.8. Name and Directory Caching without Directory Delegations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.8. ディレクトリ委任なしの名前とディレクトリのキャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 directory delegation facility (described in Section 10.9 below) is OPTIONAL for servers to implement. Even where it is implemented, it may not always be functional because of resource availability issues or other constraints. Thus, it is important to understand how name and directory caching are done in the absence of directory delegations. These topics are discussed in the next two subsections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1ディレクトリ委任機能（セクション10.9で説明）は、サーバーが実装するオプションです。それが実装されている場合でも、リソースの可用性の問題やその他の制約のため、常に機能しているとは限りません。したがって、ディレクトリ委任がない場合に名前とディレクトリのキャッシュがどのように行われるかを理解することが重要です。これらのトピックについては、次の2つのサブセクションで説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-8-1--Name-Caching">
10.8.1. Name Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.8.1. 名前のキャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results of LOOKUP and READDIR operations may be cached to avoid the cost of subsequent LOOKUP operations. Just as in the case of attribute caching, inconsistencies may arise among the various client caches. To mitigate the effects of these inconsistencies and given the context of typical file system APIs, an upper time boundary is maintained for how long a client name cache entry can be kept without verifying that the entry has not been made invalid by a directory change operation performed by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOOKUPおよびREADDIR操作の結果は、後続のLOOKUP操作のコストを回避するためにキャッシュされる場合があります。属性キャッシュの場合と同様に、さまざまなクライアントキャッシュ間で不整合が発生する可能性があります。これらの不整合の影響を軽減し、一般的なファイルシステムAPIのコンテキストを考慮して、実行されたディレクトリ変更操作によってエントリが無効にされていないことを確認せずに、クライアント名キャッシュエントリを保持できる期間の上限が維持されます。別のクライアントによる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client is not making changes to a directory for which there exist name cache entries, the client needs to periodically fetch attributes for that directory to ensure that it is not being modified. After determining that no modification has occurred, the expiration time for the associated name cache entries may be updated to be the current time plus the name cache staleness bound.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが名前キャッシュエントリが存在するディレクトリに変更を加えていない場合、クライアントはそのディレクトリの属性を定期的にフェッチして、変更されていないことを確認する必要があります。変更が発生していないと判断した後、関連付けられた名前キャッシュエントリの有効期限は、現在の時間に名前キャッシュの古さの限界を加えたものに更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When a client is making changes to a given directory, it needs to determine whether there have been changes made to the directory by other clients. It does this by using the change attribute as reported before and after the directory operation in the associated change_info4 value returned for the operation. The server is able to communicate to the client whether the change_info4 data is provided atomically with respect to the directory operation. If the change values are provided atomically, the client has a basis for determining, given proper care, whether other clients are modifying the directory in question.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントが特定のディレクトリに変更を加えているとき、他のクライアントによってディレクトリに加えられた変更があるかどうかを判断する必要があります。これは、操作に対して返された関連するchange_info4値のディレクトリ操作の前後に報告されているように、change属性を使用して行われます。サーバーは、change_info4データがディレクトリ操作に関してアトミックに提供されているかどうかをクライアントと通信できます。変更値がアトミックに提供される場合、クライアントは、適切な注意を払って、他のクライアントが問題のディレクトリを変更しているかどうかを判断するための基礎を持ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The simplest way to enable the client to make this determination is for the client to serialize all changes made to a specific directory. When this is done, and the server provides before and after values of the change attribute atomically, the client can simply compare the after value of the change attribute from one operation on a directory with the before value on the subsequent operation modifying that directory. When these are equal, the client is assured that no other client is modifying the directory in question.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがこの決定を行えるようにする最も簡単な方法は、クライアントが特定のディレクトリに加えられたすべての変更をシリアル化することです。これが行われ、サーバーが変更属性の変更前と変更後の値をアトミックに提供する場合、クライアントは、ディレクトリに対する1つの操作の変更属性の変更後の値を、そのディレクトリを変更する後続の操作の変更前の値と単純に比較できます。これらが等しい場合、クライアントは、他のクライアントが問題のディレクトリを変更していないことが保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When such serialization is not used, and there may be multiple simultaneous outstanding operations modifying a single directory sent from a single client, making this sort of determination can be more complicated. If two such operations complete in a different order than they were actually performed, that might give an appearance consistent with modification being made by another client. Where this appears to happen, the client needs to await the completion of all such modifications that were started previously, to see if the outstanding before and after change numbers can be sorted into a chain such that the before value of one change number matches the after value of a previous one, in a chain consistent with this client being the only one modifying the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このようなシリアル化が使用されておらず、単一のクライアントから送信された単一のディレクトリを変更する未処理の操作が同時に複数存在する可能性がある場合、このような決定を行うことはより複雑になる可能性があります。そのような2つの操作が実際に実行された順序とは異なる順序で完了した場合、別のクライアントによって行われた変更と一貫した外観になる可能性があります。これが発生したように見える場合、クライアントは、以前に開始されたすべての変更が完了するのを待ち、変更前と変更後の未処理番号をチェーンにソートして、1つの変更番号の変更前の値が変更後と一致するかどうかを確認する必要があります。このクライアントがディレクトリを変更する唯一のクライアントであるという一貫性のあるチェーンで、前のものの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In either of these cases, the client is able to determine whether the directory is being modified by another client. If the comparison indicates that the directory was updated by another client, the name cache associated with the modified directory is purged from the client. If the comparison indicates no modification, the name cache can be updated on the client to reflect the directory operation and the associated timeout can be extended. The post-operation change value needs to be saved as the basis for future change_info4 comparisons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのいずれの場合でも、クライアントは、ディレクトリが別のクライアントによって変更されているかどうかを判断できます。比較により、ディレクトリが別のクライアントによって更新されたことが示された場合、変更されたディレクトリに関連付けられた名前キャッシュはクライアントから削除されます。比較により変更がないことが示された場合、クライアントで名前キャッシュを更新してディレクトリ操作を反映し、関連するタイムアウトを延長できます。操作後の変更値は、将来のchange_info4比較の基礎として保存する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 As demonstrated by the scenario above, name caching requires that the client revalidate name cache data by inspecting the change attribute of a directory at the point when the name cache item was cached. This requires that the server update the change attribute for directories when the contents of the corresponding directory is modified. For a client to use the change_info4 information appropriately and correctly, the server must report the pre- and post-operation change attribute values atomically. When the server is unable to report the before and after values atomically with respect to the directory operation, the server must indicate that fact in the change_info4 return value. When the information is not atomically reported, the client should not assume that other clients have not changed the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
上記のシナリオで示されているように、名前のキャッシュでは、名前のキャッシュアイテムがキャッシュされた時点でディレクトリの変更属性を検査して、名前のキャッシュデータをクライアントが再検証する必要があります。これには、対応するディレクトリの内容が変更されたときに、サーバーがディレクトリの変更属性を更新する必要があります。クライアントがchange_info4情報を適切かつ正しく使用するには、サーバーは操作前および操作後の変更属性値をアトミックに報告する必要があります。サーバーがディレクトリ操作に関して前の値と後の値をアトミックに報告できない場合、サーバーはその事実をchange_info4の戻り値に示す必要があります。情報がアトミックに報告されない場合、クライアントは、他のクライアントがディレクトリを変更していないと想定しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-8-2--Directory-Caching">
10.8.2. Directory Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.8.2. ディレクトリキャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results of READDIR operations may be used to avoid subsequent READDIR operations. Just as in the cases of attribute and name caching, inconsistencies may arise among the various client caches. To mitigate the effects of these inconsistencies, and given the context of typical file system APIs, the following rules should be followed:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR操作の結果は、後続のREADDIR操作を回避するために使用できます。属性と名前のキャッシュの場合と同様に、さまざまなクライアントキャッシュ間で不整合が発生する可能性があります。これらの不整合の影響を軽減するため、および一般的なファイルシステムAPIのコンテキストを前提として、次のルールに従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Cached READDIR information for a directory that is not obtained in a single READDIR operation must always be a consistent snapshot of directory contents. This is determined by using a GETATTR before the first READDIR and after the last READDIR that contributes to the cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 単一のREADDIR操作で取得されないディレクトリのキャッシュされたREADDIR情報は、常にディレクトリの内容の一貫したスナップショットである必要があります。これは、最初のREADDIRの前と、キャッシュに寄与する最後のREADDIRの後にGETATTRを使用することによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An upper time boundary is maintained to indicate the length of time a directory cache entry is considered valid before the client must revalidate the cached information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントがキャッシュされた情報を再検証する必要がある前に、ディレクトリキャッシュエントリが有効と見なされる時間の長さを示すために、時間の上限が維持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The revalidation technique parallels that discussed in the case of name caching. When the client is not changing the directory in question, checking the change attribute of the directory with GETATTR is adequate. The lifetime of the cache entry can be extended at these checkpoints. When a client is modifying the directory, the client needs to use the change_info4 data to determine whether there are other clients modifying the directory. If it is determined that no other client modifications are occurring, the client may update its directory cache to reflect its own changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再検証手法は、名前のキャッシングの場合で説明した手法と類似しています。クライアントが問題のディレクトリを変更していない場合は、GETATTRを使用してディレクトリの変更属性を確認するのが適切です。キャッシュエントリの有効期間は、これらのチェックポイントで延長できます。クライアントがディレクトリを変更しているとき、クライアントはchange_info4データを使用して、ディレクトリを変更している他のクライアントがあるかどうかを判断する必要があります。他のクライアントの変更が発生していないと判断された場合、クライアントは自身の変更を反映するためにディレクトリキャッシュを更新できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As demonstrated previously, directory caching requires that the client revalidate directory cache data by inspecting the change attribute of a directory at the point when the directory was cached. This requires that the server update the change attribute for directories when the contents of the corresponding directory is modified. For a client to use the change_info4 information appropriately and correctly, the server must report the pre- and post-operation change attribute values atomically. When the server is unable to report the before and after values atomically with respect to the directory operation, the server must indicate that fact in the change_info4 return value. When the information is not atomically reported, the client should not assume that other clients have not changed the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前に示したように、ディレクトリキャッシュでは、クライアントがディレクトリがキャッシュされた時点でディレクトリの変更属性を検査して、ディレクトリキャッシュデータを再検証する必要があります。これには、対応するディレクトリの内容が変更されたときに、サーバーがディレクトリの変更属性を更新する必要があります。クライアントがchange_info4情報を適切かつ正しく使用するには、サーバーは操作前および操作後の変更属性値をアトミックに報告する必要があります。サーバーがディレクトリ操作に関して前の値と後の値をアトミックに報告できない場合、サーバーはその事実をchange_info4の戻り値に示す必要があります。情報がアトミックに報告されない場合、クライアントは、他のクライアントがディレクトリを変更していないと想定しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-9--Directory-Delegations">
10.9. Directory Delegations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.9. ディレクトリの委任
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-9-1--Introduction-to-Directory-Delegations">
10.9.1. Introduction to Directory Delegations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.9.1. ディレクトリ委任の概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Directory caching for the NFSv4.1 protocol, as previously described, is similar to file caching in previous versions. Clients typically cache directory information for a duration determined by the client. At the end of a predefined timeout, the client will query the server to see if the directory has been updated. By caching attributes, clients reduce the number of GETATTR calls made to the server to validate attributes. Furthermore, frequently accessed files and directories, such as the current working directory, have their attributes cached on the client so that some NFS operations can be performed without having to make an RPC call. By caching name and inode information about most recently looked up entries in a Directory Name Lookup Cache (DNLC), clients do not need to send LOOKUP calls to the server every time these files are accessed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前述のように、NFSv4.1プロトコルのディレクトリキャッシングは、以前のバージョンのファイルキャッシングに似ています。クライアントは通常、クライアントが決定した期間、ディレクトリ情報をキャッシュします。事前定義されたタイムアウトの最後に、クライアントはサーバーにクエリを実行して、ディレクトリが更新されているかどうかを確認します。属性をキャッシュすることにより、クライアントは属性を検証するためにサーバーに対して行われるGETATTR呼び出しの数を減らします。さらに、頻繁にアクセスされるファイルやディレクトリ（現在の作業ディレクトリなど）の属性はクライアントにキャッシュされるため、RPC呼び出しを行わなくても一部のNFS操作を実行できます。最近検索されたエントリに関する名前とiノード情報をディレクトリ名検索キャッシュ（DNLC）にキャッシュすることにより、クライアントはこれらのファイルにアクセスするたびにLOOKUP呼び出しをサーバーに送信する必要がなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This caching approach works reasonably well at reducing network traffic in many environments. However, it does not address environments where there are numerous queries for files that do not exist. In these cases of &#34;misses&#34;, the client sends requests to the server in order to provide reasonable application semantics and promptly detect the creation of new directory entries. Examples of high miss activity are compilation in software development environments. The current behavior of NFS limits its potential scalability and wide-area sharing effectiveness in these types of environments. Other distributed stateful file system architectures such as AFS and DFS have proven that adding state around directory contents can greatly reduce network traffic in high-miss environments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このキャッシングアプローチは、多くの環境でネットワークトラフィックを減らすのに適度に機能します。ただし、存在しないファイルに対するクエリが多数ある環境には対応していません。これらの「欠落」の場合、クライアントは適切なアプリケーションセマンティクスを提供し、新しいディレクトリエントリの作成を迅速に検出するためにサーバーにリクエストを送信します。ミスの多いアクティビティの例は、ソフトウェア開発環境でのコンパイルです。 NFSの現在の動作は、これらのタイプの環境における潜在的なスケーラビリティと広域共有の有効性を制限します。 AFSやDFSなどの他の分散ステートフルファイルシステムアーキテクチャでは、ディレクトリコンテンツの周りに状態を追加すると、ミス率の高い環境でネットワークトラフィックを大幅に削減できることが証明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Delegation of directory contents is an OPTIONAL feature of NFSv4.1. Directory delegations provide similar traffic reduction benefits as with file delegations. By allowing clients to cache directory contents (in a read-only fashion) while being notified of changes, the client can avoid making frequent requests to interrogate the contents of slowly-changing directories, reducing network traffic and improving client performance. It can also simplify the task of determining whether other clients are making changes to the directory when the client itself is making many changes to the directory and changes are not serialized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ディレクトリ内容の委任は、NFSv4.1のオプション機能です。ディレクトリの委任には、ファイルの委任と同様のトラフィック削減の利点があります。変更の通知を受けながら、クライアントがディレクトリの内容を（読み取り専用の方法で）キャッシュできるようにすることで、クライアントは、変化の遅いディレクトリの内容を問い合わせるための頻繁な要求を回避し、ネットワークトラフィックを減らし、クライアントのパフォーマンスを向上させることができます。また、クライアント自体がディレクトリに多くの変更を行っており、変更がシリアル化されていない場合に、他のクライアントがディレクトリに変更を加えているかどうかを判断するタスクも簡略化できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Directory delegations allow improved namespace cache consistency to be achieved through delegations and synchronous recalls, in the absence of notifications. In addition, if time-based consistency is sufficient, asynchronous notifications can provide performance benefits for the client, and possibly the server, under some common operating conditions such as slowly-changing and/or very large directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ディレクトリの委任により、通知がなくても委任と同期リコールを通じて名前空間キャッシュの一貫性を向上させることができます。さらに、時間ベースの一貫性が十分である場合、非同期通知は、ゆっくりと変化するディレクトリや非常に大きなディレクトリなどの一般的な操作条件下で、クライアント、および場合によってはサーバーにパフォーマンス上の利点を提供できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-9-2--Directory-Delegation-Design">
10.9.2. Directory Delegation Design
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.9.2. ディレクトリ委任の設計
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 introduces the GET_DIR_DELEGATION (Section 18.39) operation to allow the client to ask for a directory delegation. The delegation covers directory attributes and all entries in the directory. If either of these change, the delegation will be recalled synchronously. The operation causing the recall will have to wait before the recall is complete. Any changes to directory entry attributes will not cause the delegation to be recalled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1はGET_DIR_DELEGATION（セクション18.39）操作を導入して、クライアントがディレクトリの委任を要求できるようにします。委任には、ディレクトリ属性とディレクトリ内のすべてのエントリが含まれます。これらのいずれかが変更されると、委任は同期的に呼び出されます。再呼び出しを引き起こす操作は、再呼び出しが完了する前に待機する必要があります。ディレクトリエントリの属性を変更しても、委任は取り消されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to asking for delegations, a client can also ask for notifications for certain events. These events include changes to the directory&#39;s attributes and/or its contents. If a client asks for notification for a certain event, the server will notify the client when that event occurs. This will not result in the delegation being recalled for that client. The notifications are asynchronous and provide a way of avoiding recalls in situations where a directory is changing enough that the pure recall model may not be effective while trying to allow the client to get substantial benefit. In the absence of notifications, once the delegation is recalled the client has to refresh its directory cache; this might not be very efficient for very large directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任を要求することに加えて、クライアントは特定のイベントの通知を要求することもできます。これらのイベントには、ディレクトリの属性やコンテンツの変更が含まれます。クライアントが特定のイベントの通知を要求すると、サーバーはそのイベントが発生したときにクライアントに通知します。これにより、そのクライアントの委任が取り消されることはありません。通知は非同期であり、ディレクトリが十分に変化してクライアントが実質的なメリットを得ようとしているときに純粋な再呼び出しモデルが効果的でない可能性がある状況での再呼び出しを回避する方法を提供します。通知がない場合、委任が呼び出されると、クライアントはディレクトリキャッシュを更新する必要があります。これは、非常に大きなディレクトリではあまり効率的ではない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The delegation is read-only and the client may not make changes to the directory other than by performing NFSv4.1 operations that modify the directory or the associated file attributes so that the server has knowledge of these changes. In order to keep the client&#39;s namespace synchronized with the server, the server will notify the delegation-holding client (assuming it has requested notifications) of the changes made as a result of that client&#39;s directory-modifying operations. This is to avoid any need for that client to send subsequent GETATTR or READDIR operations to the server. If a single client is holding the delegation and that client makes any changes to the directory (i.e., the changes are made via operations sent on a session associated with the client ID holding the delegation), the delegation will not be recalled. Multiple clients may hold a delegation on the same directory, but if any such client modifies the directory, the server MUST recall the delegation from the other clients, unless those clients have made provisions to be notified of that sort of modification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任は読み取り専用であり、サーバーがこれらの変更を認識できるようにディレクトリまたは関連するファイル属性を変更するNFSv4.1操作を実行する以外に、クライアントはディレクトリを変更できません。クライアントの名前空間をサーバーと同期させておくために、サーバーは委任保持クライアント（通知を要求していると想定）に、そのクライアントのディレクトリ変更操作の結果として行われた変更を通知します。これは、そのクライアントが後続のGETATTRまたはREADDIR操作をサーバーに送信する必要をなくすためです。単一のクライアントが委任を保持していて、そのクライアントがディレクトリに変更を加えた場合（つまり、変更は、委任を保持しているクライアントIDに関連付けられたセッションで送信された操作によって行われた場合）、委任は取り消されません。複数のクライアントが同じディレクトリに委任を保持する場合がありますが、そのようなクライアントがディレクトリを変更した場合、サーバーは他のクライアントからの委任を再呼び出しする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Delegations can be recalled by the server at any time. Normally, the server will recall the delegation when the directory changes in a way that is not covered by the notification, or when the directory changes and notifications have not been requested. If another client removes the directory for which a delegation has been granted, the server will recall the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任はいつでもサーバーで呼び出すことができます。通常、通知でカバーされない方法でディレクトリが変更された場合、またはディレクトリの変更と通知が要求されていない場合、サーバーは委任を呼び出します。別のクライアントが委任が許可されているディレクトリを削除すると、サーバーは委任を取り消します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-9-3--Attributes-in-Support-of-Directory-Notifications">
10.9.3. Attributes in Support of Directory Notifications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.9.3. ディレクトリ通知をサポートする属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 5.11 for a description of the attributes associated with directory notifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ディレクトリ通知に関連する属性の説明については、セクション5.11を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-9-4--Directory-Delegation-Recall">
10.9.4. Directory Delegation Recall
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.9.4. ディレクトリ委任の取り消し
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server will recall the directory delegation by sending a callback to the client. It will use the same callback procedure as used for recalling file delegations. The server will recall the delegation when the directory changes in a way that is not covered by the notification. However, the server need not recall the delegation if attributes of an entry within the directory change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、クライアントにコールバックを送信することにより、ディレクトリの委任を呼び出します。ファイルの委任を呼び出すために使用されるのと同じコールバック手順を使用します。サーバーは、通知でカバーされない方法でディレクトリが変更されると、委任を呼び出します。ただし、ディレクトリ内のエントリの属性が変更された場合、サーバーは委任を呼び出す必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server notices that handing out a delegation for a directory is causing too many notifications to be sent out, it may decide to not hand out delegations for that directory and/or recall those already granted. If a client tries to remove the directory for which a delegation has been granted, the server will recall all associated delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが、ディレクトリの委任を配布することによって送信される通知が多すぎることに気付いた場合、そのディレクトリの委任を配布しないか、すでに許可されている委任を呼び戻すかを決定します。クライアントが委任が許可されているディレクトリを削除しようとすると、サーバーはすべての関連する委任を呼び出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The implementation sections for a number of operations describe situations in which notification or delegation recall would be required under some common circumstances. In this regard, a similar set of caveats to those listed in Section 10.2 apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの操作の実装セクションでは、いくつかの一般的な状況で通知または委任の取り消しが必要になる状況について説明します。この点で、セクション10.2にリストされているものと同様の一連の警告が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For CREATE, see Section 18.4.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o CREATEについては、セクション18.4.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For LINK, see Section 18.9.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LINKについては、セクション18.9.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For OPEN, see Section 18.16.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPENについては、セクション18.16.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For REMOVE, see Section 18.25.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o REMOVEについては、セクション18.25.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For RENAME, see Section 18.26.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RENAMEについては、セクション18.26.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For SETATTR, see Section 18.30.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SETATTRについては、セクション18.30.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-9-5--Directory-Delegation-Recovery">
10.9.5. Directory Delegation Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.9.5. ディレクトリ委任の回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recovery from client or server restart for state on regular files has two main goals: avoiding the necessity of breaking application guarantees with respect to locked files and delivery of updates cached at the client. Neither of these goals applies to directories protected by OPEN_DELEGATE_READ delegations and notifications. Thus, no provision is made for reclaiming directory delegations in the event of client or server restart. The client can simply establish a directory delegation in the same fashion as was done initially.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常のファイルの状態に対するクライアントまたはサーバーの再起動からの回復には、2つの主な目的があります。ロックされたファイルとクライアントでキャッシュされた更新の配信に関するアプリケーション保証を破る必要を回避することです。これらの目標はどちらも、OPEN_DELEGATE_READの委任と通知によって保護されているディレクトリには適用されません。したがって、クライアントまたはサーバーの再起動時にディレクトリの委任を再利用するための準備は行われません。クライアントは、最初に行われたのと同じ方法でディレクトリ委任を簡単に確立できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11--Multi-Server-Namespace">
11. Multi-Server Namespace
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. マルチサーバー名前空間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 supports attributes that allow a namespace to extend beyond the boundaries of a single server. It is RECOMMENDED that clients and servers support construction of such multi-server namespaces. Use of such multi-server namespaces is OPTIONAL, however, and for many purposes, single-server namespaces are perfectly acceptable. Use of multi-server namespaces can provide many advantages, however, by separating a file system&#39;s logical position in a namespace from the (possibly changing) logistical and administrative considerations that result in particular file systems being located on particular servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1は、名前空間が単一サーバーの境界を超えて拡張できるようにする属性をサポートしています。クライアントとサーバーがこのようなマルチサーバー名前空間の構築をサポートすることをお勧めします。このようなマルチサーバー名前空間の使用はオプションですが、多くの目的で、単一サーバー名前空間は完全に許容されます。ただし、マルチサーバー名前空間を使用すると、名前空間におけるファイルシステムの論理的な位置を、特定のファイルシステムが特定のサーバーに配置されることになる（変更される可能性がある）ロジスティックおよび管理上の考慮事項から切り離すことにより、多くの利点が得られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1--Location-Attributes">
11.1. Location Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. ロケーション属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 contains RECOMMENDED attributes that allow file systems on one server to be associated with one or more instances of that file system on other servers. These attributes specify such file system instances by specifying a server address target (either as a DNS name representing one or more IP addresses or as a literal IP address) together with the path of that file system within the associated single-server namespace.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1には、あるサーバー上のファイルシステムを他のサーバー上のそのファイルシステムの1つ以上のインスタンスに関連付けることができるRECOMMENDED属性が含まれています。これらの属性は、サーバーアドレスターゲット（1つ以上のIPアドレスを表すDNS名として、またはリテラルIPアドレスとして）と、関連付けられた単一サーバー名前空間内のファイルシステムのパスを指定することにより、そのようなファイルシステムインスタンスを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations_info RECOMMENDED attribute allows specification of one or more file system instance locations where the data corresponding to a given file system may be found. This attribute provides to the client, in addition to information about file system instance locations, significant information about the various file system instance choices (e.g., priority for use, writability, currency, etc.). It also includes information to help the client efficiently effect as seamless a transition as possible among multiple file system instances, when and if that should be necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations_info RECOMMENDED属性を使用すると、特定のファイルシステムに対応するデータが見つかる可能性がある1つ以上のファイルシステムインスタンスの場所を指定できます。この属性は、ファイルシステムインスタンスの場所に関する情報に加えて、さまざまなファイルシステムインスタンスの選択に関する重要な情報（使用の優先度、書き込み可能性、通貨など）をクライアントに提供します。また、クライアントが複数のファイルシステムインスタンス間で可能な限りシームレスにトランジションを効率的に実行できるようにするための情報も含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations RECOMMENDED attribute is inherited from NFSv4.0 and only allows specification of the file system locations where the data corresponding to a given file system may be found. Servers SHOULD make this attribute available whenever fs_locations_info is supported, but client use of fs_locations_info is to be preferred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations RECOMMENDED属性はNFSv4.0から継承され、特定のファイルシステムに対応するデータが見つかる可能性があるファイルシステムの場所の指定のみを許可します。サーバーは、fs_locations_infoがサポートされているときはいつでもこの属性を使用可能にする必要がありますが、fs_locations_infoのクライアントでの使用をお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-2--File-System-Presence-or-Absence">
11.2. File System Presence or Absence
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. ファイルシステムの有無
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A given location in an NFSv4.1 namespace (typically but not necessarily a multi-server namespace) can have a number of file system instance locations associated with it (via the fs_locations or fs_locations_info attribute). There may also be an actual current file system at that location, accessible via normal namespace operations (e.g., LOOKUP). In this case, the file system is said to be &#34;present&#34; at that position in the namespace, and clients will typically use it, reserving use of additional locations specified via the location-related attributes to situations in which the principal location is no longer available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1名前空間の特定の場所（通常、必ずしもマルチサーバー名前空間ではない）には、（fs_locationsまたはfs_locations_info属性を介して）ファイルシステムインスタンスの場所を関連付けることができます。その場所に実際の現在のファイルシステムが存在する場合もあり、通常のネームスペース操作（LOOKUPなど）を介してアクセスできます。この場合、ファイルシステムは名前空間のその位置に「存在する」と言われ、クライアントは通常それを使用し、主要な場所がもはや存在しない状況に対して、場所関連の属性によって指定された追加の場所の使用を予約します。利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When there is no actual file system at the namespace location in question, the file system is said to be &#34;absent&#34;. An absent file system contains no files or directories other than the root. Any reference to it, except to access a small set of attributes useful in determining alternate locations, will result in an error, NFS4ERR_MOVED. Note that if the server ever returns the error NFS4ERR_MOVED, it MUST support the fs_locations attribute and SHOULD support the fs_locations_info and fs_status attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
問題のネームスペースの場所に実際のファイルシステムがない場合、ファイルシステムは「存在しない」と言われます。存在しないファイルシステムには、ルート以外のファイルやディレクトリは含まれません。代替の場所を決定するのに役立つ小さな属性セットにアクセスする場合を除いて、それを参照すると、エラーNFS4ERR_MOVEDが発生します。サーバーがエラーNFS4ERR_MOVEDを返す場合は、fs_locations属性をサポートする必要があり、fs_locations_infoおよびfs_status属性をサポートする必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the error name suggests that we have a case of a file system that once was present, and has only become absent later, this is only one possibility. A position in the namespace may be permanently absent with the set of file system(s) designated by the location attributes being the only realization. The name NFS4ERR_MOVED reflects an earlier, more limited conception of its function, but this error will be returned whenever the referenced file system is absent, whether it has moved or not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエラー名は、かつて存在し、後でなくなったファイルシステムのケースがあることを示していますが、これは1つの可能性にすぎません。名前空間内の位置は永続的に存在しない場合があり、ロケーション属性によって指定されたファイルシステムのセットが唯一の実現です。 NFS4ERR_MOVEDという名前は、その機能の以前のより限定された概念を反映していますが、このエラーは、参照されたファイルシステムが移動したかどうかに関係なく、常に存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Except in the case of GETATTR-type operations (to be discussed later), when the current filehandle at the start of an operation is within an absent file system, that operation is not performed and the error NFS4ERR_MOVED is returned, to indicate that the file system is absent on the current server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETATTRタイプの操作（後で説明します）の場合を除いて、操作の開始時の現在のファイルハンドルが存在しないファイルシステム内にある場合、その操作は実行されず、エラーNFS4ERR_MOVEDが返され、ファイル現在のサーバーにはシステムがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Because a GETFH cannot succeed if the current filehandle is within an absent file system, filehandles within an absent file system cannot be transferred to the client. When a client does have filehandles within an absent file system, it is the result of obtaining them when the file system was present, and having the file system become absent subsequently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
現在のファイルハンドルが存在しないファイルシステム内にある場合、GETFHは成功しないため、存在しないファイルシステム内のファイルハンドルはクライアントに転送できません。クライアントが存在しないファイルシステム内にファイルハンドルを持っている場合、それはファイルシステムが存在していたときにそれらを取得し、その後ファイルシステムが存在しなくなった結果です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that because the check for the current filehandle being within an absent file system happens at the start of every operation, operations that change the current filehandle so that it is within an absent file system will not result in an error. This allows such combinations as PUTFH-GETATTR and LOOKUP-GETATTR to be used to get attribute information, particularly location attribute information, as discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが存在しないファイルシステム内にあるかどうかの確認はすべての操作の開始時に行われるため、現在のファイルハンドルを変更して、存在しないファイルシステム内にあるようにしても、エラーは発生しません。これにより、PUTFH-GETATTRやLOOKUP-GETATTRなどの組み合わせを使用して、属性情報、特に位置属性情報を取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RECOMMENDED file system attribute fs_status can be used to interrogate the present/absent status of a given file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RECOMMENDEDファイルシステム属性fs_statusを使用して、特定のファイルシステムの現在のステータスと存在しないステータスを問い合わせることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-3--Getting-Attributes-for-an-Absent-File-System">
11.3. Getting Attributes for an Absent File System
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. 存在しないファイルシステムの属性の取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a file system is absent, most attributes are not available, but it is necessary to allow the client access to the small set of attributes that are available, and most particularly those that give information about the correct current locations for this file system: fs_locations and fs_locations_info.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムが存在しない場合、ほとんどの属性は使用できませんが、クライアントがアクセス可能な少数の属性のセット、特にこのファイルシステムの正しい現在の場所に関する情報を提供する属性にアクセスできるようにする必要があります：fs_locationsおよびfs_locations_info。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-3-1--GETATTR-within-an-Absent-File-System">
11.3.1. GETATTR within an Absent File System
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.1. 存在しないファイルシステム内でのGETATTR
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned above, an exception is made for GETATTR in that attributes may be obtained for a filehandle within an absent file system. This exception only applies if the attribute mask contains at least one attribute bit that indicates the client is interested in a result regarding an absent file system: fs_locations, fs_locations_info, or fs_status. If none of these attributes is requested, GETATTR will result in an NFS4ERR_MOVED error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のように、GETATTRは例外として、存在しないファイルシステム内のファイルハンドルの属性を取得できます。この例外は、属性マスクに少なくとも1つの属性ビットが含まれている場合にのみ適用されます。これは、クライアントがファイルシステムの不在に関する結果に関心があることを示します：fs_locations、fs_locations_info、またはfs_status。これらの属性のいずれも要求されていない場合、GETATTRはNFS4ERR_MOVEDエラーになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a GETATTR is done on an absent file system, the set of supported attributes is very limited. Many attributes, including those that are normally REQUIRED, will not be available on an absent file system. In addition to the attributes mentioned above (fs_locations, fs_locations_info, fs_status), the following attributes SHOULD be available on absent file systems. In the case of RECOMMENDED attributes, they should be available at least to the same degree that they are available on present file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETATTRが存在しないファイルシステムで実行される場合、サポートされる属性のセットは非常に制限されます。通常は必須の属性を含む多くの属性は、存在しないファイルシステムでは使用できません。上記の属性（fs_locations、fs_locations_info、fs_status）に加えて、次の属性は、存在しないファイルシステムで使用できる必要があります（SHOULD）。 RECOMMENDED属性の場合、少なくとも現在のファイルシステムで使用できるのと同じ程度に使用できる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
change_policy: This attribute is useful for absent file systems and can be helpful in summarizing to the client when any of the location-related attributes change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
change_policy：この属性は、ファイルシステムがない場合に役立ち、ロケーション関連の属性が変更されたときにクライアントに要約するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fsid: This attribute should be provided so that the client can determine file system boundaries, including, in particular, the boundary between present and absent file systems. This value must be different from any other fsid on the current server and need have no particular relationship to fsids on any particular destination to which the client might be directed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fsid：この属性は、クライアントがファイルシステムの境界（特に、存在するファイルシステムと存在しないファイルシステムの間の境界を含む）を判別できるように提供する必要があります。この値は、現在のサーバーの他のfsidとは異なる必要があり、クライアントが向けられる可能性のある特定の宛先のfsidと特定の関係を持つ必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mounted_on_fileid: For objects at the top of an absent file system, this attribute needs to be available. Since the fileid is within the present parent file system, there should be no need to reference the absent file system to provide this information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mounted_on_fileid：存在しないファイルシステムの最上部にあるオブジェクトの場合、この属性が使用可能である必要があります。 fileidは現在の親ファイルシステム内にあるため、存在しないファイルシステムを参照してこの情報を提供する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other attributes SHOULD NOT be made available for absent file systems, even when it is possible to provide them. The server should not assume that more information is always better and should avoid gratuitously providing additional information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他の属性は、それらを提供することが可能な場合でも、存在しないファイルシステムで利用可能にするべきではありません（SHOULD NOT）。サーバーは、より多くの情報が常に優れていると想定してはならず、不必要に追加の情報を提供することは避けてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a GETATTR operation includes a bit mask for one of the attributes fs_locations, fs_locations_info, or fs_status, but where the bit mask includes attributes that are not supported, GETATTR will not return an error, but will return the mask of the actual attributes supported with the results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETATTR操作に属性fs_locations、fs_locations_info、またはfs_statusのいずれかのビットマスクが含まれているが、ビットマスクにサポートされていない属性が含まれている場合、GETATTRはエラーを返しませんが、実際にサポートされている属性のマスクを返します。結果。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Handling of VERIFY/NVERIFY is similar to GETATTR in that if the attribute mask does not include fs_locations, fs_locations_info, or fs_status, the error NFS4ERR_MOVED will result. It differs in that any appearance in the attribute mask of an attribute not supported for an absent file system (and note that this will include some normally REQUIRED attributes) will also cause an NFS4ERR_MOVED result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VERIFY / NVERIFYの処理は、属性マスクにfs_locations、fs_locations_info、またはfs_statusが含まれていない場合、エラーNFS4ERR_MOVEDが発生するという点でGETATTRに似ています。これは、存在しないファイルシステムでサポートされていない属性の属性マスクの外観（これには、通常は必須の属性が含まれることに注意してください）も、NFS4ERR_MOVED結果を引き起こす点で異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-3-2--READDIR-and-Absent-File-Systems">
11.3.2. READDIR and Absent File Systems
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.2. READDIRと不在のファイルシステム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A READDIR performed when the current filehandle is within an absent file system will result in an NFS4ERR_MOVED error, since, unlike the case of GETATTR, no such exception is made for READDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが存在しないファイルシステム内にあるときにREADDIRを実行すると、NFS4ERR_MOVEDエラーが発生します。これは、GETATTRの場合とは異なり、READDIRにはそのような例外は発生しないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Attributes for an absent file system may be fetched via a READDIR for a directory in a present file system, when that directory contains the root directories of one or more absent file systems. In this case, the handling is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存在しないファイルシステムの属性は、そのディレクトリに1つ以上の存在しないファイルシステムのルートディレクトリが含まれている場合、現在のファイルシステムのディレクトリのREADDIRを介してフェッチできます。この場合の処理​​は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the attribute set requested includes one of the attributes fs_locations, fs_locations_info, or fs_status, then fetching of attributes proceeds normally and no NFS4ERR_MOVED indication is returned, even when the rdattr_error attribute is requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 要求された属性セットに属性fs_locations、fs_locations_info、またはfs_statusのいずれかが含まれている場合、属性のフェッチは正常に行われ、rdattr_error属性が要求された場合でもNFS4ERR_MOVED通知は返されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the attribute set requested does not include one of the attributes fs_locations, fs_locations_info, or fs_status, then if the rdattr_error attribute is requested, each directory entry for the root of an absent file system will report NFS4ERR_MOVED as the value of the rdattr_error attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 要求された属性セットにfs_locations、fs_locations_info、またはfs_statusのいずれの属性も含まれていない場合、rdattr_error属性が要求されると、存在しないファイルシステムのルートの各ディレクトリエントリは、NFS4ERR_MOVEDをrdattr_error属性の値として報告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the attribute set requested does not include any of the attributes fs_locations, fs_locations_info, fs_status, or rdattr_error, then the occurrence of the root of an absent file system within the directory will result in the READDIR failing with an NFS4ERR_MOVED error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 要求された属性セットに属性fs_locations、fs_locations_info、fs_status、またはrdattr_errorが含まれていない場合、ディレクトリ内に存在しないファイルシステムのルートが発生すると、READDIRが失敗し、NFS4ERR_MOVEDエラーが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The unavailability of an attribute because of a file system&#39;s absence, even one that is ordinarily REQUIRED, does not result in any error indication. The set of attributes returned for the root directory of the absent file system in that case is simply restricted to those actually available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルシステムが存在しないために属性を使用できない場合でも、通常は必須であるにもかかわらず、エラーは表示されません。その場合、存在しないファイルシステムのルートディレクトリに返される属性のセットは、実際に使用可能な属性に制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-4--Uses-of-Location-Information">
11.4. Uses of Location Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4. 位置情報の使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The location-bearing attributes (fs_locations and fs_locations_info), together with the possibility of absent file systems, provide a number of important facilities in providing reliable, manageable, and scalable data access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロケーションベアリング属性（fs_locationsおよびfs_locations_info）は、ファイルシステムが存在しない可能性とともに、信頼性が高く、管理しやすく、スケーラブルなデータアクセスを提供する上で、いくつかの重要な機能を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a file system is present, these attributes can provide alternative locations, to be used to access the same data, in the event of server failures, communications problems, or other difficulties that make continued access to the current file system impossible or otherwise impractical. Under some circumstances, multiple alternative locations may be used simultaneously to provide higher-performance access to the file system in question. Provision of such alternate locations is referred to as &#34;replication&#34; although there are cases in which replicated sets of data are not in fact present, and the replicas are instead different paths to the same data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムが存在する場合、これらの属性は、サーバーの障害、通信の問題、または現在のファイルシステムへの継続的なアクセスを不可能にするか、そうでなければ非現実的である他の問題が発生した場合に、同じデータにアクセスするために使用される代替の場所を提供できます。状況によっては、複数の代替ロケーションを同時に使用して、問題のファイルシステムへのより高いパフォーマンスのアクセスを提供できます。そのような代替の場所の提供は「複製」と呼ばれますが、複製されたデータのセットが実際には存在せず、複製が同じデータへの異なるパスである場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a file system is present and becomes absent, clients can be given the opportunity to have continued access to their data, at an alternate location. In this case, a continued attempt to use the data in the now-absent file system will result in an NFS4ERR_MOVED error and, at that point, the successor locations (typically only one although multiple choices are possible) can be fetched and used to continue access. Transfer of the file system contents to the new location is referred to as &#34;migration&#34;, but it should be kept in mind that there are cases in which this term can be used, like &#34;replication&#34;, when there is no actual data migration per se.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムが存在しなくなった場合、クライアントは別の場所でデータへのアクセスを継続する機会を与えられます。この場合、現在存在しないファイルシステムのデータを引き続き使用しようとすると、NFS4ERR_MOVEDエラーが発生し、その時点で、後続の場所（通常、複数の選択肢が可能ですが1つだけ）をフェッチして、続行することができます。アクセス。ファイルシステムの内容を新しい場所に転送することを「移行」といいますが、実際にデータが移行されない場合、「レプリケーション」のようにこの用語を使用できる場合があることに注意してください。 se。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where a file system was not previously present, specification of file system location provides a means by which file systems located on one server can be associated with a namespace defined by another server, thus allowing a general multi-server namespace facility. A designation of such a location, in place of an absent file system, is called a &#34;referral&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前にファイルシステムが存在しなかった場合、ファイルシステムの場所を指定すると、あるサーバーにあるファイルシステムを別のサーバーで定義された名前空間に関連付けることができるため、一般的なマルチサーバー名前空間機能を使用できます。存在しないファイルシステムの代わりにそのような場所を指定することを、「参照」と呼びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because client support for location-related attributes is OPTIONAL, a server may (but is not required to) take action to hide migration and referral events from such clients, by acting as a proxy, for example. The server can determine the presence of client support from the arguments of the EXCHANGE_ID operation (see Section 18.35.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロケーション関連の属性に対するクライアントのサポートはオプションであるため、サーバーは、たとえばプロキシとして機能することにより、そのようなクライアントからの移行および参照イベントを非表示にするアクションを実行できます（必須ではありません）。サーバーは、EXCHANGE_ID操作の引数からクライアントサポートの存在を判別できます（セクション18.35.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-4-1--File-System-Replication">
11.4.1. File System Replication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4.1. ファイルシステムのレプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations and fs_locations_info attributes provide alternative locations, to be used to access data in place of or in addition to the current file system instance. On first access to a file system, the client should obtain the value of the set of alternate locations by interrogating the fs_locations or fs_locations_info attribute, with the latter being preferred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locationsおよびfs_locations_info属性は、現在のファイルシステムインスタンスの代わりに、または現在のファイルシステムインスタンスに加えてデータにアクセスするために使用される代替の場所を提供します。ファイルシステムへの最初のアクセス時に、クライアントは、fs_locationsまたはfs_locations_info属性に問い合わせることにより、代替の場所のセットの値を取得する必要があります。後者が推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event that server failures, communications problems, or other difficulties make continued access to the current file system impossible or otherwise impractical, the client can use the alternate locations as a way to get continued access to its data. Depending on specific attributes of these alternate locations, as indicated within the fs_locations_info attribute, multiple locations may be used simultaneously, to provide higher performance through the exploitation of multiple paths between client and target file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの障害、通信の問題、またはその他の問題により、現在のファイルシステムへの継続的なアクセスが不可能または実用的でない場合、クライアントは代替の場所を使用して、データに継続的にアクセスできます。 fs_locations_info属性で示されるように、これらの代替の場所の特定の属性に応じて、複数の場所を同時に使用して、クライアントとターゲットファイルシステム間の複数のパスを活用することにより、より高いパフォーマンスを提供できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The alternate locations may be physical replicas of the (typically read-only) file system data, or they may reflect alternate paths to the same server or provide for the use of various forms of server clustering in which multiple servers provide alternate ways of accessing the same physical file system. How these different modes of file system transition are represented within the fs_locations and fs_locations_info attributes and how the client deals with file system transition issues will be discussed in detail below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代替の場所は、（通常は読み取り専用の）ファイルシステムデータの物理的なレプリカであるか、同じサーバーへの代替パスを反映している、または複数のサーバーが代替のアクセス方法を提供するさまざまな形式のサーバークラスタリングの使用を提供している場合があります。同じ物理ファイルシステム。ファイルシステム移行のこれらの異なるモードがfs_locationsおよびfs_locations_info属性内でどのように表されるか、およびクライアントがファイルシステム移行の問題をどのように処理するかについては、以下で詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiple server addresses, whether they are derived from a single entry with a DNS name representing a set of IP addresses or from multiple entries each with its own server address, may correspond to the same actual server. The fact that two addresses correspond to the same server is shown by a common so_major_id field within the eir_server_owner field returned by EXCHANGE_ID (see Section 18.35.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のサーバーアドレスは、IPアドレスのセットを表すDNS名を持つ単一のエントリから派生したものでも、独自のサーバーアドレスを持つ複数のエントリから派生したものでも、同じ実際のサーバーに対応する場合があります。 2つのアドレスが同じサーバーに対応するという事実は、EXCHANGE_IDによって返されるeir_server_ownerフィールド内の共通のso_major_idフィールドによって示されます（セクション18.35.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a detailed discussion of how server address targets interact with the determination of server identity specified by the server owner field, see Section 11.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーアドレスターゲットがサーバー所有者フィールドで指定されたサーバーIDの決定とどのように相互作用するかの詳細については、セクション11.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-4-2--File-System-Migration">
11.4.2. File System Migration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4.2. ファイルシステムの移行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a file system is present and becomes absent, clients can be given the opportunity to have continued access to their data, at an alternate location, as specified by the fs_locations or fs_locations_info attribute. Typically, a client will be accessing the file system in question, get an NFS4ERR_MOVED error, and then use the fs_locations or fs_locations_info attribute to determine the new location of the data. When fs_locations_info is used, additional information will be available that will define the nature of the client&#39;s handling of the transition to a new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムが存在しなくなった場合、fs_locations属性またはfs_locations_info属性で指定された代替の場所で、データに引き続きアクセスする機会をクライアントに与えることができます。通常、クライアントは問題のファイルシステムにアクセスし、NFS4ERR_MOVEDエラーを取得してから、fs_locationsまたはfs_locations_info属性を使用してデータの新しい場所を決定します。 fs_locations_infoを使用すると、クライアントが新しいサーバーへの移行を処理する性質を定義する追加情報が利用可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Such migration can be helpful in providing load balancing or general resource reallocation. The protocol does not specify how the file system will be moved between servers. It is anticipated that a number of different server-to-server transfer mechanisms might be used with the choice left to the server implementor. The NFSv4.1 protocol specifies the method used to communicate the migration event between client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような移行は、ロードバランシングまたは一般的なリソースの再割り当てに役立ちます。プロトコルは、サーバー間でのファイルシステムの移動方法を指定しません。多数の異なるサーバー間転送メカニズムが使用され、選択はサーバー実装者に委ねられることが予想されます。 NFSv4.1プロトコルは、クライアントとサーバー間の移行イベントの通信に使用される方法を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The new location may be an alternate communication path to the same server or, in the case of various forms of server clustering, another server providing access to the same physical file system. The client&#39;s responsibilities in dealing with this transition depend on the specific nature of the new access path as well as how and whether data was in fact migrated. These issues will be discussed in detail below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい場所は、同じサーバーへの代替通信パス、またはサーバーのクラスタリングのさまざまな形式の場合、同じ物理ファイルシステムへのアクセスを提供する別のサーバーにすることができます。この移行への対処におけるクライアントの責任は、新しいアクセスパスの特定の性質、およびデータが実際に移行された方法と方法によって異なります。これらの問題については、以下で詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When multiple server addresses correspond to the same actual server, as shown by a common value for the so_major_id field of the eir_server_owner field returned by EXCHANGE_ID, the location or locations may designate alternate server addresses in the form of specific server network addresses. These can be used to access the file system in question at those addresses and when it is no longer accessible at the original address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のサーバーアドレスが同じ実際のサーバーに対応する場合、EXCHANGE_IDによって返されるeir_server_ownerフィールドのso_major_idフィールドの共通値で示されるように、場所は特定のサーバーネットワークアドレスの形式で代替サーバーアドレスを指定する場合があります。これらは、それらのアドレスで問題のファイルシステムにアクセスするため、および元のアドレスでアクセスできなくなったときに使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although a single successor location is typical, multiple locations may be provided, together with information that allows priority among the choices to be indicated, via information in the fs_locations_info attribute. Where suitable, clustering mechanisms make it possible to provide multiple identical file systems or paths to them; this allows the client the opportunity to deal with any resource or communications issues that might limit data availability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一の後継ロケーションが一般的ですが、fs_locations_info属性の情報を介して、選択肢間の優先順位を示すことができる情報とともに、複数のロケーションを提供できます。適切な場合、クラスタリングメカニズムにより、複数の同一のファイルシステムまたはそれらへのパスを提供できます。これにより、クライアントは、データの可用性を制限する可能性があるリソースまたは通信の問題に対処する機会が得られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an alternate location is designated as the target for migration, it must designate the same data (with metadata being the same to the degree indicated by the fs_locations_info attribute). Where file systems are writable, a change made on the original file system must be visible on all migration targets. Where a file system is not writable but represents a read-only copy (possibly periodically updated) of a writable file system, similar requirements apply to the propagation of updates. Any change visible in the original file system must already be effected on all migration targets, to avoid any possibility that a client, in effecting a transition to the migration target, will see any reversion in file system state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代替の場所が移行のターゲットとして指定されている場合は、同じデータを指定する必要があります（メタデータはfs_locations_info属性で示される程度に同じです）。ファイルシステムが書き込み可能である場合、元のファイルシステムで行われた変更は、すべての移行ターゲットで可視である必要があります。ファイルシステムが書き込み可能ではないが、書き込み可能なファイルシステムの読み取り専用コピー（おそらく定期的に更新される）を表す場合、同様の要件が更新の伝達に適用されます。元のファイルシステムに表示される変更はすべて、すべての移行ターゲットに影響を与えている必要があります。これにより、クライアントが移行ターゲットに移行するときに、ファイルシステムの状態が元に戻される可能性がなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-4-3--Referrals">
11.4.3. Referrals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4.3. 紹介
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Referrals provide a way of placing a file system in a location within the namespace essentially without respect to its physical location on a given server. This allows a single server or a set of servers to present a multi-server namespace that encompasses file systems located on multiple servers. Some likely uses of this include establishment of site-wide or organization-wide namespaces, or even knitting such together into a truly global namespace.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参照は、ファイルシステムをネームスペース内の場所に配置する方法を提供します。基本的に、特定のサーバー上の物理的な場所は考慮されません。これにより、単一のサーバーまたはサーバーのセットが、複数のサーバーにあるファイルシステムを含むマルチサーバーの名前空間を提供できます。この使用例としては、サイト全体または組織全体の名前空間の確立、またはそれらを組み合わせて真にグローバルな名前空間を作成することなどがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Referrals occur when a client determines, upon first referencing a position in the current namespace, that it is part of a new file system and that the file system is absent. When this occurs, typically by receiving the error NFS4ERR_MOVED, the actual location or locations of the file system can be determined by fetching the fs_locations or fs_locations_info attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
紹介は、クライアントが現在のネームスペース内の位置を最初に参照したときに、それが新しいファイルシステムの一部であり、ファイルシステムが存在しないと判断したときに発生します。これが発生した場合、通常はエラーNFS4ERR_MOVEDを受け取り、fs_locationsまたはfs_locations_info属性をフェッチすることで、ファイルシステムの実際の場所を特定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The locations-related attribute may designate a single file system location or multiple file system locations, to be selected based on the needs of the client. The server, in the fs_locations_info attribute, may specify priorities to be associated with various file system location choices. The server may assign different priorities to different locations as reported to individual clients, in order to adapt to client physical location or to effect load balancing. When both read-only and read-write file systems are present, some of the read-only locations might not be absolutely up-to-date (as they would have to be in the case of replication and migration). Servers may also specify file system locations that include client-substituted variables so that different clients are referred to different file systems (with different data contents) based on client attributes such as CPU architecture.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロケーション関連の属性は、クライアントのニーズに基づいて選択される単一のファイルシステムロケーションまたは複数のファイルシステムロケーションを指定できます。サーバーは、fs_locations_info属性で、さまざまなファイルシステムの場所の選択肢に関連付ける優先順位を指定できます。サーバーは、クライアントの物理的な場所に適応したり、ロードバランシングを実行したりするために、個々のクライアントに報告される場所ごとに異なる優先順位を割り当てることがあります。読み取り専用ファイルシステムと読み取り/書き込みファイルシステムの両方が存在する場合、読み取り専用の場所の一部は完全に最新ではない可能性があります（レプリケーションと移行の場合に必要になるため）。サーバーは、クライアント置換変数を含むファイルシステムの場所を指定することもできるため、CPUアーキテクチャなどのクライアント属性に基づいて、異なるクライアントが異なるファイルシステム（異なるデータコンテンツ）で参照されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the fs_locations_info attribute indicates that there are multiple possible targets listed, the relationships among them may be important to the client in selecting which one to use. The same rules specified in Section 11.4.1 defining the appropriate standards
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations_info属性が、複数の可能なターゲットがリストされていることを示している場合、それらの間の関係は、使用するターゲットを選択する際にクライアントにとって重要な場合があります。適切な規格を定義するセクション11.4.1で指定された同じルール
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
for the data propagation apply to these multiple replicas as well. For example, the client might prefer a writable target on a server that has additional writable replicas to which it subsequently might switch. Note that, as distinguished from the case of replication, there is no need to deal with the case of propagation of updates made by the current client, since the current client has not accessed the file system in question.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データの伝播は、これらの複数のレプリカにも適用されます。たとえば、クライアントは、追加の書き込み可能なレプリカを持つサーバー上の書き込み可能なターゲットを優先する場合があります。レプリケーションの場合とは異なり、現在のクライアントは問題のファイルシステムにアクセスしていないため、現在のクライアントによって行われた更新の伝播のケースを処理する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of multi-server namespaces is enabled by NFSv4.1 but is not required. The use of multi-server namespaces and their scope will depend on the applications used and system administration preferences.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1ではマルチサーバー名前空間の使用が可能ですが、必須ではありません。マルチサーバー名前空間とそのスコープの使用は、使用するアプリケーションとシステム管理設定に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multi-server namespaces can be established by a single server providing a large set of referrals to all of the included file systems. Alternatively, a single multi-server namespace may be administratively segmented with separate referral file systems (on separate servers) for each separately administered portion of the namespace. The top-level referral file system or any segment may use replicated referral file systems for higher availability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチサーバー名前空間は、含まれているすべてのファイルシステムへの参照の大規模なセットを提供する単一のサーバーによって確立できます。あるいは、単一のマルチサーバー名前空間は、名前空間の個別に管理される部分ごとに、個別の参照ファイルシステム（個別のサーバー上）で管理上セグメント化される場合があります。トップレベルの紹介ファイルシステムまたは任意のセグメントは、可用性を高めるために複製された紹介ファイルシステムを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Generally, multi-server namespaces are for the most part uniform, in that the same data made available to one client at a given location in the namespace is made available to all clients at that location. However, there are facilities provided that allow different clients to be directed to different sets of data, so as to adapt to such client characteristics as CPU architecture.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般に、マルチサーバー名前空間は、名前空間の特定の場所にある1つのクライアントが利用できるようにされた同じデータが、その場所にあるすべてのクライアントが利用できるという点で、ほとんどが統一されています。ただし、CPUアーキテクチャなどのクライアントの特性に適応するために、さまざまなクライアントをさまざまなデータセットに転送できるようにする機能が提供されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-5--Location-Entries-and-Server-Identity">
11.5. Location Entries and Server Identity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.5. ロケーションエントリとサーバーID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned above, a single location entry may have a server address target in the form of a DNS name that may represent multiple IP addresses, while multiple location entries may have their own server address targets that reference the same server. Whether two IP addresses designate the same server is indicated by the existence of a common so_major_id field within the eir_server_owner field returned by EXCHANGE_ID (see Section 18.35.3), subject to further verification (for details see Section 2.10.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のように、単一のロケーションエントリには、複数のIPアドレスを表すDNS名の形式のサーバーアドレスターゲットがあり、複数のロケーションエントリには、同じサーバーを参照する独自のサーバーアドレスターゲットがある場合があります。 2つのIPアドレスが同じサーバーを指定しているかどうかは、EXCHANGE_ID（セクション18.35.3を参照）によって返されるeir_server_ownerフィールド内に共通のso_major_idフィールドが存在することで示されます（詳細はセクション2.10.5を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When multiple addresses for the same server exist, the client may assume that for each file system in the namespace of a given server network address, there exist file systems at corresponding namespace locations for each of the other server network addresses. It may do this even in the absence of explicit listing in fs_locations and fs_locations_info. Such corresponding file system locations can be used as alternate locations, just as those explicitly specified via the fs_locations and fs_locations_info attributes. Where these specific addresses are explicitly designated in the fs_locations_info attribute, the conditions of use specified in this attribute (e.g., priorities, specification of simultaneous use) may limit the client&#39;s use of these alternate locations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
同じサーバーに複数のアドレスが存在する場合、クライアントは、特定のサーバーネットワークアドレスのネームスペース内の各ファイルシステムについて、他の各サーバーネットワークアドレスの対応するネームスペースの場所にファイルシステムが存在すると想定する場合があります。 fs_locationsとfs_locations_infoに明示的なリストがない場合でも、これを行う可能性があります。そのような対応するファイルシステムの場所は、fs_locationsおよびfs_locations_info属性を介して明示的に指定されたのと同じように、代替の場所として使用できます。これらの特定のアドレスがfs_locations_info属性で明示的に指定されている場合、この属性で指定された使用条件（優先度、同時使用の指定など）により、これらの代替場所のクライアントの使用が制限される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a single location entry designates multiple server IP addresses, the client cannot assume that these addresses are multiple paths to the same server. In most cases, they will be, but the client MUST verify that before acting on that assumption. When two server addresses are designated by a single location entry and they correspond to different servers, this normally indicates some sort of misconfiguration, and so the client should avoid using such location entries when alternatives are available. When they are not, clients should pick one of IP addresses and use it, without using others that are not directed to the same server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一の場所エントリが複数のサーバーIPアドレスを指定している場合、クライアントはこれらのアドレスが同じサーバーへの複数のパスであると想定できません。ほとんどの場合、そうなりますが、クライアントはその仮定に基づいて行動する前にそれを確認する必要があります。 2つのサーバーアドレスが単一の場所エントリによって指定され、それらが異なるサーバーに対応している場合、これは通常、ある種の構成ミスを示しているため、代替が利用可能な場合、クライアントはそのような場所エントリの使用を避けます。そうでない場合、クライアントは同じサーバーに向けられていない他のIPアドレスを使用せずに、IPアドレスの1つを選択して使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-6--Additional-Client-Side-Considerations">
11.6. Additional Client-Side Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.6. 追加のクライアント側の考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When clients make use of servers that implement referrals, replication, and migration, care should be taken that a user who mounts a given file system that includes a referral or a relocated file system continues to see a coherent picture of that user-side file system despite the fact that it contains a number of server-side file systems that may be on different servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが参照、複製、および移行を実装するサーバーを利用する場合、参照または再配置されたファイルシステムを含む特定のファイルシステムをマウントするユーザーが、そのユーザー側のファイルシステムの一貫した状況を引き続き表示するように注意する必要があります。異なるサーバー上にある可能性のあるサーバー側のファイルシステムが多数含まれているという事実にもかかわらず。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One important issue is upward navigation from the root of a server-side file system to its parent (specified as &#34;..&#34; in UNIX), in the case in which it transitions to that file system as a result of referral, migration, or a transition as a result of replication. When the client is at such a point, and it needs to ascend to the parent, it must go back to the parent as seen within the multi-server namespace rather than sending a LOOKUPP operation to the server, which would result in the parent within that server&#39;s single-server namespace. In order to do this, the client needs to remember the filehandles that represent such file system roots and use these instead of sending a LOOKUPP operation to the current server. This will allow the client to present to applications a consistent namespace, where upward navigation and downward navigation are consistent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重要な問題の1つは、サーバー側のファイルシステムのルートからその親（UNIXでは「..」として指定）への上方ナビゲーションです。これは、参照、移行、またはその結果としてそのファイルシステムに移行する場合に発生します。レプリケーションの結果としての遷移。クライアントがそのようなポイントにあり、親に昇格する必要がある場合、サーバーにLOOKUPP操作を送信するのではなく、マルチサーバー名前空間内で見られるように、親に戻る必要があります。そのサーバーの単一サーバー名前空間。これを行うには、クライアントは、そのようなファイルシステムルートを表すファイルハンドルを記憶し、現在のサーバーにLOOKUPP操作を送信する代わりにこれらを使用する必要があります。これにより、クライアントは、上方向のナビゲーションと下方向のナビゲーションが一致する一貫した名前空間をアプリケーションに提示できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Another issue concerns refresh of referral locations. When referrals are used extensively, they may change as server configurations change. It is expected that clients will cache information related to traversing referrals so that future client-side requests are resolved locally without server communication. This is usually rooted in client-side name look up caching. Clients should periodically purge this data for referral points in order to detect changes in location information. When the change_policy attribute changes for directories that hold referral entries or for the referral entries themselves, clients should consider any associated cached referral information to be out of date.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
もう1つの問題は、参照場所の更新に関するものです。紹介が広範囲に使用される場合、サーバー構成が変更されると紹介が変更される可能性があります。クライアントは紹介のトラバースに関連する情報をキャッシュし、将来のクライアント側の要求がサーバー通信なしでローカルに解決されることが期待されます。これは通常、クライアント側の名前検索キャッシングに根ざしています。クライアントは、位置情報の変更を検出するために、参照ポイントのこのデータを定期的に削除する必要があります。紹介エントリを保持するディレクトリまたは紹介エントリ自体のchange_policy属性が変更された場合、クライアントは、関連付けられているキャッシュされた紹介情報が古くなっていると見なす必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-7--Effecting-File-System-Transitions">
11.7. Effecting File System Transitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7. ファイルシステムの移行に影響を与える
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions between file system instances, whether due to switching between replicas upon server unavailability or to server-initiated migration events, are best dealt with together. This is so even though, for the server, pragmatic considerations will normally force different implementation strategies for planned and unplanned transitions. Even though the prototypical use cases of replication and migration contain distinctive sets of features, when all possibilities for these operations are considered, there is an underlying unity of these operations, from the client&#39;s point of view, that makes treating them together desirable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムインスタンス間の移行は、サーバーが利用できなくなったときのレプリカ間の切り替えによるものか、サーバーが開始した移行イベントによるものかにかかわらず、一緒に処理するのが最適です。これは、サーバーの場合、実用的な考慮事項が通常、計画された移行と計画外の移行に異なる実装戦略を強制する場合でも同じです。複製と移行の典型的な使用例には、特徴的な一連の機能が含まれていますが、これらの操作のすべての可能性を考慮すると、クライアントの観点から、これらの操作の根本的な統一性があり、それらを一緒に扱うことが望ましいものになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number of methods are possible for servers to replicate data and to track client state in order to allow clients to transition between file system instances with a minimum of disruption. Such methods vary between those that use inter-server clustering techniques to limit the changes seen by the client, to those that are less aggressive, use more standard methods of replicating data, and impose a greater burden on the client to adapt to the transition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがデータを複製し、クライアントの状態を追跡して、最小限の中断でファイルシステムインスタンス間をクライアントが移行できるようにするために、いくつかの方法が可能です。このような方法は、クライアント間で見られる変更を制限するためにサーバー間クラスタリング手法を使用するものから、それほど積極的ではなく、より標準的なデータ複製方法を使用し、移行に適応するためにより大きな負担をクライアントに課すものまで異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 protocol does not impose choices on clients and servers with regard to that spectrum of transition methods. In fact, there are many valid choices, depending on client and application requirements and their interaction with server implementation choices. The NFSv4.1 protocol does define the specific choices that can be made, how these choices are communicated to the client, and how the client is to deal with any discontinuities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1プロトコルは、移行方法のそのスペクトルに関してクライアントとサーバーに選択を課しません。実際、クライアントとアプリケーションの要件、およびそれらとサーバー実装の選択肢との相互作用に応じて、多くの有効な選択肢があります。 NFSv4.1プロトコルは、実行可能な特定の選択、これらの選択がクライアントに伝達される方法、およびクライアントが不連続性を処理する方法を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the sections below, references will be made to various possible server implementation choices as a way of illustrating the transition scenarios that clients may deal with. The intent here is not to define or limit server implementations but rather to illustrate the range of issues that clients may face.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のセクションでは、クライアントが処理する可能性のある移行シナリオを示す方法として、さまざまな可能なサーバー実装の選択肢を参照します。ここでの目的は、サーバーの実装を定義または制限することではなく、クライアントが直面する可能性のある問題の範囲を説明することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In the discussion below, references will be made to a file system having a particular property or to two file systems (typically the source and destination) belonging to a common class of any of several types. Two file systems that belong to such a class share some important aspects of file system behavior that clients may depend upon when present, to easily effect a seamless transition between file system instances. Conversely, where the file systems do not belong to such a common class, the client has to deal with various sorts of implementation discontinuities that may cause performance or other issues in effecting a transition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
以下の説明では、特定のプロパティを持つファイルシステム、またはいくつかのタイプのいずれかの共通クラスに属する2つのファイルシステム（通常はソースと宛先）を参照します。このようなクラスに属する2つのファイルシステムは、ファイルシステムインスタンス間のシームレスな移行を簡単に実現するために、クライアントが存在するときに依存する可能性があるファイルシステム動作のいくつかの重要な側面を共有します。逆に、ファイルシステムがこのような共通のクラスに属していない場合、クライアントは、パフォーマンスの変化やその他の移行の問題を引き起こす可能性のある、さまざまな種類の実装の不連続性に対処する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the fs_locations_info attribute is available, such file system classification data will be made directly available to the client (see Section 11.10 for details). When only fs_locations is available, default assumptions with regard to such classifications have to be inferred (see Section 11.9 for details).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations_info属性が利用可能な場合、そのようなファイルシステム分類データは、クライアントが直接利用できるようになります（詳細については、セクション11.10を参照）。 fs_locationsのみが使用可能な場合、そのような分類に関するデフォルトの仮定を推測する必要があります（詳細については、セクション11.9を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In cases in which one server is expected to accept opaque values from the client that originated from another server, the servers SHOULD encode the &#34;opaque&#34; values in big-endian byte order. If this is done, servers acting as replicas or immigrating file systems will be able to parse values like stateids, directory cookies, filehandles, etc., even if their native byte order is different from that of other servers cooperating in the replication and migration of the file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あるサーバーが別のサーバーから発信されたクライアントからの不透明な値を受け入れると予想される場合、サーバーはビッグエンディアンのバイト順で「不透明な」値をエンコードする必要があります（SHOULD）。これを行うと、レプリカとして機能するサーバーまたはファイルシステムを移行するサーバーは、ネイティブIDの順序が他のサーバーのレプリケーションと移行で協調しているサーバーと異なる場合でも、stateid、ディレクトリCookie、ファイルハンドルなどの値を解析できます。ファイルシステム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-7-1--File-System-Transitions-and-Simultaneous-Access">
11.7.1. File System Transitions and Simultaneous Access
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.1. ファイルシステムの移行と同時アクセス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a single file system may be accessed at multiple locations, either because of an indication of file system identity as reported by the fs_locations or fs_locations_info attributes or because two file system instances have corresponding locations on server addresses that connect to the same server (as indicated by a common so_major_id field in the eir_server_owner field returned by EXCHANGE_ID), the client will, depending on specific circumstances as discussed below, either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locationsまたはfs_locations_info属性によって報告されたファイルシステムIDの表示、または2つのファイルシステムインスタンスが同じサーバーに接続されているサーバーアドレスに対応する場所を持っているため（示されているとおり）、単一のファイルシステムが複数の場所でアクセスされる可能性がある場合EXCHANGE_IDによって返されるeir_server_ownerフィールドの共通のso_major_idフィールドによって、クライアントは、以下で説明する特定の状況に応じて、次のいずれかになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Access multiple instances simultaneously, each of which represents an alternate path to the same data and metadata.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 複数のインスタンスに同時にアクセスします。各インスタンスは、同じデータとメタデータへの代替パスを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Access one instance (or set of instances) and then transition to an alternative instance (or set of instances) as a result of network issues, server unresponsiveness, or server-directed migration. The transition may involve changes in filehandles, fileids, the change attribute, and/or locking state, depending on the attributes of the source and destination file system instances, as specified in the fs_locations_info attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1つのインスタンス（またはインスタンスのセット）にアクセスし、ネットワークの問題、サーバーの応答性の低下、またはサーバー主導の移行の結果として、代替インスタンス（またはインスタンスのセット）に移行します。移行では、fs_locations_info属性で指定されているように、ソースおよび宛先のファイルシステムインスタンスの属性に応じて、ファイルハンドル、ファイルID、変更属性、ロック状態の変更が含まれる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Which of these choices is possible, and how a transition is effected, is governed by equivalence classes of file system instances as reported by the fs_locations_info attribute, and for file system instances in the same location within a multi-homed single-server namespace, as indicated by the value of the so_major_id field of the eir_server_owner field returned by EXCHANGE_ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの選択肢のどれが可能であり、どのように移行が行われるかは、fs_locations_info属性によって報告されるファイルシステムインスタンスの同等クラス、およびマルチホームの単一サーバー名前空間内の同じ場所にあるファイルシステムインスタンスによって制御されます。 EXCHANGE_IDから返されたeir_server_ownerフィールドのso_major_idフィールドの値によって示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-7-2--Simultaneous-Use-and-Transparent-Transitions">
11.7.2. Simultaneous Use and Transparent Transitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.2. 同時使用と透過的な移行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When two file system instances have the same location within their respective single-server namespaces and those two server network addresses designate the same server (as indicated by the same value of the so_major_id field of the eir_server_owner field returned in response to EXCHANGE_ID), those file system instances can be treated as the same, and either used together simultaneously or serially with no transition activity required on the part of the client. In this case, we refer to the transition as &#34;transparent&#34;, and the client in transferring access from one to the other is acting as it would in the event that communication is interrupted, with a new connection and possibly a new session being established to continue access to the same file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのファイルシステムインスタンスがそれぞれの単一サーバー名前空間内で同じ場所にあり、それらの2つのサーバーネットワークアドレスが同じサーバーを指定している場合（EXCHANGE_IDに応答して返されるeir_server_ownerフィールドのso_major_idフィールドの同じ値で示される）、それらのファイルシステムインスタンスは同じものとして扱うことができ、同時に使用することも、逐次的に使用することもでき、クライアント側で移行アクティビティは必要ありません。この場合、遷移を「透過的」と呼び、クライアントが一方から他方にアクセスを転送する際に、通信が中断された場合と同様に動作し、新しい接続と、場合によっては新しいセッションが確立されます。同じファイルシステムへのアクセスを続行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whether simultaneous use of the two file system instances is valid is controlled by whether the fs_locations_info attribute shows the two instances as having the same simultaneous-use class. See Section 11.10.1 for information about the definition of the various use classes, including the simultaneous-use class.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのファイルシステムインスタンスの同時使用が有効かどうかは、fs_locations_info属性が2つのインスタンスに同じ同時使用クラスを持っていると表示するかどうかによって制御されます。同時使用クラスを含むさまざまな使用クラスの定義については、11.10.1項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that for two such file systems, any information within the fs_locations_info attribute that indicates the need for special transition activity, i.e., the appearance of the two file system instances with different handle, fileid, write-verifier, change, and readdir classes, indicates a serious problem. The client, if it allows transition to the file system instance at all, must not treat this as a transparent transition. The server SHOULD NOT indicate that these instances belong to different handle, fileid, write-verifier, change, and readdir classes, whether or not the two instances are shown belonging to the same simultaneous-use class.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような2つのファイルシステムの場合、fs_locations_info属性内の特別な遷移アクティビティの必要性を示す情報、つまり、ハンドル、fileid、write-verifier、change、およびreaddirクラスが異なる2つのファイルシステムインスタンスの外観は、深刻な問題。クライアントは、ファイルシステムインスタンスへの移行を許可する場合、これを透過的な移行として扱わないでください。サーバーは、2つのインスタンスが同じ同時使用クラスに属して表示されているかどうかに関係なく、これらのインスタンスが異なるハンドル、fileid、write-verifier、change、およびreaddirクラスに属していることを示すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where these conditions do not apply, a non-transparent file system instance transition is required with the details depending on the respective handle, fileid, write-verifier, change, and readdir classes of the two file system instances, and whether the two servers&#39; addresses in question have the same eir_server_scope value as reported by EXCHANGE_ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの条件が当てはまらない場合、2つのファイルシステムインスタンスのそれぞれのハンドル、fileid、write-verifier、change、readdirクラス、および2つのサーバーの問題のアドレスは、EXCHANGE_IDによって報告されたものと同じeir_server_scope値を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-7-2-1--Simultaneous-Use-of-File-System-Instances">
11.7.2.1. Simultaneous Use of File System Instances
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.2.1. ファイルシステムインスタンスの同時使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the conditions in Section 11.7.2 hold, in either of the following two cases, the client may use the two file system instances simultaneously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11.7.2項の条件が満たされた場合、次の2つの場合のいずれかで、クライアントは2つのファイルシステムインスタンスを同時に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o The fs_locations_info attribute does not contain separate per-network-address entries for file system instances at the distinct network addresses. This includes the case in which the fs_locations_info attribute is unavailable. In this case, the fact that the two server addresses connect to the same server (as indicated by the two addresses sharing the same the so_major_id value and subsequently confirmed as described in Section 2.10.5) justifies simultaneous use, and there is no fs_locations_info attribute information contradicting that.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
o fs_locations_info属性には、個別のネットワークアドレスにあるファイルシステムインスタンスの個別のネットワークアドレスごとのエントリは含まれません。これには、fs_locations_info属性が使用できない場合が含まれます。この場合、2つのサーバーアドレスが同じサーバーに接続している（2つのアドレスが同じso_major_id値を共有し、2.10.5で説明されているように後で確認される）ことにより、同時使用が正当化され、fs_locations_info属性はありません。それと矛盾する情報。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The fs_locations_info attribute indicates that two file system instances belong to the same simultaneous-use class.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o fs_locations_info属性は、2つのファイルシステムインスタンスが同じ同時使用クラスに属していることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this case, the client may use both file system instances simultaneously, as representations of the same file system, whether that happens because the two network addresses connect to the same physical server or because different servers connect to clustered file systems and export their data in common. When simultaneous use is in effect, any change made to one file system instance must be immediately reflected in the other file system instance(s). Locks are treated as part of a common lease, associated with a common client ID. Depending on the details of the eir_server_owner returned by EXCHANGE_ID, the two server instances may be accessed by different sessions or a single session in common.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合、2つのネットワークアドレスが同じ物理サーバーに接続しているため、または異なるサーバーがクラスター化されたファイルシステムに接続してデータをエクスポートするために、クライアントは両方のファイルシステムインスタンスを同じファイルシステムの表現として同時に使用できます。一般。同時使用が有効な場合、1つのファイルシステムインスタンスに加えられた変更は、他のファイルシステムインスタンスにすぐに反映される必要があります。ロックは、共通のクライアントIDに関連付けられた共通のリースの一部として扱われます。 EXCHANGE_IDによって返されるeir_server_ownerの詳細に応じて、2つのサーバーインスタンスは、異なるセッションまたは共通の単一セッションによってアクセスされる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-7-2-2--Transparent-File-System-Transitions">
11.7.2.2. Transparent File System Transitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.2.2. 透過的なファイルシステムの移行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the conditions in Section 11.7.2.1 hold and the fs_locations_info attribute explicitly shows the file system instances for these distinct network addresses as belonging to different simultaneous-use classes, the file system instances should not be used by the client simultaneously. Rather, they should be used serially with one being used unless and until communication difficulties, lack of responsiveness, or an explicit migration event causes another file system instance (or set of file system instances sharing a common simultaneous-use class) to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション11.7.2.1の条件が満たされ、fs_locations_info属性がこれらの個別のネットワークアドレスのファイルシステムインスタンスを異なる同時使用クラスに属するものとして明示的に示す場合、ファイルシステムインスタンスをクライアントが同時に使用しないでください。むしろ、通信の問題、応答性の欠如、または明示的な移行イベントによって別のファイルシステムインスタンス（または共通の同時使用クラスを共有するファイルシステムインスタンスのセット）が使用されるまでは、これらを連続して使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a change of file system instance is to be done, the client will use the same client ID already in effect. If the client already has connections to the new server address, these will be used. Otherwise, new connections to existing sessions or new sessions associated with the existing client ID are established as indicated by the eir_server_owner returned by EXCHANGE_ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムインスタンスの変更が行われる場合、クライアントは既に有効な同じクライアントIDを使用します。クライアントがすでに新しいサーバーアドレスに接続している場合は、これらが使用されます。それ以外の場合、既存のセッションへの新しい接続または既存のクライアントIDに関連付けられた新しいセッションは、EXCHANGE_IDによって返されたeir_server_ownerによって示されるように確立されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In all such transparent transition cases, the following apply:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのようなすべての透過的な移行の場合、以下が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If filehandles are persistent, they stay the same. If filehandles are volatile, they either stay the same or expire, but the reason for expiration is not due to the file system transition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルハンドルが永続的である場合、それらは同じままです。ファイルハンドルが揮発性である場合、それらは同じままになるか期限切れになりますが、期限切れの理由はファイルシステムの移行によるものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Fileid values do not change across the transition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Fileid値は、遷移全体で変化しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The file system will have the same fsid in both the old and new locations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルシステムは、古い場所と新しい場所の両方で同じfsidを持ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Change attribute values are consistent across the transition and do not have to be refetched. When change attributes indicate that a cached object is still valid, it can remain cached.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 変更属性値は遷移全体で一貫しており、再フェッチする必要はありません。変更された属性が、キャッシュされたオブジェクトがまだ有効であることを示している場合、そのオブジェクトはキャッシュされたままになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Client and state identifiers retain their validity across the transition, except where their staleness is recognized and reported by the new server. Except where such staleness requires it, no lock reclamation is needed. Any such staleness is an indication that the server should be considered to have restarted and is reported as discussed in Section 8.4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントと状態の識別子は、新しいサーバーによって失効が認識および報告される場合を除いて、移行中も有効性を保持します。このような古い状態で必要な場合を除いて、ロックの再利用は必要ありません。このような古い状態は、サーバーが再起動したと見なされる必要があることを示しており、セクション8.4.2で説明されているように報告されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Write verifiers are presumed to retain their validity and can be used to compare with verifiers returned by COMMIT on the new server. If COMMIT on the new server returns an identical verifier, then it is expected that the new server has all of the data that was written unstably to the original server and has committed that data to stable storage as requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 書き込みベリファイアは、その有効性を保持していると想定されており、新しいサーバーのCOMMITによって返されたベリファイアと比較するために使用できます。新しいサーバーのCOMMITが同一のベリファイアを返す場合、新しいサーバーには元のサーバーに不安定に書き込まれたすべてのデータがあり、要求に応じてそのデータを安定したストレージにコミットしていると予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Readdir cookies are presumed to retain their validity and can be presented to subsequent READDIR requests together with the readdir verifier with which they are associated. When the verifier is accepted as valid, the cookie will continue the READDIR operation so that the entire directory can be obtained by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Readdir Cookieは、その有効性を保持していると想定されており、関連付けられているreaddirベリファイアと共に後続のREADDIR要求に提示できます。ベリファイアが有効として受け入れられると、CookieはREADDIR操作を続行し、クライアントがディレクトリ全体を取得できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-7-3--Filehandles-and-File-System-Transitions">
11.7.3. Filehandles and File System Transitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.3. ファイルハンドルとファイルシステムの移行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are a number of ways in which filehandles can be handled across a file system transition. These can be divided into two broad classes depending upon whether the two file systems across which the transition happens share sufficient state to effect some sort of continuity of file system handling.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルハンドルをファイルシステムの移行全体で処理する方法はいくつかあります。これらは、移行が発生する2つのファイルシステムが、ファイルシステムの処理の連続性に影響を与えるのに十分な状態を共有しているかどうかに応じて、2つの広いクラスに分類できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When there is no such cooperation in filehandle assignment, the two file systems are reported as being in different handle classes. In this case, all filehandles are assumed to expire as part of the file system transition. Note that this behavior does not depend on the fh_expire_type attribute and supersedes the specification of the FH4_VOL_MIGRATION bit, which only affects behavior when fs_locations_info is not available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルハンドルの割り当てにそのような連携がない場合、2つのファイルシステムは異なるハンドルクラスにあると報告されます。この場合、ファイルシステムの移行の一環として、すべてのファイルハンドルが期限切れと見なされます。この動作はfh_expire_type属性に依存せず、FH4_VOL_MIGRATIONビットの指定よりも優先されることに注意してください。これは、fs_locations_infoが使用できない場合の動作にのみ影響します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When there is cooperation in filehandle assignment, the two file systems are reported as being in the same handle classes. In this case, persistent filehandles remain valid after the file system transition, while volatile filehandles (excluding those that are only volatile due to the FH4_VOL_MIGRATION bit) are subject to expiration on the target server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ファイルハンドルの割り当てに協力関係がある場合、2つのファイルシステムは同じハンドルクラスにあると報告されます。この場合、永続的なファイルハンドルはファイルシステムの移行後も有効のままですが、揮発性ファイルハンドル（FH4_VOL_MIGRATIONビットのために揮発性のみのものは除く）はターゲットサーバーで期限切れになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-7-4--Fileids-and-File-System-Transitions">
11.7.4. Fileids and File System Transitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.4. ファイルIDとファイルシステムの移行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In NFSv4.0, the issue of continuity of fileids in the event of a file system transition was not addressed. The general expectation had been that in situations in which the two file system instances are created by a single vendor using some sort of file system image copy, fileids will be consistent across the transition, while in the analogous multi-vendor transitions they will not. This poses difficulties, especially for the client without special knowledge of the transition mechanisms adopted by the server. Note that although fileid is not a REQUIRED attribute, many servers support fileids and many clients provide APIs that depend on fileids.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.0では、ファイルシステムの移行時に発生するファイルIDの連続性の問題は解決されませんでした。一般的な期待は、2つのファイルシステムインスタンスが、ある種のファイルシステムイメージコピーを使用して単一のベンダーによって作成された状況では、移行全体でfileidは一貫するが、類似のマルチベンダー移行ではそうではないというものでした。これは、特にサーバーで採用されている移行メカニズムに関する特別な知識がないクライアントにとっては困難です。 fileidは必須属性ではありませんが、多くのサーバーがfileidをサポートし、多くのクライアントがfileidに依存するAPIを提供していることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is important to note that while clients themselves may have no trouble with a fileid changing as a result of a file system transition event, applications do typically have access to the fileid (e.g., via stat). The result is that an application may work perfectly well if there is no file system instance transition or if any such transition is among instances created by a single vendor, yet be unable to deal with the situation in which a multi-vendor transition occurs at the wrong time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント自体はファイルシステム移行イベントの結果としてファイルIDを変更しても問題はないかもしれませんが、アプリケーションは通常（たとえば、statを介して）fileidにアクセスできることに注意することが重要です。その結果、ファイルシステムインスタンスの移行がない場合、またはそのような移行が単一のベンダーによって作成されたインスタンス間で行われる場合、アプリケーションは完全に正常に動作する可能性がありますが、マルチベンダーの移行が発生する状況に対処できません間違った時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Providing the same fileids in a multi-vendor (multiple server vendors) environment has generally been held to be quite difficult. While there is work to be done, it needs to be pointed out that this difficulty is partly self-imposed. Servers have typically identified fileid with inode number, i.e. with a quantity used to find the file in question. This identification poses special difficulties for migration of a file system between vendors where assigning the same index to a given file may not be possible. Note here that a fileid is not required to be useful to find the file in question, only that it is unique within the given file system. Servers prepared to accept a fileid as a single piece of metadata and store it apart from the value used to index the file information can relatively easily maintain a fileid value across a migration event, allowing a truly transparent migration event.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチベンダー（複数のサーバーベンダー）環境で同じファイルIDを提供することは、一般的に非常に難しいとされてきました。やらなければならない仕事がありますが、この困難は部分的に自主的に課されていることを指摘する必要があります。サーバーは通常、inode番号、つまり問題のファイルを見つけるために使用される数量でfileidを識別しました。この識別は、特定のファイルに同じインデックスを割り当てることができない場合があるベンダー間でのファイルシステムの移行に特別な困難をもたらします。 fileidは、問題のファイルを見つけるのに役立つ必要はなく、指定されたファイルシステム内で一意であることに注意してください。 fileidを単一のメタデータとして受け入れ、ファイル情報のインデックス付けに使用される値とは別に保存するように準備されたサーバーは、移行イベント全体で比較的簡単にfileid値を維持できるため、真に透過的な移行イベントが可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In any case, where servers can provide continuity of fileids, they should, and the client should be able to find out that such continuity is available and take appropriate action. Information about the continuity (or lack thereof) of fileids across a file system transition is represented by specifying whether the file systems in question are of the same fileid class.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いずれの場合も、サーバーがファイルIDの連続性を提供できる場合は、それらを提供する必要があります。クライアントは、そのような連続性が利用可能であることを確認し、適切なアクションを実行できる必要があります。ファイルシステムの移行全体でのファイルIDの連続性（または欠如）に関する情報は、問題のファイルシステムが同じFileidクラスであるかどうかを指定することによって表されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that when consistent fileids do not exist across a transition (either because there is no continuity of fileids or because fileid is not a supported attribute on one of instances involved), and there are no reliable filehandles across a transition event (either because there is no filehandle continuity or because the filehandles are volatile), the client is in a position where it cannot verify that files it was accessing before the transition are the same objects. It is forced to assume that no object has been renamed, and, unless there are guarantees that provide this (e.g., the file system is read-only), problems for applications may occur. Therefore, use of such configurations should be limited to situations where the problems that this may cause can be tolerated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランジション全体で一貫したfileidが存在しない場合（fileidの連続性がないか、fileidが関連するインスタンスの1つでサポートされている属性ではないため）、およびトランジションイベント全体で信頼できるファイルハンドルがない場合（ファイルハンドルの連続性がないか、ファイルハンドルが揮発性であるため）、クライアントは、遷移前にアクセスしていたファイルが同じオブジェクトであることを確認できない状況にあります。オブジェクトの名前が変更されていないと想定する必要があり、これを提供する保証がない場合（ファイルシステムが読み取り専用など）を除いて、アプリケーションに問題が発生する可能性があります。したがって、このような構成の使用は、これによって引き起こされる可能性のある問題が許容される状況に限定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-7-5--Fsids-and-File-System-Transitions">
11.7.5. Fsids and File System Transitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.5. FSIDとファイルシステムの移行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since fsids are generally only unique within a per-server basis, it is likely that they will change during a file system transition. One exception is the case of transparent transitions, but in that case we have multiple network addresses that are defined as the same server (as specified by a common value of the so_major_id field of eir_server_owner). Clients should not make the fsids received from the server visible to applications since they may not be globally unique, and because they may change during a file system transition event. Applications are best served if they are isolated from such transitions to the extent possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fsidは通常、サーバーごとにのみ一意であるため、ファイルシステムの移行中に変更される可能性があります。 1つの例外は透過的な遷移の場合ですが、その場合、同じサーバーとして定義された複数のネットワークアドレスがあります（eir_server_ownerのso_major_idフィールドの共通の値で指定）。クライアントは、サーバーから受信したfsidをグローバルに一意でない可能性があるため、およびファイルシステムの移行イベント中に変更される可能性があるため、アプリケーションから見えるようにしないでください。アプリケーションは、そのような移行から可能な限り分離されている場合に最適に機能します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although normally a single source file system will transition to a single target file system, there is a provision for splitting a single source file system into multiple target file systems, by specifying the FSLI4F_MULTI_FS flag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、単一のソースファイルシステムは単一のターゲットファイルシステムに移行しますが、FSLI4F_MULTI_FSフラグを指定することにより、単一のソースファイルシステムを複数のターゲットファイルシステムに分割することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-7-5-1--File-System-Splitting">
11.7.5.1. File System Splitting
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.5.1. ファイルシステムの分割
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a file system transition is made and the fs_locations_info indicates that the file system in question may be split into multiple file systems (via the FSLI4F_MULTI_FS flag), the client SHOULD do GETATTRs to determine the fsid attribute on all known objects within the file system undergoing transition to determine the new file system boundaries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムの移行が行われ、fs_locations_infoが問題のファイルシステムが複数のファイルシステムに（FSLI4F_MULTI_FSフラグを介して）分割できることを示している場合、クライアントは、GETATTRを実行して、実行中のファイルシステム内のすべての既知のオブジェクトのfsid属性を決定する必要があります（SHOULD）新しいファイルシステムの境界を決定する遷移。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients may maintain the fsids passed to existing applications by mapping all of the fsids for the descendant file systems to the common fsid used for the original file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、子孫ファイルシステムのすべてのfsidを、元のファイルシステムに使用されている共通のfsidにマッピングすることにより、既存のアプリケーションに渡されたfsidを維持できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Splitting a file system may be done on a transition between file systems of the same fileid class, since the fact that fileids are unique within the source file system ensure they will be unique in each of the target file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムの分割は、同じファイルIDクラスのファイルシステム間の移行で行うことができます。これは、ファイルIDがソースファイルシステム内で一意であるため、各ターゲットファイルシステムで確実に一意になるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-7-6--The-Change-Attribute-and-File-System-Transitions">
11.7.6. The Change Attribute and File System Transitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.6. 属性の変更とファイルシステムの移行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the change attribute is defined as a server-specific one, change attributes fetched from one server are normally presumed to be invalid on another server. Such a presumption is troublesome since it would invalidate all cached change attributes, requiring refetching. Even more disruptive, the absence of any assured continuity for the change attribute means that even if the same value is retrieved on refetch, no conclusions can be drawn as to whether the object in question has changed. The identical change attribute could be merely an artifact of a modified file with a different change attribute construction algorithm, with that new algorithm just happening to result in an identical change value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更属性はサーバー固有の属性として定義されているため、あるサーバーからフェッチされた変更属性は通常、別のサーバーでは無効であると見なされます。このような推定は、キャッシュされたすべての変更属性を無効にし、再フェッチが必要になるため、厄介です。さらに混乱を招き、変更属性の継続性が保証されていないため、再フェッチ時に同じ値が取得されたとしても、問題のオブジェクトが変更されたかどうかについて結論を出すことはできません。同一の変更属性は、異なる変更属性構築アルゴリズムを持つ変更されたファイルの単なるアーティファクトである可能性があり、その新しいアルゴリズムはたまたま同一の変更値をもたらすだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the two file systems have consistent change attribute formats, and this fact is communicated to the client by reporting in the same change class, the client may assume a continuity of change attribute construction and handle this situation just as it would be handled without any file system transition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのファイルシステムに一貫した変更属性形式があり、この事実が同じ変更クラスでレポートすることによってクライアントに伝えられる場合、クライアントは変更属性の構造の連続性を想定し、ファイルなしで処理されるのと同じようにこの状況を処理できます。システムの移行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-7-7--Lock-State-and-File-System-Transitions">
11.7.7. Lock State and File System Transitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.7. ロック状態とファイルシステムの遷移
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a file system transition, the client needs to handle cases in which the two servers have cooperated in state management and in which they have not. Cooperation by two servers in state management requires coordination of client IDs. Before the client attempts to use a client ID associated with one server in a request to the server of the other file system, it must eliminate the possibility that two non-cooperating servers have assigned the same client ID by accident. The client needs to compare the eir_server_scope values returned by each server. If the scope values do not match, then the servers have not cooperated in state management. If the scope values match, then this indicates the servers have cooperated in assigning client IDs to the point that they will reject client IDs that refer to state they do not know about. See Section 2.10.4 for more information about the use of server scope.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムの移行では、クライアントは、2つのサーバーが状態管理に協力した場合と協力していない場合を処理する必要があります。状態管理における2つのサーバーの連携には、クライアントIDの調整が必要です。クライアントは、一方のサーバーに関連付けられたクライアントIDを他方のファイルシステムのサーバーへのリクエストで使用しようとする前に、2つの非協力サーバーが誤って同じクライアントIDを割り当てた可能性を排除する必要があります。クライアントは、各サーバーから返されたeir_server_scope値を比較する必要があります。スコープの値が一致しない場合、サーバーは状態管理に協力していません。スコープ値が一致する場合、これは、サーバーがクライアントIDの割り当てに協力して、知らない状態を参照するクライアントIDを拒否することを示しています。サーバースコープの使用の詳細については、2.10.4項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of migration, the servers involved in the migration of a file system SHOULD transfer all server state from the original to the new server. When this is done, it must be done in a way that is transparent to the client. With replication, such a degree of common state is typically not the case. Clients, however, should use the information provided by the eir_server_scope returned by EXCHANGE_ID (as modified by the validation procedures described in Section 2.10.4) to determine whether such sharing may be in effect, rather than making assumptions based on the reason for the transition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
移行の場合、ファイルシステムの移行に関与するサーバーは、すべてのサーバーの状態を元のサーバーから新しいサーバーに転送する必要があります（SHOULD）。これを行う場合は、クライアントに対して透過的な方法で行う必要があります。レプリケーションでは、このような一般的な状態は通常ありません。ただし、クライアントは、EXCHANGE_IDによって返されたeir_server_scopeによって提供される情報（セクション2.10.4で説明されている検証手順によって変更されたもの）を使用して、移行の理由に基づいて仮定を行うのではなく、そのような共有が有効かどうかを判断する必要があります。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This state transfer will reduce disruption to the client when a file system transition occurs. If the servers are successful in transferring all state, the client can attempt to establish sessions associated with the client ID used for the source file system instance. If the server accepts that as a valid client ID, then the client may use the existing stateids associated with that client ID for the old file system instance in connection with that same client ID in connection with the transitioned file system instance. If the client in question already had a client ID on the target system, it may interrogate the stateid values from the source system under that new client ID, with the assurance that if they are accepted as valid, then they represent validly transferred lock state for the source file system, which has been transferred to the target server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この状態転送により、ファイルシステムの移行が発生したときのクライアントの中断が減少します。サーバーがすべての状態の転送に成功した場合、クライアントは、ソースファイルシステムインスタンスに使用されているクライアントIDに関連付けられたセッションの確立を試みることができます。サーバーがそれを有効なクライアントIDとして受け入れる場合、クライアントは、移行されたファイルシステムインスタンスに関連する同じクライアントIDに関連して、古いファイルシステムインスタンスに関連付けられた既存の状態IDを使用できます。問題のクライアントがすでにターゲットシステムにクライアントIDを持っている場合は、その新しいクライアントIDの下でソースシステムからのstateid値を問い合わせ、それらが有効であると受け入れられた場合、それらが有効に転送されたロック状態を表すことを保証します。ターゲットサーバーに転送されたソースファイルシステム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the two servers belong to the same server scope, it does not mean that when dealing with the transition, the client will not have to reclaim state. However, it does mean that the client may proceed using its current client ID when establishing communication with the new server, and the new server will either recognize the client ID as valid or reject it, in which case locks must be reclaimed by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのサーバーが同じサーバースコープに属している場合でも、移行を処理するときに、クライアントが状態を取り戻す必要がないわけではありません。ただし、これは、クライアントが新しいサーバーとの通信を確立するときに現在のクライアントIDを使用して続行できることを意味し、新しいサーバーはクライアントIDを有効として認識するか拒否するかのどちらかです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
File systems cooperating in state management may actually share state or simply divide the identifier space so as to recognize (and reject as stale) each other&#39;s stateids and client IDs. Servers that do share state may not do so under all conditions or at all times. If the server cannot be sure when accepting a client ID that it reflects the locks the client was given, the server must treat all associated state as stale and report it as such to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態管理で連携するファイルシステムは、実際に状態を共有するか、または単に識別子スペースを分割して、互いの状態IDとクライアントIDを認識（および古くなったとして拒否）します。状態を共有するサーバーは、すべての条件下で、または常にそうするわけではありません。サーバーがクライアントIDを受け入れるときに、クライアントに与えられたロックを反映していると確信できない場合、サーバーは、関連付けられたすべての状態を古いものとして扱い、そのようにクライアントに報告する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the two file system instances are on servers that do not share a server scope value, the client must establish a new client ID on the destination, if it does not have one already, and reclaim locks if allowed by the server. In this case, old stateids and client IDs should not be presented to the new server since there is no assurance that they will not conflict with IDs valid on that server. Note that in this case, lock reclaim may be attempted even when the servers involved in the transfer have different server scope values (see Section 8.4.2.1 for the contrary case of reclaim after server reboot). Servers with different server scope values may cooperate to allow reclaim for locks associated with the transfer of a file system even if they do not cooperate sufficiently to share a server scope.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのファイルシステムインスタンスがサーバースコープ値を共有しないサーバー上にある場合、クライアントは宛先に新しいクライアントIDをまだ確立していない場合は確立し、サーバーで許可されている場合はロックを再利用する必要があります。この場合、古い状態IDとクライアントIDは、そのサーバーで有効なIDと競合しないという保証がないため、新しいサーバーに提示しないでください。この場合、転送に関与するサーバーのサーバースコープ値が異なる場合でも、ロックの再利用が試行される場合があることに注意してください（サーバーの再起動後の再利用の反対のケースについては、8.4.2.1項を参照してください）。異なるサーバースコープ値を持つサーバーは、サーバースコープを共有するために十分に連携していない場合でも、ファイルシステムの転送に関連するロックの再利用を許可するために連携する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In either case, when actual locks are not known to be maintained, the destination server may establish a grace period specific to the given file system, with non-reclaim locks being rejected for that file system, even though normal locks are being granted for other file systems. Clients should not infer the absence of a grace period for file systems being transitioned to a server from responses to requests for other file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
どちらの場合でも、実際のロックが維持されていることがわからない場合、宛先サーバーは特定のファイルシステムに固有の猶予期間を設定し、通常のロックが他のロックに付与されていても、そのファイルシステムに対して非再利用ロックが拒否される場合があります。ファイルシステム。クライアントは、他のファイルシステムに対する要求への応答からサーバーに移行されるファイルシステムの猶予期間がないことを推測しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of lock reclamation for a given file system after a file system transition, edge conditions can arise similar to those for reclaim after server restart (although in the case of the planned state transfer associated with migration, these can be avoided by securely recording lock state as part of state migration). Unless the destination server can guarantee that locks will not be incorrectly granted, the destination server should not allow lock reclaims and should avoid establishing a grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムの移行後の特定のファイルシステムのロックの再利用の場合、エッジの条件は、サーバーの再起動後の再利用の場合と同様に発生する可能性があります（移行に関連する計画された状態転送の場合は、安全に記録することでこれらを回避できます）状態移行の一部として状態をロックします）。ロックが誤って許可されないことを宛先サーバーが保証できない限り、宛先サーバーはロックの再利用を許可してはならず、猶予期間の確立を回避する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once all locks have been reclaimed, or there were no locks to reclaim, the client indicates that there are no more reclaims to be done for the file system in question by sending a RECLAIM_COMPLETE operation with the rca_one_fs parameter set to true. Once this has been done, non-reclaim locking operations may be done, and any subsequent request to do reclaims will be rejected with the error NFS4ERR_NO_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのロックが再利用されるか、再利用するロックがなくなった場合、クライアントは、rca_one_fsパラメーターをtrueに設定してRECLAIM_COMPLETE操作を送信することにより、問題のファイルシステムに対してこれ以上行うべき再利用がないことを示します。これが行われると、非再利用ロック操作が実行される可能性があり、再利用を実行するための後続の要求はエラーNFS4ERR_NO_GRACEで拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about client identity may be propagated between servers in the form of client_owner4 and associated verifiers, under the assumption that the client presents the same values to all the servers with which it deals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントIDに関する情報は、クライアントが処理するすべてのサーバーに同じ値を提示するという前提の下で、client_owner4および関連するベリファイアの形式でサーバー間で伝達されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers are encouraged to provide facilities to allow locks to be reclaimed on the new server after a file system transition. Often, however, in cases in which the two servers do not share a server scope value, such facilities may not be available and the client should be prepared to re-obtain locks, even though it is possible that the client may have its LOCK or OPEN request denied due to a conflicting lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ファイルシステムの移行後に新しいサーバーでロックを再利用できる機能を提供することをお勧めします。ただし、多くの場合、2つのサーバーがサーバースコープ値を共有しない場合は、そのような機能が利用できず、クライアントがLOCKまたはLOCKを持っている可能性がある場合でも、クライアントはロックを再取得する準備をする必要があります。ロックの競合のため、OPEN要求が拒否されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The consequences of having no facilities available to reclaim locks on the new server will depend on the type of environment. In some environments, such as the transition between read-only file systems, such denial of locks should not pose large difficulties in practice. When an attempt to re-establish a lock on a new server is denied, the client should treat the situation as if its original lock had been revoked. Note that when the lock is granted, the client cannot assume that no conflicting lock could have been granted in the interim. Where change attribute continuity is present, the client may check the change attribute to check for unwanted file modifications. Where even this is not available, and the file system is not read-only, a client may reasonably treat all pending locks as having been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいサーバーでロックを再利用する機能がない場合の結果は、環境のタイプによって異なります。読み取り専用ファイルシステム間の移行などの一部の環境では、このようなロックの拒否は、実際には大きな困難をもたらすことはありません。新しいサーバーでロックを再確立する試みが拒否された場合、クライアントは、元のロックが取り消されたかのように状況を処理する必要があります。ロックが許可されている場合、クライアントはその間に競合するロックが許可されていなかったと想定できないことに注意してください。変更属性の連続性が存在する場合、クライアントは変更属性をチェックして、不要なファイルの変更をチェックする場合があります。これも使用できず、ファイルシステムが読み取り専用でない場合、クライアントは保留中のすべてのロックを取り消されたものとして合理的に処理する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-7-7-1--Leases-and-File-System-Transitions">
11.7.7.1. Leases and File System Transitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.7.1. リースとファイルシステムの移行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of lease renewal, the client may not be submitting requests for a file system that has been transferred to another server. This can occur because of the lease renewal mechanism. The client renews the lease associated with all file systems when submitting a request on an associated session, regardless of the specific file system being referenced.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リースの更新の場合、クライアントは別のサーバーに転送されたファイルシステムのリクエストを送信していない可能性があります。これは、リースの更新メカニズムが原因で発生する可能性があります。クライアントは、参照されている特定のファイルシステムに関係なく、関連付けられたセッションで要求を送信すると、すべてのファイルシステムに関連付けられたリースを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order for the client to schedule renewal of its lease where there is locking state that may have been relocated to the new server, the client must find out about lease relocation before that lease expire. To accomplish this, the SEQUENCE operation will return the status bit SEQ4_STATUS_LEASE_MOVED if responsibility for any of the renewed locking state has been transferred to a new server. This will continue until the client receives an NFS4ERR_MOVED error for each of the file systems for which there has been locking state relocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが、新しいサーバーに再配置された可能性のあるロック状態があるリースの更新をスケジュールするには、リースが期限切れになる前にリースの再配置について調べる必要があります。これを達成するために、更新されたロック状態のいずれかの責任が新しいサーバーに転送された場合、SEQUENCE操作はステータスビットSEQ4_STATUS_LEASE_MOVEDを返します。これは、ロック状態の再配置が行われた各ファイルシステムのNFS4ERR_MOVEDエラーをクライアントが受信するまで続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client receives an SEQ4_STATUS_LEASE_MOVED indication from a server, for each file system of the server for which the client has locking state, the client should perform an operation. For simplicity, the client may choose to reference all file systems, but what is important is that it must reference all file systems for which there was locking state where that state has moved. Once the client receives an NFS4ERR_MOVED error for each such file system, the server will clear the SEQ4_STATUS_LEASE_MOVED indication. The client can terminate the process of checking file systems once this indication is cleared (but only if the client has received a reply for all outstanding SEQUENCE requests on all sessions it has with the server), since there are no others for which locking state has moved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがサーバーからSEQ4_STATUS_LEASE_MOVED指示を受信すると、クライアントがロック状態にあるサーバーのファイルシステムごとに、クライアントは操作を実行する必要があります。簡単にするために、クライアントはすべてのファイルシステムを参照することを選択できますが、重要なのは、状態が移動したロック状態があったすべてのファイルシステムを参照する必要があることです。クライアントがそのようなファイルシステムごとにNFS4ERR_MOVEDエラーを受信すると、サーバーはSEQ4_STATUS_LEASE_MOVEDの表示をクリアします。この表示がクリアされると、クライアントはファイルシステムをチェックするプロセスを終了できます（ただし、クライアントがサーバーとのすべてのセッションで未解決のSEQUENCE要求すべてに対する応答を受け取った場合のみ）。移動しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client may use GETATTR of the fs_status (or fs_locations_info) attribute on all of the file systems to get absence indications in a single (or a few) request(s), since absent file systems will not cause an error in this context. However, it still must do an operation that receives NFS4ERR_MOVED on each file system, in order to clear the SEQ4_STATUS_LEASE_MOVED indication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、すべてのファイルシステムでfs_status（またはfs_locations_info）属性のGETATTRを使用して、1つ（またはいくつか）のリクエストで不在通知を取得できます。これは、ファイルシステムが存在しないとこのコンテキストでエラーが発生しないためです。ただし、SEQ4_STATUS_LEASE_MOVEDの表示をクリアするために、各ファイルシステムでNFS4ERR_MOVEDを受信する操作を実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the set of file systems with transferred locking state has been determined, the client can follow the normal process to obtain the new server information (through the fs_locations and fs_locations_info attributes) and perform renewal of that lease on the new server, unless information in the fs_locations_info attribute shows that no state could have been transferred. If the server has not had state transferred to it transparently, the client will receive NFS4ERR_STALE_CLIENTID from the new server, as described above, and the client can then reclaim locks as is done in the event of server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック状態が転送されたファイルシステムのセットが決定されると、クライアントは通常のプロセスに従って（fs_locationsおよびfs_locations_info属性を介して）新しいサーバー情報を取得し、新しいサーバーでそのリースの更新を実行できます。 fs_locations_info属性は、状態を転送できなかったことを示しています。サーバーの状態が透過的に転送されなかった場合、クライアントは上記のように新しいサーバーからNFS4ERR_STALE_CLIENTIDを受け取り、サーバーに障害が発生した場合と同様にクライアントはロックを再利用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-7-7-2--Transitions-and-the-Leasetime-Attribute">
11.7.7.2. Transitions and the Lease_time Attribute
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.7.2. 遷移とLease_time属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order that the client may appropriately manage its lease in the case of a file system transition, the destination server must establish proper values for the lease_time attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムの移行時にクライアントがリースを適切に管理するために、宛先サーバーは、lease_time属性に適切な値を設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When state is transferred transparently, that state should include the correct value of the lease_time attribute. The lease_time attribute on the destination server must never be less than that on the source, since this would result in premature expiration of a lease granted by the source server. Upon transitions in which state is transferred transparently, the client is under no obligation to refetch the lease_time attribute and may continue to use the value previously fetched (on the source server).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態が透過的に転送される場合、その状態には、lease_time属性の正しい値が含まれている必要があります。ソースサーバーによって付与されたリースの期限切れが早まるため、宛先サーバーのlease_time属性は、ソースの属性よりも小さくしてはなりません。状態が透過的に転送される遷移では、クライアントは、lease_time属性を再フェッチする義務はなく、以前にフェッチした値（ソースサーバー上）を引き続き使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If state has not been transferred transparently, either because the associated servers are shown as having different eir_server_scope strings or because the client ID is rejected when presented to the new server, the client should fetch the value of lease_time on the new (i.e., destination) server, and use it for subsequent locking requests. However, the server must respect a grace period of at least as long as the lease_time on the source server, in order to ensure that clients have ample time to reclaim their lock before potentially conflicting non-reclaimed locks are granted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関連付けられたサーバーが異なるeir_server_scope文字列を持っていると表示されているため、またはクライアントIDが新しいサーバーに提示されたときに拒否されたために、状態が透過的に転送されなかった場合、クライアントは新しい（つまり、宛先）のlease_timeの値をフェッチする必要があります。サーバー、および後続のロック要求に使用します。ただし、サーバーは、少なくともソースサーバーのlease_timeと同じ長さの猶予期間を尊重する必要があります。これにより、競合する再利用されないロックが許可される前に、クライアントがロックを再利用する十分な時間を確保できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-7-8--Write-Verifiers-and-File-System-Transitions">
11.7.8. Write Verifiers and File System Transitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.8. ベリファイアとファイルシステムの移行の書き込み
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a file system transition, the two file systems may be clustered in the handling of unstably written data. When this is the case, and the two file systems belong to the same write-verifier class, write verifiers returned from one system may be compared to those returned by the other and superfluous writes avoided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムの移行では、2つのファイルシステムがクラスター化され、不安定に書き込まれたデータを処理する場合があります。この場合、2つのファイルシステムが同じ書き込みベリファイアクラスに属していると、1つのシステムから返された書き込みベリファイアが、他のシステムから返されたものと比較され、余分な書き込みが回避されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When two file systems belong to different write-verifier classes, any verifier generated by one must not be compared to one provided by the other. Instead, it should be treated as not equal even when the values are identical.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのファイルシステムが異なる書き込みベリファイアクラスに属している場合、一方が生成したベリファイアを、もう一方が提供するベリファイアと比較してはなりません。代わりに、値が同じであっても等しくないものとして処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-7-9--Readdir-Cookies-and-Verifiers-and-File-System-Transitions">
11.7.9. Readdir Cookies and Verifiers and File System Transitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.9. Readdir Cookieとベリファイア、およびファイルシステムの移行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a file system transition, the two file systems may be consistent in their handling of READDIR cookies and verifiers. When this is the case, and the two file systems belong to the same readdir class, READDIR cookies and verifiers from one system may be recognized by the other and READDIR operations started on one server may be validly continued on the other, simply by presenting the cookie and verifier returned by a READDIR operation done on the first file system to the second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムの移行では、2つのファイルシステムのREADDIRクッキーとベリファイアの処理に一貫性がある場合があります。この場合、2つのファイルシステムが同じreaddirクラスに属していると、一方のシステムからのREADDIR Cookieとベリファイアが他方で認識され、一方のサーバーで開始されたREADDIR操作が他方のサーバーで有効に継続されます。最初のファイルシステムで実行されたREADDIR操作によって2番目のファイルシステムに返されたcookieとベリファイア。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When two file systems belong to different readdir classes, any READDIR cookie and verifier generated by one is not valid on the second, and must not be presented to that server by the client. The client should act as if the verifier was rejected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのファイルシステムが異なるreaddirクラスに属している場合、1つで生成されたREADDIR Cookieとベリファイアは2番目では無効であり、クライアントからサーバーに提示されてはなりません。クライアントは、ベリファイアが拒否されたかのように動作する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-7-10--File-System-Data-and-File-System-Transitions">
11.7.10. File System Data and File System Transitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.10. ファイルシステムデータとファイルシステムの移行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When multiple replicas exist and are used simultaneously or in succession by a client, applications using them will normally expect that they contain either the same data or data that is consistent with the normal sorts of changes that are made by other clients updating the data of the file system (with metadata being the same to the degree indicated by the fs_locations_info attribute). However, when multiple file systems are presented as replicas of one another, the precise relationship between the data of one and the data of another is not, as a general matter, specified by the NFSv4.1 protocol. It is quite possible to present as replicas file systems where the data of those file systems is sufficiently different that some applications have problems dealing with the transition between replicas. The namespace will typically be constructed so that applications can choose an appropriate level of support, so that in one position in the namespace a varied set of replicas will be listed, while in another only those that are up-to-date may be considered replicas. The protocol does define four special cases of the relationship among replicas to be specified by the server and relied upon by clients:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のレプリカが存在し、同時にまたは連続してクライアントによって使用される場合、それらを使用するアプリケーションは通常、同じデータ、または他のクライアントがデータのデータを更新することによって行われる通常の種類の変更と一致するデータのいずれかを含むことを期待します。ファイルシステム（メタデータはfs_locations_info属性で示される程度に同じです）。ただし、複数のファイルシステムが相互のレプリカとして提供される場合、1つのデータと別のデータの正確な関係は、一般的な問題として、NFSv4.1プロトコルでは指定されていません。一部のアプリケーションがレプリカ間の移行を処理する問題を抱えているほど、ファイルシステムのデータが十分に異なるファイルシステムをレプリカとして提示することは十分に可能です。名前空間は通常、アプリケーションが適切なレベルのサポートを選択できるように構築されます。これにより、名前空間の1つの位置にさまざまなレプリカのセットがリストされ、別の位置では最新のレプリカのみがレプリカと見なされます。 。プロトコルは、サーバーによって指定され、クライアントによって信頼されるレプリカ間の関係の4つの特別なケースを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When multiple server addresses correspond to the same actual server, as indicated by a common so_major_id field within the eir_server_owner field returned by EXCHANGE_ID, the client may depend on the fact that changes to data, metadata, or locks made on one file system are immediately reflected on others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o EXCHANGE_IDによって返されるeir_server_ownerフィールド内の共通のso_major_idフィールドによって示されるように、複数のサーバーアドレスが同じ実際のサーバーに対応する場合、クライアントは、1つのファイルシステムで行われたデータ、メタデータ、またはロックへの変更がすぐに反映されるという事実に依存する場合があります他の人に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When multiple replicas exist and are used simultaneously by a client (see the FSLIB4_CLSIMUL definition within fs_locations_info), they must designate the same data. Where file systems are writable, a change made on one instance must be visible on all instances, immediately upon the earlier of the return of the modifying requester or the visibility of that change on any of the associated replicas. This allows a client to use these replicas simultaneously without any special adaptation to the fact that there are multiple replicas. In this case, locks (whether share reservations or byte-range locks) and delegations obtained on one replica are immediately reflected on all replicas, even though these locks will be managed under a set of client IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 複数のレプリカが存在し、クライアントによって同時に使用される場合（fs_locations_info内のFSLIB4_CLSIMUL定義を参照）、それらは同じデータを指定する必要があります。ファイルシステムが書き込み可能である場合、1つのインスタンスで行われた変更は、変更リクエスタが返されるか、関連付けられたレプリカでその変更が可視化される直前に、すべてのインスタンスで可視である必要があります。これにより、クライアントは、複数のレプリカがあるという事実に特別な調整を加えることなく、これらのレプリカを同時に使用できます。この場合、1つのレプリカで取得されたロック（共有予約またはバイト範囲ロック）と委任は、これらのロックがクライアントIDのセットの下で管理されていても、すべてのレプリカにすぐに反映されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When one replica is designated as the successor instance to another existing instance after return NFS4ERR_MOVED (i.e., the case of migration), the client may depend on the fact that all changes written to stable storage on the original instance are written to stable storage of the successor (uncommitted writes are dealt with in Section 11.7.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFS4ERR_MOVED（つまり、移行の場合）が返された後、1つのレプリカが別の既存のインスタンスの後続インスタンスとして指定されている場合、クライアントは、元のインスタンスの安定したストレージに書き込まれたすべての変更が、後継者（コミットされていない書き込みはセクション11.7.8で処理されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Where a file system is not writable but represents a read-only copy (possibly periodically updated) of a writable file system, clients have similar requirements with regard to the propagation of updates. They may need a guarantee that any change visible on the original file system instance must be immediately visible on any replica before the client transitions access to that replica, in order to avoid any possibility that a client, in effecting a transition to a replica, will see any reversion in file system state. The specific means of this guarantee varies based on the value of the fss_type field that is reported as part of the fs_status attribute (see Section 11.11). Since these file systems are presumed to be unsuitable for simultaneous use, there is no specification of how locking is handled; in general, locks obtained on one file system will be separate from those on others. Since these are going to be read-only file systems, this is not expected to pose an issue for clients or applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルシステムが書き込み可能ではないが、書き込み可能なファイルシステムの読み取り専用のコピー（定期的に更新される可能性がある）を表す場合、クライアントには、更新の伝達に関して同様の要件があります。クライアントがレプリカに移行する前に、クライアントがそのレプリカへのアクセスを移行する前に、元のファイルシステムインスタンスに表示される変更がすべてのレプリカにすぐに表示されることを保証する必要がある場合があります。ファイルシステムの状態の復元を確認します。この保証の具体的な方法は、fs_status属性の一部として報告されるfss_typeフィールドの値に基づいて異なります（セクション11.11を参照）。これらのファイルシステムは同時使用には適していないと推定されるため、ロックの処理方法の指定はありません。一般に、1つのファイルシステムで取得されたロックは、他のロックから分離されます。これらは読み取り専用のファイルシステムになるため、クライアントやアプリケーションに問題が発生することは想定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-8--Effecting-File-System-Referrals">
11.8. Effecting File System Referrals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.8. ファイルシステムの参照に影響を与える
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Referrals are effected when an absent file system is encountered and one or more alternate locations are made available by the fs_locations or fs_locations_info attributes. The client will typically get an NFS4ERR_MOVED error, fetch the appropriate location information, and proceed to access the file system on a different server, even though it retains its logical position within the original namespace. Referrals differ from migration events in that they happen only when the client has not previously referenced the file system in question (so there is nothing to transition). Referrals can only come into effect when an absent file system is encountered at its root.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参照は、存在しないファイルシステムが検出され、fs_locationsまたはfs_locations_info属性によって1つ以上の代替の場所が利用可能になったときに影響を受けます。クライアントは通常、NFS4ERR_MOVEDエラーを取得し、適切な場所情報をフェッチして、元の名前空間内の論理的な位置を保持していても、別のサーバー上のファイルシステムへのアクセスを続行します。紹介は、クライアントが以前に問題のファイルシステムを参照していない場合にのみ発生するという点で移行イベントとは異なります（したがって、移行するものはありません）。参照は、ルートにファイルシステムがない場合にのみ有効になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The examples given in the sections below are somewhat artificial in that an actual client will not typically do a multi-component look up, but will have cached information regarding the upper levels of the name hierarchy. However, these example are chosen to make the required behavior clear and easy to put within the scope of a small number of requests, without getting unduly into details of how specific clients might choose to cache things.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のセクションで示す例は、実際のクライアントが通常はマルチコンポーネントの検索を行わないが、名前階層の上位レベルに関する情報をキャッシュしているという点で、多少人為的です。ただし、これらの例は、特定のクライアントがキャッシュする方法の詳細に過度に入ることなく、必要な動作を明確にし、少数の要求の範囲内に簡単に配置できるように選択されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-8-1--Referral-Example-LOOKUP">
11.8.1. Referral Example (LOOKUP)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.8.1. 紹介例（LOOKUP）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let us suppose that the following COMPOUND is sent in an environment in which /this/is/the/path is absent from the target server. This may be for a number of reasons. It may be that the file system has moved, or it may be that the target server is functioning mainly, or solely, to refer clients to the servers on which various file systems are located.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のCOMPOUNDが、ターゲットサーバーに/ this / is / the / pathがない環境で送信されたと仮定します。これにはいくつかの理由が考えられます。ファイルシステムが移動したか、ターゲットサーバーが主に、または単独で、さまざまなファイルシステムが配置されているサーバーをクライアントに参照するように機能している可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP「これ」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ルックアップ「the」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;path&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;パス&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETATTR (fsid, fileid, size, time_modify)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETATTR（fsid、fileid、size、time_modify）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Under the given circumstances, the following will be the result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与えられた状況下では、次の結果になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH --&gt; NFS_OK. The current fh is now the root of the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH-&gt; NFS_OK。現在のfhが疑似fsのルートになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34; --&gt; NFS_OK. The current fh is for /this and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34;-&gt; NFS_OK。現在のfhは/ this用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34; --&gt; NFS_OK. The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;-&gt; NFS_OK。現在のfhは/ this / is用であり、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34; --&gt; NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34;-&gt; NFS_OK。現在のfhは/ this / is / the用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;path&#34; --&gt; NFS_OK. The current fh is for /this/is/the/path and is within a new, absent file system, but ... the client will never see the value of that fh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;パス&#34;-&gt; NFS_OK。現在のfhは/ this / is / the / path用であり、新しく存在しないファイルシステム内にありますが、クライアントはそのfhの値を見ることができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETFH --&gt; NFS4ERR_MOVED. Fails because current fh is in an absent file system at the start of the operation, and the specification makes no exception for GETFH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETFH-&gt; NFS4ERR_MOVED。操作の開始時に現在のfhが存在しないファイルシステムにあり、仕様ではGETFHの例外が発生しないため、失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETATTR (fsid, fileid, size, time_modify). Not executed because the failure of the GETFH stops processing of the COMPOUND.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GETATTR（fsid、fileid、サイズ、time_modify）。 GETFHの失敗によりCOMPOUNDの処理が停止するため、実行されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given the failure of the GETFH, the client has the job of determining the root of the absent file system and where to find that file system, i.e., the server and path relative to that server&#39;s root fh. Note that in this example, the client did not obtain filehandles and attribute information (e.g., fsid) for the intermediate directories, so that it would not be sure where the absent file system starts. It could be the case, for example, that /this/is/the is the root of the moved file system and that the reason that the look up of &#34;path&#34; succeeded is that the file system was not absent on that operation but was moved between the last LOOKUP and the GETFH (since COMPOUND is not atomic). Even if we had the fsids for all of the intermediate directories, we could have no way of knowing that /this/is/the/path was the root of a new file system, since we don&#39;t yet have its fsid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETFHが失敗した場合、クライアントは、存在しないファイルシステムのルートと、そのファイルシステムを見つける場所、つまり、サーバーとそのサーバーのルートからの相対パスを決定する役割を果たします。この例では、クライアントは中間ディレクトリのファイルハンドルと属性情報（fsidなど）を取得しなかったため、存在しないファイルシステムがどこから始まるのかはわかりません。たとえば、/ this / is / theが移動されたファイルシステムのルートであり、「パス」の検索が成功した理由は、ファイルシステムがその操作に存在しなかったが、最後のLOOKUPとGETFHの間で移動しました（COMPOUNDはアトミックではないため）。すべての中間ディレクトリにfsidがあったとしても、まだfsidがないため、/ this / is / the / pathが新しいファイルシステムのルートであることを知る方法がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to get the necessary information, let us re-send the chain of LOOKUPs with GETFHs and GETATTRs to at least get the fsids so we can be sure where the appropriate file system boundaries are. The client could choose to get fs_locations_info at the same time but in most cases the client will have a good guess as to where file system boundaries are (because of where NFS4ERR_MOVED was, and was not, received) making fetching of fs_locations_info unnecessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必要な情報を取得するために、GETFHおよびGETATTRを使用してLOOKUPのチェーンを再送信し、少なくともfsidを取得して、適切なファイルシステム境界がどこにあるかを確認できるようにします。クライアントは同時にfs_locations_infoを取得することを選択できますが、ほとんどの場合、クライアントはファイルシステムの境界がどこにあるか（NFS4ERR_MOVEDが受信された場所と受信されなかった場所のため）を正確に推測し、fs_locations_infoのフェッチを不要にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP01:  PUTROOTFH --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Current fh is root of pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfhは疑似fsのルートです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP02:  GETATTR(fsid) --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Just for completeness. Normally, clients will know the fsid of the pseudo-fs as soon as they establish communication with a server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 完全を期すために。通常、クライアントは、サーバーとの通信を確立するとすぐに、疑似fsのfsidを認識します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP03:  LOOKUP &#34;this&#34; --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP04:  GETATTR(fsid) --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Get current fsid to see where file system boundaries are. The fsid will be that for the pseudo-fs in this example, so no boundary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfsidを取得して、ファイルシステムの境界がどこにあるかを確認します。 fsidは、この例の疑似fsのfsidになるため、境界はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP05:  GETFH --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Current fh is for /this and is within pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfhは/ this用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP06:  LOOKUP &#34;is&#34; --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Current fh is for /this/is and is within pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfhは/ this / is用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP07:  GETATTR(fsid) --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Get current fsid to see where file system boundaries are. The fsid will be that for the pseudo-fs in this example, so no boundary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfsidを取得して、ファイルシステムの境界がどこにあるかを確認します。 fsidは、この例の疑似fsのfsidになるため、境界はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP08:  GETFH --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Current fh is for /this/is and is within pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfhは/ this / is用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP09:  LOOKUP &#34;the&#34; --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Current fh is for /this/is/the and is within pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfhは/ this / is / the用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP10:  GETATTR(fsid) --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Get current fsid to see where file system boundaries are. The fsid will be that for the pseudo-fs in this example, so no boundary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfsidを取得して、ファイルシステムの境界がどこにあるかを確認します。 fsidは、この例の疑似fsのfsidになるため、境界はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP11:  GETFH --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Current fh is for /this/is/the and is within pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfhは/ this / is / the用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP12:  LOOKUP &#34;path&#34; --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Current fh is for /this/is/the/path and is within a new, absent file system, but ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 現在のfhは/ this / is / the / path用であり、新しく存在しないファイルシステム内にありますが...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The client will never see the value of that fh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- クライアントはそのfhの値を見ることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP13:  GETATTR(fsid, fs_locations_info) --&gt; NFS_OK
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- We are getting the fsid to know where the file system boundaries are. In this operation, the fsid will be different than that of the parent directory (which in turn was retrieved in OP10). Note that the fsid we are given will not necessarily be preserved at the new location. That fsid might be different, and in fact the fsid we have for this file system might be a valid fsid of a different file system on that new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- ファイルシステムの境界がどこにあるかをfsidに知らせています。この操作では、fsidは（OP10で取得された）親ディレクトリのfsidとは異なります。指定されたfsidは、必ずしも新しい場所に保存されるとは限りません。そのfsidは異なる可能性があり、実際、このファイルシステム用に持っているfsidは、その新しいサーバー上の異なるファイルシステムの有効なfsidである可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 - In this particular case, we are pretty sure anyway that what has moved is /this/is/the/path rather than /this/is/the since we have the fsid of the latter and it is that of the pseudo-fs, which presumably cannot move. However, in other examples, we might not have this kind of information to rely on (e.g., /this/is/the might be a non-pseudo file system separate from /this/is/the/path), so we need to have other reliable source information on the boundary of the file system that is moved. If, for example, the file system /this/is had moved, we would have a case of migration rather than referral, and once the boundaries of the migrated file system was clear we could fetch fs_locations_info.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
-この特定のケースでは、移動したものが/ this / is / theではなく/ this / is / the / pathであると確信しています。後者のfsidと疑似fsのfsidがあるためです。おそらく移動できません。ただし、他の例では、この種の情報に依存できない場合があります（たとえば、/ this / is / theは/ this / is / the / pathとは別の疑似ファイルシステムである可能性があります）。移動するファイルシステムの境界に他の信頼できるソース情報がある。たとえば、ファイルシステム/ this / isが移動された場合、参照ではなく移行のケースが発生し、移行されたファイルシステムの境界が明確になると、fs_locations_infoをフェッチできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- We are fetching fs_locations_info because the fact that we got an NFS4ERR_MOVED at this point means that it is most likely that this is a referral and we need the destination. Even if it is the case that /this/is/the is a file system that has migrated, we will still need the location information for that file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- この時点でNFS4ERR_MOVEDを取得したという事実は、これが参照であり、宛先が必要である可能性が最も高いため、fs_locations_infoをフェッチしています。 / this / is / theが移行したファイルシステムである場合でも、そのファイルシステムの場所情報が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OP14:  GETFH --&gt; NFS4ERR_MOVED
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Fails because current fh is in an absent file system at the start of the operation, and the specification makes no exception for GETFH. Note that this means the server will never send the client a filehandle from within an absent file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 操作の開始時に現在のfhが存在しないファイルシステムにあり、仕様ではGETFHの例外が発生しないため、失敗します。これは、存在しないファイルシステム内からサーバーがクライアントにファイルハンドルを送信しないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given the above, the client knows where the root of the absent file system is (/this/is/the/path) by noting where the change of fsid occurred (between &#34;the&#34; and &#34;path&#34;). The fs_locations_info attribute also gives the client the actual location of the absent file system, so that the referral can proceed. The server gives the client the bare minimum of information about the absent file system so that there will be very little scope for problems of conflict between information sent by the referring server and information of the file system&#39;s home. No filehandles and very few attributes are present on the referring server, and the client can treat those it receives as transient information with the function of enabling the referral.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の場合、クライアントは、fsidの変更が発生した場所（「the」と「path」の間）に注目することにより、存在しないファイルシステムのルートがどこにあるか（/ this / is / the / path）を認識します。 fs_locations_info属性は、クライアントに不在のファイルシステムの実際の場所も提供するため、参照を続行できます。サーバーは、存在しないファイルシステムに関する最小限の情報をクライアントに提供するため、参照サーバーから送信された情報とファイルシステムのホームの情報との間の競合の問題が生じる可能性はほとんどありません。参照サーバーにはファイルハンドルはなく、属性はほとんどありません。クライアントは、参照を有効にする機能を使用して、受け取った属性を一時的な情報として扱うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-8-2--Referral-Example-READDIR">
11.8.2. Referral Example (READDIR)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.8.2. 紹介例（READDIR）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another context in which a client may encounter referrals is when it does a READDIR on a directory in which some of the sub-directories are the roots of absent file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが紹介に遭遇する可能性があるもう1つのコンテキストは、サブディレクトリの一部が存在しないファイルシステムのルートであるディレクトリでREADDIRを実行する場合です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suppose such a directory is read as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのようなディレクトリが次のように読み取られると仮定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP「これ」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ルックアップ「the」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o READDIR (fsid, size, time_modify, mounted_on_fileid) In this case, because rdattr_error is not requested, fs_locations_info is not requested, and some of the attributes cannot be provided, the result will be an NFS4ERR_MOVED error on the READDIR, with the detailed results as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
o READDIR（fsid、size、time_modify、mounted_on_fileid）この場合、rdattr_errorは要求されず、fs_locations_infoは要求されず、一部の属性が提供されないため、結果はREADDIRでNFS4ERR_MOVEDエラーとなり、詳細な結果が表示されます。次のように：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH --&gt; NFS_OK. The current fh is at the root of the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH-&gt; NFS_OK。現在のfhは疑似fsのルートにあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34; --&gt; NFS_OK. The current fh is for /this and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34;-&gt; NFS_OK。現在のfhは/ this用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34; --&gt; NFS_OK. The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;-&gt; NFS_OK。現在のfhは/ this / is用であり、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34; --&gt; NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34;-&gt; NFS_OK。現在のfhは/ this / is / the用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR (fsid, size, time_modify, mounted_on_fileid) --&gt; NFS4ERR_MOVED. Note that the same error would have been returned if /this/is/the had migrated, but it is returned because the directory contains the root of an absent file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR（fsid、サイズ、time_modify、mounted_on_fileid）-&gt; NFS4ERR_MOVED。 / this / is / theが移行された場合も同じエラーが返されますが、存在しないファイルシステムのルートがディレクトリに含まれているために返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So now suppose that we re-send with rdattr_error:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それでは、rdattr_errorで再送信するとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP「これ」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ルックアップ「the」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR (rdattr_error, fsid, size, time_modify, mounted_on_fileid)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR（rdattr_error、fsid、size、time_modify、mounted_on_fileid）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results will be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH --&gt; NFS_OK. The current fh is at the root of the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH-&gt; NFS_OK。現在のfhは疑似fsのルートにあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34; --&gt; NFS_OK. The current fh is for /this and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34;-&gt; NFS_OK。現在のfhは/ this用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34; --&gt; NFS_OK. The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;-&gt; NFS_OK。現在のfhは/ this / is用であり、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34; --&gt; NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34;-&gt; NFS_OK。現在のfhは/ this / is / the用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR (rdattr_error, fsid, size, time_modify, mounted_on_fileid) --&gt; NFS_OK. The attributes for directory entry with the component named &#34;path&#34; will only contain rdattr_error with the value NFS4ERR_MOVED, together with an fsid value and a value for mounted_on_fileid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR（rdattr_error、fsid、size、time_modify、mounted_on_fileid）-&gt; NFS_OK。 「path」という名前のコンポーネントを持つディレクトリエントリの属性には、fsid値とMounted_on_fileidの値とともに、値NFS4ERR_MOVEDのrdattr_errorのみが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So suppose we do another READDIR to get fs_locations_info (although we could have used a GETATTR directly, as in Section 11.8.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、fs_locations_infoを取得するために別のREADDIRを実行するとします（11.8.1のようにGETATTRを直接使用することもできます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP「これ」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ルックアップ「the」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR (rdattr_error, fs_locations_info, mounted_on_fileid, fsid, size, time_modify)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR（rdattr_error、fs_locations_info、mounted_on_fileid、fsid、size、time_modify）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results would be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH --&gt; NFS_OK. The current fh is at the root of the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTROOTFH-&gt; NFS_OK。現在のfhは疑似fsのルートにあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34; --&gt; NFS_OK. The current fh is for /this and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;this&#34;-&gt; NFS_OK。現在のfhは/ this用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34; --&gt; NFS_OK. The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;is&#34;-&gt; NFS_OK。現在のfhは/ this / is用であり、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34; --&gt; NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUP &#34;the&#34;-&gt; NFS_OK。現在のfhは/ this / is / the用で、疑似fs内にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR (rdattr_error, fs_locations_info, mounted_on_fileid, fsid, size, time_modify) --&gt; NFS_OK. The attributes will be as shown below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o READDIR（rdattr_error、fs_locations_info、mounted_on_fileid、fsid、size、time_modify）-&gt; NFS_OK。属性は以下のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attributes for the directory entry with the component named &#34;path&#34; will only contain:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「パス」という名前のコンポーネントを持つディレクトリエントリの属性には、次の情報のみが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o rdattr_error (value: NFS_OK)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o rdattr_error（値：NFS_OK）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o fs_locations_info
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o fs_locations_info
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mounted_on_fileid (value: unique fileid within referring file system)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Mounted_on_fileid（値：参照ファイルシステム内の一意のファイルID）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o fsid (value: unique value within referring server)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o fsid（値：参照サーバー内の一意の値）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attributes for entry &#34;path&#34; will not contain size or time_modify because these attributes are not available within an absent file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エントリ「パス」の属性には、サイズやtime_modifyは含まれません。これらの属性は、存在しないファイルシステム内では使用できないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-9--The-Attribute-fslocations">
11.9. The Attribute fs_locations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.9. 属性fs_locations
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations attribute is structured in the following way:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations属性は、次のように構造化されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fs_location4 {
           utf8str_cis     server&lt;&gt;;
           pathname4       rootpath;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fs_locations4 {
           pathname4       fs_root;
           fs_location4    locations&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_location4 data type is used to represent the location of a file system by providing a server name and the path to the root of the file system within that server&#39;s namespace. When a set of servers have corresponding file systems at the same path within their namespaces, an array of server names may be provided. An entry in the server array is a UTF-8 string and represents one of a traditional DNS host name, IPv4 address, IPv6 address, or a zero-length string. An IPv4 or IPv6 address is represented as a universal address (see Section 3.3.9 and [15]), minus the netid, and either with or without the trailing &#34;.p1.p2&#34; suffix that represents the port number. If the suffix is omitted, then the default port, 2049, SHOULD be assumed. A zero-length string SHOULD be used to indicate the current address being used for the RPC call. It is not a requirement that all servers that share the same rootpath be listed in one fs_location4 instance. The array of server names is provided for convenience. Servers that share the same rootpath may also be listed in separate fs_location4 entries in the fs_locations attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_location4データ型は、サーバー名とそのサーバーの名前空間内のファイルシステムのルートへのパスを提供することにより、ファイルシステムの場所を表すために使用されます。一連のサーバーの名前空間内の同じパスに対応するファイルシステムがある場合、サーバー名の配列を指定できます。サーバー配列のエントリはUTF-8文字列であり、従来のDNSホスト名、IPv4アドレス、IPv6アドレス、または長さゼロの文字列の1つを表します。 IPv4またはIPv6アドレスは、netidを除いたユニバーサルアドレス（セクション3.3.9および[15]を参照）として表され、ポート番号を表す末尾の &#34;.p1.p2&#34;サフィックスの有無にかかわらず。サフィックスを省略すると、デフォルトのポート2049が想定されます（SHOULD）。 RPC呼び出しに使用されている現在のアドレスを示すには、長さがゼロの文字列を使用する必要があります（SHOULD）。同じrootpathを共有するすべてのサーバーを1つのfs_location4インスタンスにリストする必要はありません。サーバー名の配列は、便宜上提供されています。同じルートパスを共有するサーバーは、fs_locations属性の個別のfs_location4エントリにリストされる場合もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The fs_locations4 data type and fs_locations attribute contain an array of such locations. Since the namespace of each server may be constructed differently, the &#34;fs_root&#34; field is provided. The path represented by fs_root represents the location of the file system in the current server&#39;s namespace, i.e., that of the server from which the fs_locations attribute was obtained. The fs_root path is meant to aid the client by clearly referencing the root of the file system whose locations are being reported, no matter what object within the current file system the current filehandle designates. The fs_root is simply the pathname the client used to reach the object on the current server (i.e., the object to which the fs_locations attribute applies).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
fs_locations4データ型とfs_locations属性には、そのような場所の配列が含まれています。各サーバーの名前空間は異なる方法で構築される可能性があるため、「fs_root」フィールドが提供されています。 fs_rootで表されるパスは、現在のサーバーの名前空間内のファイルシステムの場所、つまり、fs_locations属性の取得元のサーバーの場所を表します。 fs_rootパスは、現在のファイルハンドルが指定する現在のファイルシステム内のオブジェクトに関係なく、場所が報告されているファイルシステムのルートを明確に参照することにより、クライアントを支援することを目的としています。 fs_rootは、クライアントが現在のサーバー上のオブジェクト（つまり、fs_locations属性が適用されるオブジェクト）に到達するために使用したパス名です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the fs_locations attribute is interrogated and there are no alternate file system locations, the server SHOULD return a zero-length array of fs_location4 structures, together with a valid fs_root.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations属性が調べられ、代替ファイルシステムの場所がない場合、サーバーは、有効なfs_rootとともに、fs_location4構造体の長さがゼロの配列を返す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example, suppose there is a replicated file system located at two servers (servA and servB). At servA, the file system is located at path /a/b/c. At, servB the file system is located at path /x/y/z. If the client were to obtain the fs_locations value for the directory at /a/b/c/d, it might not necessarily know that the file system&#39;s root is located in servA&#39;s namespace at /a/b/c. When the client switches to servB, it will need to determine that the directory it first referenced at servA is now represented by the path /x/y/z/d on servB. To facilitate this, the fs_locations attribute provided by servA would have an fs_root value of /a/b/c and two entries in fs_locations. One entry in fs_locations will be for itself (servA) and the other will be for servB with a path of /x/y/z. With this information, the client is able to substitute /x/y/z for the /a/b/c at the beginning of its access path and construct /x/y/z/d to use for the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例として、2つのサーバー（servAとservB）に複製されたファイルシステムがあるとします。 servAでは、ファイルシステムはパス/ a / b / cにあります。 servBでは、ファイルシステムはパス/ x / y / zにあります。クライアントが/ a / b / c / dにあるディレクトリのfs_locations値を取得する場合、ファイルシステムのルートが/ a / b / cにあるservAのネームスペースにあることを必ずしも認識していない場合があります。クライアントがservBに切り替わるとき、servAで最初に参照されたディレクトリがservBのパス/ x / y / z / dで表されていることを確認する必要があります。これを容易にするために、servAによって提供されるfs_locations属性は、fs_root値が/ a / b / cであり、fs_locationsに2つのエントリがあります。 fs_locationsの1つのエントリはそれ自体（servA）用であり、もう1つは/ x / y / zのパスを持つservB用です。この情報を使用して、クライアントはアクセスパスの先頭にある/ a / b / cの代わりに/ x / y / zを使用して、新しいサーバーで使用する/ x / y / z / dを作成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that there is no requirement that the number of components in each rootpath be the same; there is no relation between the number of components in rootpath or fs_root, and none of the components in a rootpath and fs_root have to be the same. In the above example, we could have had a third element in the locations array, with server equal to &#34;servC&#34; and rootpath equal to &#34;/I/II&#34;, and a fourth element in locations with server equal to &#34;servD&#34; and rootpath equal to &#34;/aleph/beth/gimel/daleth/he&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各rootpathのコンポーネント数が同じである必要はないことに注意してください。 rootpathまたはfs_rootのコンポーネント数の間に関係はなく、rootpathとfs_rootのコンポーネントは同じである必要はありません。上記の例では、locations配列に3番目の要素があり、serverが「servC」、rootpathが「/ I / II」に等しく、4番目の要素が、serverが「servD」、rootpathに等しい場合があります。 「/ aleph / beth / gimel / daleth / he」に等しい。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The relationship between fs_root to a rootpath is that the client replaces the pathname indicated in fs_root for the current server for the substitute indicated in rootpath for the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_rootとrootpathの関係は、クライアントが現在のサーバーのfs_rootに示されているパス名を、新しいサーバーのrootpathに示されている代わりに置き換えることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 For an example of a referred or migrated file system, suppose there is a file system located at serv1. At serv1, the file system is located at /az/buky/vedi/glagoli. The client finds that object at glagoli has migrated (or is a referral). The client gets the fs_locations attribute, which contains an fs_root of /az/buky/vedi/ glagoli, and one element in the locations array, with server equal to serv2, and rootpath equal to /izhitsa/fita. The client replaces /az/ buky/vedi/glagoli with /izhitsa/fita, and uses the latter pathname on serv2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
参照または移行されたファイルシステムの例として、serv1にファイルシステムがあるとします。 serv1では、ファイルシステムは/ az / buky / vedi / glagoliにあります。クライアントは、glagoliのオブジェクトが移行した（または紹介である）ことを検出しました。クライアントはfs_locations属性を取得します。これには、/ az / buky / vedi / glagoliのfs_rootと、locations配列の1つの要素が含まれます。サーバーはserv2、ルートパスは/ izhitsa / fitaです。クライアントは/ az / buky / vedi / glagoliを/ izhitsa / fitaに置き換え、serv2で後者のパス名を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, the server MUST return an fs_root that is equal to the path the client used to reach the object to which the fs_locations attribute applies. Otherwise, the client cannot determine the new path to use on the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、サーバーはfs_locations属性が適用されるオブジェクトに到達するためにクライアントが使用したパスに等しいfs_rootを返さなければなりません（MUST）。そうしないと、クライアントは新しいサーバーで使用する新しいパスを決定できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the fs_locations attribute lacks information defining various attributes of the various file system choices presented, it SHOULD only be interrogated and used when fs_locations_info is not available. When fs_locations is used, information about the specific locations should be assumed based on the following rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations属性には、提示されたさまざまなファイルシステムの選択肢のさまざまな属性を定義する情報がないため、fs_locations_infoが使用できない場合にのみ問い合わせて使用​​する必要があります。 fs_locationsを使用する場合、特定の場所に関する情報は、次のルールに基づいて想定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following rules are general and apply irrespective of the context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のルールは一般的なものであり、状況に関係なく適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All listed file system instances should be considered as of the same handle class, if and only if, the current fh_expire_type attribute does not include the FH4_VOL_MIGRATION bit. Note that in the case of referral, filehandle issues do not apply since there can be no filehandles known within the current file system, nor is there any access to the fh_expire_type attribute on the referring (absent) file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o リストされているすべてのファイルシステムインスタンスは、現在のfh_expire_type属性にFH4_VOL_MIGRATIONビットが含まれていない場合に限り、同じハンドルクラスと見なされます。参照の場合、現在のファイルシステム内に既知のファイルハンドルがないため、参照元の（存在しない）ファイルシステムのfh_expire_type属性にアクセスできないため、ファイルハンドルの問題は適用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All listed file system instances should be considered as of the same fileid class if and only if the fh_expire_type attribute indicates persistent filehandles and does not include the FH4_VOL_MIGRATION bit. Note that in the case of referral, fileid issues do not apply since there can be no fileids known within the referring (absent) file system, nor is there any access to the fh_expire_type attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o リストされたすべてのファイルシステムインスタンスは、fh_expire_type属性が永続的なファイルハンドルを示し、FH4_VOL_MIGRATIONビットを含まない場合に限り、同じfileidクラスのものと見なされます。参照の場合、参照する（存在しない）ファイルシステム内で既知のfileidが存在せず、fh_expire_type属性へのアクセスもないため、fileidの問題は適用されないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All file system instances servers should be considered as of different change classes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o すべてのファイルシステムインスタンスサーバーは、さまざまな変更クラスと見なす必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For other class assignments, handling of file system transitions depends on the reasons for the transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のクラス割り当ての場合、ファイルシステムの移行の処理は、移行の理由によって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the transition is due to migration, that is, the client was directed to a new file system after receiving an NFS4ERR_MOVED error, the target should be treated as being of the same write-verifier class as the source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 移行が移行によるものである場合、つまり、NFS4ERR_MOVEDエラーを受信した後にクライアントが新しいファイルシステムに転送された場合、ターゲットはソースと同じ書き込みベリファイアクラスのものとして処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the transition is due to failover to another replica, that is, the client selected another replica without receiving an NFS4ERR_MOVED error, the target should be treated as being of a different write-verifier class from the source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 移行の原因が別のレプリカへのフェイルオーバーである場合、つまりクライアントがNFS4ERR_MOVEDエラーを受信せずに別のレプリカを選択した場合、ターゲットはソースとは異なる書き込みベリファイアクラスであるものとして扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The specific choices reflect typical implementation patterns for failover and controlled migration, respectively. Since other choices are possible and useful, this information is better obtained by using fs_locations_info. When a server implementation needs to communicate other choices, it MUST support the fs_locations_info attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体的な選択は、それぞれフェイルオーバーと制御された移行の典型的な実装パターンを反映しています。他の選択も可能で便利なので、この情報はfs_locations_infoを使用して取得する方が適切です。サーバー実装が他の選択を伝達する必要があるとき、それはfs_locations_info属性をサポートしなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 21 for a discussion on the recommendations for the security flavor to be used by any GETATTR operation that requests the &#34;fs_locations&#34; attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「fs_locations」属性を要求するGETATTR操作で使用されるセキュリティフレーバーの推奨事項については、セクション21を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-10--The-Attribute-fslocationsinfo">
11.10. The Attribute fs_locations_info
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.10. 属性fs_locations_info
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations_info attribute is intended as a more functional replacement for fs_locations that will continue to exist and be supported. Clients can use it to get a more complete set of information about alternative file system locations. When the server does not support fs_locations_info, fs_locations can be used to get a subset of the information. A server that supports fs_locations_info MUST support fs_locations as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations_info属性は、存在し続け、サポートされ続けるfs_locationsのより機能的な代替として意図されています。クライアントはこれを使用して、代替ファイルシステムの場所に関するより完全な情報セットを取得できます。サーバーがfs_locations_infoをサポートしていない場合、fs_locationsを使用して情報のサブセットを取得できます。 fs_locations_infoをサポートするサーバーは、fs_locationsもサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is additional information present in fs_locations_info, that is not available in fs_locations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations_infoには、fs_locationsにはない追加情報があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Attribute continuity information. This information will allow a client to select a location that meets the transparency requirements of the applications accessing the data and to leverage optimizations due to the server guarantees of attribute continuity (e.g., if between multiple server locations the change attribute of a file of the file system is continuous, the client does not have to invalidate the file&#39;s cache if the change attribute is the same among all locations).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 属性連続性情報。この情報により、クライアントは、データにアクセスするアプリケーションの透過性要件を満たす場所を選択し、属性の連続性のサーバー保証による最適化を活用できます（たとえば、複数のサーバーの場所の間でファイルのファイルの属性を変更した場合）システムは継続的であり、変更属性がすべての場所で同じである場合、クライアントはファイルのキャッシュを無効にする必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o File system identity information that indicates when multiple replicas, from the client&#39;s point of view, correspond to the same target file system, allowing them to be used interchangeably, without disruption, as multiple paths to the same thing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントの観点から見た複数のレプリカが同じターゲットファイルシステムに対応していることを示すファイルシステムID情報。これにより、同じものへの複数のパスとして、中断なしにそれらを交換して使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Information that will bear on the suitability of various replicas, depending on the use that the client intends. For example, many applications need an absolutely up-to-date copy (e.g., those that write), while others may only need access to the most up-to-date copy reasonably available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントの意図する用途に応じて、さまざまなレプリカの適合性に影響する情報。たとえば、多くのアプリケーションは完全に最新のコピー（書き込みなど）を必要としますが、他のアプリケーションは合理的に利用可能な最新のコピーへのアクセスのみを必要とする場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Server-derived preference information for replicas, which can be used to implement load-balancing while giving the client the entire file system list to be used in case the primary fails.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーから派生したレプリカの設定情報。これは、プライマリに障害が発生した場合に使用されるファイルシステムリスト全体をクライアントに提供しながら、負荷分散を実装するために使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations_info attribute is structured similarly to the fs_locations attribute. A top-level structure (fs_locations_info4) contains the entire attribute including the root pathname of the file system and an array of lower-level structures that define replicas that share a common rootpath on their respective servers. The lower-level structure in turn (fs_locations_item4) contains a specific pathname and information on one or more individual server replicas. For that last lowest-level, fs_locations_info has an fs_locations_server4 structure that contains per-server-replica information in addition to the server name. This per-server-replica information includes a nominally opaque array, fls_info, in which specific pieces of information are located at the specific indices listed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations_info属性は、fs_locations属性と同様の構造になっています。トップレベルの構造（fs_locations_info4）には、ファイルシステムのルートパス名と、それぞれのサーバーで共通のルートパスを共有するレプリカを定義する下位レベルの構造の配列を含む属性全体が含まれます。下位レベルの構造（fs_locations_item4）には、特定のパス名と、1つまたは複数の個々のサーバーレプリカに関する情報が含まれています。最後の最低レベルの場合、fs_locations_infoには、サーバー名に加えてサーバーごとのレプリカ情報を含むfs_locations_server4構造があります。このサーバーレプリカごとの情報には、名目上不透明な配列fls_infoが含まれています。この配列には、以下に示す特定のインデックスに特定の情報が配置されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attribute will always contain at least a single fs_locations_server entry. Typically, this will be an entry with the FS4LIGF_CUR_REQ flag set, although in the case of a referral there will be no entry with that flag set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性には常に少なくとも1つのfs_locations_serverエントリが含まれます。通常、これはFS4LIGF_CUR_REQフラグが設定されたエントリですが、参照の場合、そのフラグが設定されたエントリはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that fs_locations_info attributes returned by servers for various replicas may differ for various reasons. One server may know about a set of replicas that are not known to other servers. Further, compatibility attributes may differ. Filehandles might be of the same class going from replica A to replica B but not going in the reverse direction. This might happen because the filehandles are the same, but replica B&#39;s server implementation might not have provision to note and report that equivalence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーによってさまざまなレプリカに対して返されるfs_locations_info属性は、さまざまな理由で異なる場合があることに注意してください。 1つのサーバーが、他のサーバーには認識されていない一連のレプリカを認識している場合があります。さらに、互換性属性が異なる場合があります。ファイルハンドルは、レプリカAからレプリカBに移動する同じクラスのものである可能性がありますが、逆方向には移動しません。これは、ファイルハンドルが同じであるために発生する可能性がありますが、レプリカBのサーバー実装には、その等価性を記録して報告する機能がない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations_info attribute consists of a root pathname (fli_fs_root, just like fs_root in the fs_locations attribute), together with an array of fs_location_item4 structures. The fs_location_item4 structures in turn consist of a root pathname (fli_rootpath) together with an array (fli_entries) of elements of data type fs_locations_server4, all defined as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations_info属性は、ルートパス名（fs_locations属性のfs_rootと同様にfli_fs_root）とfs_location_item4構造体の配列で構成されます。 fs_location_item4構造は、ルートパス名（fli_rootpath）とデータ型fs_locations_server4の要素の配列（fli_entries）で構成され、すべて次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Defines an individual server replica
    */
   struct  fs_locations_server4 {
           int32_t         fls_currency;
           opaque          fls_info&lt;&gt;;
           utf8str_cis     fls_server;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Byte indices of items within
    * fls_info: flag fields, class numbers,
    * bytes indicating ranks and orders.
    */
   const FSLI4BX_GFLAGS            = 0;
   const FSLI4BX_TFLAGS            = 1;
   const FSLI4BX_CLSIMUL           = 2;
   const FSLI4BX_CLHANDLE          = 3;
   const FSLI4BX_CLFILEID          = 4;
   const FSLI4BX_CLWRITEVER        = 5;
   const FSLI4BX_CLCHANGE          = 6;
   const FSLI4BX_CLREADDIR         = 7;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const FSLI4BX_READRANK          = 8;
   const FSLI4BX_WRITERANK         = 9;
   const FSLI4BX_READORDER         = 10;
   const FSLI4BX_WRITEORDER        = 11;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Bits defined within the general flag byte.
    */
   const FSLI4GF_WRITABLE          = 0x01;
   const FSLI4GF_CUR_REQ           = 0x02;
   const FSLI4GF_ABSENT            = 0x04;
   const FSLI4GF_GOING             = 0x08;
   const FSLI4GF_SPLIT             = 0x10;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Bits defined within the transport flag byte.
    */
   const FSLI4TF_RDMA              = 0x01;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Defines a set of replicas sharing
    * a common value of the rootpath
    * with in the corresponding
    * single-server namespaces.
    */
   struct  fs_locations_item4 {
           fs_locations_server4    fli_entries&lt;&gt;;
           pathname4               fli_rootpath;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Defines the overall structure of
    * the fs_locations_info attribute.
    */
   struct  fs_locations_info4 {
           uint32_t                fli_flags;
           int32_t                 fli_valid_for;
           pathname4               fli_fs_root;
           fs_locations_item4      fli_items&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Flag bits in fli_flags.
    */
   const FSLI4IF_VAR_SUB           = 0x00000001;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef fs_locations_info4 fattr4_fs_locations_info;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef fs_locations_info4 fattr4_fs_locations_info;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As noted above, the fs_locations_info attribute, when supported, may be requested of absent file systems without causing NFS4ERR_MOVED to be returned. It is generally expected that it will be available for both present and absent file systems even if only a single fs_locations_server4 entry is present, designating the current (present) file system, or two fs_locations_server4 entries designating the previous location of an absent file system (the one just referenced) and its successor location. Servers are strongly urged to support this attribute on all file systems if they support it on any file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のように、サポートされている場合、fs_locations_info属性は、NFS4ERR_MOVEDが返されることなく、存在しないファイルシステムに対して要求される場合があります。 fs_locations_server4エントリが1つだけ存在して現在（現在）のファイルシステムを指定する場合、または2つのfs_locations_server4エントリが存在しないファイルシステム（以前の場所）を指定する場合でも、存在するファイルシステムと存在しないファイルシステムの両方で使用できることが一般に予想されます（参照されているもの）とその後続の場所。サーバーは、任意のファイルシステムでこの属性をサポートする場合、すべてのファイルシステムでこの属性をサポートすることを強くお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The data presented in the fs_locations_info attribute may be obtained by the server in any number of ways, including specification by the administrator or by current protocols for transferring data among replicas and protocols not yet developed. NFSv4.1 only defines how this information is presented by the server to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations_info属性で提示されるデータは、管理者による指定や、レプリカ間でデータを転送するための現在のプロトコルやまだ開発されていないプロトコルなど、さまざまな方法でサーバーによって取得できます。 NFSv4.1は、この情報がサーバーからクライアントに提示される方法のみを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-10-1--The-fslocationsserver4-Structure">
11.10.1. The fs_locations_server4 Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.10.1. fs_locations_server4構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations_server4 structure consists of the following items:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations_server4構造は、次の項目で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An indication of how up-to-date the file system is (fls_currency) in seconds. This value is relative to the master copy. A negative value indicates that the server is unable to give any reasonably useful value here. A value of zero indicates that the file system is the actual writable data or a reliably coherent and fully up-to-date copy. Positive values indicate how out-of-date this copy can normally be before it is considered for update. Such a value is not a guarantee that such updates will always be performed on the required schedule but instead serves as a hint about how far the copy of the data would be expected to be behind the most up-to-date copy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルシステムの最新の状態（fls_currency）の秒単位の指標。この値は、マスターコピーを基準にしています。負の値は、サーバーがここで合理的に有用な値を提供できないことを示します。ゼロの値は、ファイルシステムが実際の書き込み可能なデータ、または確実に一貫性のある完全に最新のコピーであることを示します。正の値は、更新が考慮される前に、このコピーが通常どれだけ古くなる可能性があるかを示します。このような値は、そのような更新が常に必要なスケジュールで実行されることを保証するものではなく、データのコピーが最新のコピーの背後にあると予想される距離に関するヒントとして機能します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A counted array of one-byte values (fls_info) containing information about the particular file system instance. This data includes general flags, transport capability flags, file system equivalence class information, and selection priority information. The encoding will be discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 特定のファイルシステムインスタンスに関する情報を含む、カウントされた1バイト値の配列（fls_info）。このデータには、一般フラグ、トランスポート機能フラグ、ファイルシステム等価クラス情報、および選択優先度情報が含まれます。エンコーディングについては、後で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server string (fls_server). For the case of the replica currently being accessed (via GETATTR), a zero-length string MAY be used to indicate the current address being used for the RPC call. The fls_server field can also be an IPv4 or IPv6 address, formatted the same way as an IPv4 or IPv6 address in the &#34;server&#34; field of the fs_location4 data type (see Section 11.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバー文字列（fls_server）。 GETATTRを介して現在アクセスされているレプリカの場合、RPC呼び出しに使用されている現在のアドレスを示すために、長さゼロの文字列を使用できます（MAY）。 fls_serverフィールドは、IPv4またはIPv6アドレスにすることもできます。これは、fs_location4データ型の「server」フィールドのIPv4またはIPv6アドレスと同じ方法でフォーマットされます（セクション11.9を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data within the fls_info array is in the form of 8-bit data items with constants giving the offsets within the array of various values describing this particular file system instance. This style of definition was chosen, in preference to explicit XDR structure definitions for these values, for a number of reasons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fls_info配列内のデータは、この特定のファイルシステムインスタンスを説明するさまざまな値の配列内のオフセットを与える定数を持つ8ビットのデータ項目の形式です。この定義スタイルは、いくつかの理由により、これらの値の明示的なXDR構造定義に優先して選択されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The kinds of data in the fls_info array, representing flags, file system classes, and priorities among sets of file systems representing the same data, are such that 8 bits provide a quite acceptable range of values. Even where there might be more than 256 such file system instances, having more than 256 distinct classes or priorities is unlikely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フラグ、ファイルシステムクラス、および同じデータを表すファイルシステムのセット間の優先順位を表すfls_info配列内のデータの種類は、8ビットが非常に許容範囲の値を提供するようなものです。そのようなファイルシステムインスタンスが256を超える場合でも、256を超える異なるクラスまたは優先順位を持つことはまずありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Explicit definition of the various specific data items within XDR would limit expandability in that any extension within a subsequent minor version would require yet another attribute, leading to specification and implementation clumsiness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o XDR内のさまざまな特定のデータ項目を明示的に定義すると、拡張性が制限され、後続のマイナーバージョン内の拡張にはさらに別の属性が必要になるため、仕様と実装が不便になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Such explicit definitions would also make it impossible to propose Standards Track extensions apart from a full minor version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o このような明示的な定義は、完全なマイナーバージョンとは別に、標準トラック拡張を提案することも不可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This encoding scheme can be adapted to the specification of multi-byte numeric values, even though none are currently defined. If extensions are made via Standards Track RFCs, multi-byte quantities will be encoded as a range of bytes with a range of indices, with the byte interpreted in big-endian byte order. Further, any such index assignments are constrained so that the relevant quantities will not cross XDR word boundaries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このコード化スキームは、現在何も定義されていなくても、マルチバイト数値の仕様に適合させることができます。スタンダードトラックRFCを介して拡張が行われる場合、マルチバイトの数量は、インデックスの範囲を持つバイトの範囲としてエンコードされ、バイトはビッグエンディアンのバイト順で解釈されます。さらに、関連する量がXDRワード境界を超えないように、そのようなインデックス割り当ては制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set of fls_info data is subject to expansion in a future minor version, or in a Standards Track RFC, within the context of a single minor version. The server SHOULD NOT send and the client MUST NOT use indices within the fls_info array that are not defined in Standards Track RFCs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fls_infoデータのセットは、単一のマイナーバージョンのコンテキスト内で、将来のマイナーバージョンまたはStandards Track RFCで拡張される可能性があります。サーバーは送信すべきではなく（SHOULD NOT）、クライアントは、Standards Track RFCで定義されていないfls_info配列内のインデックスを使用してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fls_info array contains:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fls_info配列には以下が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Two 8-bit flag fields, one devoted to general file-system characteristics and a second reserved for transport-related capabilities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2つの8ビットフラグフィールド。1つは一般的なファイルシステムの特性に使用され、もう1つはトランスポート関連の機能用に予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Six 8-bit class values that define various file system equivalence classes as explained below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 以下で説明するように、さまざまなファイルシステム等価クラスを定義する6つの8ビットクラス値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Four 8-bit priority values that govern file system selection as explained below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 以下で説明するように、ファイルシステムの選択を制御する4つの8ビット優先順位値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The general file system characteristics flag (at byte index FSLI4BX_GFLAGS) has the following bits defined within it:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的なファイルシステム特性フラグ（バイトインデックスFSLI4BX_GFLAGS）には、次のビットが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o FSLI4GF_WRITABLE indicates that this file system target is writable, allowing it to be selected by clients that may need to write on this file system. When the current file system instance is writable and is defined as of the same simultaneous use class (as specified by the value at index FSLI4BX_CLSIMUL) to which the client was previously writing, then it must incorporate within its data any committed write made on the source file system instance. See Section 11.7.8, which discusses the write-verifier class. While there is no harm in not setting this flag for a file system that turns out to be writable, turning the flag on for a read-only file system can cause problems for clients that select a migration or replication target based on the flag and then find themselves unable to write.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
o FSLI4GF_WRITABLEは、このファイルシステムターゲットが書き込み可能であることを示し、このファイルシステムへの書き込みが必要になる可能性があるクライアントがターゲットを選択できるようにします。現在のファイルシステムインスタンスが書き込み可能であり、クライアントが以前に書き込んでいたのと同じ同時使用クラス（インデックスFSLI4BX_CLSIMULの値で指定）として定義されている場合、ソースで行われたコミット済みの書き込みをデータ内に組み込む必要があります。ファイルシステムインスタンス。書き込み検証クラスについては、セクション11.7.8を参照してください。書き込み可能であることが判明したファイルシステムに対してこのフラグを設定しなくても害はありませんが、読み取り専用ファイルシステムに対してフラグをオンにすると、フラグに基づいて移行またはレプリケーションターゲットを選択するクライアントで問題が発生する可能性があります。書くことができないことに気づく。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o FSLI4GF_CUR_REQ indicates that this replica is the one on which the request is being made. Only a single server entry may have this flag set and, in the case of a referral, no entry will have it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o FSLI4GF_CUR_REQは、このレプリカが要求が行われているレプリカであることを示します。このフラグを設定できるのは1つのサーバーエントリのみであり、参照の場合、エントリにはそれがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o FSLI4GF_ABSENT indicates that this entry corresponds to an absent file system replica. It can only be set if FSLI4GF_CUR_REQ is set. When both such bits are set, it indicates that a file system instance is not usable but that the information in the entry can be used to determine the sorts of continuity available when switching from this replica to other possible replicas. Since this bit can only be true if FSLI4GF_CUR_REQ is true, the value could be determined using the fs_status attribute, but the information is also made available here for the convenience of the client. An entry with this bit, since it represents a true file system (albeit absent), does not appear in the event of a referral, but only when a file system has been accessed at this location and has subsequently been migrated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o FSLI4GF_ABSENTは、このエントリが存在しないファイルシステムのレプリカに対応することを示します。 FSLI4GF_CUR_REQが設定されている場合にのみ設定できます。このようなビットが両方とも設定されている場合、ファイルシステムインスタンスは使用できないが、エントリ内の情報を使用して、このレプリカから他の可能なレプリカに切り替えるときに使用できる連続性の種類を判別できることを示します。このビットは、FSLI4GF_CUR_REQがtrueの場合にのみtrueになる可能性があるため、fs_status属性を使用して値を決定できますが、クライアントの便宜のためにここでも情報を利用できます。このビットを持つエントリは、実際のファイルシステムを表す（存在しないにもかかわらず）ため、参照のイベントでは表示されませんが、ファイルシステムがこの場所でアクセスされ、その後移行された場合にのみ表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o FSLI4GF_GOING indicates that a replica, while still available, should not be used further. The client, if using it, should make an orderly transfer to another file system instance as expeditiously as possible. It is expected that file systems going out of service will be announced as FSLI4GF_GOING some time before the actual loss of service. It is also expected that the fli_valid_for value will be sufficiently small to allow clients to detect and act on scheduled events, while large enough that the cost of the requests to fetch the fs_locations_info values will not be excessive. Values on the order of ten minutes seem reasonable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o FSLI4GF_GOINGは、レプリカがまだ利用可能であっても、それ以上使用しないことを示します。クライアントは、それを使用している場合、できるだけ迅速に別のファイルシステムインスタンスに整然と転送する必要があります。サービスが停止するファイルシステムは、実際にサービスが停止する少し前にFSLI4GF_GOINGとして通知されることが予想されます。また、fli_valid_for値は、クライアントがスケジュールされたイベントを検出して処理できるように十分に小さいが、fs_locations_info値をフェッチするリクエストのコストが過度にならないほど大きいことが予想されます。 10分程度の値は妥当なようです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
When this flag is seen as part of a transition into a new file system, a client might choose to transfer immediately to another replica, or it may reference the current file system and only transition when a migration event occurs. Similarly, when this flag appears as a replica in the referral, clients would likely avoid being referred to this instance whenever there is another choice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このフラグが新しいファイルシステムへの移行の一部と見なされると、クライアントはすぐに別のレプリカに転送するか、現在のファイルシステムを参照して移行イベントが発生したときにのみ移行するかを選択できます。同様に、このフラグが紹介でレプリカとして表示される場合、別の選択肢がある場合は常に、クライアントがこのインスタンスを参照することを避けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o FSLI4GF_SPLIT indicates that when a transition occurs from the current file system instance to this one, the replacement may consist of multiple file systems. In this case, the client has to be prepared for the possibility that objects on the same file system before migration will be on different ones after. Note that FSLI4GF_SPLIT is not incompatible with the file systems belonging to the same fileid class since, if one has a set of fileids that are unique within a file system, each subset assigned to a smaller file system after migration would not have any conflicts internal to that file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
o FSLI4GF_SPLITは、現在のファイルシステムインスタンスからこのインスタンスへの移行が発生したときに、置換が複数のファイルシステムで構成される可能性があることを示します。この場合、クライアントは、移行前の同じファイルシステム上のオブジェクトが、後で異なるオブジェクトに存在する可能性に備えて準備する必要があります。 FSLI4GF_SPLITは、同じファイルIDクラスに属するファイルシステムと互換性がないことに注意してください。これは、ファイルシステム内で一意のファイルIDのセットがある場合、移行後に小さなファイルシステムに割り当てられた各サブセットが内部で競合しないためです。そのファイルシステム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A client, in the case of a split file system, will interrogate existing files with which it has continuing connection (it is free to simply forget cached filehandles). If the client remembers the directory filehandle associated with each open file, it may proceed upward using LOOKUPP to find the new file system boundaries. Note that in the event of a referral, there will not be any such files and so these actions will not be performed. Instead, a reference to a portion of the original file system now split off into other file systems will encounter an fsid change and possibly a further referral.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
分割ファイルシステムの場合、クライアントは、接続が継続している既存のファイルに問い合わせます（キャッシュされたファイルハンドルを単に忘れることは自由です）。クライアントが、開いている各ファイルに関連付けられているディレクトリファイルハンドルを覚えている場合は、LOOKUPPを使用して上方に進んで、新しいファイルシステムの境界を見つけることができます。紹介の場合、そのようなファイルは存在しないため、これらのアクションは実行されないことに注意してください。代わりに、元のファイルシステムの一部への参照が他のファイルシステムに分割されると、fsidが変更され、場合によってはさらに参照が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Once the client recognizes that one file system has been split into two, it can prevent the disruption of running applications by presenting the two file systems as a single one until a convenient point to recognize the transition, such as a restart. This would require a mapping from the server&#39;s fsids to fsids as seen by the client, but this is already necessary for other reasons. As noted above, existing fileids within the two descendant file systems will not conflict. Providing non-conflicting fileids for newly created files on the split file systems is the responsibility of the server (or servers working in concert). The server can encode filehandles such that filehandles generated before the split event can be discerned from those generated after the split, allowing the server to determine when the need for emulating two file systems as one is over.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1つのファイルシステムが2つに分割されたことをクライアントが認識すると、再起動などの移行を認識するのに都合のよい時点まで、2つのファイルシステムを1つとして提示することで、実行中のアプリケーションの中断を防ぐことができます。これには、クライアントから見たサーバーのfsidからfsidへのマッピングが必要ですが、これは他の理由ですでに必要です。上記のように、2つの子孫ファイルシステム内の既存のファイルIDは競合しません。分割ファイルシステムで新しく作成されたファイルに競合しないfileidを提供するのは、サーバー（またはサーバーが協調して動作するサーバー）の責任です。サーバーはファイルハンドルをエンコードして、分割イベントの前に生成されたファイルハンドルを分割後に生成されたファイルハンドルと区別できるため、サーバーは2つのファイルシステムを1つとしてエミュレートする必要性がいつ終わるかを判断できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Although it is possible for this flag to be present in the event of referral, it would generally be of little interest to the client, since the client is not expected to have information regarding the current contents of the absent file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このフラグが参照のイベントに存在することは可能ですが、クライアントは存在しないファイルシステムの現在の内容に関する情報を持っているとは想定されていないため、クライアントにはほとんど関係がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transport-flag field (at byte index FSLI4BX_TFLAGS) contains the following bits related to the transport capabilities of the specific file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランスポートフラグフィールド（バイトインデックスFSLI4BX_TFLAGS）には、特定のファイルシステムのトランスポート機能に関連する次のビットが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o FSLI4TF_RDMA indicates that this file system provides NFSv4.1 file system access using an RDMA-capable transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o FSLI4TF_RDMAは、このファイルシステムがRDMA対応のトランスポートを使用してNFSv4.1ファイルシステムアクセスを提供することを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Attribute continuity and file system identity information are expressed by defining equivalence relations on the sets of file systems presented to the client. Each such relation is expressed as a set of file system equivalence classes. For each relation, a file system has an 8-bit class number. Two file systems belong to the same class if both have identical non-zero class numbers. Zero is treated as non-matching. Most often, the relevant question for the client will be whether a given replica is identical to / continuous with the current one in a given respect, but the information should be available also as to whether two other replicas match in that respect as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
属性の継続性とファイルシステムの識別情報は、クライアントに提示されるファイルシステムのセットに同値関係を定義することによって表現されます。このような関係はそれぞれ、ファイルシステムの同等クラスのセットとして表現されます。各関係について、ファイルシステムには8ビットのクラス番号があります。 2つのファイルシステムは、ゼロ以外のクラス番号が同じである場合、同じクラスに属します。ゼロは不一致として扱われます。ほとんどの場合、クライアントに関連する質問は、特定のレプリカが特定の点で現在のレプリカと同一/連続しているかどうかですが、他の2つのレプリカがその点で一致するかどうかについても情報が利用可能である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following fields specify the file system&#39;s class numbers for the equivalence relations used in determining the nature of file system transitions. See Section 11.7 and its various subsections for details about how this information is to be used. Servers may assign these values as they wish, so long as file system instances that share the same value have the specified relationship to one another; conversely, file systems that have the specified relationship to one another share a common class value. As each instance entry is added, the relationships of this instance to previously entered instances can be consulted, and if one is found that bears the specified relationship, that entry&#39;s class value can be copied to the new entry. When no such previous entry exists, a new value for that byte index (not previously used) can be selected, most likely by incrementing the value of the last class value assigned for that index.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のフィールドは、ファイルシステムの遷移の性質を決定する際に使用される同値関係のファイルシステムのクラス番号を指定します。この情報の使用方法の詳細については、セクション11.7およびそのさまざまなサブセクションを参照してください。サーバーは、同じ値を共有するファイルシステムインスタンスが指定された相互関係を持っている限り、必要に応じてこれらの値を割り当てることができます。逆に、相互に指定された関係を持つファイルシステムは、共通のクラス値を共有します。各インスタンスエントリが追加されると、このインスタンスと以前に入力されたインスタンスとの関係が調べられ、指定された関係を持つものが見つかれば、そのエントリのクラス値を新しいエントリにコピーできます。そのような以前のエントリが存在しない場合、そのバイトインデックスの新しい値（以前は使用されていなかったもの）を選択できます。これは、そのインデックスに割り当てられた最後のクラス値の値をインクリメントすることにより可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The field with byte index FSLI4BX_CLSIMUL defines the simultaneous-use class for the file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイトインデックスがFSLI4BX_CLSIMULのフィールドは、ファイルシステムの同時使用クラスを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The field with byte index FSLI4BX_CLHANDLE defines the handle class for the file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイトインデックスがFSLI4BX_CLHANDLEのフィールドは、ファイルシステムのハンドルクラスを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The field with byte index FSLI4BX_CLFILEID defines the fileid class for the file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイトインデックスがFSLI4BX_CLFILEIDのフィールドは、ファイルシステムのファイルIDクラスを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The field with byte index FSLI4BX_CLWRITEVER defines the write-verifier class for the file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイトインデックスがFSLI4BX_CLWRITEVERのフィールドは、ファイルシステムの書き込みベリファイアクラスを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The field with byte index FSLI4BX_CLCHANGE defines the change class for the file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイトインデックスがFSLI4BX_CLCHANGEのフィールドは、ファイルシステムの変更クラスを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The field with byte index FSLI4BX_CLREADDIR defines the readdir class for the file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイトインデックスがFSLI4BX_CLREADDIRのフィールドは、ファイルシステムのreaddirクラスを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server-specified preference information is also provided via 8-bit values within the fls_info array. The values provide a rank and an order (see below) to be used with separate values specifiable for the cases of read-only and writable file systems. These values are compared for different file systems to establish the server-specified preference, with lower values indicating &#34;more preferred&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー指定の設定情報も、fls_info配列内の8ビット値を介して提供されます。値は、読み取り専用および書き込み可能なファイルシステムの場合に指定可能な個別の値で使用されるランクと順序（以下を参照）を提供します。これらの値は、異なるファイルシステムに対して比較され、サーバー指定の優先順位を確立します。値が小さいほど、「優先される」ことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rank is used to express a strict server-imposed ordering on clients, with lower values indicating &#34;more preferred&#34;. Clients should attempt to use all replicas with a given rank before they use one with a higher rank. Only if all of those file systems are unavailable should the client proceed to those of a higher rank. Because specifying a rank will override client preferences, servers should be conservative about using this mechanism, particularly when the environment is one in which client communication characteristics are neither tightly controlled nor visible to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ランクは、クライアントにサーバーが課す厳密な順序を表すために使用され、値が小さいほど「優先される」ことを示します。クライアントは、ランクが高いレプリカを使用する前に、ランクが指定されたすべてのレプリカを使用する必要があります。これらのファイルシステムがすべて使用できない場合にのみ、クライアントは上位のファイルシステムに進む必要があります。ランクを指定するとクライアントの優先設定が上書きされるため、特にクライアントの通信特性が厳密に制御されておらず、サーバーからも見えない環境の場合、サーバーはこのメカニズムの使用に慎重になる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Within a rank, the order value is used to specify the server&#39;s preference to guide the client&#39;s selection when the client&#39;s own preferences are not controlling, with lower values of order indicating &#34;more preferred&#34;. If replicas are approximately equal in all respects, clients should defer to the order specified by the server. When clients look at server latency as part of their selection, they are free to use this criterion but it is suggested that when latency differences are not significant, the server-specified order should guide selection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ランク内では、順序の値を使用してサーバーの設定を指定し、クライアント自身の設定が制御していない場合にクライアントの選択をガイドします。順序の値が小さいほど、「優先」を示します。レプリカがすべての点でほぼ等しい場合、クライアントはサーバーによって指定された順序に従う必要があります。クライアントは、サーバーレイテンシを選択の一部として見る場合、この基準を自由に使用できますが、レイテンシの差がそれほど大きくない場合は、サーバー指定の順序で選択をガイドすることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The field at byte index FSLI4BX_READRANK gives the rank value to be used for read-only access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイトインデックスFSLI4BX_READRANKのフィールドは、読み取り専用アクセスに使用されるランク値を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The field at byte index FSLI4BX_READORDER gives the order value to be used for read-only access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイトインデックスFSLI4BX_READORDERのフィールドは、読み取り専用アクセスに使用される順序値を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The field at byte index FSLI4BX_WRITERANK gives the rank value to be used for writable access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイトインデックスFSLI4BX_WRITERANKのフィールドは、書き込み可能なアクセスに使用されるランク値を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The field at byte index FSLI4BX_WRITEORDER gives the order value to be used for writable access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o バイトインデックスFSLI4BX_WRITEORDERのフィールドは、書き込み可能なアクセスに使用される順序値を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on the potential need for write access by a given client, one of the pairs of rank and order values is used. The read rank and order should only be used if the client knows that only reading will ever be done or if it is prepared to switch to a different replica in the event that any write access capability is required in the future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のクライアントによる書き込みアクセスの潜在的な必要性に応じて、ランクと順序の値のペアの1つが使用されます。読み取りのランクと順序は、クライアントが読み取りのみが行われることを知っている場合、または将来書き込みアクセス機能が必要になった場合に別のレプリカに切り替える準備ができている場合にのみ使用してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-10-2--The-fslocationsinfo4-Structure">
11.10.2. The fs_locations_info4 Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.10.2. fs_locations_info4構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations_info4 structure, encoding the fs_locations_info attribute, contains the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations_info属性をエンコードするfs_locations_info4構造には、以下が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The fli_flags field, which contains general flags that affect the interpretation of this fs_locations_info4 structure and all fs_locations_item4 structures within it. The only flag currently defined is FSLI4IF_VAR_SUB. All bits in the fli_flags field that are not defined should always be returned as zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o このfs_locations_info4構造とその中のすべてのfs_locations_item4構造の解釈に影響を与える一般的なフラグを含むfli_flagsフィールド。現在定義されている唯一のフラグはFSLI4IF_VAR_SUBです。定義されていないfli_flagsフィールドのすべてのビットは、常にゼロとして返される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The fli_fs_root field, which contains the pathname of the root of the current file system on the current server, just as it does in the fs_locations4 structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o fs_locations4構造体と同様に、fli_fs_rootフィールドには、現在のサーバー上の現在のファイルシステムのルートのパス名が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An array called fli_items of fs_locations4_item structures, which contain information about replicas of the current file system. Where the current file system is actually present, or has been present, i.e., this is not a referral situation, one of the fs_locations_item4 structures will contain an fs_locations_server4 for the current server. This structure will have FSLI4GF_ABSENT set if the current file system is absent, i.e., normal access to it will return NFS4ERR_MOVED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 現在のファイルシステムのレプリカに関する情報を含むfs_locations4_item構造のfli_itemsと呼ばれる配列。現在のファイルシステムが実際に存在するか、存在していた場合、つまりこれが参照状況ではない場合、fs_locations_item4構造の1つに現在のサーバーのfs_locations_server4が含まれます。現在のファイルシステムが存在しない場合、この構造にはFSLI4GF_ABSENTが設定されます。つまり、通常のアクセスではNFS4ERR_MOVEDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The fli_valid_for field specifies a time in seconds for which it is reasonable for a client to use the fs_locations_info attribute without refetch. The fli_valid_for value does not provide a guarantee of validity since servers can unexpectedly go out of service or become inaccessible for any number of reasons. Clients are well-advised to refetch this information for an actively accessed file system at every fli_valid_for seconds. This is particularly important when file system replicas may go out of service in a controlled way using the FSLI4GF_GOING flag to communicate an ongoing change. The server should set fli_valid_for to a value that allows well-behaved clients to notice the FSLI4GF_GOING flag and make an orderly switch before the loss of service becomes effective. If this value is zero, then no refetch interval is appropriate and the client need not refetch this data on any particular schedule. In the event of a transition to a new file system instance, a new value of the fs_locations_info attribute will be fetched at the destination. It is to be expected that this may have a different fli_valid_for value, which the client should then use in the same fashion as the previous value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o fli_valid_forフィールドは、クライアントが再フェッチせずにfs_locations_info属性を使用することが妥当である時間を秒単位で指定します。 fli_valid_for値は、サーバーが予期せずにサービスを停止したり、さまざまな理由でアクセスできなくなったりする可能性があるため、有効性を保証するものではありません。クライアントは、fli_valid_for秒ごとにアクティブにアクセスされるファイルシステムのこの情報を再フェッチすることをお勧めします。これは、ファイルシステムのレプリカがFSLI4GF_GOINGフラグを使用して制御された方法でサービスを停止し、進行中の変更を通知する場合に特に重要です。サーバーは、fli_valid_forを、正常に動作しているクライアントがFSLI4GF_GOINGフラグに気づくことができる値に設定し、サービスの損失が有効になる前に正常な切り替えを行う必要があります。この値がゼロの場合、再フェッチ間隔は適切ではなく、クライアントは特定のスケジュールでこのデータを再フェッチする必要はありません。新しいファイルシステムインスタンスへの遷移が発生した場合、fs_locations_info属性の新しい値が宛先でフェッチされます。これには異なるfli_valid_for値が含まれる可能性があり、クライアントは前の値と同じ方法で使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The FSLI4IF_VAR_SUB flag within fli_flags controls whether variable substitution is to be enabled. See Section 11.10.3 for an explanation of variable substitution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fli_flags内のFSLI4IF_VAR_SUBフラグは、変数置換を有効にするかどうかを制御します。変数置換の説明については、セクション11.10.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-10-3--The-fslocationsitem4-Structure">
11.10.3. The fs_locations_item4 Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.10.3. fs_locations_item4構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations_item4 structure contains a pathname (in the field fli_rootpath) that encodes the path of the target file system replicas on the set of servers designated by the included fs_locations_server4 entries. The precise manner in which this target location is specified depends on the value of the FSLI4IF_VAR_SUB flag within the associated fs_locations_info4 structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations_item4構造には、含まれているfs_locations_server4エントリによって指定されたサーバーのセット上のターゲットファイルシステムのレプリカのパスをエンコードするパス名（フィールドfli_rootpath内）が含まれています。このターゲットの場所を指定する正確な方法は、関連するfs_locations_info4構造内のFSLI4IF_VAR_SUBフラグの値によって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If this flag is not set, then fli_rootpath simply designates the location of the target file system within each server&#39;s single-server namespace just as it does for the rootpath within the fs_location4 structure. When this bit is set, however, component entries of a certain form are subject to client-specific variable substitution so as to allow a degree of namespace non-uniformity in order to accommodate the selection of client-specific file system targets to adapt to different client architectures or other characteristics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このフラグが設定されていない場合、fli_rootpathは、fs_location4構造内のrootpathの場合と同様に、各サーバーの単一サーバー名前空間内のターゲットファイルシステムの場所を指定するだけです。ただし、このビットが設定されている場合、特定の形式のコンポーネントエントリはクライアント固有の変数置換の対象となり、クライアント固有のファイルシステムターゲットの選択に対応して、クライアントアーキテクチャまたはその他の特性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When such substitution is in effect, a variable beginning with the string &#34;${&#34; and ending with the string &#34;}&#34; and containing a colon is to be replaced by the client-specific value associated with that variable. The string &#34;unknown&#34; should be used by the client when it has no value for such a variable. The pathname resulting from such substitutions is used to designate the target file system, so that different clients may have different file systems, corresponding to that location in the multi-server namespace.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような置換が有効な場合、文字列「$ {」で始まり、文字列「}」で終わり、コロンを含む変数は、その変数に関連付けられたクライアント固有の値に置き換えられます。文字列 &#34;unknown&#34;は、そのような変数の値がない場合にクライアントで使用されます。このような置換の結果として得られるパス名は、ターゲットファイルシステムを指定するために使用されます。これにより、異なるクライアントが、マルチサーバー名前空間のその場所に対応する異なるファイルシステムを持つことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned above, such substituted pathname variables contain a colon. The part before the colon is to be a DNS domain name, and the part after is to be a case-insensitive alphanumeric string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のように、そのような置換されたパス名変数にはコロンが含まれます。コロンの前の部分はDNSドメイン名で、後の部分は大文字と小文字を区別しない英数字の文字列です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the domain is &#34;ietf.org&#34;, only variable names defined in this document or subsequent Standards Track RFCs are subject to such substitution. Organizations are free to use their domain names to create their own sets of client-specific variables, to be subject to such substitution. In cases where such variables are intended to be used more broadly than a single organization, publication of an Informational RFC defining such variables is RECOMMENDED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ドメインが「ietf.org」である場合、このドキュメントまたは後続のスタンダードトラックRFCで定義されている変数名のみが、このような置換の対象となります。組織は、ドメイン名を自由に使用して独自のクライアント固有変数のセットを作成し、そのような置換の対象にすることができます。そのような変数が単一の組織よりも広く使用されることが意図されている場合、そのような変数を定義する情報RFCの公開が推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The variable ${ietf.org:CPU_ARCH} is used to denote that the CPU architecture object files are compiled. This specification does not limit the acceptable values (except that they must be valid UTF-8 strings), but such values as &#34;x86&#34;, &#34;x86_64&#34;, and &#34;sparc&#34; would be expected to be used in line with industry practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変数$ {ietf.org:CPU_ARCH}は、CPUアーキテクチャオブジェクトファイルがコンパイルされることを示すために使用されます。この仕様は許容値を制限しません（有効なUTF-8文字列である必要があることを除いて）が、 &#34;x86&#34;、 &#34;x86_64&#34;、および &#34;sparc&#34;などの値は業界の慣行に従って使用されることが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The variable ${ietf.org:OS_TYPE} is used to denote the operating system, and thus the kernel and library APIs, for which code might be compiled. This specification does not limit the acceptable values (except that they must be valid UTF-8 strings), but such values as &#34;linux&#34; and &#34;freebsd&#34; would be expected to be used in line with industry practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変数$ {ietf.org:OS_TYPE}は、オペレーティングシステム、つまりコードがコンパイルされる可能性のあるカーネルお​​よびライブラリAPIを示すために使用されます。この仕様は許容値を制限しません（有効なUTF-8文字列である必要があることを除いて）が、 &#34;linux&#34;や &#34;freebsd&#34;などの値は業界の慣行に従って使用されることが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The variable ${ietf.org:OS_VERSION} is used to denote the operating system version, and thus the specific details of versioned interfaces, for which code might be compiled. This specification does not limit the acceptable values (except that they must be valid UTF-8 strings). However, combinations of numbers and letters with interspersed dots would be expected to be used in line with industry practice, with the details of the version format depending on the specific value of the variable ${ietf.org:OS_TYPE} with which it is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
変数$ {ietf.org:OS_VERSION}は、オペレーティングシステムのバージョンを示すために使用されます。したがって、コードがコンパイルされる可能性のあるバージョン付きインターフェースの特定の詳細を示します。この仕様は、許容値を制限しません（有効なUTF-8文字列でなければならないことを除いて）。ただし、ドットとドットが混在した数字と文字の組み合わせは、業界の慣例に従って使用されることが予想され、バージョン形式の詳細は、使用される変数$ {ietf.org:OS_TYPE}の特定の値に依存します。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of these variables could result in the direction of different clients to different file systems on the same server, as appropriate to particular clients. In cases in which the target file systems are located on different servers, a single server could serve as a referral point so that each valid combination of variable values would designate a referral hosted on a single server, with the targets of those referrals on a number of different servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの変数を使用すると、特定のクライアントに応じて、異なるクライアントが同じサーバー上の異なるファイルシステムに方向付けられる可能性があります。ターゲットファイルシステムが異なるサーバーにある場合、単一のサーバーが参照ポイントとして機能し、変数値の有効な組み合わせごとに、単一のサーバーでホストされている参照を指定し、それらの参照のターゲットを番号で指定します。異なるサーバーの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because namespace administration is affected by the values selected to substitute for various variables, clients should provide convenient means of determining what variable substitutions a client will implement, as well as, where appropriate, providing means to control the substitutions to be used. The exact means by which this will be done is outside the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前空間の管理は、さまざまな変数を置き換えるために選択された値の影響を受けるため、クライアントは、クライアントが実装する変数置換を決定する便利な手段を提供し、必要に応じて、使用される置換を制御する手段を提供する必要があります。これを行う正確な手段は、この仕様の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although variable substitution is most suitable for use in the context of referrals, it may be used in the context of replication and migration. If it is used in these contexts, the server must ensure that no matter what values the client presents for the substituted variables, the result is always a valid successor file system instance to that from which a transition is occurring, i.e., that the data is identical or represents a later image of a writable file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変数置換は、参照のコンテキストでの使用に最も適していますが、レプリケーションおよびマイグレーションのコンテキストで使用できます。これらのコンテキストで使用する場合、サーバーは、置換された変数に対してクライアントが提示する値に関係なく、遷移が発生しているインスタンスへの有効な後続ファイルシステムインスタンスが常に得られるようにする必要があります。同一または書き込み可能なファイルシステムの新しいイメージを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that when fli_rootpath is a null pathname (that is, one with zero components), the file system designated is at the root of the specified server, whether or not the FSLI4IF_VAR_SUB flag within the associated fs_locations_info4 structure is set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関連するfs_locations_info4構造内のFSLI4IF_VAR_SUBフラグが設定されているかどうかに関係なく、fli_rootpathがnullパス名（つまり、コンポーネントが0のパス名）の場合、指定されたファイルシステムは指定されたサーバーのルートにあることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-11--The-Attribute-fsstatus">
11.11. The Attribute fs_status
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.11. 属性fs_status
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In an environment in which multiple copies of the same basic set of data are available, information regarding the particular source of such data and the relationships among different copies can be very helpful in providing consistent data to applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じ基本データセットの複数のコピーが利用可能な環境では、そのようなデータの特定のソースおよび異なるコピー間の関係に関する情報は、アプリケーションに一貫したデータを提供するのに非常に役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum fs4_status_type {
           STATUS4_FIXED = 1,
           STATUS4_UPDATED = 2,
           STATUS4_VERSIONED = 3,
           STATUS4_WRITABLE = 4,
           STATUS4_REFERRAL = 5
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fs4_status {
           bool            fss_absent;
           fs4_status_type fss_type;
           utf8str_cs      fss_source;
           utf8str_cs      fss_current;
           int32_t         fss_age;
           nfstime4        fss_version;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The boolean fss_absent indicates whether the file system is currently absent. This value will be set if the file system was previously present and becomes absent, or if the file system has never been present and the type is STATUS4_REFERRAL. When this boolean is set and the type is not STATUS4_REFERRAL, the remaining information in the fs4_status reflects that last valid when the file system was present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブールfss_absentは、ファイルシステムが現在存在しないかどうかを示します。この値は、ファイルシステムが以前から存在していなかった場合、またはファイルシステムが存在したことがなく、タイプがSTATUS4_REFERRALの場合に設定されます。このブール値が設定されていて、タイプがSTATUS4_REFERRALでない場合、fs4_statusの残りの情報は、ファイルシステムが存在したときに最後に有効だった情報を反映しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fss_type field indicates the kind of file system image represented. This is of particular importance when using the version values to determine appropriate succession of file system images. When fss_absent is set, and the file system was previously present, the value of fss_type reflected is that when the file was last present. Five values are distinguished:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fss_typeフィールドは、表されるファイルシステムイメージの種類を示します。これは、バージョン値を使用してファイルシステムイメージの適切な継承を決定するときに特に重要です。 fss_absentが設定されていて、ファイルシステムが以前に存在していた場合、反映されるfss_typeの値は、ファイルが最後に存在したときのものです。 5つの値が区別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o STATUS4_FIXED, which indicates a read-only image in the sense that it will never change. The possibility is allowed that, as a result of migration or switch to a different image, changed data can be accessed, but within the confines of this instance, no change is allowed. The client can use this fact to cache aggressively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o STATUS4_FIXED：変更されないという意味で読み取り専用イメージを示します。移行または別のイメージへの切り替えの結果として、変更されたデータにアクセスできる可能性はありますが、このインスタンスの範囲内では、変更は許可されません。クライアントはこの事実を使用して積極的にキャッシュすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o STATUS4_VERSIONED, which indicates that the image, like the STATUS4_UPDATED case, is updated externally, but it provides a guarantee that the server will carefully update an associated version value so that the client can protect itself from a situation in which it reads data from one version of the file system and then later reads data from an earlier version of the same file system. See below for a discussion of how this can be done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o STATUS4_VERSIONED。これは、STATUS4_UPDATEDの場合と同様に、イメージが外部で更新されることを示しますが、サーバーが関連するバージョンの値を慎重に更新して、クライアントが1つのバージョンからデータを読み取る状況から自身を保護できることを保証します。ファイルシステムの後で、同じファイルシステムの以前のバージョンからデータを読み取ります。これを行う方法については、以下を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o STATUS4_UPDATED, which indicates an image that cannot be updated by the user writing to it but that may be changed externally, typically because it is a periodically updated copy of another writable file system somewhere else. In this case, version information is not provided, and the client does not have the responsibility of making sure that this version only advances upon a file system instance transition. In this case, it is the responsibility of the server to make sure that the data presented after a file system instance transition is a proper successor image and includes all changes seen by the client and any change made before all such changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
o STATUS4_UPDATED。書き込み中のユーザーは更新できないが、通常は別の場所にある別の書き込み可能なファイルシステムの定期的に更新されたコピーであるため、外部から変更できる画像を示します。この場合、バージョン情報は提供されず、クライアントは、このバージョンがファイルシステムインスタンスの移行時にのみ進行することを確認する責任を負いません。この場合、ファイルシステムインスタンスの移行後に提示されるデータが適切な後続イメージであり、クライアントから見たすべての変更と、そのようなすべての変更の前に行われた変更が含まれていることを確認するのは、サーバーの責任です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o STATUS4_WRITABLE, which indicates that the file system is an actual writable one. The client need not, of course, actually write to the file system, but once it does, it should not accept a transition to anything other than a writable instance of that same file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o STATUS4_WRITABLE。ファイルシステムが実際に書き込み可能なものであることを示します。もちろん、クライアントは実際にファイルシステムに書き込む必要はありませんが、一度書き込んだ後は、同じファイルシステムの書き込み可能なインスタンス以外への遷移を受け入れてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o STATUS4_REFERRAL, which indicates that the file system in question is absent and has never been present on this server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o STATUS4_REFERRAL。問題のファイルシステムが存在せず、このサーバーに存在したことがないことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that in the STATUS4_UPDATED and STATUS4_VERSIONED cases, the server is responsible for the appropriate handling of locks that are inconsistent with external changes to delegations. If a server gives out delegations, they SHOULD be recalled before an inconsistent change is made to the data, and MUST be revoked if this is not possible. Similarly, if an OPEN is inconsistent with data that is changed (the OPEN has OPEN4_SHARE_DENY_WRITE/OPEN4_SHARE_DENY_BOTH and the data is changed), that OPEN SHOULD be considered administratively revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STATUS4_UPDATEDおよびSTATUS4_VERSIONEDの場合、サーバーは、委任に対する外部の変更と矛盾するロックの適切な処理を担当することに注意してください。サーバーが委譲を提供する場合、データに不整合な変更が加えられる前にそれらをリコールする必要があり（SHOULD）、これが不可能な場合は取り消す必要があります。同様に、OPENが変更されたデータと一致しない場合（OPENにはOPEN4_SHARE_DENY_WRITE / OPEN4_SHARE_DENY_BOTHがあり、データが変更されている場合）、そのOPENは管理上取り消されていると見なされるべきです（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The opaque strings fss_source and fss_current provide a way of presenting information about the source of the file system image being present. It is not intended that the client do anything with this information other than make it available to administrative tools. It is intended that this information be helpful when researching possible problems with a file system image that might arise when it is unclear if the correct image is being accessed and, if not, how that image came to be made. This kind of diagnostic information will be helpful, if, as seems likely, copies of file systems are made in many different ways (e.g., simple user-level copies, file-system-level point-in-time copies, clones of the underlying storage), under a variety of administrative arrangements. In such environments, determining how a given set of data was constructed can be very helpful in resolving problems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不透明な文字列fss_sourceおよびfss_currentは、存在するファイルシステムイメージのソースに関する情報を表示する方法を提供します。クライアントがこの情報を使用して、管理ツールで使用できるようにすること以外に何かを行うことは意図されていません。この情報は、正しいイメージにアクセスしているかどうか、またアクセスしていない場合にそのイメージがどのように作成されたのか不明な場合に発生する可能性のある、ファイルシステムイメージの考えられる問題を調査するときに役立ちます。この種類の診断情報は、ファイルシステムのコピーがさまざまな方法で作成されている場合に役立ちます（たとえば、単純なユーザーレベルのコピー、ファイルシステムレベルのポイントインタイムコピー、基礎となるクローン）ストレージ）、さまざまな管理上の取り決めの下で。このような環境では、特定のデータセットがどのように構築されたかを判断することは、問題の解決に非常に役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The opaque string fss_source is used to indicate the source of a given file system with the expectation that tools capable of creating a file system image propagate this information, when possible. It is understood that this may not always be possible since a user-level copy may be thought of as creating a new data set and the tools used may have no mechanism to propagate this data. When a file system is initially created, it is desirable to associate with it data regarding how the file system was created, where it was created, who created it, etc. Making this information available in this attribute in a human-readable string will be helpful for applications and system administrators and will also serve to make it available when the original file system is used to make subsequent copies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
不透明な文字列fss_sourceは、ファイルシステムイメージを作成できるツールが可能な場合にこの情報を伝播することを期待して、特定のファイルシステムのソースを示すために使用されます。ユーザーレベルのコピーは新しいデータセットを作成するものと考えられ、使用されるツールにはこのデータを伝達するメカニズムがない場合があるため、これが常に可能であるとは限らないことを理解してください。ファイルシステムを最初に作成するときは、ファイルシステムの作成方法、作成場所、作成者などに関するデータをファイルシステムに関連付けることが望ましいです。この情報を人間が読める文字列でこの属性で利用できるようにすることは、アプリケーションとシステム管理者に役立ちます。また、元のファイルシステムを使用して後続のコピーを作成するときにも使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The opaque string fss_current should provide whatever information is available about the source of the current copy. Such information includes the tool creating it, any relevant parameters to that tool, the time at which the copy was done, the user making the change, the server on which the change was made, etc. All information should be in a human-readable string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不透明な文字列fss_currentは、現在のコピーのソースに関して利用可能な情報を提供する必要があります。そのような情報には、それを作成するツール、そのツールに関連するパラメーター、コピーが行われた時間、変更を行ったユーザー、変更が行われたサーバーなどが含まれます。すべての情報は人間が読める形式である必要がありますストリング。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The field fss_age provides an indication of how out-of-date the file system currently is with respect to its ultimate data source (in case of cascading data updates). This complements the fls_currency field of fs_locations_server4 (see Section 11.10) in the following way: the information in fls_currency gives a bound for how out of date the data in a file system might typically get, while the value in fss_age gives a bound on how out-of-date that data actually is. Negative values imply that no information is available. A zero means that this data is known to be current. A positive value means that this data is known to be no older than that number of seconds with respect to the ultimate data source. Using this value, the client may be able to decide that a data copy is too old, so that it may search for a newer version to use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドfss_ageは、ファイルシステムが現在の最終的なデータソースに対してどれだけ古いかを示します（カスケードデータ更新の場合）。これは、fs_locations_server4（セクション11.10を参照）のfls_currencyフィールドを次のように補完します。fls_currencyの情報は、ファイルシステムのデータが通常取得する可能性のある期限切れの限界を示し、fss_ageの値は、限界の限界を与えますデータが実際に存在する日付。負の値は、利用できる情報がないことを意味します。ゼロは、このデータが最新であることがわかっていることを意味します。正の値は、このデータが、最終的なデータソースに関してその秒数より古いことはないとわかっていることを意味します。この値を使用すると、クライアントはデータコピーが古すぎると判断できるため、使用する新しいバージョンを検索できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fss_version field provides a version identification, in the form of a time value, such that successive versions always have later time values. When the fs_type is anything other than STATUS4_VERSIONED, the server may provide such a value, but there is no guarantee as to its validity and clients will not use it except to provide additional information to add to fss_source and fss_current.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fss_versionフィールドは、バージョン値を時間値の形式で提供します。これにより、連続するバージョンには常に新しい時間値が含まれます。 fs_typeがSTATUS4_VERSIONED以外の場合、サーバーはそのような値を提供する可能性がありますが、その有効性については保証されず、クライアントはfss_sourceおよびfss_currentに追加する追加情報を提供する以外は使用しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When fss_type is STATUS4_VERSIONED, servers SHOULD provide a value of fss_version that progresses monotonically whenever any new version of the data is established. This allows the client, if reliable image progression is important to it, to fetch this attribute as part of each COMPOUND where data or metadata from the file system is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fss_typeがSTATUS4_VERSIONEDの場合、サーバーは、データの新しいバージョンが確立されるたびに単調に進行するfss_versionの値を提供する必要があります（SHOULD）。これにより、クライアントは、信頼できるイメージの進行が重要な場合、ファイルシステムからのデータまたはメタデータが使用される各COMPOUNDの一部としてこの属性をフェッチできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When it is important to the client to make sure that only valid successor images are accepted, it must make sure that it does not read data or metadata from the file system without updating its sense of the current state of the image. This is to avoid the possibility that the fs_status that the client holds will be one for an earlier image, which would cause the client to accept a new file system instance that is later than that but still earlier than the updated data read by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有効な後続イメージのみが受け入れられることを確認することがクライアントにとって重要な場合は、イメージの現在の状態の意味を更新せずに、ファイルシステムからデータまたはメタデータを読み取らないようにする必要があります。これは、クライアントが保持するfs_statusが以前のイメージのfs_statusになる可能性を回避するためです。これにより、クライアントは、それ以降であるが、クライアントが読み取る更新データよりも前の新しいファイルシステムインスタンスを受け入れます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to accept valid images reliably, the client must do a GETATTR of the fs_status attribute that follows any interrogation of data or metadata within the file system in question. Often this is most conveniently done by appending such a GETATTR after all other operations that reference a given file system. When errors occur between reading file system data and performing such a GETATTR, care must be exercised to make sure that the data in question is not used before obtaining the proper fs_status value. In this connection, when an OPEN is done within such a versioned file system and the associated GETATTR of fs_status is not successfully completed, the open file in question must not be accessed until that fs_status is fetched.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有効なイメージを確実に受け入れるために、クライアントは、問題のファイルシステム内のデータまたはメタデータの問い合わせに続くfs_status属性のGETATTRを実行する必要があります。多くの場合、これは、特定のファイルシステムを参照する他のすべての操作の後にそのようなGETATTRを追加することで最も便利に実行されます。ファイルシステムデータの読み取りとGETATTRの実行の間にエラーが発生した場合は、適切なfs_status値を取得する前に、問題のデータが使用されていないことを確認する必要があります。これに関連して、OPENがそのようなバージョンのファイルシステム内で行われ、fs_statusの関連するGETATTRが正常に完了しない場合、そのfs_statusがフェッチされるまで、問題のオープンファイルにアクセスしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedure above will ensure that before using any data from the file system the client has in hand a newly-fetched current version of the file system image. Multiple values for multiple requests in flight can be resolved by assembling them into the required partial order (and the elements should form a total order within the partial order) and using the last. The client may then, when switching among file system instances, decline to use an instance that does not have an fss_type of STATUS4_VERSIONED or whose fss_version field is earlier than the last one obtained from the predecessor file system instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の手順により、ファイルシステムのデータを使用する前に、クライアントがファイルシステムイメージの新しくフェッチされた現在のバージョンを手元に持っていることが保証されます。進行中の複数のリクエストの複数の値は、それらを必要な部分的な順序に組み立てて（そして要素は部分的な順序内の合計順序を形成する必要があります）、最後を使用することで解決できます。クライアントは、ファイルシステムインスタンスを切り替えるときに、fs4_typeがSTATUS4_VERSIONEDでないインスタンス、またはfss_versionフィールドが先行するファイルシステムインスタンスから取得した最後のフィールドよりも古いインスタンスの使用を拒否する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12--Parallel-NFS-pNFS">
12. Parallel NFS (pNFS)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. 並列NFS（pNFS）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-1--Introduction">
12.1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFS is an OPTIONAL feature within NFSv4.1; the pNFS feature set allows direct client access to the storage devices containing file data. When file data for a single NFSv4 server is stored on multiple and/or higher-throughput storage devices (by comparison to the server&#39;s throughput capability), the result can be significantly better file access performance. The relationship among multiple clients, a single server, and multiple storage devices for pNFS (server and clients have access to all storage devices) is shown in Figure 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSはNFSv4.1のオプション機能です。 pNFS機能セットにより、クライアントはファイルデータを含むストレージデバイスに直接アクセスできます。単一のNFSv4サーバーのファイルデータが複数の高スループットストレージデバイスに格納されている場合（サーバーのスループット機能と比較して）、結果としてファイルアクセスパフォーマンスが大幅に向上します。複数のクライアント、単一のサーバー、およびpNFSの複数のストレージデバイス（サーバーとクライアントはすべてのストレージデバイスにアクセスできます）間の関係を図1に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       +-----------+
       |+-----------+                                 +-----------+
       ||+-----------+                                |           |
       |||           |        NFSv4.1 + pNFS          |           |
       +||  Clients  |&lt;------------------------------&gt;|   Server  |
        +|           |                                |           |
         +-----------+                                |           |
              |||                                     +-----------+
              |||                                           |
              |||                                           |
              ||| Storage        +-----------+              |
              ||| Protocol       |+-----------+             |
              ||+----------------||+-----------+  Control   |
              |+-----------------|||           |    Protocol|
              +------------------+||  Storage  |------------+
                                  +|  Devices  |
                                   +-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this model, the clients, server, and storage devices are responsible for managing file access. This is in contrast to NFSv4 without pNFS, where it is primarily the server&#39;s responsibility; some of this responsibility may be delegated to the client under strictly specified conditions. See Section 12.2.5 for a discussion of the Storage Protocol. See Section 12.2.6 for a discussion of the Control Protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このモデルでは、クライアント、サーバー、およびストレージデバイスがファイルアクセスの管理を担当します。これは、主にサーバーの責任であるpNFSのないNFSv4とは対照的です。この責任の一部は、厳密に指定された条件下でクライアントに委任される場合があります。ストレージプロトコルの説明については、セクション12.2.5を参照してください。制御プロトコルの説明については、セクション12.2.6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFS takes the form of OPTIONAL operations that manage protocol objects called &#39;layouts&#39; (Section 12.2.7) that contain a byte-range and storage location information. The layout is managed in a similar fashion as NFSv4.1 data delegations. For example, the layout is leased, recallable, and revocable. However, layouts are distinct abstractions and are manipulated with new operations. When a client holds a layout, it is granted the ability to directly access the byte-range at the storage location specified in the layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSは、バイト範囲と格納場所の情報を含む「レイアウト」（セクション12.2.7）と呼ばれるプロトコルオブジェクトを管理するオプション操作の形式をとります。レイアウトは、NFSv4.1データ委任と同様の方法で管理されます。たとえば、レイアウトはリースされ、呼び出し可能で、取り消し可能です。ただし、レイアウトは明確な抽象化であり、新しい操作で操作されます。クライアントがレイアウトを保持している場合、レイアウトで指定された格納場所のバイト範囲に直接アクセスする機能が付与されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are interactions between layouts and other NFSv4.1 abstractions such as data delegations and byte-range locking. Delegation issues are discussed in Section 12.5.5. Byte-range locking issues are discussed in Sections 12.2.9 and 12.5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトと他のNFSv4.1抽象化の間には、データ委譲やバイト範囲ロックなどの相互作用があります。委任の問題については、セクション12.5.5で説明します。バイト範囲のロックの問題については、セクション12.2.9および12.5.1で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2--pNFS-Definitions">
12.2. pNFS Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. pNFS定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 NFSv4.1&#39;s pNFS feature provides parallel data access to a file system that stripes its content across multiple storage servers. The first instantiation of pNFS, as part of NFSv4.1, separates the file system protocol processing into two parts: metadata processing and data processing. Data consist of the contents of regular files that are striped across storage servers. Data striping occurs in at least two ways: on a file-by-file basis and, within sufficiently large files, on a block-by-block basis. In contrast, striped access to metadata by pNFS clients is not provided in NFSv4.1, even though the file system back end of a pNFS server might stripe metadata. Metadata consist of everything else, including the contents of non-regular files (e.g., directories); see Section 12.2.1. The metadata functionality is implemented by an NFSv4.1 server that supports pNFS and the operations described in Section 18; such a server is called a metadata server (Section 12.2.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFSv4.1のpNFS機能は、複数のストレージサーバー間でコンテンツをストライプ化するファイルシステムへの並列データアクセスを提供します。 NFSv4.1の一部としてのpNFSの最初のインスタンス化では、ファイルシステムプロトコルの処理が、メタデータ処理とデータ処理の2つの部分に分割されます。データは、ストレージサーバー間でストライプ化された通常のファイルの内容で構成されます。データストライピングは、少なくとも2つの方法で発生します。ファイルごと、および十分に大きいファイル内では、ブロックごとです。対照的に、pNFSサーバーのファイルシステムバックエンドがメタデータをストライプ化する場合でも、pNFSクライアントによるメタデータへのストライプ化アクセスはNFSv4.1では提供されません。メタデータは、通常以外のファイル（ディレクトリなど）の内容を含む、その他すべてのもので構成されます。セクション12.2.1を参照してください。メタデータ機能は、セクション18で説明されているpNFSおよび操作をサポートするNFSv4.1サーバーによって実装されます。このようなサーバーはメタデータサーバーと呼ばれます（セクション12.2.2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The data functionality is implemented by one or more storage devices, each of which are accessed by the client via a storage protocol. A subset (defined in Section 13.6) of NFSv4.1 is one such storage protocol. New terms are introduced to the NFSv4.1 nomenclature and existing terms are clarified to allow for the description of the pNFS feature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ機能は、1つ以上のストレージデバイスによって実装されます。各ストレージデバイスは、ストレージプロトコルを介してクライアントからアクセスされます。 NFSv4.1のサブセット（セクション13.6で定義）は、そのようなストレージプロトコルの1つです。 NFSv4.1の命名法に新しい用語が導入され、pNFS機能の説明を可能にするために既存の用語が明確になっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-1--Metadata">
12.2.1. Metadata
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.1. メタデータ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about a file system object, such as its name, location within the namespace, owner, ACL, and other attributes. Metadata may also include storage location information, and this will vary based on the underlying storage mechanism that is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前、名前空間内の場所、所有者、ACL、その他の属性など、ファイルシステムオブジェクトに関する情報。メタデータには保管場所情報も含まれる場合があり、これは使用される基礎となる保管メカニズムによって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-2--Metadata-Server">
12.2.2. Metadata Server
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.2. メタデータサーバー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An NFSv4.1 server that supports the pNFS feature. A variety of architectural choices exist for the metadata server and its use of file system information held at the server. Some servers may contain metadata only for file objects residing at the metadata server, while the file data resides on associated storage devices. Other metadata servers may hold both metadata and a varying degree of file data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFS機能をサポートするNFSv4.1サーバー。メタデータサーバーと、サーバーで保持されているファイルシステム情報の使用には、さまざまなアーキテクチャ上の選択肢があります。一部のサーバーには、メタデータサーバーにあるファイルオブジェクトのメタデータのみが含まれている場合がありますが、ファイルデータは関連するストレージデバイスにあります。他のメタデータサーバーは、メタデータとさまざまな程度のファイルデータの両方を保持できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-3--pNFS-Client">
12.2.3. pNFS Client
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.3. pNFSクライアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An NFSv4.1 client that supports pNFS operations and supports at least one storage protocol for performing I/O to storage devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFS操作をサポートし、ストレージデバイスへのI / Oを実行するための少なくとも1つのストレージプロトコルをサポートするNFSv4.1クライアント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-4--Storage-Device">
12.2.4. Storage Device
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.4. ストレージデバイス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A storage device stores a regular file&#39;s data, but leaves metadata management to the metadata server. A storage device could be another NFSv4.1 server, an object-based storage device (OSD), a block device accessed over a System Area Network (SAN, e.g., either FiberChannel or iSCSI SAN), or some other entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージデバイスは通常のファイルのデータを保存しますが、メタデータの管理はメタデータサーバーに任せます。ストレージデバイスは、別のNFSv4.1サーバー、オブジェクトベースのストレージデバイス（OSD）、システムエリアネットワーク（SAN、たとえば、FibreChannelまたはiSCSI SAN）を介してアクセスされるブロックデバイス、またはその他のエンティティです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-5--Storage-Protocol">
12.2.5. Storage Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.5. ストレージプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As noted in Figure 1, the storage protocol is the method used by the client to store and retrieve data directly from the storage devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図1に示すように、ストレージプロトコルは、クライアントがストレージデバイスから直接データを保存および取得するために使用する方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 pNFS feature has been structured to allow for a variety of storage protocols to be defined and used. One example storage protocol is NFSv4.1 itself (as documented in Section 13). Other options for the storage protocol are described elsewhere and include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 pNFS機能は、さまざまなストレージプロトコルを定義して使用できるように構成されています。ストレージプロトコルの1つの例は、NFSv4.1自体です（セクション13で説明）。ストレージプロトコルの他のオプションについては、他の場所で説明しており、次のものが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Block/volume protocols such as Internet SCSI (iSCSI) [48] and FCP [49]. The block/volume protocol support can be independent of the addressing structure of the block/volume protocol used, allowing more than one protocol to access the same file data and enabling extensibility to other block/volume protocols. See [41] for a layout specification that allows pNFS to use block/volume storage protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o インターネットSCSI（iSCSI）[48]やFCP [49]などのブロック/ボリュームプロトコル。ブロック/ボリュームプロトコルのサポートは、使用するブロック/ボリュームプロトコルのアドレッシング構造に依存しないため、複数のプロトコルが同じファイルデータにアクセスし、他のブロック/ボリュームプロトコルへの拡張性を実現できます。 pNFSがブロック/ボリュームストレージプロトコルを使用できるようにするレイアウト仕様については、[41]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Object protocols such as OSD over iSCSI or Fibre Channel [50]. See [40] for a layout specification that allows pNFS to use object storage protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OSD over iSCSIやファイバーチャネルなどのオブジェクトプロトコル[50]。 pNFSがオブジェクトストレージプロトコルを使用できるようにするレイアウト仕様については、[40]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible that various storage protocols are available to both client and server and it may be possible that a client and server do not have a matching storage protocol available to them. Because of this, the pNFS server MUST support normal NFSv4.1 access to any file accessible by the pNFS feature; this will allow for continued interoperability between an NFSv4.1 client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーの両方でさまざまなストレージプロトコルを使用できる可能性があります。また、クライアントとサーバーで、対応するストレージプロトコルを使用できない可能性もあります。このため、pNFSサーバーは、pNFS機能によってアクセス可能なファイルへの通常のNFSv4.1アクセスをサポートする必要があります。これにより、NFSv4.1クライアントとサーバー間の継続的な相互運用が可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-6--Control-Protocol">
12.2.6. Control Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.6. 制御プロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As noted in Figure 1, the control protocol is used by the exported file system between the metadata server and storage devices. Specification of such protocols is outside the scope of the NFSv4.1 protocol. Such control protocols would be used to control activities such as the allocation and deallocation of storage, the management of state required by the storage devices to perform client access control, and, depending on the storage protocol, the enforcement of authentication and authorization so that restrictions that would be enforced by the metadata server are also enforced by the storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図1に示されているように、制御プロトコルは、メタデータサーバーとストレージデバイス間のエクスポートファイルシステムによって使用されます。このようなプロトコルの仕様は、NFSv4.1プロトコルの範囲外です。このような制御プロトコルは、ストレージの割り当てや割り当て解除、クライアントアクセス制御を実行するためにストレージデバイスが必要とする状態の管理などのアクティビティを制御するために使用されます。メタデータサーバーによって強制されるものは、ストレージデバイスによっても強制されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A particular control protocol is not REQUIRED by NFSv4.1 but requirements are placed on the control protocol for maintaining attributes like modify time, the change attribute, and the end-of-file (EOF) position. Note that if pNFS is layered over a clustered, parallel file system (e.g., PVFS [51]), the mechanisms that enable clustering and parallelism in that file system can be considered the control protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
特定の制御プロトコルはNFSv4.1では必須ではありませんが、変更時刻、変更属性、ファイルの終わり（EOF）位置などの属性を維持するための要件が​​制御プロトコルに課されます。 pNFSがクラスター化された並列ファイルシステム（PVFS [51]など）の上に階層化されている場合、そのファイルシステムでクラスター化と並列処理を可能にするメカニズムは、制御プロトコルと見なすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-7--Layout-Types">
12.2.7. Layout Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.7. レイアウトの種類
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A layout describes the mapping of a file&#39;s data to the storage devices that hold the data. A layout is said to belong to a specific layout type (data type layouttype4, see Section 3.3.13). The layout type allows for variants to handle different storage protocols, such as those associated with block/volume [41], object [40], and file (Section 13) layout types. A metadata server, along with its control protocol, MUST support at least one layout type. A private sub-range of the layout type namespace is also defined. Values from the private layout type range MAY be used for internal testing or experimentation (see Section 3.3.13).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトは、データを保持するストレージデバイスへのファイルのデータのマッピングを記述します。レイアウトは特定のレイアウトタイプに属していると言われます（データタイプlayouttype4、セクション3.3.13を参照）。レイアウトタイプにより、バリアントは、ブロック/ボリューム[41]、オブジェクト[40]、ファイル（セクション13）レイアウトタイプに関連付けられたものなど、さまざまなストレージプロトコルを処理できます。メタデータサーバーは、その制御プロトコルとともに、少なくとも1つのレイアウトタイプをサポートする必要があります。レイアウトタイプ名前空間のプライベートサブレンジも定義されています。プライベートレイアウトタイプの範囲の値は、内部テストまたは実験に使用できます（セクション3.3.13を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example, the organization of the file layout type could be an array of tuples (e.g., device ID, filehandle), along with a definition of how the data is stored across the devices (e.g., striping). A block/volume layout might be an array of tuples that store &lt;device ID, block number, block count&gt; along with information about block size and the associated file offset of the block number. An object layout might be an array of tuples &lt;device ID, object ID&gt; and an additional structure (i.e., the aggregation map) that defines how the logical byte sequence of the file data is serialized into the different objects. Note that the actual layouts are typically more complex than these simple expository examples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例として、ファイルレイアウトタイプの編成は、デバイス間でのデータの格納方法の定義（たとえば、ストライピング）とともに、タプルの配列（たとえば、デバイスID、ファイルハンドル）にすることができます。ブロック/ボリュームレイアウトは、&lt;デバイスID、ブロック番号、ブロックカウント&gt;を格納するタプルの配列であり、ブロックサイズおよびブロック番号の関連ファイルオフセットに関する情報が含まれる場合があります。オブジェクトレイアウトは、タプル&lt;デバイスID、オブジェクトID&gt;の配列と、ファイルデータの論理バイトシーケンスをさまざまなオブジェクトにシリアル化する方法を定義する追加の構造（つまり、集計マップ）にすることができます。実際のレイアウトは通常、これらの単純な説明の例よりも複雑であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Requests for pNFS-related operations will often specify a layout type. Examples of such operations are GETDEVICEINFO and LAYOUTGET. The response for these operations will include structures such as a device_addr4 or a layout4, each of which includes a layout type within it. The layout type sent by the server MUST always be the same one requested by the client. When a server sends a response that includes a different layout type, the client SHOULD ignore the response and behave as if the server had returned an error response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFS関連の操作のリクエストでは、レイアウトタイプを指定することがよくあります。このような操作の例は、GETDEVICEINFOおよびLAYOUTGETです。これらの操作の応答には、device_addr4やlayout4などの構造が含まれ、それぞれにレイアウトタイプが含まれます。サーバーから送信されるレイアウトタイプは、常にクライアントから要求されたものと同じでなければなりません。サーバーが異なるレイアウトタイプを含む応答を送信すると、クライアントはその応答を無視して、サーバーがエラー応答を返したかのように動作する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-8--Layout">
12.2.8. Layout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.8. レイアウト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A layout defines how a file&#39;s data is organized on one or more storage devices. There are many potential layout types; each of the layout types are differentiated by the storage protocol used to access data and by the aggregation scheme that lays out the file data on the underlying storage devices. A layout is precisely identified by the tuple &lt;client ID, filehandle, layout type, iomode, range&gt;, where filehandle refers to the filehandle of the file on the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトは、ファイルのデータが1つ以上のストレージデバイス上でどのように編成されるかを定義します。多くの潜在的なレイアウトタイプがあります。各レイアウトタイプは、データへのアクセスに使用されるストレージプロトコルと、基になるストレージデバイスにファイルデータをレイアウトする集約方式によって区別されます。レイアウトは、タプル&lt;クライアントID、ファイルハンドル、レイアウトタイプ、iomode、範囲&gt;によって正確に識別されます。ファイルハンドルは、メタデータサーバー上のファイルのファイルハンドルを指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is important to define when layouts overlap and/or conflict with each other. For two layouts with overlapping byte-ranges to actually overlap each other, both layouts must be of the same layout type, correspond to the same filehandle, and have the same iomode. Layouts conflict when they overlap and differ in the content of the layout (i.e., the storage device/file mapping parameters differ). Note that differing iomodes do not lead to conflicting layouts. It is permissible for layouts with different iomodes, pertaining to the same byte-range, to be held by the same client. An example of this would be copy-on-write functionality for a block/volume layout type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトが重複したり競合したりするタイミングを定義することが重要です。重複するバイト範囲を持つ2つのレイアウトが実際に互いにオーバーラップするには、両方のレイアウトが同じレイアウトタイプで、同じファイルハンドルに対応し、同じiomodeである必要があります。レイアウトが重複し、レイアウトの内容が異なる場合（つまり、ストレージデバイス/ファイルマッピングパラメーターが異なる場合）、レイアウトは競合します。異なるiomodeが原因でレイアウトが競合することはありません。同じバイト範囲に関連する異なるiomodeのレイアウトが同じクライアントによって保持されることは許容されます。この例は、ブロック/ボリュームレイアウトタイプのコピーオンライト機能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-9--Layout-Iomode">
12.2.9. Layout Iomode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.9. レイアウトIomode
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layout iomode (data type layoutiomode4, see Section 3.3.20) indicates to the metadata server the client&#39;s intent to perform either just READ operations or a mixture containing READ and WRITE operations. For certain layout types, it is useful for a client to specify this intent at the time it sends LAYOUTGET (Section 18.43). For example, for block/volume-based protocols, block allocation could occur when a LAYOUTIOMODE4_RW iomode is specified. A special LAYOUTIOMODE4_ANY iomode is defined and can only be used for LAYOUTRETURN and CB_LAYOUTRECALL, not for LAYOUTGET. It specifies that layouts pertaining to both LAYOUTIOMODE4_READ and LAYOUTIOMODE4_RW iomodes are being returned or recalled, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトiomode（データタイプlayoutiomode4、セクション3.3.20を参照）は、クライアントがREAD操作のみ、またはREAD操作とWRITE操作を含む混合操作を実行する意図をメタデータサーバーに示します。特定のレイアウトタイプでは、クライアントがLAYOUTGETを送信するときにこのインテントを指定すると便利です（セクション18.43）。たとえば、ブロック/ボリュームベースのプロトコルの場合、LAYOUTIOMODE4_RW iomodeが指定されていると、ブロック割り当てが発生する可能性があります。特別なLAYOUTIOMODE4_ANY iomodeが定義されており、LAYOUTRETURNおよびCB_LAYOUTRECALLにのみ使用でき、LAYOUTGETには使用できません。これは、LAYOUTIOMODE4_READとLAYOUTIOMODE4_RW iomodeの両方に関連するレイアウトがそれぞれ返されるか再呼び出しされることを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A storage device may validate I/O with regard to the iomode; this is dependent upon storage device implementation and layout type. Thus, if the client&#39;s layout iomode is inconsistent with the I/O being performed, the storage device may reject the client&#39;s I/O with an error indicating that a new layout with the correct iomode should be obtained via LAYOUTGET. For example, if a client gets a layout with a LAYOUTIOMODE4_READ iomode and performs a WRITE to a storage device, the storage device is allowed to reject that WRITE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージデバイスは、iomodeに関してI / Oを検証できます。これは、ストレージデバイスの実装とレイアウトタイプによって異なります。したがって、クライアントのレイアウトiomodeが実行中のI / Oと一致しない場合、ストレージデバイスは、正しいiomodeの新しいレイアウトをLAYOUTGET経由で取得する必要があることを示すエラーでクライアントのI / Oを拒否することがあります。たとえば、クライアントがLAYOUTIOMODE4_READ iomodeでレイアウトを取得し、ストレージデバイスへの書き込みを実行すると、ストレージデバイスはその書き込みを拒否できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of the layout iomode does not conflict with OPEN share modes or byte-range LOCK operations; open share mode and byte-range lock conflicts are enforced as they are without the use of pNFS and are logically separate from the pNFS layout level. Open share modes and byte-range locks are the preferred method for restricting user access to data files. For example, an OPEN of OPEN4_SHARE_ACCESS_WRITE does not conflict with a LAYOUTGET containing an iomode of LAYOUTIOMODE4_RW performed by another client. Applications that depend on writing into the same file concurrently may use byte-range locking to serialize their accesses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトiomodeの使用は、OPEN共有モードまたはバイト範囲LOCK操作と競合しません。オープン共有モードとバイト範囲ロックの競合は、pNFSを使用せず、pNFSレイアウトレベルから論理的に分離されているため、強制されます。オープン共有モードとバイト範囲ロックは、データファイルへのユーザーアクセスを制限するための推奨される方法です。たとえば、OPEN4_SHARE_ACCESS_WRITEのOPENは、別のクライアントが実行したLAYOUTIOMODE4_RWのiomodeを含むLAYOUTGETと競合しません。同じファイルへの同時書き込みに依存するアプリケーションは、バイト範囲ロックを使用してアクセスをシリアル化できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-10--Device-IDs">
12.2.10. Device IDs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.10. デバイスID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The device ID (data type deviceid4, see Section 3.3.14) identifies a group of storage devices. The scope of a device ID is the pair &lt;client ID, layout type&gt;. In practice, a significant amount of information may be required to fully address a storage device. Rather than embedding all such information in a layout, layouts embed device IDs. The NFSv4.1 operation GETDEVICEINFO (Section 18.40) is used to retrieve the complete address information (including all device addresses for the device ID) regarding the storage device according to its layout type and device ID. For example, the address of an NFSv4.1 data server or of an object-based storage device could be an IP address and port. The address of a block storage device could be a volume label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デバイスID（データタイプdeviceid4、セクション3.3.14を参照）は、ストレージデバイスのグループを識別します。デバイスIDのスコープは、&lt;クライアントID、レイアウトタイプ&gt;のペアです。実際には、ストレージデバイスを完全にアドレス指定するには、かなりの量の情報が必要になる場合があります。このような情報をすべてレイアウトに埋め込むのではなく、レイアウトはデバイスIDを埋め込みます。 NFSv4.1オペレーションGETDEVICEINFO（セクション18.40）は、レイアウトタイプとデバイスIDに従ってストレージデバイスに関する完全なアドレス情報（デバイスIDのすべてのデバイスアドレスを含む）を取得するために使用されます。たとえば、NFSv4.1データサーバーまたはオブジェクトベースのストレージデバイスのアドレスは、IPアドレスとポートにすることができます。ブロックストレージデバイスのアドレスは、ボリュームラベルにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients cannot expect the mapping between a device ID and its storage device address(es) to persist across metadata server restart. See Section 12.7.4 for a description of how recovery works in that situation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、メタデータサーバーの再起動後もデバイスIDとそのストレージデバイスアドレス間のマッピングが持続することを期待できません。そのような状況で回復がどのように機能するかについては、セクション12.7.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A device ID lives as long as there is a layout referring to the device ID. If there are no layouts referring to the device ID, the server is free to delete the device ID any time. Once a device ID is deleted by the server, the server MUST NOT reuse the device ID for the same layout type and client ID again. This requirement is feasible because the device ID is 16 bytes long, leaving sufficient room to store a generation number if the server&#39;s implementation requires most of the rest of the device ID&#39;s content to be reused. This requirement is necessary because otherwise the race conditions between asynchronous notification of device ID addition and deletion would be too difficult to sort out.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デバイスIDを参照するレイアウトがある限り、デバイスIDは存続します。デバイスIDを参照するレイアウトがない場合、サーバーはいつでもデバイスIDを自由に削除できます。サーバーによってデバイスIDが削除されると、サーバーは同じレイアウトタイプとクライアントIDのデバイスIDを再利用してはなりません（MUST NOT）。サーバーIDの残りのデバイスIDのコンテンツの大部分を再利用する必要がある場合は、デバイスIDが16バイトの長さであり、世代番号を保存する十分なスペースを残すため、この要件は実現可能です。そうしないと、デバイスIDの追加と削除の非同期通知間の競合状態を解決するのが困難になるため、この要件が必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Device ID to device address mappings are not leased, and can be changed at any time. (Note that while device ID to device address mappings are likely to change after the metadata server restarts, the server is not required to change the mappings.) A server has two choices for changing mappings. It can recall all layouts referring to the device ID or it can use a notification mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デバイスIDからデバイスアドレスへのマッピングはリースされておらず、いつでも変更できます。 （デバイスIDからデバイスアドレスへのマッピングはメタデータサーバーの再起動後に変更される可能性がありますが、サーバーはマッピングを変更する必要はありません。）サーバーにはマッピングを変更するための2つの選択肢があります。デバイスIDを参照するすべてのレイアウトを呼び出すか、通知メカニズムを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 protocol has no optimal way to recall all layouts that referred to a particular device ID (unless the server associates a single device ID with a single fsid or a single client ID; in which case, CB_LAYOUTRECALL has options for recalling all layouts associated with the fsid, client ID pair, or just the client ID).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1プロトコルには、特定のデバイスIDを参照するすべてのレイアウトを呼び出すための最適な方法はありません（サーバーが単一のデバイスIDを単一のfsidまたは単一のクライアントIDに関連付ける場合を除く）。この場合、CB_LAYOUTRECALLにはすべてのレイアウトを呼び出すオプションがありますfsid、クライアントIDペア、またはクライアントIDのみに関連付けられています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Via a notification mechanism (see Section 20.12), device ID to device address mappings can change over the duration of server operation without recalling or revoking the layouts that refer to device ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知メカニズム（セクション20.12を参照）を介して、デバイスIDからデバイスアドレスへのマッピングは、デバイスIDを参照するレイアウトを呼び出したり取り消したりすることなく、サーバー操作の期間中に変更できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notification mechanism can also delete a device ID, but only if the client has no layouts referring to the device ID. A notification of a change to a device ID to device address mapping will immediately or eventually invalidate some or all of the device ID&#39;s mappings. The server MUST support notifications and the client must request them before they can be used. For further information about the notification types Section 20.12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知メカニズムはデバイスIDを削除することもできますが、クライアントにデバイスIDを参照するレイアウトがない場合のみです。デバイスIDからデバイスアドレスへのマッピングの変更の通知は、デバイスIDのマッピングの一部またはすべてをただちにまたは最終的に無効にします。サーバーは通知をサポートする必要があり、クライアントは通知を使用する前にそれらを要求する必要があります。通知タイプの詳細については、セクション20.12を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-3--pNFS-Operations">
12.3. pNFS Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3. pNFS操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 has several operations that are needed for pNFS servers, regardless of layout type or storage protocol. These operations are all sent to a metadata server and summarized here. While pNFS is an OPTIONAL feature, if pNFS is implemented, some operations are REQUIRED in order to comply with pNFS. See Section 17.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1には、レイアウトタイプやストレージプロトコルに関係なく、pNFSサーバーに必要ないくつかの操作があります。これらの操作はすべてメタデータサーバーに送信され、ここで要約されます。 pNFSはオプションの機能ですが、pNFSが実装されている場合、pNFSに準拠するために一部の操作が必要です。セクション17を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These are the fore channel pNFS operations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらは、フォアチャネルのpNFS操作です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETDEVICEINFO (Section 18.40), as noted previously (Section 12.2.10), returns the mapping of device ID to storage device address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETDEVICEINFO（セクション18.40）は、前述のとおり（セクション12.2.10）、デバイスIDのストレージデバイスアドレスへのマッピングを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETDEVICELIST (Section 18.41) allows clients to fetch all device IDs for a specific file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETDEVICELIST（セクション18.41）を使用すると、クライアントは特定のファイルシステムのすべてのデバイスIDをフェッチできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTGET (Section 18.43) is used by a client to get a layout for a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTGET（セクション18.43）は、クライアントがファイルのレイアウトを取得するために使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTCOMMIT (Section 18.42) is used to inform the metadata server of the client&#39;s intent to commit data that has been written to the storage device (the storage device as originally indicated in the return value of LAYOUTGET).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTCOMMIT（セクション18.42）は、ストレージデバイス（LAYOUTGETの戻り値で最初に示されたストレージデバイス）に書き込まれたデータをコミットするクライアントの意図をメタデータサーバーに通知するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTRETURN (Section 18.44) is used to return layouts for a file, a file system ID (FSID), or a client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTRETURN（セクション18.44）は、ファイル、ファイルシステムID（FSID）、またはクライアントIDのレイアウトを返すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These are the backchannel pNFS operations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらは、バックチャネルpNFS操作です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_LAYOUTRECALL (Section 20.3) recalls a layout, all layouts belonging to a file system, or all layouts belonging to a client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_LAYOUTRECALL（セクション20.3）は、レイアウト、ファイルシステムに属するすべてのレイアウト、またはクライアントIDに属するすべてのレイアウトを呼び出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_RECALL_ANY (Section 20.6) tells a client that it needs to return some number of recallable objects, including layouts, to the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_RECALL_ANY（セクション20.6）は、レイアウトを含むいくつかの再呼び出し可能なオブジェクトをメタデータサーバーに返す必要があることをクライアントに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_RECALLABLE_OBJ_AVAIL (Section 20.7) tells a client that a recallable object that it was denied (in case of pNFS, a layout denied by LAYOUTGET) due to resource exhaustion is now available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_RECALLABLE_OBJ_AVAIL（セクション20.7）は、リソースの枯渇が原因で拒否された（pNFSの場合、LAYOUTGETによって拒否されたレイアウト）呼び出し可能オブジェクトが使用可能になったことをクライアントに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_NOTIFY_DEVICEID (Section 20.12) notifies the client of changes to device IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_NOTIFY_DEVICEID（セクション20.12）は、デバイスIDの変更をクライアントに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-4--pNFS-Attributes">
12.4. pNFS Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.4. pNFS属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number of attributes specific to pNFS are listed and described in Section 5.12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSに固有の多数の属性がリストされ、セクション5.12で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5--Layout-Semantics">
12.5. Layout Semantics
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5. レイアウトセマンティクス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-1--Guarantees-Provided-by-Layouts">
12.5.1. Guarantees Provided by Layouts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.1. レイアウトによって提供される保証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Layouts grant to the client the ability to access data located at a storage device with the appropriate storage protocol. The client is guaranteed the layout will be recalled when one of two things occur: either a conflicting layout is requested or the state encapsulated by the layout becomes invalid (this can happen when an event directly or indirectly modifies the layout). When a layout is recalled and returned by the client, the client continues with the ability to access file data with normal NFSv4.1 operations through the metadata server. Only the ability to access the storage devices is affected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトは、適切なストレージプロトコルを使用して、ストレージデバイスにあるデータにアクセスする機能をクライアントに付与します。クライアントは、競合するレイアウトが要求されるか、レイアウトによってカプセル化された状態が無効になる（イベントがレイアウトを直接または間接的に変更したときに発生する可能性があります）のいずれかが発生したときに、レイアウトがリコールされることを保証します。レイアウトがクライアントによって呼び出されて返されると、クライアントはメタデータサーバーを介して通常のNFSv4.1操作でファイルデータにアクセスする機能を継続します。ストレージデバイスにアクセスする機能のみが影響を受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The requirement of NFSv4.1 that all user access rights MUST be obtained through the appropriate OPEN, LOCK, and ACCESS operations is not modified with the existence of layouts. Layouts are provided to NFSv4.1 clients, and user access still follows the rules of the protocol as if they did not exist. It is a requirement that for a client to access a storage device, a layout must be held by the client. If a storage device receives an I/O request for a byte-range for which the client does not hold a layout, the storage device SHOULD reject that I/O request. Note that the act of modifying a file for which a layout is held does not necessarily conflict with the holding of the layout that describes the file being modified. Therefore, it is the requirement of the storage protocol or layout type that determines the necessary behavior. For example, block/ volume layout types require that the layout&#39;s iomode agree with the type of I/O being performed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのユーザーアクセス権が適切なOPEN、LOCK、ACCESS操作を通じて取得されなければならないというNFSv4.1の要件は、レイアウトの存在によって変更されていません。レイアウトはNFSv4.1クライアントに提供され、ユーザーアクセスはまだ存在しないかのようにプロトコルのルールに従います。クライアントがストレージデバイスにアクセスするには、クライアントがレイアウトを保持する必要があります。ストレージデバイスが、クライアントがレイアウトを保持していないバイト範囲のI / O要求を受信した場合、ストレージデバイスはそのI / O要求を拒否する必要があります（SHOULD）。レイアウトが保持されているファイルを変更する動作は、変更されるファイルを記述するレイアウトの保持と必ずしも競合しないことに注意してください。したがって、必要な動作を決定するのは、ストレージプロトコルまたはレイアウトタイプの要件です。たとえば、ブロック/ボリュームレイアウトタイプでは、レイアウトのiomodeが実行されるI / Oのタイプと一致する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Depending upon the layout type and storage protocol in use, storage device access permissions may be granted by LAYOUTGET and may be encoded within the type-specific layout. For an example of storage device access permissions, see an object-based protocol such as [50]. If access permissions are encoded within the layout, the metadata server SHOULD recall the layout when those permissions become invalid for any reason -- for example, when a file becomes unwritable or inaccessible to a client. Note, clients are still required to perform the appropriate OPEN, LOCK, and ACCESS operations as described above. The degree to which it is possible for the client to circumvent these operations and the consequences of doing so must be clearly specified by the individual layout type specifications. In addition, these specifications must be clear about the requirements and non-requirements for the checking performed by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
レイアウトタイプと使用中のストレージプロトコルに応じて、ストレージデバイスのアクセス許可はLAYOUTGETによって付与され、タイプ固有のレイアウト内にエンコードされます。ストレージデバイスのアクセス許可の例については、[50]などのオブジェクトベースのプロトコルを参照してください。アクセス許可がレイアウト内でエンコードされている場合、メタデータサーバーは、たとえばファイルがクライアントから書き込めなくなったりアクセスできなくなったりした場合など、何らかの理由でそれらのアクセス許可が無効になったときにレイアウトを再呼び出しする必要があります（SHOULD）。上記のように、クライアントは依然として適切なOPEN、LOCK、ACCESS操作を実行する必要があることに注意してください。クライアントがこれらの操作を回避することが可能である度合いとその結果は、個々のレイアウトタイプの仕様で明確に指定する必要があります。さらに、これらの仕様は、サーバーによって実行されるチェックの要件と非要件について明確でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the presence of pNFS functionality, mandatory byte-range locks MUST behave as they would without pNFS. Therefore, if mandatory file locks and layouts are provided simultaneously, the storage device MUST be able to enforce the mandatory byte-range locks. For example, if one client obtains a mandatory byte-range lock and a second client accesses the storage device, the storage device MUST appropriately restrict I/O for the range of the mandatory byte-range lock. If the storage device is incapable of providing this check in the presence of mandatory byte-range locks, then the metadata server MUST NOT grant layouts and mandatory byte-range locks simultaneously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFS機能が存在する場合、必須のバイト範囲ロックは、pNFSがない場合と同様に動作する必要があります。したがって、必須のファイルロックとレイアウトが同時に提供される場合、ストレージデバイスは必須のバイト範囲ロックを強制できる必要があります。たとえば、1つのクライアントが必須のバイト範囲ロックを取得し、2番目のクライアントがストレージデバイスにアクセスする場合、ストレージデバイスは必須のバイト範囲ロックの範囲のI / Oを適切に制限する必要があります。ストレージデバイスが必須のバイト範囲ロックの存在下でこのチェックを提供できない場合、メタデータサーバーはレイアウトと必須のバイト範囲ロックを同時に許可してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-2--Getting-a-Layout">
12.5.2. Getting a Layout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.2. レイアウトを取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client obtains a layout with the LAYOUTGET operation. The metadata server will grant layouts of a particular type (e.g., block/volume, object, or file). The client selects an appropriate layout type that the server supports and the client is prepared to use. The layout returned to the client might not exactly match the requested byte-range as described in Section 18.43.3. As needed a client may send multiple LAYOUTGET operations; these might result in multiple overlapping, non-conflicting layouts (see Section 12.2.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、LAYOUTGET操作でレイアウトを取得します。メタデータサーバーは、特定のタイプ（ブロック/ボリューム、オブジェクト、ファイルなど）のレイアウトを許可します。クライアントは、サーバーがサポートする適切なレイアウトタイプを選択し、クライアントは使用する準備ができています。セクション18.43.3で説明されているように、クライアントに返されるレイアウトは、要求されたバイト範囲と正確に一致しない場合があります。必要に応じて、クライアントは複数のLAYOUTGET操作を送信できます。これらは、複数の重複しない、競合しないレイアウトになる可能性があります（セクション12.2.8を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to get a layout, the client must first have opened the file via the OPEN operation. When a client has no layout on a file, it MUST present an open stateid, a delegation stateid, or a byte-range lock stateid in the loga_stateid argument. A successful LAYOUTGET result includes a layout stateid. The first successful LAYOUTGET processed by the server using a non-layout stateid as an argument MUST have the &#34;seqid&#34; field of the layout stateid in the response set to one. Thereafter, the client MUST use a layout stateid (see Section 12.5.3) on future invocations of LAYOUTGET on the file, and the &#34;seqid&#34; MUST NOT be set to zero. Once the layout has been retrieved, it can be held across multiple OPEN and CLOSE sequences. Therefore, a client may hold a layout for a file that is not currently open by any user on the client. This allows for the caching of layouts beyond CLOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトを取得するには、クライアントが最初にOPEN操作でファイルを開いている必要があります。クライアントにファイルのレイアウトがない場合、loga_stateid引数にオープン状態ID、委任状態ID、またはバイト範囲ロック状態IDを提示する必要があります。正常なLAYOUTGET結果には、レイアウトのstateidが含まれます。引数として非レイアウト状態IDを使用してサーバーによって処理される最初の成功したLAYOUTGETは、応答のレイアウト状態IDの「seqid」フィールドを1に設定する必要があります。その後、クライアントはファイルのLAYOUTGETの今後の呼び出しでレイアウト状態ID（セクション12.5.3を参照）を使用する必要があり、「seqid」をゼロに設定してはなりません（MUST NOT）。レイアウトが取得されると、複数のOPENおよびCLOSEシーケンスにわたって保持できます。したがって、クライアントは、クライアント上のどのユーザーも現在開いていないファイルのレイアウトを保持する場合があります。これにより、CLOSEを超えたレイアウトのキャッシュが可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The storage protocol used by the client to access the data on the storage device is determined by the layout&#39;s type. The client is responsible for matching the layout type with an available method to interpret and use the layout. The method for this layout type selection is outside the scope of the pNFS functionality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがストレージデバイス上のデータにアクセスするために使用するストレージプロトコルは、レイアウトのタイプによって決まります。クライアントは、レイアウトタイプを、レイアウトを解釈して使用するために利用可能なメソッドと照合する責任があります。このレイアウトタイプの選択方法は、pNFS機能の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the metadata server is in control of the layout for a file, the pNFS client can provide hints to the server when a file is opened or created about the preferred layout type and aggregation schemes. pNFS introduces a layout_hint attribute (Section 5.12.4) that the client can set at file creation time to provide a hint to the server for new files. Setting this attribute separately, after the file has been created might make it difficult, or impossible, for the server implementation to comply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーはファイルのレイアウトを制御しますが、pNFSクライアントは、ファイルが開かれたとき、または作成されたときに、推奨されるレイアウトタイプと集計方式に関するヒントをサーバーに提供できます。 pNFSでは、クライアントがファイル作成時に設定して、サーバーに新しいファイルのヒントを提供できるlayout_hint属性（5.12.4節）が導入されています。ファイルの作成後にこの属性を個別に設定すると、サーバーの実装に準拠することが困難または不可能になる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the EXCLUSIVE4 createmode4 does not allow the setting of attributes at file creation time, NFSv4.1 introduces the EXCLUSIVE4_1 createmode4, which does allow attributes to be set at file creation time. In addition, if the session is created with persistent reply caches, EXCLUSIVE4_1 is neither necessary nor allowed. Instead, GUARDED4 both works better and is prescribed. Table 10 in Section 18.16.3 summarizes how a client is allowed to send an exclusive create.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCLUSIVE4 createmode4ではファイル作成時に属性を設定できないため、NFSv4.1ではEXCLUSIVE4_1 createmode4が導入されており、ファイル作成時に属性を設定できます。さらに、セッションが永続的な応答キャッシュを使用して作成されている場合、EXCLUSIVE4_1は必要も許可もされません。代わりに、GUARDED4の方が効果的であり、規定されています。セクション18.16.3の表10は、クライアントがどのように排他的作成を送信できるかをまとめたものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-3--Layout-Stateid">
12.5.3. Layout Stateid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.3. レイアウト状態ID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with all other stateids, the layout stateid consists of a &#34;seqid&#34; and &#34;other&#34; field. Once a layout stateid is established, the &#34;other&#34; field will stay constant unless the stateid is revoked or the client returns all layouts on the file and the server disposes of the stateid. The &#34;seqid&#34; field is initially set to one, and is never zero on any NFSv4.1 operation that uses layout stateids, whether it is a fore channel or backchannel operation. After the layout stateid is established, the server increments by one the value of the &#34;seqid&#34; in each subsequent LAYOUTGET and LAYOUTRETURN response, and in each CB_LAYOUTRECALL request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のすべての状態IDと同様に、レイアウト状態IDは「seqid」および「other」フィールドで構成されます。レイアウト状態IDが確立されると、「その他」フィールドは、状態IDが取り消されるか、クライアントがファイルのすべてのレイアウトを返し、サーバーが状態IDを破棄しない限り、一定のままになります。 「seqid」フィールドは最初は1に設定されており、それがフォアチャネル操作であるかバックチャネル操作であるかにかかわらず、レイアウト状態IDを使用するNFSv4.1操作では決してゼロにはなりません。レイアウト状態IDが確立された後、サーバーは、後続の各LAYOUTGETおよびLAYOUTRETURN応答、および各CB_LAYOUTRECALL要求で「seqid」の値を1つずつ増やします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given the design goal of pNFS to provide parallelism, the layout stateid differs from other stateid types in that the client is expected to send LAYOUTGET and LAYOUTRETURN operations in parallel. The &#34;seqid&#34; value is used by the client to properly sort responses to LAYOUTGET and LAYOUTRETURN. The &#34;seqid&#34; is also used to prevent race conditions between LAYOUTGET and CB_LAYOUTRECALL. Given that the processing rules differ from layout stateids and other stateid types, only the pNFS sections of this document should be considered to determine proper layout stateid handling.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
並列処理を提供するというpNFSの設計目標を考えると、レイアウトstateidは、クライアントがLAYOUTGETおよびLAYOUTRETURN操作を並行して送信することが期待されるという点で、他のstateidタイプとは異なります。 「seqid」値は、クライアントがLAYOUTGETおよびLAYOUTRETURNへの応答を適切にソートするために使用されます。 「seqid」は、LAYOUTGETとCB_LAYOUTRECALLの間の競合状態を防ぐためにも使用されます。処理ルールがレイアウトステートIDおよび他のステートIDタイプと異なる場合、適切なレイアウトステートIDの処理を決定するには、このドキュメントのpNFSセクションのみを検討する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the client receives a layout stateid, it MUST use the correct &#34;seqid&#34; for subsequent LAYOUTGET or LAYOUTRETURN operations. The correct &#34;seqid&#34; is defined as the highest &#34;seqid&#34; value from responses of fully processed LAYOUTGET or LAYOUTRETURN operations or arguments of a fully processed CB_LAYOUTRECALL operation. Since the server is incrementing the &#34;seqid&#34; value on each layout operation, the client may determine the order of operation processing by inspecting the &#34;seqid&#34; value. In the case of overlapping layout ranges, the ordering information will provide the client the knowledge of which layout ranges are held. Note that overlapping layout ranges may occur because of the client&#39;s specific requests or because the server is allowed to expand the range of a requested layout and notify the client in the LAYOUTRETURN results. Additional layout stateid sequencing requirements are provided in Section 12.5.5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがレイアウト状態IDを受信すると、後続のLAYOUTGETまたはLAYOUTRETURN操作で正しい「seqid」を使用する必要があります。正しい「seqid」は、完全に処理されたLAYOUTGETまたはLAYOUTRETURN操作の応答、または完全に処理されたCB_LAYOUTRECALL操作の引数からの最高の「seqid」値として定義されます。サーバーは各レイアウト操作で「seqid」値をインクリメントしているため、クライアントは「seqid」値を検査することで操作処理の順序を決定できます。レイアウト範囲が重複している場合、注文情報により、クライアントはどのレイアウト範囲が保持されているかを知ることができます。クライアントの特定の要求が原因で、またはサーバーが要求されたレイアウトの範囲を拡張し、LAYOUTRETURN結果でクライアントに通知できるため、レイアウト範囲の重複が発生する可能性があることに注意してください。追加のレイアウトステートIDシーケンス要件は、セクション12.5.5.2で提供されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client&#39;s receipt of a &#34;seqid&#34; is not sufficient for subsequent use. The client must fully process the operations before the &#34;seqid&#34; can be used. For LAYOUTGET results, if the client is not using the forgetful model (Section 12.5.5.1), it MUST first update its record of what ranges of the file&#39;s layout it has before using the seqid. For LAYOUTRETURN results, the client MUST delete the range from its record of what ranges of the file&#39;s layout it had before using the seqid. For CB_LAYOUTRECALL arguments, the client MUST send a response to the recall before using the seqid. The fundamental requirement in client processing is that the &#34;seqid&#34; is used to provide the order of processing. LAYOUTGET results may be processed in parallel. LAYOUTRETURN results may be processed in parallel. LAYOUTGET and LAYOUTRETURN responses may be processed in parallel as long as the ranges do not overlap. CB_LAYOUTRECALL request processing MUST be processed in &#34;seqid&#34; order at all times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントによる「seqid」の受信は、その後の使用には十分ではありません。 「seqid」を使用するには、クライアントが操作を完全に処理する必要があります。 LAYOUTGETの結果の場合、クライアントが忘却モデル（セクション12.5.5.1）を使用していない場合、seqidを使用する前に、ファイルのレイアウトの範囲のレコードを最初に更新する必要があります。 LAYOUTRETURNの結果の場合、クライアントは、seqidを使用する前に、ファイルのレイアウトの範囲のレコードから範囲を削除する必要があります。 CB_LAYOUTRECALL引数の場合、クライアントはseqidを使用する前にリコールに応答を送信する必要があります。クライアント処理の基本的な要件は、「seqid」を使用して処理の順序を提供することです。 LAYOUTGETの結果は並列処理される場合があります。 LAYOUTRETURNの結果は並列処理される場合があります。 LAYOUTGETとLAYOUTRETURNの応答は、範囲が重複しない限り、並行して処理できます。 CB_LAYOUTRECALL要求の処理は、常に「seqid」の順序で処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a client has no more layouts on a file, the layout stateid is no longer valid and MUST NOT be used. Any attempt to use such a layout stateid will result in NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントにファイルのレイアウトがなくなると、レイアウト状態IDは無効になり、使用してはなりません（MUST NOT）。このようなレイアウト状態IDを使用しようとすると、NFS4ERR_BAD_STATEIDが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-4--Committing-a-Layout">
12.5.4. Committing a Layout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.4. レイアウトをコミットする
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Allowing for varying storage protocol capabilities, the pNFS protocol does not require the metadata server and storage devices to have a consistent view of file attributes and data location mappings. Data location mapping refers to aspects such as which offsets store data as opposed to storing holes (see Section 13.4.4 for a discussion). Related issues arise for storage protocols where a layout may hold provisionally allocated blocks where the allocation of those blocks does not survive a complete restart of both the client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さまざまなストレージプロトコル機能を可能にするpNFSプロトコルでは、メタデータサーバーとストレージデバイスがファイル属性とデータの場所のマッピングの一貫したビューを持っている必要はありません。データの場所のマッピングは、ホールを格納するのではなく、どのオフセットがデータを格納するかなどの側面を指します（説明については、セクション13.4.4を参照してください）。レイアウトが暫定的に割り当てられたブロックを保持する可能性があるストレージプロトコルでは、これらのブロックの割り当てがクライアントとサーバーの両方の完全な再起動に耐えられない場合に、関連する問題が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because of this inconsistency, it is necessary to resynchronize the client with the metadata server and its storage devices and make any potential changes available to other clients. This is accomplished by use of the LAYOUTCOMMIT operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この不整合のため、クライアントをメタデータサーバーおよびそのストレージデバイスと再同期し、他のクライアントが利用できる可能性のある変更を行う必要があります。これは、LAYOUTCOMMIT操作を使用して実現されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LAYOUTCOMMIT operation is responsible for committing a modified layout to the metadata server. The data should be written and committed to the appropriate storage devices before the LAYOUTCOMMIT occurs. The scope of the LAYOUTCOMMIT operation depends on the storage protocol in use. It is important to note that the level of synchronization is from the point of view of the client that sent the LAYOUTCOMMIT. The updated state on the metadata server need only reflect the state as of the client&#39;s last operation previous to the LAYOUTCOMMIT. The metadata server is not REQUIRED to maintain a global view that accounts for other clients&#39; I/O that may have occurred within the same time frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTCOMMIT操作は、変更されたレイアウトをメタデータサーバーにコミットします。 LAYOUTCOMMITが発生する前に、データを書き込み、適切なストレージデバイスにコミットする必要があります。 LAYOUTCOMMIT操作の範囲は、使用中のストレージプロトコルによって異なります。同期のレベルは、LAYOUTCOMMITを送信したクライアントの観点からであることに注意することが重要です。メタデータサーバー上の更新された状態は、LAYOUTCOMMITの前のクライアントの最後の操作の時点の状態を反映するだけで済みます。メタデータサーバーは、同じ時間枠内に発生した可能性のある他のクライアントのI / Oを説明するグローバルビューを維持する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For block/volume-based layouts, LAYOUTCOMMIT may require updating the block list that comprises the file and committing this layout to stable storage. For file-based layouts, synchronization of attributes between the metadata and storage devices, primarily the size attribute, is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック/ボリュームベースのレイアウトの場合、LAYOUTCOMMITでは、ファイルを構成するブロックリストを更新し、このレイアウトを安定したストレージにコミットする必要がある場合があります。ファイルベースのレイアウトの場合、メタデータとストレージデバイス間の属性、主にサイズ属性の同期が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The control protocol is free to synchronize the attributes before it receives a LAYOUTCOMMIT; however, upon successful completion of a LAYOUTCOMMIT, state that exists on the metadata server that describes the file MUST be synchronized with the state that exists on the storage devices that comprise that file as of the client&#39;s last sent operation. Thus, a client that queries the size of a file between a WRITE to a storage device and the LAYOUTCOMMIT might observe a size that does not reflect the actual data written.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御プロトコルは、LAYOUTCOMMITを受信する前に属性を自由に同期できます。ただし、LAYOUTCOMMITが正常に完了すると、ファイルを記述するメタデータサーバーに存在する状態は、クライアントの最後に送信された操作の時点で、そのファイルを構成するストレージデバイスに存在する状態と同期する必要があります。したがって、ストレージデバイスへの書き込みとLAYOUTCOMMITの間でファイルのサイズを照会するクライアントは、書き込まれた実際のデータを反映しないサイズを監視する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MUST have a layout in order to send a LAYOUTCOMMIT operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、LAYOUTCOMMIT操作を送信するためのレイアウトを持っている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-4-1--LAYOUTCOMMIT-and-changetimemodify">
12.5.4.1. LAYOUTCOMMIT and change/time_modify
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.4.1. LAYOUTCOMMITおよびchange / time_modify
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The change and time_modify attributes may be updated by the server when the LAYOUTCOMMIT operation is processed. The reason for this is that some layout types do not support the update of these attributes when the storage devices process I/O operations. If a client has a layout with the LAYOUTIOMODE4_RW iomode on the file, the client MAY provide a suggested value to the server for time_modify within the arguments to LAYOUTCOMMIT. Based on the layout type, the provided value may or may not be used. The server should sanity-check the client-provided values before they are used. For example, the server should ensure that time does not flow backwards. The client always has the option to set time_modify through an explicit SETATTR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
changeおよびtime_modify属性は、LAYOUTCOMMIT操作が処理されるときにサーバーによって更新される場合があります。これは、ストレージデバイスがI / O操作を処理するときに、一部のレイアウトタイプがこれらの属性の更新をサポートしないためです。クライアントがファイルにLAYOUTIOMODE4_RW iomodeのレイアウトを持っている場合、クライアントは、LAYOUTCOMMITの引数内でtime_modifyの推奨値をサーバーに提供できます（MAY）。レイアウトタイプに基づいて、提供された値は使用される場合と使用されない場合があります。サーバーは、クライアントが提供する値を使用する前に、それらの妥当性をチェックする必要があります。たとえば、サーバーは時間が逆方向に流れないようにする必要があります。クライアントには、明示的なSETATTR操作を介してtime_modifyを設定するオプションが常にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For some layout protocols, the storage device is able to notify the metadata server of the occurrence of an I/O; as a result, the change and time_modify attributes may be updated at the metadata server. For a metadata server that is capable of monitoring updates to the change and time_modify attributes, LAYOUTCOMMIT processing is not required to update the change attribute. In this case, the metadata server must ensure that no further update to the data has occurred since the last update of the attributes; file-based protocols may have enough information to make this determination or may update the change attribute upon each file modification. This also applies for the time_modify attribute. If the server implementation is able to determine that the file has not been modified since the last time_modify update, the server need not update time_modify at LAYOUTCOMMIT. At LAYOUTCOMMIT completion, the updated attributes should be visible if that file was modified since the latest previous LAYOUTCOMMIT or LAYOUTGET.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のレイアウトプロトコルでは、ストレージデバイスはメタデータサーバーにI / Oの発生を通知できます。その結果、changeおよびtime_modify属性がメタデータサーバーで更新される場合があります。 changeおよびtime_modify属性の更新を監視できるメタデータサーバーの場合、変更属性を更新するためのLAYOUTCOMMIT処理は必要ありません。この場合、メタデータサーバーは、属性の最後の更新以降、データの更なる更新が発生していないことを確認する必要があります。ファイルベースのプロトコルには、この決定を行うのに十分な情報が含まれている場合や、ファイルが変更されるたびに変更属性が更新される場合があります。これは、time_modify属性にも適用されます。サーバーの実装が、前回のtime_modifyの更新以降にファイルが変更されていないことを判別できる場合、サーバーはLAYOUTCOMMITでtime_modifyを更新する必要はありません。 LAYOUTCOMMITの完了時に、最新のLAYOUTCOMMITまたはLAYOUTGET以降にそのファイルが変更された場合、更新された属性が表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-4-2--LAYOUTCOMMIT-and-size">
12.5.4.2. LAYOUTCOMMIT and size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.4.2. LAYOUTCOMMITとサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The size of a file may be updated when the LAYOUTCOMMIT operation is used by the client. One of the fields in the argument to LAYOUTCOMMIT is loca_last_write_offset; this field indicates the highest byte offset written but not yet committed with the LAYOUTCOMMIT operation. The data type of loca_last_write_offset is newoffset4 and is switched on a boolean value, no_newoffset, that indicates if a previous write occurred or not. If no_newoffset is FALSE, an offset is not given. If the client has a layout with LAYOUTIOMODE4_RW iomode on the file, with a byte-range (denoted by the values of lo_offset and lo_length) that overlaps loca_last_write_offset, then the client MAY set no_newoffset to TRUE and provide an offset that will update the file size. Keep in mind that offset is not the same as length, though they are related. For example, a loca_last_write_offset value of zero means that one byte was written at offset zero, and so the length of the file is at least one byte.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがLAYOUTCOMMIT操作を使用すると、ファイルのサイズが更新される場合があります。 LAYOUTCOMMITの引数のフィールドの1つは、loca_last_write_offsetです。このフィールドは、LAYOUTCOMMIT操作で書き込まれたがまだコミットされていない最大のバイトオフセットを示します。 loca_last_write_offsetのデータ型はnewoffset4であり、以前の書き込みが発生したかどうかを示すブール値no_newoffsetで切り替えられます。 no_newoffsetがFALSEの場合、オフセットは指定されません。クライアントに、ファイルにLAYOUTIOMODE4_RW iomodeのレイアウトがあり、loca_last_write_offsetと重複するバイト範囲（lo_offsetとlo_lengthの値で示される）がある場合、クライアントはno_newoffsetをTRUEに設定し、ファイルサイズを更新するオフセットを指定できます（MAY）。 。オフセットは長さと同じではありませんが、関連しています。たとえば、loca_last_write_offset値が0の場合、1バイトがオフセット0に書き込まれたため、ファイルの長さは少なくとも1バイトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The metadata server may do one of the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーは、次のいずれかを実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Update the file&#39;s size using the last write offset provided by the client as either the true file size or as a hint of the file size. If the metadata server has a method available, any new value for file size should be sanity-checked. For example, the file must not be truncated if the client presents a last write offset less than the file&#39;s current size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 実際のファイルサイズまたはファイルサイズのヒントとしてクライアントから提供された最後の書き込みオフセットを使用して、ファイルのサイズを更新します。メタデータサーバーに使用可能なメソッドがある場合は、ファイルサイズの新しい値の健全性をチェックする必要があります。たとえば、クライアントがファイルの現在のサイズよりも小さい最後の書き込みオフセットを提示する場合、ファイルを切り詰めてはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Ignore the client-provided last write offset; the metadata server must have sufficient knowledge from other sources to determine the file&#39;s size. For example, the metadata server queries the storage devices with the control protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. クライアント提供の最後の書き込みオフセットを無視します。メタデータサーバーは、ファイルのサイズを決定するために、他のソースからの十分な知識を持っている必要があります。たとえば、メタデータサーバーは、制御プロトコルを使用してストレージデバイスにクエリを実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The method chosen to update the file&#39;s size will depend on the storage device&#39;s and/or the control protocol&#39;s capabilities. For example, if the storage devices are block devices with no knowledge of file size, the metadata server must rely on the client to set the last write offset appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルのサイズを更新するために選択される方法は、ストレージデバイスや制御プロトコルの機能によって異なります。たとえば、ストレージデバイスがファイルサイズを知らないブロックデバイスである場合、メタデータサーバーはクライアントに依存して、最後の書き込みオフセットを適切に設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results of LAYOUTCOMMIT contain a new size value in the form of a newsize4 union data type. If the file&#39;s size is set as a result of LAYOUTCOMMIT, the metadata server must reply with the new size; otherwise, the new size is not provided. If the file size is updated, the metadata server SHOULD update the storage devices such that the new file size is reflected when LAYOUTCOMMIT processing is complete. For example, the client should be able to read up to the new file size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTCOMMITの結果には、newsize4共用体データ型の形式の新しいサイズ値が含まれています。 LAYOUTCOMMITの結果としてファイルのサイズが設定されている場合、メタデータサーバーは新しいサイズで応答する必要があります。それ以外の場合、新しいサイズは提供されません。ファイルサイズが更新された場合、メタデータサーバーは、LAYOUTCOMMIT処理が完了したときに新しいファイルサイズが反映されるようにストレージデバイスを更新する必要があります（SHOULD）。たとえば、クライアントは新しいファイルサイズまで読み取ることができる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client can extend the length of a file or truncate a file by sending a SETATTR operation to the metadata server with the size attribute specified. If the size specified is larger than the current size of the file, the file is &#34;zero extended&#34;, i.e., zeros are implicitly added between the file&#39;s previous EOF and the new EOF. (In many implementations, the zero-extended byte-range of the file consists of unallocated holes in the file.) When the client writes past EOF via WRITE, the SETATTR operation does not need to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、サイズ属性を指定してSETATTR操作をメタデータサーバーに送信することにより、ファイルの長さを拡張したり、ファイルを切り捨てたりできます。指定したサイズがファイルの現在のサイズより大きい場合、ファイルは「ゼロ拡張」されます。つまり、ファイルの以前のEOFと新しいEOFの間に暗黙的にゼロが追加されます。 （多くの実装では、ファイルのゼロ拡張バイト範囲は、ファイル内の未割り当ての穴で構成されます。）クライアントがWRITEを介してEOFを超えて書き込む場合、SETATTR操作を使用する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-4-3--LAYOUTCOMMIT-and-layoutupdate">
12.5.4.3. LAYOUTCOMMIT and layoutupdate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.4.3. LAYOUTCOMMITおよびlayoutupdate
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LAYOUTCOMMIT argument contains a loca_layoutupdate field (Section 18.42.1) of data type layoutupdate4 (Section 3.3.18). This argument is a layout-type-specific structure. The structure can be used to pass arbitrary layout-type-specific information from the client to the metadata server at LAYOUTCOMMIT time. For example, if using a block/volume layout, the client can indicate to the metadata server which reserved or allocated blocks the client used or did not use. The content of loca_layoutupdate (field lou_body) need not be the same layout-type-specific content returned by LAYOUTGET (Section 18.43.2) in the loc_body field of the lo_content field of the logr_layout field. The content of loca_layoutupdate is defined by the layout type specification and is opaque to LAYOUTCOMMIT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTCOMMIT引数には、データ型layoutupdate4（セクション3.3.18）のloca_layoutupdateフィールド（セクション18.42.1）が含まれています。この引数は、レイアウトタイプ固有の構造です。この構造を使用して、LAYOUTCOMMIT時にクライアントからメタデータサーバーに任意のレイアウトタイプ固有の情報を渡すことができます。たとえば、ブロック/ボリュームレイアウトを使用している場合、クライアントは、クライアントが使用または使用しなかった予約または割り当てられたブロックをメタデータサーバーに示すことができます。 loca_layoutupdate（フィールドlou_body）のコンテンツは、logr_layoutフィールドのlo_contentフィールドのloc_bodyフィールドのLAYOUTGET（セクション18.43.2）によって返されるレイアウトタイプ固有のコンテンツと同じである必要はありません。 loca_layoutupdateのコンテンツは、レイアウトタイプの仕様によって定義され、LAYOUTCOMMITに対して不透明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-5--Recalling-a-Layout">
12.5.5. Recalling a Layout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.5. レイアウトを呼び出す
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since a layout protects a client&#39;s access to a file via a direct client-storage-device path, a layout need only be recalled when it is semantically unable to serve this function. Typically, this occurs when the layout no longer encapsulates the true location of the file over the byte-range it represents. Any operation or action, such as server-driven restriping or load balancing, that changes the layout will result in a recall of the layout. A layout is recalled by the CB_LAYOUTRECALL callback operation (see Section 20.3) and returned with LAYOUTRETURN (see Section 18.44). The CB_LAYOUTRECALL operation may recall a layout identified by a byte-range, all layouts associated with a file system ID (FSID), or all layouts associated with a client ID. Section 12.5.5.2 discusses sequencing issues surrounding the getting, returning, and recalling of layouts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトは、クライアントのストレージデバイスへの直接パスを介したクライアントのファイルへのアクセスを保護するため、意味的にこの機能を提供できない場合にのみ、レイアウトを呼び出す必要があります。通常、これは、レイアウトがそれが表すバイト範囲でファイルの実際の場所をカプセル化しなくなったときに発生します。サーバー主導の再ストライピングや負荷分散など、レイアウトを変更する操作やアクションを実行すると、レイアウトが再呼び出しされます。レイアウトはCB_LAYOUTRECALLコールバック操作によってリコールされ（セクション20.3を参照）、LAYOUTRETURNとともに返されます（セクション18.44を参照）。 CB_LAYOUTRECALL操作は、バイト範囲で識別されるレイアウト、ファイルシステムID（FSID）に関連付けられているすべてのレイアウト、またはクライアントIDに関連付けられているすべてのレイアウトを呼び出すことができます。セクション12.5.5.2では、レイアウトの取得、返却、再呼び出しに関する順序付けの問題について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An iomode is also specified when recalling a layout. Generally, the iomode in the recall request must match the layout being returned; for example, a recall with an iomode of LAYOUTIOMODE4_RW should cause the client to only return LAYOUTIOMODE4_RW layouts and not LAYOUTIOMODE4_READ layouts. However, a special LAYOUTIOMODE4_ANY enumeration is defined to enable recalling a layout of any iomode; in other words, the client must return both LAYOUTIOMODE4_READ and LAYOUTIOMODE4_RW layouts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトを呼び出すときにもiomodeを指定します。通常、再呼び出し要求のiomodeは、返されるレイアウトと一致している必要があります。たとえば、iomodeがLAYOUTIOMODE4_RWのリコールでは、クライアントはLAYOUTIOMODE4_RWレイアウトのみを返し、LAYOUTIOMODE4_READレイアウトは返さないはずです。ただし、特別なLAYOUTIOMODE4_ANY列挙が定義されており、任意のiomodeのレイアウトを呼び出すことができます。つまり、クライアントはLAYOUTIOMODE4_READレイアウトとLAYOUTIOMODE4_RWレイアウトの両方を返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A REMOVE operation SHOULD cause the metadata server to recall the layout to prevent the client from accessing a non-existent file and to reclaim state stored on the client. Since a REMOVE may be delayed until the last close of the file has occurred, the recall may also be delayed until this time. After the last reference on the file has been released and the file has been removed, the client should no longer be able to perform I/O using the layout. In the case of a file-based layout, the data server SHOULD return NFS4ERR_STALE in response to any operation on the removed file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REMOVE操作は、メタデータサーバーがレイアウトを再呼び出しして、クライアントが存在しないファイルにアクセスできないようにし、クライアントに保存されている状態を再利用する必要があります（SHOULD）。 REMOVEはファイルの最後のクローズが発生するまで遅延する可能性があるため、再呼び出しもこの時間まで遅延する可能性があります。ファイルの最後の参照が解放され、ファイルが削除されると、クライアントはレイアウトを使用してI / Oを実行できなくなります。ファイルベースのレイアウトの場合、データサーバーは、削除されたファイルに対する操作に応じてNFS4ERR_STALEを返す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a layout has been returned, the client MUST NOT send I/Os to the storage devices for the file, byte-range, and iomode represented by the returned layout. If a client does send an I/O to a storage device for which it does not hold a layout, the storage device SHOULD reject the I/O.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトが返されると、クライアントは、返されたレイアウトで表されるファイル、バイト範囲、およびiomodeのI / Oをストレージデバイスに送信してはなりません（MUST NOT）。クライアントがレイアウトを保持していないストレージデバイスにI / Oを送信する場合、ストレージデバイスはI / Oを拒否する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Although pNFS does not alter the file data caching capabilities of clients, or their semantics, it recognizes that some clients may perform more aggressive write-behind caching to optimize the benefits provided by pNFS. However, write-behind caching may negatively affect the latency in returning a layout in response to a CB_LAYOUTRECALL; this is similar to file delegations and the impact that file data caching has on DELEGRETURN. Client implementations SHOULD limit the amount of unwritten data they have outstanding at any one time in order to prevent excessively long responses to CB_LAYOUTRECALL. Once a layout is recalled, a server MUST wait one lease period before taking further action. As soon as a lease period has passed, the server may choose to fence the client&#39;s access to the storage devices if the server perceives the client has taken too long to return a layout. However, just as in the case of data delegation and DELEGRETURN, the server may choose to wait, given that the client is showing forward progress on its way to returning the layout. This forward progress can take the form of successful interaction with the storage devices or of sub-portions of the layout being returned by the client. The server can also limit exposure to these problems by limiting the byte-ranges initially provided in the layouts and thus the amount of outstanding modified data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
pNFSはクライアントのファイルデータキャッシング機能やそのセマンティクスを変更しませんが、一部のクライアントはより積極的な後書きキャッシングを実行して、pNFSによって提供される利点を最適化する場合があることを認識しています。ただし、後書きキャッシングは、CB_LAYOUTRECALLに応答してレイアウトを返す際の待ち時間に悪影響を及ぼす可能性があります。これは、ファイルの委任と同様であり、ファイルデータキャッシュがDELEGRETURNに与える影響です。クライアント実装は、CB_LAYOUTRECALLへの過度に長い応答を防ぐために、未処理の未書き込みデータの量を一度に制限する必要があります（SHOULD）。レイアウトがリコールされると、サーバーはさらにアクションを実行する前に1リース期間待機する必要があります。リース期間が経過すると、クライアントがレイアウトを返すのに時間がかかりすぎているとサーバーが認識した場合、サーバーはクライアントのストレージデバイスへのアクセスを隔離することを選択できます。ただし、データ委任とDELEGRETURNの場合と同様に、クライアントがレイアウトを返す途中で進行状況を示している場合、サーバーは待機することを選択できます。この前進の進捗状況は、ストレージデバイスとの正常なやり取り、またはクライアントから返されるレイアウトの一部の形をとることがあります。サーバーは、レイアウトで最初に提供されたバイト範囲を制限することにより、これらの問題への露出を制限することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-5-1--Layout-Recall-Callback-Robustness">
12.5.5.1. Layout Recall Callback Robustness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.5.1. レイアウトリコールコールバックの堅牢性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It has been assumed thus far that pNFS client state (layout ranges and iomode) for a file exactly matches that of the pNFS server for that file. This assumption leads to the implication that any callback results in a LAYOUTRETURN or set of LAYOUTRETURNs that exactly match the range in the callback, since both client and server agree about the state being maintained. However, it can be useful if this assumption does not always hold. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまでのところ、ファイルのpNFSクライアントの状態（レイアウト範囲とiomode）は、そのファイルのpNFSサーバーの状態と正確に一致していると想定されていました。この仮定は、クライアントとサーバーの両方が維持されている状態について同意するため、コールバックの結果、コールバックの範囲と正確に一致するLAYOUTRETURNまたはLAYOUTRETURNのセットが生成されるという意味につながります。ただし、この仮定が常に成り立つとは限らない場合に役立ちます。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If conflicts that require callbacks are very rare, and a server can use a multi-file callback to recover per-client resources (e.g., via an FSID recall or a multi-file recall within a single CB_COMPOUND), the result may be significantly less client-server pNFS traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o コールバックを必要とする競合が非常にまれであり、サーバーがマルチファイルコールバックを使用してクライアントごとのリソースを回復できる場合（たとえば、単一のCB_COMPOUND内のFSIDリコールまたはマルチファイルリコールを介して）、結果は大幅に少なくなる可能性がありますクライアントサーバーのpNFSトラフィック。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It may be useful for servers to maintain information about what ranges are held by a client on a coarse-grained basis, leading to the server&#39;s layout ranges being beyond those actually held by the client. In the extreme, a server could manage conflicts on a per-file basis, only sending whole-file callbacks even though clients may request and be granted sub-file ranges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーがクライアントが保持している範囲に関する情報を大まかに管理すると、サーバーのレイアウト範囲が実際にクライアントが保持している範囲を超える可能性があります。極端な場合、サーバーはファイルごとに競合を管理し、クライアントがサブファイルの範囲を要求して許可されても、ファイル全体のコールバックのみを送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It may be useful for clients to &#34;forget&#34; details about what layouts and ranges the client actually has, leading to the server&#39;s layout ranges being beyond those that the client &#34;thinks&#34; it has. As long as the client does not assume it has layouts that are beyond what the server has granted, this is a safe practice. When a client forgets what ranges and layouts it has, and it receives a CB_LAYOUTRECALL operation, the client MUST follow up with a LAYOUTRETURN for what the server recalled, or alternatively return the NFS4ERR_NOMATCHING_LAYOUT error if it has no layout to return in the recalled range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントが実際にどのようなレイアウトと範囲を持っているかについての詳細を「忘れる」と、サーバーのレイアウト範囲がクライアントが「考えている」範囲を超えることにつながるので、クライアントにとって役立つ場合があります。クライアントが、サーバーが許可したレイアウトを超えるレイアウトがあると想定しない限り、これは安全な方法です。クライアントが持っている範囲とレイアウトを忘れ、CB_LAYOUTRECALL操作を受け取った場合、クライアントはサーバーがリコールした内容のLAYOUTRETURNをフォローアップするか、リコールされた範囲に返すべきレイアウトがない場合は代わりにNFS4ERR_NOMATCHING_LAYOUTエラーを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In order to avoid errors, it is vital that a client not assign itself layout permissions beyond what the server has granted, and that the server not forget layout permissions that have been granted. On the other hand, if a server believes that a client holds a layout that the client does not know about, it is useful for the client to cleanly indicate completion of the requested recall either by sending a LAYOUTRETURN operation for the entire requested range or by returning an NFS4ERR_NOMATCHING_LAYOUT error to the CB_LAYOUTRECALL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o エラーを回避するには、サーバー自体が許可したレイアウト許可を超えてクライアントがそれ自体にレイアウト許可を割り当てないこと、およびサーバーが許可したレイアウト許可を忘れないことが重要です。一方、クライアントが知らないレイアウトをクライアントが保持しているとサーバーが信じている場合、要求された範囲全体に対してLAYOUTRETURNオペレーションを送信するか、またはNFS4ERR_NOMATCHING_LAYOUTエラーをCB_LAYOUTRECALLに返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, in light of the above, it is useful for a server to be able to send callbacks for layout ranges it has not granted to a client, and for a client to return ranges it does not hold. A pNFS client MUST always return layouts that comprise the full range specified by the recall. Note, the full recalled layout range need not be returned as part of a single operation, but may be returned in portions. This allows the client to stage the flushing of dirty data and commits and returns of layouts. Also, it indicates to the metadata server that the client is making progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、上記の観点から、サーバーがクライアントに許可していないレイアウト範囲のコールバックを送信でき、クライアントが保持していない範囲をクライアントが返すことができると便利です。 pNFSクライアントは常に、再呼び出しで指定された全範囲を構成するレイアウトを返す必要があります。呼び出されたレイアウト範囲全体を単一の操作の一部として返す必要はありませんが、部分的に返すことができることに注意してください。これにより、クライアントはダーティデータのフラッシュ、およびレイアウトのコミットと返却をステージングできます。また、クライアントが進行中であることをメタデータサーバーに示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a layout is returned, the client MUST NOT have any outstanding I/O requests to the storage devices involved in the layout. Rephrasing, the client MUST NOT return the layout while it has outstanding I/O requests to the storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトが返されるとき、クライアントは、レイアウトに関係するストレージデバイスへの未処理のI / O要求を持っていてはなりません。言い換えると、クライアントは、ストレージデバイスへの未処理のI / O要求がある間はレイアウトを返してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even with this requirement for the client, it is possible that I/O requests may be presented to a storage device no longer allowed to perform them. Since the server has no strict control as to when the client will return the layout, the server may later decide to unilaterally revoke the client&#39;s access to the storage devices as provided by the layout. In choosing to revoke access, the server must deal with the possibility of lingering I/O requests, i.e., I/O requests that are still in flight to storage devices identified by the revoked layout. All layout type specifications MUST define whether unilateral layout revocation by the metadata server is supported; if it is, the specification must also describe how lingering writes are processed. For example, storage devices identified by the revoked layout could be fenced off from the client that held the layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントに対するこの要件がある場合でも、I / O要求が、実行を許可されていないストレージデバイスに提示される可能性があります。サーバーは、クライアントがいつレイアウトを返すかに関して厳密な制御を持たないため、レイアウトによって提供されるように、サーバーがクライアントのストレージデバイスへのアクセスを一方的に取り消すことを後で決定する場合があります。アクセスを取り消すことを選択する場合、サーバーは、I / O要求、つまり取り消されたレイアウトで識別されるストレージデバイスへの処理中のI / O要求が残る可能性に対処する必要があります。すべてのレイアウトタイプの仕様では、メタデータサーバーによる一方的なレイアウトの取り消しがサポートされているかどうかを定義する必要があります。そうである場合、仕様では、残存書き込みの処理方法も記述する必要があります。たとえば、取り消されたレイアウトによって識別されるストレージデバイスは、レイアウトを保持しているクライアントから隔離できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In order to ensure client/server convergence with regard to layout state, the final LAYOUTRETURN operation in a sequence of LAYOUTRETURN operations for a particular recall MUST specify the entire range being recalled, echoing the recalled layout type, iomode, recall/ return type (FILE, FSID, or ALL), and byte-range, even if layouts pertaining to partial ranges were previously returned. In addition, if the client holds no layouts that overlap the range being recalled, the client should return the NFS4ERR_NOMATCHING_LAYOUT error code to CB_LAYOUTRECALL. This allows the server to update its view of the client&#39;s layout state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
レイアウト状態に関するクライアント/サーバーの収束を確実にするために、特定の再呼び出しに対する一連のLAYOUTRETURN操作の最後のLAYOUTRETURN操作は、再呼び出しされる範囲全体を指定し、再呼び出しされたレイアウトタイプ、iomode、recall / return type（FILE 、FSID、またはALL）、およびバイト範囲（部分的な範囲に関連するレイアウトが以前に返された場合でも）。さらに、クライアントが、再呼び出しされる範囲と重複するレイアウトを保持していない場合、クライアントはNFS4ERR_NOMATCHING_LAYOUTエラーコードをCB_LAYOUTRECALLに返す必要があります。これにより、サーバーはクライアントのレイアウト状態のビューを更新できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-5-2--Sequencing-of-Layout-Operations">
12.5.5.2. Sequencing of Layout Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.5.2. レイアウト操作のシーケンス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with other stateful operations, pNFS requires the correct sequencing of layout operations. pNFS uses the &#34;seqid&#34; in the layout stateid to provide the correct sequencing between regular operations and callbacks. It is the server&#39;s responsibility to avoid inconsistencies regarding the layouts provided and the client&#39;s responsibility to properly serialize its layout requests and layout returns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のステートフル操作と同様に、pNFSではレイアウト操作の正しい順序付けが必要です。 pNFSは、レイアウト状態IDの「seqid」を使用して、通常の操作とコールバックの間の正しい順序付けを提供します。提供されるレイアウトに関する不整合を回避するのはサーバーの責任であり、そのレイアウト要求とレイアウトリターンを適切にシリアル化するのはクライアントの責任です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-5-2-1--Layout-Recall-and-Return-Sequencing">
12.5.5.2.1. Layout Recall and Return Sequencing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.5.2.1. レイアウトのリコールとリターンのシーケンス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One critical issue with regard to layout operations sequencing concerns callbacks. The protocol must defend against races between the reply to a LAYOUTGET or LAYOUTRETURN operation and a subsequent CB_LAYOUTRECALL. A client MUST NOT process a CB_LAYOUTRECALL that implies one or more outstanding LAYOUTGET or LAYOUTRETURN operations to which the client has not yet received a reply. The client detects such a CB_LAYOUTRECALL by examining the &#34;seqid&#34; field of the recall&#39;s layout stateid. If the &#34;seqid&#34; is not exactly one higher than what the client currently has recorded, and the client has at least one LAYOUTGET and/or LAYOUTRETURN operation outstanding, the client knows the server sent the CB_LAYOUTRECALL after sending a response to an outstanding LAYOUTGET or LAYOUTRETURN. The client MUST wait before processing such a CB_LAYOUTRECALL until it processes all replies for outstanding LAYOUTGET and LAYOUTRETURN operations for the corresponding file with seqid less than the seqid given by CB_LAYOUTRECALL (lor_stateid; see Section 20.3.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウト操作の順序付けに関する1つの重要な問題は、コールバックに関係しています。プロトコルは、LAYOUTGETまたはLAYOUTRETURN操作への応答と後続のCB_LAYOUTRECALLの間の競合を防ぐ必要があります。クライアントは、クライアントがまだ応答を受け取っていない1つ以上の未解決のLAYOUTGETまたはLAYOUTRETURN操作を意味するCB_LAYOUTRECALLを処理してはなりません（MUST NOT）。クライアントは、再呼び出しのレイアウト状態IDの「seqid」フィールドを調べることにより、そのようなCB_LAYOUTRECALLを検出します。 「seqid」がクライアントが現在記録しているものよりも1だけ大きくなく、クライアントに少なくとも1つのLAYOUTGETまたはLAYOUTRETURN操作が未処理の場合、未処理のLAYOUTGETへの応答の送信後にサーバーがCB_LAYOUTRECALLを送信したことをクライアントは認識します。レイアウトリターン。クライアントは、CB_LAYOUTRECALL（lor_stateid、セクション20.3を参照）で指定されたseqidより小さいseqidを持つ対応するファイルの未解決のLAYOUTGETおよびLAYOUTRETURN操作に対するすべての応答を処理するまで、そのようなCB_LAYOUTRECALLを処理する前に待機する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to the seqid-based mechanism, Section 2.10.6.3 describes the sessions mechanism for allowing the client to detect callback race conditions and delay processing such a CB_LAYOUTRECALL. The server MAY reference conflicting operations in the CB_SEQUENCE that precedes the CB_LAYOUTRECALL. Because the server has already sent replies for these operations before sending the callback, the replies may race with the CB_LAYOUTRECALL. The client MUST wait for all the referenced calls to complete and update its view of the layout state before processing the CB_LAYOUTRECALL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
seqidベースのメカニズムに加えて、セクション2.10.6.3では、クライアントがコールバックの競合状態を検出し、CB_LAYOUTRECALLなどの処理を遅延できるようにするセッションメカニズムについて説明します。サーバーは、CB_LAYOUTRECALLの前にあるCB_SEQUENCEの競合する操作を参照する場合があります。サーバーはコールバックを送信する前にこれらの操作に対する応答をすでに送信しているため、応答はCB_LAYOUTRECALLと競合する可能性があります。クライアントは、CB_LAYOUTRECALLを処理する前に、参照されるすべての呼び出しが完了してレイアウト状態のビューを更新するまで待機する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-5-2-1-1--GetReturn-Sequencing">
12.5.5.2.1.1. Get/Return Sequencing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.5.2.1.1. Get / Returnシーケンス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The protocol allows the client to send concurrent LAYOUTGET and LAYOUTRETURN operations to the server. The protocol does not provide any means for the server to process the requests in the same order in which they were created. However, through the use of the &#34;seqid&#34; field in the layout stateid, the client can determine the order in which parallel outstanding operations were processed by the server. Thus, when a layout retrieved by an outstanding LAYOUTGET operation intersects with a layout returned by an outstanding LAYOUTRETURN on the same file, the order in which the two conflicting operations are processed determines the final state of the overlapping layout. The order is determined by the &#34;seqid&#34; returned in each operation: the operation with the higher seqid was executed later.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このプロトコルにより、クライアントはLAYOUTGETおよびLAYOUTRETURN操作を同時にサーバーに送信できます。このプロトコルは、サーバーが要求を作成されたのと同じ順序で要求を処理する手段を提供しません。ただし、レイアウト状態IDの「seqid」フィールドを使用することで、クライアントは、並列の未処理の操作がサーバーによって処理された順序を判別できます。したがって、未解決のLAYOUTGET操作によって取得されたレイアウトが、同じファイルの未解決のLAYOUTRETURNによって返されたレイアウトと交差する場合、2つの競合する操作が処理される順序によって、重複するレイアウトの最終的な状態が決まります。順序は、各操作で返される「seqid」によって決定されます。seqidがより高い操作が後で実行されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is permissible for the client to send multiple parallel LAYOUTGET operations for the same file or multiple parallel LAYOUTRETURN operations for the same file or a mix of both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、同じファイルに対して複数の並列LAYOUTGET操作を送信することも、同じファイルに対して複数の並列LAYOUTRETURN操作を送信することも、両方を組み合わせて送信することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is permissible for the client to use the current stateid (see Section 16.2.3.1.2) for LAYOUTGET operations, for example, when compounding LAYOUTGETs or compounding OPEN and LAYOUTGETs. It is also permissible to use the current stateid when compounding LAYOUTRETURNs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、LAYOUTGETを合成したり、OPENとLAYOUTGETを合成したりする場合、クライアントはLAYOUTGET操作に現在の状態ID（セクション16.2.3.1.2を参照）を使用できます。 LAYOUTRETURNを合成するときに、現在の状態IDを使用することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is permissible for the client to use the current stateid when combining LAYOUTRETURN and LAYOUTGET operations for the same file in the same COMPOUND request since the server MUST process these in order. However, if a client does send such COMPOUND requests, it MUST NOT have more than one outstanding for the same file at the same time, and it MUST NOT have other LAYOUTGET or LAYOUTRETURN operations outstanding at the same time for that same file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはこれらを順番に処理する必要があるため、同じCOMPOUND要求で同じファイルのLAYOUTRETURN操作とLAYOUTGET操作を組み合わせる場合、クライアントは現在の状態IDを使用できます。ただし、クライアントがそのようなCOMPOUND要求を送信する場合、同じファイルに対して同時に複数の未処理を保持してはならず、同じファイルに対して同時に未処理の他のLAYOUTGETまたはLAYOUTRETURN操作を実行してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-5-2-1-2--Client-Considerations">
12.5.5.2.1.2. Client Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.5.2.1.2. クライアントの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider a pNFS client that has sent a LAYOUTGET, and before it receives the reply to LAYOUTGET, it receives a CB_LAYOUTRECALL for the same file with an overlapping range. There are two possibilities, which the client can distinguish via the layout stateid in the recall.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTGETを送信したpNFSクライアントを考えます。LAYOUTGETへの応答を受信する前に、重複する範囲を持つ同じファイルのCB_LAYOUTRECALLを受信します。 2つの可能性があり、クライアントは、再呼び出しのレイアウト状態IDを介して区別できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The server processed the LAYOUTGET before sending the recall, so the LAYOUTGET must be waited for because it may be carrying layout information that will need to be returned to deal with the CB_LAYOUTRECALL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. サーバーは再呼び出しを送信する前にLAYOUTGETを処理したため、CB_LAYOUTRECALLを処理するために返される必要のあるレイアウト情報を含んでいる可能性があるため、LAYOUTGETを待つ必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The server sent the callback before receiving the LAYOUTGET. The server will not respond to the LAYOUTGET until the CB_LAYOUTRECALL is processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. サーバーはLAYOUTGETを受信する前にコールバックを送信しました。サーバーは、CB_LAYOUTRECALLが処理されるまでLAYOUTGETに応答しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If these possibilities cannot be distinguished, a deadlock could result, as the client must wait for the LAYOUTGET response before processing the recall in the first case, but that response will not arrive until after the recall is processed in the second case. Note that in the first case, the &#34;seqid&#34; in the layout stateid of the recall is two greater than what the client has recorded; in the second case, the &#34;seqid&#34; is one greater than what the client has recorded. This allows the client to disambiguate between the two cases. The client thus knows precisely which possibility applies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
これらの可能性を区別できない場合、クライアントは最初のケースで再呼び出しを処理する前にLAYOUTGET応答を待つ必要がありますが、その応答は2番目のケースで再呼び出しが処理されるまで到着しません。最初のケースでは、再呼び出しのレイアウト状態IDの「seqid」は、クライアントが記録したものより2つ大きいことに注意してください。 2番目のケースでは、「seqid」はクライアントが記録したものより1つ大きくなります。これにより、クライアントは2つのケースを明確にすることができます。したがって、クライアントはどの可能性が適用されるかを正確に把握しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In case 1, the client knows it needs to wait for the LAYOUTGET response before processing the recall (or the client can return NFS4ERR_DELAY).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ケース1では、クライアントは、再呼び出しを処理する前にLAYOUTGET応答を待つ必要があることを認識しています（またはクライアントはNFS4ERR_DELAYを返すことができます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In case 2, the client will not wait for the LAYOUTGET response before processing the recall because waiting would cause deadlock. Therefore, the action at the client will only require waiting in the case that the client has not yet seen the server&#39;s earlier responses to the LAYOUTGET operation(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ケース2では、待機するとデッドロックが発生するため、クライアントはLAYOUTGET応答を待たずに再呼び出しを処理します。したがって、クライアントでのアクションは、クライアントがLAYOUTGET操作に対するサーバーの以前の応答をまだ確認していない場合にのみ待機する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The recall process can be considered completed when the final LAYOUTRETURN operation for the recalled range is completed. The LAYOUTRETURN uses the layout stateid (with seqid) specified in CB_LAYOUTRECALL. If the client uses multiple LAYOUTRETURNs in processing the recall, the first LAYOUTRETURN will use the layout stateid as specified in CB_LAYOUTRECALL. Subsequent LAYOUTRETURNs will use the highest seqid as is the usual case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リコールプロセスは、リコールされた範囲の最後のLAYOUTRETURN操作が完了したときに完了したと見なすことができます。 LAYOUTRETURNは、CB_LAYOUTRECALLで指定されたレイアウト状態ID（seqid付き）を使用します。クライアントが再呼び出しの処理に複数のLAYOUTRETURNを使用する場合、最初のLAYOUTRETURNは、CB_LAYOUTRECALLで指定されたレイアウトの状態IDを使用します。後続のLAYOUTRETURNは、通常の場合と同様に、最も高いseqidを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-5-2-1-3--Server-Considerations">
12.5.5.2.1.3. Server Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.5.2.1.3. サーバーに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider a race from the metadata server&#39;s point of view. The metadata server has sent a CB_LAYOUTRECALL and receives an overlapping LAYOUTGET for the same file before the LAYOUTRETURN(s) that respond to the CB_LAYOUTRECALL. There are three cases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーの観点から競争を検討してください。メタデータサーバーはCB_LAYOUTRECALLを送信し、CB_LAYOUTRECALLに応答するLAYOUTRETURN（s）の前に同じファイルの重複するLAYOUTGETを受信しました。 3つのケースがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The client sent the LAYOUTGET before processing the CB_LAYOUTRECALL. The &#34;seqid&#34; in the layout stateid of the arguments of LAYOUTGET is one less than the &#34;seqid&#34; in CB_LAYOUTRECALL. The server returns NFS4ERR_RECALLCONFLICT to the client, which indicates to the client that there is a pending recall.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. クライアントは、CB_LAYOUTRECALLを処理する前にLAYOUTGETを送信しました。 LAYOUTGETの引数のレイアウト状態IDの「seqid」は、CB_LAYOUTRECALLの「seqid」よりも1つ少ないです。サーバーはNFS4ERR_RECALLCONFLICTをクライアントに返します。これは、保留中の再呼び出しがあることをクライアントに示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The client sent the LAYOUTGET after processing the CB_LAYOUTRECALL, but the LAYOUTGET arrived before the LAYOUTRETURN and the response to CB_LAYOUTRECALL that completed that processing. The &#34;seqid&#34; in the layout stateid of LAYOUTGET is equal to or greater than that of the &#34;seqid&#34; in CB_LAYOUTRECALL. The server has not received a response to the CB_LAYOUTRECALL, so it returns NFS4ERR_RECALLCONFLICT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. クライアントは、CB_LAYOUTRECALLの処理後にLAYOUTGETを送信しましたが、LAYOUTRETURNおよびその処理を完了したCB_LAYOUTRECALLへの応答の前にLAYOUTGETが到着しました。 LAYOUTGETのレイアウトステートIDの「seqid」は、CB_LAYOUTRECALLの「seqid」の「seqid」以上です。サーバーはCB_LAYOUTRECALLへの応答を受け取っていないため、NFS4ERR_RECALLCONFLICTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The client sent the LAYOUTGET after processing the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. クライアントは、処理後にLAYOUTGETを送信しました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
CB_LAYOUTRECALL; the server received the CB_LAYOUTRECALL response, but the LAYOUTGET arrived before the LAYOUTRETURN that completed that processing. The &#34;seqid&#34; in the layout stateid of LAYOUTGET is equal to that of the &#34;seqid&#34; in CB_LAYOUTRECALL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
CB_LAYOUTRECALL;サーバーはCB_LAYOUTRECALL応答を受け取りましたが、LAYOUTGETがその処理を完了したLAYOUTRETURNの前に到着しました。 LAYOUTGETのレイアウト状態IDの「seqid」は、CB_LAYOUTRECALLの「seqid」の「seqid」と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The server has received a response to the CB_LAYOUTRECALL, so it returns NFS4ERR_RETURNCONFLICT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
サーバーはCB_LAYOUTRECALLへの応答を受信したため、NFS4ERR_RETURNCONFLICTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-5-2-1-4--Wraparound-and-Validation-of-Seqid">
12.5.5.2.1.4. Wraparound and Validation of Seqid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.5.2.1.4. Seqidのラップアラウンドと検証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules for layout stateid processing differ from other stateids in the protocol because the &#34;seqid&#34; value cannot be zero and the stateid&#39;s &#34;seqid&#34; value changes in a CB_LAYOUTRECALL operation. The non-zero requirement combined with the inherent parallelism of layout operations means that a set of LAYOUTGET and LAYOUTRETURN operations may contain the same value for &#34;seqid&#34;. The server uses a slightly modified version of the modulo arithmetic as described in Section 2.10.6.1 when incrementing the layout stateid&#39;s &#34;seqid&#34;. The difference is that zero is not a valid value for &#34;seqid&#34;; when the value of a &#34;seqid&#34; is 0xFFFFFFFF, the next valid value will be 0x00000001. The modulo arithmetic is also used for the comparisons of &#34;seqid&#34; values in the processing of CB_LAYOUTRECALL events as described above in Section 12.5.5.2.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「seqid」の値はゼロにすることはできず、stateidの「seqid」の値はCB_LAYOUTRECALL操作で変更されるため、レイアウトのstateid処理のルールはプロトコルの他のstateidsとは異なります。ゼロ以外の要件とレイアウト操作の固有の並列処理を組み合わせると、LAYOUTGETおよびLAYOUTRETURN操作のセットに「seqid」の同じ値が含まれる可能性があります。サーバーは、レイアウト状態IDの「seqid」をインクリメントするときに、セクション2.10.6.1で説明されているように、モジュロ演算のわずかに変更されたバージョンを使用します。違いは、ゼロは「seqid」の有効な値ではないということです。 「seqid」の値が0xFFFFFFFFの場合、次の有効な値は0x00000001になります。セクション12.5.5.2.1.3で説明したように、モジュロ演算は、CB_LAYOUTRECALLイベントの処理における「seqid」値の比較にも使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Just as the server validates the &#34;seqid&#34; in the event of CB_LAYOUTRECALL usage, as described in Section 12.5.5.2.1.3, the server also validates the &#34;seqid&#34; value to ensure that it is within an appropriate range. This range represents the degree of parallelism the server supports for layout stateids. If the client is sending multiple layout operations to the server in parallel, by definition, the &#34;seqid&#34; value in the supplied stateid will not be the current &#34;seqid&#34; as held by the server. The range of parallelism spans from the highest or current &#34;seqid&#34; to a &#34;seqid&#34; value in the past. To assist in the discussion, the server&#39;s current &#34;seqid&#34; value for a layout stateid is defined as SERVER_CURRENT_SEQID. The lowest &#34;seqid&#34; value that is acceptable to the server is represented by PAST_SEQID. And the value for the range of valid &#34;seqid&#34;s or range of parallelism is VALID_SEQID_RANGE. Therefore, the following holds: VALID_SEQID_RANGE = SERVER_CURRENT_SEQID - PAST_SEQID. In the following, all arithmetic is the modulo arithmetic as described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12.5.5.2.1.3項で説明するように、サーバーがCB_LAYOUTRECALLの使用時に「seqid」を検証するのと同様に、サーバーは「seqid」値も検証して、適切な範囲内にあることを確認します。この範囲は、サーバーがレイアウトステートIDに対してサポートする並列度を表します。クライアントが複数のレイアウト操作をサーバーに並行して送信している場合、定義により、提供されたstateidの「seqid」の値は、サーバーが保持している現在の「seqid」にはなりません。並列処理の範囲は、最高または現在の「seqid」から過去の「seqid」値までの範囲です。議論を助けるために、レイアウト状態IDに対するサーバーの現在の「seqid」値は、SERVER_CURRENT_SEQIDとして定義されています。サーバーが許容できる最小の「seqid」値は、PAST_SEQIDで表されます。また、有効な「seqid」の範囲または並列処理の範囲の値はVALID_SEQID_RANGEです。したがって、次のようになります。VALID_SEQID_RANGE= SERVER_CURRENT_SEQID-PAST_SEQID。以下では、すべての演算は上記のモジュロ演算です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The server MUST support a minimum VALID_SEQID_RANGE. The minimum is defined as: VALID_SEQID_RANGE = summation over 1..N of (ca_maxoperations(i) - 1), where N is the number of session fore channels and ca_maxoperations(i) is the value of the ca_maxoperations returned from CREATE_SESSION of the i&#39;th session. The reason for &#34;- 1&#34; is to allow for the required SEQUENCE operation. The server MAY support a VALID_SEQID_RANGE value larger than the minimum. The maximum VALID_SEQID_RANGE is (2 ^ 32 - 2) (accounting for zero not being a valid &#34;seqid&#34; value).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーは最小のVALID_SEQID_RANGEをサポートする必要があります。最小値は次のように定義されます。VALID_SEQID_RANGE= 1..Nの合計（ca_maxoperations（i）-1）。Nはセッションフォアチャネルの数、ca_maxoperations（i）はiのCREATE_SESSIONから返されるca_maxoperationsの値です。 &#39;番目のセッション。 「-1」の理由は、必要なSEQUENCE操作を許可するためです。サーバーは、最小値より大きいVALID_SEQID_RANGE値をサポートしてもよい（MAY）。 VALID_SEQID_RANGEの最大値は（2 ^ 32-2）です（ゼロが有効な「seqid」値ではないため）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server finds the &#34;seqid&#34; is zero, the NFS4ERR_BAD_STATEID error is returned to the client. The server further validates the &#34;seqid&#34; to ensure it is within the range of parallelism, VALID_SEQID_RANGE. If the &#34;seqid&#34; value is outside of that range, the error NFS4ERR_OLD_STATEID is returned to the client. Upon receipt of NFS4ERR_OLD_STATEID, the client updates the stateid in the layout request based on processing of other layout requests and re-sends the operation to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが「seqid」がゼロであることを検出すると、NFS4ERR_BAD_STATEIDエラーがクライアントに返されます。サーバーはさらに「seqid」を検証して、それが並列処理の範囲VALID_SEQID_RANGE内にあることを確認します。 「seqid」値がその範囲外の場合、エラーNFS4ERR_OLD_STATEIDがクライアントに返されます。 NFS4ERR_OLD_STATEIDを受信すると、クライアントは他のレイアウト要求の処理に基づいてレイアウト要求の状態IDを更新し、サーバーに操作を再送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-5-2-1-5--Bulk-Recall-and-Return">
12.5.5.2.1.5. Bulk Recall and Return
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.5.2.1.5. 一括リコールと返品
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFS supports recalling and returning all layouts that are for files belonging to a particular fsid (LAYOUTRECALL4_FSID, LAYOUTRETURN4_FSID) or client ID (LAYOUTRECALL4_ALL, LAYOUTRETURN4_ALL). There are no &#34;bulk&#34; stateids, so detection of races via the seqid is not possible. The server MUST NOT initiate bulk recall while another recall is in progress, or the corresponding LAYOUTRETURN is in progress or pending. In the event the server sends a bulk recall while the client has a pending or in-progress LAYOUTRETURN, CB_LAYOUTRECALL, or LAYOUTGET, the client returns NFS4ERR_DELAY. In the event the client sends a LAYOUTGET or LAYOUTRETURN while a bulk recall is in progress, the server returns NFS4ERR_RECALLCONFLICT. If the client sends a LAYOUTGET or LAYOUTRETURN after the server receives NFS4ERR_DELAY from a bulk recall, then to ensure forward progress, the server MAY return NFS4ERR_RECALLCONFLICT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSは、特定のfsid（LAYOUTRECALL4_FSID、LAYOUTRETURN4_FSID）またはクライアントID（LAYOUTRECALL4_ALL、LAYOUTRETURN4_ALL）に属するファイルのすべてのレイアウトの呼び出しと返却をサポートしています。 「バルク」のステートIDがないため、seqidを介したレースの検出は不可能です。サーバーは、別の再呼び出しが進行中、または対応するLAYOUTRETURNが進行中または保留中に、一括再呼び出しを開始してはなりません（MUST NOT）。クライアントに保留中または進行中のLAYOUTRETURN、CB_LAYOUTRECALL、またはLAYOUTGETがある間にサーバーがバルク再呼び出しを送信した場合、クライアントはNFS4ERR_DELAYを返します。バルク再呼び出しの進行中にクライアントがLAYOUTGETまたはLAYOUTRETURNを送信すると、サーバーはNFS4ERR_RECALLCONFLICTを返します。サーバーがバルク再呼び出しからNFS4ERR_DELAYを受信した後にクライアントがLAYOUTGETまたはLAYOUTRETURNを送信した場合、サーバーは順方向の進行を確実にするために、NFS4ERR_RECALLCONFLICTを返す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a CB_LAYOUTRECALL of LAYOUTRECALL4_ALL is sent, the server MUST NOT allow the client to use any layout stateid except for LAYOUTCOMMIT operations. Once the client receives a CB_LAYOUTRECALL of LAYOUTRECALL4_ALL, it MUST NOT use any layout stateid except for LAYOUTCOMMIT operations. Once a LAYOUTRETURN of LAYOUTRETURN4_ALL is sent, all layout stateids granted to the client ID are freed. The client MUST NOT use the layout stateids again. It MUST use LAYOUTGET to obtain new layout stateids.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTRECALL4_ALLのCB_LAYOUTRECALLが送信されると、サーバーは、クライアントがLAYOUTCOMMIT操作以外のレイアウト状態IDを使用することを許可してはなりません（MUST NOT）。クライアントがLAYOUTRECALL4_ALLのCB_LAYOUTRECALLを受信すると、LAYOUTCOMMIT操作以外のレイアウト状態IDを使用してはなりません（MUST NOT）。 LAYOUTRETURN4_ALLのLAYOUTRETURNが送信されると、クライアントIDに付与されたすべてのレイアウトステートIDが解放されます。クライアントはレイアウト状態IDを再び使用してはなりません（MUST NOT）。新しいレイアウトステートIDを取得するには、LAYOUTGETを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Once a CB_LAYOUTRECALL of LAYOUTRECALL4_FSID is sent, the server MUST NOT allow the client to use any layout stateid that refers to a file with the specified fsid except for LAYOUTCOMMIT operations. Once the client receives a CB_LAYOUTRECALL of LAYOUTRECALL4_ALL, it MUST NOT use any layout stateid that refers to a file with the specified fsid except for LAYOUTCOMMIT operations. Once a LAYOUTRETURN of LAYOUTRETURN4_FSID is sent, all layout stateids granted to the referenced fsid are freed. The client MUST NOT use those freed layout stateids for files with the referenced fsid again. Subsequently, for any file with the referenced fsid, to use a layout, the client MUST first send a LAYOUTGET operation in order to obtain a new layout stateid for that file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
LAYOUTRECALL4_FSIDのCB_LAYOUTRECALLが送信されると、サーバーは、LAYOUTCOMMIT操作を除いて、指定されたfsidを持つファイルを参照するレイアウト状態IDをクライアントが使用することを許可してはなりません（MUST NOT）。クライアントがLAYOUTRECALL4_ALLのCB_LAYOUTRECALLを受信すると、LAYOUTCOMMIT操作を除いて、指定されたfsidを持つファイルを参照するレイアウト状態IDを使用してはなりません（MUST NOT）。 LAYOUTRETURN4_FSIDのLAYOUTRETURNが送信されると、参照されるfsidに付与されたすべてのレイアウトステートIDが解放されます。クライアントは、参照されたfsidを持つファイルに対して、これらの解放されたレイアウト状態IDを再び使用してはなりません（MUST NOT）。その後、参照されたfsidを持つすべてのファイルでレイアウトを使用するには、クライアントは最初にLAYOUTGET操作を送信して、そのファイルの新しいレイアウト状態IDを取得する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server has sent a bulk CB_LAYOUTRECALL and receives a LAYOUTGET, or a LAYOUTRETURN with a stateid, the server MUST return NFS4ERR_RECALLCONFLICT. If the server has sent a bulk CB_LAYOUTRECALL and receives a LAYOUTRETURN with an lr_returntype that is not equal to the lor_recalltype of the CB_LAYOUTRECALL, the server MUST return NFS4ERR_RECALLCONFLICT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが大量のCB_LAYOUTRECALLを送信し、LAYOUTGETまたはstateidを含むLAYOUTRETURNを受信した場合、サーバーはNFS4ERR_RECALLCONFLICTを返さなければなりません（MUST）。サーバーが大量のCB_LAYOUTRECALLを送信し、lr_returntypeがCB_LAYOUTRECALLのlor_recalltypeと等しくないLAYOUTRETURNを受信した場合、サーバーはNFS4ERR_RECALLCONFLICTを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-6--Revoking-Layouts">
12.5.6. Revoking Layouts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.6. レイアウトを取り消す
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Parallel NFS permits servers to revoke layouts from clients that fail to respond to recalls and/or fail to renew their lease in time. Depending on the layout type, the server might revoke the layout and might take certain actions with respect to the client&#39;s I/O to data servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Parallel NFSを使用すると、サーバーは、リコールに応答できなかったり、リースを期限内に更新できなかったりしたクライアントからレイアウトを取り消すことができます。レイアウトの種類によっては、サーバーがレイアウトを取り消し、データサーバーへのクライアントのI / Oに関して特定のアクションを実行する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-5-7--Metadata-Server-Write-Propagation">
12.5.7. Metadata Server Write Propagation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5.7. メタデータサーバーの書き込み伝達
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Asynchronous writes written through the metadata server may be propagated lazily to the storage devices. For data written asynchronously through the metadata server, a client performing a read at the appropriate storage device is not guaranteed to see the newly written data until a COMMIT occurs at the metadata server. While the write is pending, reads to the storage device may give out either the old data, the new data, or a mixture of new and old. Upon completion of a synchronous WRITE or COMMIT (for asynchronously written data), the metadata server MUST ensure that storage devices give out the new data and that the data has been written to stable storage. If the server implements its storage in any way such that it cannot obey these constraints, then it MUST recall the layouts to prevent reads being done that cannot be handled correctly. Note that the layouts MUST be recalled prior to the server responding to the associated WRITE operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーを介して書き込まれた非同期書き込みは、ストレージデバイスに遅延伝播される場合があります。メタデータサーバーを介して非同期で書き込まれたデータの場合、適切なストレージデバイスで読み取りを実行するクライアントは、メタデータサーバーでCOMMITが発生するまで、新しく書き込まれたデータを確認できるとは限りません。書き込みが保留されている間、ストレージデバイスへの読み取りは、古いデータ、新しいデータ、または新しいデータと古いデータの混合のいずれかを提供します。同期WRITEまたはCOMMIT（非同期に書き込まれたデータの場合）が完了すると、メタデータサーバーは、ストレージデバイスが新しいデータを配布し、データが安定したストレージに書き込まれていることを確認する必要があります。サーバーがストレージを実装してこれらの制約に従わない場合は、レイアウトをリコールして、正しく処理できない読み取りが行われないようにする必要があります。レイアウトは、サーバーが関連するWRITE操作に応答する前にリコールする必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-6--pNFS-Mechanics">
12.6. pNFS Mechanics
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6. pNFSの仕組み
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the operations flow taken by a pNFS client to a metadata server and storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、pNFSクライアントがメタデータサーバーとストレージデバイスに行う操作フローについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When a pNFS client encounters a new FSID, it sends a GETATTR to the NFSv4.1 server for the fs_layout_type (Section 5.12.1) attribute. If the attribute returns at least one layout type, and the layout types returned are among the set supported by the client, the client knows that pNFS is a possibility for the file system. If, from the server that returned the new FSID, the client does not have a client ID that came from an EXCHANGE_ID result that returned EXCHGID4_FLAG_USE_PNFS_MDS, it MUST send an EXCHANGE_ID to the server with the EXCHGID4_FLAG_USE_PNFS_MDS bit set. If the server&#39;s response does not have EXCHGID4_FLAG_USE_PNFS_MDS, then contrary to what the fs_layout_type attribute said, the server does not support pNFS, and the client will not be able use pNFS to that server; in this case, the server MUST return NFS4ERR_NOTSUPP in response to any pNFS operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
pNFSクライアントは、新しいFSIDを検出すると、fs_layout_type（セクション5.12.1）属性のGETATTRをNFSv4.1サーバーに送信します。属性が少なくとも1つのレイアウトタイプを返し、返されたレイアウトタイプがクライアントによってサポートされているセットの中にある場合、クライアントはpNFSがファイルシステムの可能性があることを認識しています。新しいFSIDを返したサーバーから、EXCHGID4_FLAG_USE_PNFS_MDSを返したEXCHANGE_IDの結果から得られたクライアントIDがクライアントにない場合、EXCHGID4_FLAG_USE_PNFS_MDSビットが設定されたサーバーにEXCHANGE_IDを送信する必要があります。サーバーの応答にEXCHGID4_FLAG_USE_PNFS_MDSがない場合、fs_layout_type属性の説明とは逆に、サーバーはpNFSをサポートせず、クライアントはそのサーバーに対してpNFSを使用できません。この場合、サーバーはpNFS操作に応答してNFS4ERR_NOTSUPPを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client then creates a session, requesting a persistent session, so that exclusive creates can be done with single round trip via the createmode4 of GUARDED4. If the session ends up not being persistent, the client will use EXCLUSIVE4_1 for exclusive creates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、クライアントはセッションを作成し、永続的なセッションを要求します。これにより、GUARDED4のcreatemode4を介した単一の往復で排他的作成を実行できます。セッションが永続的でない場合、クライアントは排他的作成にEXCLUSIVE4_1を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a file is to be created on a pNFS-enabled file system, the client uses the OPEN operation. With the normal set of attributes that may be provided upon OPEN used for creation, there is an OPTIONAL layout_hint attribute. The client&#39;s use of layout_hint allows the client to express its preference for a layout type and its associated layout details. The use of a createmode4 of UNCHECKED4, GUARDED4, or EXCLUSIVE4_1 will allow the client to provide the layout_hint attribute at create time. The client MUST NOT use EXCLUSIVE4 (see Table 10). The client is RECOMMENDED to combine a GETATTR operation after the OPEN within the same COMPOUND. The GETATTR may then retrieve the layout_type attribute for the newly created file. The client will then know what layout type the server has chosen for the file and therefore what storage protocol the client must use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルがpNFS対応のファイルシステムで作成される場合、クライアントはOPEN操作を使用します。作成時に使用されるOPEN時に提供される可能性のある通常の属性セットには、オプションのlayout_hint属性があります。クライアントがlayout_hintを使用することで、クライアントは、レイアウトタイプとそれに関連付けられたレイアウトの詳細に対する好みを表現できます。 UNCHECKED4、GUARDED4、またはEXCLUSIVE4_1のcreatemode4を使用すると、クライアントは作成時にlayout_hint属性を提供できます。クライアントはEXCLUSIVE4を使用してはなりません（表10を参照）。クライアントは、同じCOMPOUND内でOPENの後にGETATTR操作を結合することをお勧めします。 GETATTRは、新しく作成されたファイルのlayout_type属性を取得します。その後、クライアントは、サーバーがファイルに対して選択したレイアウトの種類、したがってクライアントが使用する必要のあるストレージプロトコルを認識します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client wants to open an existing file, then it also includes a GETATTR to determine what layout type the file supports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが既存のファイルを開きたい場合は、ファイルがサポートするレイアウトタイプを決定するGETATTRも含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The GETATTR in either the file creation or plain file open case can also include the layout_blksize and layout_alignment attributes so that the client can determine optimal offsets and lengths for I/O on the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイル作成時またはプレーンファイルオープンの場合のGETATTRには、クライアントがファイル上のI / Oの最適なオフセットと長さを決定できるように、layout_blksize属性とlayout_alignment属性も含めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming the client supports the layout type returned by GETATTR and it chooses to use pNFS for data access, it then sends LAYOUTGET using the filehandle and stateid returned by OPEN, specifying the range it wants to do I/O on. The response is a layout, which may be a subset of the range for which the client asked. It also includes device IDs and a description of how data is organized (or in the case of writing, how data is to be organized) across the devices. The device IDs and data description are encoded in a format that is specific to the layout type, but the client is expected to understand.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがGETATTRによって返されるレイアウトタイプをサポートし、データアクセスにpNFSを使用することを選択すると、OPENによって返されるファイルハンドルと状態IDを使用してLAYOUTGETを送信し、I / Oを実行する範囲を指定します。応答はレイアウトであり、クライアントが要求した範囲のサブセットである場合があります。また、デバイスIDと、デバイス間でのデータの編成方法（または書き込みの場合はデータの編成方法）の説明も含まれます。デバイスIDとデータの説明は、レイアウトタイプに固有の形式でエンコードされますが、クライアントが理解する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client wants to send an I/O, it determines to which device ID it needs to send the I/O command by examining the data description in the layout. It then sends a GETDEVICEINFO to find the device address(es) of the device ID. The client then sends the I/O request to one of device ID&#39;s device addresses, using the storage protocol defined for the layout type. Note that if a client has multiple I/Os to send, these I/O requests may be done in parallel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがI / Oを送信する場合、レイアウト内のデータの説明を調べて、I / Oコマンドを送信する必要があるデバイスIDを決定します。次に、GETDEVICEINFOを送信して、デバイスIDのデバイスアドレスを検索します。次に、クライアントは、レイアウトタイプに定義されたストレージプロトコルを使用して、デバイスIDのデバイスアドレスの1つにI / O要求を送信します。クライアントが送信する複数のI / Oを持っている場合、これらのI / O要求は並行して行われる可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the I/O was a WRITE, then at some point the client may want to use LAYOUTCOMMIT to commit the modification time and the new size of the file (if it believes it extended the file size) to the metadata server and the modified data to the file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I / OがWRITEの場合、クライアントはある時点でLAYOUTCOMMITを使用して、変更時間とファイルの新しいサイズ（ファイルサイズが拡張されたと思われる場合）をメタデータサーバーと変更されたデータにコミットすることができます。ファイルシステムに。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-7--Recovery">
12.7. Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.7. 回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recovery is complicated by the distributed nature of the pNFS protocol. In general, crash recovery for layouts is similar to crash recovery for delegations in the base NFSv4.1 protocol. However, the client&#39;s ability to perform I/O without contacting the metadata server introduces subtleties that must be handled correctly if the possibility of file system corruption is to be avoided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSプロトコルの分散性により、リカバリは複雑になります。一般に、レイアウトのクラッシュリカバリは、基本NFSv4.1プロトコルの委任のクラッシュリカバリに似ています。ただし、メタデータサーバーに接続せずにI / Oを実行するクライアントの機能は、ファイルシステムの破損の可能性を回避する場合に正しく処理する必要がある微妙な問題をもたらします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-7-1--Recovery-from-Client-Restart">
12.7.1. Recovery from Client Restart
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.7.1. クライアントの再起動からの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client recovery for layouts is similar to client recovery for other lock and delegation state. When a pNFS client restarts, it will lose all information about the layouts that it previously owned. There are two methods by which the server can reclaim these resources and allow otherwise conflicting layouts to be provided to other clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトのクライアント回復は、他のロックおよび委任状態のクライアント回復と似ています。 pNFSクライアントが再起動すると、以前に所有していたレイアウトに関するすべての情報が失われます。サーバーがこれらのリソースを再利用し、競合するレイアウトを他のクライアントに提供できるようにする方法は2つあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first is through the expiry of the client&#39;s lease. If the client recovery time is longer than the lease period, the client&#39;s lease will expire and the server will know that state may be released. For layouts, the server may release the state immediately upon lease expiry or it may allow the layout to persist, awaiting possible lease revival, as long as no other layout conflicts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つ目は、クライアントのリースの有効期限です。クライアントの回復時間がリース期間よりも長い場合、クライアントのリースは期限切れになり、サーバーは状態が解放される可能性があることを認識します。レイアウトの場合、サーバーはリースの有効期限が切れるとすぐに状態を解放するか、他のレイアウトの競合がない限り、レイアウトの持続を許可して、可能なリースの復活を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The second is through the client restarting in less time than it takes for the lease period to expire. In such a case, the client will contact the server through the standard EXCHANGE_ID protocol. The server will find that the client&#39;s co_ownerid matches the co_ownerid of the previous client invocation, but that the verifier is different. The server uses this as a signal to release all layout state associated with the client&#39;s previous invocation. In this scenario, the data written by the client but not covered by a successful LAYOUTCOMMIT is in an undefined state; it may have been written or it may now be lost. This is acceptable behavior and it is the client&#39;s responsibility to use LAYOUTCOMMIT to achieve the desired level of stability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2つ目は、リース期間が終了するのにかかる時間よりも短い時間でクライアントを再起動する方法です。このような場合、クライアントは標準のEXCHANGE_IDプロトコルを介してサーバーに接続します。サーバーは、クライアントのco_owneridが前のクライアント呼び出しのco_owneridと一致することを確認しますが、ベリファイアは異なります。サーバーはこれをシグナルとして使用して、クライアントの以前の呼び出しに関連付けられたすべてのレイアウト状態を解放します。このシナリオでは、クライアントによって書き込まれたが、成功したLAYOUTCOMMITによってカバーされていないデータは、未定義の状態です。書き込まれたか、失われた可能性があります。これは許容できる動作であり、LAYOUTCOMMITを使用して必要なレベルの安定性を達成するのはクライアントの責任です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-7-2--Dealing-with-Lease-Expiration-on-the-Client">
12.7.2. Dealing with Lease Expiration on the Client
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.7.2. クライアントのリース期限切れへの対処
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client believes its lease has expired, it MUST NOT send I/O to the storage device until it has validated its lease. The client can send a SEQUENCE operation to the metadata server. If the SEQUENCE operation is successful, but sr_status_flag has SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED, SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED, or SEQ4_STATUS_ADMIN_STATE_REVOKED set, the client MUST NOT use currently held layouts. The client has two choices to recover from the lease expiration. First, for all modified but uncommitted data, the client writes it to the metadata server using the FILE_SYNC4 flag for the WRITEs, or WRITE and COMMIT. Second, the client re-establishes a client ID and session with the server and obtains new layouts and device-ID-to-device-address mappings for the modified data ranges and then writes the data to the storage devices with the newly obtained layouts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リースが期限切れであるとクライアントが確信している場合は、リースを検証するまで、ストレージデバイスにI / Oを送信してはなりません。クライアントはSEQUENCE操作をメタデータサーバーに送信できます。 SEQUENCE操作は成功したが、sr_status_flagにSEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED、SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED、またはSEQ4_STATUS_ADMIN_STATE_REVOKEDが設定されている場合、クライアントは現在保持されているレイアウトを使用してはなりません（MUST NOT）。クライアントには、リースの有効期限から回復するための2つの選択肢があります。最初に、変更されたがコミットされていないすべてのデータについて、クライアントは、書き込み用のFILE_SYNC4フラグ、またはWRITEとCOMMITを使用してメタデータサーバーに書き込みます。次に、クライアントはクライアントIDとサーバーとのセッションを再確立し、変更されたデータ範囲の新しいレイアウトとデバイスIDからデバイスアドレスへのマッピングを取得して、新しく取得したレイアウトでストレージデバイスにデータを書き込みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If sr_status_flags from the metadata server has SEQ4_STATUS_RESTART_RECLAIM_NEEDED set (or SEQUENCE returns NFS4ERR_BAD_SESSION and CREATE_SESSION returns NFS4ERR_STALE_CLIENTID), then the metadata server has restarted, and the client SHOULD recover using the methods described in Section 12.7.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーからのsr_status_flagsにSEQ4_STATUS_RESTART_RECLAIM_NEEDEDが設定されている（またはSEQUENCEがNFS4ERR_BAD_SESSIONを返し、CREATE_SESSIONがNFS4ERR_STALE_CLIENTIDを返す）場合、メタデータサーバーは再起動し、クライアントはセクション12.7.4で説明されている方法を使用して回復する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If sr_status_flags from the metadata server has SEQ4_STATUS_LEASE_MOVED set, then the client recovers by following the procedure described in Section 11.7.7.1. After that, the client may get an indication that the layout state was not moved with the file system. The client recovers as in the other applicable situations discussed in the first two paragraphs of this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーからのsr_status_flagsにSEQ4_STATUS_LEASE_MOVEDが設定されている場合、クライアントはセクション11.7.7.1で説明されている手順に従って回復します。その後、クライアントは、レイアウト状態がファイルシステムと一緒に移動されなかったという指示を受け取る場合があります。クライアントは、このセクションの最初の2つの段落で説明した他の適用可能な状況と同様に回復します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If sr_status_flags reports no loss of state, then the lease for the layouts that the client has are valid and renewed, and the client can once again send I/O requests to the storage devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sr_status_flagsが状態の損失を報告しない場合、クライアントのレイアウトのリースは有効で更新されており、クライアントはもう一度I / O要求をストレージデバイスに送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While clients SHOULD NOT send I/Os to storage devices that may extend past the lease expiration time period, this is not always possible, for example, an extended network partition that starts after the I/O is sent and does not heal until the I/O request is received by the storage device. Thus, the metadata server and/or storage devices are responsible for protecting themselves from I/Os that are both sent before the lease expires and arrive after the lease expires. See Section 12.7.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはI / Oをストレージデバイスに送信しないでください（リースの有効期限を超えている可能性があります）。ただし、これが常に可能であるとは限りません。たとえば、I / Oの送信後に開始され、Iまで回復しない拡張ネットワークパーティション/ O要求がストレージデバイスによって受信されました。したがって、メタデータサーバーやストレージデバイスは、リースが期限切れになる前に送信され、リースが期限切れになった後に到着するI / Oから自分自身を保護する責任があります。 12.7.3項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-7-3--Dealing-with-Loss-of-Layout-State-on-the-Metadata-Server">
12.7.3. Dealing with Loss of Layout State on the Metadata Server
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.7.3. メタデータサーバーでのレイアウト状態の喪失への対処
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is a description of the case where all of the following are true:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、次のすべてが当てはまる場合の説明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the metadata server has not restarted
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o メタデータサーバーが再起動されていません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a pNFS client&#39;s layouts have been discarded (usually because the client&#39;s lease expired) and are invalid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o pNFSクライアントのレイアウトは破棄され（通常、クライアントのリースの期限が切れたため）、無効です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o an I/O from the pNFS client arrives at the storage device
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o pNFSクライアントからのI / Oがストレージデバイスに到着する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The metadata server and its storage devices MUST solve this by fencing the client. In other words, they MUST solve this by preventing the execution of I/O operations from the client to the storage devices after layout state loss. The details of how fencing is done are specific to the layout type. The solution for NFSv4.1 file-based layouts is described in (Section 13.11), and solutions for other layout types are in their respective external specification documents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーとそのストレージデバイスは、クライアントをフェンシングすることでこれを解決する必要があります。つまり、レイアウト状態が失われた後、クライアントからストレージデバイスへのI / O操作の実行を防ぐことで、これを解決する必要があります。フェンシングの実行方法の詳細は、レイアウトタイプに固有です。 NFSv4.1ファイルベースのレイアウトのソリューションは（セクション13.11）で説明されており、他のレイアウトタイプのソリューションはそれぞれの外部仕様ドキュメントにあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-7-4--Recovery-from-Metadata-Server-Restart">
12.7.4. Recovery from Metadata Server Restart
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.7.4. メタデータサーバーの再起動からの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pNFS client will discover that the metadata server has restarted via the methods described in Section 8.4.2 and discussed in a pNFS-specific context in Paragraph 2, of Section 12.7.2. The client MUST stop using layouts and delete the device ID to device address mappings it previously received from the metadata server. Having done that, if the client wrote data to the storage device without committing the layouts via LAYOUTCOMMIT, then the client has additional work to do in order to have the client, metadata server, and storage device(s) all synchronized on the state of the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSクライアントは、セクション8.4.2で説明され、セクション12.7.2のパラグラフ2のpNFS固有のコンテキストで説明されている方法でメタデータサーバーが再起動したことを検出します。クライアントは、レイアウトの使用を停止し、メタデータサーバーから以前に受け取ったデバイスIDからデバイスアドレスへのマッピングを削除する必要があります。これを行った後、LAYOUTCOMMITを介してレイアウトをコミットせずにクライアントがストレージデバイスにデータを書き込んだ場合、クライアントは、クライアント、メタデータサーバー、およびストレージデバイスの状態をすべて同期させるために実行する追加の作業があります。データ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the client has data still modified and unwritten in the client&#39;s memory, the client has only two choices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントのデータがまだ変更されており、クライアントのメモリに書き込まれていない場合、クライアントには2つの選択肢しかありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. The client can obtain a layout via LAYOUTGET after the server&#39;s grace period and write the data to the storage devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. クライアントは、サーバーの猶予期間後にLAYOUTGETを介してレイアウトを取得し、データをストレージデバイスに書き込むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. The client can WRITE that data through the metadata server using the WRITE (Section 18.32) operation, and then obtain layouts as desired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. クライアントは、WRITE（セクション18.32）操作を使用してメタデータサーバーを介してそのデータを書き込み、必要に応じてレイアウトを取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o If the client asynchronously wrote data to the storage device, but still has a copy of the data in its memory, then it has available to it the recovery options listed above in the previous bullet point. If the metadata server is also in its grace period, the client has available to it the options below in the next bullet point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
oクライアントが非同期でデータをストレージデバイスに書き込んでも、メモリにデータのコピーが残っている場合は、前の箇条書きで前述した回復オプションを利用できます。メタデータサーバーも猶予期間内である場合、クライアントは次の箇条書きで以下のオプションを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client does not have a copy of the data in its memory and the metadata server is still in its grace period. The client cannot use LAYOUTGET (within or outside the grace period) to reclaim a layout because the contents of the response from LAYOUTGET may not match what it had previously. The range might be different or the client might get the same range but the content of the layout might be different. Even if the content of the layout appears to be the same, the device IDs may map to different device addresses, and even if the device addresses are the same, the device addresses could have been assigned to a different storage device. The option of retrieving the data from the storage device and writing it to the metadata server per the recovery scenario described above is not available because, again, the mappings of range to device ID, device ID to device address, and device address to physical device are stale, and new mappings via new LAYOUTGET do not solve the problem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントのメモリにはデータのコピーがなく、メタデータサーバーはまだ猶予期間です。 LAYOUTGETからの応答の内容が以前のものと一致しない場合があるため、クライアントはLAYOUTGET（猶予期間内または猶予期間外）を使用してレイアウトを再利用できません。範囲が異なる場合や、クライアントが同じ範囲を取得してもレイアウトの内容が異なる場合があります。レイアウトの内容が同じであるように見えても、デバイスIDは異なるデバイスアドレスにマップされる場合があり、デバイスアドレスが同じであっても、デバイスアドレスが別のストレージデバイスに割り当てられている可能性があります。範囲のデバイスIDへのマッピング、デバイスIDからデバイスアドレスへのマッピング、およびデバイスアドレスから物理デバイスへのマッピングのため、前述の回復シナリオに従って、ストレージデバイスからデータを取得してメタデータサーバーに書き込むオプションは使用できません。は古く、新しいLAYOUTGETを介した新しいマッピングは問題を解決しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The only recovery option for this scenario is to send a LAYOUTCOMMIT in reclaim mode, which the metadata server will accept as long as it is in its grace period. The use of LAYOUTCOMMIT in reclaim mode informs the metadata server that the layout has changed. It is critical that the metadata server receive this information before its grace period ends, and thus before it starts allowing updates to the file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このシナリオの唯一の回復オプションは、再利用モードでLAYOUTCOMMITを送信することです。これは、メタデータサーバーが猶予期間である限りこれを受け入れます。再利用モードでLAYOUTCOMMITを使用すると、レイアウトが変更されたことがメタデータサーバーに通知されます。メタデータサーバーは、猶予期間が終了する前に、つまりファイルシステムへの更新を許可する前に、この情報を受信することが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
To send LAYOUTCOMMIT in reclaim mode, the client sets the loca_reclaim field of the operation&#39;s arguments (Section 18.42.1) to TRUE. During the metadata server&#39;s recovery grace period (and only during the recovery grace period) the metadata server is prepared to accept LAYOUTCOMMIT requests with the loca_reclaim field set to TRUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
再利用モードでLAYOUTCOMMITを送信するには、クライアントは操作の引数（セクション18.42.1）のloca_reclaimフィールドをTRUEに設定します。メタデータサーバーの復旧猶予期間中（および復旧猶予期間中のみ）、メタデータサーバーは、loca_reclaimフィールドがTRUEに設定されたLAYOUTCOMMIT要求を受け入れる準備ができています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When loca_reclaim is TRUE, the client is attempting to commit changes to the layout that occurred prior to the restart of the metadata server. The metadata server applies some consistency checks on the loca_layoutupdate field of the arguments to determine whether the client can commit the data written to the storage device to the file system. The loca_layoutupdate field is of data type layoutupdate4 and contains layout-type-specific content (in the lou_body field of loca_layoutupdate). The layout-type-specific information that loca_layoutupdate might have is discussed in Section 12.5.4.3. If the metadata server&#39;s consistency checks on loca_layoutupdate succeed, then the metadata server MUST commit the data (as described by the loca_offset, loca_length, and loca_layoutupdate fields of the arguments) that was written to the storage device. If the metadata server&#39;s consistency checks on loca_layoutupdate fail, the metadata server rejects the LAYOUTCOMMIT operation and makes no changes to the file system. However, any time LAYOUTCOMMIT with loca_reclaim TRUE fails, the pNFS client has lost all the data in the range defined by &lt;loca_offset, loca_length&gt;. A client can defend against this risk by caching all data, whether written synchronously or asynchronously in its memory, and by not releasing the cached data until a successful LAYOUTCOMMIT. This condition does not hold true for all layout types; for example, file-based storage devices need not suffer from this limitation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
loca_reclaimがTRUEの場合、クライアントは、メタデータサーバーの再起動前に発生したレイアウトへの変更をコミットしようとしています。メタデータサーバーは、引数のloca_layoutupdateフィールドにいくつかの整合性チェックを適用して、クライアントがストレージデバイスに書き込まれたデータをファイルシステムにコミットできるかどうかを判断します。 loca_layoutupdateフィールドはデータタイプlayoutupdate4であり、レイアウトタイプ固有のコンテンツを含みます（loca_layoutupdateのlou_bodyフィールド内）。 loca_layoutupdateが持つ可能性のあるレイアウトタイプ固有の情報については、セクション12.5.4.3で説明します。メタデータサーバーのloca_layoutupdateに対する整合性チェックが成功した場合、メタデータサーバーは、ストレージデバイスに書き込まれたデータ（引数のloca_offset、loca_length、およびloca_layoutupdateフィールドで説明）をコミットする必要があります。 loca_layoutupdateに対するメタデータサーバーの整合性チェックが失敗した場合、メタデータサーバーはLAYOUTCOMMIT操作を拒否し、ファイルシステムに変更を加えません。ただし、loca_reclaim TRUEを指定したLAYOUTCOMMITが失敗すると、pNFSクライアントは&lt;loca_offset、loca_length&gt;で定義された範囲内のすべてのデータを失います。クライアントは、同期または非同期でメモリに書き込まれたすべてのデータをキャッシュし、LAYOUTCOMMITが成功するまでキャッシュされたデータを解放しないことにより、このリスクを防ぐことができます。この条件は、すべてのレイアウトタイプに当てはまるわけではありません。たとえば、ファイルベースのストレージデバイスは、この制限を受ける必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client does not have a copy of the data in its memory and the metadata server is no longer in its grace period; i.e., the metadata server returns NFS4ERR_NO_GRACE. As with the scenario in the above bullet point, the failure of LAYOUTCOMMIT means the data in the range &lt;loca_offset, loca_length&gt; lost. The defense against the risk is the same -- cache all written data on the client until a successful LAYOUTCOMMIT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントのメモリにはデータのコピーがなく、メタデータサーバーは猶予期間ではなくなりました。つまり、メタデータサーバーはNFS4ERR_NO_GRACEを返します。上記の箇条書きのシナリオと同様に、LAYOUTCOMMITの失敗は、&lt;loca_offset、loca_length&gt;の範囲のデータが失われたことを意味します。リスクに対する防御は同じです。LAYOUTCOMMITが成功するまで、書き込まれたすべてのデータをクライアントにキャッシュします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-7-5--Operations-during-Metadata-Server-Grace-Period">
12.7.5. Operations during Metadata Server Grace Period
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.7.5. メタデータサーバーの猶予期間中の操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some of the recovery scenarios thus far noted that some operations (namely, WRITE and LAYOUTGET) might be permitted during the metadata server&#39;s grace period. The metadata server may allow these operations during its grace period. For LAYOUTGET, the metadata server must reliably determine that servicing such a request will not conflict with an impending LAYOUTCOMMIT reclaim request. For WRITE, the metadata server must reliably determine that servicing the request will not conflict with an impending OPEN or with a LOCK where the file has mandatory byte-range locking enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまでの回復シナリオの一部では、メタデータサーバーの猶予期間中に一部の操作（つまり、WRITEおよびLAYOUTGET）が許可される可能性があると指摘されていました。メタデータサーバーは、猶予期間中にこれらの操作を許可する場合があります。 LAYOUTGETの場合、メタデータサーバーは、そのような要求の処理が、差し迫ったLAYOUTCOMMIT再利用要求と競合しないことを確実に判断する必要があります。書き込みの場合、メタデータサーバーは、リクエストのサービスが、差し迫ったOPENや、ファイルで必須のバイト範囲ロックが有効になっているLOCKと競合しないことを確実に判断する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned previously, for expediency, the metadata server might reject some operations (namely, WRITE and LAYOUTGET) during its grace period, because the simplest correct approach is to reject all non-reclaim pNFS requests and WRITE operations by returning the NFS4ERR_GRACE error. However, depending on the storage protocol (which is specific to the layout type) and metadata server implementation, the metadata server may be able to determine that a particular request is safe. For example, a metadata server may save provisional allocation mappings for each file to stable storage, as well as information about potentially conflicting OPEN share modes and mandatory byte-range locks that might have been in effect at the time of restart, and the metadata server may use this information during the recovery grace period to determine that a WRITE request is safe.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前述のように、便宜上、メタデータサーバーは猶予期間中に一部の操作（つまり、書き込みとLAYOUTGET）を拒否することがあります。これは、NFS4ERR_GRACEエラーを返すことにより、再利用されていないすべてのpNFS要求と書き込み操作を拒否するためです。ただし、ストレージプロトコル（レイアウトタイプに固有）とメタデータサーバーの実装によっては、メタデータサーバーが特定のリクエストが安全であると判断できる場合があります。たとえば、メタデータサーバーは、各ファイルの暫定的な割り当てマッピングを、安定したストレージに保存することができます。また、再起動時に有効であった可能性のあるOPEN共有モードと必須のバイト範囲ロックについての情報だけでなく、メタデータサーバーも保存できます。リカバリ猶予期間中にこの情報を使用して、書き込み要求が安全であると判断する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-7-6--Storage-Device-Recovery">
12.7.6. Storage Device Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.7.6. ストレージデバイスの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recovery from storage device restart is mostly dependent upon the layout type in use. However, there are a few general techniques a client can use if it discovers a storage device has crashed while holding modified, uncommitted data that was asynchronously written. First and foremost, it is important to realize that the client is the only one that has the information necessary to recover non-committed data since it holds the modified data and probably nothing else does. Second, the best solution is for the client to err on the side of caution and attempt to rewrite the modified data through another path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージデバイスの再起動からの回復は、使用しているレイアウトタイプに大きく依存します。ただし、非同期で書き込まれた変更されたコミットされていないデータを保持しているときにストレージデバイスがクラッシュしたことを検出した場合、クライアントが使用できるいくつかの一般的な手法があります。何よりもまず、クライアントは、コミットされていないデータを復元するために必要な情報を持つ唯一のクライアントであることを理解することが重要です。次に、最善の解決策は、クライアントが注意を怠ってエラーを修正し、別のパスを介して変更されたデータを書き換えようとすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client SHOULD immediately WRITE the data to the metadata server, with the stable field in the WRITE4args set to FILE_SYNC4. Once it does this, there is no need to wait for the original storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、WRITE4argsのstableフィールドをFILE_SYNC4に設定して、すぐにメタデータサーバーにデータを書き込む必要があります（SHOULD）。これを行うと、元のストレージデバイスを待つ必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-8--Metadata-and-Storage-Device-Roles">
12.8. Metadata and Storage Device Roles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.8. メタデータとストレージデバイスの役割
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the same physical hardware is used to implement both a metadata server and storage device, then the same hardware entity is to be understood to be implementing two distinct roles and it is important that it be clearly understood on behalf of which role the hardware is executing at any given time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーとストレージデバイスの両方を実装するために同じ物理ハードウェアが使用されている場合、同じハードウェアエンティティは2つの異なる役割を実装していると理解され、ハードウェアが実行している役割に代わって明確に理解されることが重要です。いつでも。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two sub-cases can be distinguished.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのサブケースを区別できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The storage device uses NFSv4.1 as the storage protocol, i.e., the same physical hardware is used to implement both a metadata and data server. See Section 13.1 for a description of how multiple roles are handled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. ストレージデバイスは、ストレージプロトコルとしてNFSv4.1を使用します。つまり、同じ物理ハードウェアを使用して、メタデータとデータサーバーの両方を実装します。複数のロールの処理方法については、セクション13.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The storage device does not use NFSv4.1 as the storage protocol, and the same physical hardware is used to implement both a metadata and storage device. Whether distinct network addresses are used to access the metadata server and storage device is immaterial. This is because it is always clear to the pNFS client and server, from the upper-layer protocol being used (NFSv4.1 or non-NFSv4.1), to which role the request to the common server network address is directed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. ストレージデバイスはストレージプロトコルとしてNFSv4.1を使用せず、同じ物理ハードウェアを使用してメタデータとストレージデバイスの両方を実装します。メタデータサーバーとストレージデバイスへのアクセスに個別のネットワークアドレスを使用するかどうかは重要ではありません。これは、使用されている上位層プロトコル（NFSv4.1または非NFSv4.1）から、共通サーバーネットワークアドレスへの要求が向けられる役割が、pNFSクライアントおよびサーバーに常に明確であるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-9--Security-Considerations-for-pNFS">
12.9. Security Considerations for pNFS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.9. pNFSのセキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 pNFS separates file system metadata and data and provides access to both. There are pNFS-specific operations (listed in Section 12.3) that provide access to the metadata; all existing NFSv4.1 conventional (non-pNFS) security mechanisms and features apply to accessing the metadata. The combination of components in a pNFS system (see Figure 1) is required to preserve the security properties of NFSv4.1 with respect to an entity that is accessing a storage device from a client, including security countermeasures to defend against threats for which NFSv4.1 provides defenses in environments where these threats are considered significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
pNFSは、ファイルシステムのメタデータとデータを分離し、両方へのアクセスを提供します。メタデータへのアクセスを提供するpNFS固有の操作（セクション12.3に記載）があります。メタデータへのアクセスには、既存のすべてのNFSv4.1従来型（非pNFS）セキュリティメカニズムと機能が適用されます。 NFSv4の脅威を防御するためのセキュリティ対策を含め、クライアントからストレージデバイスにアクセスしているエンティティに関するNFSv4.1のセキュリティプロパティを維持するには、pNFSシステムのコンポーネントの組み合わせ（図1を参照）が必要です。 1は、これらの脅威が重要であると見なされる環境で防御を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some cases, the security countermeasures for connections to storage devices may take the form of physical isolation or a recommendation to avoid the use of pNFS in an environment. For example, it may be impractical to provide confidentiality protection for some storage protocols to protect against eavesdropping. In environments where eavesdropping on such protocols is of sufficient concern to require countermeasures, physical isolation of the communication channel (e.g., via direct connection from client(s) to storage device(s)) and/or a decision to forgo use of pNFS (e.g., and fall back to conventional NFSv4.1) may be appropriate courses of action.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
場合によっては、ストレージデバイスへの接続のセキュリティ対策は、物理的分離または環境でのpNFSの使用を回避するための推奨の形を取ることがあります。たとえば、盗聴から保護するために一部のストレージプロトコルに機密保護を提供することは非現実的です。そのようなプロトコルの盗聴が対策を必要とするのに十分な懸念がある環境では、通信チャネルの物理的な分離（たとえば、クライアントからストレージデバイスへの直接接続を介して）、および/またはpNFSの使用を断念する決定（たとえば、従来のNFSv4.1にフォールバックすることは、適切な一連の行動である可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where communication with storage devices is subject to the same threats as client-to-metadata server communication, the protocols used for that communication need to provide security mechanisms as strong as or no weaker than those available via RPCSEC_GSS for NFSv4.1. Except for the storage protocol used for the LAYOUT4_NFSV4_1_FILES layout (see Section 13), i.e., except for NFSv4.1, it is beyond the scope of this document to specify the security mechanisms for storage access protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージデバイスとの通信がクライアントからメタデータサーバーへの通信と同じ脅威を受ける場合、その通信に使用されるプロトコルは、NFSv4.1のRPCSEC_GSSを介して利用可能なものと同等またはそれ以上のセキュリティメカニズムを提供する必要があります。 LAYOUT4_NFSV4_1_FILESレイアウト（セクション13を参照）に使用されるストレージプロトコルを除いて、つまりNFSv4.1を除いて、ストレージアクセスプロトコルのセキュリティメカニズムを指定することは、このドキュメントの範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 pNFS implementations MUST NOT remove NFSv4.1&#39;s access controls. The combination of clients, storage devices, and the metadata server are responsible for ensuring that all client-to-storage-device file data access respects NFSv4.1&#39;s ACLs and file open modes. This entails performing both of these checks on every access in the client, the storage device, or both (as applicable; when the storage device is an NFSv4.1 server, the storage device is ultimately responsible for controlling access as described in Section 13.9.2). If a pNFS configuration performs these checks only in the client, the risk of a misbehaving client obtaining unauthorized access is an important consideration in determining when it is appropriate to use such a pNFS configuration. Such layout types SHOULD NOT be used when client-only access checks do not provide sufficient assurance that NFSv4.1 access control is being applied correctly. (This is not a problem for the file layout type described in Section 13 because the storage access protocol for LAYOUT4_NFSV4_1_FILES is NFSv4.1, and thus the security model for storage device access via LAYOUT4_NFSv4_1_FILES is the same as that of the metadata server.) For handling of access control specific to a layout, the reader should examine the layout specification, such as the NFSv4.1/ file-based layout (Section 13) of this document, the blocks layout [41], and objects layout [40].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
pNFS実装は、NFSv4.1のアクセス制御を削除してはなりません（MUST NOT）。クライアント、ストレージデバイス、およびメタデータサーバーの組み合わせは、クライアントからストレージデバイスへのすべてのファイルデータアクセスがNFSv4.1のACLとファイルオープンモードを確実に順守する責任があります。これには、クライアント、ストレージデバイス、またはその両方のすべてのアクセスでこれらのチェックの両方を実行する必要があります（該当する場合。ストレージデバイスがNFSv4.1サーバーの場合、ストレージデバイスは、セクション13.9で説明されているように、最終的にアクセスを制御します。 2）。 pNFS構成がこれらのチェックをクライアントのみで実行する場合、不正な動作をするクライアントが不正アクセスを取得するリスクは、そのようなpNFS構成をいつ使用するのが適切であるかを判断する上で重要な考慮事項です。このようなレイアウトタイプは、クライアントのみのアクセスチェックでNFSv4.1アクセス制御が正しく適用されていることを十分に保証できない場合は使用しないでください。 （LAYOUT4_NFSV4_1_FILESのストレージアクセスプロトコルはNFSv4.1であり、LAYOUT4_NFSv4_1_FILESを介したストレージデバイスアクセスのセキュリティモデルはメタデータサーバーのセキュリティモデルと同じであるため、これはセクション13で説明するファイルレイアウトタイプの問題ではありません。）レイアウトに固有のアクセス制御の処理については、読者は、このドキュメントのNFSv4.1 /ファイルベースのレイアウト（セクション13）、ブロックレイアウト[41]、オブジェクトレイアウト[40]などのレイアウト仕様を調べる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13--NFSv4-1-as-a-Storage-Protocol-in-pNFS-the-File-Layout-Type">
13. NFSv4.1 as a Storage Protocol in pNFS: the File Layout Type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. pNFSのストレージプロトコルとしてのNFSv4.1：ファイルレイアウトタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the semantics and format of NFSv4.1 file-based layouts for pNFS. NFSv4.1 file-based layouts use the LAYOUT4_NFSV4_1_FILES layout type. The LAYOUT4_NFSV4_1_FILES type defines striping data across multiple NFSv4.1 data servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、pNFSのNFSv4.1ファイルベースのレイアウトのセマンティクスと形式について説明します。 NFSv4.1ファイルベースのレイアウトは、LAYOUT4_NFSV4_1_FILESレイアウトタイプを使用します。 LAYOUT4_NFSV4_1_FILESタイプは、複数のNFSv4.1データサーバーにわたるデータのストライピングを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-1--Client-ID-and-Session-Considerations">
13.1. Client ID and Session Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. クライアントIDとセッションに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sessions are a REQUIRED feature of NFSv4.1, and this extends to both the metadata server and file-based (NFSv4.1-based) data servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションはNFSv4.1の必須機能であり、これはメタデータサーバーとファイルベース（NFSv4.1ベース）のデータサーバーの両方に拡張されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The role a server plays in pNFS is determined by the result it returns from EXCHANGE_ID. The roles are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがpNFSで果たす役割は、EXCHANGE_IDから返される結果によって決まります。役割は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Metadata server (EXCHGID4_FLAG_USE_PNFS_MDS is set in the result eir_flags).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o メタデータサーバー（EXCHGID4_FLAG_USE_PNFS_MDSが結果のeir_flagsに設定されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Data server (EXCHGID4_FLAG_USE_PNFS_DS).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o データサーバー（EXCHGID4_FLAG_USE_PNFS_DS）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Non-metadata server (EXCHGID4_FLAG_USE_NON_PNFS). This is an NFSv4.1 server that does not support operations (e.g., LAYOUTGET) or attributes that pertain to pNFS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 非メタデータサーバー（EXCHGID4_FLAG_USE_NON_PNFS）。これは、pNFSに関連する操作（LAYOUTGETなど）または属性をサポートしないNFSv4.1サーバーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MAY request zero or more of EXCHGID4_FLAG_USE_NON_PNFS, EXCHGID4_FLAG_USE_PNFS_DS, or EXCHGID4_FLAG_USE_PNFS_MDS, even though some combinations (e.g., EXCHGID4_FLAG_USE_NON_PNFS | EXCHGID4_FLAG_USE_PNFS_MDS) are contradictory. However, the server MUST only return the following acceptable combinations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの組み合わせ（例：EXCHGID4_FLAG_USE_NON_PNFS | EXCHGDSPFL_AGCH_DS_FLAG_USE_NON_PNFS_EXCHGID_FLAG_USE_PNFS）は、クライアントが0個以上のEXCHGID4_FLAG_USE_NON_PNFS、EXCHGID4_FLAG_USE_PNFS_DS、またはEXCHGID4_FLAG_USE_PNFS_MDSを要求する場合があります。ただし、サーバーは次の受け入れ可能な組み合わせのみを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        +--------------------------------------------------------+
        | Acceptable Results from EXCHANGE_ID                    |
        +--------------------------------------------------------+
        | EXCHGID4_FLAG_USE_PNFS_MDS                             |
        | EXCHGID4_FLAG_USE_PNFS_MDS | EXCHGID4_FLAG_USE_PNFS_DS |
        | EXCHGID4_FLAG_USE_PNFS_DS                              |
        | EXCHGID4_FLAG_USE_NON_PNFS                             |
        | EXCHGID4_FLAG_USE_PNFS_DS | EXCHGID4_FLAG_USE_NON_PNFS |
        +--------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 As the above table implies, a server can have one or two roles. A server can be both a metadata server and a data server, or it can be both a data server and non-metadata server. In addition to returning two roles in the EXCHANGE_ID&#39;s results, and thus serving both roles via a common client ID, a server can serve two roles by returning a unique client ID and server owner for each role in each of two EXCHANGE_ID results, with each result indicating each role.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
上記の表が示すように、サーバーは1つまたは2つの役割を持つことができます。サーバーは、メタデータサーバーとデータサーバーの両方にすることも、データサーバーと非メタデータサーバーの両方にすることもできます。 EXCHANGE_IDの結果で2つの役割を返し、共通のクライアントIDを介して両方の役割を提供することに加えて、サーバーは、2つのEXCHANGE_ID結果のそれぞれで各役割の一​​意のクライアントIDとサーバー所有者を返すことにより、2つの役割を提供できます。各役割を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of a server with concurrent pNFS roles that are served by a common client ID, if the EXCHANGE_ID request from the client has zero or a combination of the bits set in eia_flags, the server result should set bits that represent the higher of the acceptable combination of the server roles, with a preference to match the roles requested by the client. Thus, if a client request has (EXCHGID4_FLAG_USE_NON_PNFS | EXCHGID4_FLAG_USE_PNFS_MDS | EXCHGID4_FLAG_USE_PNFS_DS) flags set, and the server is both a metadata server and a data server, serving both the roles by a common client ID, the server SHOULD return with (EXCHGID4_FLAG_USE_PNFS_MDS | EXCHGID4_FLAG_USE_PNFS_DS) set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共通のクライアントIDによって処理される並行pNFSロールを持つサーバーの場合、クライアントからのEXCHANGE_IDリクエストにゼロまたはeia_flagsで設定されたビットの組み合わせがある場合、サーバーの結果は、より高いビットを表すビットを設定する必要がありますサーバーの役割の許容できる組み合わせ、およびクライアントから要求された役割に一致する設定。したがって、クライアント要求に（EXCHGID4_FLAG_USE_NON_PNFS | EXCHGID4_FLAG_USE_PNFS_MDS | EXCHGID4_FLAG_USE_PNFS_DS）フラグが設定されていて、サーバーがメタデータサーバーとデータサーバーの両方であり、共通のクライアントIDによって両方の役割を提供している場合、セットする。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of a server that has multiple concurrent pNFS roles, each role served by a unique client ID, if the client specifies zero or a combination of roles in the request, the server results SHOULD return only one of the roles from the combination specified by the client request. If the role specified by the server result does not match the intended use by the client, the client should send the EXCHANGE_ID specifying just the interested pNFS role.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数の同時pNFS役割を持つサーバーの場合、各役割は一意のクライアントIDによって処理されます。クライアントがリクエストでゼロまたは役割の組み合わせを指定した場合、サーバーの結果は、指定された組み合わせから役割の1つのみを返す必要があります（SHOULD）。クライアントの要求によって。サーバーの結果によって指定されたロールがクライアントの使用目的と一致しない場合、クライアントは、関心のあるpNFSロールのみを指定するEXCHANGE_IDを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a pNFS metadata client gets a layout that refers it to an NFSv4.1 data server, it needs a client ID on that data server. If it does not yet have a client ID from the server that had the EXCHGID4_FLAG_USE_PNFS_DS flag set in the EXCHANGE_ID results, then the client needs to send an EXCHANGE_ID to the data server, using the same co_ownerid as it sent to the metadata server, with the EXCHGID4_FLAG_USE_PNFS_DS flag set in the arguments. If the server&#39;s EXCHANGE_ID results have EXCHGID4_FLAG_USE_PNFS_DS set, then the client may use the client ID to create sessions that will exchange pNFS data operations. The client ID returned by the data server has no relationship with the client ID returned by a metadata server unless the client IDs are equal, and the server owners and server scopes of the data server and metadata server are equal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSメタデータクライアントがNFSv4.1データサーバーを参照するレイアウトを取得する場合、そのデータサーバー上にクライアントIDが必要です。 EXCHANGE_IDの結果にEXCHGID4_FLAG_USE_PNFS_DSフラグが設定されているサーバーからのクライアントIDがまだない場合、クライアントは、メタデータサーバーに送信したのと同じco_owneridを使用して、EXCHANGE_IDをデータサーバーに送信する必要があります。引数に設定されたEXCHGID4_FLAG_USE_PNFS_DSフラグ。サーバーのEXCHANGE_IDの結果にEXCHGID4_FLAG_USE_PNFS_DSが設定されている場合、クライアントはクライアントIDを使用して、pNFSデータ操作を交換するセッションを作成できます。データサーバーから返されるクライアントIDは、クライアントIDが等しく、データサーバーとメタデータサーバーのサーバー所有者とサーバースコープが同じでない限り、メタデータサーバーによって返されるクライアントIDとは関係ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In NFSv4.1, the session ID in the SEQUENCE operation implies the client ID, which in turn might be used by the server to map the stateid to the right client/server pair. However, when a data server is presented with a READ or WRITE operation with a stateid, because the stateid is associated with a client ID on a metadata server, and because the session ID in the preceding SEQUENCE operation is tied to the client ID of the data server, the data server has no obvious way to determine the metadata server from the COMPOUND procedure, and thus has no way to validate the stateid. One RECOMMENDED approach is for pNFS servers to encode metadata server routing and/or identity information in the data server filehandles as returned in the layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFSv4.1では、SEQUENCE操作のセッションIDはクライアントIDを意味します。これは、サーバーがstateidを正しいクライアント/サーバーのペアにマップするために使用する可能性があります。ただし、stateidがメタデータサーバーのクライアントIDに関連付けられているため、および前述のSEQUENCE操作のセッションIDがデータサーバーの場合、データサーバーにはCOMPOUNDプロシージャからメタデータサーバーを特定する明確な方法がないため、stateidを検証する方法はありません。推奨されるアプローチの1つは、pNFSサーバーがレイアウトで返されるメタデータサーバーのルーティングやID情報をデータサーバーのファイルハンドルにエンコードすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If metadata server routing and/or identity information is encoded in data server filehandles, when the metadata server identity or location changes, the data server filehandles it gave out will become invalid (stale), and so the metadata server MUST first recall the layouts. Invalidating a data server filehandle does not render the NFS client&#39;s data cache invalid. The client&#39;s cache should map a data server filehandle to a metadata server filehandle, and a metadata server filehandle to cached data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーのルーティングやID情報がデータサーバーのファイルハンドルでエンコードされている場合、メタデータサーバーのIDまたは場所が変更されると、メタデータサーバーが提供したデータサーバーのファイルハンドルが無効（失効）になるため、メタデータサーバーは最初にレイアウトをリコールする必要があります。データサーバーのファイルハンドルを無効化しても、NFSクライアントのデータキャッシュは無効になりません。クライアントのキャッシュは、データサーバーのファイルハンドルをメタデータサーバーのファイルハンドルにマップし、メタデータサーバーのファイルハンドルをキャッシュされたデータにマップする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server is both a metadata server and a data server, the server might need to distinguish operations on files that are directed to the metadata server from those that are directed to the data server. It is RECOMMENDED that the values of the filehandles returned by the LAYOUTGET operation be different than the value of the filehandle returned by the OPEN of the same file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがメタデータサーバーとデータサーバーの両方である場合、サーバーは、メタデータサーバーに送られるファイルの操作とデータサーバーに送られるファイルの操作を区別する必要がある場合があります。 LAYOUTGET操作によって返されるファイルハンドルの値は、同じファイルのOPENによって返されるファイルハンドルの値とは異なることが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another scenario is for the metadata server and the storage device to be distinct from one client&#39;s point of view, and the roles reversed from another client&#39;s point of view. For example, in the cluster file system model, a metadata server to one client might be a data server to another client. If NFSv4.1 is being used as the storage protocol, then pNFS servers need to encode the values of filehandles according to their specific roles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別のシナリオでは、メタデータサーバーとストレージデバイスを1つのクライアントの観点から区別し、役割を別のクライアントの観点から逆にします。たとえば、クラスタファイルシステムモデルでは、あるクライアントへのメタデータサーバーが別のクライアントへのデータサーバーになる場合があります。 NFSv4.1がストレージプロトコルとして使用されている場合、pNFSサーバーは特定の役割に従ってファイルハンドルの値をエンコードする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-1-1--Sessions-Considerations-for-Data-Servers">
13.1.1. Sessions Considerations for Data Servers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1. データサーバーのセッションに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 2.10.11.2 states that a client has to keep its lease renewed in order to prevent a session from being deleted by the server. If the reply to EXCHANGE_ID has just the EXCHGID4_FLAG_USE_PNFS_DS role set, then (as noted in Section 13.6) the client will not be able to determine the data server&#39;s lease_time attribute because GETATTR will not be permitted. Instead, the rule is that any time a client receives a layout referring it to a data server that returns just the EXCHGID4_FLAG_USE_PNFS_DS role, the client MAY assume that the lease_time attribute from the metadata server that returned the layout applies to the data server. Thus, the data server MUST be aware of the values of all lease_time attributes of all metadata servers for which it is providing I/O, and it MUST use the maximum of all such lease_time values as the lease interval for all client IDs and sessions established on it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.10.11.2項では、サーバーがセッションを削除しないようにするために、クライアントはリースを更新し続ける必要があると述べています。 EXCHANGE_IDへの応答にEXCHGID4_FLAG_USE_PNFS_DSロールセットのみがある場合、（セクション13.6で説明したように）GETATTRが許可されないため、クライアントはデータサーバーのlease_time属性を決定できません。代わりに、EXCHGID4_FLAG_USE_PNFS_DSロールのみを返すデータサーバーを参照するレイアウトをクライアントが受信するたびに、クライアントは、レイアウトを返したメタデータサーバーからのlease_time属性がデータサーバーに適用されると見なす場合があります。したがって、データサーバーは、I / Oを提供するすべてのメタデータサーバーのすべてのlease_time属性の値を認識している必要があり、確立されているすべてのクライアントIDとセッションのリース間隔として、そのようなすべてのlease_time値の最大値を使用する必要があります。その上に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 For example, if one metadata server has a lease_time attribute of 20 seconds, and a second metadata server has a lease_time attribute of 10 seconds, then if both servers return layouts that refer to an EXCHGID4_FLAG_USE_PNFS_DS-only data server, the data server MUST renew a client&#39;s lease if the interval between two SEQUENCE operations on different COMPOUND requests is less than 20 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
たとえば、1つのメタデータサーバーが20秒のlease_time属性を持ち、2番目のメタデータサーバーが10秒のlease_time属性を持っている場合、両方のサーバーがEXCHGID4_FLAG_USE_PNFS_DSのみのデータサーバーを参照するレイアウトを返す場合、データサーバーは更新する必要があります。異なるCOMPOUNDリクエストに対する2つのSEQUENCE操作の間隔が20秒未満の場合のクライアントのリース。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-2--File-Layout-Definitions">
13.2. File Layout Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. ファイルレイアウト定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following definitions apply to the LAYOUT4_NFSV4_1_FILES layout type and may be applicable to other layout types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の定義は、LAYOUT4_NFSV4_1_FILESレイアウトタイプに適用され、他のレイアウトタイプに適用できる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unit. A unit is a fixed-size quantity of data written to a data server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単位。ユニットは、データサーバーに書き込まれる固定サイズのデータ​​量です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pattern. A pattern is a method of distributing one or more equal sized units across a set of data servers. A pattern is iterated one or more times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パターン。パターンは、1つ以上の同じサイズのユニットをデータサーバーのセット全体に分散する方法です。パターンは1回以上繰り返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stripe. A stripe is a set of data distributed across a set of data servers in a pattern before that pattern repeats.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
縞。ストライプは、パターンが繰り返される前に、パターン内のデータサーバーのセット全体に分散されたデータのセットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stripe Count. A stripe count is the number of units in a pattern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストライプ数。ストライプカウントは、パターン内のユニット数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stripe Width. A stripe width is the size of a stripe in bytes. The stripe width = the stripe count * the size of the stripe unit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストライプ幅。ストライプ幅は、ストライプのサイズ（バイト単位）です。ストライプ幅=ストライプ数*ストライプユニットのサイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hereafter, this document will refer to a unit that is a written in a pattern as a &#34;stripe unit&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下、この文書では、パターンで書かれたユニットを「ストライプユニット」と呼ぶ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A pattern may have more stripe units than data servers. If so, some data servers will have more than one stripe unit per stripe. A data server that has multiple stripe units per stripe MAY store each unit in a different data file (and depending on the implementation, will possibly assign a unique data filehandle to each data file).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パターンには、データサーバーよりも多くのストライプユニットがある場合があります。その場合、一部のデータサーバーには、ストライプごとに複数のストライプユニットがあります。ストライプごとに複数のストライプユニットを持つデータサーバーは、各ユニットを異なるデータファイルに格納できます（実装によっては、一意のデータファイルハンドルを各データファイルに割り当てる可能性があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-3--File-Layout-Data-Types">
13.3. File Layout Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3. ファイルレイアウトのデータタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The high level NFSv4.1 layout types are nfsv4_1_file_layouthint4, nfsv4_1_file_layout_ds_addr4, and nfsv4_1_file_layout4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高レベルのNFSv4.1レイアウトタイプは、nfsv4_1_file_layouthint4、nfsv4_1_file_layout_ds_addr4、およびnfsv4_1_file_layout4です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SETATTR operation supports a layout hint attribute (Section 5.12.4). When the client sets a layout hint (data type layouthint4) with a layout type of LAYOUT4_NFSV4_1_FILES (the loh_type field), the loh_body field contains a value of data type nfsv4_1_file_layouthint4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTR操作は、レイアウトヒント属性をサポートします（5.12.4項）。クライアントがレイアウトタイプLAYOUT4_NFSV4_1_FILES（loh_typeフィールド）でレイアウトヒント（データタイプlayouthint4）を設定すると、loh_bodyフィールドにはデータタイプnfsv4_1_file_layouthint4の値が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const NFL4_UFLG_MASK            = 0x0000003F;
   const NFL4_UFLG_DENSE           = 0x00000001;
   const NFL4_UFLG_COMMIT_THRU_MDS = 0x00000002;
   const NFL4_UFLG_STRIPE_UNIT_SIZE_MASK
                                   = 0xFFFFFFC0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t nfl_util4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t nfl_util4;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum filelayout_hint_care4 { NFLH4_CARE_DENSE = NFL4_UFLG_DENSE,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙型filelayout_hint_care4 {NFLH4_CARE_DENSE = NFL4_UFLG_DENSE、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
NFLH4_CARE_COMMIT_THRU_MDS = NFL4_UFLG_COMMIT_THRU_MDS,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
NFLH4_CARE_COMMIT_THRU_MDS = NFL4_UFLG_COMMIT_THRU_MDS、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
NFLH4_CARE_STRIPE_UNIT_SIZE = 0x00000040,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
NFLH4_CARE_STRIPE_UNIT_SIZE = 0x00000040、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 NFLH4_CARE_STRIPE_COUNT = 0x00000080 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFLH4_CARE_STRIPE_COUNT = 0x00000080};
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Encoded in the loh_body field of data type layouthint4: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfsv4_1_file_layouthint4 {
           uint32_t        nflh_care;
           nfl_util4       nflh_util;
           count4          nflh_stripe_count;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The generic layout hint structure is described in Section 3.3.19. The client uses the layout hint in the layout_hint (Section 5.12.4) attribute to indicate the preferred type of layout to be used for a newly created file. The LAYOUT4_NFSV4_1_FILES layout-type-specific content for the layout hint is composed of three fields. The first field, nflh_care, is a set of flags indicating which values of the hint the client cares about. If the NFLH4_CARE_DENSE flag is set, then the client indicates in the second field, nflh_util, a preference for how the data file is packed (Section 13.4.4), which is controlled by the value of the expression nflh_util &amp; NFL4_UFLG_DENSE (&#34;&amp;&#34; represents the bitwise AND operator). If the NFLH4_CARE_COMMIT_THRU_MDS flag is set, then the client indicates a preference for whether the client should send COMMIT operations to the metadata server or data server (Section 13.7), which is controlled by the value of nflh_util &amp; NFL4_UFLG_COMMIT_THRU_MDS. If the NFLH4_CARE_STRIPE_UNIT_SIZE flag is set, the client indicates its preferred stripe unit size, which is indicated in nflh_util &amp; NFL4_UFLG_STRIPE_UNIT_SIZE_MASK (thus, the stripe unit size MUST be a multiple of 64 bytes). The minimum stripe unit size is 64 bytes. If the NFLH4_CARE_STRIPE_COUNT flag is set, the client indicates in the third field, nflh_stripe_count, the stripe count. The stripe count multiplied by the stripe unit size is the stripe width.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
一般的なレイアウトヒント構造については、3.3.19節で説明します。クライアントは、layout_hint（5.12.4節）属性のレイアウトヒントを使用して、新しく作成されたファイルに使用するレイアウトの優先タイプを示します。レイアウトヒントのLAYOUT4_NFSV4_1_FILESレイアウトタイプ固有のコンテンツは、3つのフィールドで構成されています。最初のフィールドnflh_careは、クライアントが気にするヒントの値を示すフラグのセットです。 NFLH4_CARE_DENSEフラグが設定されている場合、クライアントは2番目のフィールドnflh_utilにデータファイルのパック方法の優先順位を示し（セクション13.4.4）、これは式nflh_util＆NFL4_UFLG_DENSE（ &#34;＆&#34;の値によって制御されます。ビットごとのAND演算子を表します）。 NFLH4_CARE_COMMIT_THRU_MDSフラグが設定されている場合、クライアントは、クライアントがCOMMIT操作をメタデータサーバーまたはデータサーバーに送信するかどうかの設定を示し（セクション13.7）、これはnflh_utilおよびNFL4_UFLG_COMMIT_THRU_MDSの値によって制御されます。 NFLH4_CARE_STRIPE_UNIT_SIZEフラグが設定されている場合、クライアントはnflh_utilおよびNFL4_UFLG_STRIPE_UNIT_SIZE_MASKで示される優先ストライプユニットサイズを示します（したがって、ストライプユニットサイズは64バイトの倍数でなければなりません）。ストライプユニットの最小サイズは64バイトです。 NFLH4_CARE_STRIPE_COUNTフラグが設定されている場合、クライアントは3番目のフィールドであるnflh_stripe_countのストライプカウントを示します。ストライプカウントにストライプユニットサイズを掛けると、ストライプ幅になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When LAYOUTGET returns a LAYOUT4_NFSV4_1_FILES layout (indicated in the loc_type field of the lo_content field), the loc_body field of the lo_content field contains a value of data type nfsv4_1_file_layout4. Among other content, nfsv4_1_file_layout4 has a storage device ID (field nfl_deviceid) of data type deviceid4. The GETDEVICEINFO operation maps a device ID to a storage device address (type device_addr4). When GETDEVICEINFO returns a device address with a layout type of LAYOUT4_NFSV4_1_FILES (the da_layout_type field), the da_addr_body field contains a value of data type nfsv4_1_file_layout_ds_addr4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTGETがLAYOUT4_NFSV4_1_FILESレイアウト（lo_contentフィールドのloc_typeフィールドで示される）を返す場合、lo_contentフィールドのloc_bodyフィールドには、データ型nfsv4_1_file_layout4の値が含まれます。他のコンテンツの中でも、nfsv4_1_file_layout4には、データ型deviceid4のストレージデバイスID（フィールドnfl_deviceid）があります。 GETDEVICEINFO操作は、デバイスIDをストレージデバイスアドレス（type device_addr4）にマップします。 GETDEVICEINFOがレイアウトタイプがLAYOUT4_NFSV4_1_FILES（da_layout_typeフィールド）のデバイスアドレスを返す場合、da_addr_bodyフィールドにはデータ型nfsv4_1_file_layout_ds_addr4の値が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef netaddr4 multipath_list4&lt;&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Encoded in the da_addr_body field of
    * data type device_addr4:
    */
   struct nfsv4_1_file_layout_ds_addr4 {
           uint32_t        nflda_stripe_indices&lt;&gt;;
           multipath_list4 nflda_multipath_ds_list&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfsv4_1_file_layout_ds_addr4 data type represents the device address. It is composed of two fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfsv4_1_file_layout_ds_addr4データ型はデバイスアドレスを表します。 2つのフィールドで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. nflda_multipath_ds_list: An array of lists of data servers, where each list can be one or more elements, and each element represents a data server address that may serve equally as the target of I/O operations (see Section 13.5). The length of this array might be different than the stripe count.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. nflda_multipath_ds_list：データサーバーのリストの配列。各リストは1つ以上の要素であり、各要素は、I / O操作のターゲットとして等しく機能するデータサーバーアドレスを表します（セクション13.5を参照）。この配列の長さは、ストライプ数とは異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. nflda_stripe_indices: An array of indices used to index into nflda_multipath_ds_list. The value of each element of nflda_stripe_indices MUST be less than the number of elements in nflda_multipath_ds_list. Each element of nflda_multipath_ds_list SHOULD be referred to by one or more elements of nflda_stripe_indices. The number of elements in nflda_stripe_indices is always equal to the stripe count.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. nflda_stripe_indices：nflda_multipath_ds_listへのインデックス付けに使用されるインデックスの配列。 nflda_stripe_indicesの各要素の値は、nflda_multipath_ds_listの要素の数よりも小さい必要があります。 nflda_multipath_ds_listの各要素は、nflda_stripe_indicesの1つ以上の要素によって参照される必要があります（SHOULD）。 nflda_stripe_indicesの要素数は、常にストライプカウントと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Encoded in the loc_body field of
    * data type layout_content4:
    */
   struct nfsv4_1_file_layout4 {
            deviceid4      nfl_deviceid;
            nfl_util4      nfl_util;
            uint32_t       nfl_first_stripe_index;
            offset4        nfl_pattern_offset;
            nfs_fh4        nfl_fh_list&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfsv4_1_file_layout4 data type represents the layout. It is composed of the following fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfsv4_1_file_layout4データ型はレイアウトを表します。次のフィールドで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. nfl_deviceid: The device ID that maps to a value of type nfsv4_1_file_layout_ds_addr4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. nfl_deviceid：タイプnfsv4_1_file_layout_ds_addr4の値にマップするデバイスID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. nfl_util: Like the nflh_util field of data type nfsv4_1_file_layouthint4, a compact representation of how the data on a file on each data server is packed, whether the client should send COMMIT operations to the metadata server or data server, and the stripe unit size. If a server returns two or more overlapping layouts, each stripe unit size in each overlapping layout MUST be the same.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. nfl_util：データ型nfsv4_1_file_layouthint4のnflh_utilフィールドと同様に、各データサーバー上のファイルのデータがどのようにパックされるか、クライアントがCOMMIT操作をメタデータサーバーまたはデータサーバーに送信する必要があるかどうか、およびストライプユニットサイズのコンパクトな表現。サーバーが2つ以上の重複するレイアウトを返す場合、各重複するレイアウトの各ストライプユニットサイズは同じである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. nfl_first_stripe_index: The index into the first element of the nflda_stripe_indices array to use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. nfl_first_stripe_index：使用するnflda_stripe_indices配列の最初の要素へのインデックス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. nfl_pattern_offset: This field is the logical offset into the file where the striping pattern starts. It is required for converting the client&#39;s logical I/O offset (e.g., the current offset in a POSIX file descriptor before the read() or write() system call is sent) into the stripe unit number (see Section 13.4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. nfl_pattern_offset：このフィールドは、ストライプパターンが開始するファイルへの論理オフセットです。これは、クライアントの論理I / Oオフセット（たとえば、read()またはwrite()システムコールが送信される前のPOSIXファイル記述子の現在のオフセット）をストライプユニット番号に変換するために必要です（セクション13.4.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
If dense packing is used, then nfl_pattern_offset is also needed to convert the client&#39;s logical I/O offset to an offset on the file on the data server corresponding to the stripe unit number (see Section 13.4.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
密なパッキングが使用されている場合、クライアントの論理I / Oオフセットをストライプユニット番号に対応するデータサーバー上のファイルのオフセットに変換するためにnfl_pattern_offsetも必要です（セクション13.4.4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Note that nfl_pattern_offset is not always the same as lo_offset. For example, via the LAYOUTGET operation, a client might request a layout starting at offset 1000 of a file that has its striping pattern start at offset zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
nfl_pattern_offsetは常にlo_offsetと同じではないことに注意してください。たとえば、LAYOUTGET操作を介して、クライアントはオフセット0から始まるストライプパターンを持つファイルのオフセット1000から始まるレイアウトを要求する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. nfl_fh_list: An array of data server filehandles for each list of data servers in each element of the nflda_multipath_ds_list array. The number of elements in nfl_fh_list depends on whether sparse or dense packing is being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. nfl_fh_list：nflda_multipath_ds_list配列の各要素にあるデータサーバーの各リストのデータサーバーファイルハンドルの配列。 nfl_fh_listの要素の数は、スパースパッキングとデンスパッキングのどちらが使用されているかによって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* If sparse packing is being used, the number of elements in nfl_fh_list MUST be one of three values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* スパースパッキングが使用されている場合、nfl_fh_listの要素数は次の3つの値のいずれかである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ Zero. This means that filehandles used for each data server are the same as the filehandle returned by the OPEN operation from the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ ゼロ。つまり、各データサーバーで使用されるファイルハンドルは、メタデータサーバーからOPEN操作によって返されるファイルハンドルと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ One. This means that every data server uses the same filehandle: what is specified in nfl_fh_list[0].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ 1。これは、すべてのデータサーバーが同じファイルハンドルを使用することを意味します：nfl_fh_list [0]で指定されているもの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ The same number of elements in nflda_multipath_ds_list. Thus, in this case, when sending an I/O operation to any data server in nflda_multipath_ds_list[X], the filehandle in nfl_fh_list[X] MUST be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ nflda_multipath_ds_list内の同じ要素数。したがって、この場合、nflda_multipath_ds_list [X]のデータサーバーにI / O操作を送信するときは、nfl_fh_list [X]のファイルハンドルを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
See the discussion on sparse packing in Section 13.4.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
セクション13.4.4のスパースパッキングに関する説明を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* If dense packing is being used, the number of elements in nfl_fh_list MUST be the same as the number of elements in nflda_stripe_indices. Thus, when sending an I/O operation to any data server in nflda_multipath_ds_list[nflda_stripe_indices[Y]], the filehandle in nfl_fh_list[Y] MUST be used. In addition, any time there exists i and j, (i != j), such that the intersection of nflda_multipath_ds_list[nflda_stripe_indices[i]] and nflda_multipath_ds_list[nflda_stripe_indices[j]] is not empty, then nfl_fh_list[i] MUST NOT equal nfl_fh_list[j]. In other words, when dense packing is being used, if a data server appears in two or more units of a striping pattern, each reference to the data server MUST use a different filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* 密なパッキングが使用されている場合、nfl_fh_listの要素の数は、nflda_stripe_indicesの要素の数と同じでなければなりません。したがって、nflda_multipath_ds_list [nflda_stripe_indices [Y]]内の任意のデータサーバーにI / O操作を送信する場合は、nfl_fh_list [Y]内のファイルハンドルを使用する必要があります。さらに、iとjが存在する場合は常に（i！= j）、nflda_multipath_ds_list [nflda_stripe_indices [i]]とnflda_multipath_ds_list [nflda_stripe_indices [j]]の交差は空ではなく、nfl_fh_list [i]は等しくないnfl_fh_list [j]。言い換えると、密なパッキングが使用されている場合、データサーバーがストライピングパターンの2つ以上のユニットに表示される場合、データサーバーへの各参照は異なるファイルハンドルを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Indeed, if there are multiple striping patterns, as indicated by the presence of multiple objects of data type layout4 (either returned in one or multiple LAYOUTGET operations), and a data server is the target of a unit of one pattern and another unit of another pattern, then each reference to each data server MUST use a different filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
実際、データタイプlayout4の複数のオブジェクト（1つまたは複数のLAYOUTGET操作で返される）の存在によって示されるように、複数のストライピングパターンがあり、データサーバーが1つのパターンのユニットと別のユニットの別のユニットのターゲットである場合パターンでは、各データサーバーへの各参照は異なるファイルハンドルを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
See the discussion on dense packing in Section 13.4.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
13.4.4項の密なパッキングに関する説明を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The details on the interpretation of the layout are in Section 13.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトの解釈の詳細はセクション13.4にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-4--Interpreting-the-File-Layout">
13.4. Interpreting the File Layout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4. ファイルレイアウトの解釈
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-4-1--Determining-the-Stripe-Unit-Number">
13.4.1. Determining the Stripe Unit Number
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4.1. ストライプユニット番号の決定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To find the stripe unit number that corresponds to the client&#39;s logical file offset, the pattern offset will also be used. The i&#39;th stripe unit (SUi) is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの論理ファイルオフセットに対応するストライプユニット番号を見つけるために、パターンオフセットも使用されます。 i番目のストライプユニット（SUi）は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       relative_offset = file_offset - nfl_pattern_offset;
       SUi = floor(relative_offset / stripe_unit_size);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-4-2--Interpreting-the-File-Layout-Using-Sparse-Packing">
13.4.2. Interpreting the File Layout Using Sparse Packing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4.2. スパースパッキングを使用したファイルレイアウトの解釈
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When sparse packing is used, the algorithm for determining the filehandle and set of data-server network addresses to write stripe unit i (SUi) to is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スパースパッキングを使用する場合、ストライプユニットi（SUi）を書き込むファイルハンドルとデータサーバーネットワークアドレスのセットを決定するアルゴリズムは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
stripe_count = number of elements in nflda_stripe_indices;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
stripe_count = nflda_stripe_indicesの要素数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      j = (SUi + nfl_first_stripe_index) % stripe_count;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
idx = nflda_stripe_indices[j];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
idx = nflda_stripe_indices [j];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      fh_count = number of elements in nfl_fh_list;
      ds_count = number of elements in nflda_multipath_ds_list;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      switch (fh_count) {
        case ds_count:
          fh = nfl_fh_list[idx];
          break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        case 1:
          fh = nfl_fh_list[0];
          break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        case 0:
          fh = filehandle returned by OPEN;
          break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        default:
          throw a fatal exception;
          break;
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
address_list = nflda_multipath_ds_list[idx];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
address_list = nflda_multipath_ds_list [idx];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client would then select a data server from address_list, and send a READ or WRITE operation using the filehandle specified in fh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次にクライアントは、address_listからデータサーバーを選択し、fhで指定されたファイルハンドルを使用してREADまたはWRITE操作を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider the following example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例について考えてみます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suppose we have a device address consisting of seven data servers, arranged in three equivalence (Section 13.5) classes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3つの同等（クラス13.5）クラスに配置された7つのデータサーバーで構成されるデバイスアドレスがあるとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      { A, B, C, D }, { E }, { F, G }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where A through G are network addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、AからGはネットワークアドレスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その後
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nflda_multipath_ds_list&lt;&gt; = { A, B, C, D }, { E }, { F, G }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
i.e.,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
い。え。、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nflda_multipath_ds_list[0] = { A, B, C, D }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nflda_multipath_ds_list[1] = { E }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nflda_multipath_ds_list[2] = { F, G }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suppose the striping index array is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストライピングインデックス配列が次のようであるとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nflda_stripe_indices&lt;&gt; = { 2, 0, 1, 0 }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now suppose the client gets a layout that has a device ID that maps to the above device address. The initial index contains
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、クライアントが、上記のデバイスアドレスにマップするデバイスIDを持つレイアウトを取得するとします。初期インデックスには
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
nfl_first_stripe_index = 2,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
nfl_first_stripe_index = 2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and the filehandle list is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そしてファイルハンドルリストは
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nfl_fh_list = { 0x36, 0x87, 0x67 }.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client wants to write to SU0, the set of valid { network address, filehandle } combinations for SUi are determined by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがSU0への書き込みを希望する場合、SUiの有効な{ネットワークアドレス、ファイルハンドル}の組み合わせのセットは、次のように決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nfl_first_stripe_index = 2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
祖
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      idx = nflda_stripe_indices[(0 + 2) % 4]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
= nflda_stripe_indices[2]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
= nflda_stripe_indices [2]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
= 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
＝ １
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
祖
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nflda_multipath_ds_list[1] = { E }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nfl_fh_list[1] = { 0x87 }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client can thus write SU0 to { 0x87, { E } }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、クライアントはSU0を{0x87、{E}}に書き込むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The destinations of the first 13 storage units are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の13のストレージユニットの宛先は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                    +-----+------------+--------------+
                    | SUi | filehandle | data servers |
                    +-----+------------+--------------+
                    | 0   | 87         | E            |
                    | 1   | 36         | A,B,C,D      |
                    | 2   | 67         | F,G          |
                    | 3   | 36         | A,B,C,D      |
                    | 4   | 87         | E            |
                    | 5   | 36         | A,B,C,D      |
                    | 6   | 67         | F,G          |
                    | 7   | 36         | A,B,C,D      |
                    | 8   | 87         | E            |
                    | 9   | 36         | A,B,C,D      |
                    | 10  | 67         | F,G          |
                    | 11  | 36         | A,B,C,D      |
                    | 12  | 87         | E            |
                    +-----+------------+--------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-4-3--Interpreting-the-File-Layout-Using-Dense-Packing">
13.4.3. Interpreting the File Layout Using Dense Packing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4.3. 密なパッキングを使用したファイルレイアウトの解釈
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When dense packing is used, the algorithm for determining the filehandle and set of data server network addresses to write stripe unit i (SUi) to is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密なパッキングを使用する場合、ストライプユニットi（SUi）を書き込むファイルハンドルとデータサーバーネットワークアドレスのセットを決定するアルゴリズムは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
stripe_count = number of elements in nflda_stripe_indices;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
stripe_count = nflda_stripe_indicesの要素数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      j = (SUi + nfl_first_stripe_index) % stripe_count;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
idx = nflda_stripe_indices[j];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
idx = nflda_stripe_indices [j];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      fh_count = number of elements in nfl_fh_list;
      ds_count = number of elements in nflda_multipath_ds_list;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      switch (fh_count) {
        case stripe_count:
          fh = nfl_fh_list[j];
          break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        default:
          throw a fatal exception;
          break;
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
address_list = nflda_multipath_ds_list[idx];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
address_list = nflda_multipath_ds_list [idx];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client would then select a data server from address_list, and send a READ or WRITE operation using the filehandle specified in fh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次にクライアントは、address_listからデータサーバーを選択し、fhで指定されたファイルハンドルを使用してREADまたはWRITE操作を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider the following example (which is the same as the sparse packing example, except for the filehandle list):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例を考えてみます（これは、ファイルハンドルリストを除いて、スパースパッキングの例と同じです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suppose we have a device address consisting of seven data servers, arranged in three equivalence (Section 13.5) classes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3つの同等（クラス13.5）クラスに配置された7つのデータサーバーで構成されるデバイスアドレスがあるとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      { A, B, C, D }, { E }, { F, G }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where A through G are network addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、AからGはネットワークアドレスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その後
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nflda_multipath_ds_list&lt;&gt; = { A, B, C, D }, { E }, { F, G }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
i.e.,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
い。え。、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nflda_multipath_ds_list[0] = { A, B, C, D }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nflda_multipath_ds_list[1] = { E }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nflda_multipath_ds_list[2] = { F, G }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suppose the striping index array is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストライピングインデックス配列が次のようであるとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nflda_stripe_indices&lt;&gt; = { 2, 0, 1, 0 }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now suppose the client gets a layout that has a device ID that maps to the above device address. The initial index contains
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、クライアントが、上記のデバイスアドレスにマップするデバイスIDを持つレイアウトを取得するとします。初期インデックスには
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
nfl_first_stripe_index = 2,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
nfl_first_stripe_index = 2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nfl_fh_list = { 0x67, 0x37, 0x87, 0x36 }.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The interesting examples for dense packing are SU1 and SU3 because each stripe unit refers to the same data server list, yet each stripe unit MUST use a different filehandle. If the client wants to write to SU1, the set of valid { network address, filehandle } combinations for SUi are determined by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密なパッキングの興味深い例は、各ストライプユニットが同じデータサーバーリストを参照するため、SU1とSU3ですが、各ストライプユニットは異なるファイルハンドルを使用する必要があります。クライアントがSU1に書き込みたい場合、SUiの有効な{ネットワークアドレス、ファイルハンドル}の組み合わせのセットは次のように決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nfl_first_stripe_index = 2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
祖
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      j = (1 + 2) % 4 = 3
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
idx = nflda_stripe_indices[j]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
idx = nflda_stripe_indices [j]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
= nflda_stripe_indices[3]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
= nflda_stripe_indices [3]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
= 0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
＝ ０
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
祖
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nflda_multipath_ds_list[0] = { A, B, C, D }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      nfl_fh_list[3] = { 0x36 }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client can thus write SU1 to { 0x36, { A, B, C, D } }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、クライアントはSU1を{0x36、{A、B、C、D}}に書き込むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   For SU3, j = (3 + 2) % 4 = 1, and nflda_stripe_indices[1] = 0.  Then
   nflda_multipath_ds_list[0] = { A, B, C, D }, and nfl_fh_list[1] =
   0x37.  The client can thus write SU3 to { 0x37, { A, B, C, D } }.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The destinations of the first 13 storage units are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の13のストレージユニットの宛先は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                    +-----+------------+--------------+
                    | SUi | filehandle | data servers |
                    +-----+------------+--------------+
                    | 0   | 87         | E            |
                    | 1   | 36         | A,B,C,D      |
                    | 2   | 67         | F,G          |
                    | 3   | 37         | A,B,C,D      |
                    | 4   | 87         | E            |
                    | 5   | 36         | A,B,C,D      |
                    | 6   | 67         | F,G          |
                    | 7   | 37         | A,B,C,D      |
                    | 8   | 87         | E            |
                    | 9   | 36         | A,B,C,D      |
                    | 10  | 67         | F,G          |
                    | 11  | 37         | A,B,C,D      |
                    | 12  | 87         | E            |
                    +-----+------------+--------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-4-4--Sparse-and-Dense-Stripe-Unit-Packing">
13.4.4. Sparse and Dense Stripe Unit Packing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4.4. 疎密のストライプユニットパッキング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flag NFL4_UFLG_DENSE of the nfl_util4 data type (field nflh_util of the data type nfsv4_1_file_layouthint4 and field nfl_util of data type nfsv4_1_file_layout_ds_addr4) specifies how the data is packed within the data file on a data server. It allows for two different data packings: sparse and dense. The packing type determines the calculation that will be made to map the client-visible file offset to the offset within the data file located on the data server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfl_util4データ型のフラグNFL4_UFLG_DENSE（データ型nfsv4_1_file_layouthint4のフィールドnflh_utilおよびデータ型nfsv4_1_file_layout_ds_addr4のフィールドnfl_util）は、データサーバー上のデータファイル内でのデータのパック方法を指定します。 2つの異なるデータパッキングが可能です：疎と密。パッキングタイプは、クライアントから見えるファイルオフセットをデータサーバーにあるデータファイル内のオフセットにマップするために行われる計算を決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If nfl_util &amp; NFL4_UFLG_DENSE is zero, this means that sparse packing is being used. Hence, the logical offsets of the file as viewed by a client sending READs and WRITEs directly to the metadata server are the same offsets each data server uses when storing a stripe unit. The effect then, for striping patterns consisting of at least two stripe units, is for each data server file to be sparse or &#34;holey&#34;. So for example, suppose there is a pattern with three stripe units, the stripe unit size is 4096 bytes, and there are three data servers in the pattern. Then, the file in data server 1 will have stripe units 0, 3, 6, 9, ... filled; data server 2&#39;s file will have stripe units 1, 4, 7, 10, ... filled; and data server 3&#39;s file will have stripe units 2, 5, 8, 11, ... filled. The unfilled stripe units of each file will be holes; hence, the files in each data server are sparse.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfl_util＆NFL4_UFLG_DENSEがゼロの場合、これはスパースパッキングが使用されていることを意味します。したがって、READおよびWRITEをメタデータサーバーに直接送信するクライアントから見たファイルの論理オフセットは、各データサーバーがストライプユニットを格納するときに使用するオフセットと同じです。その場合、少なくとも2つのストライプユニットで構成されるストライピングパターンの影響は、各データサーバーファイルがスパースまたは「ホーリー」になることです。たとえば、ストライプユニットが3つあるパターンがあり、ストライプユニットのサイズが4096バイトで、パターン内に3つのデータサーバーがあるとします。次に、データサーバー1のファイルには、ストライプユニット0、3、6、9、...が入ります。データサーバー2のファイルには、ストライプユニット1、4、7、10、...が入ります。データサーバー3のファイルには、ストライプユニット2、5、8、11、...が入ります。各ファイルの埋められていないストライプ単位は穴になります。したがって、各データサーバーのファイルはまばらです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If sparse packing is being used and a client attempts I/O to one of the holes, then an error MUST be returned by the data server. Using the above example, if data server 3 received a READ or WRITE operation for block 4, the data server would return NFS4ERR_PNFS_IO_HOLE. Thus, data servers need to understand the striping pattern in order to support sparse packing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
スパースパッキングが使用されており、クライアントがいずれかのホールへのI / Oを試行する場合、データサーバーからエラーを返す必要があります。上記の例を使用すると、データサーバー3がブロック4のREADまたはWRITE操作を受け取った場合、データサーバーはNFS4ERR_PNFS_IO_HOLEを返します。したがって、スパースパッキングをサポートするために、データサーバーはストライピングパターンを理解する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If nfl_util &amp; NFL4_UFLG_DENSE is one, this means that dense packing is being used, and the data server files have no holes. Dense packing might be selected because the data server does not (efficiently) support holey files or because the data server cannot recognize read-ahead unless there are no holes. If dense packing is indicated in the layout, the data files will be packed. Using the same striping pattern and stripe unit size that were used for the sparse packing example, the corresponding dense packing example would have all stripe units of all data files filled as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfl_util＆NFL4_UFLG_DENSEが1の場合、これは密なパッキングが使用されており、データサーバーファイルに穴がないことを意味します。データサーバーが穴あきファイルを（効率的に）サポートしていないか、データサーバーが穴がないと先読みを認識できないため、密なパッキングが選択されている可能性があります。レイアウトで密なパッキングが指定されている場合、データファイルはパッキングされます。スパースパッキングの例で使用されたものと同じストライプパターンとストライプユニットサイズを使用すると、対応するデンスパッキングの例では、すべてのデータファイルのすべてのストライプユニットが次のように入力されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Logical stripe units 0, 3, 6, ... of the file would live on stripe units 0, 1, 2, ... of the file of data server 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルの論理ストライプユニット0、3、6、...は、データサーバー1のファイルのストライプユニット0、1、2、...に存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Logical stripe units 1, 4, 7, ... of the file would live on stripe units 0, 1, 2, ... of the file of data server 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルの論理ストライプユニット1、4、7、...は、データサーバー2のファイルのストライプユニット0、1、2、...にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Logical stripe units 2, 5, 8, ... of the file would live on stripe units 0, 1, 2, ... of the file of data server 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルの論理ストライプユニット2、5、8、...は、データサーバー3のファイルのストライプユニット0、1、2、...にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because dense packing does not leave holes on the data servers, the pNFS client is allowed to write to any offset of any data file of any data server in the stripe. Thus, the data servers need not know the file&#39;s striping pattern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密なパッキングはデータサーバーに穴を残さないため、pNFSクライアントは、ストライプ内の任意のデータサーバーの任意のデータファイルの任意のオフセットに書き込むことができます。したがって、データサーバーはファイルのストライピングパターンを知る必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The calculation to determine the byte offset within the data file for dense data server layouts is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高密度データサーバーレイアウトのデータファイル内のバイトオフセットを決定する計算は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
stripe_width = stripe_unit_size * N; where N = number of elements in nflda_stripe_indices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
stripe_width = stripe_unit_size * N;ここで、N = nflda_stripe_indicesの要素の数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      relative_offset = file_offset - nfl_pattern_offset;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      data_file_offset = floor(relative_offset / stripe_width)
         * stripe_unit_size
         + relative_offset % stripe_unit_size
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If dense packing is being used, and a data server appears more than once in a striping pattern, then to distinguish one stripe unit from another, the data server MUST use a different filehandle. Let&#39;s suppose there are two data servers. Logical stripe units 0, 3, 6 are served by data server 1; logical stripe units 1, 4, 7 are served by data server 2; and logical stripe units 2, 5, 8 are also served by data server 2. Unless data server 2 has two filehandles (each referring to a different data file), then, for example, a write to logical stripe unit 1 overwrites the write to logical stripe unit 2 because both logical stripe units are located in the same stripe unit (0) of data server 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
密なパッキングが使用されており、データサーバーがストライピングパターンで複数回出現する場合、1つのストライプユニットを別のストライプユニットと区別するには、データサーバーは別のファイルハンドルを使用する必要があります。 2つのデータサーバーがあるとします。論理ストライプユニット0、3、6はデータサーバー1によって処理されます。論理ストライプユニット1、4、7はデータサーバー2によって処理されます。また、論理ストライプユニット2、5、8もデータサーバー2によって処理されます。たとえば、データサーバー2に2つのファイルハンドル（それぞれが異なるデータファイルを参照）がない場合、論理ストライプユニット1への書き込みは、両方の論理ストライプユニットがデータサーバー2の同じストライプユニット（0）に配置されているため、論理ストライプユニット2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-5--Data-Server-Multipathing">
13.5. Data Server Multipathing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5. データサーバーのマルチパス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 file layout supports multipathing to multiple data server addresses. Data-server-level multipathing is used for bandwidth scaling via trunking (Section 2.10.5) and for higher availability of use in the case of a data-server failure. Multipathing allows the client to switch to another data server address which may be that of another data server that is exporting the same data stripe unit, without having to contact the metadata server for a new layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1ファイルレイアウトは、複数のデータサーバーアドレスへのマルチパスをサポートしています。データサーバーレベルのマルチパスは、トランキングによる帯域幅のスケーリング（2.10.5節）と、データサーバーに障害が発生した場合の使用の可用性を高めるために使用されます。マルチパスにより、クライアントは、新しいレイアウトのためにメタデータサーバーにアクセスする必要なく、同じデータストライプユニットをエクスポートしている別のデータサーバーのアドレスである可能性がある別のデータサーバーアドレスに切り替えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To support data server multipathing, each element of the nflda_multipath_ds_list contains an array of one more data server network addresses. This array (data type multipath_list4) represents a list of data servers (each identified by a network address), with the possibility that some data servers will appear in the list multiple times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データサーバーのマルチパスをサポートするために、nflda_multipath_ds_listの各要素には、1つ以上のデータサーバーネットワークアドレスの配列が含まれています。この配列（データ型multipath_list4）は、データサーバー（それぞれがネットワークアドレスで識別される）のリストを表し、一部のデータサーバーがリストに複数回表示される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client is free to use any of the network addresses as a destination to send data server requests. If some network addresses are less optimal paths to the data than others, then the MDS SHOULD NOT include those network addresses in an element of nflda_multipath_ds_list. If less optimal network addresses exist to provide failover, the RECOMMENDED method to offer the addresses is to provide them in a replacement device-ID-to-device-address mapping, or a replacement device ID. When a client finds that no data server in an element of nflda_multipath_ds_list responds, it SHOULD send a GETDEVICEINFO to attempt to replace the existing device-ID-to-device-address mappings. If the MDS detects that all data servers represented by an element of nflda_multipath_ds_list are unavailable, the MDS SHOULD send a CB_NOTIFY_DEVICEID (if the client has indicated it wants device ID notifications for changed device IDs) to change the device-ID-to-device-address mappings to the available data servers. If the device ID itself will be replaced, the MDS SHOULD recall all layouts with the device ID, and thus force the client to get new layouts and device ID mappings via LAYOUTGET and GETDEVICEINFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、データサーバー要求を送信する宛先として、任意のネットワークアドレスを自由に使用できます。一部のネットワークアドレスが他よりもデータへの最適パスではない場合、MDSはそれらのネットワークアドレスをnflda_multipath_ds_listの要素に含めないでください。フェイルオーバーを提供するのに最適ではないネットワークアドレスが存在する場合、アドレスを提供するための推奨される方法は、代替のデバイスIDからデバイスアドレスへのマッピング、または代替のデバイスIDでアドレスを提供することです。クライアントがnflda_multipath_ds_listの要素内のデータサーバーが応答しないことを検出した場合、既存のデバイスIDからデバイスアドレスへのマッピングを置き換えるためにGETDEVICEINFOを送信する必要があります（SHOULD）。 nflda_multipath_ds_listの要素によって表されるすべてのデータサーバーが利用できないことをMDSが検出した場合、MDSはCB_NOTIFY_DEVICEIDを送信して（変更されたデバイスIDのデバイスID通知が必要であるとクライアントが示している場合）、デバイスIDからデバイスへ利用可能なデータサーバーへのアドレスマッピング。デバイスID自体が置き換えられる場合、MDSはすべてのレイアウトをデバイスIDで再呼び出しする必要があるため、クライアントにLAYOUTGETおよびGETDEVICEINFOを介して新しいレイアウトとデバイスIDマッピングを強制的に取得させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Generally, if two network addresses appear in an element of nflda_multipath_ds_list, they will designate the same data server, and the two data server addresses will support the implementation of client ID or session trunking (the latter is RECOMMENDED) as defined in Section 2.10.5. The two data server addresses will share the same server owner or major ID of the server owner. It is not always necessary for the two data server addresses to designate the same server with trunking being used. For example, the data could be read-only, and the data consist of exact replicas.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
一般に、2つのネットワークアドレスがnflda_multipath_ds_listの要素に表示される場合、それらは同じデータサーバーを指定し、2つのデータサーバーアドレスは、セクション2.10.5で定義されているように、クライアントIDまたはセッショントランキングの実装をサポートします（後者は推奨）。 。 2つのデータサーバーアドレスは、同じサーバー所有者またはサーバー所有者のメジャーIDを共有します。 2つのデータサーバーアドレスが、トランキングが使用されている同じサーバーを指定する必要は必ずしもありません。たとえば、データは読み取り専用で、データは正確なレプリカで構成されている場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-6--Operations-Sent-to-NFSv4-1-Data-Servers">
13.6. Operations Sent to NFSv4.1 Data Servers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6. NFSv4.1データサーバーに送信される操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients accessing data on an NFSv4.1 data server MUST send only the NULL procedure and COMPOUND procedures whose operations are taken only from two restricted subsets of the operations defined as valid NFSv4.1 operations. Clients MUST use the filehandle specified by the layout when accessing data on NFSv4.1 data servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1データサーバー上のデータにアクセスするクライアントは、有効なNFSv4.1操作として定義された操作の2つの制限されたサブセットからのみ操作が取得されるNULLプロシージャとCOMPOUNDプロシージャのみを送信する必要があります。クライアントは、NFSv4.1データサーバー上のデータにアクセスするときに、レイアウトで指定されたファイルハンドルを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first of these operation subsets consists of management operations. This subset consists of the BACKCHANNEL_CTL, BIND_CONN_TO_SESSION, CREATE_SESSION, DESTROY_CLIENTID, DESTROY_SESSION, EXCHANGE_ID, SECINFO_NO_NAME, SET_SSV, and SEQUENCE operations. The client may use these operations in order to set up and maintain the appropriate client IDs, sessions, and security contexts involved in communication with the data server. Henceforth, these will be referred to as data-server housekeeping operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの操作サブセットの最初の部分は、管理操作で構成されています。このサブセットは、BACKCHANNEL_CTL、BIND_CONN_TO_SESSION、CREATE_SESSION、DESTROY_CLIENTID、DESTROY_SESSION、EXCHANGE_ID、SECINFO_NO_NAME、SET_SSV、およびSEQUENCE操作で構成されています。クライアントは、データサーバーとの通信に関連する適切なクライアントID、セッション、およびセキュリティコンテキストを設定および維持するために、これらの操作を使用できます。以降、これらはデータサーバーのハウスキーピング操作と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second subset consists of COMMIT, READ, WRITE, and PUTFH. These operations MUST be used with a current filehandle specified by the layout. In the case of PUTFH, the new current filehandle MUST be one taken from the layout. Henceforth, these will be referred to as data-server I/O operations. As described in Section 12.5.1, a client MUST NOT send an I/O to a data server for which it does not hold a valid layout; the data server MUST reject such an I/O.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目のサブセットは、COMMIT、READ、WRITE、およびPUTFHで構成されています。これらの操作は、レイアウトで指定された現在のファイルハンドルで使用する必要があります。 PUTFHの場合、新しい現在のファイルハンドルはレイアウトから取得したものでなければなりません。以降、これらはデータサーバーのI / O操作と呼ばれます。 12.5.1項で説明したように、クライアントは、有効なレイアウトを保持していないデータサーバーにI / Oを送信してはなりません（MUST NOT）。データサーバーは、そのようなI / Oを拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless the server has a concurrent non-data-server personality -- i.e., EXCHANGE_ID results returned (EXCHGID4_FLAG_USE_PNFS_DS | EXCHGID4_FLAG_USE_PNFS_MDS) or (EXCHGID4_FLAG_USE_PNFS_DS | EXCHGID4_FLAG_USE_NON_PNFS) see Section 13.1 -- any attempted use of operations against a data server other than those specified in the two subsets above MUST return NFS4ERR_NOTSUPP to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーに同時の非データサーバーパーソナリティがない場合、つまり、EXCHANGE_IDの結果が返された場合（EXCHGID4_FLAG_USE_PNFS_DS | EXCHGID4_FLAG_USE_PNFS_MDS）または（EXCHGID4_FLAG_USE_PNFS_DS | EXCHGID4_FLAG_USE_NON_PNFSに対して指定されたデータ操作に対しては、セクション13で指定されたデータ以外の操作を参照してください。上記の2つのサブセットは、クライアントにNFS4ERR_NOTSUPPを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server has concurrent data-server and non-data-server personalities, each COMPOUND sent by the client MUST be constructed so that it is appropriate to one of the two personalities, and it MUST NOT contain operations directed to a mix of those personalities. The server MUST enforce this. To understand the constraints, operations within a COMPOUND are divided into the following three classes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーにデータサーバーと非データサーバーのパーソナリティが同時に存在する場合、クライアントから送信される各COMPOUNDは、2つのパーソナリティのいずれかに適切であるように構築する必要があり、これらのパーソナリティの混合に向けられた操作を含めることはできません。サーバーはこれを強制する必要があります。制約を理解するために、COMPOUND内の操作は次の3つのクラスに分類されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 1. An operation that is ambiguous regarding its personality assignment. This includes all of the data-server housekeeping operations. Additionally, if the server has assigned filehandles so that the ones defined by the layout are the same as those used by the metadata server, all operations using such filehandles are within this class, with the following exception. The exception is that if the operation uses a stateid that is incompatible with a data-server personality (e.g., a special stateid or the stateid has a non-zero &#34;seqid&#34; field, see Section 13.9.1), the operation is in class 3, as described below. A COMPOUND containing multiple class 1 operations (and operations of no other class) MAY be sent to a server with multiple concurrent data server and non-data-server personalities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
1.性格の割り当てに関してあいまいな操作。これには、すべてのデータサーバーハウスキーピング操作が含まれます。さらに、レイアウトで定義されたファイルハンドルがメタデータサーバーで使用されるファイルハンドルと同じになるようにサーバーがファイルハンドルを割り当てた場合、そのようなファイルハンドルを使用するすべての操作はこのクラス内にありますが、次の例外があります。例外は、操作がデータサーバーのパーソナリティと互換性のない状態IDを使用する場合です（たとえば、特別な状態IDまたは状態IDにゼロ以外の「seqid」フィールドがあります。セクション13.9.1を参照）、操作はクラス内にあります。図3複数のクラス1操作（および他のクラスのない操作）を含むCOMPOUNDは、複数の同時データサーバーと非データサーバーパーソナリティを持つサーバーに送信できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. An operation that is unambiguously referable to the data-server personality. This includes data-server I/O operations where the filehandle is one that can only be validly directed to the data-server personality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. データサーバーのパーソナリティを明確に参照できる操作。これには、ファイルハンドルがデータサーバーパーソナリティにのみ有効に送信できるデータサーバーI / O操作が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. An operation that is unambiguously referable to the non-data-server personality. This includes all COMPOUND operations that are neither data-server housekeeping nor data-server I/O operations, plus data-server I/O operations where the current fh (or the one to be made the current fh in the case of PUTFH) is only valid on the metadata server or where a stateid is used that is incompatible with the data server, i.e., is a special stateid or has a non-zero seqid value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 非データサーバーのパーソナリティに明確に参照できる操作。これには、データサーバーのハウスキーピングでもデータサーバーのI / O操作でもないすべてのCOMPOUND操作と、現在のfh（またはPUTFHの場合は現在のfhになる操作）が実行されるデータサーバーのI / O操作が含まれます。メタデータサーバーでのみ、またはデータサーバーと互換性のないstateidが使用されている場合にのみ有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a COMPOUND first executes an operation from class 3 above, it acts as a normal COMPOUND on any other server, and the data-server personality ceases to be relevant. There are no special restrictions on the operations in the COMPOUND to limit them to those for a data server. When a PUTFH is done, filehandles derived from the layout are not valid. If their format is not normally acceptable, then NFS4ERR_BADHANDLE MUST result. Similarly, current filehandles for other operations do not accept filehandles derived from layouts and are not normally usable on the metadata server. Using these will result in NFS4ERR_STALE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDが最初に上記のクラス3の操作を実行すると、他のサーバーでは通常のCOMPOUNDとして機能し、データサーバーのパーソナリティは関連しなくなります。 COMPOUNDの操作には、データサーバーの操作に限定する特別な制限はありません。 PUTFHが実行されると、レイアウトから派生したファイルハンドルは無効になります。それらの形式が通常受け入れられない場合は、NFS4ERR_BADHANDLEが発生する必要があります。同様に、他の操作の現在のファイルハンドルは、レイアウトから派生したファイルハンドルを受け入れず、通常、メタデータサーバーで使用できません。これらを使用すると、NFS4ERR_STALEになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a COMPOUND first executes an operation from class 2, which would be PUTFH where the filehandle is one from a layout, the COMPOUND henceforth is interpreted with respect to the data-server personality. Operations outside the two classes discussed above MUST result in NFS4ERR_NOTSUPP. Filehandles are validated using the rules of the data server, resulting in NFS4ERR_BADHANDLE and/or NFS4ERR_STALE even when they would not normally do so when addressed to the non-data-server personality. Stateids must obey the rules of the data server in that any use of special stateids or stateids with non-zero seqid values must result in NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDが最初にクラス2から操作を実行すると、ファイルハンドルがレイアウトの1つであるPUTFHになります。これ以降、COMPOUNDはデータサーバーのパーソナリティに関して解釈されます。上記の2つのクラス外の操作では、NFS4ERR_NOTSUPPが発生する必要があります。ファイルハンドルはデータサーバーのルールを使用して検証されるため、データサーバー以外のパーソナリティに宛てられたときに通常そうしない場合でも、NFS4ERR_BADHANDLEまたはNFS4ERR_STALEが生成されます。ステートIDは、特殊なステートIDまたはゼロ以外のseqid値を持つステートIDを使用すると、NFS4ERR_BAD_STATEIDが発生するため、データサーバーのルールに従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Until the server first executes an operation from class 2 or class 3, the client MUST NOT depend on the operation being executed by either the data-server or the non-data-server personality. The server MUST pick one personality consistently for a given COMPOUND, with the only possible transition being a single one when the first operation from class 2 or class 3 is executed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがクラス2またはクラス3の操作を最初に実行するまで、クライアントは、データサーバーまたは非データサーバーのパーソナリティによって実行される操作に依存してはなりません（MUST NOT）。サーバーは、指定されたCOMPOUNDに対して一貫して1つのパーソナリティを選択する必要があります。クラス2またはクラス3からの最初の操作が実行されたときの唯一の可能な遷移は単一のものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because of the complexity induced by assigning filehandles so they can be used on both a data server and a metadata server, it is RECOMMENDED that where the same server can have both personalities, the server assign separate unique filehandles to both personalities. This makes it unambiguous for which server a given request is intended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データハンドルとメタデータサーバーの両方で使用できるようにファイルハンドルを割り当てることによって生じる複雑さのため、同じサーバーが両方のパーソナリティを持つことができる場合、サーバーは別々の一意のファイルハンドルを両方のパーソナリティに割り当てることが推奨されます。これにより、特定のリクエストがどのサーバーを対象としているかが明確になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETATTR and SETATTR MUST be directed to the metadata server. In the case of a SETATTR of the size attribute, the control protocol is responsible for propagating size updates/truncations to the data servers. In the case of extending WRITEs to the data servers, the new size must be visible on the metadata server once a LAYOUTCOMMIT has completed (see Section 12.5.4.2). Section 13.10 describes the mechanism by which the client is to handle data-server files that do not reflect the metadata server&#39;s size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETATTRおよびSETATTRはメタデータサーバーに送信する必要があります。 size属性のSETATTRの場合、制御プロトコルは、データサーバーへのサイズの更新/切り捨ての伝達を担当します。 WRITEをデータサーバーに拡張する場合、LAYOUTCOMMITが完了すると、新しいサイズがメタデータサーバーに表示される必要があります（セクション12.5.4.2を参照）。セクション13.10では、メタデータサーバーのサイズを反映しないデータサーバーファイルをクライアントが処理するメカニズムについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-7--COMMIT-through-Metadata-Server">
13.7. COMMIT through Metadata Server
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.7. メタデータサーバーによるCOMMIT
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The file layout provides two alternate means of providing for the commit of data written through data servers. The flag NFL4_UFLG_COMMIT_THRU_MDS in the field nfl_util of the file layout (data type nfsv4_1_file_layout4) is an indication from the metadata server to the client of the REQUIRED way of performing COMMIT, either by sending the COMMIT to the data server or the metadata server. These two methods of dealing with the issue correspond to broad styles of implementation for a pNFS server supporting the file layout type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルレイアウトは、データサーバーを介して書き込まれたデータのコミットを提供する2つの代替手段を提供します。ファイルレイアウト（データタイプnfsv4_1_file_layout4）のフィールドnfl_utilのフラグNFL4_UFLG_COMMIT_THRU_MDSは、COMMITをデータサーバーまたはメタデータサーバーに送信することにより、COMMITを実行する必要な方法のメタデータサーバーからクライアントへの指示です。この問題に対処するこれらの2つの方法は、ファイルレイアウトタイプをサポートするpNFSサーバーの幅広い実装スタイルに対応しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the flag is FALSE, COMMIT operations MUST to be sent to the data server to which the corresponding WRITE operations were sent. This approach is sometimes useful when file striping is implemented within the pNFS server (instead of the file system), with the individual data servers each implementing their own file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フラグがFALSEの場合、対応するWRITE操作が送信されたデータサーバーにCOMMIT操作を送信する必要があります。このアプローチは、ファイルストライピングが（ファイルシステムではなく）pNFSサーバー内に実装され、個々のデータサーバーがそれぞれ独自のファイルシステムを実装している場合に役立つことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o When the flag is TRUE, COMMIT operations MUST be sent to the metadata server, rather than to the individual data servers. This approach is sometimes useful when file striping is implemented within the clustered file system that is the backend to the pNFS server. In such an implementation, each COMMIT to each data server might result in repeated writes of metadata blocks to the detriment of write performance. Sending a single COMMIT to the metadata server can be more efficient when there exists a clustered file system capable of implementing such a coordinated COMMIT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
oフラグがTRUEの場合、COMMIT操作は個々のデータサーバーではなくメタデータサーバーに送信する必要があります。この方法は、pNFSサーバーのバックエンドであるクラスター化されたファイルシステム内にファイルストライピングが実装されている場合に役立つことがあります。このような実装では、各データサーバーへの各COMMITにより、メタデータブロックが繰り返し書き込まれ、書き込みパフォーマンスが低下する可能性があります。メタデータサーバーへの単一のCOMMITの送信は、そのような調整されたCOMMITを実装できるクラスター化されたファイルシステムが存在する場合により効率的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If nfl_util &amp; NFL4_UFLG_COMMIT_THRU_MDS is TRUE, then in order to maintain the current NFSv4.1 commit and recovery model, the data servers MUST return a common writeverf verifier in all WRITE responses for a given file layout, and the metadata server&#39;s COMMIT implementation must return the same writeverf. The value of the writeverf verifier MUST be changed at the metadata server or any data server that is referenced in the layout, whenever there is a server event that can possibly lead to loss of uncommitted data. The scope of the verifier can be for a file or for the entire pNFS server. It might be more difficult for the server to maintain the verifier at the file level, but the benefit is that only events that impact a given file will require recovery action.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
nfl_util＆NFL4_UFLG_COMMIT_THRU_MDSがTRUEの場合、現在のNFSv4.1コミットおよびリカバリモデルを維持するために、データサーバーは特定のファイルレイアウトのすべてのWRITE応答で共通のwriteverfベリファイアを返す必要があり、メタデータサーバーのCOMMIT実装は同じwriteverf。コミットされていないデータの損失につながる可能性のあるサーバーイベントがある場合は常に、レイアウトで参照されるメタデータサーバーまたはデータサーバーでwriteverfベリファイアの値を変更する必要があります。ベリファイアのスコープは、ファイルまたはpNFSサーバー全体です。サーバーがベリファイアをファイルレベルで維持することはより難しいかもしれませんが、利点は、特定のファイルに影響を与えるイベントのみがリカバリアクションを必要とすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if the layout specified dense packing, then the offset used to a COMMIT to the MDS may differ than that of an offset used to a COMMIT to the data server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトで密なパッキングが指定されている場合、MDSへのCOMMITに使用されるオフセットは、データサーバーへのCOMMITに使用されるオフセットのオフセットと異なる場合があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The single COMMIT to the metadata server will return a verifier, and the client should compare it to all the verifiers from the WRITEs and fail the COMMIT if there are any mismatched verifiers. If COMMIT to the metadata server fails, the client should re-send WRITEs for all the modified data in the file. The client should treat modified data with a mismatched verifier as a WRITE failure and try to recover by resending the WRITEs to the original data server or using another path to that data if the layout has not been recalled. Alternatively, the client can obtain a new layout or it could rewrite the data directly to the metadata server. If nfl_util &amp; NFL4_UFLG_COMMIT_THRU_MDS is FALSE, sending a COMMIT to the metadata server might have no effect. If nfl_util &amp; NFL4_UFLG_COMMIT_THRU_MDS is FALSE, a COMMIT sent to the metadata server should be used only to commit data that was written to the metadata server. See Section 12.7.6 for recovery options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーへの単一のCOMMITはベリファイアを返し、クライアントはそれをWRITEからのすべてのベリファイアと比較し、一致しないベリファイアがある場合はCOMMITに失敗する必要があります。メタデータサーバーへのCOMMITが失敗した場合、クライアントは、ファイル内の変更されたすべてのデータの書き込みを再送信する必要があります。クライアントは、ベリファイアが一致しない変更されたデータをWRITEエラーとして扱い、元のデータサーバーにWRITEを再送信するか、レイアウトがリコールされていない場合はそのデータへの別のパスを使用して回復を試みます。または、クライアントは新しいレイアウトを取得することも、メタデータサーバーに直接データを書き換えることもできます。 nfl_utilとNFL4_UFLG_COMMIT_THRU_MDSがFALSEの場合、COMMITをメタデータサーバーに送信しても効果がない場合があります。 nfl_util＆NFL4_UFLG_COMMIT_THRU_MDSがFALSEの場合、メタデータサーバーに送信されたCOMMITは、メタデータサーバーに書き込まれたデータをコミットするためにのみ使用する必要があります。回復オプションについては、セクション12.7.6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-8--The-Layout-Iomode">
13.8. The Layout Iomode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.8. レイアウトIomode
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layout iomode need not be used by the metadata server when servicing NFSv4.1 file-based layouts, although in some circumstances it may be useful. For example, if the server implementation supports reading from read-only replicas or mirrors, it would be useful for the server to return a layout enabling the client to do so. As such, the client SHOULD set the iomode based on its intent to read or write the data. The client may default to an iomode of LAYOUTIOMODE4_RW.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1ファイルベースのレイアウトを処理するとき、レイアウトiomodeをメタデータサーバーで使用する必要はありませんが、状況によっては役立つ場合があります。たとえば、サーバーの実装が読み取り専用のレプリカまたはミラーからの読み取りをサポートしている場合、サーバーがクライアントが実行できるようにするレイアウトを返すと便利です。そのため、クライアントはデータの読み取りまたは書き込みの意図に基づいてiomodeを設定する必要があります（SHOULD）。クライアントは、デフォルトでiomodeをLAYOUTIOMODE4_RWにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The iomode need not be checked by the data servers when clients perform I/O. However, the data servers SHOULD still validate that the client holds a valid layout and return an error if the client does not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがI / Oを実行するときに、データサーバーがiomodeをチェックする必要はありません。ただし、データサーバーは、クライアントが有効なレイアウトを保持していることを検証し、クライアントが保持していない場合はエラーを返す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-9--Metadata-and-Data-Server-State-Coordination">
13.9. Metadata and Data Server State Coordination
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.9. メタデータとデータサーバーの状態の調整
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-9-1--Global-Stateid-Requirements">
13.9.1. Global Stateid Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.9.1. グローバルStateid要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client sends I/O to a data server, the stateid used MUST NOT be a layout stateid as returned by LAYOUTGET or sent by CB_LAYOUTRECALL. Permitted stateids are based on one of the following: an OPEN stateid (the stateid field of data type OPEN4resok as returned by OPEN), a delegation stateid (the stateid field of data types open_read_delegation4 and open_write_delegation4 as returned by OPEN or WANT_DELEGATION, or as sent by CB_PUSH_DELEG), or a stateid returned by the LOCK or LOCKU operations. The stateid sent to the data server MUST be sent with the seqid set to zero, indicating the most current version of that stateid, rather than indicating a specific non-zero seqid value. In no case is the use of special stateid values allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがデータサーバーにI / Oを送信する場合、使用される状態IDは、LAYOUTGETによって返された、またはCB_LAYOUTRECALLによって送信されたレイアウト状態IDであってはなりません。許可された状態IDは、OPEN状態ID（OPENによって返されるデータ型OPEN4resokの状態IDフィールド）、委任状態ID（OPENまたはWANT_DELEGATIONによって返される、または送信されるデータ型open_read_delegation4およびopen_write_delegation4の状態IDフィールド）のいずれかに基づいています。 CB_PUSH_DELEG）、またはLOCKまたはLOCKU操作によって返される状態ID。データサーバーに送信されるstateidは、seqidをゼロに設定して送信する必要があります。これは、特定のゼロ以外のseqid値を示すのではなく、そのstateidの最新バージョンを示します。特別なstateid値の使用は許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The stateid used for I/O MUST have the same effect and be subject to the same validation on a data server as it would if the I/O was being performed on the metadata server itself in the absence of pNFS. This has the implication that stateids are globally valid on both the metadata and data servers. This requires the metadata server to propagate changes in LOCK and OPEN state to the data servers, so that the data servers can validate I/O accesses. This is discussed further in Section 13.9.2. Depending on when stateids are propagated, the existence of a valid stateid on the data server may act as proof of a valid layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I / Oに使用される状態IDは、pNFSがない場合にメタデータサーバー自体でI / Oが実行された場合と同じ効果を持ち、データサーバーで同じ検証を受ける必要があります。これは、stateidがメタデータサーバーとデータサーバーの両方でグローバルに有効であることを意味します。これには、データサーバーがI / Oアクセスを検証できるように、メタデータサーバーがLOCKおよびOPEN状態の変更をデータサーバーに伝達する必要があります。これについては、セクション13.9.2で詳しく説明します。状態IDが伝搬されるタイミングによっては、データサーバー上の有効な状態IDの存在が、有効なレイアウトの証拠として機能する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients performing I/O operations need to select an appropriate stateid based on the locks (including opens and delegations) held by the client and the various types of state-owners sending the I/O requests. The rules for doing so when referencing data servers are somewhat different from those discussed in Section 8.2.5, which apply when accessing metadata servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I / O操作を実行するクライアントは、クライアントが保持するロック（オープンと委任を含む）とI / O要求を送信するさまざまなタイプの状態所有者に基づいて、適切な状態IDを選択する必要があります。データサーバーを参照するときにそうするためのルールは、メタデータサーバーにアクセスするときに適用されるセクション8.2.5で説明されているものとは多少異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following rules, applied in order of decreasing priority, govern the selection of the appropriate stateid:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のルールは、優先度の高い順に適用され、適切なステートIDの選択を管理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the client holds a delegation for the file in question, the delegation stateid should be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントが問題のファイルの委任を保持している場合は、委任のstateidを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Otherwise, there must be an OPEN stateid for the current open-owner, and that OPEN stateid for the open file in question is used, unless mandatory locking prevents that. See below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o それ以外の場合は、現在のオープン所有者のOPENステートIDが存在している必要があり、強制ロックがそれを妨げない限り、問題のオープンファイルのOPENステートIDが使用されます。下記参照。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the data server had previously responded with NFS4ERR_LOCKED to use of the OPEN stateid, then the client should use the byte-range lock stateid whenever one exists for that open file with the current lock-owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o データサーバーが以前にNFS4ERR_LOCKEDでOPENステートIDの使用に応答していた場合、クライアントは、現在のロック所有者のオープンファイルに存在する場合は常にバイト範囲ロックステートIDを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Special stateids should never be used. If they are used, the data server MUST reject the I/O with an NFS4ERR_BAD_STATEID error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 特別なステートIDは使用しないでください。それらが使用される場合、データサーバーはNFS4ERR_BAD_STATEIDエラーでI / Oを拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-9-2--Data-Server-State-Propagation">
13.9.2. Data Server State Propagation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.9.2. データサーバーの状態の伝達
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the metadata server, which handles byte-range lock and open-mode state changes as well as ACLs, might not be co-located with the data servers where I/O accesses are validated, the server implementation MUST take care of propagating changes of this state to the data servers. Once the propagation to the data servers is complete, the full effect of those changes MUST be in effect at the data servers. However, some state changes need not be propagated immediately, although all changes SHOULD be propagated promptly. These state propagations have an impact on the design of the control protocol, even though the control protocol is outside of the scope of this specification. Immediate propagation refers to the synchronous propagation of state from the metadata server to the data server(s); the propagation must be complete before returning to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイト範囲のロックとオープンモードの状態変更、およびACLを処理するメタデータサーバーは、I / Oアクセスが検証されるデータサーバーと同じ場所に配置されない場合があるため、サーバーの実装は、変更の伝播に注意する必要があります。この状態をデータサーバーに送信します。データサーバーへの伝達が完了すると、それらの変更の完全な効果がデータサーバーで有効になります。ただし、すべての変更を迅速に伝達する必要がありますが、一部の状態変更をすぐに伝達する必要はありません。これらの状態の伝播は、制御プロトコルがこの仕様の範囲外であっても、制御プロトコルの設計に影響を与えます。即時伝播とは、メタデータサーバーからデータサーバーへの状態の同期伝播を指します。伝播は、クライアントに戻る前に完了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-9-2-1--Lock-State-Propagation">
13.9.2.1. Lock State Propagation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.9.2.1. ロック状態の伝播
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the pNFS server supports mandatory byte-range locking, any mandatory byte-range locks on a file MUST be made effective at the data servers before the request that establishes them returns to the caller. The effect MUST be the same as if the mandatory byte-range lock state were synchronously propagated to the data servers, even though the details of the control protocol may avoid actual transfer of the state under certain circumstances.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSサーバーが必須のバイト範囲ロックをサポートしている場合、ファイルの必須のバイト範囲ロックは、それらを確立する要求が呼び出し元に戻る前に、データサーバーで有効にする必要があります。制御プロトコルの詳細によって特定の状況下での状態の実際の転送が回避される場合でも、効果は、必須のバイト範囲ロック状態が同期的にデータサーバーに伝播された場合と同じでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 On the other hand, since advisory byte-range lock state is not used for checking I/O accesses at the data servers, there is no semantic reason for propagating advisory byte-range lock state to the data servers. Since updates to advisory locks neither confer nor remove privileges, these changes need not be propagated immediately, and may not need to be propagated promptly. The updates to advisory locks need only be propagated when the data server needs to resolve a question about a stateid. In fact, if byte-range locking is not mandatory (i.e., is advisory) the clients are advised to avoid using the byte-range lock-based stateids for I/O. The stateids returned by OPEN are sufficient and eliminate overhead for this kind of state propagation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
一方、データ・サーバーでのI / Oアクセスのチェックには、推奨のバイト範囲ロック状態は使用されないため、データ・サーバーに推奨のバイト範囲ロック状態を伝播する意味上の理由はありません。アドバイザリロックの更新では、特権の付与も削除も行われないため、これらの変更をすぐに反映する必要はなく、すぐに反映する必要がない場合があります。アドバイザリロックの更新は、データサーバーがstateidに関する質問を解決する必要がある場合にのみ伝達する必要があります。実際、バイト範囲ロックが必須ではない（つまり、助言的である）場合、クライアントはI / Oにバイト範囲ロックベースのステートIDを使用しないようにアドバイスされます。 OPENによって返される状態IDで十分であり、この種の状態伝播のオーバーヘッドを排除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client gets back an NFS4ERR_LOCKED error from a data server, this is an indication that mandatory byte-range locking is in force. The client recovers from this by getting a byte-range lock that covers the affected range and re-sends the I/O with the stateid of the byte-range lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがデータ・サーバーからNFS4ERR_LOCKEDエラーを受け取った場合、これは必須のバイト範囲ロックが有効であることを示しています。クライアントは、影響を受ける範囲をカバーするバイト範囲ロックを取得してこれから回復し、バイト範囲ロックの状態IDを使用してI / Oを再送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-9-2-2--Open-and-Deny-Mode-Validation">
13.9.2.2. Open and Deny Mode Validation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.9.2.2. オープンおよび拒否モードの検証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Open and deny mode validation MUST be performed against the open and deny mode(s) held by the data servers. When access is reduced or a deny mode made more restrictive (because of CLOSE or OPEN_DOWNGRADE), the data server MUST prevent any I/Os that would be denied if performed on the metadata server. When access is expanded, the data server MUST make sure that no requests are subsequently rejected because of open or deny issues that no longer apply, given the previous relaxation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープンモードと拒否モードの検証は、データサーバーが保持するオープンモードと拒否モードに対して実行する必要があります。アクセスが削減されるか、拒否モードがより制限的になると（CLOSEまたはOPEN_DOWNGRADEにより）、データサーバーは、メタデータサーバーで実行された場合に拒否されるI / Oを防止する必要があります。アクセスが拡張されると、データサーバーは、以前の緩和を前提として、もはや適用されないオープンまたは拒否の問題が原因で、要求が拒否されないことを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-9-2-3--File-Attributes">
13.9.2.3. File Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.9.2.3. ファイル属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the SETATTR operation has the ability to modify state that is visible on both the metadata and data servers (e.g., the size), care must be taken to ensure that the resultant state across the set of data servers is consistent, especially when truncating or growing the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTR操作には、メタデータサーバーとデータサーバーの両方に表示される状態（サイズなど）を変更する機能があるため、データサーバーのセット全体で結果の状態が一貫していることを確認する必要があります。ファイルを拡大します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described earlier, the LAYOUTCOMMIT operation is used to ensure that the metadata is synchronized with changes made to the data servers. For the NFSv4.1-based data storage protocol, it is necessary to re-synchronize state such as the size attribute, and the setting of mtime/change/atime. See Section 12.5.4 for a full description of the semantics regarding LAYOUTCOMMIT and attribute synchronization. It should be noted that by using an NFSv4.1-based layout type, it is possible to synchronize this state before LAYOUTCOMMIT occurs. For example, the control protocol can be used to query the attributes present on the data servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前述のように、LAYOUTCOMMIT操作は、メタデータがデータサーバーに加えられた変更と確実に同期されるようにするために使用されます。 NFSv4.1ベースのデータストレージプロトコルの場合、サイズ属性やmtime / change / atimeの設定などの状態を再同期する必要があります。 LAYOUTCOMMITと属性の同期に関するセマンティクスの詳細については、セクション12.5.4を参照してください。 NFSv4.1ベースのレイアウトタイプを使用すると、LAYOUTCOMMITが発生する前にこの状態を同期できることに注意してください。たとえば、制御プロトコルを使用して、データサーバーに存在する属性を照会できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any changes to file attributes that control authorization or access as reflected by ACCESS calls or READs and WRITEs on the metadata server, MUST be propagated to the data servers for enforcement on READ and WRITE I/O calls. If the changes made on the metadata server result in more restrictive access permissions for any user, those changes MUST be propagated to the data servers synchronously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバー上のACCESS呼び出しまたはREADおよびWRITEによって反映される承認またはアクセスを制御するファイル属性への変更は、READおよびWRITE I / O呼び出しの実施のためにデータサーバーに伝播する必要があります。メタデータサーバーで行われた変更の結果、すべてのユーザーのアクセス制限が制限される場合は、それらの変更をデータサーバーに同期的に伝達する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPEN operation (Section 18.16.4) does not impose any requirement that I/O operations on an open file have the same credentials as the OPEN itself (unless EXCHGID4_FLAG_BIND_PRINC_STATEID is set when EXCHANGE_ID creates the client ID), and so it requires the server&#39;s READ and WRITE operations to perform appropriate access checking. Changes to ACLs also require new access checking by READ and WRITE on the server. The propagation of access-right changes due to changes in ACLs may be asynchronous only if the server implementation is able to determine that the updated ACL is not more restrictive for any user specified in the old ACL. Due to the relative infrequency of ACL updates, it is suggested that all changes be propagated synchronously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN操作（セクション18.16.4）は、開いているファイルのI / O操作がOPEN自体と同じ資格情報を持つことを要求していません（EXCHGID4_FLAG_BIND_PRINC_STATEIDがEXCHANGE_IDでクライアントIDを作成するときに設定されている場合を除く）。したがって、サーバーの適切なアクセスチェックを実行するためのREADおよびWRITE操作。 ACLの変更には、サーバーでのREADおよびWRITEによる新しいアクセスチェックも必要です。 ACLの変更によるアクセス権の変更の伝達は、サーバーの実装が、更新されたACLが古いACLで指定されたユーザーに対してより制限的でないと判断できる場合にのみ非同期になる可能性があります。 ACLの更新は比較的頻度が低いため、すべての変更を同期的に伝播することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-10--Data-Server-Component-File-Size">
13.10. Data Server Component File Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.10. データサーバーコンポーネントのファイルサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A potential problem exists when a component data file on a particular data server has grown past EOF; the problem exists for both dense and sparse layouts. Imagine the following scenario: a client creates a new file (size == 0) and writes to byte 131072; the client then seeks to the beginning of the file and reads byte 100. The client should receive zeroes back as a result of the READ. However, if the striping pattern directs the client to send the READ to a data server other than the one that received the client&#39;s original WRITE, the data server servicing the READ may believe that the file&#39;s size is still 0 bytes. In that event, the data server&#39;s READ response will contain zero bytes and an indication of EOF. The data server can only return zeroes if it knows that the file&#39;s size has been extended. This would require the immediate propagation of the file&#39;s size to all data servers, which is potentially very costly. Therefore, the client that has initiated the extension of the file&#39;s size MUST be prepared to deal with these EOF conditions. When the offset in the arguments to READ is less than the client&#39;s view of the file size, if the READ response indicates EOF and/or contains fewer bytes than requested, the client will interpret such a response as a hole in the file, and the NFS client will substitute zeroes for the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のデータサーバー上のコンポーネントデータファイルがEOFを超えて大きくなると、潜在的な問題が発生します。この問題は、密レイアウトと疎レイアウトの両方に存在します。次のシナリオを想像してみてください。クライアントが新しいファイル（サイズ== 0）を作成し、バイト131072に書き込みます。次に、クライアントはファイルの先頭にシークし、バイト100を読み取ります。クライアントは、READの結果としてゼロを受け取る必要があります。ただし、ストライピングパターンがクライアントに、クライアントの元のWRITEを受信したデータサーバー以外のデータサーバーにREADを送信するように指示している場合、READにサービスを提供するデータサーバーは、ファイルのサイズがまだ0バイトであると信じている場合があります。その場合、データサーバーのREAD応答には0バイトとEOFの表示が含まれます。データ・サーバーは、ファイルのサイズが拡張されていることがわかっている場合にのみゼロを返すことができます。これには、ファイルのサイズをすべてのデータサーバーに即座に伝達する必要があり、非常にコストがかかる可能性があります。したがって、ファイルのサイズの拡張を開始したクライアントは、これらのEOF条件に対処できるように準備する必要があります。 READの引数のオフセットがクライアントのファイルサイズのビューよりも小さい場合、READ応答がEOFを示すか、要求されたよりも少ないバイトを含む場合、クライアントはそのような応答をファイルの穴として解釈し、 NFSクライアントは、データをゼロに置き換えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 protocol only provides close-to-open file data cache semantics; meaning that when the file is closed, all modified data is written to the server. When a subsequent OPEN of the file is done, the change attribute is inspected for a difference from a cached value for the change attribute. For the case above, this means that a LAYOUTCOMMIT will be done at close (along with the data WRITEs) and will update the file&#39;s size and change attribute. Access from another client after that point will result in the appropriate size being returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1プロトコルは、オープンに近いファイルデータキャッシュセマンティクスのみを提供します。つまり、ファイルが閉じられると、変更されたすべてのデータがサーバーに書き込まれます。ファイルの後続のOPENが行われると、変更属性は、変更属性のキャッシュされた値との違いを検査されます。上記の場合、これは、LAYOUTCOMMITが（データの書き込みとともに）クローズ時に行われ、ファイルのサイズを更新して属性を変更することを意味します。それ以降に別のクライアントからアクセスすると、適切なサイズが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-11--Layout-Revocation-and-Fencing">
13.11. Layout Revocation and Fencing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.11. レイアウトの取り消しとフェンシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 12.7, the layout-type-specific storage protocol is responsible for handling the effects of I/Os that started before lease expiration and extend through lease expiration. The LAYOUT4_NFSV4_1_FILES layout type can prevent all I/Os to data servers from being executed after lease expiration (this prevention is called &#34;fencing&#34;), without relying on a precise client lease timer and without requiring data servers to maintain lease timers. The LAYOUT4_NFSV4_1_FILES pNFS server has the flexibility to revoke individual layouts, and thus fence I/O on a per-file basis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション12.7で説明されているように、レイアウトタイプ固有のストレージプロトコルは、リースの有効期限が切れる前に開始され、リースの有効期限が切れるまでのI / Oの影響を処理します。 LAYOUT4_NFSV4_1_FILESレイアウトタイプは、正確なクライアントリースタイマーに依存することなく、またデータサーバーにリースタイマーを維持することを要求せずに、リースの有効期限後にデータサーバーへのすべてのI / Oが実行されるのを防ぎます（この防止は「フェンシング」と呼ばれます）。 LAYOUT4_NFSV4_1_FILES pNFSサーバーには、個々のレイアウトを取り消す柔軟性があるため、ファイルごとにI / Oをフェンスできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to lease expiration, the reasons a layout can be revoked include: client fails to respond to a CB_LAYOUTRECALL, the metadata server restarts, or administrative intervention. Regardless of the reason, once a client&#39;s layout has been revoked, the pNFS server MUST prevent the client from sending I/O for the affected file from and to all data servers; in other words, it MUST fence the client from the affected file on the data servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リースの有効期限に加えて、レイアウトを取り消すことができる理由には、クライアントがCB_LAYOUTRECALLへの応答に失敗する、メタデータサーバーが再起動する、または管理者の介入が含まれます。理由に関係なく、いったんクライアントのレイアウトが取り消されると、pNFSサーバーは、クライアントが影響を受けるファイルのI / Oをすべてのデータサーバーとの間で送信することを防止する必要があります。言い換えると、データサーバー上の影響を受けるファイルからクライアントをフェンスする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fencing works as follows. As described in Section 13.1, in COMPOUND procedure requests to the data server, the data filehandle provided by the PUTFH operation and the stateid in the READ or WRITE operation are used to ensure that the client has a valid layout for the I/O being performed; if it does not, the I/O is rejected with NFS4ERR_PNFS_NO_LAYOUT. The server can simply check the stateid and, additionally, make the data filehandle stale if the layout specified a data filehandle that is different from the metadata server&#39;s filehandle for the file (see the nfl_fh_list description in Section 13.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フェンシングは次のように機能します。セクション13.1で説明したように、データサーバーへのCOMPOUNDプロシージャリクエストでは、PUTFH操作によって提供されるデータファイルハンドルと、READまたはWRITE操作のstateidを使用して、クライアントが実行中のI / Oの有効なレイアウトを持っていることを確認します。 ;そうでない場合、I / OはNFS4ERR_PNFS_NO_LAYOUTで拒否されます。サーバーは単に状態IDをチェックし、さらに、レイアウトがファイルのメタデータサーバーのファイルハンドルと異なるデータファイルハンドルを指定した場合、データファイルハンドルを古くすることができます（セクション13.3のnfl_fh_listの説明を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before the metadata server takes any action to revoke layout state given out by a previous instance, it must make sure that all layout state from that previous instance are invalidated at the data servers. This has the following implications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーは、前のインスタンスによって与えられたレイアウト状態を取り消すためのアクションを実行する前に、その前のインスタンスからのすべてのレイアウト状態がデータサーバーで無効化されていることを確認する必要があります。これには次の影響があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The metadata server must not restripe a file until it has contacted all of the data servers to invalidate the layouts from the previous instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o メタデータサーバーは、以前のインスタンスからのレイアウトを無効にするためにすべてのデータサーバーに接続するまで、ファイルを再ストライプ化してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The metadata server must not give out mandatory locks that conflict with layouts from the previous instance without either doing a specific layout invalidation (as it would have to do anyway) or doing a global data server invalidation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o メタデータサーバーは、特定のレイアウトの無効化（とにかく行う必要がある）またはグローバルデータサーバーの無効化を行わずに、前のインスタンスのレイアウトと競合する必須ロックを提供してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-12--Security-Considerations-for-the-File-Layout-Type">
13.12. Security Considerations for the File Layout Type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.12. ファイルレイアウトタイプのセキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 file layout type MUST adhere to the security considerations outlined in Section 12.9. NFSv4.1 data servers MUST make all of the required access checks on each READ or WRITE I/O as determined by the NFSv4.1 protocol. If the metadata server would deny a READ or WRITE operation on a file due to its ACL, mode attribute, open access mode, open deny mode, mandatory byte-range lock state, or any other attributes and state, the data server MUST also deny the READ or WRITE operation. This impacts the control protocol and the propagation of state from the metadata server to the data servers; see Section 13.9.2 for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1ファイルレイアウトタイプは、セクション12.9で概説されているセキュリティの考慮事項に準拠する必要があります。 NFSv4.1データサーバーは、NFSv4.1プロトコルによって決定されるように、各読み取りまたは書き込みI / Oで必要なすべてのアクセスチェックを行う必要があります。メタデータサーバーが、ファイルのACL、モード属性、オープンアクセスモード、オープン拒否モード、必須のバイト範囲ロック状態、またはその他の属性と状態のために、ファイルの読み取りまたは書き込み操作を拒否する場合、データサーバーも拒否する必要があります。 READまたはWRITE操作。これは、制御プロトコルと、メタデータサーバーからデータサーバーへの状態の伝達に影響します。詳細については、セクション13.9.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The methods for authentication, integrity, and privacy for data servers based on the LAYOUT4_NFSV4_1_FILES layout type are the same as those used by metadata servers. Metadata and data servers use ONC RPC security flavors to authenticate, and SECINFO and SECINFO_NO_NAME to negotiate the security mechanism and services to be used. Thus, when using the LAYOUT4_NFSV4_1_FILES layout type, the impact on the RPC-based security model due to pNFS (as alluded to in Sections 1.7.1 and 1.7.2.2) is zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUT4_NFSV4_1_FILESレイアウトタイプに基づくデータサーバーの認証、整合性、プライバシーの方法は、メタデータサーバーで使用される方法と同じです。メタデータおよびデータサーバーは、ONC RPCセキュリティフレーバーを使用して認証し、SECINFOおよびSECINFO_NO_NAMEを使用して、使用するセキュリティメカニズムおよびサービスをネゴシエートします。したがって、LAYOUT4_NFSV4_1_FILESレイアウトタイプを使用する場合、pNFSによるRPCベースのセキュリティモデルへの影響（セクション1.7.1および1.7.2.2で言及）はゼロです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a given file object, a metadata server MAY require different security parameters (secinfo4 value) than the data server. For a given file object with multiple data servers, the secinfo4 value SHOULD be the same across all data servers. If the secinfo4 values across a metadata server and its data servers differ for a specific file, the mapping of the principal to the server&#39;s internal user identifier MUST be the same in order for the access-control checks based on ACL, mode, open and deny mode, and mandatory locking to be consistent across on the pNFS server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のファイルオブジェクトについて、メタデータサーバーは、データサーバーとは異なるセキュリティパラメータ（secinfo4値）を必要とする場合があります。複数のデータサーバーを持つ特定のファイルオブジェクトの場合、secinfo4値はすべてのデータサーバーで同じである必要があります（SHOULD）。メタデータサーバーとそのデータサーバー全体のsecinfo4値が特定のファイルで異なる場合、ACL、モード、オープン、拒否に基づくアクセス制御チェックのために、サーバーの内部ユーザー識別子へのプリンシパルのマッピングは同じでなければなりません。モード、およびpNFSサーバー全体で一貫性を保つための必須ロック。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an NFSv4.1 implementation supports pNFS and supports NFSv4.1 file layouts, then the implementation MUST support the SECINFO_NO_NAME operation on both the metadata and data servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1実装がpNFSをサポートし、NFSv4.1ファイルレイアウトをサポートする場合、実装はメタデータサーバーとデータサーバーの両方でSECINFO_NO_NAME操作をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14--Internationalization">
14. Internationalization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. 国際化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The primary issue in which NFSv4.1 needs to deal with internationalization, or I18N, is with respect to file names and other strings as used within the protocol. The choice of string representation must allow reasonable name/string access to clients that use various languages. The UTF-8 encoding of the UCS (Universal Multiple-Octet Coded Character Set) as defined by ISO10646 [21] allows for this type of access and follows the policy described in &#34;IETF Policy on Character Sets and Languages&#34;, RFC 2277 [22].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1が国際化、つまりI18Nを処理する必要がある主な問題は、プロトコル内で使用されるファイル名およびその他の文字列に関するものです。文字列表現の選択では、さまざまな言語を使用するクライアントに適切な名前/文字列アクセスを許可する必要があります。 ISO10646 [21]で定義されているUCS（Universal Multiple-Octet Coded Character Set）のUTF-8エンコーディングでは、このタイプのアクセスが可能で、RFC 2277 [22の「文字セットと言語に関するIETFポリシー」で説明されているポリシーに従います。 ]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 3454 [19], otherwise know as &#34;stringprep&#34;, documents a framework for using Unicode/UTF-8 in networking protocols so as &#34;to increase the likelihood that string input and string comparison work in ways that make sense for typical users throughout the world&#34;. A protocol must define a profile of stringprep &#34;in order to fully specify the processing options&#34;. The remainder of this section defines the NFSv4.1 stringprep profiles. Much of the terminology used for the remainder of this section comes from stringprep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 3454 [19]（別名「stringprep」）は、ネットワークプロトコルでUnicode / UTF-8を使用するためのフレームワークを文書化し、「文字列入力と文字列比較が、一般的なユーザーにとって意味のある方法で機能する可能性を高めます世界&#34;。プロトコルは、「処理オプションを完全に指定するために」stringprepのプロファイルを定義する必要があります。このセクションの残りの部分では、NFSv4.1 stringprepプロファイルを定義します。このセクションの残りの部分で使用される用語の多くは、stringprepに由来しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are three UTF-8 string types defined for NFSv4.1: utf8str_cs, utf8str_cis, and utf8str_mixed. Separate profiles are defined for each. Each profile defines the following, as required by stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1には、utf8str_cs、utf8str_cis、utf8str_mixedの3つのUTF-8文字列タイプが定義されています。それぞれに個別のプロファイルが定義されています。 stringprepでの必要に応じて、各プロファイルは以下を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The intended applicability of the profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o プロファイルの意図された適用性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The character repertoire that is the input and output to stringprep (which is Unicode 3.2 for the referenced version of stringprep). However, NFSv4.1 implementations are not limited to 3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o stringprepへの入力と出力である文字レパートリー（stringprepの参照バージョンのUnicode 3.2）。ただし、NFSv4.1の実装は3.2に限定されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The mapping tables from stringprep used (as described in Section 3 of stringprep).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 使用されたstringprepのマッピングテーブル（stringprepのセクション3で説明）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Any additional mapping tables specific to the profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o プロファイルに固有の追加のマッピングテーブル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Unicode normalization used, if any (as described in Section 4 of stringprep).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 使用されるUnicode正規化（存在する場合）（stringprepのセクション4で説明）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The tables from the stringprep listing of characters that are prohibited as output (as described in Section 5 of stringprep).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 出力として禁止されている文字のstringprepリストの表（stringprepのセクション5で説明）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The bidirectional string testing used, if any (as described in Section 6 of stringprep).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 使用される双方向文字列テスト（ある場合）（stringprepのセクション6で説明）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Any additional characters that are prohibited as output specific to the profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o プロファイル固有の出力として禁止されている追加の文字。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stringprep discusses Unicode characters, whereas NFSv4.1 renders UTF-8 characters. Since there is a one-to-one mapping from UTF-8 to Unicode, when the remainder of this document refers to Unicode, the reader should assume UTF-8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
StringprepはUnicode文字について説明しますが、NFSv4.1はUTF-8文字をレンダリングします。 UTF-8からUnicodeへの1対1のマッピングがあるため、このドキュメントの残りの部分でUnicodeを参照する場合、読者はUTF-8を想定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Much of the text for the profiles comes from RFC 3491 [23].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロファイルのテキストの多くはRFC 3491 [23]からのものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-1--Stringprep-Profile-for-the-utf8strcs-Type">
14.1. Stringprep Profile for the utf8str_cs Type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. utf8str_csタイプのStringprepプロファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every use of the utf8str_cs type definition in the NFSv4 protocol specification follows the profile named nfs4_cs_prep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4プロトコル仕様でのutf8str_csタイプ定義の使用はすべて、nfs4_cs_prepという名前のプロファイルに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-1-1--Intended-Applicability-of-the-nfs4csprep-Profile">
14.1.1. Intended Applicability of the nfs4_cs_prep Profile
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.1. nfs4_cs_prepプロファイルの意図された適用性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The utf8str_cs type is a case-sensitive string of UTF-8 characters. Its primary use in NFSv4.1 is for naming components and pathnames. Components and pathnames are stored on the server&#39;s file system. Two valid distinct UTF-8 strings might be the same after processing via the utf8str_cs profile. If the strings are two names inside a directory, the NFSv4.1 server will need to either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_csタイプは、大文字と小文字が区別されるUTF-8文字列です。 NFSv4.1での主な用途は、コンポーネントとパス名の命名です。コンポーネントとパス名は、サーバーのファイルシステムに格納されます。 utf8str_csプロファイルで処理した後、2つの有効な異なるUTF-8文字列が同じになる可能性があります。文字列がディレクトリ内の2つの名前である場合、NFSv4.1サーバーは次のいずれかを行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o disallow the creation of a second name if its post-processed form collides with that of an existing name, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 後処理されたフォームが既存の名前のフォームと衝突する場合、2番目の名前の作成を許可しない、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o allow the creation of the second name, but arrange so that after post-processing, the second name is different than the post-processed form of the first name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2番目の名前の作成を許可しますが、後処理後に2番目の名前が1番目の名前の後処理形式と異なるように調整します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-1-2--Character-Repertoire-of-nfs4csprep">
14.1.2. Character Repertoire of nfs4_cs_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.2. nfs4_cs_prepの文字レパートリー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cs_prep profile uses Unicode 3.2, as defined in stringprep&#39;s Appendix A.1. However, NFSv4.1 implementations are not limited to 3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cs_prepプロファイルは、stringprepの付録A.1で定義されているように、Unicode 3.2を使用します。ただし、NFSv4.1の実装は3.2に限定されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-1-3--Mapping-Used-by-nfs4csprep">
14.1.3. Mapping Used by nfs4_cs_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.3. nfs4_cs_prepで使用されるマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cs_prep profile specifies mapping using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cs_prepプロファイルは、stringprepの次のテーブルを使用してマッピングを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table B.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表B.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table B.2 is normally not part of the nfs4_cs_prep profile as it is primarily for dealing with case-insensitive comparisons. However, if the NFSv4.1 file server supports the case_insensitive file system attribute, and if case_insensitive is TRUE, the NFSv4.1 server MUST use Table B.2 (in addition to Table B1) when processing utf8str_cs strings, and the NFSv4.1 client MUST assume Table B.2 (in addition to Table B.1) is being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表B.2は、主に大文字と小文字を区別しない比較を処理するためのものであるため、通常、nfs4_cs_prepプロファイルの一部ではありません。ただし、NFSv4.1ファイルサーバーがcase_insensitiveファイルシステム属性をサポートし、case_insensitiveがTRUEの場合、NFSv4.1サーバーはutf8str_cs文字列の処理時に（表B1に加えて）表B.2を使用する必要があり、NFSv4.1クライアントは、（表B.1に加えて）表B.2が使用されていると想定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the case_preserving attribute is present and set to FALSE, then the NFSv4.1 server MUST use Table B.2 to map case when processing utf8str_cs strings. Whether the server maps from lower to upper case or from upper to lower case is an implementation dependency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
case_preserving属性が存在し、FALSEに設定されている場合、NFSv4.1サーバーは、表B.2を使用して、utf8str_cs文字列を処理するときに大文字と小文字をマップする必要があります。サーバーが小文字から大文字にマップするか、大文字から小文字にマップするかは、実装の依存関係です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-1-4--Normalization-used-by-nfs4csprep">
14.1.4. Normalization used by nfs4_cs_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.4. nfs4_cs_prepで使用される正規化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cs_prep profile does not specify a normalization form. A later revision of this specification may specify a particular normalization form. Therefore, the server and client can expect that they may receive unnormalized characters within protocol requests and responses. If the operating environment requires normalization, then the implementation must normalize utf8str_cs strings within the protocol before presenting the information to an application (at the client) or local file system (at the server).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cs_prepプロファイルは、正規化形式を指定していません。この仕様の今後の改訂では、特定の正規化形式を指定する可能性があります。したがって、サーバーとクライアントは、プロトコルの要求と応答内で正規化されていない文字を受け取る可能性があることを期待できます。オペレーティング環境が正規化を必要とする場合、実装は、情報をアプリケーション（クライアント）またはローカルファイルシステム（サーバー）に提示する前に、プロトコル内のutf8str_cs文字列を正規化する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-1-5--Prohibited-Output-for-nfs4csprep">
14.1.5. Prohibited Output for nfs4_cs_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.5. nfs4_cs_prepの禁止出力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cs_prep profile RECOMMENDS prohibiting the use of the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cs_prepプロファイルは、stringprepから次のテーブルの使用を禁止することを推奨します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-1-6--Bidirectional-Output-for-nfs4csprep">
14.1.6. Bidirectional Output for nfs4_cs_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.6. nfs4_cs_prepの双方向出力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cs_prep profile does not specify any checking of bidirectional strings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cs_prepプロファイルは、双方向文字列のチェックを指定しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2--Stringprep-Profile-for-the-utf8strcis-Type">
14.2. Stringprep Profile for the utf8str_cis Type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. utf8str_cisタイプのStringprepプロファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every use of the utf8str_cis type definition in the NFSv4.1 protocol specification follows the profile named nfs4_cis_prep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1プロトコル仕様でのutf8str_cisタイプ定義の使用はすべて、nfs4_cis_prepという名前のプロファイルに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-1--Intended-Applicability-of-the-nfs4cisprep-Profile">
14.2.1. Intended Applicability of the nfs4_cis_prep Profile
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.1. nfs4_cis_prepプロファイルの意図された適用性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The utf8str_cis type is a case-insensitive string of UTF-8 characters. Its primary use in NFSv4.1 is for naming NFS servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_cisタイプは、大文字と小文字を区別しないUTF-8文字列です。 NFSv4.1での主な用途は、NFSサーバーの命名です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-2--Character-Repertoire-of-nfs4cisprep">
14.2.2. Character Repertoire of nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.2. nfs4_cis_prepの文字レパートリー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cis_prep profile uses Unicode 3.2, as defined in stringprep&#39;s Appendix A.1. However, NFSv4.1 implementations are not limited to 3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cis_prepプロファイルは、stringprepの付録A.1で定義されているように、Unicode 3.2を使用します。ただし、NFSv4.1の実装は3.2に限定されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-3--Mapping-Used-by-nfs4cisprep">
14.2.3. Mapping Used by nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.3. nfs4_cis_prepで使用されるマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cis_prep profile specifies mapping using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cis_prepプロファイルは、stringprepの次のテーブルを使用してマッピングを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table B.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表B.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table B.2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表B.2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-4--Normalization-Used-by-nfs4cisprep">
14.2.4. Normalization Used by nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.4. nfs4_cis_prepで使用される正規化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cis_prep profile specifies using Unicode normalization form KC, as described in stringprep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cis_prepプロファイルは、stringprepで説明されているように、KCからのUnicode正規化の使用を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-5--Prohibited-Output-for-nfs4cisprep">
14.2.5. Prohibited Output for nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.5. nfs4_cis_prepの禁止出力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cis_prep profile specifies prohibiting using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cis_prepプロファイルは、stringprepから次のテーブルを使用することを禁止することを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.1.2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.1.2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.2.2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.2.2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.7
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.7
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.8
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.8
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.9
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.9
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-6--Bidirectional-Output-for-nfs4cisprep">
14.2.6. Bidirectional Output for nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.6. nfs4_cis_prepの双方向出力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cis_prep profile specifies checking bidirectional strings as described in stringprep&#39;s Section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cis_prepプロファイルは、stringprepのセクション6で説明されているように、双方向文字列のチェックを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-3--Stringprep-Profile-for-the-utf8strmixed-Type">
14.3. Stringprep Profile for the utf8str_mixed Type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3. utf8str_mixedタイプのStringprepプロファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every use of the utf8str_mixed type definition in the NFSv4.1 protocol specification follows the profile named nfs4_mixed_prep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1プロトコル仕様でのutf8str_mixedタイプ定義の使用はすべて、nfs4_mixed_prepという名前のプロファイルに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-3-1--Intended-Applicability-of-the-nfs4mixedprep-Profile">
14.3.1. Intended Applicability of the nfs4_mixed_prep Profile
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3.1. nfs4_mixed_prepプロファイルの意図された適用性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The utf8str_mixed type is a string of UTF-8 characters, with a prefix that is case sensitive, a separator equal to &#39;@&#39;, and a suffix that is a fully qualified domain name. Its primary use in NFSv4.1 is for naming principals identified in an Access Control Entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_mixedタイプは、大文字と小文字が区別されるプレフィックス、「@」に等しいセパレータ、および完全修飾ドメイン名であるサフィックスを持つUTF-8文字の文字列です。 NFSv4.1での主な用途は、アクセス制御エントリで識別されるプリンシパルに名前を付けることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-3-2--Character-Repertoire-of-nfs4mixedprep">
14.3.2. Character Repertoire of nfs4_mixed_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3.2. nfs4_mixed_prepの文字レパートリー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_mixed_prep profile uses Unicode 3.2, as defined in stringprep&#39;s Appendix A.1. However, NFSv4.1 implementations are not limited to 3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_mixed_prepプロファイルは、stringprepの付録A.1で定義されているように、Unicode 3.2を使用します。ただし、NFSv4.1の実装は3.2に限定されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-3-3--Mapping-Used-by-nfs4cisprep">
14.3.3. Mapping Used by nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3.3. nfs4_cis_prepで使用されるマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the prefix and the separator of a utf8str_mixed string, the nfs4_mixed_prep profile specifies mapping using the following table from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_mixed文字列の接頭辞と区切り記号の場合、nfs4_mixed_prepプロファイルは、stringprepの次のテーブルを使用してマッピングを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table B.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表B.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the suffix of a utf8str_mixed string, the nfs4_mixed_prep profile specifies mapping using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_mixed文字列のサフィックスの場合、nfs4_mixed_prepプロファイルは、stringprepの次のテーブルを使用してマッピングを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table B.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表B.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table B.2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表B.2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-3-4--Normalization-Used-by-nfs4mixedprep">
14.3.4. Normalization Used by nfs4_mixed_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3.4. nfs4_mixed_prepで使用される正規化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_mixed_prep profile specifies using Unicode normalization form KC, as described in stringprep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_mixed_prepプロファイルは、stringprepで説明されているように、KCからのUnicode正規化の使用を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-3-5--Prohibited-Output-for-nfs4mixedprep">
14.3.5. Prohibited Output for nfs4_mixed_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3.5. nfs4_mixed_prepの禁止出力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_mixed_prep profile specifies prohibiting using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_mixed_prepプロファイルは、stringprepから次のテーブルを使用することを禁止することを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.1.2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.1.2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.2.2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.2.2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Table C.5 Table C.6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
表C.5表C.6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.7
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.7
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.8
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.8
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.9
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.9
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-3-6--Bidirectional-Output-for-nfs4mixedprep">
14.3.6. Bidirectional Output for nfs4_mixed_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3.6. nfs4_mixed_prepの双方向出力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_mixed_prep profile specifies checking bidirectional strings as described in stringprep&#39;s Section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_mixed_prepプロファイルは、stringprepのセクション6で説明されているように、双方向文字列のチェックを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-4--UTF-8-Capabilities">
14.4. UTF-8 Capabilities
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.4. UTF-8機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const FSCHARSET_CAP4_CONTAINS_NON_UTF8  = 0x1;
   const FSCHARSET_CAP4_ALLOWS_ONLY_UTF8   = 0x2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t fs_charset_cap4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t fs_charset_cap4;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because some operating environments and file systems do not enforce character set encodings, NFSv4.1 supports the fs_charset_cap attribute (Section 5.8.2.11) that indicates to the client a file system&#39;s UTF-8 capabilities. The attribute is an integer containing a pair of flags. The first flag is FSCHARSET_CAP4_CONTAINS_NON_UTF8, which, if set to one, tells the client that the file system contains non-UTF-8 characters, and the server will not convert non-UTF characters to UTF-8 if the client reads a symlink or directory, neither will operations with component names or pathnames in the arguments convert the strings to UTF-8. The second flag is FSCHARSET_CAP4_ALLOWS_ONLY_UTF8, which, if set to one, indicates that the server will accept (and generate) only UTF-8 characters on the file system. If FSCHARSET_CAP4_ALLOWS_ONLY_UTF8 is set to one, FSCHARSET_CAP4_CONTAINS_NON_UTF8 MUST be set to zero. FSCHARSET_CAP4_ALLOWS_ONLY_UTF8 SHOULD always be set to one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のオペレーティング環境とファイルシステムは文字セットエンコーディングを強制しないため、NFSv4.1はクライアントにファイルシステムのUTF-8機能を示すfs_charset_cap属性（セクション5.8.2.11）をサポートします。属性は、フラグのペアを含む整数です。最初のフラグはFSCHARSET_CAP4_CONTAINS_NON_UTF8であり、これを1に設定すると、ファイルシステムに非UTF-8文字が含まれていることをクライアントに通知し、クライアントがシンボリックリンクまたはディレクトリを読み取る場合、サーバーは非UTF文字をUTF-8に変換しません。 、引数にコンポーネント名またはパス名を指定した操作では、文字列はUTF-8に変換されません。 2番目のフラグはFSCHARSET_CAP4_ALLOWS_ONLY_UTF8であり、1に設定されている場合、サーバーがファイルシステムでUTF-8文字のみを受け入れ（そして生成）することを示します。 FSCHARSET_CAP4_ALLOWS_ONLY_UTF8が1に設定されている場合、FSCHARSET_CAP4_CONTAINS_NON_UTF8はゼロに設定する必要があります。 FSCHARSET_CAP4_ALLOWS_ONLY_UTF8は常に1に設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-5--UTF-8-Related-Errors">
14.5. UTF-8 Related Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.5. UTF-8関連のエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the client sends an invalid UTF-8 string, the server should return NFS4ERR_INVAL (see Table 5). This includes cases in which inappropriate prefixes are detected and where the count includes trailing bytes that do not constitute a full UCS character.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが無効なUTF-8文字列を送信する場合、サーバーはNFS4ERR_INVALを返す必要があります（表5を参照）。これには、不適切なプレフィックスが検出された場合や、完全なUCS文字を構成しない末尾のバイトがカウントに含まれる場合が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Where the client-supplied string is valid UTF-8 but contains characters that are not supported by the server as a value for that string (e.g., names containing characters outside of Unicode plane 0 on file systems that fail to support such characters despite their presence in the Unicode standard), the server should return NFS4ERR_BADCHAR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントが提供する文字列は有効なUTF-8であるが、その文字列の値としてサーバーでサポートされていない文字が含まれている場合（たとえば、存在するにもかかわらず、そのような文字をサポートできないファイルシステムのUnicodeプレーン0以外の文字を含む名前） Unicode標準では）、サーバーはNFS4ERR_BADCHARを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where a UTF-8 string is used as a file name, and the file system (while supporting all of the characters within the name) does not allow that particular name to be used, the server should return the error NFS4ERR_BADNAME (Table 5). This includes situations in which the server file system imposes a normalization constraint on name strings, but will also include such situations as file system prohibitions of &#34;.&#34; and &#34;..&#34; as file names for certain operations, and other such constraints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UTF-8文字列がファイル名として使用され、ファイルシステム（名前内のすべての文字をサポートしている）がその特定の名前の使用を許可していない場合、サーバーはエラーNFS4ERR_BADNAMEを返す必要があります（表5）。これには、サーバーファイルシステムが名前文字列に正規化の制約を課す状況が含まれますが、「。」のファイルシステム禁止などの状況も含まれます。および「..」は、特定の操作やその他の制約のファイル名として使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15--Error-Values">
15. Error Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. エラー値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS error numbers are assigned to failed operations within a Compound (COMPOUND or CB_COMPOUND) request. A Compound request contains a number of NFS operations that have their results encoded in sequence in a Compound reply. The results of successful operations will consist of an NFS4_OK status followed by the encoded results of the operation. If an NFS operation fails, an error status will be entered in the reply and the Compound request will be terminated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSエラー番号は、複合（COMPOUNDまたはCB_COMPOUND）要求内の失敗した操作に割り当てられます。複合要求には、複合応答で結果が順番にエンコードされたいくつかのNFS操作が含まれています。成功した操作の結果は、NFS4_OKステータスと、それに続く操作のエンコードされた結果で構成されます。 NFS操作が失敗した場合、エラーステータスが応答に入力され、複合要求は終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1--Error-Definitions">
15.1. Error Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1. エラー定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
Protocol Error Definitions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
プロトコルエラーの定義
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    +-----------------------------------+--------+-------------------+
    | Error                             | Number | Description       |
    +-----------------------------------+--------+-------------------+
    | NFS4_OK                           | 0      | Section 15.1.3.1  |
    | NFS4ERR_ACCESS                    | 13     | Section 15.1.6.1  |
    | NFS4ERR_ATTRNOTSUPP               | 10032  | Section 15.1.15.1 |
    | NFS4ERR_ADMIN_REVOKED             | 10047  | Section 15.1.5.1  |
    | NFS4ERR_BACK_CHAN_BUSY            | 10057  | Section 15.1.12.1 |
    | NFS4ERR_BADCHAR                   | 10040  | Section 15.1.7.1  |
    | NFS4ERR_BADHANDLE                 | 10001  | Section 15.1.2.1  |
    | NFS4ERR_BADIOMODE                 | 10049  | Section 15.1.10.1 |
    | NFS4ERR_BADLAYOUT                 | 10050  | Section 15.1.10.2 |
    | NFS4ERR_BADNAME                   | 10041  | Section 15.1.7.2  |
    | NFS4ERR_BADOWNER                  | 10039  | Section 15.1.15.2 |
    | NFS4ERR_BADSESSION                | 10052  | Section 15.1.11.1 |
    | NFS4ERR_BADSLOT                   | 10053  | Section 15.1.11.2 |
    | NFS4ERR_BADTYPE                   | 10007  | Section 15.1.4.1  |
    | NFS4ERR_BADXDR                    | 10036  | Section 15.1.1.1  |
    | NFS4ERR_BAD_COOKIE                | 10003  | Section 15.1.1.2  |
    | NFS4ERR_BAD_HIGH_SLOT             | 10077  | Section 15.1.11.3 |
    | NFS4ERR_BAD_RANGE                 | 10042  | Section 15.1.8.1  |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    | NFS4ERR_BAD_SEQID                 | 10026  | Section 15.1.16.1 |
    | NFS4ERR_BAD_SESSION_DIGEST        | 10051  | Section 15.1.12.2 |
    | NFS4ERR_BAD_STATEID               | 10025  | Section 15.1.5.2  |
    | NFS4ERR_CB_PATH_DOWN              | 10048  | Section 15.1.11.4 |
    | NFS4ERR_CLID_INUSE                | 10017  | Section 15.1.13.2 |
    | NFS4ERR_CLIENTID_BUSY             | 10074  | Section 15.1.13.1 |
    | NFS4ERR_COMPLETE_ALREADY          | 10054  | Section 15.1.9.1  |
    | NFS4ERR_CONN_NOT_BOUND_TO_SESSION | 10055  | Section 15.1.11.6 |
    | NFS4ERR_DEADLOCK                  | 10045  | Section 15.1.8.2  |
    | NFS4ERR_DEADSESSION               | 10078  | Section 15.1.11.5 |
    | NFS4ERR_DELAY                     | 10008  | Section 15.1.1.3  |
    | NFS4ERR_DELEG_ALREADY_WANTED      | 10056  | Section 15.1.14.1 |
    | NFS4ERR_DELEG_REVOKED             | 10087  | Section 15.1.5.3  |
    | NFS4ERR_DENIED                    | 10010  | Section 15.1.8.3  |
    | NFS4ERR_DIRDELEG_UNAVAIL          | 10084  | Section 15.1.14.2 |
    | NFS4ERR_DQUOT                     | 69     | Section 15.1.4.2  |
    | NFS4ERR_ENCR_ALG_UNSUPP           | 10079  | Section 15.1.13.3 |
    | NFS4ERR_EXIST                     | 17     | Section 15.1.4.3  |
    | NFS4ERR_EXPIRED                   | 10011  | Section 15.1.5.4  |
    | NFS4ERR_FBIG                      | 27     | Section 15.1.4.4  |
    | NFS4ERR_FHEXPIRED                 | 10014  | Section 15.1.2.2  |
    | NFS4ERR_FILE_OPEN                 | 10046  | Section 15.1.4.5  |
    | NFS4ERR_GRACE                     | 10013  | Section 15.1.9.2  |
    | NFS4ERR_HASH_ALG_UNSUPP           | 10072  | Section 15.1.13.4 |
    | NFS4ERR_INVAL                     | 22     | Section 15.1.1.4  |
    | NFS4ERR_IO                        | 5      | Section 15.1.4.6  |
    | NFS4ERR_ISDIR                     | 21     | Section 15.1.2.3  |
    | NFS4ERR_LAYOUTTRYLATER            | 10058  | Section 15.1.10.3 |
    | NFS4ERR_LAYOUTUNAVAILABLE         | 10059  | Section 15.1.10.4 |
    | NFS4ERR_LEASE_MOVED               | 10031  | Section 15.1.16.2 |
    | NFS4ERR_LOCKED                    | 10012  | Section 15.1.8.4  |
    | NFS4ERR_LOCKS_HELD                | 10037  | Section 15.1.8.5  |
    | NFS4ERR_LOCK_NOTSUPP              | 10043  | Section 15.1.8.6  |
    | NFS4ERR_LOCK_RANGE                | 10028  | Section 15.1.8.7  |
    | NFS4ERR_MINOR_VERS_MISMATCH       | 10021  | Section 15.1.3.2  |
    | NFS4ERR_MLINK                     | 31     | Section 15.1.4.7  |
    | NFS4ERR_MOVED                     | 10019  | Section 15.1.2.4  |
    | NFS4ERR_NAMETOOLONG               | 63     | Section 15.1.7.3  |
    | NFS4ERR_NOENT                     | 2      | Section 15.1.4.8  |
    | NFS4ERR_NOFILEHANDLE              | 10020  | Section 15.1.2.5  |
    | NFS4ERR_NOMATCHING_LAYOUT         | 10060  | Section 15.1.10.5 |
    | NFS4ERR_NOSPC                     | 28     | Section 15.1.4.9  |
    | NFS4ERR_NOTDIR                    | 20     | Section 15.1.2.6  |
    | NFS4ERR_NOTEMPTY                  | 66     | Section 15.1.4.10 |
    | NFS4ERR_NOTSUPP                   | 10004  | Section 15.1.1.5  |
    | NFS4ERR_NOT_ONLY_OP               | 10081  | Section 15.1.3.3  |
    | NFS4ERR_NOT_SAME                  | 10027  | Section 15.1.15.3 |
    | NFS4ERR_NO_GRACE                  | 10033  | Section 15.1.9.3  |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    | NFS4ERR_NXIO                      | 6      | Section 15.1.16.3 |
    | NFS4ERR_OLD_STATEID               | 10024  | Section 15.1.5.5  |
    | NFS4ERR_OPENMODE                  | 10038  | Section 15.1.8.8  |
    | NFS4ERR_OP_ILLEGAL                | 10044  | Section 15.1.3.4  |
    | NFS4ERR_OP_NOT_IN_SESSION         | 10071  | Section 15.1.3.5  |
    | NFS4ERR_PERM                      | 1      | Section 15.1.6.2  |
    | NFS4ERR_PNFS_IO_HOLE              | 10075  | Section 15.1.10.6 |
    | NFS4ERR_PNFS_NO_LAYOUT            | 10080  | Section 15.1.10.7 |
    | NFS4ERR_RECALLCONFLICT            | 10061  | Section 15.1.14.3 |
    | NFS4ERR_RECLAIM_BAD               | 10034  | Section 15.1.9.4  |
    | NFS4ERR_RECLAIM_CONFLICT          | 10035  | Section 15.1.9.5  |
    | NFS4ERR_REJECT_DELEG              | 10085  | Section 15.1.14.4 |
    | NFS4ERR_REP_TOO_BIG               | 10066  | Section 15.1.3.6  |
    | NFS4ERR_REP_TOO_BIG_TO_CACHE      | 10067  | Section 15.1.3.7  |
    | NFS4ERR_REQ_TOO_BIG               | 10065  | Section 15.1.3.8  |
    | NFS4ERR_RESTOREFH                 | 10030  | Section 15.1.16.4 |
    | NFS4ERR_RETRY_UNCACHED_REP        | 10068  | Section 15.1.3.9  |
    | NFS4ERR_RETURNCONFLICT            | 10086  | Section 15.1.10.8 |
    | NFS4ERR_ROFS                      | 30     | Section 15.1.4.11 |
    | NFS4ERR_SAME                      | 10009  | Section 15.1.15.4 |
    | NFS4ERR_SHARE_DENIED              | 10015  | Section 15.1.8.9  |
    | NFS4ERR_SEQUENCE_POS              | 10064  | Section 15.1.3.10 |
    | NFS4ERR_SEQ_FALSE_RETRY           | 10076  | Section 15.1.11.7 |
    | NFS4ERR_SEQ_MISORDERED            | 10063  | Section 15.1.11.8 |
    | NFS4ERR_SERVERFAULT               | 10006  | Section 15.1.1.6  |
    | NFS4ERR_STALE                     | 70     | Section 15.1.2.7  |
    | NFS4ERR_STALE_CLIENTID            | 10022  | Section 15.1.13.5 |
    | NFS4ERR_STALE_STATEID             | 10023  | Section 15.1.16.5 |
    | NFS4ERR_SYMLINK                   | 10029  | Section 15.1.2.8  |
    | NFS4ERR_TOOSMALL                  | 10005  | Section 15.1.1.7  |
    | NFS4ERR_TOO_MANY_OPS              | 10070  | Section 15.1.3.11 |
    | NFS4ERR_UNKNOWN_LAYOUTTYPE        | 10062  | Section 15.1.10.9 |
    | NFS4ERR_UNSAFE_COMPOUND           | 10069  | Section 15.1.3.12 |
    | NFS4ERR_WRONGSEC                  | 10016  | Section 15.1.6.3  |
    | NFS4ERR_WRONG_CRED                | 10082  | Section 15.1.6.4  |
    | NFS4ERR_WRONG_TYPE                | 10083  | Section 15.1.2.9  |
    | NFS4ERR_XDEV                      | 18     | Section 15.1.4.12 |
    +-----------------------------------+--------+-------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Table 5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
表5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-1--General-Errors">
15.1.1. General Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1. 一般的なエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section deals with errors that are applicable to a broad set of different purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、さまざまな目的に適用できるエラーについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-1-1--NFS4ERRBADXDR-Error-Code-10036">
15.1.1.1. NFS4ERR_BADXDR (Error Code 10036)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1.1. NFS4ERR_BADXDR（エラーコード10036）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The arguments for this operation do not match those specified in the XDR definition. This includes situations in which the request ends before all the arguments have been seen. Note that this error applies when fixed enumerations (these include booleans) have a value within the input stream that is not valid for the enum. A replier may pre-parse all operations for a Compound procedure before doing any operation execution and return RPC-level XDR errors in that case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作の引数は、XDR定義で指定されたものと一致しません。これには、すべての引数が確認される前に要求が終了する状況が含まれます。このエラーは、固定列挙（これらのブール値を含む）が入力ストリーム内で列挙に対して無効な値を持っている場合に適用されることに注意してください。返信者は、操作を実行する前に、複合手続きのすべての操作を事前に解析し、その場合はRPCレベルのXDRエラーを返すことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-1-2--NFS4ERRBADCOOKIE-Error-Code-10003">
15.1.1.2. NFS4ERR_BAD_COOKIE (Error Code 10003)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1.2. NFS4ERR_BAD_COOKIE（エラーコード10003）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Used for operations that provide a set of information indexed by some quantity provided by the client or cookie sent by the server for an earlier invocation. Where the value cannot be used for its intended purpose, this error results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前の呼び出しのためにクライアントから提供されたある量またはサーバーから送信されたCookieによってインデックス付けされた一連の情報を提供する操作に使用されます。意図した目的に値を使用できない場合、このエラーが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-1-3--NFS4ERRDELAY-Error-Code-10008">
15.1.1.3. NFS4ERR_DELAY (Error Code 10008)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1.3. NFS4ERR_DELAY（エラーコード10008）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For any of a number of reasons, the replier could not process this operation in what was deemed a reasonable time. The client should wait and then try the request with a new slot and sequence value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの理由のいずれかにより、返信者はこの操作を妥当な時間と見なされた時間内に処理できませんでした。クライアントは待機してから、新しいスロットとシーケンス値を使用して要求を試行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some examples of scenarios that might lead to this situation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この状況につながる可能性のあるシナリオの例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A server that supports hierarchical storage receives a request to process a file that had been migrated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 階層ストレージをサポートするサーバーが、移行されたファイルの処理要求を受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An operation requires a delegation recall to proceed, and waiting for this delegation recall makes processing this request in a timely fashion impossible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 操作は委任の取り消しを続行する必要があり、この委任の取り消しを待機すると、この要求をタイムリーに処理できなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In such cases, the error NFS4ERR_DELAY allows these preparatory operations to proceed without holding up client resources such as a session slot. After delaying for period of time, the client can then re-send the operation in question (but not with the same slot ID and sequence ID; one or both MUST be different on the re-send).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのような場合、エラーNFS4ERR_DELAYにより、セッションスロットなどのクライアントリソースを保持せずに、これらの準備操作を続行できます。一定期間遅延した後、クライアントは問題の操作を再送信できます（ただし、同じスロットIDとシーケンスIDを使用することはできません。再送信では一方または両方が異なる必要があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that without the ability to return NFS4ERR_DELAY and the client&#39;s willingness to re-send when receiving it, deadlock might result. For example, if a recall is done, and if the delegation return or operations preparatory to delegation return are held up by other operations that need the delegation to be returned, session slots might not be available. The result could be deadlock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DELAYを返す機能がなく、クライアントが受信時に再送信する意思がない場合、デッドロックが発生する可能性があることに注意してください。たとえば、リコールが行われ、委任の返還または委任の返還に備えた操作が、委任の返却を必要とする他の操作によって保留されている場合、セッションスロットが使用できない場合があります。その結果、デッドロックが発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-1-4--NFS4ERRINVAL-Error-Code-22">
15.1.1.4. NFS4ERR_INVAL (Error Code 22)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1.4. NFS4ERR_INVAL（エラーコード22）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The arguments for this operation are not valid for some reason, even though they do match those specified in the XDR definition for the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作の引数は、要求のXDR定義で指定された引数と一致していても、何らかの理由で無効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-1-5--NFS4ERRNOTSUPP-Error-Code-10004">
15.1.1.5. NFS4ERR_NOTSUPP (Error Code 10004)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1.5. NFS4ERR_NOTSUPP（エラーコード10004）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Operation not supported, either because the operation is an OPTIONAL one and is not supported by this server or because the operation MUST NOT be implemented in the current minor version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作がオプションであり、このサーバーでサポートされていないため、または操作を現在のマイナーバージョンに実装してはならないため、操作はサポートされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-1-6--NFS4ERRSERVERFAULT-Error-Code-10006">
15.1.1.6. NFS4ERR_SERVERFAULT (Error Code 10006)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1.6. NFS4ERR_SERVERFAULT（エラーコード10006）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An error occurred on the server that does not map to any of the specific legal NFSv4.1 protocol error values. The client should translate this into an appropriate error. UNIX clients may choose to translate this to EIO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定の正当なNFSv4.1プロトコルエラー値のいずれにもマップしないエラーがサーバーで発生しました。クライアントはこれを適切なエラーに変換する必要があります。 UNIXクライアントは、これをEIOに変換することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-1-7--NFS4ERRTOOSMALL-Error-Code-10005">
15.1.1.7. NFS4ERR_TOOSMALL (Error Code 10005)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1.7. NFS4ERR_TOOSMALL（エラーコード10005）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Used where an operation returns a variable amount of data, with a limit specified by the client. Where the data returned cannot be fit within the limit specified by the client, this error results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作が可変量のデータを返し、クライアントによって指定された制限がある場合に使用されます。返されたデータがクライアントによって指定された制限内に収まらない場合、このエラーが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-2--Filehandle-Errors">
15.1.2. Filehandle Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2. ファイルハンドルエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These errors deal with the situation in which the current or saved filehandle, or the filehandle passed to PUTFH intended to become the current filehandle, is invalid in some way. This includes situations in which the filehandle is a valid filehandle in general but is not of the appropriate object type for the current operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのエラーは、現在または保存されているファイルハンドル、または現在のファイルハンドルになることを目的としてPUTFHに渡されたファイルハンドルが何らかの方法で無効である状況に対処します。これには、ファイルハンドルが一般に有効なファイルハンドルであるが、現在の操作に適切なオブジェクトタイプではない状況が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the error description indicates a problem with the current or saved filehandle, it is to be understood that filehandles are only checked for the condition if they are implicit arguments of the operation in question.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラーの説明が現在または保存されているファイルハンドルの問題を示している場合、ファイルハンドルは問題の操作の暗黙的な引数である場合にのみ、条件がチェックされることを理解してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-2-1--NFS4ERRBADHANDLE-Error-Code-10001">
15.1.2.1. NFS4ERR_BADHANDLE (Error Code 10001)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2.1. NFS4ERR_BADHANDLE（エラーコード10001）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Illegal NFS filehandle for the current server. The current file handle failed internal consistency checks. Once accepted as valid (by PUTFH), no subsequent status change can cause the filehandle to generate this error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のサーバーの不正なNFSファイルハンドル。現在のファイルハンドルは内部整合性チェックに失敗しました。 （PUTFHによって）有効として受け入れられると、その後のステータス変更によってファイルハンドルがこのエラーを生成することはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-2-2--NFS4ERRFHEXPIRED-Error-Code-10014">
15.1.2.2. NFS4ERR_FHEXPIRED (Error Code 10014)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2.2. NFS4ERR_FHEXPIRED（エラーコード10014）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A current or saved filehandle that is an argument to the current operation is volatile and has expired at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の操作の引数である現在または保存されているファイルハンドルは揮発性であり、サーバーで有効期限が切れています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-2-3--NFS4ERRISDIR-Error-Code-21">
15.1.2.3. NFS4ERR_ISDIR (Error Code 21)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2.3. NFS4ERR_ISDIR（エラーコード21）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current or saved filehandle designates a directory when the current operation does not allow a directory to be accepted as the target of this operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルまたは保存されたファイルハンドルは、現在の操作でディレクトリをこの操作のターゲットとして受け入れることができない場合にディレクトリを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-2-4--NFS4ERRMOVED-Error-Code-10019">
15.1.2.4. NFS4ERR_MOVED (Error Code 10019)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2.4. NFS4ERR_MOVED（エラーコード10019）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The file system that contains the current filehandle object is not present at the server. It may have been relocated or migrated to another server, or it may have never been present. The client may obtain the new file system location by obtaining the &#34;fs_locations&#34; or &#34;fs_locations_info&#34; attribute for the current filehandle. For further discussion, refer to Section 11.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルオブジェクトを含むファイルシステムがサーバーに存在しません。別のサーバーに再配置または移行されたか、存在しなかった可能性があります。クライアントは、現在のファイルハンドルの「fs_locations」または「fs_locations_info」属性を取得することにより、新しいファイルシステムの場所を取得できます。詳細については、セクション11.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-2-5--NFS4ERRNOFILEHANDLE-Error-Code-10020">
15.1.2.5. NFS4ERR_NOFILEHANDLE (Error Code 10020)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2.5. NFS4ERR_NOFILEHANDLE（エラーコード10020）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The logical current or saved filehandle value is required by the current operation and is not set. This may be a result of a malformed COMPOUND operation (i.e., no PUTFH or PUTROOTFH before an operation that requires the current filehandle be set).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の論理または保存されたファイルハンドル値は、現在の操作に必要であり、設定されていません。これは、不正な形式のCOMPOUND操作の結果である可能性があります（つまり、現在のファイルハンドルの設定を必要とする操作の前にPUTFHまたはPUTROOTFHがありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-2-6--NFS4ERRNOTDIR-Error-Code-20">
15.1.2.6. NFS4ERR_NOTDIR (Error Code 20)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2.6. NFS4ERR_NOTDIR（エラーコード20）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current (or saved) filehandle designates an object that is not a directory for an operation in which a directory is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の（または保存された）ファイルハンドルは、ディレクトリが必要な操作のディレクトリではないオブジェクトを指定しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-2-7--NFS4ERRSTALE-Error-Code-70">
15.1.2.7. NFS4ERR_STALE (Error Code 70)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2.7. NFS4ERR_STALE（エラーコード70）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current or saved filehandle value designating an argument to the current operation is invalid. The file referred to by that filehandle no longer exists or access to it has been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の操作への引数を指定する現在または保存されているファイルハンドル値は無効です。そのファイルハンドルによって参照されているファイルが存在しないか、そのファイルへのアクセスが取り消されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-2-8--NFS4ERRSYMLINK-Error-Code-10029">
15.1.2.8. NFS4ERR_SYMLINK (Error Code 10029)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2.8. NFS4ERR_SYMLINK（エラーコード10029）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current filehandle designates a symbolic link when the current operation does not allow a symbolic link as the target.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルは、現在の操作がシンボリックリンクをターゲットとして許可しない場合にシンボリックリンクを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-2-9--NFS4ERRWRONGTYPE-Error-Code-10083">
15.1.2.9. NFS4ERR_WRONG_TYPE (Error Code 10083)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2.9. NFS4ERR_WRONG_TYPE（エラーコード10083）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current (or saved) filehandle designates an object that is of an invalid type for the current operation, and there is no more specific error (such as NFS4ERR_ISDIR or NFS4ERR_SYMLINK) that applies. Note that in NFSv4.0, such situations generally resulted in the less-specific error NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の（または保存された）ファイルハンドルは、現在の操作に対して無効なタイプのオブジェクトを指定し、適用される特定のエラー（NFS4ERR_ISDIRまたはNFS4ERR_SYMLINKなど）はありません。 NFSv4.0では、このような状況では一般に、具体性の低いエラーNFS4ERR_INVALが発生することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-3--Compound-Structure-Errors">
15.1.3. Compound Structure Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3. 複合構造エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section deals with errors that relate to the overall structure of a Compound request (by which we mean to include both COMPOUND and CB_COMPOUND), rather than to particular operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、特定の操作ではなく、複合要求の全体的な構造（COMPOUNDとCB_COMPOUNDの両方を含めることを意味します）に関連するエラーを扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are a number of basic constraints on the operations that may appear in a Compound request. Sessions add to these basic constraints by requiring a Sequence operation (either SEQUENCE or CB_SEQUENCE) at the start of the Compound.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複合リクエストに表示される操作には、いくつかの基本的な制約があります。セッションは、コンパウンドの開始時にシーケンス操作（SEQUENCEまたはCB_SEQUENCE）を要求することにより、これらの基本的な制約に追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-3-1--NFSOK-Error-code-0">
15.1.3.1. NFS_OK (Error code 0)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3.1. NFS_OK（エラーコード0）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Indicates the operation completed successfully, in that all of the constituent operations completed without error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作が正常に完了したことを示します。構成操作はすべてエラーなしで完了しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-3-2--NFS4ERRMINORVERSMISMATCH-Error-code-10021">
15.1.3.2. NFS4ERR_MINOR_VERS_MISMATCH (Error code 10021)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3.2. NFS4ERR_MINOR_VERS_MISMATCH（エラーコード10021）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The minor version specified is not one that the current listener supports. This value is returned in the overall status for the Compound but is not associated with a specific operation since the results will specify a result count of zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたマイナーバージョンは、現在のリスナーがサポートしているものではありません。この値は、Compoundの全体的なステータスで返されますが、結果はゼロの結果カウントを指定するため、特定の操作には関連付けられていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-3-3--NFS4ERRNOTONLYOP-Error-Code-10081">
15.1.3.3. NFS4ERR_NOT_ONLY_OP (Error Code 10081)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3.3. NFS4ERR_NOT_ONLY_OP（エラーコード10081）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Certain operations, which are allowed to be executed outside of a session, MUST be the only operation within a Compound whenever the Compound does not start with a Sequence operation. This error results when that constraint is not met.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション外での実行が許可されている特定の操作は、コンパウンドがシーケンス操作で開始しない場合は常に、コンパウンド内の唯一の操作でなければなりません。このエラーは、その制約が満たされていない場合に発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-3-4--NFS4ERROPILLEGAL-Error-Code-10044">
15.1.3.4. NFS4ERR_OP_ILLEGAL (Error Code 10044)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3.4. NFS4ERR_OP_ILLEGAL（エラーコード10044）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operation code is not a valid one for the current Compound procedure. The opcode in the result stream matched with this error is the ILLEGAL value, although the value that appears in the request stream may be different. Where an illegal value appears and the replier pre-parses all operations for a Compound procedure before doing any operation execution, an RPC-level XDR error may be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オペレーションコードは、現在のCompoundプロシージャでは無効です。このエラーと一致する結果ストリームのオペコードはILLEGAL値ですが、要求ストリームに表示される値は異なる場合があります。不正な値が表示され、返信者が操作を実行する前に複合手続きのすべての操作を事前に解析した場合、RPCレベルのXDRエラーが返されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-3-5--NFS4ERROPNOTINSESSION-Error-Code-10071">
15.1.3.5. NFS4ERR_OP_NOT_IN_SESSION (Error Code 10071)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3.5. NFS4ERR_OP_NOT_IN_SESSION（エラーコード10071）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most forward operations and all callback operations are only valid within the context of a session, so that the Compound request in question MUST begin with a Sequence operation. If an attempt is made to execute these operations outside the context of session, this error results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどの転送操作とすべてのコールバック操作はセッションのコンテキスト内でのみ有効であるため、問題の複合リクエストはシーケンス操作で開始する必要があります。セッションのコンテキスト外でこれらの操作を実行しようとすると、このエラーが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-3-6--NFS4ERRREPTOOBIG-Error-Code-10066">
15.1.3.6. NFS4ERR_REP_TOO_BIG (Error Code 10066)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3.6. NFS4ERR_REP_TOO_BIG（エラーコード10066）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reply to a Compound would exceed the channel&#39;s negotiated maximum response size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複合への応答は、チャネルのネゴシエートされた最大応答サイズを超えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-3-7--NFS4ERRREPTOOBIGTOCACHE-Error-Code-10067">
15.1.3.7. NFS4ERR_REP_TOO_BIG_TO_CACHE (Error Code 10067)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3.7. NFS4ERR_REP_TOO_BIG_TO_CACHE（エラーコード10067）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reply to a Compound would exceed the channel&#39;s negotiated maximum size for replies cached in the reply cache when the Sequence for the current request specifies that this request is to be cached.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のリクエストのシーケンスがこのリクエストをキャッシュするように指定している場合、Compoundへの返信は、返信キャッシュにキャッシュされる返信のチャネルのネゴシエートされた最大サイズを超えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-3-8--NFS4ERRREQTOOBIG-Error-Code-10065">
15.1.3.8. NFS4ERR_REQ_TOO_BIG (Error Code 10065)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3.8. NFS4ERR_REQ_TOO_BIG（エラーコード10065）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Compound request exceeds the channel&#39;s negotiated maximum size for requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複合リクエストは、チャネルの交渉されたリクエストの最大サイズを超えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-3-9--NFS4ERRRETRYUNCACHEDREP-Error-Code-10068">
15.1.3.9. NFS4ERR_RETRY_UNCACHED_REP (Error Code 10068)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3.9. NFS4ERR_RETRY_UNCACHED_REP（エラーコード10068）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The requester has attempted a retry of a Compound that it previously requested not be placed in the reply cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスターは、以前にリプライ・キャッシュに入れられないように要求したコンパウンドの再試行を試みました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-3-10--NFS4ERRSEQUENCEPOS-Error-Code-10064">
15.1.3.10. NFS4ERR_SEQUENCE_POS (Error Code 10064)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3.10. NFS4ERR_SEQUENCE_POS（エラーコード10064）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Sequence operation appeared in a position other than the first operation of a Compound request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス操作が、複合リクエストの最初の操作以外の場所に表示されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-3-11--NFS4ERRTOOMANYOPS-Error-Code-10070">
15.1.3.11. NFS4ERR_TOO_MANY_OPS (Error Code 10070)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3.11. NFS4ERR_TOO_MANY_OPS（エラーコード10070）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Compound request has too many operations, exceeding the count negotiated when the session was created.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複合リクエストには操作が多すぎて、セッションの作成時にネゴシエートされたカウントを超えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-3-12--NFS4ERRUNSAFECOMPOUND-Error-Code-10068">
15.1.3.12. NFS4ERR_UNSAFE_COMPOUND (Error Code 10068)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3.12. NFS4ERR_UNSAFE_COMPOUND（エラーコード10068）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client has sent a COMPOUND request with an unsafe mix of operations -- specifically, with a non-idempotent operation that changes the current filehandle and that is not followed by a GETFH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが、安全でない操作の組み合わせを含むCOMPOUND要求を送信しました。具体的には、現在のファイルハンドルを変更し、その後にGETFHを行わないべき等でない操作を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-4--File-System-Errors">
15.1.4. File System Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4. ファイルシステムエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These errors describe situations that occurred in the underlying file system implementation rather than in the protocol or any NFSv4.x feature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのエラーは、プロトコルやNFSv4.x機能ではなく、基盤となるファイルシステムの実装で発生した状況を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-4-1--NFS4ERRBADTYPE-Error-Code-10007">
15.1.4.1. NFS4ERR_BADTYPE (Error Code 10007)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4.1. NFS4ERR_BADTYPE（エラーコード10007）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attempt was made to create an object with an inappropriate type specified to CREATE. This may be because the type is undefined, because the type is not supported by the server, or because the type is not intended to be created by CREATE (such as a regular file or named attribute, for which OPEN is used to do the file creation).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATEに指定された不適切なタイプでオブジェクトを作成しようとしました。これは、タイプが未定義であるか、タイプがサーバーでサポートされていないか、またはタイプがCREATEによって作成されることを意図していないためである可能性があります（通常のファイルまたは名前付き属性など、OPENを使用してファイルを実行します）作成）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-4-2--NFS4ERRDQUOT-Error-Code-19">
15.1.4.2. NFS4ERR_DQUOT (Error Code 19)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4.2. NFS4ERR_DQUOT（エラーコード19）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Resource (quota) hard limit exceeded. The user&#39;s resource limit on the server has been exceeded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソース（割り当て量）のハード制限を超えています。サーバー上のユーザーのリソース制限を超えました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-4-3--NFS4ERREXIST-Error-Code-17">
15.1.4.3. NFS4ERR_EXIST (Error Code 17)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4.3. NFS4ERR_EXIST（エラーコード17）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A file of the specified target name (when creating, renaming, or linking) already exists.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたターゲット名のファイル（作成、名前変更、またはリンク時）が既に存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-4-4--NFS4ERRFBIG-Error-Code-27">
15.1.4.4. NFS4ERR_FBIG (Error Code 27)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4.4. NFS4ERR_FBIG（エラーコード27）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The file is too large. The operation would have caused the file to grow beyond the server&#39;s limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルが大きすぎます。この操作により、ファイルがサーバーの制限を超えました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-4-5--NFS4ERRFILEOPEN-Error-Code-10046">
15.1.4.5. NFS4ERR_FILE_OPEN (Error Code 10046)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4.5. NFS4ERR_FILE_OPEN（エラーコード10046）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operation is not allowed because a file involved in the operation is currently open. Servers may, but are not required to, disallow linking-to, removing, or renaming open files.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作に関連するファイルが現在開いているため、操作は許可されません。サーバーは、開いているファイルへのリンク、削除、または名前の変更を許可しない場合がありますが、必須ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-4-6--NFS4ERRIO-Error-Code-5">
15.1.4.6. NFS4ERR_IO (Error Code 5)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4.6. NFS4ERR_IO（エラーコード5）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Indicates that an I/O error occurred for which the file system was unable to provide recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムがリカバリを提供できなかったI / Oエラーが発生したことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-4-7--NFS4ERRMLINK-Error-Code-31">
15.1.4.7. NFS4ERR_MLINK (Error Code 31)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4.7. NFS4ERR_MLINK（エラーコード31）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The request would have caused the server&#39;s limit for the number of hard links a file may have to be exceeded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求により、サーバーがファイルのハードリンク数の制限を超えた可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-4-8--NFS4ERRNOENT-Error-Code-2">
15.1.4.8. NFS4ERR_NOENT (Error Code 2)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4.8. NFS4ERR_NOENT（エラーコード2）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Indicates no such file or directory. The file or directory name specified does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのようなファイルまたはディレクトリがないことを示します。指定されたファイルまたはディレクトリ名は存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-4-9--NFS4ERRNOSPC-Error-Code-28">
15.1.4.9. NFS4ERR_NOSPC (Error Code 28)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4.9. NFS4ERR_NOSPC（エラーコード28）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Indicates there is no space left on the device. The operation would have caused the server&#39;s file system to exceed its limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デバイスにスペースが残っていないことを示します。この操作により、サーバーのファイルシステムが制限を超えていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-4-10--NFS4ERRNOTEMPTY-Error-Code-66">
15.1.4.10. NFS4ERR_NOTEMPTY (Error Code 66)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4.10. NFS4ERR_NOTEMPTY（エラーコード66）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attempt was made to remove a directory that was not empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空でないディレクトリを削除しようとしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-4-11--NFS4ERRROFS-Error-Code-30">
15.1.4.11. NFS4ERR_ROFS (Error Code 30)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4.11. NFS4ERR_ROFS（エラーコード30）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Indicates a read-only file system. A modifying operation was attempted on a read-only file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
読み取り専用ファイルシステムを示します。読み取り専用ファイルシステムで変更操作が試行されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-4-12--NFS4ERRXDEV-Error-Code-18">
15.1.4.12. NFS4ERR_XDEV (Error Code 18)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4.12. NFS4ERR_XDEV（エラーコード18）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Indicates an attempt to do an operation, such as linking, that inappropriately crosses a boundary. This may be due to such boundaries as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リンクなど、不適切に境界を越える操作を実行しようとしたことを示します。これは、次のような境界が原因である可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o that between file systems (where the fsids are different).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルシステム間（fsidが異なる場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o that between different named attribute directories or between a named attribute directory and an ordinary directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 異なる名前付き属性ディレクトリ間、または名前付き属性ディレクトリと通常のディレクトリの間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o that between byte-ranges of a file system that the file system implementation treats as separate (for example, for space accounting purposes), and where cross-connection between the byte-ranges are not allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルシステムの実装が個別に（たとえば、スペースアカウンティングの目的で）扱うファイルシステムのバイト範囲間、およびバイト範囲間の相互接続が許可されていない場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-5--State-Management-Errors">
15.1.5. State Management Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.5. 状態管理エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These errors indicate problems with the stateid (or one of the stateids) passed to a given operation. This includes situations in which the stateid is invalid as well as situations in which the stateid is valid but designates locking state that has been revoked. Depending on the operation, the stateid when valid may designate opens, byte-range locks, file or directory delegations, layouts, or device maps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのエラーは、特定の操作に渡された状態ID（または状態IDの1つ）に問題があることを示しています。これには、stateidが無効である状況、およびstateidは有効であるが取り消されたロック状態を指定する状況が含まれます。操作に応じて、stateidが有効な場合は、オープン、バイト範囲ロック、ファイルまたはディレクトリの委任、レイアウト、またはデバイスマップを指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-5-1--NFS4ERRADMINREVOKED-Error-Code-10047">
15.1.5.1. NFS4ERR_ADMIN_REVOKED (Error Code 10047)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.5.1. NFS4ERR_ADMIN_REVOKED（エラーコード10047）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A stateid designates locking state of any type that has been revoked due to administrative interaction, possibly while the lease is valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateidは、おそらくリースが有効な間に、管理上の相互作用により取り消された任意のタイプのロック状態を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-5-2--NFS4ERRBADSTATEID-Error-Code-10026">
15.1.5.2. NFS4ERR_BAD_STATEID (Error Code 10026)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.5.2. NFS4ERR_BAD_STATEID（エラーコード10026）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A stateid does not properly designate any valid state. See Sections 8.2.4 and 8.2.3 for a discussion of how stateids are validated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateidは有効な状態を適切に指定しません。ステートIDが検証される方法については、セクション8.2.4および8.2.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-5-3--NFS4ERRDELEGREVOKED-Error-Code-10087">
15.1.5.3. NFS4ERR_DELEG_REVOKED (Error Code 10087)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.5.3. NFS4ERR_DELEG_REVOKED（エラーコード10087）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A stateid designates recallable locking state of any type (delegation or layout) that has been revoked due to the failure of the client to return the lock when it was recalled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateidは、クライアントがロックを再呼び出ししたときにロックを返せなかったために取り消された、任意のタイプ（委任またはレイアウト）の再呼び出し可能なロック状態を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-5-4--NFS4ERREXPIRED-Error-Code-10011">
15.1.5.4. NFS4ERR_EXPIRED (Error Code 10011)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.5.4. NFS4ERR_EXPIRED（エラーコード10011）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A stateid designates locking state of any type that has been revoked due to expiration of the client&#39;s lease, either immediately upon lease expiration, or following a later request for a conflicting lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateidは、クライアントのリースの有効期限が切れたために、リースの有効期限が切れた直後に、または後で競合するロックを要求した後に取り消された、あらゆるタイプのロック状態を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-5-5--NFS4ERROLDSTATEID-Error-Code-10024">
15.1.5.5. NFS4ERR_OLD_STATEID (Error Code 10024)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.5.5. NFS4ERR_OLD_STATEID（エラーコード10024）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A stateid with a non-zero seqid value does match the current seqid for the state designated by the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ゼロ以外のseqid値を持つstateidは、ユーザーが指定した状態の現在のseqidと一致しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-6--Security-Errors">
15.1.6. Security Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.6. セキュリティエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These are the various permission-related errors in NFSv4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらは、NFSv4.1のさまざまな権限関連のエラーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-6-1--NFS4ERRACCESS-Error-Code-13">
15.1.6.1. NFS4ERR_ACCESS (Error Code 13)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.6.1. NFS4ERR_ACCESS（エラーコード13）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Indicates permission denied. The caller does not have the correct permission to perform the requested operation. Contrast this with NFS4ERR_PERM (Section 15.1.6.2), which restricts itself to owner or privileged-user permission failures, and NFS4ERR_WRONG_CRED (Section 15.1.6.4), which deals with appropriate permission to delete or modify transient objects based on the credentials of the user that created them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
許可が拒否されたことを示します。呼び出し元には、要求された操作を実行するための適切な権限がありません。これを、所有者または特権ユーザーのアクセス許可の失敗に制限するNFS4ERR_PERM（セクション15.1.6.2）、およびユーザーの資格情報に基づいて一時オブジェクトを削除または変更する適切なアクセス許可を扱うNFS4ERR_WRONG_CRED（セクション15.1.6.4）と対照的です。それらを作成しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-6-2--NFS4ERRPERM-Error-Code-1">
15.1.6.2. NFS4ERR_PERM (Error Code 1)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.6.2. NFS4ERR_PERM（エラーコード1）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Indicates requester is not the owner. The operation was not allowed because the caller is neither a privileged user (root) nor the owner of the target of the operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求者が所有者ではないことを示します。呼び出し元が特権ユーザー（root）でも操作のターゲットの所有者でもないため、操作は許可されませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-6-3--NFS4ERRWRONGSEC-Error-Code-10016">
15.1.6.3. NFS4ERR_WRONGSEC (Error Code 10016)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.6.3. NFS4ERR_WRONGSEC（エラーコード10016）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Indicates that the security mechanism being used by the client for the operation does not match the server&#39;s security policy. The client should change the security mechanism being used and re-send the operation (but not with the same slot ID and sequence ID; one or both MUST be different on the re-send). SECINFO and SECINFO_NO_NAME can be used to determine the appropriate mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが操作に使用しているセキュリティメカニズムがサーバーのセキュリティポリシーと一致しないことを示します。クライアントは、使用されているセキュリティメカニズムを変更して、操作を再送信する必要があります（ただし、同じスロットIDとシーケンスIDを使用しないでください。再送信では、一方または両方が異なる必要があります）。 SECINFOおよびSECINFO_NO_NAMEを使用して、適切なメカニズムを決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-6-4--NFS4ERRWRONGCRED-Error-Code-10082">
15.1.6.4. NFS4ERR_WRONG_CRED (Error Code 10082)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.6.4. NFS4ERR_WRONG_CRED（エラーコード10082）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An operation that manipulates state was attempted by a principal that was not allowed to modify that piece of state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態を操作する操作が、その状態の一部を変更することが許可されていないプリンシパルによって試行されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-7--Name-Errors">
15.1.7. Name Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.7. 名前エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Names in NFSv4 are UTF-8 strings. When the strings are not valid UTF-8 or are of length zero, the error NFS4ERR_INVAL results. Besides this, there are a number of other errors to indicate specific problems with names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4の名前はUTF-8文字列です。文字列が有効なUTF-8でないか、長さがゼロの場合、エラーNFS4ERR_INVALが発生します。これ以外にも、名前に関する特定の問題を示す他の多くのエラーがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-7-1--NFS4ERRBADCHAR-Error-Code-10040">
15.1.7.1. NFS4ERR_BADCHAR (Error Code 10040)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.7.1. NFS4ERR_BADCHAR（エラーコード10040）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A UTF-8 string contains a character that is not supported by the server in the context in which it being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UTF-8文字列には、使用されているコンテキストでサーバーによってサポートされていない文字が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-7-2--NFS4ERRBADNAME-Error-Code-10041">
15.1.7.2. NFS4ERR_BADNAME (Error Code 10041)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.7.2. NFS4ERR_BADNAME（エラーコード10041）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A name string in a request consisted of valid UTF-8 characters supported by the server, but the name is not supported by the server as a valid name for the current operation. An example might be creating a file or directory named &#34;..&#34; on a server whose file system uses that name for links to parent directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスト内の名前文字列はサーバーでサポートされている有効なUTF-8文字で構成されていますが、サーバーでは現在の操作の有効な名前としてサポートされていません。例としては、ファイルシステムが親ディレクトリへのリンクにその名前を使用するサーバー上に「..」という名前のファイルまたはディレクトリを作成する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-7-3--NFS4ERRNAMETOOLONG-Error-Code-63">
15.1.7.3. NFS4ERR_NAMETOOLONG (Error Code 63)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.7.3. NFS4ERR_NAMETOOLONG（エラーコード63）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Returned when the filename in an operation exceeds the server&#39;s implementation limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作のファイル名がサーバーの実装制限を超えたときに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-8--Locking-Errors">
15.1.8. Locking Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.8. エラーのロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section deals with errors related to locking, both as to share reservations and byte-range locking. It does not deal with errors specific to the process of reclaiming locks. Those are dealt with in Section 15.1.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、予約の共有とバイト範囲ロックの両方に関して、ロックに関連するエラーを扱います。ロックを再利用するプロセスに固有のエラーは処理しません。これらについては、セクション15.1.9で扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-8-1--NFS4ERRBADRANGE-Error-Code-10042">
15.1.8.1. NFS4ERR_BAD_RANGE (Error Code 10042)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.8.1. NFS4ERR_BAD_RANGE（エラーコード10042）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The byte-range of a LOCK, LOCKT, or LOCKU operation is not allowed by the server. For example, this error results when a server that only supports 32-bit ranges receives a range that cannot be handled by that server. (See Section 18.10.3.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK、LOCKT、またはLOCKU操作のバイト範囲は、サーバーで許可されていません。たとえば、このエラーは、32ビットの範囲のみをサポートするサーバーが、そのサーバーでは処理できない範囲を受け取った場合に発生します。 （18.10.3項を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-8-2--NFS4ERRDEADLOCK-Error-Code-10045">
15.1.8.2. NFS4ERR_DEADLOCK (Error Code 10045)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.8.2. NFS4ERR_DEADLOCK（エラーコード10045）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server has been able to determine a byte-range locking deadlock condition for a READW_LT or WRITEW_LT LOCK operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、READW_LTまたはWRITEW_LT LOCK操作のバイト範囲ロックデッドロック状態を判別できました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-8-3--NFS4ERRDENIED-Error-Code-10010">
15.1.8.3. NFS4ERR_DENIED (Error Code 10010)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.8.3. NFS4ERR_DENIED（エラーコード10010）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attempt to lock a file is denied. Since this may be a temporary condition, the client is encouraged to re-send the lock request (but not with the same slot ID and sequence ID; one or both MUST be different on the re-send) until the lock is accepted. See Section 9.6 for a discussion of the re-send.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルをロックする試みは拒否されます。これは一時的な状態である可能性があるため、ロックが受け入れられるまで、クライアントはロック要求を再送信することをお勧めします（ただし、同じスロットIDとシーケンスIDではありません。再送信では一方または両方が異なる必要があります）。再送信の説明については、セクション9.6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-8-4--NFS4ERRLOCKED-Error-Code-10012">
15.1.8.4. NFS4ERR_LOCKED (Error Code 10012)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.8.4. NFS4ERR_LOCKED（エラーコード10012）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A READ or WRITE operation was attempted on a file where there was a conflict between the I/O and an existing lock:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I / Oと既存のロックの間に競合があったファイルに対して、READまたはWRITE操作が試行されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There is a share reservation inconsistent with the I/O being done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 実行中のI / Oと矛盾する共有予約があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The range to be read or written intersects an existing mandatory byte-range lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 読み取りまたは書き込みの範囲が、既存の必須のバイト範囲ロックと交差しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-8-5--NFS4ERRLOCKSHELD-Error-Code-10037">
15.1.8.5. NFS4ERR_LOCKS_HELD (Error Code 10037)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.8.5. NFS4ERR_LOCKS_HELD（エラーコード10037）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An operation was prevented by the unexpected presence of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予期しないロックの存在によって操作が妨げられました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-8-6--NFS4ERRLOCKNOTSUPP-Error-Code-10043">
15.1.8.6. NFS4ERR_LOCK_NOTSUPP (Error Code 10043)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.8.6. NFS4ERR_LOCK_NOTSUPP（エラーコード10043）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A LOCK operation was attempted that would require the upgrade or downgrade of a byte-range lock range already held by the owner, and the server does not support atomic upgrade or downgrade of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者がすでに保持しているバイト範囲ロック範囲のアップグレードまたはダウングレードを必要とするLOCK操作が試行されましたが、サーバーはロックのアトミックアップグレードまたはダウングレードをサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-8-7--NFS4ERRLOCKRANGE-Error-Code-10028">
15.1.8.7. NFS4ERR_LOCK_RANGE (Error Code 10028)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.8.7. NFS4ERR_LOCK_RANGE（エラーコード10028）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A LOCK operation is operating on a range that overlaps in part a currently held byte-range lock for the current lock-owner and does not precisely match a single such byte-range lock where the server does not support this type of request, and thus does not implement POSIX locking semantics [24]. See Sections 18.10.4, 18.11.4, and 18.12.4 for a discussion of how this applies to LOCK, LOCKT, and LOCKU respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
LOCK操作は、現在ロック所有者に対して現在保持されているバイト範囲ロックと部分的に重複し、サーバーがこのタイプの要求をサポートしていない単一のそのようなバイト範囲ロックと正確に一致しない範囲で動作しているため、 POSIXロックセマンティクスを実装していません[24]。これがLOCK、LOCKT、LOCKUにそれぞれどのように適用されるかについては、セクション18.10.4、18.11.4、および18.12.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-8-8--NFS4ERROPENMODE-Error-Code-10038">
15.1.8.8. NFS4ERR_OPENMODE (Error Code 10038)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.8.8. NFS4ERR_OPENMODE（エラーコード10038）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client attempted a READ, WRITE, LOCK, or other operation not sanctioned by the stateid passed (e.g., writing to a file opened for read-only access).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、渡されたstateidによって許可されていない読み取り、書き込み、ロック、またはその他の操作（たとえば、読み取り専用アクセス用に開かれたファイルへの書き込み）を試みました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-8-9--NFS4ERRSHAREDENIED-Error-Code-10015">
15.1.8.9. NFS4ERR_SHARE_DENIED (Error Code 10015)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.8.9. NFS4ERR_SHARE_DENIED（エラーコード10015）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attempt to OPEN a file with a share reservation has failed because of a share conflict.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有の競合のため、共有予約を使用してファイルを開く試みが失敗しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-9--Reclaim-Errors">
15.1.9. Reclaim Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.9. エラーを取り戻す
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These errors relate to the process of reclaiming locks after a server restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのエラーは、サーバーの再起動後にロックを再利用するプロセスに関連しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-9-1--NFS4ERRCOMPLETEALREADY-Error-Code-10054">
15.1.9.1. NFS4ERR_COMPLETE_ALREADY (Error Code 10054)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.9.1. NFS4ERR_COMPLETE_ALREADY（エラーコード10054）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client previously sent a successful RECLAIM_COMPLETE operation. An additional RECLAIM_COMPLETE operation is not necessary and results in this error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは以前に正常なRECLAIM_COMPLETE操作を送信しました。追加のRECLAIM_COMPLETE操作は不要であり、このエラーが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-9-2--NFS4ERRGRACE-Error-Code-10013">
15.1.9.2. NFS4ERR_GRACE (Error Code 10013)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.9.2. NFS4ERR_GRACE（エラーコード10013）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server was in its recovery or grace period. The locking request was not a reclaim request and so could not be granted during that period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは回復または猶予期間にありました。ロック要求は再利用要求ではなかったため、その期間中は付与できませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-9-3--NFS4ERRNOGRACE-Error-Code-10033">
15.1.9.3. NFS4ERR_NO_GRACE (Error Code 10033)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.9.3. NFS4ERR_NO_GRACE（エラーコード10033）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reclaim of client state was attempted in circumstances in which the server cannot guarantee that conflicting state has not been provided to another client. This can occur because the reclaim has been done outside of the grace period of the server, after the client has done a RECLAIM_COMPLETE operation, or because previous operations have created a situation in which the server is not able to determine that a reclaim-interfering edge condition does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが競合状態が別のクライアントに提供されていないことを保証できない状況で、クライアント状態の再利用が試みられました。これは、クライアントがRECLAIM_COMPLETE操作を実行した後、サーバーの猶予期間外に再生が行われたか、以前の操作によってサーバーが再生の干渉エッジを判断できない状況が発生したために発生する可能性があります。状態は存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-9-4--NFS4ERRRECLAIMBAD-Error-Code-10034">
15.1.9.4. NFS4ERR_RECLAIM_BAD (Error Code 10034)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.9.4. NFS4ERR_RECLAIM_BAD（エラーコード10034）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The server has determined that a reclaim attempted by the client is not valid, i.e. the lock specified as being reclaimed could not possibly have existed before the server restart. A server is not obliged to make this determination and will typically rely on the client to only reclaim locks that the client was granted prior to restart. However, when a server does have reliable information to enable it make this determination, this error indicates that the reclaim has been rejected as invalid. This is as opposed to the error NFS4ERR_RECLAIM_CONFLICT (see Section 15.1.9.5) where the server can only determine that there has been an invalid reclaim, but cannot determine which request is invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーは、クライアントが試みた再利用が無効であると判断しました。つまり、再利用として指定されたロックがサーバーの再起動前に存在していなかった可能性があります。サーバーはこの決定を行う義務はなく、通常、クライアントに依存して、再起動前にクライアントに付与されたロックのみを再利用します。ただし、サーバーがこの決定を行うための信頼できる情報を持っている場合、このエラーは再利用が無効として拒否されたことを示します。これは、NFS4ERR_RECLAIM_CONFLICT（セクション15.1.9.5を参照）のエラーとは対照的です。この場合、サーバーは無効な再利用があったことのみを判別でき、どの要求が無効であるか判別できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-9-5--NFS4ERRRECLAIMCONFLICT-Error-Code-10035">
15.1.9.5. NFS4ERR_RECLAIM_CONFLICT (Error Code 10035)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.9.5. NFS4ERR_RECLAIM_CONFLICT（エラーコード10035）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reclaim attempted by the client has encountered a conflict and cannot be satisfied. Potentially indicates a misbehaving client, although not necessarily the one receiving the error. The misbehavior might be on the part of the client that established the lock with which this client conflicted. See also Section 15.1.9.4 for the related error, NFS4ERR_RECLAIM_BAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが試みた再利用で競合が発生したため、満足できません。クライアントが必ずしもエラーを受け取っているとは限りませんが、クライアントの動作に問題がある可能性があります。不正な動作は、クライアントが競合したロックを確立したクライアント側にある可能性があります。関連するエラーNFS4ERR_RECLAIM_BADについては、セクション15.1.9.4も参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-10--pNFS-Errors">
15.1.10. pNFS Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.10. pNFSエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section deals with pNFS-related errors including those that are associated with using NFSv4.1 to communicate with a data server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、NFSv4.1を使用してデータサーバーと通信することに関連するエラーを含む、pNFS関連のエラーを扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-10-1--NFS4ERRBADIOMODE-Error-Code-10049">
15.1.10.1. NFS4ERR_BADIOMODE (Error Code 10049)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.10.1. NFS4ERR_BADIOMODE（エラーコード10049）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An invalid or inappropriate layout iomode was specified. For example an inappropriate layout iomode, suppose a client&#39;s LAYOUTGET operation specified an iomode of LAYOUTIOMODE4_RW, and the server is neither able nor willing to let the client send write requests to data servers; the server can reply with NFS4ERR_BADIOMODE. The client would then send another LAYOUTGET with an iomode of LAYOUTIOMODE4_READ.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
無効または不適切なレイアウトiomodeが指定されました。たとえば、不適切なレイアウトiomodeの場合、クライアントのLAYOUTGET操作でIOmodeにLAYOUTIOMODE4_RWが指定されていて、サーバーがクライアントにデータサーバーへの書き込み要求の送信を許可したり、許可したりしないとします。サーバーはNFS4ERR_BADIOMODEで応答できます。次に、クライアントはiomodeがLAYOUTIOMODE4_READの別のLAYOUTGETを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-10-2--NFS4ERRBADLAYOUT-Error-Code-10050">
15.1.10.2. NFS4ERR_BADLAYOUT (Error Code 10050)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.10.2. NFS4ERR_BADLAYOUT（エラーコード10050）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layout specified is invalid in some way. For LAYOUTCOMMIT, this indicates that the specified layout is not held by the client or is not of mode LAYOUTIOMODE4_RW. For LAYOUTGET, it indicates that a layout matching the client&#39;s specification as to minimum length cannot be granted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたレイアウトは何らかの理由で無効です。 LAYOUTCOMMITの場合、これは指定されたレイアウトがクライアントによって保持されていないか、モードがLAYOUTIOMODE4_RWではないことを示します。 LAYOUTGETの場合、最小長に関するクライアントの仕様に一致するレイアウトを許可できないことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-10-3--NFS4ERRLAYOUTTRYLATER-Error-Code-10058">
15.1.10.3. NFS4ERR_LAYOUTTRYLATER (Error Code 10058)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.10.3. NFS4ERR_LAYOUTTRYLATER（エラーコード10058）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Layouts are temporarily unavailable for the file. The client should re-send later (but not with the same slot ID and sequence ID; one or both MUST be different on the re-send).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルのレイアウトは一時的に利用できません。クライアントは後で再送信する必要があります（ただし、同じスロットIDとシーケンスIDを使用しないでください。再送信では一方または両方が異なる必要があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-10-4--NFS4ERRLAYOUTUNAVAILABLE-Error-Code-10059">
15.1.10.4. NFS4ERR_LAYOUTUNAVAILABLE (Error Code 10059)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.10.4. NFS4ERR_LAYOUTUNAVAILABLE（エラーコード10059）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Returned when layouts are not available for the current file system or the particular specified file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルシステムまたは指定された特定のファイルでレイアウトが使用できない場合に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-10-5--NFS4ERRNOMATCHINGLAYOUT-Error-Code-10060">
15.1.10.5. NFS4ERR_NOMATCHING_LAYOUT (Error Code 10060)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.10.5. NFS4ERR_NOMATCHING_LAYOUT（エラーコード10060）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Returned when layouts are recalled and the client has no layouts matching the specification of the layouts being recalled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトが再呼び出しされ、クライアントが再呼び出しされているレイアウトの仕様に一致するレイアウトを持っていない場合に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-10-6--NFS4ERRPNFSIOHOLE-Error-Code-10075">
15.1.10.6. NFS4ERR_PNFS_IO_HOLE (Error Code 10075)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.10.6. NFS4ERR_PNFS_IO_HOLE（エラーコード10075）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pNFS client has attempted to read from or write to an illegal hole of a file of a data server that is using sparse packing. See Section 13.4.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSクライアントが、スパースパッキングを使用しているデータサーバーのファイルの不正なホールから読み取りまたは書き込みを試みました。セクション13.4.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-10-7--NFS4ERRPNFSNOLAYOUT-Error-Code-10080">
15.1.10.7. NFS4ERR_PNFS_NO_LAYOUT (Error Code 10080)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.10.7. NFS4ERR_PNFS_NO_LAYOUT（エラーコード10080）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pNFS client has attempted to read from or write to a file (using a request to a data server) without holding a valid layout. This includes the case where the client had a layout, but the iomode does not allow a WRITE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSクライアントは、有効なレイアウトを保持せずに（データサーバーへの要求を使用して）ファイルの読み取りまたは書き込みを試みました。これには、クライアントにレイアウトがあったが、iomodeが書き込みを許可しない場合も含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-10-8--NFS4ERRRETURNCONFLICT-Error-Code-10086">
15.1.10.8. NFS4ERR_RETURNCONFLICT (Error Code 10086)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.10.8. NFS4ERR_RETURNCONFLICT（エラーコード10086）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A layout is unavailable due to an attempt to perform the LAYOUTGET before a pending LAYOUTRETURN on the file has been received. See Section 12.5.5.2.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルの保留中のLAYOUTRETURNを受信する前にLAYOUTGETを実行しようとしたため、レイアウトを使用できません。セクション12.5.5.2.1.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-10-9--NFS4ERRUNKNOWNLAYOUTTYPE-Error-Code-10062">
15.1.10.9. NFS4ERR_UNKNOWN_LAYOUTTYPE (Error Code 10062)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.10.9. NFS4ERR_UNKNOWN_LAYOUTTYPE（エラーコード10062）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client has specified a layout type that is not supported by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが、サーバーでサポートされていないレイアウトタイプを指定しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-11--Session-Use-Errors">
15.1.11. Session Use Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.11. セッション使用エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section deals with errors encountered when using sessions, that is, errors encountered when a request uses a Sequence (i.e., either SEQUENCE or CB_SEQUENCE) operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、セッションの使用時に発生するエラー、つまり、リクエストがシーケンス（つまり、SEQUENCEまたはCB_SEQUENCE）操作を使用するときに発生するエラーについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-11-1--NFS4ERRBADSESSION-Error-Code-10052">
15.1.11.1. NFS4ERR_BADSESSION (Error Code 10052)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.11.1. NFS4ERR_BADSESSION（エラーコード10052）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The specified session ID is unknown to the server to which the operation is addressed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたセッションIDは、操作の宛先であるサーバーには不明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-11-2--NFS4ERRBADSLOT-Error-Code-10053">
15.1.11.2. NFS4ERR_BADSLOT (Error Code 10053)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.11.2. NFS4ERR_BADSLOT（エラーコード10053）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The requester sent a Sequence operation that attempted to use a slot the replier does not have in its slot table. It is possible the slot may have been retired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスタが、リプライアがスロットテーブルにないスロットを使用しようとしたシーケンスオペレーションを送信しました。スロットが廃止された可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-11-3--NFS4ERRBADHIGHSLOT-Error-Code-10077">
15.1.11.3. NFS4ERR_BAD_HIGH_SLOT (Error Code 10077)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.11.3. NFS4ERR_BAD_HIGH_SLOT（エラーコード10077）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The highest_slot argument in a Sequence operation exceeds the replier&#39;s enforced highest_slotid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sequenceオペレーションのhighest_slot引数が、回答者の強制されたhighest_slotidを超えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-11-4--NFS4ERRCBPATHDOWN-Error-Code-10048">
15.1.11.4. NFS4ERR_CB_PATH_DOWN (Error Code 10048)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.11.4. NFS4ERR_CB_PATH_DOWN（エラーコード10048）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is a problem contacting the client via the callback path. The function of this error has been mostly superseded by the use of status flags in the reply to the SEQUENCE operation (see Section 18.46).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コールバックパスを介したクライアントへの接続に問題があります。このエラーの機能は、SEQUENCE操作への応答でステータスフラグを使用することによってほとんど取って代わられました（セクション18.46を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-11-5--NFS4ERRDEADSESSION-Error-Code-10078">
15.1.11.5. NFS4ERR_DEADSESSION (Error Code 10078)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.11.5. NFS4ERR_DEADSESSION（エラーコード10078）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The specified session is a persistent session that is dead and does not accept new requests or perform new operations on existing requests (in the case in which a request was partially executed before server restart).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたセッションは永続的なセッションであり、停止していて、新しい要求を受け入れたり、既存の要求に対して新しい操作を実行したりしません（サーバーの再起動前に要求が部分的に実行された場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-11-6--NFS4ERRCONNNOTBOUNDTOSESSION-Error-Code-10055">
15.1.11.6. NFS4ERR_CONN_NOT_BOUND_TO_SESSION (Error Code 10055)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.11.6. NFS4ERR_CONN_NOT_BOUND_TO_SESSION（エラーコード10055）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Sequence operation was sent on a connection that has not been associated with the specified session, where the client specified that connection association was to be enforced with SP4_MACH_CRED or SP4_SSV state protection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス操作が、指定されたセッションに関連付けられていない接続で送信されました。クライアントは、接続の関連付けをSP4_MACH_CREDまたはSP4_SSV状態保護で実施することを指定しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-11-7--NFS4ERRSEQFALSERETRY-Error-Code-10076">
15.1.11.7. NFS4ERR_SEQ_FALSE_RETRY (Error Code 10076)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.11.7. NFS4ERR_SEQ_FALSE_RETRY（エラーコード10076）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The requester sent a Sequence operation with a slot ID and sequence ID that are in the reply cache, but the replier has detected that the retried request is not the same as the original request. See Section 2.10.6.1.3.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスターは、応答キャッシュにあるスロットIDとシーケンスIDを使用してシーケンス操作を送信しましたが、再試行された要求が元の要求と同じでないことをリプライアーが検出しました。セクション2.10.6.1.3.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-11-8--NFS4ERRSEQMISORDERED-Error-Code-10063">
15.1.11.8. NFS4ERR_SEQ_MISORDERED (Error Code 10063)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.11.8. NFS4ERR_SEQ_MISORDERED（エラーコード10063）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The requester sent a Sequence operation with an invalid sequence ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスターが無効なシーケンスIDのシーケンス操作を送信しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-12--Session-Management-Errors">
15.1.12. Session Management Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.12. セッション管理エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section deals with errors associated with requests used in session management.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、セッション管理で使用されるリクエストに関連するエラーを扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-12-1--NFS4ERRBACKCHANBUSY-Error-Code-10057">
15.1.12.1. NFS4ERR_BACK_CHAN_BUSY (Error Code 10057)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.12.1. NFS4ERR_BACK_CHAN_BUSY（エラーコード10057）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attempt was made to destroy a session when the session cannot be destroyed because the server has callback requests outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーに未解決のコールバック要求があるためにセッションを破棄できないときに、セッションを破棄しようとしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-12-2--NFS4ERRBADSESSIONDIGEST-Error-Code-10051">
15.1.12.2. NFS4ERR_BAD_SESSION_DIGEST (Error Code 10051)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.12.2. NFS4ERR_BAD_SESSION_DIGEST（エラーコード10051）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The digest used in a SET_SSV request is not valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SET_SSV要求で使用されるダイジェストは無効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-13--Client-Management-Errors">
15.1.13. Client Management Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.13. クライアント管理エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section deals with errors associated with requests used to create and manage client IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、クライアントIDの作成と管理に使用されるリクエストに関連するエラーについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-13-1--NFS4ERRCLIENTIDBUSY-Error-Code-10074">
15.1.13.1. NFS4ERR_CLIENTID_BUSY (Error Code 10074)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.13.1. NFS4ERR_CLIENTID_BUSY（エラーコード10074）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DESTROY_CLIENTID operation has found there are sessions and/or unexpired state associated with the client ID to be destroyed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESTROY_CLIENTID操作により、破棄するクライアントIDに関連付けられたセッションまたは期限切れでない状態、あるいはその両方が存在することがわかりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-13-2--NFS4ERRCLIDINUSE-Error-Code-10017">
15.1.13.2. NFS4ERR_CLID_INUSE (Error Code 10017)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.13.2. NFS4ERR_CLID_INUSE（エラーコード10017）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While processing an EXCHANGE_ID operation, the server was presented with a co_ownerid field that matches an existing client with valid leased state, but the principal sending the EXCHANGE_ID operation differs from the principal that established the existing client. This indicates a collision (most likely due to chance) between clients. The client should recover by changing the co_ownerid and re-sending EXCHANGE_ID (but not with the same slot ID and sequence ID; one or both MUST be different on the re-send).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCHANGE_ID操作の処理中に、サーバーは、有効なリース状態の既存のクライアントと一致するco_owneridフィールドを提示されましたが、EXCHANGE_ID操作を送信するプリンシパルは、既存のクライアントを確立したプリンシパルとは異なります。これは、クライアント間の衝突（おそらく偶然による）を示しています。クライアントは、co_owneridを変更してEXCHANGE_IDを再送信することで回復する必要があります（ただし、同じスロットIDとシーケンスIDを使用することはできません。再送信では一方または両方が異なる必要があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-13-3--NFS4ERRENCRALGUNSUPP-Error-Code-10079">
15.1.13.3. NFS4ERR_ENCR_ALG_UNSUPP (Error Code 10079)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.13.3. NFS4ERR_ENCR_ALG_UNSUPP（エラーコード10079）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An EXCHANGE_ID was sent that specified state protection via SSV, and where the set of encryption algorithms presented by the client did not include any supported by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCHANGE_IDは、SSVを介して指定された状態保護を送信され、クライアントによって提示された暗号化アルゴリズムのセットには、サーバーによってサポートされているものは含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-13-4--NFS4ERRHASHALGUNSUPP-Error-Code-10072">
15.1.13.4. NFS4ERR_HASH_ALG_UNSUPP (Error Code 10072)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.13.4. NFS4ERR_HASH_ALG_UNSUPP（エラーコード10072）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An EXCHANGE_ID was sent that specified state protection via SSV, and where the set of hashing algorithms presented by the client did not include any supported by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCHANGE_IDは、SSVを介して指定された状態保護を送信され、クライアントによって提示されたハッシュアルゴリズムのセットには、サーバーによってサポートされているものは含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-13-5--NFS4ERRSTALECLIENTID-Error-Code-10022">
15.1.13.5. NFS4ERR_STALE_CLIENTID (Error Code 10022)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.13.5. NFS4ERR_STALE_CLIENTID（エラーコード10022）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A client ID not recognized by the server was passed to an operation. Note that unlike the case of NFSv4.0, client IDs are not passed explicitly to the server in ordinary locking operations and cannot result in this error. Instead, when there is a server restart, it is first manifested through an error on the associated session, and the staleness of the client ID is detected when trying to associate a client ID with a new session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーによって認識されないクライアントIDが操作に渡されました。 NFSv4.0の場合とは異なり、クライアントIDは通常のロック操作では明示的にサーバーに渡されないため、このエラーが発生することはありません。代わりに、サーバーの再起動があると、関連付けられたセッションのエラーによって最初に明らかになり、クライアントIDを新しいセッションに関連付けようとすると、クライアントIDの古さが検出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-14--Delegation-Errors">
15.1.14. Delegation Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.14. 委任エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section deals with errors associated with requesting and returning delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、委任の要求と返却に関連するエラーについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-14-1--NFS4ERRDELEGALREADYWANTED-Error-Code-10056">
15.1.14.1. NFS4ERR_DELEG_ALREADY_WANTED (Error Code 10056)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.14.1. NFS4ERR_DELEG_ALREADY_WANTED（エラーコード10056）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client has requested a delegation when it had already registered that it wants that same delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、同じ委任が必要であることをすでに登録しているときに、委任を要求しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-14-2--NFS4ERRDIRDELEGUNAVAIL-Error-Code-10084">
15.1.14.2. NFS4ERR_DIRDELEG_UNAVAIL (Error Code 10084)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.14.2. NFS4ERR_DIRDELEG_UNAVAIL（エラーコード10084）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This error is returned when the server is unable or unwilling to provide a requested directory delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエラーは、サーバーが要求されたディレクトリ委任を提供できない、または提供したくない場合に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-14-3--NFS4ERRRECALLCONFLICT-Error-Code-10061">
15.1.14.3. NFS4ERR_RECALLCONFLICT (Error Code 10061)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.14.3. NFS4ERR_RECALLCONFLICT（エラーコード10061）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A recallable object (i.e., a layout or delegation) is unavailable due to a conflicting recall operation that is currently in progress for that object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再呼び出し可能なオブジェクト（つまり、レイアウトまたは委任）は、そのオブジェクトに対して現在進行中の競合する再呼び出し操作が原因で使用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-14-4--NFS4ERRREJECTDELEG-Error-Code-10085">
15.1.14.4. NFS4ERR_REJECT_DELEG (Error Code 10085)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.14.4. NFS4ERR_REJECT_DELEG（エラーコード10085）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The callback operation invoked to deal with a new delegation has rejected it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい委任を処理するために呼び出されたコールバック操作が拒否しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-15--Attribute-Handling-Errors">
15.1.15. Attribute Handling Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.15. 属性処理エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section deals with errors specific to attribute handling within NFSv4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、NFSv4内の属性処理に固有のエラーを扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-15-1--NFS4ERRATTRNOTSUPP-Error-Code-10032">
15.1.15.1. NFS4ERR_ATTRNOTSUPP (Error Code 10032)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.15.1. NFS4ERR_ATTRNOTSUPP（エラーコード10032）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attribute specified is not supported by the server. This error MUST NOT be returned by the GETATTR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定された属性はサーバーでサポートされていません。このエラーは、GETATTR操作によって返されてはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-15-2--NFS4ERRBADOWNER-Error-Code-10039">
15.1.15.2. NFS4ERR_BADOWNER (Error Code 10039)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.15.2. NFS4ERR_BADOWNER（エラーコード10039）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This error is returned when an owner or owner_group attribute value or the who field of an ACE within an ACL attribute value cannot be translated to a local representation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエラーは、ownerまたはowner_group属性値、またはACL属性値内のACEのwhoフィールドをローカル表現に変換できない場合に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-15-3--NFS4ERRNOTSAME-Error-Code-10027">
15.1.15.3. NFS4ERR_NOT_SAME (Error Code 10027)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.15.3. NFS4ERR_NOT_SAME（エラーコード10027）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This error is returned by the VERIFY operation to signify that the attributes compared were not the same as those provided in the client&#39;s request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエラーは、VERIFY操作によって返され、比較された属性がクライアントのリクエストで提供されたものと同じではなかったことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-15-4--NFS4ERRSAME-Error-Code-10009">
15.1.15.4. NFS4ERR_SAME (Error Code 10009)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.15.4. NFS4ERR_SAME（エラーコード10009）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This error is returned by the NVERIFY operation to signify that the attributes compared were the same as those provided in the client&#39;s request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエラーはNVERIFY操作によって返され、比較された属性がクライアントのリクエストで提供されたものと同じであることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-16--Obsoleted-Errors">
15.1.16. Obsoleted Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.16. 廃止されたエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These errors MUST NOT be generated by any NFSv4.1 operation. This can be for a number of reasons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのエラーは、NFSv4.1操作によって生成されてはなりません。これにはいくつかの理由が考えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The function provided by the error has been superseded by one of the status bits returned by the SEQUENCE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o エラーによって提供された機能は、SEQUENCE操作によって返されたステータスビットの1つに取って代わられました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The new session structure and associated change in locking have made the error unnecessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 新しいセッション構造とそれに関連するロックの変更により、エラーは不要になりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There has been a restructuring of some errors for NFSv4.1 that resulted in the elimination of certain errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1の一部のエラーが再構成され、特定のエラーが解消されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-16-1--NFS4ERRBADSEQID-Error-Code-10026">
15.1.16.1. NFS4ERR_BAD_SEQID (Error Code 10026)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.16.1. NFS4ERR_BAD_SEQID（エラーコード10026）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sequence number (seqid) in a locking request is neither the next expected number or the last number processed. These seqids are ignored in NFSv4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック要求のシーケンス番号（seqid）が、次に予期される番号でも、最後に処理された番号でもありません。これらのseqidはNFSv4.1では無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-16-2--NFS4ERRLEASEMOVED-Error-Code-10031">
15.1.16.2. NFS4ERR_LEASE_MOVED (Error Code 10031)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.16.2. NFS4ERR_LEASE_MOVED（エラーコード10031）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A lease being renewed is associated with a file system that has been migrated to a new server. The error has been superseded by the SEQ4_STATUS_LEASE_MOVED status bit (see Section 18.46).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
更新されるリースは、新しいサーバーに移行されたファイルシステムに関連付けられています。エラーは、SEQ4_STATUS_LEASE_MOVEDステータスビットに置き換えられました（セクション18.46を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-16-3--NFS4ERRNXIO-Error-Code-5">
15.1.16.3. NFS4ERR_NXIO (Error Code 5)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.16.3. NFS4ERR_NXIO（エラーコード5）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I/O error. No such device or address. This error is for errors involving block and character device access, but because NFSv4.1 is not a device-access protocol, this error is not applicable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I / Oエラー。そのようなデバイスやアドレスはありません。このエラーは、ブロックおよびキャラクターのデバイスアクセスに関連するエラーですが、NFSv4.1はデバイスアクセスプロトコルではないため、このエラーは適用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-16-4--NFS4ERRRESTOREFH-Error-Code-10030">
15.1.16.4. NFS4ERR_RESTOREFH (Error Code 10030)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.16.4. NFS4ERR_RESTOREFH（エラーコード10030）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RESTOREFH operation does not have a saved filehandle (identified by SAVEFH) to operate upon. In NFSv4.1, this error has been superseded by NFS4ERR_NOFILEHANDLE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESTOREFH操作には、操作対象の保存されたファイルハンドル（SAVEFHで識別）がありません。 NFSv4.1では、このエラーはNFS4ERR_NOFILEHANDLEに置き換えられました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-16-5--NFS4ERRSTALESTATEID-Error-Code-10023">
15.1.16.5. NFS4ERR_STALE_STATEID (Error Code 10023)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.16.5. NFS4ERR_STALE_STATEID（エラーコード10023）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A stateid generated by an earlier server instance was used. This error is moot in NFSv4.1 because all operations that take a stateid MUST be preceded by the SEQUENCE operation, and the earlier server instance is detected by the session infrastructure that supports SEQUENCE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のサーバーインスタンスによって生成された状態IDが使用されました。 stateidをとるすべての操作の前にはSEQUENCE操作が必要であり、以前のサーバーインスタンスがSEQUENCEをサポートするセッションインフラストラクチャによって検出されるため、このエラーはNFSv4.1では意味がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-2--Operations-and-Their-Valid-Errors">
15.2. Operations and Their Valid Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2. 操作とその有効なエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section contains a table that gives the valid error returns for each protocol operation. The error code NFS4_OK (indicating no error) is not listed but should be understood to be returnable by all operations with two important exceptions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションには、各プロトコル操作の有効なエラーの戻り値を示す表が含まれています。エラーコードNFS4_OK（エラーがないことを示す）はリストされていませんが、次の2つの重要な例外を除いて、すべての操作で返されることが理解できるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The operations that MUST NOT be implemented: OPEN_CONFIRM, RELEASE_LOCKOWNER, RENEW, SETCLIENTID, and SETCLIENTID_CONFIRM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 実装してはならない操作：OPEN_CONFIRM、RELEASE_LOCKOWNER、RENEW、SETCLIENTID、SETCLIENTID_CONFIRM。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The invalid operation: ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 無効な操作：ILLEGAL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Valid Error Returns for Each Protocol Operation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
各プロトコル操作で有効なエラーが返される
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----------------------+--------------------------------------------+
   | Operation            | Errors                                     |
   +----------------------+--------------------------------------------+
   | ACCESS               | NFS4ERR_ACCESS, NFS4ERR_BADXDR,            |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,          |
   |                      | NFS4ERR_IO, NFS4ERR_MOVED,                 |
   |                      | NFS4ERR_NOFILEHANDLE,                      |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS                       |
   | BACKCHANNEL_CTL      | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,       |
   |                      | NFS4ERR_DELAY, NFS4ERR_INVAL,              |
   |                      | NFS4ERR_NOENT, NFS4ERR_OP_NOT_IN_SESSION,  |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_TOO_MANY_OPS                       |
   | BIND_CONN_TO_SESSION | NFS4ERR_BADSESSION, NFS4ERR_BADXDR,        |
   |                      | NFS4ERR_BAD_SESSION_DIGEST,                |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_INVAL, NFS4ERR_NOT_ONLY_OP,        |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS  |
   | CLOSE                | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,     |
   |                      | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION,  |
   |                      | NFS4ERR_DELAY, NFS4ERR_EXPIRED,            |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_LOCKS_HELD,     |
   |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,       |
   |                      | NFS4ERR_OLD_STATEID,                       |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED   |
   | COMMIT               | NFS4ERR_ACCESS, NFS4ERR_BADXDR,            |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_IO,             |
   |                      | NFS4ERR_ISDIR, NFS4ERR_MOVED,              |
   |                      | NFS4ERR_NOFILEHANDLE,                      |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,     |
   |                      | NFS4ERR_WRONG_TYPE                         |
   | CREATE               | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,       |
   |                      | NFS4ERR_BADCHAR, NFS4ERR_BADNAME,          |
   |                      | NFS4ERR_BADOWNER, NFS4ERR_BADTYPE,         |
   |                      | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,       |
   |                      | NFS4ERR_DELAY, NFS4ERR_DQUOT,              |
   |                      | NFS4ERR_EXIST, NFS4ERR_FHEXPIRED,          |
   |                      | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MLINK,  |
   |                      | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,        |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,       |
   |                      | NFS4ERR_NOTDIR, NFS4ERR_OP_NOT_IN_SESSION, |
   |                      | NFS4ERR_PERM, NFS4ERR_REP_TOO_BIG,         |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS,  |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS,                      |
   |                      | NFS4ERR_UNSAFE_COMPOUND                    |
   | CREATE_SESSION       | NFS4ERR_BADXDR, NFS4ERR_CLID_INUSE,        |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_INVAL, NFS4ERR_NOENT,              |
   |                      | NFS4ERR_NOT_ONLY_OP, NFS4ERR_NOSPC,        |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SEQ_MISORDERED,                    |
   |                      | NFS4ERR_SERVERFAULT,                       |
   |                      | NFS4ERR_STALE_CLIENTID, NFS4ERR_TOOSMALL,  |
   |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED   |
   | DELEGPURGE           | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,       |
   |                      | NFS4ERR_DELAY, NFS4ERR_NOTSUPP,            |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS, |
   |                      | NFS4ERR_WRONG_CRED                         |
   | DELEGRETURN          | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,     |
   |                      | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION,  |
   |                      | NFS4ERR_DELAY, NFS4ERR_DELEG_REVOKED,      |
   |                      | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,        |
   |                      | NFS4ERR_INVAL, NFS4ERR_MOVED,              |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP,     |
   |                      | NFS4ERR_OLD_STATEID,                       |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED   |
   | DESTROY_CLIENTID     | NFS4ERR_BADXDR, NFS4ERR_CLIENTID_BUSY,     |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_NOT_ONLY_OP, NFS4ERR_REP_TOO_BIG,  |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT,                       |
   |                      | NFS4ERR_STALE_CLIENTID,                    |
   |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED   |
   | DESTROY_SESSION      | NFS4ERR_BACK_CHAN_BUSY,                    |
   |                      | NFS4ERR_BADSESSION, NFS4ERR_BADXDR,        |
   |                      | NFS4ERR_CB_PATH_DOWN,                      |
   |                      | NFS4ERR_CONN_NOT_BOUND_TO_SESSION,         |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_NOT_ONLY_OP, NFS4ERR_REP_TOO_BIG,  |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT,                       |
   |                      | NFS4ERR_STALE_CLIENTID,                    |
   |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED   |
   | EXCHANGE_ID          | NFS4ERR_BADCHAR, NFS4ERR_BADXDR,           |
   |                      | NFS4ERR_CLID_INUSE, NFS4ERR_DEADSESSION,   |
   |                      | NFS4ERR_DELAY, NFS4ERR_ENCR_ALG_UNSUPP,    |
   |                      | NFS4ERR_HASH_ALG_UNSUPP, NFS4ERR_INVAL,    |
   |                      | NFS4ERR_NOENT, NFS4ERR_NOT_ONLY_OP,        |
   |                      | NFS4ERR_NOT_SAME, NFS4ERR_REP_TOO_BIG,     |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS  |
   | FREE_STATEID         | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_LOCKS_HELD, NFS4ERR_OLD_STATEID,   |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS, |
   |                      | NFS4ERR_WRONG_CRED                         |
   | GET_DIR_DELEGATION   | NFS4ERR_ACCESS, NFS4ERR_BADXDR,            |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_DIRDELEG_UNAVAIL,                  |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,          |
   |                      | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,  |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,      |
   |                      | NFS4ERR_NOTSUPP,                           |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS                       |
   | GETATTR              | NFS4ERR_ACCESS, NFS4ERR_BADXDR,            |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,          |
   |                      | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,  |
   |                      | NFS4ERR_NOFILEHANDLE,                      |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE   |
   | GETDEVICEINFO        | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,       |
   |                      | NFS4ERR_DELAY, NFS4ERR_INVAL,              |
   |                      | NFS4ERR_NOENT, NFS4ERR_NOTSUPP,            |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_TOOSMALL,     |
   |                      | NFS4ERR_TOO_MANY_OPS,                      |
   |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE                 |
   | GETDEVICELIST        | NFS4ERR_BADXDR, NFS4ERR_BAD_COOKIE,        |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,          |
   |                      | NFS4ERR_IO, NFS4ERR_NOFILEHANDLE,          |
   |                      | NFS4ERR_NOTSUPP, NFS4ERR_NOT_SAME,         |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS, |
   |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE                 |
   | GETFH                | NFS4ERR_FHEXPIRED, NFS4ERR_MOVED,          |
   |                      | NFS4ERR_NOFILEHANDLE,                      |
   |                      | NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_STALE   |
   | ILLEGAL              | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL         |
   | LAYOUTCOMMIT         | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,     |
   |                      | NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADIOMODE,    |
   |                      | NFS4ERR_BADLAYOUT, NFS4ERR_BADXDR,         |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,    |
   |                      | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED,           |
   |                      | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,  |
   |                      | NFS4ERR_ISDIR NFS4ERR_MOVED,               |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP,     |
   |                      | NFS4ERR_NO_GRACE,                          |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_RECLAIM_BAD,                       |
   |                      | NFS4ERR_RECLAIM_CONFLICT,                  |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,     |
   |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,                |
   |                      | NFS4ERR_WRONG_CRED                         |
   | LAYOUTGET            | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,     |
   |                      | NFS4ERR_BADIOMODE, NFS4ERR_BADLAYOUT,      |
   |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,       |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,      |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,          |
   |                      | NFS4ERR_INVAL, NFS4ERR_IO,                 |
   |                      | NFS4ERR_LAYOUTTRYLATER,                    |
   |                      | NFS4ERR_LAYOUTUNAVAILABLE, NFS4ERR_LOCKED, |
   |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,       |
   |                      | NFS4ERR_NOSPC, NFS4ERR_NOTSUPP,            |
   |                      | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,     |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                      | NFS4ERR_RECALLCONFLICT,                    |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOOSMALL, NFS4ERR_TOO_MANY_OPS,    |
   |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,                |
   |                      | NFS4ERR_WRONG_TYPE                         |
   | LAYOUTRETURN         | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,     |
   |                      | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION,  |
   |                      | NFS4ERR_DELAY, NFS4ERR_DELEG_REVOKED,      |
   |                      | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,        |
   |                      | NFS4ERR_GRACE, NFS4ERR_INVAL,              |
   |                      | NFS4ERR_ISDIR, NFS4ERR_MOVED,              |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP,     |
   |                      | NFS4ERR_NO_GRACE, NFS4ERR_OLD_STATEID,     |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS,                      |
   |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,                |
   |                      | NFS4ERR_WRONG_CRED, NFS4ERR_WRONG_TYPE     |
   | LINK                 | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,           |
   |                      | NFS4ERR_BADNAME, NFS4ERR_BADXDR,           |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_DQUOT, NFS4ERR_EXIST,              |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,      |
   |                      | NFS4ERR_GRACE, NFS4ERR_INVAL,              |
   |                      | NFS4ERR_ISDIR, NFS4ERR_IO, NFS4ERR_MLINK,  |
   |                      | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,        |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,       |
   |                      | NFS4ERR_NOTDIR, NFS4ERR_NOTSUPP,           |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS,  |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,     |
   |                      | NFS4ERR_WRONGSEC, NFS4ERR_WRONG_TYPE,      |
   |                      | NFS4ERR_XDEV                               |
   | LOCK                 | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,     |
   |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_RANGE,         |
   |                      | NFS4ERR_BAD_STATEID, NFS4ERR_DEADLOCK,     |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_DENIED, NFS4ERR_EXPIRED,           |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,          |
   |                      | NFS4ERR_INVAL, NFS4ERR_ISDIR,              |
   |                      | NFS4ERR_LOCK_NOTSUPP, NFS4ERR_LOCK_RANGE,  |
   |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,       |
   |                      | NFS4ERR_NO_GRACE, NFS4ERR_OLD_STATEID,     |
   |                      | NFS4ERR_OPENMODE,                          |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_RECLAIM_BAD,                       |
   |                      | NFS4ERR_RECLAIM_CONFLICT,                  |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS,  |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,     |
   |                      | NFS4ERR_WRONG_CRED, NFS4ERR_WRONG_TYPE     |
   | LOCKT                | NFS4ERR_ACCESS, NFS4ERR_BADXDR,            |
   |                      | NFS4ERR_BAD_RANGE, NFS4ERR_DEADSESSION,    |
   |                      | NFS4ERR_DELAY, NFS4ERR_DENIED,             |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,          |
   |                      | NFS4ERR_INVAL, NFS4ERR_ISDIR,              |
   |                      | NFS4ERR_LOCK_RANGE, NFS4ERR_MOVED,         |
   |                      | NFS4ERR_NOFILEHANDLE,                      |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS,  |
   |                      | NFS4ERR_STALE, NFS4ERR_SYMLINK,            |
   |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED,  |
   |                      | NFS4ERR_WRONG_TYPE                         |
   | LOCKU                | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,     |
   |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_RANGE,         |
   |                      | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION,  |
   |                      | NFS4ERR_DELAY, NFS4ERR_EXPIRED,            |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,          |
   |                      | NFS4ERR_LOCK_RANGE, NFS4ERR_MOVED,         |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_OLD_STATEID, |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED   |
   | LOOKUP               | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,           |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                      | NFS4ERR_BADNAME, NFS4ERR_BADXDR,           |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,          |
   |                      | NFS4ERR_IO, NFS4ERR_MOVED,                 |
   |                      | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT,        |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,      |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,     |
   |                      | NFS4ERR_WRONGSEC                           |
   | LOOKUPP              | NFS4ERR_ACCESS, NFS4ERR_DEADSESSION,       |
   |                      | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,          |
   |                      | NFS4ERR_IO, NFS4ERR_MOVED, NFS4ERR_NOENT,  |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,      |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,     |
   |                      | NFS4ERR_WRONGSEC                           |
   | NVERIFY              | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,       |
   |                      | NFS4ERR_BADCHAR, NFS4ERR_BADXDR,           |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,          |
   |                      | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,  |
   |                      | NFS4ERR_NOFILEHANDLE,                      |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_SAME,  |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS,                      |
   |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,                |
   |                      | NFS4ERR_WRONG_TYPE                         |
   | OPEN                 | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,     |
   |                      | NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADCHAR,      |
   |                      | NFS4ERR_BADNAME, NFS4ERR_BADOWNER,         |
   |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,       |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_DELEG_ALREADY_WANTED,              |
   |                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                      | NFS4ERR_EXIST, NFS4ERR_EXPIRED,            |
   |                      | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED,           |
   |                      | NFS4ERR_GRACE, NFS4ERR_INVAL,              |
   |                      | NFS4ERR_ISDIR, NFS4ERR_IO, NFS4ERR_MOVED,  |
   |                      | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT,        |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,       |
   |                      | NFS4ERR_NOTDIR, NFS4ERR_NO_GRACE,          |
   |                      | NFS4ERR_OLD_STATEID,                       |
   |                      | NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PERM,   |
   |                      | NFS4ERR_RECLAIM_BAD,                       |
   |                      | NFS4ERR_RECLAIM_CONFLICT,                  |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS,  |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_SHARE_DENIED, |
   |                      | NFS4ERR_STALE, NFS4ERR_SYMLINK,            |
   |                      | NFS4ERR_TOO_MANY_OPS,                      |
   |                      | NFS4ERR_UNSAFE_COMPOUND, NFS4ERR_WRONGSEC, |
   |                      | NFS4ERR_WRONG_TYPE                         |
   | OPEN_CONFIRM         | NFS4ERR_NOTSUPP                            |
   | OPEN_DOWNGRADE       | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,     |
   |                      | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION,  |
   |                      | NFS4ERR_DELAY, NFS4ERR_EXPIRED,            |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,          |
   |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,       |
   |                      | NFS4ERR_OLD_STATEID,                       |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS,  |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED   |
   | OPENATTR             | NFS4ERR_ACCESS, NFS4ERR_BADXDR,            |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_DQUOT, NFS4ERR_FHEXPIRED,          |
   |                      | NFS4ERR_IO, NFS4ERR_MOVED, NFS4ERR_NOENT,  |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,       |
   |                      | NFS4ERR_NOTSUPP,                           |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS,  |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS,                      |
   |                      | NFS4ERR_UNSAFE_COMPOUND,                   |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                      | NFS4ERR_WRONG_TYPE                         |
   | PUTFH                | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,         |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_MOVED, NFS4ERR_OP_NOT_IN_SESSION,  |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONGSEC     |
   | PUTPUBFH             | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS, |
   |                      | NFS4ERR_WRONGSEC                           |
   | PUTROOTFH            | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS, |
   |                      | NFS4ERR_WRONGSEC                           |
   | READ                 | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,     |
   |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,       |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,    |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,          |
   |                      | NFS4ERR_INVAL, NFS4ERR_ISDIR, NFS4ERR_IO,  |
   |                      | NFS4ERR_LOCKED, NFS4ERR_MOVED,             |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_OLD_STATEID, |
   |                      | NFS4ERR_OPENMODE,                          |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_PNFS_IO_HOLE,                      |
   |                      | NFS4ERR_PNFS_NO_LAYOUT,                    |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,     |
   |                      | NFS4ERR_WRONG_TYPE                         |
   | READDIR              | NFS4ERR_ACCESS, NFS4ERR_BADXDR,            |
   |                      | NFS4ERR_BAD_COOKIE, NFS4ERR_DEADSESSION,   |
   |                      | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,          |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                      | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,  |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,      |
   |                      | NFS4ERR_NOT_SAME,                          |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOOSMALL, NFS4ERR_TOO_MANY_OPS     |
   | READLINK             | NFS4ERR_ACCESS, NFS4ERR_DEADSESSION,       |
   |                      | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,          |
   |                      | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,  |
   |                      | NFS4ERR_NOFILEHANDLE,                      |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE   |
   | RECLAIM_COMPLETE     | NFS4ERR_BADXDR, NFS4ERR_COMPLETE_ALREADY,  |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,          |
   |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,       |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED,  |
   |                      | NFS4ERR_WRONG_TYPE                         |
   | RELEASE_LOCKOWNER    | NFS4ERR_NOTSUPP                            |
   | REMOVE               | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,           |
   |                      | NFS4ERR_BADNAME, NFS4ERR_BADXDR,           |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,      |
   |                      | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,  |
   |                      | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,        |
   |                      | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,       |
   |                      | NFS4ERR_NOTDIR, NFS4ERR_NOTEMPTY,          |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS,  |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                      | NFS4ERR_TOO_MANY_OPS                       |
   | RENAME               | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,           |
   |                      | NFS4ERR_BADNAME, NFS4ERR_BADXDR,           |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_DQUOT, NFS4ERR_EXIST,              |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,      |
   |                      | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,  |
   |                      | NFS4ERR_MLINK, NFS4ERR_MOVED,              |
   |                      | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT,        |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,       |
   |                      | NFS4ERR_NOTDIR, NFS4ERR_NOTEMPTY,          |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS,  |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONGSEC,    |
   |                      | NFS4ERR_XDEV                               |
   | RENEW                | NFS4ERR_NOTSUPP                            |
   | RESTOREFH            | NFS4ERR_DEADSESSION, NFS4ERR_FHEXPIRED,    |
   |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,       |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONGSEC     |
   | SAVEFH               | NFS4ERR_DEADSESSION, NFS4ERR_FHEXPIRED,    |
   |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,       |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS                       |
   | SECINFO              | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,           |
   |                      | NFS4ERR_BADNAME, NFS4ERR_BADXDR,           |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,          |
   |                      | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,        |
   |                      | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,       |
   |                      | NFS4ERR_NOTDIR, NFS4ERR_OP_NOT_IN_SESSION, |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS                       |
   | SECINFO_NO_NAME      | NFS4ERR_ACCESS, NFS4ERR_BADXDR,            |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,          |
   |                      | NFS4ERR_MOVED, NFS4ERR_NOENT,              |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,      |
   |                      | NFS4ERR_NOTSUPP,                           |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS                       |
   | SEQUENCE             | NFS4ERR_BADSESSION, NFS4ERR_BADSLOT,       |
   |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_HIGH_SLOT,     |
   |                      | NFS4ERR_CONN_NOT_BOUND_TO_SESSION,         |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SEQUENCE_POS,                      |
   |                      | NFS4ERR_SEQ_FALSE_RETRY,                   |
   |                      | NFS4ERR_SEQ_MISORDERED,                    |
   |                      | NFS4ERR_TOO_MANY_OPS                       |
   | SET_SSV              | NFS4ERR_BADXDR,                            |
   |                      | NFS4ERR_BAD_SESSION_DIGEST,                |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_INVAL, NFS4ERR_OP_NOT_IN_SESSION,  |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_TOO_MANY_OPS                       |
   | SETATTR              | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,     |
   |                      | NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADCHAR,      |
   |                      | NFS4ERR_BADOWNER, NFS4ERR_BADXDR,          |
   |                      | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION,  |
   |                      | NFS4ERR_DELAY, NFS4ERR_DELEG_REVOKED,      |
   |                      | NFS4ERR_DQUOT, NFS4ERR_EXPIRED,            |
   |                      | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED,           |
   |                      | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,  |
   |                      | NFS4ERR_LOCKED, NFS4ERR_MOVED,             |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,       |
   |                      | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,     |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                      | NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PERM,   |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS,  |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS,                      |
   |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,                |
   |                      | NFS4ERR_WRONG_TYPE                         |
   | SETCLIENTID          | NFS4ERR_NOTSUPP                            |
   | SETCLIENTID_CONFIRM  | NFS4ERR_NOTSUPP                            |
   | TEST_STATEID         | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,       |
   |                      | NFS4ERR_DELAY, NFS4ERR_OP_NOT_IN_SESSION,  |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS  |
   | VERIFY               | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,       |
   |                      | NFS4ERR_BADCHAR, NFS4ERR_BADXDR,           |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,          |
   |                      | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,  |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOT_SAME,    |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS,                      |
   |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,                |
   |                      | NFS4ERR_WRONG_TYPE                         |
   | WANT_DELEGATION      | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,       |
   |                      | NFS4ERR_DELAY,                             |
   |                      | NFS4ERR_DELEG_ALREADY_WANTED,              |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,          |
   |                      | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,  |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP,     |
   |                      | NFS4ERR_NO_GRACE,                          |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_RECALLCONFLICT,                    |
   |                      | NFS4ERR_RECLAIM_BAD,                       |
   |                      | NFS4ERR_RECLAIM_CONFLICT,                  |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE   |
   | WRITE                | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,     |
   |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,       |
   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |
   |                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,      |
   |                      | NFS4ERR_EXPIRED, NFS4ERR_FBIG,             |
   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,          |
   |                      | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR,  |
   |                      | NFS4ERR_LOCKED, NFS4ERR_MOVED,             |
   |                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,       |
   |                      | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,     |
   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |
   |                      | NFS4ERR_PNFS_IO_HOLE,                      |
   |                      | NFS4ERR_PNFS_NO_LAYOUT,                    |
   |                      | NFS4ERR_REP_TOO_BIG,                       |
   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |
   |                      | NFS4ERR_REQ_TOO_BIG,                       |
   |                      | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS,  |
   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |
   |                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,     |
   |                      | NFS4ERR_WRONG_TYPE                         |
   +----------------------+--------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Table 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
表6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-3--Callback-Operations-and-Their-Valid-Errors">
15.3. Callback Operations and Their Valid Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3. コールバック操作とその有効なエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section contains a table that gives the valid error returns for each callback operation. The error code NFS4_OK (indicating no error) is not listed but should be understood to be returnable by all callback operations with the exception of CB_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションには、コールバック操作ごとに有効なエラーが返される表が含まれています。エラーコードNFS4_OK（エラーがないことを示す）はリストされていませんが、CB_ILLEGALを除くすべてのコールバック操作で返されることが理解できるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Valid Error Returns for Each Protocol Callback Operation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
各プロトコルコールバック操作に対して有効なエラーが返される
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------------------+-----------------------------------------+
   | Callback Operation      | Errors                                  |
   +-------------------------+-----------------------------------------+
   | CB_GETATTR              | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,      |
   |                         | NFS4ERR_DELAY, NFS4ERR_INVAL,           |
   |                         | NFS4ERR_OP_NOT_IN_SESSION,              |
   |                         | NFS4ERR_REP_TOO_BIG,                    |
   |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,           |
   |                         | NFS4ERR_REQ_TOO_BIG,                    |
   |                         | NFS4ERR_RETRY_UNCACHED_REP,             |
   |                         | NFS4ERR_SERVERFAULT,                    |
   |                         | NFS4ERR_TOO_MANY_OPS,                   |
   | CB_ILLEGAL              | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | CB_LAYOUTRECALL         | NFS4ERR_BADHANDLE, NFS4ERR_BADIOMODE,   |
   |                         | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,    |
   |                         | NFS4ERR_DELAY, NFS4ERR_INVAL,           |
   |                         | NFS4ERR_NOMATCHING_LAYOUT,              |
   |                         | NFS4ERR_NOTSUPP,                        |
   |                         | NFS4ERR_OP_NOT_IN_SESSION,              |
   |                         | NFS4ERR_REP_TOO_BIG,                    |
   |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,           |
   |                         | NFS4ERR_REQ_TOO_BIG,                    |
   |                         | NFS4ERR_RETRY_UNCACHED_REP,             |
   |                         | NFS4ERR_TOO_MANY_OPS,                   |
   |                         | NFS4ERR_UNKNOWN_LAYOUTTYPE,             |
   |                         | NFS4ERR_WRONG_TYPE                      |
   | CB_NOTIFY               | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,      |
   |                         | NFS4ERR_BAD_STATEID, NFS4ERR_DELAY,     |
   |                         | NFS4ERR_INVAL, NFS4ERR_NOTSUPP,         |
   |                         | NFS4ERR_OP_NOT_IN_SESSION,              |
   |                         | NFS4ERR_REP_TOO_BIG,                    |
   |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,           |
   |                         | NFS4ERR_REQ_TOO_BIG,                    |
   |                         | NFS4ERR_RETRY_UNCACHED_REP,             |
   |                         | NFS4ERR_SERVERFAULT,                    |
   |                         | NFS4ERR_TOO_MANY_OPS                    |
   | CB_NOTIFY_DEVICEID      | NFS4ERR_BADXDR, NFS4ERR_DELAY,          |
   |                         | NFS4ERR_INVAL, NFS4ERR_NOTSUPP,         |
   |                         | NFS4ERR_OP_NOT_IN_SESSION,              |
   |                         | NFS4ERR_REP_TOO_BIG,                    |
   |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,           |
   |                         | NFS4ERR_REQ_TOO_BIG,                    |
   |                         | NFS4ERR_RETRY_UNCACHED_REP,             |
   |                         | NFS4ERR_SERVERFAULT,                    |
   |                         | NFS4ERR_TOO_MANY_OPS                    |
   | CB_NOTIFY_LOCK          | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,      |
   |                         | NFS4ERR_BAD_STATEID, NFS4ERR_DELAY,     |
   |                         | NFS4ERR_NOTSUPP,                        |
   |                         | NFS4ERR_OP_NOT_IN_SESSION,              |
   |                         | NFS4ERR_REP_TOO_BIG,                    |
   |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,           |
   |                         | NFS4ERR_REQ_TOO_BIG,                    |
   |                         | NFS4ERR_RETRY_UNCACHED_REP,             |
   |                         | NFS4ERR_SERVERFAULT,                    |
   |                         | NFS4ERR_TOO_MANY_OPS                    |
   | CB_PUSH_DELEG           | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,      |
   |                         | NFS4ERR_DELAY, NFS4ERR_INVAL,           |
   |                         | NFS4ERR_NOTSUPP,                        |
   |                         | NFS4ERR_OP_NOT_IN_SESSION,              |
   |                         | NFS4ERR_REJECT_DELEG,                   |
   |                         | NFS4ERR_REP_TOO_BIG,                    |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,           |
   |                         | NFS4ERR_REQ_TOO_BIG,                    |
   |                         | NFS4ERR_RETRY_UNCACHED_REP,             |
   |                         | NFS4ERR_SERVERFAULT,                    |
   |                         | NFS4ERR_TOO_MANY_OPS,                   |
   |                         | NFS4ERR_WRONG_TYPE                      |
   | CB_RECALL               | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,      |
   |                         | NFS4ERR_BAD_STATEID, NFS4ERR_DELAY,     |
   |                         | NFS4ERR_OP_NOT_IN_SESSION,              |
   |                         | NFS4ERR_REP_TOO_BIG,                    |
   |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,           |
   |                         | NFS4ERR_REQ_TOO_BIG,                    |
   |                         | NFS4ERR_RETRY_UNCACHED_REP,             |
   |                         | NFS4ERR_SERVERFAULT,                    |
   |                         | NFS4ERR_TOO_MANY_OPS                    |
   | CB_RECALL_ANY           | NFS4ERR_BADXDR, NFS4ERR_DELAY,          |
   |                         | NFS4ERR_INVAL,                          |
   |                         | NFS4ERR_OP_NOT_IN_SESSION,              |
   |                         | NFS4ERR_REP_TOO_BIG,                    |
   |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,           |
   |                         | NFS4ERR_REQ_TOO_BIG,                    |
   |                         | NFS4ERR_RETRY_UNCACHED_REP,             |
   |                         | NFS4ERR_TOO_MANY_OPS                    |
   | CB_RECALLABLE_OBJ_AVAIL | NFS4ERR_BADXDR, NFS4ERR_DELAY,          |
   |                         | NFS4ERR_INVAL, NFS4ERR_NOTSUPP,         |
   |                         | NFS4ERR_OP_NOT_IN_SESSION,              |
   |                         | NFS4ERR_REP_TOO_BIG,                    |
   |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,           |
   |                         | NFS4ERR_REQ_TOO_BIG,                    |
   |                         | NFS4ERR_RETRY_UNCACHED_REP,             |
   |                         | NFS4ERR_SERVERFAULT,                    |
   |                         | NFS4ERR_TOO_MANY_OPS                    |
   | CB_RECALL_SLOT          | NFS4ERR_BADXDR, NFS4ERR_BAD_HIGH_SLOT,  |
   |                         | NFS4ERR_DELAY,                          |
   |                         | NFS4ERR_OP_NOT_IN_SESSION,              |
   |                         | NFS4ERR_REP_TOO_BIG,                    |
   |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,           |
   |                         | NFS4ERR_REQ_TOO_BIG,                    |
   |                         | NFS4ERR_RETRY_UNCACHED_REP,             |
   |                         | NFS4ERR_TOO_MANY_OPS                    |
   | CB_SEQUENCE             | NFS4ERR_BADSESSION, NFS4ERR_BADSLOT,    |
   |                         | NFS4ERR_BADXDR, NFS4ERR_BAD_HIGH_SLOT,  |
   |                         | NFS4ERR_CONN_NOT_BOUND_TO_SESSION,      |
   |                         | NFS4ERR_DELAY, NFS4ERR_REP_TOO_BIG,     |
   |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,           |
   |                         | NFS4ERR_REQ_TOO_BIG,                    |
   |                         | NFS4ERR_RETRY_UNCACHED_REP,             |
   |                         | NFS4ERR_SEQUENCE_POS,                   |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                         | NFS4ERR_SEQ_FALSE_RETRY,                |
   |                         | NFS4ERR_SEQ_MISORDERED,                 |
   |                         | NFS4ERR_TOO_MANY_OPS                    |
   | CB_WANTS_CANCELLED      | NFS4ERR_BADXDR, NFS4ERR_DELAY,          |
   |                         | NFS4ERR_NOTSUPP,                        |
   |                         | NFS4ERR_OP_NOT_IN_SESSION,              |
   |                         | NFS4ERR_REP_TOO_BIG,                    |
   |                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,           |
   |                         | NFS4ERR_REQ_TOO_BIG,                    |
   |                         | NFS4ERR_RETRY_UNCACHED_REP,             |
   |                         | NFS4ERR_SERVERFAULT,                    |
   |                         | NFS4ERR_TOO_MANY_OPS                    |
   +-------------------------+-----------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Table 7
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
表7
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-4--Errors-and-the-Operations-That-Use-Them">
15.4. Errors and the Operations That Use Them
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4. エラーとそれらを使用する操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----------------------------------+-------------------------------+
   | Error                             | Operations                    |
   +-----------------------------------+-------------------------------+
   | NFS4ERR_ACCESS                    | ACCESS, COMMIT, CREATE,       |
   |                                   | GETATTR, GET_DIR_DELEGATION,  |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LINK, LOCK, LOCKT, LOCKU,     |
   |                                   | LOOKUP, LOOKUPP, NVERIFY,     |
   |                                   | OPEN, OPENATTR, READ,         |
   |                                   | READDIR, READLINK, REMOVE,    |
   |                                   | RENAME, SECINFO,              |
   |                                   | SECINFO_NO_NAME, SETATTR,     |
   |                                   | VERIFY, WRITE                 |
   | NFS4ERR_ADMIN_REVOKED             | CLOSE, DELEGRETURN,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LOCK, LOCKU,    |
   |                                   | OPEN, OPEN_DOWNGRADE, READ,   |
   |                                   | SETATTR, WRITE                |
   | NFS4ERR_ATTRNOTSUPP               | CREATE, LAYOUTCOMMIT,         |
   |                                   | NVERIFY, OPEN, SETATTR,       |
   |                                   | VERIFY                        |
   | NFS4ERR_BACK_CHAN_BUSY            | DESTROY_SESSION               |
   | NFS4ERR_BADCHAR                   | CREATE, EXCHANGE_ID, LINK,    |
   |                                   | LOOKUP, NVERIFY, OPEN,        |
   |                                   | REMOVE, RENAME, SECINFO,      |
   |                                   | SETATTR, VERIFY               |
   | NFS4ERR_BADHANDLE                 | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY, CB_NOTIFY_LOCK,    |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | PUTFH                         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | NFS4ERR_BADIOMODE                 | CB_LAYOUTRECALL,              |
   |                                   | LAYOUTCOMMIT, LAYOUTGET       |
   | NFS4ERR_BADLAYOUT                 | LAYOUTCOMMIT, LAYOUTGET       |
   | NFS4ERR_BADNAME                   | CREATE, LINK, LOOKUP, OPEN,   |
   |                                   | REMOVE, RENAME, SECINFO       |
   | NFS4ERR_BADOWNER                  | CREATE, OPEN, SETATTR         |
   | NFS4ERR_BADSESSION                | BIND_CONN_TO_SESSION,         |
   |                                   | CB_SEQUENCE, DESTROY_SESSION, |
   |                                   | SEQUENCE                      |
   | NFS4ERR_BADSLOT                   | CB_SEQUENCE, SEQUENCE         |
   | NFS4ERR_BADTYPE                   | CREATE                        |
   | NFS4ERR_BADXDR                    | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION,         |
   |                                   | CB_GETATTR, CB_ILLEGAL,       |
   |                                   | CB_LAYOUTRECALL, CB_NOTIFY,   |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY,                |
   |                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION, EXCHANGE_ID, |
   |                                   | FREE_STATEID, GETATTR,        |
   |                                   | GETDEVICEINFO, GETDEVICELIST, |
   |                                   | GET_DIR_DELEGATION, ILLEGAL,  |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | NVERIFY, OPEN, OPENATTR,      |
   |                                   | OPEN_DOWNGRADE, PUTFH, READ,  |
   |                                   | READDIR, RECLAIM_COMPLETE,    |
   |                                   | REMOVE, RENAME, SECINFO,      |
   |                                   | SECINFO_NO_NAME, SEQUENCE,    |
   |                                   | SETATTR, SET_SSV,             |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   | NFS4ERR_BAD_COOKIE                | GETDEVICELIST, READDIR        |
   | NFS4ERR_BAD_HIGH_SLOT             | CB_RECALL_SLOT, CB_SEQUENCE,  |
   |                                   | SEQUENCE                      |
   | NFS4ERR_BAD_RANGE                 | LOCK, LOCKT, LOCKU            |
   | NFS4ERR_BAD_SESSION_DIGEST        | BIND_CONN_TO_SESSION, SET_SSV |
   | NFS4ERR_BAD_STATEID               | CB_LAYOUTRECALL, CB_NOTIFY,   |
   |                                   | CB_NOTIFY_LOCK, CB_RECALL,    |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                                   | CLOSE, DELEGRETURN,           |
   |                                   | FREE_STATEID, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LOCK, LOCKU,    |
   |                                   | OPEN, OPEN_DOWNGRADE, READ,   |
   |                                   | SETATTR, WRITE                |
   | NFS4ERR_CB_PATH_DOWN              | DESTROY_SESSION               |
   | NFS4ERR_CLID_INUSE                | CREATE_SESSION, EXCHANGE_ID   |
   | NFS4ERR_CLIENTID_BUSY             | DESTROY_CLIENTID              |
   | NFS4ERR_COMPLETE_ALREADY          | RECLAIM_COMPLETE              |
   | NFS4ERR_CONN_NOT_BOUND_TO_SESSION | CB_SEQUENCE, DESTROY_SESSION, |
   |                                   | SEQUENCE                      |
   | NFS4ERR_DEADLOCK                  | LOCK                          |
   | NFS4ERR_DEADSESSION               | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION, CLOSE,  |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION, EXCHANGE_ID, |
   |                                   | FREE_STATEID, GETATTR,        |
   |                                   | GETDEVICEINFO, GETDEVICELIST, |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SEQUENCE, SETATTR, SET_SSV,   |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   | NFS4ERR_DELAY                     | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION,         |
   |                                   | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY,                    |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY,                |
   |                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION, EXCHANGE_ID, |
   |                                   | FREE_STATEID, GETATTR,        |
   |                                   | GETDEVICEINFO, GETDEVICELIST, |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, SECINFO,              |
   |                                   | SECINFO_NO_NAME, SEQUENCE,    |
   |                                   | SETATTR, SET_SSV,             |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   | NFS4ERR_DELEG_ALREADY_WANTED      | OPEN, WANT_DELEGATION         |
   | NFS4ERR_DELEG_REVOKED             | DELEGRETURN, LAYOUTCOMMIT,    |
   |                                   | LAYOUTGET, LAYOUTRETURN,      |
   |                                   | OPEN, READ, SETATTR, WRITE    |
   | NFS4ERR_DENIED                    | LOCK, LOCKT                   |
   | NFS4ERR_DIRDELEG_UNAVAIL          | GET_DIR_DELEGATION            |
   | NFS4ERR_DQUOT                     | CREATE, LAYOUTGET, LINK,      |
   |                                   | OPEN, OPENATTR, RENAME,       |
   |                                   | SETATTR, WRITE                |
   | NFS4ERR_ENCR_ALG_UNSUPP           | EXCHANGE_ID                   |
   | NFS4ERR_EXIST                     | CREATE, LINK, OPEN, RENAME    |
   | NFS4ERR_EXPIRED                   | CLOSE, DELEGRETURN,           |
   |                                   | LAYOUTCOMMIT, LAYOUTRETURN,   |
   |                                   | LOCK, LOCKU, OPEN,            |
   |                                   | OPEN_DOWNGRADE, READ,         |
   |                                   | SETATTR, WRITE                |
   | NFS4ERR_FBIG                      | LAYOUTCOMMIT, OPEN, SETATTR,  |
   |                                   | WRITE                         |
   | NFS4ERR_FHEXPIRED                 | ACCESS, CLOSE, COMMIT,        |
   |                                   | CREATE, DELEGRETURN, GETATTR, |
   |                                   | GETDEVICELIST, GETFH,         |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SETATTR, VERIFY,              |
   |                                   | WANT_DELEGATION, WRITE        |
   | NFS4ERR_FILE_OPEN                 | LINK, REMOVE, RENAME          |
   | NFS4ERR_GRACE                     | GETATTR, GET_DIR_DELEGATION,  |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, NVERIFY, OPEN, READ,   |
   |                                   | REMOVE, RENAME, SETATTR,      |
   |                                   | VERIFY, WANT_DELEGATION,      |
   |                                   | WRITE                         |
   | NFS4ERR_HASH_ALG_UNSUPP           | EXCHANGE_ID                   |
   | NFS4ERR_INVAL                     | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION,         |
   |                                   | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY,                    |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_PUSH_DELEG,                |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY, CREATE,        |
   |                                   | CREATE_SESSION, DELEGRETURN,  |
   |                                   | EXCHANGE_ID, GETATTR,         |
   |                                   | GETDEVICEINFO, GETDEVICELIST, |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | NVERIFY, OPEN,                |
   |                                   | OPEN_DOWNGRADE, READ,         |
   |                                   | READDIR, READLINK,            |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, SECINFO,              |
   |                                   | SECINFO_NO_NAME, SETATTR,     |
   |                                   | SET_SSV, VERIFY,              |
   |                                   | WANT_DELEGATION, WRITE        |
   | NFS4ERR_IO                        | ACCESS, COMMIT, CREATE,       |
   |                                   | GETATTR, GETDEVICELIST,       |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LINK, LOOKUP, LOOKUPP,        |
   |                                   | NVERIFY, OPEN, OPENATTR,      |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | REMOVE, RENAME, SETATTR,      |
   |                                   | VERIFY, WANT_DELEGATION,      |
   |                                   | WRITE                         |
   | NFS4ERR_ISDIR                     | COMMIT, LAYOUTCOMMIT,         |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                                   | LOCKT, OPEN, READ, WRITE      |
   | NFS4ERR_LAYOUTTRYLATER            | LAYOUTGET                     |
   | NFS4ERR_LAYOUTUNAVAILABLE         | LAYOUTGET                     |
   | NFS4ERR_LOCKED                    | LAYOUTGET, READ, SETATTR,     |
   |                                   | WRITE                         |
   | NFS4ERR_LOCKS_HELD                | CLOSE, FREE_STATEID           |
   | NFS4ERR_LOCK_NOTSUPP              | LOCK                          |
   | NFS4ERR_LOCK_RANGE                | LOCK, LOCKT, LOCKU            |
   | NFS4ERR_MLINK                     | CREATE, LINK, RENAME          |
   | NFS4ERR_MOVED                     | ACCESS, CLOSE, COMMIT,        |
   |                                   | CREATE, DELEGRETURN, GETATTR, |
   |                                   | GETFH, GET_DIR_DELEGATION,    |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, READ, READDIR,         |
   |                                   | READLINK, RECLAIM_COMPLETE,   |
   |                                   | REMOVE, RENAME, RESTOREFH,    |
   |                                   | SAVEFH, SECINFO,              |
   |                                   | SECINFO_NO_NAME, SETATTR,     |
   |                                   | VERIFY, WANT_DELEGATION,      |
   |                                   | WRITE                         |
   | NFS4ERR_NAMETOOLONG               | CREATE, LINK, LOOKUP, OPEN,   |
   |                                   | REMOVE, RENAME, SECINFO       |
   | NFS4ERR_NOENT                     | BACKCHANNEL_CTL,              |
   |                                   | CREATE_SESSION, EXCHANGE_ID,  |
   |                                   | GETDEVICEINFO, LOOKUP,        |
   |                                   | LOOKUPP, OPEN, OPENATTR,      |
   |                                   | REMOVE, RENAME, SECINFO,      |
   |                                   | SECINFO_NO_NAME               |
   | NFS4ERR_NOFILEHANDLE              | ACCESS, CLOSE, COMMIT,        |
   |                                   | CREATE, DELEGRETURN, GETATTR, |
   |                                   | GETDEVICELIST, GETFH,         |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SETATTR, VERIFY,              |
   |                                   | WANT_DELEGATION, WRITE        |
   | NFS4ERR_NOMATCHING_LAYOUT         | CB_LAYOUTRECALL               |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | NFS4ERR_NOSPC                     | CREATE, CREATE_SESSION,       |
   |                                   | LAYOUTGET, LINK, OPEN,        |
   |                                   | OPENATTR, RENAME, SETATTR,    |
   |                                   | WRITE                         |
   | NFS4ERR_NOTDIR                    | CREATE, GET_DIR_DELEGATION,   |
   |                                   | LINK, LOOKUP, LOOKUPP, OPEN,  |
   |                                   | READDIR, REMOVE, RENAME,      |
   |                                   | SECINFO, SECINFO_NO_NAME      |
   | NFS4ERR_NOTEMPTY                  | REMOVE, RENAME                |
   | NFS4ERR_NOTSUPP                   | CB_LAYOUTRECALL, CB_NOTIFY,   |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG,                |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_WANTS_CANCELLED,           |
   |                                   | DELEGPURGE, DELEGRETURN,      |
   |                                   | GETDEVICEINFO, GETDEVICELIST, |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, OPENATTR, |
   |                                   | OPEN_CONFIRM,                 |
   |                                   | RELEASE_LOCKOWNER, RENEW,     |
   |                                   | SECINFO_NO_NAME, SETCLIENTID, |
   |                                   | SETCLIENTID_CONFIRM,          |
   |                                   | WANT_DELEGATION               |
   | NFS4ERR_NOT_ONLY_OP               | BIND_CONN_TO_SESSION,         |
   |                                   | CREATE_SESSION,               |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION, EXCHANGE_ID  |
   | NFS4ERR_NOT_SAME                  | EXCHANGE_ID, GETDEVICELIST,   |
   |                                   | READDIR, VERIFY               |
   | NFS4ERR_NO_GRACE                  | LAYOUTCOMMIT, LAYOUTRETURN,   |
   |                                   | LOCK, OPEN, WANT_DELEGATION   |
   | NFS4ERR_OLD_STATEID               | CLOSE, DELEGRETURN,           |
   |                                   | FREE_STATEID, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LOCK, LOCKU,    |
   |                                   | OPEN, OPEN_DOWNGRADE, READ,   |
   |                                   | SETATTR, WRITE                |
   | NFS4ERR_OPENMODE                  | LAYOUTGET, LOCK, READ,        |
   |                                   | SETATTR, WRITE                |
   | NFS4ERR_OP_ILLEGAL                | CB_ILLEGAL, ILLEGAL           |
   | NFS4ERR_OP_NOT_IN_SESSION         | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY,                    |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                                   | CB_RECALL_ANY,                |
   |                                   | CB_RECALL_SLOT,               |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE, DELEGPURGE,   |
   |                                   | DELEGRETURN, FREE_STATEID,    |
   |                                   | GETATTR, GETDEVICEINFO,       |
   |                                   | GETDEVICELIST, GETFH,         |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SETATTR, SET_SSV,             |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   | NFS4ERR_PERM                      | CREATE, OPEN, SETATTR         |
   | NFS4ERR_PNFS_IO_HOLE              | READ, WRITE                   |
   | NFS4ERR_PNFS_NO_LAYOUT            | READ, WRITE                   |
   | NFS4ERR_RECALLCONFLICT            | LAYOUTGET, WANT_DELEGATION    |
   | NFS4ERR_RECLAIM_BAD               | LAYOUTCOMMIT, LOCK, OPEN,     |
   |                                   | WANT_DELEGATION               |
   | NFS4ERR_RECLAIM_CONFLICT          | LAYOUTCOMMIT, LOCK, OPEN,     |
   |                                   | WANT_DELEGATION               |
   | NFS4ERR_REJECT_DELEG              | CB_PUSH_DELEG                 |
   | NFS4ERR_REP_TOO_BIG               | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION,         |
   |                                   | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY,                    |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY,                |
   |                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION, EXCHANGE_ID, |
   |                                   | FREE_STATEID, GETATTR,        |
   |                                   | GETDEVICEINFO, GETDEVICELIST, |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SEQUENCE, SETATTR, SET_SSV,   |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   | NFS4ERR_REP_TOO_BIG_TO_CACHE      | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION,         |
   |                                   | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY,                    |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY,                |
   |                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION, EXCHANGE_ID, |
   |                                   | FREE_STATEID, GETATTR,        |
   |                                   | GETDEVICEINFO, GETDEVICELIST, |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SEQUENCE, SETATTR, SET_SSV,   |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   | NFS4ERR_REQ_TOO_BIG               | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION,         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                                   | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY,                    |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY,                |
   |                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION, EXCHANGE_ID, |
   |                                   | FREE_STATEID, GETATTR,        |
   |                                   | GETDEVICEINFO, GETDEVICELIST, |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SEQUENCE, SETATTR, SET_SSV,   |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   | NFS4ERR_RETRY_UNCACHED_REP        | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION,         |
   |                                   | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY,                    |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY,                |
   |                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION, EXCHANGE_ID, |
   |                                   | FREE_STATEID, GETATTR,        |
   |                                   | GETDEVICEINFO, GETDEVICELIST, |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SEQUENCE, SETATTR, SET_SSV,   |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   | NFS4ERR_ROFS                      | CREATE, LINK, LOCK, LOCKT,    |
   |                                   | OPEN, OPENATTR,               |
   |                                   | OPEN_DOWNGRADE, REMOVE,       |
   |                                   | RENAME, SETATTR, WRITE        |
   | NFS4ERR_SAME                      | NVERIFY                       |
   | NFS4ERR_SEQUENCE_POS              | CB_SEQUENCE, SEQUENCE         |
   | NFS4ERR_SEQ_FALSE_RETRY           | CB_SEQUENCE, SEQUENCE         |
   | NFS4ERR_SEQ_MISORDERED            | CB_SEQUENCE, CREATE_SESSION,  |
   |                                   | SEQUENCE                      |
   | NFS4ERR_SERVERFAULT               | ACCESS, BIND_CONN_TO_SESSION, |
   |                                   | CB_GETATTR, CB_NOTIFY,        |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION, EXCHANGE_ID, |
   |                                   | FREE_STATEID, GETATTR,        |
   |                                   | GETDEVICEINFO, GETDEVICELIST, |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKU, LOOKUP, LOOKUPP,       |
   |                                   | NVERIFY, OPEN, OPENATTR,      |
   |                                   | OPEN_DOWNGRADE, PUTFH,        |
   |                                   | PUTPUBFH, PUTROOTFH, READ,    |
   |                                   | READDIR, READLINK,            |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                                   | SETATTR, TEST_STATEID,        |
   |                                   | VERIFY, WANT_DELEGATION,      |
   |                                   | WRITE                         |
   | NFS4ERR_SHARE_DENIED              | OPEN                          |
   | NFS4ERR_STALE                     | ACCESS, CLOSE, COMMIT,        |
   |                                   | CREATE, DELEGRETURN, GETATTR, |
   |                                   | GETFH, GET_DIR_DELEGATION,    |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, READ, READDIR,         |
   |                                   | READLINK, RECLAIM_COMPLETE,   |
   |                                   | REMOVE, RENAME, RESTOREFH,    |
   |                                   | SAVEFH, SECINFO,              |
   |                                   | SECINFO_NO_NAME, SETATTR,     |
   |                                   | VERIFY, WANT_DELEGATION,      |
   |                                   | WRITE                         |
   | NFS4ERR_STALE_CLIENTID            | CREATE_SESSION,               |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION               |
   | NFS4ERR_SYMLINK                   | COMMIT, LAYOUTCOMMIT, LINK,   |
   |                                   | LOCK, LOCKT, LOOKUP, LOOKUPP, |
   |                                   | OPEN, READ, WRITE             |
   | NFS4ERR_TOOSMALL                  | CREATE_SESSION,               |
   |                                   | GETDEVICEINFO, LAYOUTGET,     |
   |                                   | READDIR                       |
   | NFS4ERR_TOO_MANY_OPS              | ACCESS, BACKCHANNEL_CTL,      |
   |                                   | BIND_CONN_TO_SESSION,         |
   |                                   | CB_GETATTR, CB_LAYOUTRECALL,  |
   |                                   | CB_NOTIFY,                    |
   |                                   | CB_NOTIFY_DEVICEID,           |
   |                                   | CB_NOTIFY_LOCK,               |
   |                                   | CB_PUSH_DELEG, CB_RECALL,     |
   |                                   | CB_RECALLABLE_OBJ_AVAIL,      |
   |                                   | CB_RECALL_ANY,                |
   |                                   | CB_RECALL_SLOT, CB_SEQUENCE,  |
   |                                   | CB_WANTS_CANCELLED, CLOSE,    |
   |                                   | COMMIT, CREATE,               |
   |                                   | CREATE_SESSION, DELEGPURGE,   |
   |                                   | DELEGRETURN,                  |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION, EXCHANGE_ID, |
   |                                   | FREE_STATEID, GETATTR,        |
   |                                   | GETDEVICEINFO, GETDEVICELIST, |
   |                                   | GET_DIR_DELEGATION,           |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, LOCKU, LOOKUP,         |
   |                                   | LOOKUPP, NVERIFY, OPEN,       |
   |                                   | OPENATTR, OPEN_DOWNGRADE,     |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | READ, READDIR, READLINK,      |
   |                                   | RECLAIM_COMPLETE, REMOVE,     |
   |                                   | RENAME, RESTOREFH, SAVEFH,    |
   |                                   | SECINFO, SECINFO_NO_NAME,     |
   |                                   | SEQUENCE, SETATTR, SET_SSV,   |
   |                                   | TEST_STATEID, VERIFY,         |
   |                                   | WANT_DELEGATION, WRITE        |
   | NFS4ERR_UNKNOWN_LAYOUTTYPE        | CB_LAYOUTRECALL,              |
   |                                   | GETDEVICEINFO, GETDEVICELIST, |
   |                                   | LAYOUTCOMMIT, LAYOUTGET,      |
   |                                   | LAYOUTRETURN, NVERIFY,        |
   |                                   | SETATTR, VERIFY               |
   | NFS4ERR_UNSAFE_COMPOUND           | CREATE, OPEN, OPENATTR        |
   | NFS4ERR_WRONGSEC                  | LINK, LOOKUP, LOOKUPP, OPEN,  |
   |                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |
   |                                   | RENAME, RESTOREFH             |
   | NFS4ERR_WRONG_CRED                | CLOSE, CREATE_SESSION,        |
   |                                   | DELEGPURGE, DELEGRETURN,      |
   |                                   | DESTROY_CLIENTID,             |
   |                                   | DESTROY_SESSION,              |
   |                                   | FREE_STATEID, LAYOUTCOMMIT,   |
   |                                   | LAYOUTRETURN, LOCK, LOCKT,    |
   |                                   | LOCKU, OPEN_DOWNGRADE,        |
   |                                   | RECLAIM_COMPLETE              |
   | NFS4ERR_WRONG_TYPE                | CB_LAYOUTRECALL,              |
   |                                   | CB_PUSH_DELEG, COMMIT,        |
   |                                   | GETATTR, LAYOUTGET,           |
   |                                   | LAYOUTRETURN, LINK, LOCK,     |
   |                                   | LOCKT, NVERIFY, OPEN,         |
   |                                   | OPENATTR, READ, READLINK,     |
   |                                   | RECLAIM_COMPLETE, SETATTR,    |
   |                                   | VERIFY, WANT_DELEGATION,      |
   |                                   | WRITE                         |
   | NFS4ERR_XDEV                      | LINK, RENAME                  |
   +-----------------------------------+-------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Table 8
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
表8
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16--NFSv4-1-Procedures">
16. NFSv4.1 Procedures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. NFSv4.1の手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both procedures, NULL and COMPOUND, MUST be implemented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NULLとCOMPOUNDの両方のプロシージャを実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16-1--Procedure-0-NULL---No-Operation">
16.1. Procedure 0: NULL - No Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1. 手順0：NULL-操作なし
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16-1-1--ARGUMENTS">
16.1.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16-1-2--RESULTS">
16.1.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16-1-3--DESCRIPTION">
16.1.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is the standard NULL procedure with the standard void argument and void response. This procedure has no functionality associated with it. Because of this, it is sometimes used to measure the overhead of processing a service request. Therefore, the server SHOULD ensure that no unnecessary work is done in servicing this procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、標準のvoid引数とvoid応答を持つ標準のNULLプロシージャです。この手順には、関連する機能はありません。このため、サービス要求の処理のオーバーヘッドを測定するために使用されることがあります。したがって、サーバーは、この手順を実行する際に不要な作業が行われないようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16-1-4--ERRORS">
16.1.4. ERRORS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.4. エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
None.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
なし。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16-2--Procedure-1-COMPOUND---Compound-Operations">
16.2. Procedure 1: COMPOUND - Compound Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2. 手順1：COMPOUND-複合操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16-2-1--ARGUMENTS">
16.2.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum nfs_opnum4 {
    OP_ACCESS              = 3,
    OP_CLOSE               = 4,
    OP_COMMIT              = 5,
    OP_CREATE              = 6,
    OP_DELEGPURGE          = 7,
    OP_DELEGRETURN         = 8,
    OP_GETATTR             = 9,
    OP_GETFH               = 10,
    OP_LINK                = 11,
    OP_LOCK                = 12,
    OP_LOCKT               = 13,
    OP_LOCKU               = 14,
    OP_LOOKUP              = 15,
    OP_LOOKUPP             = 16,
    OP_NVERIFY             = 17,
    OP_OPEN                = 18,
    OP_OPENATTR            = 19,
    OP_OPEN_CONFIRM        = 20, /* Mandatory not-to-implement */
    OP_OPEN_DOWNGRADE      = 21,
    OP_PUTFH               = 22,
    OP_PUTPUBFH            = 23,
    OP_PUTROOTFH           = 24,
    OP_READ                = 25,
    OP_READDIR             = 26,
    OP_READLINK            = 27,
    OP_REMOVE              = 28,
    OP_RENAME              = 29,
    OP_RENEW               = 30, /* Mandatory not-to-implement */
    OP_RESTOREFH           = 31,
    OP_SAVEFH              = 32,
    OP_SECINFO             = 33,
    OP_SETATTR             = 34,
    OP_SETCLIENTID         = 35, /* Mandatory not-to-implement */
    OP_SETCLIENTID_CONFIRM = 36, /* Mandatory not-to-implement */
    OP_VERIFY              = 37,
    OP_WRITE               = 38,
    OP_RELEASE_LOCKOWNER   = 39, /* Mandatory not-to-implement */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* new operations for NFSv4.1 */
    OP_BACKCHANNEL_CTL     = 40,
    OP_BIND_CONN_TO_SESSION = 41,
    OP_EXCHANGE_ID         = 42,
    OP_CREATE_SESSION      = 43,
    OP_DESTROY_SESSION     = 44,
    OP_FREE_STATEID        = 45,
    OP_GET_DIR_DELEGATION  = 46,
    OP_GETDEVICEINFO       = 47,
    OP_GETDEVICELIST       = 48,
    OP_LAYOUTCOMMIT        = 49,
    OP_LAYOUTGET           = 50,
    OP_LAYOUTRETURN        = 51,
    OP_SECINFO_NO_NAME     = 52,
    OP_SEQUENCE            = 53,
    OP_SET_SSV             = 54,
    OP_TEST_STATEID        = 55,
    OP_WANT_DELEGATION     = 56,
    OP_DESTROY_CLIENTID    = 57,
    OP_RECLAIM_COMPLETE    = 58,
    OP_ILLEGAL             = 10044
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_argop4 switch (nfs_opnum4 argop) {
    case OP_ACCESS:        ACCESS4args opaccess;
    case OP_CLOSE:         CLOSE4args opclose;
    case OP_COMMIT:        COMMIT4args opcommit;
    case OP_CREATE:        CREATE4args opcreate;
    case OP_DELEGPURGE:    DELEGPURGE4args opdelegpurge;
    case OP_DELEGRETURN:   DELEGRETURN4args opdelegreturn;
    case OP_GETATTR:       GETATTR4args opgetattr;
    case OP_GETFH:         void;
    case OP_LINK:          LINK4args oplink;
    case OP_LOCK:          LOCK4args oplock;
    case OP_LOCKT:         LOCKT4args oplockt;
    case OP_LOCKU:         LOCKU4args oplocku;
    case OP_LOOKUP:        LOOKUP4args oplookup;
    case OP_LOOKUPP:       void;
    case OP_NVERIFY:       NVERIFY4args opnverify;
    case OP_OPEN:          OPEN4args opopen;
    case OP_OPENATTR:      OPENATTR4args opopenattr;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Not for NFSv4.1 */
    case OP_OPEN_CONFIRM:  OPEN_CONFIRM4args opopen_confirm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_OPEN_DOWNGRADE: OPEN_DOWNGRADE4args opopen_downgrade;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_OPEN_DOWNGRADE：OPEN_DOWNGRADE4args opopen_downgrade;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    case OP_PUTFH:         PUTFH4args opputfh;
    case OP_PUTPUBFH:      void;
    case OP_PUTROOTFH:     void;
    case OP_READ:          READ4args opread;
    case OP_READDIR:       READDIR4args opreaddir;
    case OP_READLINK:      void;
    case OP_REMOVE:        REMOVE4args opremove;
    case OP_RENAME:        RENAME4args oprename;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Not for NFSv4.1 */
    case OP_RENEW:         RENEW4args oprenew;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    case OP_RESTOREFH:     void;
    case OP_SAVEFH:        void;
    case OP_SECINFO:       SECINFO4args opsecinfo;
    case OP_SETATTR:       SETATTR4args opsetattr;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Not for NFSv4.1 */
    case OP_SETCLIENTID: SETCLIENTID4args opsetclientid;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Not for NFSv4.1 */
    case OP_SETCLIENTID_CONFIRM: SETCLIENTID_CONFIRM4args
                                   opsetclientid_confirm;
    case OP_VERIFY:        VERIFY4args opverify;
    case OP_WRITE:         WRITE4args opwrite;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Not for NFSv4.1 */
    case OP_RELEASE_LOCKOWNER:
                           RELEASE_LOCKOWNER4args
                           oprelease_lockowner;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Operations new to NFSv4.1 */
    case OP_BACKCHANNEL_CTL:
                           BACKCHANNEL_CTL4args opbackchannel_ctl;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_BIND_CONN_TO_SESSION: BIND_CONN_TO_SESSION4args opbind_conn_to_session;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_BIND_CONN_TO_SESSION：BIND_CONN_TO_SESSION4args opbind_conn_to_session;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_EXCHANGE_ID: EXCHANGE_ID4args opexchange_id;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_EXCHANGE_ID：EXCHANGE_ID4args opexchange_id;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_CREATE_SESSION: CREATE_SESSION4args opcreate_session;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_CREATE_SESSION：CREATE_SESSION4args opcreate_session;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_DESTROY_SESSION: DESTROY_SESSION4args opdestroy_session;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_DESTROY_SESSION：DESTROY_SESSION4args opdestroy_session;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_FREE_STATEID: FREE_STATEID4args opfree_stateid;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_FREE_STATEID：FREE_STATEID4args opgree_stateid;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_GET_DIR_DELEGATION: GET_DIR_DELEGATION4args opget_dir_delegation;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_GET_DIR_DELEGATION：GET_DIR_DELEGATION4args opget_dir_delegation;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    case OP_GETDEVICEINFO: GETDEVICEINFO4args opgetdeviceinfo;
    case OP_GETDEVICELIST: GETDEVICELIST4args opgetdevicelist;
    case OP_LAYOUTCOMMIT:  LAYOUTCOMMIT4args oplayoutcommit;
    case OP_LAYOUTGET:     LAYOUTGET4args oplayoutget;
    case OP_LAYOUTRETURN:  LAYOUTRETURN4args oplayoutreturn;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_SECINFO_NO_NAME: SECINFO_NO_NAME4args opsecinfo_no_name;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_SECINFO_NO_NAME：SECINFO_NO_NAME4args opsecinfo_no_name;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    case OP_SEQUENCE:      SEQUENCE4args opsequence;
    case OP_SET_SSV:       SET_SSV4args opset_ssv;
    case OP_TEST_STATEID:  TEST_STATEID4args optest_stateid;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_WANT_DELEGATION: WANT_DELEGATION4args opwant_delegation;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_WANT_DELEGATION：WANT_DELEGATION4args opwant_delegation;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_DESTROY_CLIENTID: DESTROY_CLIENTID4args opdestroy_clientid;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_DESTROY_CLIENTID：DESTROY_CLIENTID4args opdestroy_clientid;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_RECLAIM_COMPLETE: RECLAIM_COMPLETE4args opreclaim_complete;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_RECLAIM_COMPLETE：RECLAIM_COMPLETE4args opreclaim_complete;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Operations not new to NFSv4.1 */
    case OP_ILLEGAL:       void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COMPOUND4args {
           utf8str_cs      tag;
           uint32_t        minorversion;
           nfs_argop4      argarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16-2-2--RESULTS">
16.2.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_resop4 switch (nfs_opnum4 resop) {
    case OP_ACCESS:        ACCESS4res opaccess;
    case OP_CLOSE:         CLOSE4res opclose;
    case OP_COMMIT:        COMMIT4res opcommit;
    case OP_CREATE:        CREATE4res opcreate;
    case OP_DELEGPURGE:    DELEGPURGE4res opdelegpurge;
    case OP_DELEGRETURN:   DELEGRETURN4res opdelegreturn;
    case OP_GETATTR:       GETATTR4res opgetattr;
    case OP_GETFH:         GETFH4res opgetfh;
    case OP_LINK:          LINK4res oplink;
    case OP_LOCK:          LOCK4res oplock;
    case OP_LOCKT:         LOCKT4res oplockt;
    case OP_LOCKU:         LOCKU4res oplocku;
    case OP_LOOKUP:        LOOKUP4res oplookup;
    case OP_LOOKUPP:       LOOKUPP4res oplookupp;
    case OP_NVERIFY:       NVERIFY4res opnverify;
    case OP_OPEN:          OPEN4res opopen;
    case OP_OPENATTR:      OPENATTR4res opopenattr;
    /* Not for NFSv4.1 */
    case OP_OPEN_CONFIRM:  OPEN_CONFIRM4res opopen_confirm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_OPEN_DOWNGRADE: OPEN_DOWNGRADE4res opopen_downgrade;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_OPEN_DOWNGRADE：OPEN_DOWNGRADE4res opopen_downgrade;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    case OP_PUTFH:         PUTFH4res opputfh;
    case OP_PUTPUBFH:      PUTPUBFH4res opputpubfh;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    case OP_PUTROOTFH:     PUTROOTFH4res opputrootfh;
    case OP_READ:          READ4res opread;
    case OP_READDIR:       READDIR4res opreaddir;
    case OP_READLINK:      READLINK4res opreadlink;
    case OP_REMOVE:        REMOVE4res opremove;
    case OP_RENAME:        RENAME4res oprename;
    /* Not for NFSv4.1 */
    case OP_RENEW:         RENEW4res oprenew;
    case OP_RESTOREFH:     RESTOREFH4res oprestorefh;
    case OP_SAVEFH:        SAVEFH4res opsavefh;
    case OP_SECINFO:       SECINFO4res opsecinfo;
    case OP_SETATTR:       SETATTR4res opsetattr;
    /* Not for NFSv4.1 */
    case OP_SETCLIENTID: SETCLIENTID4res opsetclientid;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Not for NFSv4.1 */
    case OP_SETCLIENTID_CONFIRM:
                           SETCLIENTID_CONFIRM4res
                                   opsetclientid_confirm;
    case OP_VERIFY:        VERIFY4res opverify;
    case OP_WRITE:         WRITE4res opwrite;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Not for NFSv4.1 */
    case OP_RELEASE_LOCKOWNER:
                           RELEASE_LOCKOWNER4res
                                   oprelease_lockowner;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Operations new to NFSv4.1 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_BACKCHANNEL_CTL: BACKCHANNEL_CTL4res opbackchannel_ctl;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_BACKCHANNEL_CTL：BACKCHANNEL_CTL4res opbackchannel_ctl;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_BIND_CONN_TO_SESSION: BIND_CONN_TO_SESSION4res opbind_conn_to_session;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_BIND_CONN_TO_SESSION：BIND_CONN_TO_SESSION4res opbind_conn_to_session;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_EXCHANGE_ID: EXCHANGE_ID4res opexchange_id;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_EXCHANGE_ID：EXCHANGE_ID4res opexchange_id;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_CREATE_SESSION: CREATE_SESSION4res opcreate_session;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_CREATE_SESSION：CREATE_SESSION4res opcreate_session;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_DESTROY_SESSION: DESTROY_SESSION4res opdestroy_session;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_DESTROY_SESSION：DESTROY_SESSION4res opdestroy_session;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_FREE_STATEID: FREE_STATEID4res opfree_stateid;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_FREE_STATEID：FREE_STATEID4res opgree_stateid;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_GET_DIR_DELEGATION: GET_DIR_DELEGATION4res opget_dir_delegation;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_GET_DIR_DELEGATION：GET_DIR_DELEGATION4res opget_dir_delegation;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_GETDEVICEINFO: GETDEVICEINFO4res opgetdeviceinfo;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_GETDEVICEINFO：GETDEVICEINFO4res opgetdeviceinfo;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_GETDEVICELIST: GETDEVICELIST4res opgetdevicelist;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_GETDEVICELIST：GETDEVICELIST4res opgetdevicelist;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    case OP_LAYOUTCOMMIT:  LAYOUTCOMMIT4res oplayoutcommit;
    case OP_LAYOUTGET:     LAYOUTGET4res oplayoutget;
    case OP_LAYOUTRETURN:  LAYOUTRETURN4res oplayoutreturn;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_SECINFO_NO_NAME: SECINFO_NO_NAME4res opsecinfo_no_name;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_SECINFO_NO_NAME：SECINFO_NO_NAME4res opsecinfo_no_name;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    case OP_SEQUENCE:      SEQUENCE4res opsequence;
    case OP_SET_SSV:       SET_SSV4res opset_ssv;
    case OP_TEST_STATEID:  TEST_STATEID4res optest_stateid;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_WANT_DELEGATION: WANT_DELEGATION4res opwant_delegation;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_WANT_DELEGATION：WANT_DELEGATION4res opwant_delegation;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_DESTROY_CLIENTID:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_DESTROY_CLIENTID：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
DESTROY_CLIENTID4res opdestroy_clientid;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
DESTROY_CLIENTID4res opdestroy_clientid;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_RECLAIM_COMPLETE: RECLAIM_COMPLETE4res opreclaim_complete;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_RECLAIM_COMPLETE：RECLAIM_COMPLETE4res opreclaim_complete;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Operations not new to NFSv4.1 */
    case OP_ILLEGAL:       ILLEGAL4res opillegal;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COMPOUND4res {
           nfsstat4        status;
           utf8str_cs      tag;
           nfs_resop4      resarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16-2-3--DESCRIPTION">
16.2.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMPOUND procedure is used to combine one or more NFSv4 operations into a single RPC request. The server interprets each of the operations in turn. If an operation is executed by the server and the status of that operation is NFS4_OK, then the next operation in the COMPOUND procedure is executed. The server continues this process until there are no more operations to be executed or until one of the operations has a status value other than NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャは、1つ以上のNFSv4操作を単一のRPC要求に結合するために使用されます。サーバーは各操作を順番に解釈します。サーバーによって操作が実行され、その操作のステータスがNFS4_OKである場合、COMPOUNDプロシージャの次の操作が実行されます。サーバーは、実行する操作がなくなるまで、または操作の1つがNFS4_OK以外のステータス値になるまで、このプロセスを続行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the processing of the COMPOUND procedure, the server may find that it does not have the available resources to execute any or all of the operations within the COMPOUND sequence. See Section 2.10.6.4 for a more detailed discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャの処理中に、サーバーは、COMPOUNDシーケンス内の操作の一部またはすべてを実行するために使用できるリソースがないことに気付く場合があります。詳細については、セクション2.10.6.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server will generally choose between two methods of decoding the client&#39;s request. The first would be the traditional one-pass XDR decode. If there is an XDR decoding error in this case, the RPC XDR decode error would be returned. The second method would be to make an initial pass to decode the basic COMPOUND request and then to XDR decode the individual operations; the most interesting is the decode of attributes. In this case, the server may encounter an XDR decode error during the second pass. If it does, the server would return the error NFS4ERR_BADXDR to signify the decode error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは通常、クライアントの要求をデコードする2つの方法から選択します。 1つ目は、従来のワンパスXDRデコードです。この場合にXDRデコードエラーが発生すると、RPC XDRデコードエラーが返されます。 2番目の方法は、最初のパスを作成して基本的なCOMPOUND要求をデコードし、次にXDRで個々の操作をデコードすることです。最も興味深いのは、属性のデコードです。この場合、サーバーは2回目のパス中にXDRデコードエラーを検出する可能性があります。その場合、サーバーはエラーNFS4ERR_BADXDRを返し、デコードエラーを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMPOUND arguments contain a &#34;minorversion&#34; field. For NFSv4.1, the value for this field is 1. If the server receives a COMPOUND procedure with a minorversion field value that it does not support, the server MUST return an error of NFS4ERR_MINOR_VERS_MISMATCH and a zero-length resultdata array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND引数には、「minorversion」フィールドが含まれています。 NFSv4.1の場合、このフィールドの値は1です。サーバーがサポートしていないマイナーバージョンフィールド値を持つCOMPOUNDプロシージャを受信した場合、サーバーはNFS4ERR_MINOR_VERS_MISMATCHのエラーと長さゼロの結果データ配列を返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Contained within the COMPOUND results is a &#34;status&#34; field. If the results array length is non-zero, this status must be equivalent to the status of the last operation that was executed within the COMPOUND procedure. Therefore, if an operation incurred an error then the &#34;status&#34; value will be the same error value as is being returned for the operation that failed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND結果には、「ステータス」フィールドが含まれています。結果の配列の長さがゼロ以外の場合、このステータスはCOMPOUNDプロシージャ内で実行された最後の操作のステータスと同じである必要があります。したがって、操作でエラーが発生した場合、「ステータス」の値は、失敗した操作で返されるエラー値と同じになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Note that operations zero and one are not defined for the COMPOUND procedure. Operation 2 is not defined and is reserved for future definition and use with minor versioning. If the server receives an operation array that contains operation 2 and the minorversion field has a value of zero, an error of NFS4ERR_OP_ILLEGAL, as described in the next paragraph, is returned to the client. If an operation array contains an operation 2 and the minorversion field is non-zero and the server does not support the minor version, the server returns an error of NFS4ERR_MINOR_VERS_MISMATCH. Therefore, the NFS4ERR_MINOR_VERS_MISMATCH error takes precedence over all other errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
COMPOUNDプロシージャには、操作0と1が定義されていないことに注意してください。操作2は定義されておらず、将来の定義およびマイナーバージョン管理での使用のために予約されています。サーバーが操作2を含む操作配列を受信し、minorversionフィールドの値がゼロの場合、次の段落で説明するように、NFS4ERR_OP_ILLEGALのエラーがクライアントに返されます。操作配列に操作2が含まれ、minorversionフィールドがゼロ以外であり、サーバーがマイナーバージョンをサポートしていない場合、サーバーはNFS4ERR_MINOR_VERS_MISMATCHのエラーを返します。したがって、NFS4ERR_MINOR_VERS_MISMATCHエラーは、他のすべてのエラーよりも優先されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible that the server receives a request that contains an operation that is less than the first legal operation (OP_ACCESS) or greater than the last legal operation (OP_RELEASE_LOCKOWNER). In this case, the server&#39;s response will encode the opcode OP_ILLEGAL rather than the illegal opcode of the request. The status field in the ILLEGAL return results will be set to NFS4ERR_OP_ILLEGAL. The COMPOUND procedure&#39;s return results will also be NFS4ERR_OP_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが、最初の正当な操作（OP_ACCESS）よりも小さい操作、または最後の正当な操作（OP_RELEASE_LOCKOWNER）よりも大きい操作を含む要求を受信する可能性があります。この場合、サーバーの応答は、要求の不正なオペコードではなく、オペコードOP_ILLEGALをエンコードします。 ILLEGALの戻り結果のステータスフィールドはNFS4ERR_OP_ILLEGALに設定されます。 COMPOUNDプロシージャの戻り結果もNFS4ERR_OP_ILLEGALになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The definition of the &#34;tag&#34; in the request is left to the implementor. It may be used to summarize the content of the Compound request for the benefit of packet-sniffers and engineers debugging implementations. However, the value of &#34;tag&#34; in the response SHOULD be the same value as provided in the request. This applies to the tag field of the CB_COMPOUND procedure as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスト内の「タグ」の定義は実装者に任されています。パケットスニファーとエンジニアのデバッグ実装の利益のために、複合リクエストの内容を要約するために使用できます。ただし、応答の「タグ」の値は、要求で提供されたものと同じ値である必要があります。これは、CB_COMPOUNDプロシージャのタグフィールドにも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16-2-3-1--Current-Filehandle-and-Stateid">
16.2.3.1. Current Filehandle and Stateid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.3.1. 現在のファイルハンドルと状態ID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMPOUND procedure offers a simple environment for the execution of the operations specified by the client. The first two relate to the filehandle while the second two relate to the current stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDプロシージャは、クライアントが指定した操作を実行するためのシンプルな環境を提供します。最初の2つはファイルハンドルに関連し、次の2つは現在の状態IDに関連しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16-2-3-1-1--Current-Filehandle">
16.2.3.1.1. Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.3.1.1. 現在のファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current and saved filehandles are used throughout the protocol. Most operations implicitly use the current filehandle as an argument, and many set the current filehandle as part of the results. The combination of client-specified sequences of operations and current and saved filehandle arguments and results allows for greater protocol flexibility. The best or easiest example of current filehandle usage is a sequence like the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在および保存されているファイルハンドルは、プロトコル全体で使用されます。ほとんどの操作は暗黙的に現在のファイルハンドルを引数として使用し、多くの操作は現在のファイルハンドルを結果の一部として設定します。クライアント指定の操作シーケンスと、現在および保存されているファイルハンドル引数と結果の組み合わせにより、プロトコルの柔軟性が向上します。現在のファイルハンドルの使用法の最良または最も簡単な例は、次のようなシーケンスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         PUTFH fh1              {fh1}
         LOOKUP &#34;compA&#34;         {fh2}
         GETATTR                {fh2}
         LOOKUP &#34;compB&#34;         {fh3}
         GETATTR                {fh3}
         LOOKUP &#34;compC&#34;         {fh4}
         GETATTR                {fh4}
         GETFH
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this example, the PUTFH (Section 18.19) operation explicitly sets the current filehandle value while the result of each LOOKUP operation sets the current filehandle value to the resultant file system object. Also, the client is able to insert GETATTR operations using the current filehandle as an argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例では、PUTFH（セクション18.19）操作は現在のファイルハンドル値を明示的に設定し、各LOOKUP操作の結果は現在のファイルハンドル値を結果のファイルシステムオブジェクトに設定します。また、クライアントは、現在のファイルハンドルを引数として使用して、GETATTR操作を挿入できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PUTROOTFH (Section 18.21) and PUTPUBFH (Section 18.20) operations also set the current filehandle. The above example would replace &#34;PUTFH fh1&#34; with PUTROOTFH or PUTPUBFH with no filehandle argument in order to achieve the same effect (on the assumption that &#34;compA&#34; is directly below the root of the namespace).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTROOTFH（セクション18.21）およびPUTPUBFH（セクション18.20）操作も、現在のファイルハンドルを設定します。上記の例では、同じ効果を達成するために、「PUTFH fh1」をファイルハンドル引数なしでPUTROOTFHまたはPUTPUBFHに置き換えます（「compA」が名前空間のルートのすぐ下にあるという前提）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Along with the current filehandle, there is a saved filehandle. While the current filehandle is set as the result of operations like LOOKUP, the saved filehandle must be set directly with the use of the SAVEFH operation. The SAVEFH operation copies the current filehandle value to the saved value. The saved filehandle value is used in combination with the current filehandle value for the LINK and RENAME operations. The RESTOREFH operation will copy the saved filehandle value to the current filehandle value; as a result, the saved filehandle value may be used a sort of &#34;scratch&#34; area for the client&#39;s series of operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルに加えて、保存されたファイルハンドルがあります。現在のファイルハンドルはLOOKUPなどの操作の結果として設定されますが、保存されたファイルハンドルはSAVEFH操作を使用して直接設定する必要があります。 SAVEFH操作は、現在のファイルハンドル値を保存された値にコピーします。保存されたファイルハンドル値は、LINKおよびRENAME操作の現在のファイルハンドル値と組み合わせて使用​​されます。 RESTOREFH操作は、保存されたファイルハンドル値を現在のファイルハンドル値にコピーします。その結果、保存されたファイルハンドル値は、クライアントの一連の操作のための一種の「スクラッチ」領域として使用される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16-2-3-1-2--Current-Stateid">
16.2.3.1.2. Current Stateid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.3.1.2. 現在の州名
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With NFSv4.1, additions of a current stateid and a saved stateid have been made to the COMPOUND processing environment; this allows for the passing of stateids between operations. There are no changes to the syntax of the protocol, only changes to the semantics of a few operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1では、COMPOUND処理環境に現在の状態IDと保存された状態IDが追加されました。これにより、操作間で状態IDを渡すことができます。プロトコルの構文に変更はなく、いくつかの操作のセマンティクスのみが変更されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A &#34;current stateid&#34; is the stateid that is associated with the current filehandle. The current stateid may only be changed by an operation that modifies the current filehandle or returns a stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「現在の状態ID」は、現在のファイルハンドルに関連付けられている状態IDです。現在の状態IDは、現在のファイルハンドルを変更するか、状態IDを返す操作によってのみ変更できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   If an operation returns a stateid, it MUST set the current stateid to
   the returned value.  If an operation sets the current filehandle but
   does not return a stateid, the current stateid MUST be set to the
   all-zeros special stateid, i.e., (seqid, other) = (0, 0).  If an
   operation uses a stateid as an argument but does not return a
   stateid, the current stateid MUST NOT be changed.  For example,
   PUTFH, PUTROOTFH, and PUTPUBFH will change the current server state
   from {ocfh, (osid)} to {cfh, (0, 0)}, while LOCK will change the
   current state from {cfh, (osid} to {cfh, (nsid)}.  Operations like
   LOOKUP that transform a current filehandle and component name into a
   new current filehandle will also change the current state to {0, 0}.
   The SAVEFH and RESTOREFH operations will save and restore both the
   current filehandle and the current stateid as a set.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following example is the common case of a simple READ operation with a normal stateid showing that the PUTFH initializes the current stateid to (0, 0). The subsequent READ with stateid (sid1) leaves the current stateid unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例は、PUTFHが現在の状態IDを（0、0）に初期化することを示す、通常の状態IDを持つ単純なREAD操作の一般的なケースです。状態ID（sid1）を使用した後続のREADでは、現在の状態IDは変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       PUTFH fh1                             - -&gt; {fh1, (0, 0)}
       READ (sid1), 0, 1024      {fh1, (0, 0)} -&gt; {fh1, (0, 0)}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This next example performs an OPEN with the root filehandle and, as a result, generates stateid (sid1). The next operation specifies the READ with the argument stateid set such that (seqid, other) are equal to (1, 0), but the current stateid set by the previous operation is actually used when the operation is evaluated. This allows correct interaction with any existing, potentially conflicting, locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例では、ルートファイルハンドルを使用してOPENを実行し、その結果、stateid（sid1）を生成します。次の操作は、（seqid、other）が（1、0）に等しくなるように引数stateidを設定してREADを指定しますが、前の操作によって設定された現在のstateidは、操作が評価されるときに実際に使用されます。これにより、既存の、潜在的に競合するロックとの正しい相互作用が可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       PUTROOTFH                             - -&gt; {fh1, (0, 0)}
       OPEN &#34;compA&#34;              {fh1, (0, 0)} -&gt; {fh2, (sid1)}
       READ (1, 0), 0, 1024      {fh2, (sid1)} -&gt; {fh2, (sid1)}
       CLOSE (1, 0)              {fh2, (sid1)} -&gt; {fh2, (sid2)}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This next example is similar to the second in how it passes the stateid sid2 generated by the LOCK operation to the next READ operation. This allows the client to explicitly surround a single I/O operation with a lock and its appropriate stateid to guarantee correctness with other client locks. The example also shows how SAVEFH and RESTOREFH can save and later reuse a filehandle and stateid, passing them as the current filehandle and stateid to a READ operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この次の例は、LOCK操作によって生成されたstateid sid2を次のREAD操作に渡す方法が2番目の例と似ています。これにより、クライアントは、単一のI / O操作をロックとその適切な状態IDで明示的に囲み、他のクライアントロックとの正確性を保証できます。この例では、SAVEFHおよびRESTOREFHがファイルハンドルと状態IDを保存して後で再利用し、それらを現在のファイルハンドルと状態IDとしてREAD操作に渡す方法も示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       PUTFH fh1                             - -&gt; {fh1, (0, 0)}
       LOCK 0, 1024, (sid1)      {fh1, (sid1)} -&gt; {fh1, (sid2)}
       READ (1, 0), 0, 1024      {fh1, (sid2)} -&gt; {fh1, (sid2)}
       LOCKU 0, 1024, (1, 0)     {fh1, (sid2)} -&gt; {fh1, (sid3)}
       SAVEFH                    {fh1, (sid3)} -&gt; {fh1, (sid3)}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       PUTFH fh2                 {fh1, (sid3)} -&gt; {fh2, (0, 0)}
       WRITE (1, 0), 0, 1024     {fh2, (0, 0)} -&gt; {fh2, (0, 0)}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       RESTOREFH                 {fh2, (0, 0)} -&gt; {fh1, (sid3)}
       READ (1, 0), 1024, 1024   {fh1, (sid3)} -&gt; {fh1, (sid3)}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The final example shows a disallowed use of the current stateid. The client is attempting to implicitly pass an anonymous special stateid, (0,0), to the READ operation. The server MUST return NFS4ERR_BAD_STATEID in the reply to the READ operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の例は、現在のstateidの使用が許可されていないことを示しています。クライアントは匿名の特別な状態ID（0,0）を暗黙的にREAD操作に渡そうとしています。サーバーは、READ操作への応答でNFS4ERR_BAD_STATEIDを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       PUTFH fh1                             - -&gt; {fh1, (0, 0)}
       READ (1, 0), 0, 1024      {fh1, (0, 0)} -&gt; NFS4ERR_BAD_STATEID
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16-2-4--ERRORS">
16.2.4. ERRORS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.4. エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND will of course return every error that each operation on the fore channel can return (see Table 6). However, if COMPOUND returns zero operations, obviously the error returned by COMPOUND has nothing to do with an error returned by an operation. The list of errors COMPOUND will return if it processes zero operations include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDはもちろん、フォアチャネルの各操作が返す可能性があるすべてのエラーを返します（表6を参照）。ただし、COMPOUNDがゼロの操作を返す場合、COMPOUNDが返すエラーは、操作が返すエラーとは関係ありません。 COMPOUNDが処理する操作がゼロの場合、COMPOUNDが返すエラーのリストは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-26">
COMPOUND Error Returns
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-26">
COMPOUNDエラーが返される
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------------------------+------------------------------------+
   | Error                        | Notes                              |
   +------------------------------+------------------------------------+
   | NFS4ERR_BADCHAR              | The tag argument has a character   |
   |                              | the replier does not support.      |
   | NFS4ERR_BADXDR               |                                    |
   | NFS4ERR_DELAY                |                                    |
   | NFS4ERR_INVAL                | The tag argument is not in UTF-8   |
   |                              | encoding.                          |
   | NFS4ERR_MINOR_VERS_MISMATCH  |                                    |
   | NFS4ERR_SERVERFAULT          |                                    |
   | NFS4ERR_TOO_MANY_OPS         |                                    |
   | NFS4ERR_REP_TOO_BIG          |                                    |
   | NFS4ERR_REP_TOO_BIG_TO_CACHE |                                    |
   | NFS4ERR_REQ_TOO_BIG          |                                    |
   +------------------------------+------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Table 9
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
表9
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="17--Operations-REQUIRED-RECOMMENDED-or-OPTIONAL">
17. Operations: REQUIRED, RECOMMENDED, or OPTIONAL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. 操作：REQUIRED、RECOMMENDED、またはOPTIONAL
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following tables summarize the operations of the NFSv4.1 protocol and the corresponding designation of REQUIRED, RECOMMENDED, and OPTIONAL to implement or MUST NOT implement. The designation of MUST NOT implement is reserved for those operations that were defined in NFSv4.0 and MUST NOT be implemented in NFSv4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の表は、NFSv4.1プロトコルの操作と、対応するREQUIRED、RECOMMENDED、およびOPTIONALの対応する指定をまとめたものです。実装してはならないの指定は、NFSv4.0で定義された操作のために予約されており、NFSv4.1で実装してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the most part, the REQUIRED, RECOMMENDED, or OPTIONAL designation for operations sent by the client is for the server implementation. The client is generally required to implement the operations needed for the operating environment for which it serves. For example, a read-only NFSv4.1 client would have no need to implement the WRITE operation and is not required to do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどの場合、クライアントから送信された操作のREQUIRED、RECOMMENDED、またはOPTIONALの指定は、サーバーの実装用です。クライアントは通常、サービスを提供するオペレーティング環境に必要な操作を実装する必要があります。たとえば、読み取り専用のNFSv4.1クライアントは、WRITE操作を実装する必要がなく、実装する必要もありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The REQUIRED or OPTIONAL designation for callback operations sent by the server is for both the client and server. Generally, the client has the option of creating the backchannel and sending the operations on the fore channel that will be a catalyst for the server sending callback operations. A partial exception is CB_RECALL_SLOT; the only way the client can avoid supporting this operation is by not creating a backchannel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーによって送信されるコールバック操作の必須またはオプションの指定は、クライアントとサーバーの両方に適用されます。通常、クライアントには、バックチャネルを作成し、サーバーがコールバック操作を送信するための触媒となるフォアチャネルで操作を送信するオプションがあります。部分的な例外はCB_RECALL_SLOTです。クライアントがこの操作のサポートを回避できる唯一の方法は、バックチャネルを作成しないことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since this is a summary of the operations and their designation, there are subtleties that are not presented here. Therefore, if there is a question of the requirements of implementation, the operation descriptions themselves must be consulted along with other relevant explanatory text within this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは操作とその指定の要約であるため、ここには示されていない微妙な点があります。したがって、実装の要件について質問がある場合は、この仕様内の他の関連する説明文とともに操作の説明自体を参照する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The abbreviations used in the second and third columns of the table are defined as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表の2列目と3列目で使用されている略語は、次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ REQUIRED to implement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装が必要なREQ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REC RECOMMEND to implement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装するREC推奨
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPT OPTIONAL to implement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装するOPT OPTIONAL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MNI MUST NOT implement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MNIは実装してはならない
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the NFSv4.1 features that are OPTIONAL, the operations that support those features are OPTIONAL, and the server would return NFS4ERR_NOTSUPP in response to the client&#39;s use of those operations. If an OPTIONAL feature is supported, it is possible that a set of operations related to the feature become REQUIRED to implement. The third column of the table designates the feature(s) and if the operation is REQUIRED or OPTIONAL in the presence of support for the feature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPTIONALであるNFSv4.1機能の場合、それらの機能をサポートする操作はOPTIONALであり、サーバーはクライアントによるこれらの操作の使用に応じてNFS4ERR_NOTSUPPを返します。 OPTIONAL機能がサポートされている場合、その機能に関連する一連の操作を実装する必要が生じる可能性があります。表の3列目は、機能と、その機能がサポートされている場合に操作が必須かオプションかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPTIONAL features identified and their abbreviations are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
識別されたオプションの機能とその省略形は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFS Parallel NFS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFS並列NFS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 FDELG File Delegations DDELG Directory Delegations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
FDELGファイルの委任DDELGディレクトリの委任
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-32">
Operations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-32">
操作
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----------------------+------------+--------------+----------------+
   | Operation            | REQ, REC,  | Feature      | Definition     |
   |                      | OPT, or    | (REQ, REC,   |                |
   |                      | MNI        | or OPT)      |                |
   +----------------------+------------+--------------+----------------+
   | ACCESS               | REQ        |              | Section 18.1   |
   | BACKCHANNEL_CTL      | REQ        |              | Section 18.33  |
   | BIND_CONN_TO_SESSION | REQ        |              | Section 18.34  |
   | CLOSE                | REQ        |              | Section 18.2   |
   | COMMIT               | REQ        |              | Section 18.3   |
   | CREATE               | REQ        |              | Section 18.4   |
   | CREATE_SESSION       | REQ        |              | Section 18.36  |
   | DELEGPURGE           | OPT        | FDELG (REQ)  | Section 18.5   |
   | DELEGRETURN          | OPT        | FDELG,       | Section 18.6   |
   |                      |            | DDELG, pNFS  |                |
   |                      |            | (REQ)        |                |
   | DESTROY_CLIENTID     | REQ        |              | Section 18.50  |
   | DESTROY_SESSION      | REQ        |              | Section 18.37  |
   | EXCHANGE_ID          | REQ        |              | Section 18.35  |
   | FREE_STATEID         | REQ        |              | Section 18.38  |
   | GETATTR              | REQ        |              | Section 18.7   |
   | GETDEVICEINFO        | OPT        | pNFS (REQ)   | Section 18.40  |
   | GETDEVICELIST        | OPT        | pNFS (OPT)   | Section 18.41  |
   | GETFH                | REQ        |              | Section 18.8   |
   | GET_DIR_DELEGATION   | OPT        | DDELG (REQ)  | Section 18.39  |
   | LAYOUTCOMMIT         | OPT        | pNFS (REQ)   | Section 18.42  |
   | LAYOUTGET            | OPT        | pNFS (REQ)   | Section 18.43  |
   | LAYOUTRETURN         | OPT        | pNFS (REQ)   | Section 18.44  |
   | LINK                 | OPT        |              | Section 18.9   |
   | LOCK                 | REQ        |              | Section 18.10  |
   | LOCKT                | REQ        |              | Section 18.11  |
   | LOCKU                | REQ        |              | Section 18.12  |
   | LOOKUP               | REQ        |              | Section 18.13  |
   | LOOKUPP              | REQ        |              | Section 18.14  |
   | NVERIFY              | REQ        |              | Section 18.15  |
   | OPEN                 | REQ        |              | Section 18.16  |
   | OPENATTR             | OPT        |              | Section 18.17  |
   | OPEN_CONFIRM         | MNI        |              | N/A            |
   | OPEN_DOWNGRADE       | REQ        |              | Section 18.18  |
   | PUTFH                | REQ        |              | Section 18.19  |
   | PUTPUBFH             | REQ        |              | Section 18.20  |
   | PUTROOTFH            | REQ        |              | Section 18.21  |
   | READ                 | REQ        |              | Section 18.22  |
   | READDIR              | REQ        |              | Section 18.23  |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | READLINK             | OPT        |              | Section 18.24  |
   | RECLAIM_COMPLETE     | REQ        |              | Section 18.51  |
   | RELEASE_LOCKOWNER    | MNI        |              | N/A            |
   | REMOVE               | REQ        |              | Section 18.25  |
   | RENAME               | REQ        |              | Section 18.26  |
   | RENEW                | MNI        |              | N/A            |
   | RESTOREFH            | REQ        |              | Section 18.27  |
   | SAVEFH               | REQ        |              | Section 18.28  |
   | SECINFO              | REQ        |              | Section 18.29  |
   | SECINFO_NO_NAME      | REC        | pNFS file    | Section 18.45, |
   |                      |            | layout (REQ) | Section 13.12  |
   | SEQUENCE             | REQ        |              | Section 18.46  |
   | SETATTR              | REQ        |              | Section 18.30  |
   | SETCLIENTID          | MNI        |              | N/A            |
   | SETCLIENTID_CONFIRM  | MNI        |              | N/A            |
   | SET_SSV              | REQ        |              | Section 18.47  |
   | TEST_STATEID         | REQ        |              | Section 18.48  |
   | VERIFY               | REQ        |              | Section 18.31  |
   | WANT_DELEGATION      | OPT        | FDELG (OPT)  | Section 18.49  |
   | WRITE                | REQ        |              | Section 18.32  |
   +----------------------+------------+--------------+----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-28">
Callback Operations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-28">
コールバック操作
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------------------+-----------+-------------+---------------+
   | Operation               | REQ, REC, | Feature     | Definition    |
   |                         | OPT, or   | (REQ, REC,  |               |
   |                         | MNI       | or OPT)     |               |
   +-------------------------+-----------+-------------+---------------+
   | CB_GETATTR              | OPT       | FDELG (REQ) | Section 20.1  |
   | CB_LAYOUTRECALL         | OPT       | pNFS (REQ)  | Section 20.3  |
   | CB_NOTIFY               | OPT       | DDELG (REQ) | Section 20.4  |
   | CB_NOTIFY_DEVICEID      | OPT       | pNFS (OPT)  | Section 20.12 |
   | CB_NOTIFY_LOCK          | OPT       |             | Section 20.11 |
   | CB_PUSH_DELEG           | OPT       | FDELG (OPT) | Section 20.5  |
   | CB_RECALL               | OPT       | FDELG,      | Section 20.2  |
   |                         |           | DDELG, pNFS |               |
   |                         |           | (REQ)       |               |
   | CB_RECALL_ANY           | OPT       | FDELG,      | Section 20.6  |
   |                         |           | DDELG, pNFS |               |
   |                         |           | (REQ)       |               |
   | CB_RECALL_SLOT          | REQ       |             | Section 20.8  |
   | CB_RECALLABLE_OBJ_AVAIL | OPT       | DDELG, pNFS | Section 20.7  |
   |                         |           | (REQ)       |               |
   | CB_SEQUENCE             | OPT       | FDELG,      | Section 20.9  |
   |                         |           | DDELG, pNFS |               |
   |                         |           | (REQ)       |               |
   | CB_WANTS_CANCELLED      | OPT       | FDELG,      | Section 20.10 |
   |                         |           | DDELG, pNFS |               |
   |                         |           | (REQ)       |               |
   +-------------------------+-----------+-------------+---------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18--NFSv4-1-Operations">
18. NFSv4.1 Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. NFSv4.1の操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-1--Operation-3-ACCESS---Check-Access-Rights">
18.1. Operation 3: ACCESS - Check Access Rights
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1. 操作3：アクセス-アクセス権の確認
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-1-1--ARGUMENTS">
18.1.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACCESS4_READ      = 0x00000001;
   const ACCESS4_LOOKUP    = 0x00000002;
   const ACCESS4_MODIFY    = 0x00000004;
   const ACCESS4_EXTEND    = 0x00000008;
   const ACCESS4_DELETE    = 0x00000010;
   const ACCESS4_EXECUTE   = 0x00000020;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ACCESS4args {
           /* CURRENT_FH: object */
           uint32_t        access;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-1-2--RESULTS">
18.1.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ACCESS4resok {
           uint32_t        supported;
           uint32_t        access;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union ACCESS4res switch (nfsstat4 status) {
    case NFS4_OK:
            ACCESS4resok   resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-1-3--DESCRIPTION">
18.1.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS determines the access rights that a user, as identified by the credentials in the RPC request, has with respect to the file system object specified by the current filehandle. The client encodes the set of access rights that are to be checked in the bit mask &#34;access&#34;. The server checks the permissions encoded in the bit mask. If a status of NFS4_OK is returned, two bit masks are included in the response. The first, &#34;supported&#34;, represents the access rights for which the server can verify reliably. The second, &#34;access&#34;, represents the access rights available to the user for the filehandle provided. On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESSは、RPC要求の資格情報によって識別されるように、ユーザーが現在のファイルハンドルで指定されたファイルシステムオブジェクトに対して持つアクセス権を決定します。クライアントは、ビットマスク「アクセス」でチェックされるアクセス権のセットをエンコードします。サーバーは、ビットマスクにエンコードされたアクセス許可をチェックします。 NFS4_OKのステータスが返された場合、2つのビットマスクが応答に含まれます。最初の「サポートされる」は、サーバーが確実に検証できるアクセス権を表します。 2番目の「アクセス」は、提供されたファイルハンドルに対してユーザーが利用できるアクセス権を表します。成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the reply&#39;s supported and access fields MUST NOT contain more values than originally set in the request&#39;s access field. For example, if the client sends an ACCESS operation with just the ACCESS4_READ value set and the server supports this value, the server MUST NOT set more than ACCESS4_READ in the supported field even if it could have reliably checked other values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答のサポートされているアクセスフィールドには、リクエストのアクセスフィールドに最初に設定されている値よりも多くの値を含めることはできません。たとえば、クライアントがACCESS4_READ値のみを設定してACCESS操作を送信し、サーバーがこの値をサポートする場合、サーバーは、他の値を確実にチェックできたとしても、サポートされているフィールドにACCESS4_READを超えて設定してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reply&#39;s access field MUST NOT contain more values than the supported field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
返信のアクセスフィールドには、サポートされているフィールドよりも多くの値を含めることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results of this operation are necessarily advisory in nature. A return status of NFS4_OK and the appropriate bit set in the bit mask do not imply that such access will be allowed to the file system object in the future. This is because access rights can be revoked by the server at any time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作の結果は、必然的に助言です。 NFS4_OKの戻りステータスとビットマスクに設定された適切なビットは、そのようなアクセスが将来ファイルシステムオブジェクトに許可されることを意味しません。これは、サーバーがいつでもアクセス権を取り消すことができるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following access permissions may be requested:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following access permissions may be requested:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_READ Read data from file or read a directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_READファイルからデータを読み取るか、ディレクトリを読み取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_LOOKUP Look up a name in a directory (no meaning for non-directory objects).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_LOOKUPディレクトリで名前を検索します（ディレクトリ以外のオブジェクトには意味がありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_MODIFY Rewrite existing file data or modify existing directory entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_MODIFY Rewrite existing file data or modify existing directory entries.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXTEND Write new data or add directory entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXTEND新しいデータを書き込むか、ディレクトリエントリを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_DELETE Delete an existing directory entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_DELETE既存のディレクトリエントリを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXECUTE Execute a regular file (no meaning for a directory).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXECUTE通常のファイルを実行します（ディレクトリには意味がありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXECUTE is a challenging semantic to implement because NFS provides remote file access, not remote execution. This leads to the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSはリモート実行ではなくリモートファイルアクセスを提供するため、ACCESS4_EXECUTEは実装が難しいセマンティクスです。これにより、次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Whether or not a regular file is executable ought to be the responsibility of the NFS client and not the server. And yet the ACCESS operation is specified to seemingly require a server to own that responsibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 通常のファイルが実行可能かどうかは、サーバーではなくNFSクライアントの責任である必要があります。それでもACCESS操作は、サーバーがその責任を負うように見えるように指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a client executes a regular file, it has to read the file from the server. Strictly speaking, the server should not allow the client to read a file being executed unless the user has read permissions on the file. Requiring explicit read permissions on executable files in order to access them over NFS is not going to be acceptable to some users and storage administrators. Historically, NFS servers have allowed a user to READ a file if the user has execute access to the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントが通常のファイルを実行するときは、サーバーからファイルを読み取る必要があります。厳密に言うと、サーバーは、ユーザーがファイルに対する読み取りアクセス許可を持っている場合を除き、実行中のファイルの読み取りをクライアントに許可してはなりません。一部のユーザーやストレージ管理者は、NFS経由でアクセスするために実行可能ファイルに明示的な読み取りアクセス許可を要求することは受け入れられません。歴史的に、ユーザーがファイルへの実行アクセス権を持っている場合、NFSサーバーはユーザーにファイルの読み取りを許可してきました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a practical example, the UNIX specification [52] states that an implementation claiming conformance to UNIX may indicate in the access() programming interface&#39;s result that a privileged user has execute rights, even if no execute permission bits are set on the regular file&#39;s attributes. It is possible to claim conformance to the UNIX specification and instead not indicate execute rights in that situation, which is true for some operating environments. Suppose the operating environments of the client and server are implementing the access() semantics for privileged users differently, and the ACCESS operation implementations of the client and server follow their respective access() semantics. This can cause undesired behavior:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実用的な例として、UNIX仕様[52]は、UNIXへの適合を主張する実装が、通常のファイルの属性に実行許可ビットが設定されていない場合でも、特権ユーザーが実行権限を持っていることをaccess()プログラミングインターフェイスの結果で示す可能性があると述べています。 UNIX仕様に準拠していると主張することは可能ですが、そのような状況では実行権を示さないことがあります。これは、一部のオペレーティング環境に当てはまります。クライアントとサーバーのオペレーティング環境が特権ユーザーのaccess()セマンティクスを異なる方法で実装しており、クライアントとサーバーのACCESS操作の実装がそれぞれのaccess()セマンティクスに従っているとします。これは望ましくない動作を引き起こす可能性があります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o Suppose the client&#39;s access() interface returns X_OK if the user is privileged and no execute permission bits are set on the regular file&#39;s attribute, and the server&#39;s access() interface does not return X_OK in that situation. Then the client will be unable to execute files stored on the NFS server that could be executed if stored on a non-NFS file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
oユーザーに特権があり、通常のファイルの属性に実行許可ビットが設定されていない場合にクライアントのaccess()インターフェースがX_OKを返し、その状況ではサーバーのaccess()インターフェースがX_OKを返さないとします。そうすると、クライアントはNFSサーバーに保存されているファイルを実行できなくなり、NFS以外のファイルシステムに保存されている場合は実行される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Suppose the client&#39;s access() interface does not return X_OK if the user is privileged, and no execute permission bits are set on the regular file&#39;s attribute, and the server&#39;s access() interface does return X_OK in that situation. Then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ユーザーに特権がある場合にクライアントのaccess()インターフェースがX_OKを返さず、通常のファイルの属性に実行許可ビットが設定されておらず、その状況でサーバーのaccess()インターフェースがX_OKを返すとします。次に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The client will be able to execute files stored on the NFS server that could be executed if stored on a non-NFS file system, unless the client&#39;s execution subsystem also checks for execute permission bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントは、NFSサーバーに格納されているファイルを実行できますが、クライアントの実行サブシステムが実行許可ビットもチェックしない限り、NFS以外のファイルシステムに格納されている場合に実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Even if the execution subsystem is checking for execute permission bits, there are more potential issues. For example, suppose the client is invoking access() to build a &#34;path search table&#34; of all executable files in the user&#39;s &#34;search path&#34;, where the path is a list of directories each containing executable files. Suppose there are two files each in separate directories of the search path, such that files have the same component name. In the first directory the file has no execute permission bits set, and in the second directory the file has execute bits set. The path search table will indicate that the first directory has the executable file, but the execute subsystem will fail to execute it. The command shell might fail to try the second file in the second directory. And even if it did, this is a potential performance issue. Clearly, the desired outcome for the client is for the path search table to not contain the first file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 実行サブシステムが実行許可ビットをチェックしている場合でも、さらに多くの潜在的な問題があります。たとえば、クライアントがaccess()を呼び出して、ユーザーの「検索パス」にあるすべての実行可能ファイルの「パス検索テーブル」を作成するとします。パスは、実行可能ファイルを含むディレクトリのリストです。検索パスの別々のディレクトリにそれぞれ2つのファイルがあり、ファイルに同じコンポーネント名が付いているとします。最初のディレクトリのファイルには実行許可ビットが設定されておらず、2番目のディレクトリのファイルには実行ビットが設定されています。パス検索テーブルは、最初のディレクトリに実行可能ファイルがあることを示しますが、実行サブシステムはその実行に失敗します。コマンドシェルは、2番目のディレクトリにある2番目のファイルの試行に失敗する場合があります。たとえそうであっても、これは潜在的なパフォーマンスの問題です。明らかに、クライアントにとって望ましい結果は、パス検索テーブルに最初のファイルが含まれていないことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To deal with the problems described above, the &#34;smart client, stupid server&#34; principle is used. The client owns overall responsibility for determining execute access and relies on the server to parse the execution permissions within the file&#39;s mode, acl, and dacl attributes. The rules for the client and server follow:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の問題に対処するために、「スマートクライアント、愚かなサーバー」の原則が使用されます。クライアントは、実行アクセスを決定する全体的な責任を負い、サーバーに依存して、ファイルのモード、acl、およびdacl属性内の実行権限を解析します。クライアントとサーバーのルールは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the client is sending ACCESS in order to determine if the user can read the file, the client SHOULD set ACCESS4_READ in the request&#39;s access field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ユーザーがファイルを読み取ることができるかどうかを判断するためにクライアントがACCESSを送信している場合、クライアントはリクエストのアクセスフィールドにACCESS4_READを設定する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the client&#39;s operating environment only grants execution to the user if the user has execute access according to the execute permissions in the mode, acl, and dacl attributes, then if the client wants to determine execute access, the client SHOULD send an ACCESS request with ACCESS4_EXECUTE bit set in the request&#39;s access field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ユーザーがmode、acl、およびdacl属性の実行アクセス権に従って実行アクセス権を持っている場合にのみ、クライアントのオペレーティング環境がユーザーに実行を許可する場合、クライアントが実行アクセス権を決定する必要がある場合、クライアントはACCESSリクエストを送信する必要があります（SHOULD）。リクエストのアクセスフィールドに設定されたACCESS4_EXECUTEビット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the client&#39;s operating environment grants execution to the user even if the user does not have execute access according to the execute permissions in the mode, acl, and dacl attributes, then if the client wants to determine execute access, it SHOULD send an ACCESS request with both the ACCESS4_EXECUTE and ACCESS4_READ bits set in the request&#39;s access field. This way, if any read or execute permission grants the user read or execute access (or if the server interprets the user as privileged), as indicated by the presence of ACCESS4_EXECUTE and/or ACCESS4_READ in the reply&#39;s access field, the client will be able to grant the user execute access to the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ユーザーのmode、acl、およびdacl属性の実行権限に応じた実行アクセス権がない場合でも、クライアントのオペレーティング環境がユーザーに実行を許可する場合、クライアントが実行アクセス権を決定する必要がある場合は、ACCESSリクエストを送信する必要があります（SHOULD）リクエストのアクセスフィールドにACCESS4_EXECUTEビットとACCESS4_READビットの両方が設定されています。このようにして、応答のアクセスフィールドにACCESS4_EXECUTEやACCESS4_READが存在することで示されるように、読み取りまたは実行権限がユーザーに読み取りまたは実行アクセスを許可する場合（またはサーバーがユーザーを特権として解釈する場合）、クライアントはユーザーにファイルへの実行アクセス権を付与します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the server supports execute permission bits, or some other method for denoting executability (e.g., the suffix of the name of the file might indicate execute), it MUST check only execute permissions, not read permissions, when determining whether or not the reply will have ACCESS4_EXECUTE set in the access field. The server MUST NOT also examine read permission bits when determining whether or not the reply will have ACCESS4_EXECUTE set in the access field. Even if the server&#39;s operating environment would grant execute access to the user (e.g., the user is privileged), the server MUST NOT reply with ACCESS4_EXECUTE set in reply&#39;s access field unless there is at least one execute permission bit set in the mode, acl, or dacl attributes. In the case of acl and dacl, the &#34;one execute permission bit&#34; MUST be an ACE4_EXECUTE bit set in an ALLOW ACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the server supports execute permission bits, or some other method for denoting executability (e.g., the suffix of the name of the file might indicate execute), it MUST check only execute permissions, not read permissions, when determining whether or not the reply will have ACCESS4_EXECUTE set in the access field. The server MUST NOT also examine read permission bits when determining whether or not the reply will have ACCESS4_EXECUTE set in the access field. Even if the server&#39;s operating environment would grant execute access to the user (e.g., the user is privileged), the server MUST NOT reply with ACCESS4_EXECUTE set in reply&#39;s access field unless there is at least one execute permission bit set in the mode, acl, or dacl attributes. In the case of acl and dacl, the &#34;one execute permission bit&#34; MUST be an ACE4_EXECUTE bit set in an ALLOW ACE.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the server does not support execute permission bits or some other method for denoting executability, it MUST NOT set ACCESS4_EXECUTE in the reply&#39;s supported and access fields. If the client set ACCESS4_EXECUTE in the ACCESS request&#39;s access field, and ACCESS4_EXECUTE is not set in the reply&#39;s supported field, then the client will have to send an ACCESS request with the ACCESS4_READ bit set in the request&#39;s access field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーが実行許可ビットまたは実行可能性を示す他の方法をサポートしていない場合、応答のサポートされているフィールドとアクセスフィールドにACCESS4_EXECUTEを設定してはなりません（MUST NOT）。クライアントがACCESSリクエストのアクセスフィールドにACCESS4_EXECUTEを設定し、応答のサポートフィールドにACCESS4_EXECUTEが設定されていない場合、クライアントは、リクエストのアクセスフィールドにACCESS4_READビットが設定されたACCESSリクエストを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the server supports read permission bits, it MUST only check for read permissions in the mode, acl, and dacl attributes when it receives an ACCESS request with ACCESS4_READ set in the access field. The server MUST NOT also examine execute permission bits when determining whether the reply will have ACCESS4_READ set in the access field or not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーが読み取り許可ビットをサポートしている場合は、アクセスフィールドにACCESS4_READが設定されたACCESS要求を受信したときに、mode、acl、およびdacl属性の読み取り許可のみをチェックする必要があります。サーバーは、応答にACCESS4_READがアクセスフィールドに設定されているかどうかを判断するときに、実行許可ビットも検査してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Note that if the ACCESS reply has ACCESS4_READ or ACCESS_EXECUTE set, then the user also has permissions to OPEN (Section 18.16) or READ (Section 18.22) the file. In other words, if the client sends an ACCESS request with the ACCESS4_READ and ACCESS_EXECUTE set in the access field (or two separate requests, one with ACCESS4_READ set and the other with ACCESS4_EXECUTE set), and the reply has just ACCESS4_EXECUTE set in the access field (or just one reply has ACCESS4_EXECUTE set), then the user has authorization to OPEN or READ the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ACCESS応答にACCESS4_READまたはACCESS_EXECUTEが設定されている場合、ユーザーはファイルをOPEN（セクション18.16）またはREAD（セクション18.22）する権限も持っていることに注意してください。言い換えると、クライアントがアクセスフィールドにACCESS4_READおよびACCESS_EXECUTEが設定されたACCESSリクエスト（またはACCESS4_READが設定された1つとACCESS4_EXECUTEが設定された2つの個別のリクエスト）を送信し、応答のアクセスフィールドにACCESS4_EXECUTEが設定されている場合（または1つの応答にACCESS4_EXECUTEが設定されている場合）、ユーザーはファイルを開くまたは読み取る権限を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-1-4--IMPLEMENTATION">
18.1.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, it is not sufficient for the client to attempt to deduce access permissions by inspecting the uid, gid, and mode fields in the file attributes or by attempting to interpret the contents of the ACL attribute. This is because the server may perform uid or gid mapping or enforce additional access-control restrictions. It is also possible that the server may not be in the same ID space as the client. In these cases (and perhaps others), the client cannot reliably perform an access check with only current file attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般に、クライアントがファイル属性のuid、gid、およびmodeフィールドを調べたり、ACL属性の内容を解釈したりして、アクセス許可を推測するだけでは不十分です。これは、サーバーがuidまたはgidマッピングを実行したり、追加のアクセス制御制限を適用したりする可能性があるためです。また、サーバーがクライアントと同じIDスペースにない場合もあります。これらのケース（およびその他のケース）では、クライアントは現在のファイル属性のみでアクセスチェックを確実に実行できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the NFSv2 protocol, the only reliable way to determine whether an operation was allowed was to try it and see if it succeeded or failed. Using the ACCESS operation in the NFSv4.1 protocol, the client can ask the server to indicate whether or not one or more classes of operations are permitted. The ACCESS operation is provided to allow clients to check before doing a series of operations that will result in an access failure. The OPEN operation provides a point where the server can verify access to the file object and a method to return that information to the client. The ACCESS operation is still useful for directory operations or for use in the case that the UNIX interface access() is used on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv2プロトコルでは、操作が許可されているかどうかを判断する唯一の信頼できる方法は、操作を試行して、操作が成功したか失敗したかを確認することでした。クライアントは、NFSv4.1プロトコルのACCESS操作を使用して、1つ以上のクラスの操作が許可されているかどうかをサーバーに要求することができます。 ACCESS操作は、クライアントがアクセス障害を引き起こす一連の操作を実行する前に確認できるようにするために提供されています。 OPEN操作は、サーバーがファイルオブジェクトへのアクセスを確認できるポイントと、その情報をクライアントに返すメソッドを提供します。 ACCESS操作は、ディレクトリ操作や、UNIXインターフェースaccess()がクライアントで使用されている場合に使用する場合にも役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The information returned by the server in response to an ACCESS call is not permanent. It was correct at the exact time that the server performed the checks, but not necessarily afterwards. The server can revoke access permission at any time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS呼び出しへの応答としてサーバーから返される情報は永続的なものではありません。サーバーがチェックを実行した正確な時点で正しかったが、必ずしもその後ではなかった。サーバーはいつでもアクセス許可を取り消すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client should use the effective credentials of the user to build the authentication information in the ACCESS request used to determine access rights. It is the effective user and group credentials that are used in subsequent READ and WRITE operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、ユーザーの有効な資格情報を使用して、アクセス権を決定するために使用されるACCESSリクエストで認証情報を構築する必要があります。後続のREADおよびWRITE操作で使用されるのは、有効なユーザーおよびグループの資格情報です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many implementations do not directly support the ACCESS4_DELETE permission. Operating systems like UNIX will ignore the ACCESS4_DELETE bit if set on an access request on a non-directory object. In these systems, delete permission on a file is determined by the access permissions on the directory in which the file resides, instead of being determined by the permissions of the file itself. Therefore, the mask returned enumerating which access rights can be determined will have the ACCESS4_DELETE value set to 0. This indicates to the client that the server was unable to check that particular access right. The ACCESS4_DELETE bit in the access mask returned will then be ignored by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの実装では、ACCESS4_DELETE権限を直接サポートしていません。 UNIXなどのオペレーティングシステムは、非ディレクトリオブジェクトに対するアクセス要求で設定されている場合、ACCESS4_DELETEビットを無視します。これらのシステムでは、ファイルの削除権限は、ファイル自体の権限ではなく、ファイルが存在するディレクトリへのアクセス権限によって決定されます。したがって、決定できるアクセス権を列挙して返されたマスクでは、ACCESS4_DELETE値が0に設定されます。これは、サーバーがその特定のアクセス権をチェックできなかったことをクライアントに示します。返されたアクセスマスクのACCESS4_DELETEビットは、クライアントによって無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-2--Operation-4-CLOSE---Close-File">
18.2. Operation 4: CLOSE - Close File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2. 操作4：CLOSE-ファイルを閉じる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-2-1--ARGUMENTS">
18.2.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CLOSE4args {
           /* CURRENT_FH: object */
           seqid4          seqid;
           stateid4        open_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-2-2--RESULTS">
18.2.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union CLOSE4res switch (nfsstat4 status) {
    case NFS4_OK:
            stateid4       open_stateid;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-2-3--DESCRIPTION">
18.2.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CLOSE operation releases share reservations for the regular or named attribute file as specified by the current filehandle. The share reservations and other state information released at the server as a result of this CLOSE are only those associated with the supplied stateid. State associated with other OPENs is not affected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSE操作は、現在のファイルハンドルで指定された通常または名前付きの属性ファイルの共有予約を解放します。このCLOSEの結果としてサーバーで解放された共有予約およびその他の状態情報は、提供された状態IDに関連付けられたものだけです。他のOPENに関連する状態は影響を受けません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If byte-range locks are held, the client SHOULD release all locks before sending a CLOSE. The server MAY free all outstanding locks on CLOSE, but some servers may not support the CLOSE of a file that still has byte-range locks held. The server MUST return failure if any locks would exist after the CLOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイト範囲のロックが保持されている場合、クライアントはCLOSEを送信する前にすべてのロックを解放する必要があります（SHOULD）。サーバーはCLOSEですべての未解決のロックを解放してもかまいませんが、一部のサーバーは、バイト範囲ロックが保持されているファイルのCLOSEをサポートしない場合があります。 CLOSEの後にロックが存在する場合、サーバーは失敗を返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The argument seqid MAY have any value, and the server MUST ignore seqid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数seqidは任意の値を持つことができ、サーバーはseqidを無視しなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MAY require that the combination of principal, security flavor, and, if applicable, GSS mechanism that sent the OPEN request also be the one to CLOSE the file. This might not be possible if credentials for the principal are no longer available. The server MAY allow the machine credential or SSV credential (see Section 18.35) to send CLOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MAY require that the combination of principal, security flavor, and, if applicable, GSS mechanism that sent the OPEN request also be the one to CLOSE the file. This might not be possible if credentials for the principal are no longer available. The server MAY allow the machine credential or SSV credential (see Section 18.35) to send CLOSE.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-2-4--IMPLEMENTATION">
18.2.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even though CLOSE returns a stateid, this stateid is not useful to the client and should be treated as deprecated. CLOSE &#34;shuts down&#34; the state associated with all OPENs for the file by a single open-owner. As noted above, CLOSE will either release all file-locking state or return an error. Therefore, the stateid returned by CLOSE is not useful for operations that follow. To help find any uses of this stateid by clients, the server SHOULD return the invalid special stateid (the &#34;other&#34; value is zero and the &#34;seqid&#34; field is NFS4_UINT32_MAX, see Section 8.2.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSEはstateidを返しますが、このstateidはクライアントには役立ちません。非推奨として扱う必要があります。 CLOSEは、単一のオープン所有者によるファイルのすべてのOPENに関連付けられた状態を「シャットダウン」します。上記のように、CLOSEはすべてのファイルロック状態を解除するか、エラーを返します。したがって、CLOSEによって返される状態IDは、その後の操作には役立ちません。クライアントによるこのstateidの使用を見つけるために、サーバーは無効な特別なstateidを返す必要があります（「other」の値はゼロで、「seqid」フィールドはNFS4_UINT32_MAXです。セクション8.2.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A CLOSE operation may make delegations grantable where they were not previously. Servers may choose to respond immediately if there are pending delegation want requests or may respond to the situation at a later time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSE操作を行うと、委任が以前は許可されていなかった場合でも、委任が許可される場合があります。サーバーは、保留中の委任要求がある場合はすぐに応答するか、後で状況に応答するかを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-3--Operation-5-COMMIT---Commit-Cached-Data">
18.3. Operation 5: COMMIT - Commit Cached Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3. 操作5：COMMIT-キャッシュデータのコミット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-3-1--ARGUMENTS">
18.3.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COMMIT4args {
           /* CURRENT_FH: file */
           offset4         offset;
           count4          count;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-3-2--RESULTS">
18.3.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.2. RESULTS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COMMIT4resok {
           verifier4       writeverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union COMMIT4res switch (nfsstat4 status) {
    case NFS4_OK:
            COMMIT4resok   resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-3-3--DESCRIPTION">
18.3.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMMIT operation forces or flushes uncommitted, modified data to stable storage for the file specified by the current filehandle. The flushed data is that which was previously written with one or more WRITE operations that had the &#34;committed&#34; field of their results field set to UNSTABLE4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMIT操作は、現在のファイルハンドルで指定されたファイルの安定したストレージに、コミットされていない変更済みデータを強制またはフラッシュします。フラッシュされたデータは、結果フィールドの &#34;committed&#34;フィールドがUNSTABLE4に設定された1つ以上のWRITE操作で以前に書き込まれたデータです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The offset specifies the position within the file where the flush is to begin. An offset value of zero means to flush data starting at the beginning of the file. The count specifies the number of bytes of data to flush. If the count is zero, a flush from the offset to the end of the file is done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オフセットは、フラッシュを開始するファイル内の位置を指定します。ゼロのオフセット値は、ファイルの最初からデータをフラッシュすることを意味します。カウントは、フラッシュするデータのバイト数を指定します。カウントがゼロの場合、オフセットからファイルの最後までフラッシュされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server returns a write verifier upon successful completion of the COMMIT. The write verifier is used by the client to determine if the server has restarted between the initial WRITE operations and the COMMIT. The client does this by comparing the write verifier returned from the initial WRITE operations and the verifier returned by the COMMIT operation. The server must vary the value of the write verifier at each server event or instantiation that may lead to a loss of uncommitted data. Most commonly this occurs when the server is restarted; however, other events at the server may result in uncommitted data loss as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMITが正常に完了すると、サーバーは書き込みベリファイアを返します。クライアントが書き込みベリファイアを使用して、サーバーが最初のWRITE操作とCOMMITの間に再起動したかどうかを判断します。クライアントは、最初のWRITE操作から返された書き込みベリファイアとCOMMIT操作によって返されたベリファイアを比較することにより、これを行います。サーバーは、コミットされていないデータの損失につながる可能性のあるサーバーイベントまたはインスタンス化ごとに、書き込みベリファイアの値を変更する必要があります。最も一般的には、これはサーバーの再起動時に発生します。ただし、サーバーで他のイベントが発生すると、コミットされていないデータが失われる可能性もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-3-4--IMPLEMENTATION">
18.3.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMMIT operation is similar in operation and semantics to the POSIX fsync() [25] system interface that synchronizes a file&#39;s state with the disk (file data and metadata is flushed to disk or stable storage). COMMIT performs the same operation for a client, flushing any unsynchronized data and metadata on the server to the server&#39;s disk or stable storage for the specified file. Like fsync(), it may be that there is some modified data or no modified data to synchronize. The data may have been synchronized by the server&#39;s normal periodic buffer synchronization activity. COMMIT should return NFS4_OK, unless there has been an unexpected error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMIT操作の操作とセマンティクスは、ファイルの状態をディスクと同期するPOSIX fsync()[25]システムインターフェイスと似ています（ファイルデータとメタデータはディスクまたは安定したストレージにフラッシュされます）。 COMMITはクライアントに対して同じ操作を実行し、サーバー上の同期されていないデータとメタデータをサーバーのディスクまたは指定されたファイルの安定したストレージにフラッシュします。 fsync()と同様に、同期する変更されたデータがあるか、変更されたデータがない可能性があります。データは、サーバーの通常の定期的なバッファー同期アクティビティによって同期された可能性があります。予期しないエラーが発生していない限り、COMMITはNFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMIT differs from fsync() in that it is possible for the client to flush a range of the file (most likely triggered by a buffer-reclamation scheme on the client before the file has been completely written).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMIT differs from fsync() in that it is possible for the client to flush a range of the file (most likely triggered by a buffer-reclamation scheme on the client before the file has been completely written).
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The server implementation of COMMIT is reasonably simple. If the server receives a full file COMMIT request, that is, starting at offset zero and count zero, it should do the equivalent of applying fsync() to the entire file. Otherwise, it should arrange to have the modified data in the range specified by offset and count to be flushed to stable storage. In both cases, any metadata associated with the file must be flushed to stable storage before returning. It is not an error for there to be nothing to flush on the server. This means that the data and metadata that needed to be flushed have already been flushed or lost during the last server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
COMMITのサーバー実装はかなり単純です。サーバーが完全なファイルCOMMIT要求を受け取った場合、つまり、オフセット0とカウント0から開始する場合、サーバーはfsync()をファイル全体に適用するのと同じことを行う必要があります。それ以外の場合は、安定したストレージにフラッシュされるように、オフセットとカウントで指定された範囲の変更されたデータを配置する必要があります。どちらの場合も、ファイルに関連付けられているメタデータは、戻る前に安定したストレージにフラッシュする必要があります。サーバー上でフラッシュするものが何もないことはエラーではありません。つまり、フラッシュする必要があったデータとメタデータは、最後のサーバー障害時にすでにフラッシュされているか、失われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client implementation of COMMIT is a little more complex. There are two reasons for wanting to commit a client buffer to stable storage. The first is that the client wants to reuse a buffer. In this case, the offset and count of the buffer are sent to the server in the COMMIT request. The server then flushes any modified data based on the offset and count, and flushes any modified metadata associated with the file. It then returns the status of the flush and the write verifier. The second reason for the client to generate a COMMIT is for a full file flush, such as may be done at close. In this case, the client would gather all of the buffers for this file that contain uncommitted data, do the COMMIT operation with an offset of zero and count of zero, and then free all of those buffers. Any other dirty buffers would be sent to the server in the normal fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMITのクライアント実装はもう少し複雑です。クライアントバッファを安定したストレージにコミットする理由は2つあります。 1つ目は、クライアントがバッファを再利用することです。この場合、バッファのオフセットとカウントは、COMMITリクエストでサーバーに送信されます。次に、サーバーは、オフセットとカウントに基づいて変更されたデータをフラッシュし、ファイルに関連付けられた変更されたメタデータをフラッシュします。次に、フラッシュと書き込みベリファイアのステータスを返します。クライアントがCOMMITを生成する2番目の理由は、クローズ時に実行されるなど、完全なファイルフラッシュのためです。この場合、クライアントは、コミットされていないデータを含むこのファイルのすべてのバッファーを収集し、オフセット0とカウント0でCOMMIT操作を実行してから、それらのバッファーをすべて解放します。他のダーティバッファは通常の方法でサーバーに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After a buffer is written (via the WRITE operation) by the client with the &#34;committed&#34; field in the result of WRITE set to UNSTABLE4, the buffer must be considered as modified by the client until the buffer has either been flushed via a COMMIT operation or written via a WRITE operation with the &#34;committed&#34; field in the result set to FILE_SYNC4 or DATA_SYNC4. This is done to prevent the buffer from being freed and reused before the data can be flushed to stable storage on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITEの結果の「committed」フィールドがUNSTABLE4に設定されたクライアントによって（WRITE操作を介して）バッファーが書き込まれた後、そのバッファーは、COMMIT操作を介してフラッシュされるまで、クライアントによって変更されたと見なされる必要があります。または、結果セットの「committed」フィールドをFILE_SYNC4またはDATA_SYNC4に設定して、WRITE操作で書き込みます。これは、サーバー上の安定したストレージにデータをフラッシュする前に、バッファーが解放されて再利用されるのを防ぐために行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a response is returned from either a WRITE or a COMMIT operation and it contains a write verifier that differs from that previously returned by the server, the client will need to retransmit all of the buffers containing uncommitted data to the server. How this is to be done is up to the implementor. If there is only one buffer of interest, then it should be sent in a WRITE request with the FILE_SYNC4 stable parameter. If there is more than one buffer, it might be worthwhile retransmitting all of the buffers in WRITE operations with the stable parameter set to UNSTABLE4 and then retransmitting the COMMIT operation to flush all of the data on the server to stable storage. However, if the server repeatably returns from COMMIT a verifier that differs from that returned by WRITE, the only way to ensure progress is to retransmit all of the buffers with WRITE requests with the FILE_SYNC4 stable parameter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
書き込み操作またはCOMMIT操作のいずれかから応答が返され、以前にサーバーから返されたものとは異なる書き込みベリファイアが含まれている場合、クライアントはコミットされていないデータを含むすべてのバッファーをサーバーに再送信する必要があります。これをどのように行うかは、実装者次第です。対象のバッファが1つしかない場合は、FILE_SYNC4の安定したパラメータを使用して、WRITEリクエストで送信する必要があります。複数のバッファがある場合は、安定したパラメータをUNSTABLE4に設定してWRITE操作ですべてのバッファを再送信し、次にCOMMIT操作を再送信して、サーバー上のすべてのデータを安定したストレージにフラッシュします。ただし、サーバーがCOMMITからWRITEによって返されたものとは異なるベリファイアを繰り返し返す場合、進行を確実にする唯一の方法は、FILE_SYNC4安定パラメーターを使用してWRITE要求ですべてのバッファーを再送信することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above description applies to page-cache-based systems as well as buffer-cache-based systems. In the former systems, the virtual memory system will need to be modified instead of the buffer cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の説明は、ページキャッシュベースのシステムとバッファキャッシュベースのシステムに適用されます。以前のシステムでは、バッファキャッシュの代わりに仮想メモリシステムを変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-4--Operation-6-CREATE---Create-a-Non-Regular-File-Object">
18.4. Operation 6: CREATE - Create a Non-Regular File Object
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.4. 操作6：作成-通常以外のファイルオブジェクトを作成する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-4-1--ARGUMENTS">
18.4.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.4.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union createtype4 switch (nfs_ftype4 type) {
    case NF4LNK:
            linktext4 linkdata;
    case NF4BLK:
    case NF4CHR:
            specdata4 devdata;
    case NF4SOCK:
    case NF4FIFO:
    case NF4DIR:
            void;
    default:
            void;  /* server should return NFS4ERR_BADTYPE */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CREATE4args {
           /* CURRENT_FH: directory for creation */
           createtype4     objtype;
           component4      objname;
           fattr4          createattrs;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-4-2--RESULTS">
18.4.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.4.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CREATE4resok {
           change_info4    cinfo;
           bitmap4         attrset;        /* attributes set */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union CREATE4res switch (nfsstat4 status) {
    case NFS4_OK:
            /* new CURRENTFH: created object */
            CREATE4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-4-3--DESCRIPTION">
18.4.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.4.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CREATE operation creates a file object other than an ordinary file in a directory with a given name. The OPEN operation MUST be used to create a regular file or a named attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATE操作は、指定された名前のディレクトリに通常のファイル以外のファイルオブジェクトを作成します。通常のファイルまたは名前付き属性を作成するには、OPEN操作を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current filehandle must be a directory: an object of type NF4DIR. If the current filehandle is an attribute directory (type NF4ATTRDIR), the error NFS4ERR_WRONG_TYPE is returned. If the current file handle designates any other type of object, the error NFS4ERR_NOTDIR results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルはディレクトリでなければなりません：NF4DIRタイプのオブジェクト。現在のファイルハンドルが属性ディレクトリ（タイプNF4ATTRDIR）の場合、エラーNFS4ERR_WRONG_TYPEが返されます。現在のファイルハンドルが他のタイプのオブジェクトを指定している場合、エラーNFS4ERR_NOTDIRが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The objname specifies the name for the new object. The objtype determines the type of object to be created: directory, symlink, etc. If the object type specified is that of an ordinary file, a named attribute, or a named attribute directory, the error NFS4ERR_BADTYPE results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
objnameは、新しいオブジェクトの名前を指定します。 objtypeは、作成されるオブジェクトのタイプ（ディレクトリー、シンボリックリンクなど）を決定します。指定されたオブジェクトタイプが通常のファイル、名前付き属性、または名前付き属性ディレクトリーのタイプである場合、エラーNFS4ERR_BADTYPEが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an object of the same name already exists in the directory, the server will return the error NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じ名前のオブジェクトがディレクトリにすでに存在する場合、サーバーはエラーNFS4ERR_EXISTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the directory where the new file object was created, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 data type, the server will indicate if the before and after change attributes were obtained atomically with respect to the file object creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいファイルオブジェクトが作成されたディレクトリの場合、サーバーはchange_info4情報をcinfoに返します。 change_info4データ型のアトミックフィールドを使用すると、サーバーは、変更前と変更後の属性がファイルオブジェクトの作成に関してアトミックに取得されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the objname has a length of zero, or if objname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
objnameの長さがゼロの場合、またはobjnameがUTF-8定義に従っていない場合、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current filehandle is replaced by that of the new object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルは、新しいオブジェクトのファイルハンドルに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The createattrs specifies the initial set of attributes for the object. The set of attributes may include any writable attribute valid for the object type. When the operation is successful, the server will return to the client an attribute mask signifying which attributes were successfully set for the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
createattrsは、オブジェクトの属性の初期セットを指定します。属性のセットには、オブジェクトタイプに有効な書き込み可能な属性を含めることができます。操作が成功すると、サーバーは、オブジェクトにどの属性が正常に設定されたかを示す属性マスクをクライアントに返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If createattrs includes neither the owner attribute nor an ACL with an ACE for the owner, and if the server&#39;s file system both supports and requires an owner attribute (or an owner ACE), then the server MUST derive the owner (or the owner ACE). This would typically be from the principal indicated in the RPC credentials of the call, but the server&#39;s operating environment or file system semantics may dictate other methods of derivation. Similarly, if createattrs includes neither the group attribute nor a group ACE, and if the server&#39;s file system both supports and requires the notion of a group attribute (or group ACE), the server MUST derive the group attribute (or the corresponding owner ACE) for the file. This could be from the RPC call&#39;s credentials, such as the group principal if the credentials include it (such as with AUTH_SYS), from the group identifier associated with the principal in the credentials (e.g., POSIX systems have a user database [26] that has a group identifier for every user identifier), inherited from the directory in which the object is created, or whatever else the server&#39;s operating environment or file system semantics dictate. This applies to the OPEN operation too.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
createattrsに所有者属性も、所有者のACEを含むACLも含まれておらず、サーバーのファイルシステムが所有者属性（または所有者ACE）をサポートおよび要求している場合、サーバーは所有者（または所有者ACE）を導出する必要があります。 。これは通常、呼び出しのRPC資格情報に示されているプリンシパルからのものですが、サーバーの動作環境またはファイルシステムのセマンティクスによって、他の派生方法が決まる場合があります。同様に、createattrsにグループ属性もグループACEも含まれておらず、サーバーのファイルシステムがグループ属性（またはグループACE）の概念をサポートおよび要求している場合、サーバーはグループ属性（または対応する所有者ACE）を導出する必要があります。ファイル用。これは、RPC呼び出しの資格情報、たとえば、資格情報にそれが含まれている場合（AUTH_SYSなど）のグループプリンシパルから、資格情報のプリンシパルに関連付けられたグループ識別子から（たとえば、POSIXシステムにユーザーデータベースがある[26]）オブジェクトが作成されたディレクトリ、またはサーバーの動作環境やファイルシステムのセマンティクスで指定されたものから継承された、すべてのユーザー識別子のグループ識別子があります）。これは、OPEN操作にも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Conversely, it is possible that the client will specify in createattrs an owner attribute, group attribute, or ACL that the principal indicated the RPC call&#39;s credentials does not have permissions to create files for. The error to be returned in this instance is NFS4ERR_PERM. This applies to the OPEN operation too.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
逆に、クライアントがcreateattrsで所有者属性、グループ属性、またはACLを指定すると、RPC呼び出しの資格情報にファイルを作成する権限がないことをプリンシパルが示した可能性があります。このインスタンスで返されるエラーはNFS4ERR_PERMです。これは、OPEN操作にも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle designates a directory for which another client holds a directory delegation, then, unless the delegation is such that the situation can be resolved by sending a notification, the delegation MUST be recalled, and the CREATE operation MUST NOT proceed until the delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが、別のクライアントがディレクトリ委任を保持しているディレクトリを指定している場合、委任が通知を送信することで状況を解決できるようなものでない限り、委任は再呼び出しされなければならず（MUST）、作成操作は委任まで進行してはならない（MUST NOT）返却または取り消されます。これが非常に迅速に発生する場合を除いて、委任が未解決のままである間に、1つ以上のNFS4ERR_DELAYエラーが要求に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the current filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, NOTIFY4_ADD_ENTRY will be generated as a result of this operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが1つ以上のディレクトリ委任が存在するディレクトリを指定している場合、それらの委任がそのような通知を要求すると、この操作の結果としてNOTIFY4_ADD_ENTRYが生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the capability FSCHARSET_CAP4_ALLOWS_ONLY_UTF8 is set (Section 14.4), and a symbolic link is being created, then the content of the symbolic link MUST be in UTF-8 encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
機能FSCHARSET_CAP4_ALLOWS_ONLY_UTF8が設定され（セクション14.4）、シンボリックリンクが作成されている場合、シンボリックリンクのコンテンツはUTF-8エンコーディングである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-4-4--IMPLEMENTATION">
18.4.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.4.4. IMPLEMENTATION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client desires to set attribute values after the create, a SETATTR operation can be added to the COMPOUND request so that the appropriate attributes will be set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが作成後に属性値を設定することを望む場合、適切な属性が設定されるように、SETATTR操作をCOMPOUND要求に追加できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-5--Operation-7-DELEGPURGE---Purge-Delegations-Awaiting-Recovery">
18.5. Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.5. 操作7：DELEGPURGE-回復を待機している委任のパージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-5-1--ARGUMENTS">
18.5.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.5.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DELEGPURGE4args {
           clientid4       clientid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-5-2--RESULTS">
18.5.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.5.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DELEGPURGE4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-5-3--DESCRIPTION">
18.5.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.5.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation purges all of the delegations awaiting recovery for a given client. This is useful for clients that do not commit delegation information to stable storage to indicate that conflicting requests need not be delayed by the server awaiting recovery of delegation information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、特定のクライアントの回復を待機しているすべての委任を削除します。これは、委託情報を安定したストレージにコミットしないクライアントが、委託情報の回復を待機しているサーバーが競合する要求を遅らせる必要がないことを示すのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client is NOT specified by the clientid field of the request. The client SHOULD set the client field to zero, and the server MUST ignore the clientid field. Instead, the server MUST derive the client ID from the value of the session ID in the arguments of the SEQUENCE operation that precedes DELEGPURGE in the COMPOUND request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、リクエストのclientidフィールドで指定されていません。クライアントはクライアントフィールドをゼロに設定する必要があり（SHOULD）、サーバーはclientidフィールドを無視しなければなりません（MUST）。代わりに、サーバーはCOMPOUNDリクエストのDELEGPURGEの前にあるSEQUENCE操作の引数のセッションIDの値からクライアントIDを導出する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DELEGPURGE operation should be used by clients that record delegation information on stable storage on the client. In this case, after the client recovers all delegations it knows of, it should immediately send a DELEGPURGE operation. Doing so will notify the server that no additional delegations for the client will be recovered allowing it to free resources, and avoid delaying other clients which make requests that conflict with the unrecovered delegations. The set of delegations known to the server and the client might be different. The reason for this is that after sending a request that resulted in a delegation, the client might experience a failure before it both received the delegation and committed the delegation to the client&#39;s stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの安定したストレージに委任情報を記録するクライアントは、DELEGPURGE操作を使用する必要があります。この場合、クライアントは、知っているすべての委任を回復した後、すぐにDELEGPURGE操作を送信する必要があります。そうすることで、クライアントの追加の委任が回復されずにリソースを解放できることがサーバーに通知され、回復されていない委任と競合する要求を行う他のクライアントの遅延が回避されます。サーバーとクライアントが認識している委任のセットは異なる場合があります。これは、委任の原因となった要求を送信した後、クライアントが委任を受信し、委任をクライアントの安定したストレージにコミットする前に、クライアントで障害が発生する可能性があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MAY support DELEGPURGE, but if it does not, it MUST NOT support CLAIM_DELEGATE_PREV and MUST NOT support CLAIM_DELEG_PREV_FH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはDELEGPURGEをサポートする場合がありますが、サポートしない場合は、CLAIM_DELEGATE_PREVをサポートしてはならず、CLAIM_DELEG_PREV_FHをサポートしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-6--Operation-8-DELEGRETURN---Return-Delegation">
18.6. Operation 8: DELEGRETURN - Return Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.6. 操作8：DELEGRETURN-委任を返す
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-6-1--ARGUMENTS">
18.6.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.6.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DELEGRETURN4args {
           /* CURRENT_FH: delegated object */
           stateid4        deleg_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-6-2--RESULTS">
18.6.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.6.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DELEGRETURN4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-6-3--DESCRIPTION">
18.6.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.6.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DELEGRETURN operation returns the delegation represented by the current filehandle and stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DELEGRETURN操作は、現在のファイルハンドルと状態IDで表される委任を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Delegations may be returned voluntarily (i.e., before the server has recalled them) or when recalled. In either case, the client must properly propagate state changed under the context of the delegation to the server before returning the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Delegations may be returned voluntarily (i.e., before the server has recalled them) or when recalled. In either case, the client must properly propagate state changed under the context of the delegation to the server before returning the delegation.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MAY require that the principal, security flavor, and if applicable, the GSS mechanism, combination that acquired the delegation also be the one to send DELEGRETURN on the file. This might not be possible if credentials for the principal are no longer available. The server MAY allow the machine credential or SSV credential (see Section 18.35) to send DELEGRETURN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、委任を取得したプリンシパル、セキュリティフレーバー、および該当する場合はGSSメカニズムの組み合わせも、ファイルにDELEGRETURNを送信するためのものであることを要求する場合があります。プリンシパルの資格情報が使用できなくなった場合、これは不可能である可能性があります。サーバーは、マシン信任状またはSSV信任状（セクション18.35を参照）がDELEGRETURNを送信することを許可する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-7--Operation-9-GETATTR---Get-Attributes">
18.7. Operation 9: GETATTR - Get Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.7. 操作9：GETATTR-属性の取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-7-1--ARGUMENTS">
18.7.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.7.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETATTR4args {
           /* CURRENT_FH: object */
           bitmap4         attr_request;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-7-2--RESULTS">
18.7.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.7.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETATTR4resok {
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            GETATTR4resok  resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-7-3--DESCRIPTION">
18.7.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.7.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The GETATTR operation will obtain attributes for the file system object specified by the current filehandle. The client sets a bit in the bitmap argument for each attribute value that it would like the server to return. The server returns an attribute bitmap that indicates the attribute values that it was able to return, which will include all attributes requested by the client that are attributes supported by the server for the target file system. This bitmap is followed by the attribute values ordered lowest attribute number first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETATTR操作は、現在のファイルハンドルで指定されたファイルシステムオブジェクトの属性を取得します。クライアントは、サーバーが返す各属性値のビットマップ引数にビットを設定します。サーバーは、返された属性値を示す属性ビットマップを返します。これには、ターゲットファイルシステムのサーバーでサポートされている属性である、クライアントから要求されたすべての属性が含まれます。このビットマップの後には、最初に属性番号が小さい順に属性値が続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MUST return a value for each attribute that the client requests if the attribute is supported by the server for the target file system. If the server does not support a particular attribute on the target file system, then it MUST NOT return the attribute value and MUST NOT set the attribute bit in the result bitmap. The server MUST return an error if it supports an attribute on the target but cannot obtain its value. In that case, no attribute values will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがターゲットファイルシステムの属性をサポートしている場合、サーバーは、クライアントが要求する各属性の値を返す必要があります。サーバーがターゲットファイルシステムの特定の属性をサポートしていない場合、属性値を返してはならず、結果のビットマップに属性ビットを設定してはなりません（MUST NOT）。サーバーは、ターゲットの属性をサポートしているがその値を取得できない場合、エラーを返さなければなりません（MUST）。その場合、属性値は返されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
File systems that are absent should be treated as having support for a very small set of attributes as described in Section 11.3.1, even if previously, when the file system was present, more attributes were supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存在しないファイルシステムは、セクション11.3.1で説明されているように、非常に小さな属性セットをサポートしているものとして扱う必要があります。以前は、ファイルシステムが存在していたときに、より多くの属性がサポートされていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All servers MUST support the REQUIRED attributes as specified in Section 5.6, for all file systems, with the exception of absent file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存在しないファイルシステムを除いて、すべてのサーバーは、セクション5.6で指定されているように、すべてのファイルシステムに対してREQUIRED属性をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-7-4--IMPLEMENTATION">
18.7.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.7.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suppose there is an OPEN_DELEGATE_WRITE delegation held by another client for the file in question and size and/or change are among the set of attributes being interrogated. The server has two choices. First, the server can obtain the actual current value of these attributes from the client holding the delegation by using the CB_GETATTR callback. Second, the server, particularly when the delegated client is unresponsive, can recall the delegation in question. The GETATTR MUST NOT proceed until one of the following occurs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
問題のファイルについて別のクライアントによって保持されているOPEN_DELEGATE_WRITE委任があり、サイズまたは変更、あるいはその両方が、照会される属性のセットの中にあるとします。サーバーには2つの選択肢があります。最初に、サーバーはCB_GETATTRコールバックを使用して、委任を保持しているクライアントからこれらの属性の実際の現在の値を取得できます。次に、サーバーは、特に委任されたクライアントが応答しない場合、問題の委任を呼び出すことができます。 GETATTRは、次のいずれかが発生するまで続行してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The requested attribute values are returned in the response to CB_GETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 要求された属性値は、CB_GETATTRへの応答で返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The OPEN_DELEGATE_WRITE delegation is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN_DELEGATE_WRITE委任が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The OPEN_DELEGATE_WRITE delegation is revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN_DELEGATE_WRITE委任は取り消されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless one of the above happens very quickly, one or more NFS4ERR_DELAY errors will be returned while a delegation is outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のいずれかが非常に迅速に発生しない限り、委任が未解決である間、1つ以上のNFS4ERR_DELAYエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-8--Operation-10-GETFH---Get-Current-Filehandle">
18.8. Operation 10: GETFH - Get Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.8. 操作10：GETFH-現在のファイルハンドルを取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-8-1--ARGUMENTS">
18.8.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.8.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* CURRENT_FH: */
   void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-8-2--RESULTS">
18.8.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.8.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETFH4resok {
           nfs_fh4         object;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union GETFH4res switch (nfsstat4 status) {
    case NFS4_OK:
           GETFH4resok     resok4;
    default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-8-3--DESCRIPTION">
18.8.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.8.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation returns the current filehandle value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、現在のファイルハンドル値を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 2.10.6.4, GETFH is REQUIRED or RECOMMENDED to immediately follow certain operations, and servers are free to reject such operations if the client fails to insert GETFH in the request as REQUIRED or RECOMMENDED. Section 18.16.4.1 provides additional justification for why GETFH MUST follow OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション2.10.6.4で説明されているように、GETFHは特定の操作の直後にREQUIREDまたはRECOMMENDEDであり、クライアントがリクエストにGETFHをREQUIREDまたはRECOMMENDEDとして挿入できなかった場合、サーバーはそのような操作を自由に拒否できます。セクション18.16.4.1は、GETFHがOPENに従わなければならない理由を説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-8-4--IMPLEMENTATION">
18.8.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.8.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Operations that change the current filehandle like LOOKUP or CREATE do not automatically return the new filehandle as a result. For instance, if a client needs to look up a directory entry and obtain its filehandle, then the following request is needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOOKUPやCREATEなどの現在のファイルハンドルを変更する操作は、結果として新しいファイルハンドルを自動的に返しません。たとえば、クライアントがディレクトリエントリを検索してそのファイルハンドルを取得する必要がある場合、次のリクエストが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PUTFH (directory filehandle) LOOKUP (entry name) GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PUTFH（ディレクトリファイルハンドル）LOOKUP（エントリ名）GETFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-9--Operation-11-LINK---Create-Link-to-a-File">
18.9. Operation 11: LINK - Create Link to a File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.9. 操作11：リンク-ファイルへのリンクを作成する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-9-1--ARGUMENTS">
18.9.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.9.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LINK4args {
           /* SAVED_FH: source object */
           /* CURRENT_FH: target directory */
           component4      newname;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-9-2--RESULTS">
18.9.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.9.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LINK4resok {
           change_info4    cinfo;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            LINK4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-9-3--DESCRIPTION">
18.9.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.9.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LINK operation creates an additional newname for the file represented by the saved filehandle, as set by the SAVEFH operation, in the directory represented by the current filehandle. The existing file and the target directory must reside within the same file system on the server. On success, the current filehandle will continue to be the target directory. If an object exists in the target directory with the same name as newname, the server must return NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LINK操作は、SAVEFH操作で設定された、保存されたファイルハンドルで表されるファイルの追加の新しい名前を、現在のファイルハンドルで表されるディレクトリに作成します。既存のファイルとターゲットディレクトリは、サーバー上の同じファイルシステム内に存在する必要があります。成功した場合、現在のファイルハンドルは引き続きターゲットディレクトリになります。 newnameと同じ名前のオブジェクトがターゲットディレクトリに存在する場合、サーバーはNFS4ERR_EXISTを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 data type, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 data type, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the newname has a length of zero, or if newname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
newnameの長さがゼロの場合、またはnewnameがUTF-8定義に従っていない場合、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-9-4--IMPLEMENTATION">
18.9.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.9.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MAY impose restrictions on the LINK operation such that LINK may not be done when the file is open or when that open is done by particular protocols, or with particular options or access modes. When LINK is rejected because of such restrictions, the error NFS4ERR_FILE_OPEN is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ファイルが開いているとき、またはそのオープンが特定のプロトコルによって、または特定のオプションやアクセスモードで行われているときに、LINKが実行されないように、LINK操作に制限を課してもよい（MAY）。このような制限のためにLINKが拒否されると、エラーNFS4ERR_FILE_OPENが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server does implement such restrictions and those restrictions include cases of NFSv4 opens preventing successful execution of a link, the server needs to recall any delegations that could hide the existence of opens relevant to that decision. The reason is that when a client holds a delegation, the server might not have an accurate account of the opens for that client, since the client may execute OPENs and CLOSEs locally. The LINK operation must be delayed only until a definitive result can be obtained. For example, suppose there are multiple delegations and one of them establishes an open whose presence would prevent the link. Given the server&#39;s semantics, NFS4ERR_FILE_OPEN may be returned to the caller as soon as that delegation is returned without waiting for other delegations to be returned. Similarly, if such opens are not associated with delegations, NFS4ERR_FILE_OPEN can be returned immediately with no delegation recall being done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがそのような制限を実装し、NFSv4オープンがリンクの正常な実行を妨げるケースがそれらの制限に含まれる場合、サーバーはその決定に関連するオープンの存在を隠す可能性のあるすべての委任を呼び出す必要があります。その理由は、クライアントが委任を保持している場合、クライアントがローカルでOPENおよびCLOSEを実行する可能性があるため、サーバーはそのクライアントのオープンの正確なアカウントを持たない可能性があるためです。 LINK操作は、最終的な結果が得られるまでのみ遅延させる必要があります。たとえば、複数の委任があり、そのうちの1つがその存在によりリンクを妨げるオープンを確立するとします。サーバーのセマンティクスが与えられている場合、他の委任が返されるのを待たずに、その委任が返されるとすぐに、NFS4ERR_FILE_OPENが呼び出し元に返されることがあります。同様に、そのようなオープンが委任に関連付けられていない場合、委任の再呼び出しを行わずに、NFS4ERR_FILE_OPENをすぐに返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle designates a directory for which another client holds a directory delegation, then, unless the delegation is such that the situation can be resolved by sending a notification, the delegation MUST be recalled, and the operation cannot be performed successfully until the delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが、別のクライアントがディレクトリ委任を保持しているディレクトリを指定している場合、委任が通知を送信することで状況を解決できるようなものでない限り、委任を再呼び出しする必要があり、委任まで操作を正常に実行できません返却または取り消されます。これが非常に迅速に発生する場合を除いて、委任が未解決のままである間に、1つ以上のNFS4ERR_DELAYエラーが要求に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the current filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, instead of a recall, NOTIFY4_ADD_ENTRY will be generated as a result of the LINK operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが1つ以上のディレクトリ委任が存在するディレクトリを指定している場合、それらの委任がそのような通知を要求すると、再呼び出しの代わりに、NOTIFY4_ADD_ENTRYがLINK操作の結果として生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current file system supports the numlinks attribute, and other clients have delegations to the file being linked, then those delegations MUST be recalled and the LINK operation MUST NOT proceed until all delegations are returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルシステムがnumlinks属性をサポートし、他のクライアントがリンクされているファイルへの委任を持っている場合は、それらの委任を再呼び出しする必要があり、すべての委任が返されるか取り消されるまでLINK操作を続行してはなりません。これが非常に迅速に発生する場合を除いて、委任が未解決のままである間に、1つ以上のNFS4ERR_DELAYエラーが要求に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Changes to any property of the &#34;hard&#34; linked files are reflected in all of the linked files. When a link is made to a file, the attributes for the file should have a value for numlinks that is one greater than the value before the LINK operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Changes to any property of the &#34;hard&#34; linked files are reflected in all of the linked files. When a link is made to a file, the attributes for the file should have a value for numlinks that is one greater than the value before the LINK operation.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The statement &#34;file and the target directory must reside within the same file system on the server&#34; means that the fsid fields in the attributes for the objects are the same. If they reside on different file systems, the error NFS4ERR_XDEV is returned. This error may be returned by some servers when there is an internal partitioning of a file system that the LINK operation would violate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「ファイルとターゲットディレクトリはサーバー上の同じファイルシステム内に存在する必要がある」というステートメントは、オブジェクトの属性のfsidフィールドが同じであることを意味します。それらが異なるファイルシステムに存在する場合、エラーNFS4ERR_XDEVが返されます。このエラーは、LINK操作に違反するファイルシステムの内部パーティションがある場合に、一部のサーバーによって返されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On some servers, &#34;.&#34; and &#34;..&#34; are illegal values for newname and the error NFS4ERR_BADNAME will be returned if they are specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のサーバーでは、「。」および「..」はnewnameに無効な値であり、指定されている場合はエラーNFS4ERR_BADNAMEが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the current filehandle designates a named attribute directory and the object to be linked (the saved filehandle) is not a named attribute for the same object, the error NFS4ERR_XDEV MUST be returned. When the saved filehandle designates a named attribute and the current filehandle is not the appropriate named attribute directory, the error NFS4ERR_XDEV MUST also be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが名前付き属性ディレクトリを指定し、リンクされるオブジェクト（保存されたファイルハンドル）が同じオブジェクトの名前付き属性でない場合、エラーNFS4ERR_XDEVを返さなければなりません（MUST）。保存されたファイルハンドルが名前付き属性を指定し、現在のファイルハンドルが適切な名前付き属性ディレクトリでない場合、エラーNFS4ERR_XDEVも返されなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the current filehandle designates a named attribute directory and the object to be linked (the saved filehandle) is a named attribute within that directory, the server may return the error NFS4ERR_NOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが名前付き属性ディレクトリを指定し、リンクされるオブジェクト（保存されたファイルハンドル）がそのディレクトリ内の名前付き属性である場合、サーバーはエラーNFS4ERR_NOTSUPPを返すことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that newname is already linked to the file represented by the saved filehandle, the server will return NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保存されたファイルハンドルによって表されるファイルにnewnameがすでにリンクされている場合、サーバーはNFS4ERR_EXISTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that symbolic links are created with the CREATE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シンボリックリンクはCREATE操作で作成されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-10--Operation-12-LOCK---Create-Lock">
18.10. Operation 12: LOCK - Create Lock
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.10. 操作12：LOCK-ロックの作成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-10-1--ARGUMENTS">
18.10.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.10.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * For LOCK, transition from open_stateid and lock_owner
    * to a lock stateid.
    */
   struct open_to_lock_owner4 {
           seqid4          open_seqid;
           stateid4        open_stateid;
           seqid4          lock_seqid;
           lock_owner4     lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * For LOCK, existing lock stateid continues to request new
    * file lock for the same lock_owner and open_stateid.
    */
   struct exist_lock_owner4 {
           stateid4        lock_stateid;
           seqid4          lock_seqid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union locker4 switch (bool new_lock_owner) {
    case TRUE:
           open_to_lock_owner4     open_owner;
    case FALSE:
           exist_lock_owner4       lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * LOCK/LOCKT/LOCKU: Record lock management
    */
   struct LOCK4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           bool            reclaim;
           offset4         offset;
           length4         length;
           locker4         locker;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-10-2--RESULTS">
18.10.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.10.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCK4denied {
           offset4         offset;
           length4         length;
           nfs_lock_type4  locktype;
           lock_owner4     owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCK4resok {
           stateid4        lock_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LOCK4res switch (nfsstat4 status) {
    case NFS4_OK:
            LOCK4resok     resok4;
    case NFS4ERR_DENIED:
            LOCK4denied    denied;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-10-3--DESCRIPTION">
18.10.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.10.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOCK operation requests a byte-range lock for the byte-range specified by the offset and length parameters, and lock type specified in the locktype parameter. If this is a reclaim request, the reclaim parameter will be TRUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK操作は、offsetパラメータとlengthパラメータで指定されたバイト範囲、およびlocktypeパラメータで指定されたロックタイプのバイト範囲ロックを要求します。これが再利用リクエストの場合、再利用パラメーターはTRUEになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bytes in a file may be locked even if those bytes are not currently allocated to the file. To lock the file from a specific offset through the end-of-file (no matter how long the file actually is) use a length field equal to NFS4_UINT64_MAX. The server MUST return NFS4ERR_INVAL under the following combinations of length and offset:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイル内のバイトは、それらのバイトが現在ファイルに割り当てられていなくてもロックされる場合があります。特定のオフセットからファイルの終わりまでファイルをロックするには（ファイルが実際にどのくらい長くても）、NFS4_UINT64_MAXに等しい長さフィールドを使用します。サーバーは、長さとオフセットの次の組み合わせでNFS4ERR_INVALを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Length is equal to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Length is equal to zero.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Length is not equal to NFS4_UINT64_MAX, and the sum of length and offset exceeds NFS4_UINT64_MAX.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 長さがNFS4_UINT64_MAXと等しくなく、長さとオフセットの合計がNFS4_UINT64_MAXを超えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32-bit servers are servers that support locking for byte offsets that fit within 32 bits (i.e., less than or equal to NFS4_UINT32_MAX). If the client specifies a range that overlaps one or more bytes beyond offset NFS4_UINT32_MAX but does not end at offset NFS4_UINT64_MAX, then such a 32-bit server MUST return the error NFS4ERR_BAD_RANGE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32ビットサーバーは、32ビット内に収まるバイトオフセット（つまり、NFS4_UINT32_MAX以下）のロックをサポートするサーバーです。クライアントがオフセットNFS4_UINT32_MAXを超えて1バイト以上オーバーラップする範囲を指定しているが、オフセットNFS4_UINT64_MAXで終わっていない場合、そのような32ビットサーバーはエラーNFS4ERR_BAD_RANGEを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server returns NFS4ERR_DENIED, the owner, offset, and length of a conflicting lock are returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがNFS4ERR_DENIEDを返す場合、所有者、オフセット、および競合するロックの長さが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The locker argument specifies the lock-owner that is associated with the LOCK operation. The locker4 structure is a switched union that indicates whether the client has already created byte-range locking state associated with the current open file and lock-owner. In the case in which it has, the argument is just a stateid representing the set of locks associated with that open file and lock-owner, together with a lock_seqid value that MAY be any value and MUST be ignored by the server. In the case where no byte-range locking state has been established, or the client does not have the stateid available, the argument contains the stateid of the open file with which this lock is to be associated, together with the lock-owner with which the lock is to be associated. The open_to_lock_owner case covers the very first lock done by a lock-owner for a given open file and offers a method to use the established state of the open_stateid to transition to the use of a lock stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
locker引数は、LOCK操作に関連付けられているロック所有者を指定します。 locker4構造体は、クライアントが現在開いているファイルとロック所有者に関連付けられたバイト範囲ロック状態をすでに作成しているかどうかを示すスイッチドユニオンです。持っている場合、引数は、開いているファイルとロック所有者に関連付けられているロックのセットを表すstateidであり、任意の値であり、サーバーによって無視される可能性があるlock_seqid値と一緒です。バイト範囲のロック状態が確立されていない場合、またはクライアントに使用可能な状態IDがない場合、引数には、このロックが関連付けられている開いているファイルの状態IDと、そのロック所有者が含まれます。ロックが関連付けられます。 open_to_lock_ownerケースは、特定のオープンファイルに対してロック所有者が行った最初のロックをカバーし、open_stateidの確立された状態を使用してロック状態IDの使用に移行する方法を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following fields of the locker parameter MAY be set to any value by the client and MUST be ignored by the server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロッカーパラメータの次のフィールドは、クライアントによって任意の値に設定される場合があり、サーバーによって無視される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The clientid field of the lock_owner field of the open_owner field (locker.open_owner.lock_owner.clientid). The reason the server MUST ignore the clientid field is that the server MUST derive the client ID from the session ID from the SEQUENCE operation of the COMPOUND request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o open_ownerフィールド（locker.open_owner.lock_owner.clientid）のlock_ownerフィールドのclientidフィールド。サーバーがclientidフィールドを無視しなければならない理由は、サーバーがCOMPOUNDリクエストのSEQUENCE操作からのセッションIDからクライアントIDを導出しなければならないからです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The open_seqid and lock_seqid fields of the open_owner field (locker.open_owner.open_seqid and locker.open_owner.lock_seqid).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o open_ownerフィールドのopen_seqidおよびlock_seqidフィールド（locker.open_owner.open_seqidおよびlocker.open_owner.lock_seqid）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The lock_seqid field of the lock_owner field (locker.lock_owner.lock_seqid).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o lock_ownerフィールド（locker.lock_owner.lock_seqid）のlock_seqidフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the client ID appearing in a LOCK4denied structure is the actual client associated with the conflicting lock, whether this is the client ID associated with the current session or a different one. Thus, if the server returns NFS4ERR_DENIED, it MUST set the clientid field of the owner field of the denied field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK4denied構造に表示されるクライアントIDは、現在のセッションに関連付けられているクライアントIDでも、別のセッションに関連付けられているクライアントIDでも、競合するロックに関連付けられている実際のクライアントです。したがって、サーバーがNFS4ERR_DENIEDを返す場合、拒否されたフィールドの所有者フィールドのclientidフィールドを設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is not an ordinary file, an error will be returned to the client. In the case that the current filehandle represents an object of type NF4DIR, NFS4ERR_ISDIR is returned. If the current filehandle designates a symbolic link, NFS4ERR_SYMLINK is returned. In all other cases, NFS4ERR_WRONG_TYPE is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが通常のファイルではない場合、クライアントにエラーが返されます。現在のファイルハンドルがNF4DIRタイプのオブジェクトを表す場合、NFS4ERR_ISDIRが返されます。現在のファイルハンドルがシンボリックリンクを指定している場合、NFS4ERR_SYMLINKが返されます。それ以外の場合はすべて、NFS4ERR_WRONG_TYPEが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-10-4--IMPLEMENTATION">
18.10.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.10.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server is unable to determine the exact offset and length of the conflicting byte-range lock, the same offset and length that were provided in the arguments should be returned in the denied results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが競合するバイト範囲ロックの正確なオフセットと長さを判別できない場合、引数で指定されたものと同じオフセットと長さが拒否された結果に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK operations are subject to permission checks and to checks against the access type of the associated file. However, the specific right and modes required for various types of locks reflect the semantics of the server-exported file system, and are not specified by the protocol. For example, Windows 2000 allows a write lock of a file open for read access, while a POSIX-compliant system does not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK操作は、権限チェックと、関連ファイルのアクセスタイプに対するチェックの対象となります。ただし、さまざまなタイプのロックに必要な特定の権限とモードは、サーバーでエクスポートされたファイルシステムのセマンティクスを反映しており、プロトコルでは指定されていません。たとえば、Windows 2000では読み取りアクセス用に開いているファイルの書き込みロックが許可されていますが、POSIX準拠のシステムでは許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When the client sends a LOCK operation that corresponds to a range that the lock-owner has locked already (with the same or different lock type), or to a sub-range of such a range, or to a byte-range that includes multiple locks already granted to that lock-owner, in whole or in part, and the server does not support such locking operations (i.e., does not support POSIX locking semantics), the server will return the error NFS4ERR_LOCK_RANGE. In that case, the client may return an error, or it may emulate the required operations, using only LOCK for ranges that do not include any bytes already locked by that lock-owner and LOCKU of locks held by that lock-owner (specifying an exactly matching range and type). Similarly, when the client sends a LOCK operation that amounts to upgrading (changing from a READ_LT lock to a WRITE_LT lock) or downgrading (changing from WRITE_LT lock to a READ_LT lock) an existing byte-range lock, and the server does not support such a lock, the server will return NFS4ERR_LOCK_NOTSUPP. Such operations may not perfectly reflect the required semantics in the face of conflicting LOCK operations from other clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントが、ロック所有者がすでにロックした（同じまたは異なるロックタイプで）範囲、またはそのような範囲のサブ範囲、または複数を含むバイト範囲に対応するLOCK操作を送信するときそのロック所有者に全体的または部分的にすでに付与されているロックであり、サーバーがそのようなロック操作をサポートしていない（つまり、POSIXロックセマンティクスをサポートしていない）場合、サーバーはエラーNFS4ERR_LOCK_RANGEを返します。その場合、クライアントはエラーを返すか、必要な操作をエミュレートし、そのロック所有者によってすでにロックされているバイトとそのロック所有者によって保持されているロックのLOCKUを含まない範囲のLOCKのみを使用します（指定する正確に一致する範囲とタイプ）。同様に、クライアントが既存のバイト範囲ロックをアップグレード（READ_LTロックからWRITE_LTロックに変更）またはダウングレード（WRITE_LTロックからREAD_LTロックに変更）するLOCK操作を送信し、サーバーがそのような操作をサポートしていない場合ロックの場合、サーバーはNFS4ERR_LOCK_NOTSUPPを返します。このような操作は、他のクライアントからのLOCK操作の競合に直面して、必要なセマンティクスを完全に反映していない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client holds an OPEN_DELEGATE_WRITE delegation, the client holding that delegation is assured that there are no opens by other clients. Thus, there can be no conflicting LOCK operations from such clients. Therefore, the client may be handling locking requests locally, without doing LOCK operations on the server. If it does that, it must be prepared to update the lock status on the server, by sending appropriate LOCK and LOCKU operations before returning the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがOPEN_DELEGATE_WRITE委任を保持している場合、その委任を保持しているクライアントは、他のクライアントによるオープンがないことが保証されます。したがって、そのようなクライアントからのLOCK操作の競合はありません。したがって、クライアントは、サーバーでLOCK操作を実行せずに、ローカルでロック要求を処理している可能性があります。その場合は、委任を返す前に、適切なLOCKおよびLOCKU操作を送信して、サーバーのロックステータスを更新する準備をする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When one or more clients hold OPEN_DELEGATE_READ delegations, any LOCK operation where the server is implementing mandatory locking semantics MUST result in the recall of all such delegations. The LOCK operation may not be granted until all such delegations are returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while the delegation remains outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つ以上のクライアントがOPEN_DELEGATE_READ委任を保持している場合、サーバーが必須のロックセマンティクスを実装しているLOCK操作では、そのようなすべての委任が再呼び出しされる必要があります。 LOCK操作は、そのような委任がすべて返されるか取り消されるまで許可されない場合があります。これが非常に迅速に発生する場合を除いて、委任が未解決のままである間に、1つ以上のNFS4ERR_DELAYエラーが要求に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-11--Operation-13-LOCKT---Test-for-Lock">
18.11. Operation 13: LOCKT - Test for Lock
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.11. 操作13：LOCKT-ロックのテスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-11-1--ARGUMENTS">
18.11.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.11.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCKT4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           offset4         offset;
           length4         length;
           lock_owner4     owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-11-2--RESULTS">
18.11.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.11.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LOCKT4res switch (nfsstat4 status) {
    case NFS4ERR_DENIED:
            LOCK4denied    denied;
    case NFS4_OK:
            void;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-11-3--DESCRIPTION">
18.11.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.11.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOCKT operation tests the lock as specified in the arguments. If a conflicting lock exists, the owner, offset, length, and type of the conflicting lock are returned. The owner field in the results includes the client ID of the owner of the conflicting lock, whether this is the client ID associated with the current session or a different client ID. If no lock is held, nothing other than NFS4_OK is returned. Lock types READ_LT and READW_LT are processed in the same way in that a conflicting lock test is done without regard to blocking or non-blocking. The same is true for WRITE_LT and WRITEW_LT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKT操作は、引数で指定されたロックをテストします。競合するロックが存在する場合、競合するロックの所有者、オフセット、長さ、およびタイプが返されます。結果の所有者フィールドには、現在のセッションに関連付けられているクライアントIDでも、別のクライアントIDでも、競合するロックの所有者のクライアントIDが含まれます。ロックが保持されていない場合、NFS4_OK以外は何も返されません。ロック・タイプREAD_LTおよびREADW_LTは、ブロッキングまたは非ブロッキングに関係なく、競合するロック・テストが行​​われるのと同じ方法で処理されます。 WRITE_LTおよびWRITEW_LTについても同様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ranges are specified as for LOCK. The NFS4ERR_INVAL and NFS4ERR_BAD_RANGE errors are returned under the same circumstances as for LOCK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
範囲はLOCKの場合と同様に指定されます。 NFS4ERR_INVALおよびNFS4ERR_BAD_RANGEエラーは、LOCKの場合と同じ状況で返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The clientid field of the owner MAY be set to any value by the client and MUST be ignored by the server. The reason the server MUST ignore the clientid field is that the server MUST derive the client ID from the session ID from the SEQUENCE operation of the COMPOUND request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者のclientidフィールドは、クライアントによって任意の値に設定される場合があり、サーバーによって無視されなければならない（MUST）。サーバーがclientidフィールドを無視しなければならない理由は、サーバーがCOMPOUNDリクエストのSEQUENCE操作からのセッションIDからクライアントIDを導出しなければならないからです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is not an ordinary file, an error will be returned to the client. In the case that the current filehandle represents an object of type NF4DIR, NFS4ERR_ISDIR is returned. If the current filehandle designates a symbolic link, NFS4ERR_SYMLINK is returned. In all other cases, NFS4ERR_WRONG_TYPE is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが通常のファイルではない場合、クライアントにエラーが返されます。現在のファイルハンドルがNF4DIRタイプのオブジェクトを表す場合、NFS4ERR_ISDIRが返されます。現在のファイルハンドルがシンボリックリンクを指定している場合、NFS4ERR_SYMLINKが返されます。それ以外の場合はすべて、NFS4ERR_WRONG_TYPEが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-11-4--IMPLEMENTATION">
18.11.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.11.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server is unable to determine the exact offset and length of the conflicting lock, the same offset and length that were provided in the arguments should be returned in the denied results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server is unable to determine the exact offset and length of the conflicting lock, the same offset and length that were provided in the arguments should be returned in the denied results.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKT uses a lock_owner4 rather a stateid4, as is used in LOCK to identify the owner. This is because the client does not have to open the file to test for the existence of a lock, so a stateid might not be available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKTは、所有者を識別するためにLOCKで使用されるように、stateid4ではなく、lock_owner4を使用します。これは、クライアントがロックの存在をテストするためにファイルを開く必要がないため、stateidが使用できない場合があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As noted in Section 18.10.4, some servers may return NFS4ERR_LOCK_RANGE to certain (otherwise non-conflicting) LOCK operations that overlap ranges already granted to the current lock-owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As noted in Section 18.10.4, some servers may return NFS4ERR_LOCK_RANGE to certain (otherwise non-conflicting) LOCK operations that overlap ranges already granted to the current lock-owner.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOCKT operation&#39;s test for conflicting locks SHOULD exclude locks for the current lock-owner, and thus should return NFS4_OK in such cases. Note that this means that a server might return NFS4_OK to a LOCKT request even though a LOCK operation for the same range and lock-owner would fail with NFS4ERR_LOCK_RANGE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKT操作の競合するロックのテストでは、現在のロック所有者のロックを除外する必要があるため（SHOULD）、そのような場合はNFS4_OKを返す必要があります。これは、同じ範囲とロックの所有者に対するLOCK操作がNFS4ERR_LOCK_RANGEで失敗しても、サーバーがNFS4_OKをLOCKT要求に返す可能性があることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client holds an OPEN_DELEGATE_WRITE delegation, it may choose (see Section 18.10.4) to handle LOCK requests locally. In such a case, LOCKT requests will similarly be handled locally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがOPEN_DELEGATE_WRITE委任を保持している場合、LOCK要求をローカルで処理することを選択できます（セクション18.10.4を参照）。このような場合、LOCKT要求は同様にローカルで処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-12--Operation-14-LOCKU---Unlock-File">
18.12. Operation 14: LOCKU - Unlock File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.12. 操作14：LOCKU-ファイルのロック解除
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-12-1--ARGUMENTS">
18.12.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.12.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCKU4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           seqid4          seqid;
           stateid4        lock_stateid;
           offset4         offset;
           length4         length;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-12-2--RESULTS">
18.12.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.12.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LOCKU4res switch (nfsstat4 status) {
    case   NFS4_OK:
            stateid4       lock_stateid;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-12-3--DESCRIPTION">
18.12.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.12.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOCKU operation unlocks the byte-range lock specified by the parameters. The client may set the locktype field to any value that is legal for the nfs_lock_type4 enumerated type, and the server MUST accept any legal value for locktype. Any legal value for locktype has no effect on the success or failure of the LOCKU operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKU操作は、パラメーターで指定されたバイト範囲ロックをアンロックします。クライアントは、locktypeフィールドをnfs_lock_type4列挙型に有効な任意の値に設定できます。サーバーは、locktypeに有効な任意の値を受け入れる必要があります。 locktypeの正当な値は、LOCKU操作の成功または失敗には影響しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ranges are specified as for LOCK. The NFS4ERR_INVAL and NFS4ERR_BAD_RANGE errors are returned under the same circumstances as for LOCK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
範囲はLOCKの場合と同様に指定されます。 NFS4ERR_INVALおよびNFS4ERR_BAD_RANGEエラーは、LOCKの場合と同じ状況で返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The seqid parameter MAY be any value and the server MUST ignore it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
seqidパラメータは任意の値である場合があり、サーバーはそれを無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is not an ordinary file, an error will be returned to the client. In the case that the current filehandle represents an object of type NF4DIR, NFS4ERR_ISDIR is returned. If the current filehandle designates a symbolic link, NFS4ERR_SYMLINK is returned. In all other cases, NFS4ERR_WRONG_TYPE is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが通常のファイルではない場合、クライアントにエラーが返されます。現在のファイルハンドルがNF4DIRタイプのオブジェクトを表す場合、NFS4ERR_ISDIRが返されます。現在のファイルハンドルがシンボリックリンクを指定している場合、NFS4ERR_SYMLINKが返されます。それ以外の場合はすべて、NFS4ERR_WRONG_TYPEが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MAY require that the principal, security flavor, and if applicable, the GSS mechanism, combination that sent a LOCK operation also be the one to send LOCKU on the file. This might not be possible if credentials for the principal are no longer available. The server MAY allow the machine credential or SSV credential (see Section 18.35) to send LOCKU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、LOCK操作を送信したプリンシパル、セキュリティフレーバー、および該当する場合はGSSメカニズムの組み合わせが、ファイルにLOCKUを送信するものであることを要求する場合があります。プリンシパルの資格情報が使用できなくなった場合、これは不可能である可能性があります。サーバーは、マシン資格情報またはSSV資格情報（セクション18.35を参照）がLOCKUを送信することを許可する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-12-4--IMPLEMENTATION">
18.12.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.12.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the area to be unlocked does not correspond exactly to a lock actually held by the lock-owner, the server may return the error NFS4ERR_LOCK_RANGE. This includes the case in which the area is not locked, where the area is a sub-range of the area locked, where it overlaps the area locked without matching exactly, or the area specified includes multiple locks held by the lock-owner. In all of these cases, allowed by POSIX locking [24] semantics, a client receiving this error should, if it desires support for such operations, simulate the operation using LOCKU on ranges corresponding to locks it actually holds, possibly followed by LOCK operations for the sub-ranges not being unlocked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック解除する領域が、ロック所有者が実際に保持しているロックに正確に対応していない場合、サーバーはエラーNFS4ERR_LOCK_RANGEを返すことがあります。これには、領域がロックされていない、領域がロックされた領域のサブ範囲である、完全に一致せずにロックされた領域と重なる、または指定された領域にロック所有者が保持する複数のロックが含まれる場合が含まれます。 POSIXロッキング[24]セマンティクスで許可されているこれらすべてのケースで、このエラーを受け取るクライアントは、そのような操作のサポートが必要な場合、実際に保持しているロックに対応する範囲でLOCKUを使用して操作をシミュレートし、その後にLOCK操作を実行する必要があります。ロック解除されていないサブ範囲。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client holds an OPEN_DELEGATE_WRITE delegation, it may choose (see Section 18.10.4) to handle LOCK requests locally. In such a case, LOCKU operations will similarly be handled locally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがOPEN_DELEGATE_WRITE委任を保持している場合、LOCK要求をローカルで処理することを選択できます（セクション18.10.4を参照）。そのような場合、LOCKU操作はローカルで同様に処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-13--Operation-15-LOOKUP---Lookup-Filename">
18.13. Operation 15: LOOKUP - Lookup Filename
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.13. Operation 15: LOOKUP - Lookup Filename
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-13-1--ARGUMENTS">
18.13.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.13.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOOKUP4args {
           /* CURRENT_FH: directory */
           component4      objname;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-13-2--RESULTS">
18.13.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.13.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOOKUP4res {
           /* New CURRENT_FH: object */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-13-3--DESCRIPTION">
18.13.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.13.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOOKUP operation looks up or finds a file system object using the directory specified by the current filehandle. LOOKUP evaluates the component and if the object exists, the current filehandle is replaced with the component&#39;s filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOOKUP操作は、現在のファイルハンドルで指定されたディレクトリを使用して、ファイルシステムオブジェクトを検索または検索します。 LOOKUPはコンポーネントを評価し、オブジェクトが存在する場合、現在のファイルハンドルがコンポーネントのファイルハンドルに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the component cannot be evaluated either because it does not exist or because the client does not have permission to evaluate the component, then an error will be returned and the current filehandle will be unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンポーネントが存在しないため、またはクライアントにコンポーネントを評価する権限がないためにコンポーネントを評価できない場合、エラーが返され、現在のファイルハンドルは変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the component is a zero-length string or if any component does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンポーネントが長さ0の文字列である場合、またはいずれかのコンポーネントがUTF-8定義に従っていない場合、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-13-4--IMPLEMENTATION">
18.13.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.13.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client wants to achieve the effect of a multi-component look up, it may construct a COMPOUND request such as (and obtain each filehandle):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがマルチコンポーネントルックアップの効果を達成したい場合は、次のようなCOMPOUNDリクエストを作成します（各ファイルハンドルを取得します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
PUTFH (directory filehandle) LOOKUP &#34;pub&#34; GETFH LOOKUP &#34;foo&#34; GETFH LOOKUP &#34;bar&#34; GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
PUTFH（ディレクトリファイルハンドル）LOOKUP &#34;pub&#34; GETFH LOOKUP &#34;foo&#34; GETFH LOOKUP &#34;bar&#34; GETFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike NFSv3, NFSv4.1 allows LOOKUP requests to cross mountpoints on the server. The client can detect a mountpoint crossing by comparing the fsid attribute of the directory with the fsid attribute of the directory looked up. If the fsids are different, then the new directory is a server mountpoint. UNIX clients that detect a mountpoint crossing will need to mount the server&#39;s file system. This needs to be done to maintain the file object identity checking mechanisms common to UNIX clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv3とは異なり、NFSv4.1では、LOOKUP要求がサーバー上のマウントポイントをクロスすることができます。クライアントは、ディレクトリのfsid属性と、検索されたディレクトリのfsid属性を比較することにより、マウントポイントの交差を検出できます。 fsidが異なる場合、新しいディレクトリはサーバーのマウントポイントです。マウントポイントの交差を検出するUNIXクライアントは、サーバーのファイルシステムをマウントする必要があります。これは、UNIXクライアントに共通のファイルオブジェクトIDチェックメカニズムを維持するために実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers that limit NFS access to &#34;shared&#34; or &#34;exported&#34; file systems should provide a pseudo file system into which the exported file systems can be integrated, so that clients can browse the server&#39;s namespace. The clients view of a pseudo file system will be limited to paths that lead to exported file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSアクセスを「共有」または「エクスポート」ファイルシステムに制限するサーバーは、クライアントがサーバーの名前空間を参照できるように、エクスポートファイルシステムを統合できる疑似ファイルシステムを提供する必要があります。疑似ファイルシステムのクライアントビューは、エクスポートされたファイルシステムにつながるパスに制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: previous versions of the protocol assigned special semantics to the names &#34;.&#34; and &#34;..&#34;. NFSv4.1 assigns no special semantics to these names. The LOOKUPP operator must be used to look up a parent directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：以前のバージョンのプロトコルでは、名前「。」に特別なセマンティクスが割り当てられていました。そして「..」。 NFSv4.1は、これらの名前に特別なセマンティクスを割り当てません。親ディレクトリを検索するには、LOOKUPP演算子を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this operation does not follow symbolic links. The client is responsible for all parsing of filenames including filenames that are modified by symbolic links encountered during the look up process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作はシンボリックリンクをたどらないことに注意してください。クライアントは、ルックアッププロセス中に検出されたシンボリックリンクによって変更されたファイル名を含む、すべてのファイル名の解析を担当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle supplied is not a directory but a symbolic link, the error NFS4ERR_SYMLINK is returned as the error. For all other non-directory file types, the error NFS4ERR_NOTDIR is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
提供された現在のファイルハンドルがディレクトリではなくシンボリックリンクである場合、エラーNFS4ERR_SYMLINKがエラーとして返されます。他のすべての非ディレクトリファイルタイプの場合、エラーNFS4ERR_NOTDIRが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-14--Operation-16-LOOKUPP---Lookup-Parent-Directory">
18.14. Operation 16: LOOKUPP - Lookup Parent Directory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.14. 操作16：LOOKUPP-親ディレクトリの検索
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-14-1--ARGUMENTS">
18.14.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.14.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* CURRENT_FH: object */
   void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-14-2--RESULTS">
18.14.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.14.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOOKUPP4res {
           /* new CURRENT_FH: parent directory */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-14-3--DESCRIPTION">
18.14.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.14.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current filehandle is assumed to refer to a regular directory or a named attribute directory. LOOKUPP assigns the filehandle for its parent directory to be the current filehandle. If there is no parent directory, an NFS4ERR_NOENT error must be returned. Therefore, NFS4ERR_NOENT will be returned by the server when the current filehandle is at the root or top of the server&#39;s file tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルは、通常のディレクトリまたは名前付き属性ディレクトリを参照すると想定されています。 LOOKUPPは、親ディレクトリのファイルハンドルを現在のファイルハンドルに割り当てます。親ディレクトリがない場合は、NFS4ERR_NOENTエラーを返す必要があります。したがって、現在のファイルハンドルがサーバーのファイルツリーのルートまたは最上位にある場合、サーバーはNFS4ERR_NOENTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As is the case with LOOKUP, LOOKUPP will also cross mountpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOOKUPの場合と同様に、LOOKUPPもマウントポイントを通過します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is not a directory or named attribute directory, the error NFS4ERR_NOTDIR is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルがディレクトリまたは名前付き属性ディレクトリでない場合、エラーNFS4ERR_NOTDIRが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the requester&#39;s security flavor does not match that configured for the parent directory, then the server SHOULD return NFS4ERR_WRONGSEC (a future minor revision of NFSv4 may upgrade this to MUST) in the LOOKUPP response. However, if the server does so, it MUST support the SECINFO_NO_NAME operation (Section 18.45), so that the client can gracefully determine the correct security flavor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the requester&#39;s security flavor does not match that configured for the parent directory, then the server SHOULD return NFS4ERR_WRONGSEC (a future minor revision of NFSv4 may upgrade this to MUST) in the LOOKUPP response. However, if the server does so, it MUST support the SECINFO_NO_NAME operation (Section 18.45), so that the client can gracefully determine the correct security flavor.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is a named attribute directory that is associated with a file system object via OPENATTR (i.e., not a sub-directory of a named attribute directory), LOOKUPP SHOULD return the filehandle of the associated file system object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルがOPENATTRを介してファイルシステムオブジェクトに関連付けられている名前付き属性ディレクトリである場合（つまり、名前付き属性ディレクトリのサブディレクトリではない場合）、LOOKUPPは関連付けられているファイルシステムオブジェクトのファイルハンドルを返す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-14-4--IMPLEMENTATION">
18.14.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.14.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An issue to note is upward navigation from named attribute directories. The named attribute directories are essentially detached from the namespace, and this property should be safely represented in the client operating environment. LOOKUPP on a named attribute directory may return the filehandle of the associated file, and conveying this to applications might be unsafe as many applications expect the parent of an object to always be a directory. Therefore, the client may want to hide the parent of named attribute directories (represented as &#34;..&#34; in UNIX) or represent the named attribute directory as its own parent (as is typically done for the file system root directory in UNIX).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意すべき問題は、名前付き属性ディレクトリからの上方ナビゲーションです。名前付き属性ディレクトリは基本的に名前空間から切り離されており、このプロパティはクライアントのオペレーティング環境で安全に表す必要があります。名前付き属性ディレクトリのLOOKUPPは、関連付けられたファイルのファイルハンドルを返す可能性があり、多くのアプリケーションはオブジェクトの親が常にディレクトリであると想定しているため、これをアプリケーションに伝達することは安全ではありません。したがって、クライアントは、名前付き属性ディレクトリ（UNIXでは「..」として表される）の親を非表示にするか、名前付き属性ディレクトリをそれ自体の親として表すことができます（通常、UNIXのファイルシステムルートディレクトリに対して行われます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-15--Operation-17-NVERIFY---Verify-Difference-in-Attributes">
18.15. Operation 17: NVERIFY - Verify Difference in Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.15. 操作17：NVERIFY-属性の違いを確認する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-15-1--ARGUMENTS">
18.15.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.15.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct NVERIFY4args {
           /* CURRENT_FH: object */
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-15-2--RESULTS">
18.15.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.15.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct NVERIFY4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-15-3--DESCRIPTION">
18.15.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.15.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used to prefix a sequence of operations to be performed if one or more attributes have changed on some file system object. If all the attributes match, then the error NFS4ERR_SAME MUST be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、ファイルシステムオブジェクトの1つ以上の属性が変更された場合に実行される一連の操作の前に付けるために使用されます。すべての属性が一致する場合、エラーNFS4ERR_SAMEを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-15-4--IMPLEMENTATION">
18.15.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.15.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is useful as a cache validation operator. If the object to which the attributes belong has changed, then the following operations may obtain new data associated with that object, for instance, to check if a file has been changed and obtain new data if it has:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、キャッシュ検証演算子として役立ちます。属性が属するオブジェクトが変更された場合、次の操作は、そのオブジェクトに関連付けられた新しいデータを取得する場合があります。たとえば、ファイルが変更されたかどうかを確認し、変更されている場合は新しいデータを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
SEQUENCE PUTFH fh NVERIFY attrbits attrs READ 0 32767
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
シーケンスPUTFH fh NVERIFY attrbits attrs READ 0 32767
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Contrast this with NFSv3, which would first send a GETATTR in one request/reply round trip, and then if attributes indicated that the client&#39;s cache was stale, then send a READ in another request/reply round trip.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これを、最初に1つの要求/応答の往復でGETATTRを送信し、次に属性がクライアントのキャッシュが古いことを示している場合は、別の要求/応答の往復でREADを送信するNFSv3とは対照的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that a RECOMMENDED attribute is specified in the NVERIFY operation and the server does not support that attribute for the file system object, the error NFS4ERR_ATTRNOTSUPP is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NVERIFY操作でRECOMMENDED属性が指定されていて、サーバーがファイルシステムオブジェクトのその属性をサポートしていない場合、エラーNFS4ERR_ATTRNOTSUPPがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the attribute rdattr_error or any set-only attribute (e.g., time_modify_set) is specified, the error NFS4ERR_INVAL is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性rdattr_errorまたは任意のセットのみの属性（time_modify_setなど）が指定されている場合、エラーNFS4ERR_INVALがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-16--Operation-18-OPEN---Open-a-Regular-File">
18.16. Operation 18: OPEN - Open a Regular File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.16. 操作18：OPEN-通常のファイルを開く
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-16-1--ARGUMENTS">
18.16.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.16.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Various definitions for OPEN
    */
   enum createmode4 {
           UNCHECKED4      = 0,
           GUARDED4        = 1,
           /* Deprecated in NFSv4.1. */
           EXCLUSIVE4      = 2,
           /*
            * New to NFSv4.1. If session is persistent,
            * GUARDED4 MUST be used.  Otherwise, use
            * EXCLUSIVE4_1 instead of EXCLUSIVE4.
            */
           EXCLUSIVE4_1    = 3
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct creatverfattr {
            verifier4      cva_verf;
            fattr4         cva_attrs;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union createhow4 switch (createmode4 mode) {
    case UNCHECKED4:
    case GUARDED4:
            fattr4         createattrs;
    case EXCLUSIVE4:
            verifier4      createverf;
    case EXCLUSIVE4_1:
            creatverfattr  ch_createboth;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum opentype4 {
           OPEN4_NOCREATE  = 0,
           OPEN4_CREATE    = 1
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union openflag4 switch (opentype4 opentype) {
    case OPEN4_CREATE:
            createhow4     how;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Next definitions used for OPEN delegation */
   enum limit_by4 {
           NFS_LIMIT_SIZE          = 1,
           NFS_LIMIT_BLOCKS        = 2
           /* others as needed */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfs_modified_limit4 {
           uint32_t        num_blocks;
           uint32_t        bytes_per_block;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_space_limit4 switch (limit_by4 limitby) {
    /* limit specified as file size */
    case NFS_LIMIT_SIZE:
            uint64_t               filesize;
    /* limit specified by number of blocks */
    case NFS_LIMIT_BLOCKS:
            nfs_modified_limit4    mod_blocks;
   } ;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Share Access and Deny constants for open argument
    */
   const OPEN4_SHARE_ACCESS_READ   = 0x00000001;
   const OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;
   const OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const OPEN4_SHARE_DENY_NONE     = 0x00000000;
   const OPEN4_SHARE_DENY_READ     = 0x00000001;
   const OPEN4_SHARE_DENY_WRITE    = 0x00000002;
   const OPEN4_SHARE_DENY_BOTH     = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* new flags for share_access field of OPEN4args */
   const OPEN4_SHARE_ACCESS_WANT_DELEG_MASK        = 0xFF00;
   const OPEN4_SHARE_ACCESS_WANT_NO_PREFERENCE     = 0x0000;
   const OPEN4_SHARE_ACCESS_WANT_READ_DELEG        = 0x0100;
   const OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG       = 0x0200;
   const OPEN4_SHARE_ACCESS_WANT_ANY_DELEG         = 0x0300;
   const OPEN4_SHARE_ACCESS_WANT_NO_DELEG          = 0x0400;
   const OPEN4_SHARE_ACCESS_WANT_CANCEL            = 0x0500;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL = 0x10000;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL = 0x10000;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED = 0x20000;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED = 0x20000;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum open_delegation_type4 {
           OPEN_DELEGATE_NONE      = 0,
           OPEN_DELEGATE_READ      = 1,
           OPEN_DELEGATE_WRITE     = 2,
           OPEN_DELEGATE_NONE_EXT  = 3 /* new to v4.1 */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum open_claim_type4 { /* * Not a reclaim. */ CLAIM_NULL = 0,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum open_claim_type4 {/ * *再利用ではありません。 * / CLAIM_NULL = 0、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
CLAIM_PREVIOUS = 1, CLAIM_DELEGATE_CUR = 2, CLAIM_DELEGATE_PREV = 3,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
CLAIM_PREVIOUS = 1、CLAIM_DELEGATE_CUR = 2、CLAIM_DELEGATE_PREV = 3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /*
            * Not a reclaim.
            *
            * Like CLAIM_NULL, but object identified
            * by the current filehandle.
            */
           CLAIM_FH                = 4, /* new to v4.1 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /*
            * Like CLAIM_DELEGATE_CUR, but object identified
            * by current filehandle.
            */
           CLAIM_DELEG_CUR_FH      = 5, /* new to v4.1 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /*
            * Like CLAIM_DELEGATE_PREV, but object identified
            * by current filehandle.
            */
           CLAIM_DELEG_PREV_FH     = 6 /* new to v4.1 */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_claim_delegate_cur4 {
           stateid4        delegate_stateid;
           component4      file;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union open_claim4 switch (open_claim_type4 claim) {
    /*
     * No special rights to file.
     * Ordinary OPEN of the specified file.
     */
    case CLAIM_NULL:
           /* CURRENT_FH: directory */
           component4      file;
    /*
     * Right to the file established by an
     * open previous to server reboot.  File
     * identified by filehandle obtained at
     * that time rather than by name.
     */
    case CLAIM_PREVIOUS:
           /* CURRENT_FH: file being reclaimed */
           open_delegation_type4   delegate_type;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /*
     * Right to file based on a delegation
     * granted by the server.  File is
     * specified by name.
     */
    case CLAIM_DELEGATE_CUR:
           /* CURRENT_FH: directory */
           open_claim_delegate_cur4        delegate_cur_info;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /*
     * Right to file based on a delegation
     * granted to a previous boot instance
     * of the client.  File is specified by name.
     */
    case CLAIM_DELEGATE_PREV:
            /* CURRENT_FH: directory */
           component4      file_delegate_prev;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /*
     * Like CLAIM_NULL.  No special rights
     * to file.  Ordinary OPEN of the
     * specified file by current filehandle.
     */
    case CLAIM_FH: /* new to v4.1 */
           /* CURRENT_FH: regular file to open */
           void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /*
     * Like CLAIM_DELEGATE_PREV.  Right to file based on a
     * delegation granted to a previous boot
     * instance of the client.  File is identified by
     * by filehandle.
     */
    case CLAIM_DELEG_PREV_FH: /* new to v4.1 */
           /* CURRENT_FH: file being opened */
           void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /*
     * Like CLAIM_DELEGATE_CUR.  Right to file based on
     * a delegation granted by the server.
     * File is identified by filehandle.
     */
    case CLAIM_DELEG_CUR_FH: /* new to v4.1 */
            /* CURRENT_FH: file being opened */
            stateid4       oc_delegate_stateid;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * OPEN: Open a file, potentially receiving an OPEN delegation
    */
   struct OPEN4args {
           seqid4          seqid;
           uint32_t        share_access;
           uint32_t        share_deny;
           open_owner4     owner;
           openflag4       openhow;
           open_claim4     claim;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-16-2--RESULTS">
18.16.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.16.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_read_delegation4 {
    stateid4 stateid;    /* Stateid for delegation*/
    bool     recall;     /* Pre-recalled flag for
                            delegations obtained
                            by reclaim (CLAIM_PREVIOUS) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    nfsace4 permissions; /* Defines users who don&#39;t
                            need an ACCESS call to
                            open for read */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_write_delegation4 {
    stateid4 stateid;      /* Stateid for delegation */
    bool     recall;       /* Pre-recalled flag for
                              delegations obtained
                              by reclaim
                              (CLAIM_PREVIOUS) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    nfs_space_limit4
              space_limit; /* Defines condition that
                              the client must check to
                              determine whether the
                              file needs to be flushed
                              to the server on close.  */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    nfsace4   permissions; /* Defines users who don&#39;t
                              need an ACCESS call as
                              part of a delegated
                              open. */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum why_no_delegation4 { /* new to v4.1 */
           WND4_NOT_WANTED         = 0,
           WND4_CONTENTION         = 1,
           WND4_RESOURCE           = 2,
           WND4_NOT_SUPP_FTYPE     = 3,
           WND4_WRITE_DELEG_NOT_SUPP_FTYPE = 4,
           WND4_NOT_SUPP_UPGRADE   = 5,
           WND4_NOT_SUPP_DOWNGRADE = 6,
           WND4_CANCELLED          = 7,
           WND4_IS_DIR             = 8
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union open_none_delegation4 /* new to v4.1 */
   switch (why_no_delegation4 ond_why) {
           case WND4_CONTENTION:
                   bool ond_server_will_push_deleg;
           case WND4_RESOURCE:
                   bool ond_server_will_signal_avail;
           default:
                   void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union open_delegation4
   switch (open_delegation_type4 delegation_type) {
           case OPEN_DELEGATE_NONE:
                   void;
           case OPEN_DELEGATE_READ:
                   open_read_delegation4 read;
           case OPEN_DELEGATE_WRITE:
                   open_write_delegation4 write;
           case OPEN_DELEGATE_NONE_EXT: /* new to v4.1 */
                   open_none_delegation4 od_whynone;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Result flags
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Client must confirm open */
   const OPEN4_RESULT_CONFIRM      = 0x00000002;
   /* Type of file locking behavior at the server */
   const OPEN4_RESULT_LOCKTYPE_POSIX = 0x00000004;
   /* Server will preserve file if removed while open */
   const OPEN4_RESULT_PRESERVE_UNLINKED = 0x00000008;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Server may use CB_NOTIFY_LOCK on locks
    * derived from this open
    */
   const OPEN4_RESULT_MAY_NOTIFY_LOCK = 0x00000020;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN4resok {
    stateid4       stateid;      /* Stateid for open */
    change_info4   cinfo;        /* Directory Change Info */
    uint32_t       rflags;       /* Result flags */
    bitmap4        attrset;      /* attribute set for create*/
    open_delegation4 delegation; /* Info on any open
                                    delegation */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OPEN4res switch (nfsstat4 status) {
    case NFS4_OK:
           /* New CURRENT_FH: opened file */
           OPEN4resok      resok4;
    default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-16-3--DESCRIPTION">
18.16.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.16.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPEN operation opens a regular file in a directory with the provided name or filehandle. OPEN can also create a file if a name is provided, and the client specifies it wants to create a file. Specification of whether or not a file is to be created, and the method of creation is via the openhow parameter. The openhow parameter consists of a switched union (data type opengflag4), which switches on the value of opentype (OPEN4_NOCREATE or OPEN4_CREATE). If OPEN4_CREATE is specified, this leads to another switched union (data type createhow4) that supports four cases of creation methods: UNCHECKED4, GUARDED4, EXCLUSIVE4, or EXCLUSIVE4_1. If opentype is OPEN4_CREATE, then the claim field of the claim field MUST be one of CLAIM_NULL, CLAIM_DELEGATE_CUR, or CLAIM_DELEGATE_PREV, because these claim methods include a component of a file name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN操作は、指定された名前またはファイルハンドルでディレクトリ内の通常のファイルを開きます。名前が提供され、クライアントがファイルを作成することを指定した場合、OPENはファイルを作成することもできます。ファイルを作成するかどうかの指定、および作成方法は、openhowパラメータを使用します。 openhowパラメータは、opentype（OPEN4_NOCREATEまたはOPEN4_CREATE）の値をオンにするスイッチドユニオン（データ型opengflag4）で構成されます。 OPEN4_CREATEが指定されている場合、これにより、UNCHECKED4、GUARDED4、EXCLUSIVE4、またはEXCLUSIVE4_1の4つの作成方法のケースをサポートする別のスイッチドユニオン（データ型createhow4）が作成されます。 opentypeがOPEN4_CREATEの場合、クレームフィールドのクレームフィールドには、CLAIM_NULL、CLAIM_DELEGATE_CUR、またはCLAIM_DELEGATE_PREVのいずれかを指定する必要があります。これらのクレームメソッドにはファイル名のコンポーネントが含まれているためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon success (which might entail creation of a new file), the current filehandle is replaced by that of the created or existing object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon success (which might entail creation of a new file), the current filehandle is replaced by that of the created or existing object.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is a named attribute directory, OPEN will then create or open a named attribute file. Note that exclusive create of a named attribute is not supported. If the createmode is EXCLUSIVE4 or EXCLUSIVE4_1 and the current filehandle is a named attribute directory, the server will return EINVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが名前付き属性ディレクトリである場合、OPENは名前付き属性ファイルを作成または開きます。名前付き属性の排他的な作成はサポートされていないことに注意してください。 createmodeがEXCLUSIVE4またはEXCLUSIVE4_1で、現在のファイルハンドルが名前付き属性ディレクトリである場合、サーバーはEINVALを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNCHECKED4 means that the file should be created if a file of that name does not exist and encountering an existing regular file of that name is not an error. For this type of create, createattrs specifies the initial set of attributes for the file. The set of attributes may include any writable attribute valid for regular files. When an UNCHECKED4 create encounters an existing file, the attributes specified by createattrs are not used, except that when createattrs specifies the size attribute with a size of zero, the existing file is truncated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNCHECKED4は、その名前のファイルが存在せず、その名前の既存の通常のファイルに遭遇してもエラーではない場合に、ファイルを作成する必要があることを意味します。このタイプの作成の場合、createattrsはファイルの属性の初期セットを指定します。属性のセットには、通常のファイルに有効な任意の書き込み可能な属性を含めることができます。 UNCHECKED4の作成で既存のファイルが検出されると、createattrsで指定された属性は使用されません。ただし、createattrsでサイズ属性がゼロのsize属性を指定すると、既存のファイルは切り捨てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If GUARDED4 is specified, the server checks for the presence of a duplicate object by name before performing the create. If a duplicate exists, NFS4ERR_EXIST is returned. If the object does not exist, the request is performed as described for UNCHECKED4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GUARDED4が指定されている場合、サーバーは、作成を実行する前に、名前で重複オブジェクトの存在を確認します。重複が存在する場合、NFS4ERR_EXISTが返されます。オブジェクトが存在しない場合、UNCHECKED4の説明に従って要求が実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the UNCHECKED4 and GUARDED4 cases, where the operation is successful, the server will return to the client an attribute mask signifying which attributes were successfully set for the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNCHECKED4およびGUARDED4の場合、操作が成功すると、サーバーはオブジェクトに設定された属性を示す属性マスクをクライアントに返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCLUSIVE4_1 and EXCLUSIVE4 specify that the server is to follow exclusive creation semantics, using the verifier to ensure exclusive creation of the target. The server should check for the presence of a duplicate object by name. If the object does not exist, the server creates the object and stores the verifier with the object. If the object does exist and the stored verifier matches the client provided verifier, the server uses the existing object as the newly created object. If the stored verifier does not match, then an error of NFS4ERR_EXIST is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCLUSIVE4_1およびEXCLUSIVE4は、サーバーが排他的作成セマンティクスに従うことを指定し、ベリファイアを使用してターゲットの排他的作成を保証します。サーバーは名前で重複オブジェクトの存在を確認する必要があります。オブジェクトが存在しない場合、サーバーはオブジェクトを作成し、オブジェクトとともにベリファイアを格納します。オブジェクトが存在し、格納されているベリファイアがクライアント提供のベリファイアと一致する場合、サーバーは既存のオブジェクトを新しく作成されたオブジェクトとして使用します。保存されたベリファイアが一致しない場合、NFS4ERR_EXISTのエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If using EXCLUSIVE4, and if the server uses attributes to store the exclusive create verifier, the server will signify which attributes it used by setting the appropriate bits in the attribute mask that is returned in the results. Unlike UNCHECKED4, GUARDED4, and EXCLUSIVE4_1, EXCLUSIVE4 does not support the setting of attributes at file creation, and after a successful OPEN via EXCLUSIVE4, the client MUST send a SETATTR to set attributes to a known state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCLUSIVE4を使用していて、サーバーが属性を使用して排他的作成ベリファイアを格納している場合、サーバーは、結果で返される属性マスクに適切なビットを設定することにより、使用した属性を示します。 UNCHECKED4、GUARDED4、およびEXCLUSIVE4_1とは異なり、EXCLUSIVE4はファイル作成時の属性の設定をサポートせず、EXCLUSIVE4を介してOPENが正常に完了した後、クライアントはSETATTRを送信して属性を既知の状態に設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In NFSv4.1, EXCLUSIVE4 has been deprecated in favor of EXCLUSIVE4_1. Unlike EXCLUSIVE4, attributes may be provided in the EXCLUSIVE4_1 case, but because the server may use attributes of the target object to store the verifier, the set of allowable attributes may be fewer than the set of attributes SETATTR allows. The allowable attributes for EXCLUSIVE4_1 are indicated in the suppattr_exclcreat (Section 5.8.1.14) attribute. If the client attempts to set in cva_attrs an attribute that is not in suppattr_exclcreat, the server MUST return NFS4ERR_INVAL. The response field, attrset, indicates both which attributes the server set from cva_attrs and which attributes the server used to store the verifier. As described in
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1では、EXCLUSIVE4_1の代わりにEXCLUSIVE4が非推奨になりました。 EXCLUSIVE4とは異なり、属性はEXCLUSIVE4_1の場合に提供されますが、サーバーはターゲットオブジェクトの属性を使用してベリファイアを格納するため、許可される属性のセットはSETATTRで許可される属性のセットよりも少ない場合があります。 EXCLUSIVE4_1に使用できる属性は、suppattr_exclcreat（セクション5.8.1.14）属性に示されています。クライアントがsuppattr_exclcreatにない属性をcva_attrsに設定しようとする場合、サーバーはNFS4ERR_INVALを返さなければなりません（MUST）。応答フィールドattrsetは、サーバーがcva_attrsから設定した属性と、サーバーがベリファイアの格納に使用した属性の両方を示します。で説明されているように
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 18.16.4, the client can compare cva_attrs.attrmask with attrset to determine which attributes were used to store the verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション18.16.4、クライアントはcva_attrs.attrmaskをattrsetと比較して、ベリファイアの格納に使用された属性を判別できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the addition of persistent sessions and pNFS, under some conditions EXCLUSIVE4 MUST NOT be used by the client or supported by the server. The following table summarizes the appropriate and mandated exclusive create methods for implementations of NFSv4.1:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
永続的なセッションとpNFSの追加により、一部の条件下では、EXCLUSIVE4をクライアントが使用したり、サーバーがサポートしたりしてはなりません（MUST NOT）。次の表は、NFSv4.1の実装に適した必須の排他的作成メソッドをまとめたものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
Required methods for exclusive create
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
排他的作成に必要なメソッド
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----------------+-----------+---------------+----------------------+
   | Persistent     | Server    | Server        | Client Allowed       |
   | Reply Cache    | Supports  | REQUIRED      |                      |
   | Enabled        | pNFS      |               |                      |
   +----------------+-----------+---------------+----------------------+
   | no             | no        | EXCLUSIVE4_1  | EXCLUSIVE4_1         |
   |                |           | and           | (SHOULD) or          |
   |                |           | EXCLUSIVE4    | EXCLUSIVE4 (SHOULD   |
   |                |           |               | NOT)                 |
   | no             | yes       | EXCLUSIVE4_1  | EXCLUSIVE4_1         |
   | yes            | no        | GUARDED4      | GUARDED4             |
   | yes            | yes       | GUARDED4      | GUARDED4             |
   +----------------+-----------+---------------+----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Table 10
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
表10
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If CREATE_SESSION4_FLAG_PERSIST is set in the results of CREATE_SESSION, the reply cache is persistent (see Section 18.36). If the EXCHGID4_FLAG_USE_PNFS_MDS flag is set in the results from EXCHANGE_ID, the server is a pNFS server (see Section 18.35). If the client attempts to use EXCLUSIVE4 on a persistent session, or a session derived from an EXCHGID4_FLAG_USE_PNFS_MDS client ID, the server MUST return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATE_SESSION4_FLAG_PERSISTがCREATE_SESSIONの結果に設定されている場合、応答キャッシュは永続的です（セクション18.36を参照）。 EXCHANGE_IDの結果にEXCHGID4_FLAG_USE_PNFS_MDSフラグが設定されている場合、サーバーはpNFSサーバーです（セクション18.35を参照）。クライアントが永続的なセッションまたはEXCHGID4_FLAG_USE_PNFS_MDSクライアントIDから派生したセッションでEXCLUSIVE4を使用しようとする場合、サーバーはNFS4ERR_INVALを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With persistent sessions, exclusive create semantics are fully achievable via GUARDED4, and so EXCLUSIVE4 or EXCLUSIVE4_1 MUST NOT be used. When pNFS is being used, the layout_hint attribute might not be supported after the file is created. Only the EXCLUSIVE4_1 and GUARDED methods of exclusive file creation allow the atomic setting of attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
永続的なセッションでは、排他的な作成セマンティクスはGUARDED4を介して完全に実現できるため、EXCLUSIVE4またはEXCLUSIVE4_1を使用してはなりません。 pNFSが使用されている場合、ファイルの作成後、layout_hint属性はサポートされない可能性があります。排他的なファイル作成のEXCLUSIVE4_1およびGUARDEDメソッドのみが属性のアトミック設定を許可します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 data type, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットディレクトリの場合、サーバーはchange_info4情報をcinfoに返します。 change_info4データ型のアトミックフィールドを使用すると、サーバーは、リンクの作成に関して変更前と変更後の属性がアトミックに取得されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPEN operation provides for Windows share reservation capability with the use of the share_access and share_deny fields of the OPEN arguments. The client specifies at OPEN the required share_access and share_deny modes. For clients that do not directly support SHAREs (i.e., UNIX), the expected deny value is OPEN4_SHARE_DENY_NONE. In the case that there is an existing SHARE reservation that conflicts with the OPEN request, the server returns the error NFS4ERR_SHARE_DENIED. For additional discussion of SHARE semantics, see Section 9.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN操作は、OPEN引数のshare_accessおよびshare_denyフィールドを使用して、Windows共有予約機能を提供します。クライアントは、OPENで必要なshare_accessおよびshare_denyモードを指定します。 SHAREを直接サポートしていないクライアント（UNIXなど）の場合、予想される拒否値はOPEN4_SHARE_DENY_NONEです。 OPEN要求と競合する既存のSHARE予約がある場合、サーバーはエラーNFS4ERR_SHARE_DENIEDを返します。 SHAREセマンティクスの詳細については、セクション9.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each OPEN, the client provides a value for the owner field of the OPEN argument. The owner field is of data type open_owner4, and contains a field called clientid and a field called owner. The client can set the clientid field to any value and the server MUST ignore it. Instead, the server MUST derive the client ID from the session ID of the SEQUENCE operation of the COMPOUND request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各OPENについて、クライアントはOPEN引数の所有者フィールドに値を提供します。 ownerフィールドはデータ型open_owner4で、clientidというフィールドとownerというフィールドが含まれています。クライアントはclientidフィールドを任意の値に設定でき、サーバーはそれを無視する必要があります。代わりに、サーバーはCOMPOUNDリクエストのSEQUENCE操作のセッションIDからクライアントIDを導出する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;seqid&#34; field of the request is not used in NFSv4.1, but it MAY be any value and the server MUST ignore it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストの「seqid」フィールドはNFSv4.1では使用されませんが、任意の値である場合があり、サーバーはそれを無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that the client is recovering state from a server failure, the claim field of the OPEN argument is used to signify that the request is meant to reclaim state previously held.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがサーバーの障害から状態を回復している場合、OPEN引数のクレームフィールドは、要求が以前に保持された状態を取り戻すことを意図していることを示すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;claim&#34; field of the OPEN argument is used to specify the file to be opened and the state information that the client claims to possess. There are seven claim types as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN引数の「claim」フィールドは、開かれるファイルとクライアントが所有すると主張する状態情報を指定するために使用されます。次の7つのクレームタイプがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----------------------+--------------------------------------------+
   | open type            | description                                |
   +----------------------+--------------------------------------------+
   | CLAIM_NULL, CLAIM_FH | For the client, this is a new OPEN request |
   |                      | and there is no previous state associated  |
   |                      | with the file for the client.  With        |
   |                      | CLAIM_NULL, the file is identified by the  |
   |                      | current filehandle and the specified       |
   |                      | component name.  With CLAIM_FH (new to     |
   |                      | NFSv4.1), the file is identified by just   |
   |                      | the current filehandle.                    |
   | CLAIM_PREVIOUS       | The client is claiming basic OPEN state    |
   |                      | for a file that was held previous to a     |
   |                      | server restart.  Generally used when a     |
   |                      | server is returning persistent             |
   |                      | filehandles; the client may not have the   |
   |                      | file name to reclaim the OPEN.             |
   | CLAIM_DELEGATE_CUR,  | The client is claiming a delegation for    |
   | CLAIM_DELEG_CUR_FH   | OPEN as granted by the server.  Generally, |
   |                      | this is done as part of recalling a        |
   |                      | delegation.  With CLAIM_DELEGATE_CUR, the  |
   |                      | file is identified by the current          |
   |                      | filehandle and the specified component     |
   |                      | name.  With CLAIM_DELEG_CUR_FH (new to     |
   |                      | NFSv4.1), the file is identified by just   |
   |                      | the current filehandle.                    |
   | CLAIM_DELEGATE_PREV, | The client is claiming a delegation        |
   | CLAIM_DELEG_PREV_FH  | granted to a previous client instance;     |
   |                      | used after the client restarts.  The       |
   |                      | server MAY support CLAIM_DELEGATE_PREV     |
   |                      | and/or CLAIM_DELEG_PREV_FH (new to         |
   |                      | NFSv4.1).  If it does support either claim |
   |                      | type, CREATE_SESSION MUST NOT remove the   |
   |                      | client&#39;s delegation state, and the server  |
   |                      | MUST support the DELEGPURGE operation.     |
   +----------------------+--------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For OPEN requests that reach the server during the grace period, the server returns an error of NFS4ERR_GRACE. The following claim types are exceptions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For OPEN requests that reach the server during the grace period, the server returns an error of NFS4ERR_GRACE. The following claim types are exceptions:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN requests specifying the claim type CLAIM_PREVIOUS are devoted to reclaiming opens after a server restart and are typically only valid during the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クレームタイプCLAIM_PREVIOUSを指定するOPENリクエストは、サーバーの再起動後にオープンを再利用するためのものであり、通常は猶予期間中にのみ有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o OPEN requests specifying the claim types CLAIM_DELEGATE_CUR and CLAIM_DELEG_CUR_FH are valid both during and after the grace period. Since the granting of the delegation that they are subordinate to assures that there is no conflict with locks to be reclaimed by other clients, the server need not return NFS4ERR_GRACE when these are received during the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
oクレームタイプCLAIM_DELEGATE_CURおよびCLAIM_DELEG_CUR_FHを指定するOPEN要求は、猶予期間中および猶予期間後の両方で有効です。他のクライアントによって再利用されるロックとの競合がないことを保証するために、それらが従属であるという委任を許可するため、猶予期間中にこれらが受信された場合、サーバーはNFS4ERR_GRACEを返す必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For any OPEN request, the server may return an OPEN delegation, which allows further opens and closes to be handled locally on the client as described in Section 10.4. Note that delegation is up to the server to decide. The client should never assume that delegation will or will not be granted in a particular instance. It should always be prepared for either case. A partial exception is the reclaim (CLAIM_PREVIOUS) case, in which a delegation type is claimed. In this case, delegation will always be granted, although the server may specify an immediate recall in the delegation structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN要求の場合、サーバーはOPEN委任を返すことがあります。これにより、セクション10.4で説明されているように、クライアント上でローカルでさらに開いたり閉じたりすることができます。委任は決定するサーバー次第であることに注意してください。クライアントは、特定のインスタンスで委任が許可されるかどうかを決して想定しないでください。どちらの場合も常に準備する必要があります。部分的な例外は、委任タイプが要求される再利用（CLAIM_PREVIOUS）の場合です。この場合、サーバーは委任構造で即時の再呼び出しを指定できますが、委任は常に許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rflags returned by a successful OPEN allow the server to return information governing how the open file is to be handled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENが成功すると返されるrflagsにより、サーバーは開いているファイルの処理方法を管理する情報を返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_RESULT_CONFIRM is deprecated and MUST NOT be returned by an NFSv4.1 server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_RESULT_CONFIRMは非推奨であり、NFSv4.1サーバーから返されてはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_RESULT_LOCKTYPE_POSIX indicates that the server&#39;s byte-range locking behavior supports the complete set of POSIX locking techniques [24]. From this, the client can choose to manage byte-range locking state in a way to handle a mismatch of byte-range locking management.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_RESULT_LOCKTYPE_POSIXは、サーバーのバイト範囲ロック動作がPOSIXロックテクニックの完全なセットをサポートすることを示します[24]。これにより、クライアントは、バイト範囲ロック管理の不一致を処理する方法でバイト範囲ロック状態を管理することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_RESULT_PRESERVE_UNLINKED indicates that the server will preserve the open file if the client (or any other client) removes the file as long as it is open. Furthermore, the server promises to preserve the file through the grace period after server restart, thereby giving the client the opportunity to reclaim its open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_RESULT_PRESERVE_UNLINKEDは、クライアント（または他のクライアント）がファイルを開いている限り、ファイルを削除した場合、サーバーが開いているファイルを保持することを示します。さらに、サーバーは、サーバーの再起動後、猶予期間中ファイルを保持することを約束するため、クライアントはオープン状態を取り戻すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_RESULT_MAY_NOTIFY_LOCK indicates that the server may attempt CB_NOTIFY_LOCK callbacks for locks on this file. This flag is a hint only, and may be safely ignored by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_RESULT_MAY_NOTIFY_LOCKは、サーバーがこのファイルのロックに対してCB_NOTIFY_LOCKコールバックを試行できることを示します。このフラグはヒントのみであり、クライアントによって安全に無視される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the component is of zero length, NFS4ERR_INVAL will be returned. The component is also subject to the normal UTF-8, character support, and name checks. See Section 14.5 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンポーネントの長さがゼロの場合、NFS4ERR_INVALが返されます。このコンポーネントは、通常のUTF-8、文字サポート、および名前のチェックも受けます。詳細については、セクション14.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When an OPEN is done and the specified open-owner already has the resulting filehandle open, the result is to &#34;OR&#34; together the new share and deny status together with the existing status. In this case, only a single CLOSE need be done, even though multiple OPENs were completed. When such an OPEN is done, checking of share reservations for the new OPEN proceeds normally, with no exception for the existing OPEN held by the same open-owner. In this case, the stateid returned as an &#34;other&#34; field that matches that of the previous open while the &#34;seqid&#34; field is incremented to reflect the change status due to the new open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
OPENが実行され、指定されたopen-ownerが既にファイルハンドルを開いている場合、結果は、新しい共有を「OR」し、既存のステータスとステータスを拒否します。この場合、複数のOPENが完了した場合でも、1回のCLOSEで済みます。このようなOPENが行われると、同じOPEN所有者が保持している既存のOPENを例外として、新しいOPENの共有予約のチェックは通常どおりに行われます。この場合、stateidは以前のオープンのフィールドと一致する「other」フィールドとして返され、「seqid」フィールドはインクリメントされて、新しいオープンによる変更ステータスが反映されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the underlying file system at the server is only accessible in a read-only mode and the OPEN request has specified ACCESS_WRITE or ACCESS_BOTH, the server will return NFS4ERR_ROFS to indicate a read-only file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the underlying file system at the server is only accessible in a read-only mode and the OPEN request has specified ACCESS_WRITE or ACCESS_BOTH, the server will return NFS4ERR_ROFS to indicate a read-only file system.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with the CREATE operation, the server MUST derive the owner, owner ACE, group, or group ACE if any of the four attributes are required and supported by the server&#39;s file system. For an OPEN with the EXCLUSIVE4 createmode, the server has no choice, since such OPEN calls do not include the createattrs field. Conversely, if createattrs (UNCHECKED4 or GUARDED4) or cva_attrs (EXCLUSIVE4_1) is specified, and includes an owner, owner_group, or ACE that the principal in the RPC call&#39;s credentials does not have authorization to create files for, then the server may return NFS4ERR_PERM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATE操作と同様に、4つの属性のいずれかが必要であり、サーバーのファイルシステムでサポートされている場合、サーバーは所有者、所有者ACE、グループ、またはグループACEを導出する必要があります。 EXCLUSIVE4 createmodeを使用したOPENの場合、そのようなOPEN呼び出しにはcreateattrsフィールドが含まれていないため、サーバーには選択肢がありません。逆に、createattrs（UNCHECKED4またはGUARDED4）またはcva_attrs（EXCLUSIVE4_1）が指定されており、RPC呼び出しの資格情報のプリンシパルにファイルを作成する権限がない所有者、owner_group、またはACEが含まれている場合、サーバーはNFS4ERR_PERMを返すことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of an OPEN that specifies a size of zero (e.g., truncation) and the file has named attributes, the named attributes are left as is and are not removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サイズがゼロ（切り捨てなど）を指定するOPENで、ファイルに名前付き属性がある場合、名前付き属性はそのまま残り、削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 gives more precise control to clients over acquisition of delegations via the following new flags for the share_access field of OPEN4args:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1では、OPEN4argsのshare_accessフィールドの次の新しいフラグを使用して、委任の取得をより正確にクライアントに制御できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_READ_DELEG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_READ_DELEG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_ANY_DELEG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_ANY_DELEG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_NO_DELEG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_NO_DELEG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_CANCEL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_CANCEL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If (share_access &amp; OPEN4_SHARE_ACCESS_WANT_DELEG_MASK) is not zero, then the client will have specified one and only one of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（share_access＆OPEN4_SHARE_ACCESS_WANT_DELEG_MASK）がゼロでない場合、クライアントは次のいずれか1つのみを指定しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_READ_DELEG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_READ_DELEG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG OPEN4_SHARE_ACCESS_WANT_ANY_DELEG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG OPEN4_SHARE_ACCESS_WANT_ANY_DELEG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_NO_DELEG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_NO_DELEG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_CANCEL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_CANCEL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise, the client is neither indicating a desire nor a non-desire for a delegation, and the server MAY or MAY not return a delegation in the OPEN response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それ以外の場合、クライアントは委任の希望も非希望も示しておらず、サーバーはOPEN応答で委任を返さない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server supports the new _WANT_ flags and the client sends one or more of the new flags, then in the event the server does not return a delegation, it MUST return a delegation type of OPEN_DELEGATE_NONE_EXT. The field ond_why in the reply indicates why no delegation was returned and will be one of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが新しい_WANT_フラグをサポートし、クライアントが1つ以上の新しいフラグを送信する場合、サーバーが委任を返さない場合、サーバーは委任型のOPEN_DELEGATE_NONE_EXTを返さなければなりません（MUST）。応答のフィールドond_whyは、委任が返されなかった理由を示し、次のいずれかになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_NOT_WANTED The client specified OPEN4_SHARE_ACCESS_WANT_NO_DELEG.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_NOT_WANTEDクライアントがOPEN4_SHARE_ACCESS_WANT_NO_DELEGを指定しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_CONTENTION There is a conflicting delegation or open on the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_CONTENTION There is a conflicting delegation or open on the file.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_RESOURCE Resource limitations prevent the server from granting a delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_RESOURCEリソースの制限により、サーバーは委任を許可できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_NOT_SUPP_FTYPE The server does not support delegations on this file type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_NOT_SUPP_FTYPEサーバーは、このファイルの種類の委任をサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_WRITE_DELEG_NOT_SUPP_FTYPE The server does not support OPEN_DELEGATE_WRITE delegations on this file type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_WRITE_DELEG_NOT_SUPP_FTYPEサーバーは、このファイルタイプのOPEN_DELEGATE_WRITE委任をサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_NOT_SUPP_UPGRADE The server does not support atomic upgrade of an OPEN_DELEGATE_READ delegation to an OPEN_DELEGATE_WRITE delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_NOT_SUPP_UPGRADEサーバーは、OPEN_DELEGATE_READ委任からOPEN_DELEGATE_WRITE委任へのアトミックアップグレードをサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_NOT_SUPP_DOWNGRADE The server does not support atomic downgrade of an OPEN_DELEGATE_WRITE delegation to an OPEN_DELEGATE_READ delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_NOT_SUPP_DOWNGRADEサーバーは、OPEN_DELEGATE_WRITE委任からOPEN_DELEGATE_READ委任へのアトミックダウングレードをサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_CANCELED The client specified OPEN4_SHARE_ACCESS_WANT_CANCEL and now any &#34;want&#34; for this file object is cancelled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_CANCELEDクライアントがOPEN4_SHARE_ACCESS_WANT_CANCELを指定したため、このファイルオブジェクトの「want」はすべてキャンセルされました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_IS_DIR The specified file object is a directory, and the operation is OPEN or WANT_DELEGATION, which do not support delegations on directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WND4_IS_DIR指定されたファイルオブジェクトはディレクトリであり、操作はOPENまたはWANT_DELEGATIONであり、ディレクトリでの委任はサポートされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_READ_DELEG, OPEN_SHARE_ACCESS_WANT_WRITE_DELEG, or OPEN_SHARE_ACCESS_WANT_ANY_DELEG mean, respectively, the client wants an OPEN_DELEGATE_READ, OPEN_DELEGATE_WRITE, or any delegation regardless which of OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH is set. If the client has an OPEN_DELEGATE_READ delegation on a file and requests an OPEN_DELEGATE_WRITE delegation, then the client is requesting atomic upgrade of its OPEN_DELEGATE_READ delegation to an OPEN_DELEGATE_WRITE delegation. If the client has an OPEN_DELEGATE_WRITE delegation on a file and requests an OPEN_DELEGATE_READ delegation, then the client is requesting atomic downgrade to an OPEN_DELEGATE_READ delegation. A server MAY support atomic upgrade or downgrade. If it does, then the returned delegation_type of OPEN_DELEGATE_READ or OPEN_DELEGATE_WRITE that is different from the delegation type the client currently has, indicates successful upgrade or downgrade. If the server does not support atomic delegation upgrade or downgrade, then ond_why will be set to WND4_NOT_SUPP_UPGRADE or WND4_NOT_SUPP_DOWNGRADE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_READ_DELEG、OPEN_SHARE_ACCESS_WANT_WRITE_DELEG、またはOPEN_SHARE_ACCESS_WANT_ANY_DELEGは、それぞれ、クライアントがOPEN_DELEGATE_READ、OPEN_DELEGATE_WRITE、またはOPEN4_SHARE_ACCESS__ OPEN_SHARE_ACCESS___OPEN_SH_ARE_ACCESS_SH_ARE_ACCESS__ OPEN_SHARE_ACCESS__ _ OPEN_SHARE_ACCESS__ _ OPEN_SHARE_ACCESS__ _ OPEN_SHARE_ACCESS__ _ OPEN_SHARE_ACCESS__ OPEN_SHARE_ACCESS__ _ OPEN_SHARE_ACCESS__ OPEN_SHARE_ACCESS__ OPEN_SHARE_ACCESS__ OPEN_SHARE_ACCESS__ OPEN_SHARE_ACCESS__ OPEN_SHARE_ACCESS_ACCESS__ OPEN_SHARE_ACCESS__ OPEN_SHARE_ACCESS_ACCESS__クライアントにファイルに対するOPEN_DELEGATE_READ委任があり、OPEN_DELEGATE_WRITE委任を要求する場合、クライアントはOPEN_DELEGATE_READ委任のOPEN_DELEGATE_WRITE委任へのアトミックアップグレードを要求しています。クライアントがファイルにOPEN_DELEGATE_WRITE委任を持ち、OPEN_DELEGATE_READ委任を要求する場合、クライアントはOPEN_DELEGATE_READ委任へのアトミックダウングレードを要求しています。サーバーは、アトミックアップグレードまたはダウングレードをサポートする場合があります。その場合、クライアントが現在持っている委任タイプとは異なるOPEN_DELEGATE_READまたはOPEN_DELEGATE_WRITEの返されたdelegation_typeは、アップグレードまたはダウングレードが成功したことを示します。サーバーがアトミック委任のアップグレードまたはダウングレードをサポートしていない場合、ond_whyはWND4_NOT_SUPP_UPGRADEまたはWND4_NOT_SUPP_DOWNGRADEに設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_NO_DELEG means that the client wants no delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_NO_DELEGは、クライアントが委任を望まないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_CANCEL means that the client wants no delegation and wants to cancel any previously registered &#34;want&#34; for a delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_SHARE_ACCESS_WANT_CANCELは、クライアントが委任を必要とせず、以前に登録された委任の「want」をキャンセルしたいことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client may set one or both of OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL and OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED. However, they will have no effect unless one of following is set:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAILとOPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDEDの一方または両方を設定できます。ただし、次のいずれかが設定されていない限り、効果はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_SHARE_ACCESS_WANT_READ_DELEG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_SHARE_ACCESS_WANT_READ_DELEG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_SHARE_ACCESS_WANT_ANY_DELEG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_SHARE_ACCESS_WANT_ANY_DELEG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If the client specifies OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL, then it wishes to register a &#34;want&#34; for a delegation, in the event the OPEN results do not include a delegation. If so and the server denies the delegation due to insufficient resources, the server MAY later inform the client, via the CB_RECALLABLE_OBJ_AVAIL operation, that the resource limitation condition has eased. The server will tell the client that it intends to send a future CB_RECALLABLE_OBJ_AVAIL operation by setting delegation_type in the results to OPEN_DELEGATE_NONE_EXT, ond_why to WND4_RESOURCE, and ond_server_will_signal_avail set to TRUE. If ond_server_will_signal_avail is set to TRUE, the server MUST later send a CB_RECALLABLE_OBJ_AVAIL operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントがOPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAILを指定している場合、OPENの結果に委任が含まれていない場合は、委任の「want」を登録する必要があります。そうであり、サーバーがリソース不足のために委任を拒否した場合、サーバーは後で、リソース制限条件が緩和されたことをCB_RECALLABLE_OBJ_AVAIL操作を介してクライアントに通知できます（MAY）。サーバーは、結果のdelegation_typeをOPEN_DELEGATE_NONE_EXTに設定し、ond_whyをWND4_RESOURCEに設定し、ond_server_will_signal_availをTRUEに設定することにより、将来のCB_RECALLABLE_OBJ_AVAIL操作を送信する予定であることをクライアントに通知します。 ond_server_will_signal_availがTRUEに設定されている場合、サーバーは後でCB_RECALLABLE_OBJ_AVAIL操作を送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client specifies OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_UNCONTENDED, then it wishes to register a &#34;want&#34; for a delegation, in the event the OPEN results do not include a delegation. If so and the server denies the delegation due to contention, the server MAY later inform the client, via the CB_PUSH_DELEG operation, that the contention condition has eased. The server will tell the client that it intends to send a future CB_PUSH_DELEG operation by setting delegation_type in the results to OPEN_DELEGATE_NONE_EXT, ond_why to WND4_CONTENTION, and ond_server_will_push_deleg to TRUE. If ond_server_will_push_deleg is TRUE, the server MUST later send a CB_PUSH_DELEG operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがOPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_UNCONTENDEDを指定している場合、OPENの結果に委任が含まれていない場合は、委任の「want」を登録する必要があります。そうであり、サーバーが競合のために委任を拒否した場合、サーバーは後でCB_PUSH_DELEG操作を介してクライアントに通知し、競合状態が緩和されたことを示します。サーバーは、結果のdelegation_typeをOPEN_DELEGATE_NONE_EXTに、ond_whyをWND4_CONTENTIONに、ond_server_will_push_delegをTRUEに設定することにより、将来のCB_PUSH_DELEG操作を送信する予定であることをクライアントに通知します。 ond_server_will_push_delegがTRUEの場合、サーバーは後でCB_PUSH_DELEG操作を送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client has previously registered a want for a delegation on a file, and then sends a request to register a want for a delegation on the same file, the server MUST return a new error: NFS4ERR_DELEG_ALREADY_WANTED. If the client wishes to register a different type of delegation want for the same file, it MUST cancel the existing delegation WANT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client has previously registered a want for a delegation on a file, and then sends a request to register a want for a delegation on the same file, the server MUST return a new error: NFS4ERR_DELEG_ALREADY_WANTED. If the client wishes to register a different type of delegation want for the same file, it MUST cancel the existing delegation WANT.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-16-4--IMPLEMENTATION">
18.16.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.16.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In absence of a persistent session, the client invokes exclusive create by setting the how parameter to EXCLUSIVE4 or EXCLUSIVE4_1. In these cases, the client provides a verifier that can reasonably be expected to be unique. A combination of a client identifier, perhaps the client network address, and a unique number generated by the client, perhaps the RPC transaction identifier, may be appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
永続的なセッションがない場合、クライアントはhowパラメーターをEXCLUSIVE4またはEXCLUSIVE4_1に設定することにより、排他的作成を呼び出します。これらの場合、クライアントは一意であると合理的に期待できるベリファイアを提供します。クライアント識別子（おそらくクライアントのネットワークアドレス）と、クライアントによって生成された一意の番号（おそらくRPCトランザクション識別子）の組み合わせが適切な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the object does not exist, the server creates the object and stores the verifier in stable storage. For file systems that do not provide a mechanism for the storage of arbitrary file attributes, the server may use one or more elements of the object&#39;s metadata to store the verifier. The verifier MUST be stored in stable storage to prevent erroneous failure on retransmission of the request. It is assumed that an exclusive create is being performed because exclusive semantics are critical to the application. Because of the expected usage, exclusive CREATE does not rely solely on the server&#39;s reply cache for storage of the verifier. A nonpersistent reply cache does not survive a crash and the session and reply cache may be deleted after a network partition that exceeds the lease time, thus opening failure windows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトが存在しない場合、サーバーはオブジェクトを作成し、ベリファイアを安定したストレージに保存します。任意のファイル属性を保存するメカニズムを提供しないファイルシステムの場合、サーバーはオブジェクトのメタデータの1つ以上の要素を使用してベリファイアを保存します。ベリファイアは、リクエストの再送信での誤った失敗を防ぐために、安定したストレージに保存する必要があります。排他的なセマンティクスがアプリケーションにとって重要であるため、排他的な作成が実行されていると想定されます。予想される使用法のため、排他的CREATEは、ベリファイアの格納のためにサーバーの応答キャッシュだけに依存するわけではありません。非永続的な応答キャッシュはクラッシュに耐えることができず、ネットワークパーティションがリース時間を超過すると、セッションと応答キャッシュが削除され、障害ウィンドウが開く場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An NFSv4.1 server SHOULD NOT store the verifier in any of the file&#39;s RECOMMENDED or REQUIRED attributes. If it does, the server SHOULD use time_modify_set or time_access_set to store the verifier. The server SHOULD NOT store the verifier in the following attributes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1サーバーは、ファイルのRECOMMENDEDまたはREQUIRED属性のいずれにもベリファイアを格納してはなりません（SHOULD NOT）。もしそうなら、サーバーはベリファイアを保存するためにtime_modify_setまたはtime_access_setを使用すべきです（SHOULD）。サーバーは次の属性にベリファイアを格納してはいけません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
acl (it is desirable for access control to be established at creation),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
acl（作成時にアクセス制御が確立されることが望ましい）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
dacl (ditto),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
タックル（同上）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
mode (ditto),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
モード（同上）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
owner (ditto),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
オーナー（同上）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
owner_group (ditto),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
owner_group（同上）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
retentevt_set (it may be desired to establish retention at creation)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
retentevt_set（作成時に保持を確立することが望ましい場合があります）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
retention_hold (ditto),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
保持（同上）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
retention_set (ditto),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
tention_set（同上）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
sacl (it is desirable for auditing control to be established at creation),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
sacl（監査制御が作成時に確立されることが望ましい）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
size (on some servers, size may have a limited range of values),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サイズ（一部のサーバーでは、サイズの値の範囲が限られている場合があります）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
mode_set_masked (as with mode),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
mode_set_masked（modeと同様）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
time_creation (a meaningful file creation should be set when the file is created).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
time_creation（ファイルの作成時に、意味のあるファイル作成を設定する必要があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another alternative for the server is to use a named attribute to store the verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのもう1つの代替方法は、名前付き属性を使用してベリファイアを格納することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the EXCLUSIVE4 create method does not specify initial attributes when processing an EXCLUSIVE4 create, the server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCLUSIVE4作成メソッドは、EXCLUSIVE4作成を処理するときに初期属性を指定しないため、サーバー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SHOULD set the owner of the file to that corresponding to the credential of request&#39;s RPC header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルの所有者を、要求のRPCヘッダーの資格に対応する所有者に設定する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SHOULD NOT leave the file&#39;s access control to anyone but the owner of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルのアクセス制御をファイルの所有者以外に任せないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server cannot support exclusive create semantics, possibly because of the requirement to commit the verifier to stable storage, it should fail the OPEN request with the error NFS4ERR_NOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベリファイアを安定したストレージにコミットする必要があるために、サーバーが排他的作成セマンティクスをサポートできない場合、OPENSリクエストはエラーNFS4ERR_NOTSUPPで失敗するはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During an exclusive CREATE request, if the object already exists, the server reconstructs the object&#39;s verifier and compares it with the verifier in the request. If they match, the server treats the request as a success. The request is presumed to be a duplicate of an earlier, successful request for which the reply was lost and that the server duplicate request cache mechanism did not detect. If the verifiers do not match, the request is rejected with the status NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
排他的CREATEリクエスト中に、オブジェクトがすでに存在する場合、サーバーはオブジェクトのベリファイアを再構築し、リクエスト内のベリファイアと比較します。それらが一致する場合、サーバーは要求を成功として扱います。要求は、応答が失われ、サーバーの複製要求キャッシュメカニズムが検出しなかった、以前の成功した要求の複製であると推定されます。ベリファイアが一致しない場合、リクエストはステータスNFS4ERR_EXISTで拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the client has performed a successful exclusive create, the attrset response indicates which attributes were used to store the verifier. If EXCLUSIVE4 was used, the attributes set in attrset were used for the verifier. If EXCLUSIVE4_1 was used, the client determines the attributes used for the verifier by comparing attrset with cva_attrs.attrmask; any bits set in the former but not the latter identify the attributes used to store the verifier. The client MUST immediately send a SETATTR to set attributes used to store the verifier. Until it does so, the attributes used to store the verifier cannot be relied upon. The subsequent SETATTR MUST NOT occur in the same COMPOUND request as the OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが排他的作成を正常に実行した後、attrset応答は、ベリファイアの格納に使用された属性を示します。 EXCLUSIVE4が使用された場合、attrsetで設定された属性がベリファイアに使用されました。 EXCLUSIVE4_1が使用された場合、クライアントはattrsetをcva_attrs.attrmaskと比較することにより、検証に使用される属性を決定します。前者で設定されたビットは後者を設定せず、ベリファイアを格納するために使用される属性を識別します。クライアントはすぐにSETATTRを送信して、ベリファイアの格納に使用される属性を設定する必要があります。そうするまで、ベリファイアの格納に使用される属性は信頼できません。後続のSETATTRは、OPENと同じCOMPOUND要求で発生してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless a persistent session is used, use of the GUARDED4 attribute does not provide exactly once semantics. In particular, if a reply is lost and the server does not detect the retransmission of the request, the operation can fail with NFS4ERR_EXIST, even though the create was performed successfully. The client would use this behavior in the case that the application has not requested an exclusive create but has asked to have the file truncated when the file is opened. In the case of the client timing out and retransmitting the create request, the client can use GUARDED4 to prevent against a sequence like create, write, create (retransmitted) from occurring.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
永続的なセッションが使用されない限り、GUARDED4属性を使用しても、正確に1回のセマンティクスは提供されません。特に、応答が失われ、サーバーが要求の再送信を検出しない場合、作成が正常に実行された場合でも、NFS4ERR_EXISTで操作が失敗する可能性があります。クライアントがこの動作を使用するのは、アプリケーションが排他的作成を要求していないが、ファイルを開くときにファイルを切り捨てるように要求した場合です。クライアントがタイムアウトして作成要求を再送信する場合、クライアントはGUARDED4を使用して、作成、書き込み、作成（再送信）などのシーケンスが発生しないようにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For SHARE reservations, the value of the expression (share_access &amp; ~OPEN4_SHARE_ACCESS_WANT_DELEG_MASK) MUST be one of OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH. If not, the server MUST return NFS4ERR_INVAL. The value of share_deny MUST be one of OPEN4_SHARE_DENY_NONE, OPEN4_SHARE_DENY_READ, OPEN4_SHARE_DENY_WRITE, or OPEN4_SHARE_DENY_BOTH. If not, the server MUST return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHARE予約の場合、式の値（share_access＆〜OPEN4_SHARE_ACCESS_WANT_DELEG_MASK）は、OPEN4_SHARE_ACCESS_READ、OPEN4_SHARE_ACCESS_WRITE、またはOPEN4_SHARE_ACCESS_BOTHのいずれかである必要があります。そうでない場合、サーバーはNFS4ERR_INVALを返さなければなりません（MUST）。 share_denyの値は、OPEN4_SHARE_DENY_NONE、OPEN4_SHARE_DENY_READ、OPEN4_SHARE_DENY_WRITE、またはOPEN4_SHARE_DENY_BOTHのいずれかである必要があります。そうでない場合、サーバーはNFS4ERR_INVALを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the share_access value (OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH), the client should check that the requester has the proper access rights to perform the specified operation. This would generally be the results of applying the ACL access rules to the file for the current requester. However, just as with the ACCESS operation, the client should not attempt to second-guess the server&#39;s decisions, as access rights may change and may be subject to server administrative controls outside the ACL framework. If the requester&#39;s READ or WRITE operation is not authorized (depending on the share_access value), the server MUST return NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
share_access値（OPEN4_SHARE_ACCESS_READ、OPEN4_SHARE_ACCESS_WRITE、またはOPEN4_SHARE_ACCESS_BOTH）に基づいて、クライアントは、リクエスターが指定された操作を実行するための適切なアクセス権を持っていることを確認する必要があります。これは通常、現在のリクエスターのファイルにACLアクセスルールを適用した結果です。ただし、ACCESS操作と同様に、アクセス権が変更されたり、ACLフレームワークの外部でサーバーの管理制御が行われたりする可能性があるため、クライアントはサーバーの決定を推測することを試みるべきではありません。リクエスターのREADまたはWRITE操作が許可されていない場合（share_access値に応じて）、サーバーはNFS4ERR_ACCESSを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if the client ID was not created with the EXCHGID4_FLAG_BIND_PRINC_STATEID capability set in the reply to EXCHANGE_ID, then the server MUST NOT impose any requirement that READs and WRITEs sent for an open file have the same credentials as the OPEN itself, and the server is REQUIRED to perform access checking on the READs and WRITEs themselves. Otherwise, if the reply to EXCHANGE_ID did have EXCHGID4_FLAG_BIND_PRINC_STATEID set, then with one exception, the credentials used in the OPEN request MUST match those used in the READs and WRITEs, and the stateids in the READs and WRITEs MUST match, or be derived from the stateid from the reply to OPEN. The exception is if SP4_SSV or SP4_MACH_CRED state protection is used, and the spo_must_allow result of EXCHANGE_ID includes the READ and/or WRITE operations. In that case, the machine or SSV credential will be allowed to send READ and/or WRITE. See Section 18.35.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCHANGE_IDへの応答で設定されたEXCHGID4_FLAG_BIND_PRINC_STATEID機能を使用してクライアントIDが作成されなかった場合、サーバーは、オープンファイルに対して送信されるREADおよびWRITEがOPEN自体と同じ資格情報を持っているという要件を課してはならないことに注意してください。読み取りと書き込み自体のアクセスチェックを実行する必要があります。それ以外の場合、EXCHANGE_IDへの応答にEXCHGID4_FLAG_BIND_PRINC_STATEIDが設定されている場合、1つの例外を除いて、OPEN要求で使用される資格情報は、READおよびWRITEで使用される資格情報と一致する必要があり、READsおよびWRITEの状態IDは一致するか、またはOPENへの応答からのstateid。例外は、SP4_SSVまたはSP4_MACH_CRED状態保護が使用されており、EXCHANGE_IDのspo_must_allow結果にREADまたはWRITE操作、あるいはその両方が含まれている場合です。その場合、マシンまたはSSVクレデンシャルはREADやWRITEを送信できます。セクション18.35を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the component provided to OPEN is a symbolic link, the error NFS4ERR_SYMLINK will be returned to the client, while if it is a directory the error NFS4ERR_ISDIR will be returned. If the component is neither of those but not an ordinary file, the error NFS4ERR_WRONG_TYPE is returned. If the current filehandle is not a directory, the error NFS4ERR_NOTDIR will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENに提供されたコンポーネントがシンボリックリンクの場合、エラーNFS4ERR_SYMLINKがクライアントに返され、ディレクトリの場合、エラーNFS4ERR_ISDIRが返されます。コンポーネントがこれらのいずれでもないが通常のファイルではない場合、エラーNFS4ERR_WRONG_TYPEが返されます。現在のファイルハンドルがディレクトリでない場合、エラーNFS4ERR_NOTDIRが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of the OPEN4_RESULT_PRESERVE_UNLINKED result flag allows a client to avoid the common implementation practice of renaming an open file to &#34;.nfs&lt;unique value&gt;&#34; after it removes the file. After the server returns OPEN4_RESULT_PRESERVE_UNLINKED, if a client sends a REMOVE operation that would reduce the file&#39;s link count to zero, the server SHOULD report a value of zero for the numlinks attribute on the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of the OPEN4_RESULT_PRESERVE_UNLINKED result flag allows a client to avoid the common implementation practice of renaming an open file to &#34;.nfs&lt;unique value&gt;&#34; after it removes the file. After the server returns OPEN4_RESULT_PRESERVE_UNLINKED, if a client sends a REMOVE operation that would reduce the file&#39;s link count to zero, the server SHOULD report a value of zero for the numlinks attribute on the file.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If another client has a delegation of the file being opened that conflicts with open being done (sometimes depending on the share_access or share_deny value specified), the delegation(s) MUST be recalled, and the operation cannot proceed until each such delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding. In the case of an OPEN_DELEGATE_WRITE delegation, any open by a different client will conflict, while for an OPEN_DELEGATE_READ delegation, only opens with one of the following characteristics will be considered conflicting:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
別のクライアントが、開かれているファイルと委任されているファイルの委任を持っている場合（指定されたshare_accessまたはshare_denyの値に応じて）、委任を再呼び出しする必要があり、そのような各委任が返されるまで操作を続行できません。取り消されました。これが非常に迅速に発生する場合を除いて、委任が未解決のままである間に、1つ以上のNFS4ERR_DELAYエラーが要求に返されます。 OPEN_DELEGATE_WRITE委任の場合、別のクライアントによるオープンは競合しますが、OPEN_DELEGATE_READ委任の場合、以下のいずれかの特性を持つオープンのみが競合すると見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value of share_access includes the bit OPEN4_SHARE_ACCESS_WRITE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o share_accessの値には、ビットOPEN4_SHARE_ACCESS_WRITEが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value of share_deny specifies OPEN4_SHARE_DENY_READ or OPEN4_SHARE_DENY_BOTH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o share_denyの値は、OPEN4_SHARE_DENY_READまたはOPEN4_SHARE_DENY_BOTHを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_CREATE is specified together with UNCHECKED4, the size attribute is specified as zero (for truncation), and an existing file is truncated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_CREATEがUNCHECKED4と共に指定され、サイズ属性がゼロに指定され（切り捨ての場合）、既存のファイルが切り捨てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If OPEN4_CREATE is specified and the file does not exist and the current filehandle designates a directory for which another client holds a directory delegation, then, unless the delegation is such that the situation can be resolved by sending a notification, the delegation MUST be recalled, and the operation cannot proceed until the delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_CREATEが指定されており、ファイルが存在せず、現在のファイルハンドルが別のクライアントがディレクトリ委任を保持しているディレクトリを指定している場合、通知を送信することで状況を解決できるような委譲でない限り、委任を再呼び出しする必要があります。委任が返却されるか取り消されるまで、操作は続行できません。これが非常に迅速に発生する場合を除いて、委任が未解決のままである間に、1つ以上のNFS4ERR_DELAYエラーが要求に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If OPEN4_CREATE is specified and the file does not exist and the current filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, NOTIFY4_ADD_ENTRY will be generated as a result of this operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_CREATEが指定され、ファイルが存在せず、現在のファイルハンドルが1つ以上のディレクトリ委任が存在するディレクトリを指定している場合、これらの委任がそのような通知を要求すると、この操作の結果としてNOTIFY4_ADD_ENTRYが生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-16-4-1--Warning-to-Client-Implementors">
18.16.4.1. Warning to Client Implementors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.16.4.1. クライアント実装者への警告
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN resembles LOOKUP in that it generates a filehandle for the client to use. Unlike LOOKUP though, OPEN creates server state on the filehandle. In normal circumstances, the client can only release this state with a CLOSE operation. CLOSE uses the current filehandle to determine which file to close. Therefore, the client MUST follow every OPEN operation with a GETFH operation in the same COMPOUND procedure. This will supply the client with the filehandle such that CLOSE can be used appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENは、クライアントが使用するファイルハンドルを生成する点でLOOKUPに似ています。ただし、LOOKUPとは異なり、OPENはファイルハンドルにサーバー状態を作成します。通常の状況では、クライアントはCLOSE操作でのみこの状態を解放できます。 CLOSEは、現在のファイルハンドルを使用して、閉じるファイルを決定します。したがって、クライアントはすべてのOPEN操作の後に、同じCOMPOUNDプロシージャのGETFH操作を実行する必要があります。これにより、クライアントにファイルハンドルが提供され、CLOSEを適切に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Simply waiting for the lease on the file to expire is insufficient because the server may maintain the state indefinitely as long as another client does not attempt to make a conflicting access to the same file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Simply waiting for the lease on the file to expire is insufficient because the server may maintain the state indefinitely as long as another client does not attempt to make a conflicting access to the same file.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See also Section 2.10.6.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション2.10.6.4も参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-17--Operation-19-OPENATTR---Open-Named-Attribute-Directory">
18.17. Operation 19: OPENATTR - Open Named Attribute Directory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.17. 操作19：OPENATTR-名前付き属性ディレクトリを開く
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-17-1--ARGUMENTS">
18.17.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.17.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPENATTR4args {
           /* CURRENT_FH: object */
           bool    createdir;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-17-2--RESULTS">
18.17.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.17.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPENATTR4res {
           /*
            * If status is NFS4_OK,
            *   new CURRENT_FH: named attribute
            *                   directory
            */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-17-3--DESCRIPTION">
18.17.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.17.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPENATTR operation is used to obtain the filehandle of the named attribute directory associated with the current filehandle. The result of the OPENATTR will be a filehandle to an object of type NF4ATTRDIR. From this filehandle, READDIR and LOOKUP operations can be used to obtain filehandles for the various named attributes associated with the original file system object. Filehandles returned within the named attribute directory will designate objects of type of NF4NAMEDATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENATTR操作は、現在のファイルハンドルに関連付けられている名前付き属性ディレクトリのファイルハンドルを取得するために使用されます。 OPENATTRの結果は、NF4ATTRDIRタイプのオブジェクトへのファイルハンドルになります。このファイルハンドルから、READDIRおよびLOOKUP操作を使用して、元のファイルシステムオブジェクトに関連付けられたさまざまな名前付き属性のファイルハンドルを取得できます。名前付き属性ディレクトリ内で返されるファイルハンドルは、NF4NAMEDATTRタイプのオブジェクトを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The createdir argument allows the client to signify if a named attribute directory should be created as a result of the OPENATTR operation. Some clients may use the OPENATTR operation with a value of FALSE for createdir to determine if any named attributes exist for the object. If none exist, then NFS4ERR_NOENT will be returned. If createdir has a value of TRUE and no named attribute directory exists, one is created and its filehandle becomes the current filehandle. On the other hand, if createdir has a value of TRUE and the named attribute directory already exists, no error results and the filehandle of the existing directory becomes the current filehandle. The creation of a named attribute directory assumes that the server has implemented named attribute support in this fashion and is not required to do so by this definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
createdir引数を使用すると、OPENATTR操作の結果として名前付き属性ディレクトリを作成する必要があるかどうかをクライアントが示すことができます。一部のクライアントは、createdirの値がFALSEのOPENATTR操作を使用して、オブジェクトに名前付き属性が存在するかどうかを判断します。存在しない場合は、NFS4ERR_NOENTが返されます。 createdirの値がTRUEであり、名前付き属性ディレクトリが存在しない場合は、1つが作成され、そのファイルハンドルが現在のファイルハンドルになります。一方、createdirの値がTRUEで、指定された属性ディレクトリがすでに存在する場合、エラーは発生せず、既存のディレクトリのファイルハンドルが現在のファイルハンドルになります。名前付き属性ディレクトリの作成は、サーバーがこの方法で名前付き属性のサポートを実装していることを前提としており、この定義ではそうする必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current file handle designates an object of type NF4NAMEDATTR (a named attribute) or NF4ATTRDIR (a named attribute directory), an error of NFS4ERR_WRONG_TYPE is returned to the client. Named attributes or a named attribute directory MUST NOT have their own named attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルがタイプNF4NAMEDATTR（名前付き属性）またはNF4ATTRDIR（名前付き属性ディレクトリ）のオブジェクトを指定している場合、NFS4ERR_WRONG_TYPEのエラーがクライアントに返されます。名前付き属性または名前付き属性ディレクトリには、独自の名前付き属性があってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-17-4--IMPLEMENTATION">
18.17.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.17.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server does not support named attributes for the current filehandle, an error of NFS4ERR_NOTSUPP will be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが現在のファイルハンドルの名前付き属性をサポートしていない場合、NFS4ERR_NOTSUPPのエラーがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-18--Operation-21-OPENDOWNGRADE---Reduce-Open-File-Access">
18.18. Operation 21: OPEN_DOWNGRADE - Reduce Open File Access
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.18. 操作21：OPEN_DOWNGRADE-オープンファイルアクセスを減らす
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-18-1--ARGUMENTS">
18.18.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.18.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN_DOWNGRADE4args {
           /* CURRENT_FH: opened file */
           stateid4        open_stateid;
           seqid4          seqid;
           uint32_t        share_access;
           uint32_t        share_deny;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-18-2--RESULTS">
18.18.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.18.2. RESULTS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN_DOWNGRADE4resok {
           stateid4        open_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OPEN_DOWNGRADE4res switch(nfsstat4 status) {
    case NFS4_OK:
           OPEN_DOWNGRADE4resok    resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-18-3--DESCRIPTION">
18.18.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.18.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used to adjust the access and deny states for a given open. This is necessary when a given open-owner opens the same file multiple times with different access and deny values. In this situation, a close of one of the opens may change the appropriate share_access and share_deny flags to remove bits associated with opens no longer in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、特定のオープンのアクセス状態と拒否状態を調整するために使用されます。これは、特定のオープンオーナーが異なるファイルで複数回同じファイルを開き、値を拒否する場合に必要です。この状況では、オープンの1つを閉じると、適切なshare_accessフラグとshare_denyフラグが変更され、オープンに関連しないビットが削除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Valid values for the expression (share_access &amp; ~OPEN4_SHARE_ACCESS_WANT_DELEG_MASK) are OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH. If the client specifies other values, the server MUST reply with NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
式（share_access＆〜OPEN4_SHARE_ACCESS_WANT_DELEG_MASK）の有効な値は、OPEN4_SHARE_ACCESS_READ、OPEN4_SHARE_ACCESS_WRITE、またはOPEN4_SHARE_ACCESS_BOTHです。クライアントが他の値を指定する場合、サーバーはNFS4ERR_INVALで応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Valid values for the share_deny field are OPEN4_SHARE_DENY_NONE, OPEN4_SHARE_DENY_READ, OPEN4_SHARE_DENY_WRITE, or OPEN4_SHARE_DENY_BOTH. If the client specifies other values, the server MUST reply with NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
share_denyフィールドの有効な値は、OPEN4_SHARE_DENY_NONE、OPEN4_SHARE_DENY_READ、OPEN4_SHARE_DENY_WRITE、またはOPEN4_SHARE_DENY_BOTHです。クライアントが他の値を指定する場合、サーバーはNFS4ERR_INVALで応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After checking for valid values of share_access and share_deny, the server replaces the current access and deny modes on the file with share_access and share_deny subject to the following constraints:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、share_accessとshare_denyの有効な値を確認した後、ファイルの現在のアクセスモードと拒否モードを次の制約に従って、share_accessとshare_denyに置き換えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The bits in share_access SHOULD equal the union of the share_access bits (not including OPEN4_SHARE_WANT_* bits) specified for some subset of the OPENs in effect for the current open-owner on the current file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o share_accessのビットは、現在のファイルの現在のオープン所有者に対して有効なOPENの一部のサブセットに指定されたshare_accessビット（OPEN4_SHARE_WANT_ *ビットを含まない）の和集合に等しい必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The bits in share_deny SHOULD equal the union of the share_deny bits specified for some subset of the OPENs in effect for the current open-owner on the current file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o share_denyのビットは、現在のファイルの現在のオープン所有者に対して有効なOPENのサブセットに指定されたshare_denyビットの和集合に等しい必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the above constraints are not respected, the server SHOULD return the error NFS4ERR_INVAL. Since share_access and share_deny bits should be subsets of those already granted, short of a defect in the client or server implementation, it is not possible for the OPEN_DOWNGRADE request to be denied because of conflicting share reservations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の制約が守られていない場合、サーバーはエラーNFS4ERR_INVALを返す必要があります（SHOULD）。 share_accessビットとshare_denyビットは、クライアントまたはサーバーの実装に欠陥がない限り、すでに付与されているもののサブセットである必要があるため、共有の予約が競合しているためにOPEN_DOWNGRADE要求が拒否されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The seqid argument is not used in NFSv4.1, MAY be any value, and MUST be ignored by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
seqid引数はNFSv4.1では使用されません。任意の値である場合があり、サーバーによって無視される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-18-4--IMPLEMENTATION">
18.18.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.18.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An OPEN_DOWNGRADE operation may make OPEN_DELEGATE_READ delegations grantable where they were not previously. Servers may choose to respond immediately if there are pending delegation want requests or may respond to the situation at a later time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN_DOWNGRADE操作を行うと、以前はなかったOPEN_DELEGATE_READ委任を付与できるようになります。サーバーは、保留中の委任要求がある場合はすぐに応答するか、後で状況に応答するかを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-19--Operation-22-PUTFH---Set-Current-Filehandle">
18.19. Operation 22: PUTFH - Set Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.19. 操作22：PUTFH-現在のファイルハンドルの設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-19-1--ARGUMENTS">
18.19.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.19.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct PUTFH4args {
           nfs_fh4         object;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-19-2--RESULTS">
18.19.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.19.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct PUTFH4res {
           /*
            * If status is NFS4_OK,
            *    new CURRENT_FH: argument to PUTFH
            */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-19-3--DESCRIPTION">
18.19.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.19.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation replaces the current filehandle with the filehandle provided as an argument. It clears the current stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、現在のファイルハンドルを引数として提供されたファイルハンドルに置き換えます。現在の状態IDをクリアします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the security mechanism used by the requester does not meet the requirements of the filehandle provided to this operation, the server MUST return NFS4ERR_WRONGSEC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスタが使用するセキュリティメカニズムがこの操作に提供されるファイルハンドルの要件を満たさない場合、サーバーはNFS4ERR_WRONGSECを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 16.2.3.1.1 for more details on the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルの詳細については、16.2.3.1.1項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 16.2.3.1.2 for more details on the current stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の状態IDの詳細については、セクション16.2.3.1.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-19-4--IMPLEMENTATION">
18.19.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.19.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used in an NFS request to set the context for file accessing operations that follow in the same COMPOUND request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、NFS要求で使用され、同じCOMPOUND要求に続くファイルアクセス操作のコンテキストを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-20--Operation-23-PUTPUBFH---Set-Public-Filehandle">
18.20. Operation 23: PUTPUBFH - Set Public Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.20. 操作23：PUTPUBFH-パブリックファイルハンドルの設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-20-1--ARGUMENT">
18.20.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.20.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-20-2--RESULT">
18.20.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.20.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct PUTPUBFH4res {
           /*
            * If status is NFS4_OK,
            *   new CURRENT_FH: public fh
            */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-20-3--DESCRIPTION">
18.20.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.20.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation replaces the current filehandle with the filehandle that represents the public filehandle of the server&#39;s namespace. This filehandle may be different from the &#34;root&#34; filehandle that may be associated with some other directory on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、現在のファイルハンドルをサーバーの名前空間のパブリックファイルハンドルを表すファイルハンドルに置き換えます。このファイルハンドルは、サーバー上の他のディレクトリに関連付けられている「ルート」ファイルハンドルとは異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTPUBFH also clears the current stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTPUBFHは、現在の状態IDもクリアします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The public filehandle represents the concepts embodied in RFC 2054 [42], RFC 2055 [43], and RFC 2224 [53]. The intent for NFSv4.1 is that the public filehandle (represented by the PUTPUBFH operation) be used as a method of providing WebNFS server compatibility with NFSv3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パブリックファイルハンドルは、RFC 2054 [42]、RFC 2055 [43]、およびRFC 2224 [53]で具体化された概念を表します。 NFSv4.1の目的は、NFSv3とのWebNFSサーバーの互換性を提供する方法として、パブリックファイルハンドル（PUTPUBFH操作で表される）を使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The public filehandle and the root filehandle (represented by the PUTROOTFH operation) SHOULD be equivalent. If the public and root filehandles are not equivalent, then the directory corresponding to the public filehandle MUST be a descendant of the directory corresponding to the root filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パブリックファイルハンドルとルートファイルハンドル（PUTROOTFHオペレーションで表される）は同等である必要があります。パブリックファイルハンドルとルートファイルハンドルが同等でない場合、パブリックファイルハンドルに対応するディレクトリは、ルートファイルハンドルに対応するディレクトリの子孫である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 16.2.3.1.1 for more details on the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 16.2.3.1.1 for more details on the current filehandle.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 16.2.3.1.2 for more details on the current stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の状態IDの詳細については、セクション16.2.3.1.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-20-4--IMPLEMENTATION">
18.20.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.20.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used in an NFS request to set the context for file accessing operations that follow in the same COMPOUND request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、NFS要求で使用され、同じCOMPOUND要求に続くファイルアクセス操作のコンテキストを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 With the NFSv3 public filehandle, the client is able to specify whether the pathname provided in the LOOKUP should be evaluated as either an absolute path relative to the server&#39;s root or relative to the public filehandle. RFC 2224 [53] contains further discussion of the functionality. With NFSv4.1, that type of specification is not directly available in the LOOKUP operation. The reason for this is because the component separators needed to specify absolute vs. relative are not allowed in NFSv4. Therefore, the client is responsible for constructing its request such that the use of either PUTROOTFH or PUTPUBFH signifies absolute or relative evaluation of an NFS URL, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFSv3パブリックファイルハンドルを使用すると、クライアントは、LOOKUPで提供されるパス名を、サーバーのルートからの絶対パスまたはパブリックファイルハンドルからの相対パスのどちらとして評価するかを指定できます。 RFC 2224 [53]には、機能の詳細な説明が含まれています。 NFSv4.1では、そのタイプの仕様はLOOKUP操作では直接利用できません。これは、絶対と相対の指定に必要なコンポーネントの区切り文字がNFSv4では許可されていないためです。したがって、クライアントは、PUTROOTFHまたはPUTPUBFHの使用がそれぞれNFS URLの絶対評価または相対評価を示すように、その要求を作成する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that there are warnings mentioned in RFC 2224 [53] with respect to the use of absolute evaluation and the restrictions the server may place on that evaluation with respect to how much of its namespace has been made available. These same warnings apply to NFSv4.1. It is likely, therefore, that because of server implementation details, an NFSv3 absolute public filehandle look up may behave differently than an NFSv4.1 absolute resolution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
絶対評価の使用に関してRFC 2224 [53]で言及されている警告と、サーバーがその名前空間の利用可能量に関してその評価に課す制限があることに注意してください。これらの同じ警告がNFSv4.1に適用されます。したがって、サーバーの実装の詳細により、NFSv3の絶対パブリックファイルハンドルのルックアップは、NFSv4.1の絶対解像度とは異なる動作をする可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is a form of security negotiation as described in RFC 2755 [54] that uses the public filehandle and an overloading of the pathname. This method is not available with NFSv4.1 as filehandles are not overloaded with special meaning and therefore do not provide the same framework as NFSv3. Clients should therefore use the security negotiation mechanisms described in Section 2.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 2755 [54]で説明されているように、パブリックファイルハンドルとパス名のオーバーロードを使用するセキュリティネゴシエーションの形式があります。ファイルハンドルは特別な意味でオーバーロードされず、NFSv3と同じフレームワークを提供しないため、このメソッドはNFSv4.1では使用できません。したがって、クライアントはセクション2.6で説明されているセキュリティネゴシエーションメカニズムを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-21--Operation-24-PUTROOTFH---Set-Root-Filehandle">
18.21. Operation 24: PUTROOTFH - Set Root Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.21. Operation 24: PUTROOTFH - Set Root Filehandle
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-21-1--ARGUMENTS">
18.21.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.21.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-21-2--RESULTS">
18.21.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.21.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct PUTROOTFH4res {
           /*
            * If status is NFS4_OK,
            *   new CURRENT_FH: root fh
            */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-21-3--DESCRIPTION">
18.21.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.21.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation replaces the current filehandle with the filehandle that represents the root of the server&#39;s namespace. From this filehandle, a LOOKUP operation can locate any other filehandle on the server. This filehandle may be different from the &#34;public&#34; filehandle that may be associated with some other directory on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、現在のファイルハンドルをサーバーの名前空間のルートを表すファイルハンドルに置き換えます。このファイルハンドルから、LOOKUP操作はサーバー上の他のファイルハンドルを見つけることができます。このファイルハンドルは、サーバー上の他のディレクトリに関連付けられている「パブリック」ファイルハンドルとは異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTROOTFH also clears the current stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTROOTFHは、現在の状態IDもクリアします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 16.2.3.1.1 for more details on the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルの詳細については、16.2.3.1.1項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 16.2.3.1.2 for more details on the current stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の状態IDの詳細については、セクション16.2.3.1.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-21-4--IMPLEMENTATION">
18.21.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.21.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used in an NFS request to set the context for file accessing operations that follow in the same COMPOUND request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、NFS要求で使用され、同じCOMPOUND要求に続くファイルアクセス操作のコンテキストを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-22--Operation-25-READ---Read-from-File">
18.22. Operation 25: READ - Read from File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.22. 操作25：読み取り-ファイルから読み取り
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-22-1--ARGUMENTS">
18.22.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.22.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READ4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           count4          count;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-22-2--RESULTS">
18.22.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.22.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READ4resok {
           bool            eof;
           opaque          data&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READ4res switch (nfsstat4 status) {
    case NFS4_OK:
            READ4resok     resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-22-3--DESCRIPTION">
18.22.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.22.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READ operation reads data from the regular file identified by the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ操作は、現在のファイルハンドルで識別される通常のファイルからデータを読み取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client provides an offset of where the READ is to start and a count of how many bytes are to be read. An offset of zero means to read data starting at the beginning of the file. If offset is greater than or equal to the size of the file, the status NFS4_OK is returned with a data length set to zero and eof is set to TRUE. The READ is subject to access permissions checking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、READの開始位置のオフセットと、読み取るバイト数のカウントを提供します。オフセット0は、ファイルの先頭からデータを読み取ることを意味します。オフセットがファイルのサイズ以上の場合、データ長がゼロに設定され、eofがTRUEに設定されたステータスNFS4_OKが返されます。 READは、アクセス許可チェックの対象です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client specifies a count value of zero, the READ succeeds and returns zero bytes of data again subject to access permissions checking. The server may choose to return fewer bytes than specified by the client. The client needs to check for this condition and handle the condition appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがゼロのカウント値を指定した場合、READは成功し、アクセス許可検査の対象となりますが、再び0バイトのデータを返します。サーバーは、クライアントが指定したよりも少ないバイト数を返すことを選択できます。クライアントはこの状態を確認し、状態を適切に処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Except when special stateids are used, the stateid value for a READ request represents a value returned from a previous byte-range lock or share reservation request or the stateid associated with a delegation. The stateid identifies the associated owners if any and is used by the server to verify that the associated locks are still valid (e.g., have not been revoked).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特別な状態IDが使用される場合を除いて、READ要求の状態ID値は、以前のバイト範囲ロックまたは共有予約要求から返された値、または委任に関連付けられた状態IDを表します。 stateidは、関連付けられた所有者が存在する場合にそれを識別し、関連付けられたロックがまだ有効であること（たとえば、取り消されていないこと）を確認するためにサーバーによって使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the read ended at the end-of-file (formally, in a correctly formed READ operation, if offset + count is equal to the size of the file), or the READ operation extends beyond the size of the file (if offset + count is greater than the size of the file), eof is returned as TRUE; otherwise, it is FALSE. A successful READ of an empty file will always return eof as TRUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
読み取りがファイルの終わりで終了した場合（正式には、正しく形成されたREAD操作で、offset + countがファイルのサイズと等しい場合）、またはREAD操作がファイルのサイズを超えている場合（offset + countがファイルのサイズより大きい場合）、eofはTRUEとして返されます。それ以外の場合はFALSEです。空のファイルの読み取りが成功すると、常にeofがTRUEとして返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is not an ordinary file, an error will be returned to the client. In the case that the current filehandle represents an object of type NF4DIR, NFS4ERR_ISDIR is returned. If the current filehandle designates a symbolic link, NFS4ERR_SYMLINK is returned. In all other cases, NFS4ERR_WRONG_TYPE is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが通常のファイルではない場合、クライアントにエラーが返されます。現在のファイルハンドルがNF4DIRタイプのオブジェクトを表す場合、NFS4ERR_ISDIRが返されます。現在のファイルハンドルがシンボリックリンクを指定している場合、NFS4ERR_SYMLINKが返されます。それ以外の場合はすべて、NFS4ERR_WRONG_TYPEが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a READ with a stateid value of all bits equal to zero, the server MAY allow the READ to be serviced subject to mandatory byte-range locks or the current share deny modes for the file. For a READ with a stateid value of all bits equal to one, the server MAY allow READ operations to bypass locking checks at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのビットのstateid値がゼロに等しいREADの場合、サーバーは、ファイルの必須のバイト範囲ロックまたは現在の共有拒否モードに従って、READのサービスを許可できます（MAY）。すべてのビットのstateid値が1のREADの場合、サーバーは、READ操作がサーバーでのロックチェックをバイパスすることを許可する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-22-4--IMPLEMENTATION">
18.22.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.22.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server returns a &#34;short read&#34; (i.e., fewer data than requested and eof is set to FALSE), the client should send another READ to get the remaining data. A server may return less data than requested under several circumstances. The file may have been truncated by another client or perhaps on the server itself, changing the file size from what the requesting client believes to be the case. This would reduce the actual amount of data available to the client. It is possible that the server reduce the transfer size and so return a short read result. Server resource exhaustion may also occur in a short read.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが「短い読み取り」を返す場合（つまり、要求されたよりも少ないデータであり、eofがFALSEに設定されている場合）、クライアントは残りのデータを取得するために別のREADを送信する必要があります。サーバーは、いくつかの状況下で要求されたよりも少ないデータを返す場合があります。ファイルが別のクライアントまたはサーバー自体で切り捨てられている可能性があり、要求元のクライアントがそうであると信じているファイルサイズを変更しています。これにより、クライアントが使用できる実際のデータ量が減少します。サーバーが転送サイズを減らし、短い読み取り結果を返す可能性があります。サーバーリソースの枯渇は、短い読み取りでも発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If mandatory byte-range locking is in effect for the file, and if the byte-range corresponding to the data to be read from the file is WRITE_LT locked by an owner not associated with the stateid, the server will return the NFS4ERR_LOCKED error. The client should try to get the appropriate READ_LT via the LOCK operation before re-attempting the READ. When the READ completes, the client should release the byte-range lock via LOCKU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須のバイト範囲ロックがファイルに対して有効であり、ファイルから読み取られるデータに対応するバイト範囲が、stateidに関連付けられていない所有者によってWRITE_LTロックされている場合、サーバーはNFS4ERR_LOCKEDエラーを返します。クライアントは、READを再試行する前に、LOCK操作を介して適切なREAD_LTを取得しようとする必要があります。 READが完了すると、クライアントはLOCKUを介してバイト範囲ロックを解放する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If another client has an OPEN_DELEGATE_WRITE delegation for the file being read, the delegation must be recalled, and the operation cannot proceed until that delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while the delegation remains outstanding. Normally, delegations will not be recalled as a result of a READ operation since the recall will occur as a result of an earlier OPEN. However, since it is possible for a READ to be done with a special stateid, the server needs to check for this case even though the client should have done an OPEN previously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別のクライアントが読み取り中のファイルに対してOPEN_DELEGATE_WRITE委任を持っている場合、委任を再呼び出しする必要があり、その委任が返されるか取り消されるまで操作を続行できません。これが非常に迅速に発生する場合を除いて、委任が未解決のままである間に、1つ以上のNFS4ERR_DELAYエラーが要求に返されます。以前のOPENの結果としてリコールが発生するため、通常、READ操作の結果として委任はリコールされません。ただし、READが特別な状態IDで実行される可能性があるため、クライアントが以前にOPENを実行していたとしても、サーバーはこのケースを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-23--Operation-26-READDIR---Read-Directory">
18.23. Operation 26: READDIR - Read Directory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.23. 操作26：READDIR-ディレクトリの読み取り
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-23-1--ARGUMENTS">
18.23.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.23.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READDIR4args {
           /* CURRENT_FH: directory */
           nfs_cookie4     cookie;
           verifier4       cookieverf;
           count4          dircount;
           count4          maxcount;
           bitmap4         attr_request;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-23-2--RESULTS">
18.23.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.23.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct entry4 {
           nfs_cookie4     cookie;
           component4      name;
           fattr4          attrs;
           entry4          *nextentry;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct dirlist4 {
           entry4          *entries;
           bool            eof;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READDIR4resok {
           verifier4       cookieverf;
           dirlist4        reply;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READDIR4res switch (nfsstat4 status) {
    case NFS4_OK:
            READDIR4resok  resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-23-3--DESCRIPTION">
18.23.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.23.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READDIR operation retrieves a variable number of entries from a file system directory and returns client-requested attributes for each entry along with information to allow the client to request additional directory entries in a subsequent READDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR操作は、ファイルシステムディレクトリから可変数のエントリを取得し、クライアントが後続のREADDIRで追加のディレクトリエントリを要求できるようにする情報とともに、各エントリのクライアント要求属性を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The arguments contain a cookie value that represents where the READDIR should start within the directory. A value of zero for the cookie is used to start reading at the beginning of the directory. For subsequent READDIR requests, the client specifies a cookie value that is provided by the server on a previous READDIR request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数には、READDIRがディレクトリ内のどこから始まるかを表すcookie値が含まれています。 Cookieのゼロの値は、ディレクトリの先頭から読み取りを開始するために使用されます。後続のREADDIR要求の場合、クライアントは、前のREADDIR要求でサーバーによって提供されたCookie値を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The request&#39;s cookieverf field should be set to 0 zero) when the request&#39;s cookie field is zero (first read of the directory). On subsequent requests, the cookieverf field must match the cookieverf returned by the READDIR in which the cookie was acquired. If the server determines that the cookieverf is no longer valid for the directory, the error NFS4ERR_NOT_SAME must be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストのcookieverfフィールドは0に設定する必要があります）リクエストのcookieフィールドがゼロの場合（ディレクトリの最初の読み取り）。後続の要求では、cookieverfフィールドは、Cookieが取得されたREADDIRによって返されたcookieverfと一致する必要があります。サーバーがcookieverfがディレクトリに対して無効であると判断した場合、エラーNFS4ERR_NOT_SAMEを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The dircount field of the request is a hint of the maximum number of bytes of directory information that should be returned. This value represents the total length of the names of the directory entries and the cookie value for these entries. This length represents the XDR encoding of the data (names and cookies) and not the length in the native format of the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストのdircountフィールドは、返されるディレクトリ情報の最大バイト数のヒントです。この値は、ディレクトリエントリの名前とこれらのエントリのCookie値の合計の長さを表します。この長さは、データ（名前とCookie）のXDRエンコードを表し、サーバーのネイティブ形式の長さではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The maxcount field of the request represents the maximum total size of all of the data being returned within the READDIR4resok structure and includes the XDR overhead. The server MAY return less data. If the server is unable to return a single directory entry within the maxcount limit, the error NFS4ERR_TOOSMALL MUST be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストのmaxcountフィールドは、READDIR4resok構造内で返されるすべてのデータの最大合計サイズを表し、XDRオーバーヘッドが含まれます。サーバーはより少ないデータを返すかもしれません。サーバーがmaxcount制限内の単一のディレクトリエントリを返すことができない場合、エラーNFS4ERR_TOOSMALLをクライアントに返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, the request&#39;s attr_request field represents the list of attributes to be returned for each directory entry supplied by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、リクエストのattr_requestフィールドは、サーバーから提供された各ディレクトリエントリに対して返される属性のリストを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A successful reply consists of a list of directory entries. Each of these entries contains the name of the directory entry, a cookie value for that entry, and the associated attributes as requested. The &#34;eof&#34; flag has a value of TRUE if there are no more entries in the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功した応答は、ディレクトリエントリのリストで構成されます。これらの各エントリには、ディレクトリエントリの名前、そのエントリのCookie値、および要求された関連属性が含まれています。 「eof」フラグの値は、ディレクトリにエントリがなくなるとTRUEになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cookie value is only meaningful to the server and is used as a cursor for the directory entry. As mentioned, this cookie is used by the client for subsequent READDIR operations so that it may continue reading a directory. The cookie is similar in concept to a READ offset but MUST NOT be interpreted as such by the client. Ideally, the cookie value SHOULD NOT change if the directory is modified since the client may be caching these values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookie値はサーバーにとってのみ意味があり、ディレクトリエントリのカーソルとして使用されます。前述のように、このCookieは、後続のREADDIR操作でクライアントによって使用されるため、ディレクトリの読み取りを続行できます。 Cookieは、概念的にはREADオフセットに似ていますが、クライアントによってそのように解釈されてはなりません。理想的には、クライアントがこれらの値をキャッシュしている可能性があるため、ディレクトリが変更された場合でも、Cookieの値は変更しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some cases, the server may encounter an error while obtaining the attributes for a directory entry. Instead of returning an error for the entire READDIR operation, the server can instead return the attribute rdattr_error (Section 5.8.1.12). With this, the server is able to communicate the failure to the client and not fail the entire operation in the instance of what might be a transient failure. Obviously, the client must request the fattr4_rdattr_error attribute for this method to work properly. If the client does not request the attribute, the server has no choice but to return failure for the entire READDIR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some cases, the server may encounter an error while obtaining the attributes for a directory entry. Instead of returning an error for the entire READDIR operation, the server can instead return the attribute rdattr_error (Section 5.8.1.12). With this, the server is able to communicate the failure to the client and not fail the entire operation in the instance of what might be a transient failure. Obviously, the client must request the fattr4_rdattr_error attribute for this method to work properly. If the client does not request the attribute, the server has no choice but to return failure for the entire READDIR operation.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For some file system environments, the directory entries &#34;.&#34; and &#34;..&#34; have special meaning, and in other environments, they do not. If the server supports these special entries within a directory, they SHOULD NOT be returned to the client as part of the READDIR response. To enable some client environments, the cookie values of zero, 1, and 2 are to be considered reserved. Note that the UNIX client will use these values when combining the server&#39;s response and local representations to enable a fully formed UNIX directory presentation to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のファイルシステム環境では、ディレクトリエントリ「。」と「..」には特別な意味があり、他の環境ではそうではありません。サーバーがディレクトリ内のこれらの特別なエントリをサポートする場合、それらはREADDIR応答の一部としてクライアントに返されるべきではありません（SHOULD NOT）。一部のクライアント環境を有効にするために、ゼロ、1、および2のCookie値は予約済みと見なされます。 UNIXクライアントは、サーバーの応答とローカル表現を組み合わせるときにこれらの値を使用して、アプリケーションへの完全に形成されたUNIXディレクトリプレゼンテーションを有効にすることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For READDIR arguments, cookie values of one and two SHOULD NOT be used, and for READDIR results, cookie values of zero, one, and two SHOULD NOT be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR引数の場合、1と2のCookie値は使用すべきではなく（SHOULD NOT）、READDIR結果の場合、0、1、および2のCookie値は返されるべきです（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-23-4--IMPLEMENTATION">
18.23.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.23.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server&#39;s file system directory representations can differ greatly. A client&#39;s programming interfaces may also be bound to the local operating environment in a way that does not translate well into the NFS protocol. Therefore, the use of the dircount and maxcount fields are provided to enable the client to provide hints to the server. If the client is aggressive about attribute collection during a READDIR, the server has an idea of how to limit the encoded response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのファイルシステムのディレクトリ表現は、大きく異なる場合があります。クライアントのプログラミングインターフェイスは、NFSプロトコルにうまく変換できない方法でローカルのオペレーティング環境にバインドされる場合もあります。したがって、クライアントがサーバーにヒントを提供できるようにするために、dircountおよびmaxcountフィールドの使用が提供されています。クライアントがREADDIR中の属性収集に積極的である場合、サーバーは、エンコードされた応答を制限する方法を知っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If dircount is zero, the server bounds the reply&#39;s size based on the request&#39;s maxcount field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If dircount is zero, the server bounds the reply&#39;s size based on the request&#39;s maxcount field.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cookieverf may be used by the server to help manage cookie values that may become stale. It should be a rare occurrence that a server is unable to continue properly reading a directory with the provided cookie/cookieverf pair. The server SHOULD make every effort to avoid this condition since the application at the client might be unable to properly handle this type of failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはcookieverfを使用して、古くなる可能性のあるCookie値の管理を支援します。サーバーが提供されたcookie / cookieverfペアでディレクトリを適切に読み続けることができないのはまれなことです。クライアントのアプリケーションはこのタイプの障害を適切に処理できない可能性があるため、サーバーはこの状態を回避するためにあらゆる努力をする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of the cookieverf will also protect the client from using READDIR cookie values that might be stale. For example, if the file system has been migrated, the server might or might not be able to use the same cookie values to service READDIR as the previous server used. With the client providing the cookieverf, the server is able to provide the appropriate response to the client. This prevents the case where the server accepts a cookie value but the underlying directory has changed and the response is invalid from the client&#39;s context of its previous READDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieverfを使用すると、古くなっている可能性のあるREADDIR Cookie値を使用してクライアントを保護することもできます。たとえば、ファイルシステムが移行されている場合、サーバーは、以前のサーバーが使用していたのと同じCookie値を使用してREADDIRを処理できる場合とできない場合があります。クライアントがcookieverfを提供すると、サーバーはクライアントに適切な応答を提供できます。これにより、サーバーがcookie値を受け入れたが、基になるディレクトリが変更され、クライアントの以前のREADDIRのコンテキストからの応答が無効になるという事態が防止されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since some servers will not be returning &#34;.&#34; and &#34;..&#34; entries as has been done with previous versions of the NFS protocol, the client that requires these entries be present in READDIR responses must fabricate them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のサーバーは &#34;。&#34;を返さないため。以前のバージョンのNFSプロトコルで行われていた「..」エントリと同様に、これらのエントリがREADDIR応答に存在する必要があるクライアントは、それらを作成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-24--Operation-27-READLINK---Read-Symbolic-Link">
18.24. Operation 27: READLINK - Read Symbolic Link
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.24. 操作27：READLINK-シンボリックリンクの読み取り
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-24-1--ARGUMENTS">
18.24.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.24.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* CURRENT_FH: symlink */
   void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-24-2--RESULTS">
18.24.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.24.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READLINK4resok {
           linktext4       link;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READLINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            READLINK4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-24-3--DESCRIPTION">
18.24.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.24.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READLINK reads the data associated with a symbolic link. Depending on the value of the UTF-8 capability attribute (Section 14.4), the data is encoded in UTF-8. Whether created by an NFS client or created locally on the server, the data in a symbolic link is not interpreted (except possibly to check for proper UTF-8 encoding) when created, but is simply stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READLINK reads the data associated with a symbolic link. Depending on the value of the UTF-8 capability attribute (Section 14.4), the data is encoded in UTF-8. Whether created by an NFS client or created locally on the server, the data in a symbolic link is not interpreted (except possibly to check for proper UTF-8 encoding) when created, but is simply stored.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-24-4--IMPLEMENTATION">
18.24.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.24.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A symbolic link is nominally a pointer to another file. The data is not necessarily interpreted by the server, just stored in the file. It is possible for a client implementation to store a pathname that is not meaningful to the server operating system in a symbolic link. A READLINK operation returns the data to the client for interpretation. If different implementations want to share access to symbolic links, then they must agree on the interpretation of the data in the symbolic link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シンボリックリンクは、名目上は別のファイルへのポインタです。データは必ずしもサーバーによって解釈されるのではなく、ファイルに格納されるだけです。クライアントの実装が、サーバーのオペレーティングシステムにとって意味のないパス名をシンボリックリンクに格納する可能性があります。 READLINK操作は、解釈のためにデータをクライアントに返します。異なる実装がシンボリックリンクへのアクセスを共有する場合は、シンボリックリンクのデータの解釈に同意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READLINK operation is only allowed on objects of type NF4LNK. The server should return the error NFS4ERR_WRONG_TYPE if the object is not of type NF4LNK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READLINK操作は、NF4LNKタイプのオブジェクトでのみ許可されます。オブジェクトがNF4LNKタイプでない場合、サーバーはエラーNFS4ERR_WRONG_TYPEを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-25--Operation-28-REMOVE---Remove-File-System-Object">
18.25. Operation 28: REMOVE - Remove File System Object
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.25. 操作28：REMOVE-ファイルシステムオブジェクトの削除
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-25-1--ARGUMENTS">
18.25.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.25.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct REMOVE4args {
           /* CURRENT_FH: directory */
           component4      target;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-25-2--RESULTS">
18.25.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.25.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct REMOVE4resok {
           change_info4    cinfo;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union REMOVE4res switch (nfsstat4 status) {
    case NFS4_OK:
            REMOVE4resok   resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-25-3--DESCRIPTION">
18.25.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.25.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The REMOVE operation removes (deletes) a directory entry named by filename from the directory corresponding to the current filehandle. If the entry in the directory was the last reference to the corresponding file system object, the object may be destroyed. The directory may be either of type NF4DIR or NF4ATTRDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REMOVE操作は、filenameで指定されたディレクトリエントリを現在のファイルハンドルに対応するディレクトリから削除（削除）します。ディレクトリ内のエントリが対応するファイルシステムオブジェクトへの最後の参照であった場合、オブジェクトは破棄される可能性があります。ディレクトリは、NF4DIRまたはNF4ATTRDIRタイプのいずれかです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the directory where the filename was removed, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 data type, the server will indicate if the before and after change attributes were obtained atomically with respect to the removal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイル名が削除されたディレクトリの場合、サーバーはcinfoにchange_info4情報を返します。 change_info4データ型のアトミックフィールドを使用すると、サーバーは、削除に関して変更前および変更後の属性がアトミックに取得されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the target has a length of zero, or if the target does not obey the UTF-8 definition (and the server is enforcing UTF-8 encoding; see Section 14.4), the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットの長さがゼロの場合、またはターゲットがUTF-8定義に従っていない場合（およびサーバーがUTF-8エンコーディングを強制している場合は、セクション14.4を参照）、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-25-4--IMPLEMENTATION">
18.25.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.25.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv3 required a different operator RMDIR for directory removal and REMOVE for non-directory removal. This allowed clients to skip checking the file type when being passed a non-directory delete system call (e.g., unlink() [27] in POSIX) to remove a directory, as well as the converse (e.g., a rmdir() on a non-directory) because they knew the server would check the file type. NFSv4.1 REMOVE can be used to delete any directory entry independent of its file type. The implementor of an NFSv4.1 client&#39;s entry points from the unlink() and rmdir() system calls should first check the file type against the types the system call is allowed to remove before sending a REMOVE operation. Alternatively, the implementor can produce a COMPOUND call that includes a LOOKUP/VERIFY sequence of operations to verify the file type before a REMOVE operation in the same COMPOUND call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv3では、ディレクトリの削除には別の演算子RMDIRが必要であり、ディレクトリ以外の削除にはREMOVEが必要でした。これにより、クライアントは、ディレクトリを削除するための非ディレクトリ削除システムコール（たとえば、POSIXのunlink()[27]）が渡されたときにファイルタイプのチェックをスキップし、逆に（たとえば、非ディレクトリ）は、サーバーがファイルタイプをチェックすることを知っていたためです。 NFSv4.1 REMOVEを使用すると、ファイルタイプに関係なく、任意のディレクトリエントリを削除できます。 unlink()およびrmdir()システムコールからのNFSv4.1クライアントのエントリポイントの実装者は、REMOVE操作を送信する前に、システムコールが削除できるタイプに対してファイルタイプを最初にチェックする必要があります。あるいは、実装者は、LOOKUP / VERIFYシーケンスの操作を含むCOMPOUND呼び出しを生成して、同じCOMPOUND呼び出しでREMOVE操作の前にファイルタイプを確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The concept of last reference is server specific. However, if the numlinks field in the previous attributes of the object had the value 1, the client should not rely on referring to the object via a filehandle. Likewise, the client should not rely on the resources (disk space, directory entry, and so on) formerly associated with the object becoming immediately available. Thus, if a client needs to be able to continue to access a file after using REMOVE to remove it, the client should take steps to make sure that the file will still be accessible. While the traditional mechanism used is to RENAME the file from its old name to a new hidden name, the NFSv4.1 OPEN operation MAY return a result flag, OPEN4_RESULT_PRESERVE_UNLINKED, which indicates to the client that the file will be preserved if the file has an outstanding open (see Section 18.16).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
最後の参照の概念はサーバー固有です。ただし、オブジェクトの以前の属性のnumlinksフィールドの値が1の場合、クライアントはファイルハンドルを介してオブジェクトを参照することに依存すべきではありません。同様に、クライアントは、以前オブジェクトに関連付けられていたリソース（ディスク領域、ディレクトリエントリなど）がすぐに利用可能になることに依存してはなりません。したがって、クライアントがREMOVEを使用してファイルを削除した後も引き続きファイルにアクセスできるようにする必要がある場合、クライアントは、ファイルが引き続きアクセス可能であることを確認する手順を実行する必要があります。使用される従来のメカニズムは、ファイルを古い名前から新しい非表示の名前に名前変更することですが、NFSv4.1 OPEN操作は結果フラグOPEN4_RESULT_PRESERVE_UNLINKEDを返す場合があります。これは、ファイルにファイルがある場合にファイルが保持されることをクライアントに示します未処理のオープン（セクション18.16を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server finds that the file is still open when the REMOVE arrives:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REMOVEが到着したときにサーバーがファイルがまだ開いていることを検出した場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server SHOULD NOT delete the file&#39;s directory entry if the file was opened with OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server SHOULD NOT delete the file&#39;s directory entry if the file was opened with OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the file was not opened with OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH, the server SHOULD delete the file&#39;s directory entry. However, until last CLOSE of the file, the server MAY continue to allow access to the file via its filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ファイルがOPEN4_SHARE_DENY_WRITEまたはOPEN4_SHARE_DENY_BOTHで開かれなかった場合、サーバーはファイルのディレクトリエントリを削除する必要があります（SHOULD）。ただし、ファイルの最後のCLOSEまで、サーバーはそのファイルハンドルを介してファイルへのアクセスを許可し続ける場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server MUST NOT delete the directory entry if the reply from OPEN had the flag OPEN4_RESULT_PRESERVE_UNLINKED set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPENからの応答にフラグOPEN4_RESULT_PRESERVE_UNLINKEDが設定されている場合、サーバーはディレクトリエントリを削除してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MAY implement its own restrictions on removal of a file while it is open. The server might disallow such a REMOVE (or a removal that occurs as part of RENAME). The conditions that influence the restrictions on removal of a file while it is still open include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、開いているファイルの削除に関する独自の制限を実装できます。サーバーは、そのようなREMOVE（またはRENAMEの一部として発生する削除）を許可しない場合があります。開いたままのファイルの削除に関する制限に影響を与える条件は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Whether certain access protocols (i.e., not just NFS) are holding the file open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 特定のアクセスプロトコル（NFSだけでなく）がファイルを開いたままにしているかどうか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Whether particular options, access modes, or policies on the server are enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバー上の特定のオプション、アクセスモード、またはポリシーが有効になっているかどうか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a file has an outstanding OPEN and this prevents the removal of the file&#39;s directory entry, the error NFS4ERR_FILE_OPEN is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルに未処理のOPENがあり、これによりファイルのディレクトリエントリが削除されない場合、エラーNFS4ERR_FILE_OPENが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Where the determination above cannot be made definitively because delegations are being held, they MUST be recalled to allow processing of the REMOVE to continue. When a delegation is held, the server has no reliable knowledge of the status of OPENs for that client, so unless there are files opened with the particular deny modes by clients without delegations, the determination cannot be made until delegations are recalled, and the operation cannot proceed until each sufficient delegation has been returned or revoked to allow the server to make a correct determination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
委任が開催されているために上記の決定を明確に行うことができない場合、REMOVEの処理を続行できるように、それらをリコールする必要があります。委任が保持されている場合、サーバーはそのクライアントのOPENの状態について信頼できる知識を持たないため、委任のないクライアントによって特定の拒否モードで開かれたファイルがない限り、委任が呼び出されて操作が実行されるまで、決定を行うことはできません。十分な委任が返されるか、サーバーが正しい決定を行うことができるように取り消されるまで続行できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In all cases in which delegations are recalled, the server is likely to return one or more NFS4ERR_DELAY errors while delegations remain outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任が呼び戻されるすべての場合において、サーバーは、委任が未解決のままである間、1つ以上のNFS4ERR_DELAYエラーを返す可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle designates a directory for which another client holds a directory delegation, then, unless the situation can be resolved by sending a notification, the directory delegation MUST be recalled, and the operation MUST NOT proceed until the delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが、別のクライアントがディレクトリ委任を保持しているディレクトリを指定している場合、通知を送信して状況を解決できない限り、ディレクトリ委任を再呼び出しする必要があり、委任が返されるか取り消されるまで操作を続行してはなりません。これが非常に迅速に発生する場合を除いて、委任が未解決のままである間に、1つ以上のNFS4ERR_DELAYエラーが要求に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the current filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, NOTIFY4_REMOVE_ENTRY will be generated as a result of this operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが1つ以上のディレクトリ委任が存在するディレクトリを指定している場合、それらの委任がそのような通知を要求すると、この操作の結果としてNOTIFY4_REMOVE_ENTRYが生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that when a remove occurs as a result of a RENAME, NOTIFY4_REMOVE_ENTRY will only be generated if the removal happens as a separate operation. In the case in which the removal is integrated and atomic with RENAME, the notification of the removal is integrated with notification for the RENAME. See the discussion of the NOTIFY4_RENAME_ENTRY notification in Section 20.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENAMEの結果として削除が発生した場合、NOTIFY4_REMOVE_ENTRYは、削除が別の操作として発生した場合にのみ生成されることに注意してください。削除がRENAMEと統合され、アトミックである場合、削除の通知はRENAMEの通知と統合されます。セクション20.4のNOTIFY4_RENAME_ENTRY通知の説明を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-26--Operation-29-RENAME---Rename-Directory-Entry">
18.26. Operation 29: RENAME - Rename Directory Entry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.26. 操作29：RENAME-ディレクトリエントリの名前変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-26-1--ARGUMENTS">
18.26.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.26.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RENAME4args {
           /* SAVED_FH: source directory */
           component4      oldname;
           /* CURRENT_FH: target directory */
           component4      newname;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-26-2--RESULTS">
18.26.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.26.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RENAME4resok {
           change_info4    source_cinfo;
           change_info4    target_cinfo;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union RENAME4res switch (nfsstat4 status) {
    case NFS4_OK:
           RENAME4resok    resok4;
    default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-26-3--DESCRIPTION">
18.26.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.26.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RENAME operation renames the object identified by oldname in the source directory corresponding to the saved filehandle, as set by the SAVEFH operation, to newname in the target directory corresponding to the current filehandle. The operation is required to be atomic to the client. Source and target directories MUST reside on the same file system on the server. On success, the current filehandle will continue to be the target directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENAMEオペレーションは、SAVEFHオペレーションで設定された、保存されたファイルハンドルに対応するソースディレクトリのoldnameで識別されるオブジェクトの名前を、現在のファイルハンドルに対応するターゲットディレクトリのnewnameに変更します。操作はクライアントに対してアトミックである必要があります。ソースディレクトリとターゲットディレクトリは、サーバー上の同じファイルシステムに存在する必要があります。成功した場合、現在のファイルハンドルは引き続きターゲットディレクトリになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the target directory already contains an entry with the name newname, the source object MUST be compatible with the target: either both are non-directories or both are directories and the target MUST be empty. If compatible, the existing target is removed before the rename occurs or, preferably, the target is removed atomically as part of the rename. See Section 18.25.4 for client and server actions whenever a target is removed. Note however that when the removal is performed atomically with the rename, certain parts of the removal described there are integrated with the rename. For example, notification of the removal will not be via a NOTIFY4_REMOVE_ENTRY but will be indicated as part of the NOTIFY4_ADD_ENTRY or NOTIFY4_RENAME_ENTRY generated by the rename.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットディレクトリにnewnameという名前のエントリが既に含まれている場合、ソースオブジェクトはターゲットと互換性がある必要があります。両方ともディレクトリではないか、両方ともディレクトリであり、ターゲットは空でなければなりません。互換性がある場合、名前の変更が行われる前に既存のターゲットが削除されるか、名前の変更の一部としてターゲットがアトミックに削除されます。ターゲットが削除された場合のクライアントとサーバーのアクションについては、セクション18.25.4を参照してください。ただし、名前変更を使用して削除がアトミックに実行されると、そこに記載されている削除の特定の部分が名前変更と統合されます。たとえば、削除の通知はNOTIFY4_REMOVE_ENTRY経由ではなく、名前変更によって生成されたNOTIFY4_ADD_ENTRYまたはNOTIFY4_RENAME_ENTRYの一部として示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the source object and the target are not compatible or if the target is a directory but not empty, the server will return the error NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースオブジェクトとターゲットに互換性がない場合、またはターゲットがディレクトリであるが空ではない場合、サーバーはエラーNFS4ERR_EXISTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If oldname and newname both refer to the same file (e.g., they might be hard links of each other), then unless the file is open (see Section 18.26.4), RENAME MUST perform no action and return NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldnameとnewnameの両方が同じファイルを参照している場合（たとえば、相互にハードリンクである可能性があります）、ファイルが開いていない限り（セクション18.26.4を参照）、RENAMEは何も実行せず、NFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For both directories involved in the RENAME, the server returns change_info4 information. With the atomic field of the change_info4 data type, the server will indicate if the before and after change attributes were obtained atomically with respect to the rename.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENAMEに関係する両方のディレクトリについて、サーバーはchange_info4情報を返します。 change_info4データ型のアトミックフィールドを使用すると、サーバーは、名前変更に関して変更前と変更後の属性がアトミックに取得されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If oldname refers to a named attribute and the saved and current filehandles refer to different file system objects, the server will return NFS4ERR_XDEV just as if the saved and current filehandles represented directories on different file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldnameが名前付き属性を参照し、保存済みファイルハンドルと現在のファイルハンドルが異なるファイルシステムオブジェクトを参照する場合、サーバーは、保存済みファイルハンドルと現在のファイルハンドルが異なるファイルシステム上のディレクトリを表す場合と同様に、NFS4ERR_XDEVを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If oldname or newname has a length of zero, or if oldname or newname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldnameまたはnewnameの長さがゼロの場合、またはoldnameまたはnewnameがUTF-8定義に従っていない場合、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-26-4--IMPLEMENTATION">
18.26.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.26.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MAY impose restrictions on the RENAME operation such that RENAME may not be done when the file being renamed is open or when that open is done by particular protocols, or with particular options or access modes. Similar restrictions may be applied when a file exists with the target name and is open. When RENAME is rejected because of such restrictions, the error NFS4ERR_FILE_OPEN is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはRENAME操作に制限を課してもよいため、名前を変更するファイルが開いているとき、またはそのオープンが特定のプロトコルによって、または特定のオプションやアクセスモードで行われているときは、RENAMEを実行できません。ターゲット名を持つファイルが存在し、開かれている場合も、同様の制限が適用される場合があります。このような制限のためにRENAMEが拒否されると、エラーNFS4ERR_FILE_OPENが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When oldname and rename refer to the same file and that file is open in a fashion such that RENAME would normally be rejected with NFS4ERR_FILE_OPEN if oldname and newname were different files, then RENAME SHOULD be rejected with NFS4ERR_FILE_OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldnameとrenameが同じファイルを参照し、oldnameとnewnameが異なるファイルである場合にRENAMEが通常NFS4ERR_FILE_OPENで拒否されるようにそのファイルが開かれている場合、RENAME SHOULDはNFS4ERR_FILE_OPENで拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server does implement such restrictions and those restrictions include cases of NFSv4 opens preventing successful execution of a rename, the server needs to recall any delegations that could hide the existence of opens relevant to that decision. This is because when a client holds a delegation, the server might not have an accurate account of the opens for that client, since the client may execute OPENs and CLOSEs locally. The RENAME operation need only be delayed until a definitive result can be obtained. For example, if there are multiple delegations and one of them establishes an open whose presence would prevent the rename, given the server&#39;s semantics, NFS4ERR_FILE_OPEN may be returned to the caller as soon as that delegation is returned without waiting for other delegations to be returned. Similarly, if such opens are not associated with delegations, NFS4ERR_FILE_OPEN can be returned immediately with no delegation recall being done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがそのような制限を実装し、それらの制限にNFSv4オープンが名前変更の正常な実行を妨げるケースが含まれる場合、サーバーはその決定に関連するオープンの存在を隠す可能性があるすべての委任を呼び出す必要があります。これは、クライアントが委任を保持している場合、クライアントがローカルでOPENおよびCLOSEを実行する可能性があるため、サーバーがそのクライアントのオープンの正確なアカウントを持たない可能性があるためです。 RENAME操作は、最終的な結果が得られるまで遅らせる必要があります。たとえば、複数の委任があり、そのうちの1つが名前の変更を妨げるようなオープンを確立する場合、サーバーのセマンティクスを考えると、他の委任が返されるのを待たずに、その委任が返されるとすぐにNFS4ERR_FILE_OPENが呼び出し元に返されることがあります。同様に、そのようなオープンが委任に関連付けられていない場合、委任の再呼び出しを行わずに、NFS4ERR_FILE_OPENをすぐに返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle or the saved filehandle designates a directory for which another client holds a directory delegation, then, unless the situation can be resolved by sending a notification, the delegation MUST be recalled, and the operation cannot proceed until the delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルまたは保存されたファイルハンドルが、別のクライアントがディレクトリの委任を保持するディレクトリを指定している場合、通知を送信して状況を解決できない限り、委任を再呼び出しする必要があり、委任が返されるまで操作を続行できません。取り消されました。これが非常に迅速に発生する場合を除いて、委任が未解決のままである間に、1つ以上のNFS4ERR_DELAYエラーが要求に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When the current and saved filehandles are the same and they designate a directory for which one or more directory delegations exist, then, when those delegations request such notifications, a notification of type NOTIFY4_RENAME_ENTRY will be generated as a result of this operation. When oldname and rename refer to the same file, no notification is generated (because, as Section 18.26.3 states, the server MUST take no action). When a file is removed because it has the same name as the target, if that removal is done atomically with the rename, a NOTIFY4_REMOVE_ENTRY notification will not be generated. Instead, the deletion of the file will be reported as part of the NOTIFY4_RENAME_ENTRY notification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When the current and saved filehandles are the same and they designate a directory for which one or more directory delegations exist, then, when those delegations request such notifications, a notification of type NOTIFY4_RENAME_ENTRY will be generated as a result of this operation. When oldname and rename refer to the same file, no notification is generated (because, as Section 18.26.3 states, the server MUST take no action). When a file is removed because it has the same name as the target, if that removal is done atomically with the rename, a NOTIFY4_REMOVE_ENTRY notification will not be generated. Instead, the deletion of the file will be reported as part of the NOTIFY4_RENAME_ENTRY notification.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the current and saved filehandles are not the same:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルと保存されたファイルハンドルが同じでない場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the current filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, NOTIFY4_ADD_ENTRY will be generated as a result of this operation. When a file is removed because it has the same name as the target, if that removal is done atomically with the rename, a NOTIFY4_REMOVE_ENTRY notification will not be generated. Instead, the deletion of the file will be reported as part of the NOTIFY4_ADD_ENTRY notification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 現在のファイルハンドルが1つ以上のディレクトリ委任が存在するディレクトリを指定している場合、それらの委任がそのような通知を要求すると、この操作の結果としてNOTIFY4_ADD_ENTRYが生成されます。ターゲットと同じ名前のファイルが削除されたときに、名前の変更を使用してその削除がアトミックに行われた場合、NOTIFY4_REMOVE_ENTRY通知は生成されません。代わりに、ファイルの削除はNOTIFY4_ADD_ENTRY通知の一部として報告されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the saved filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, NOTIFY4_REMOVE_ENTRY will be generated as a result of this operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 保存されたファイルハンドルが、1つ以上のディレクトリ委任が存在するディレクトリを指定している場合、それらの委任がそのような通知を要求すると、この操作の結果としてNOTIFY4_REMOVE_ENTRYが生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the object being renamed has file delegations held by clients other than the one doing the RENAME, the delegations MUST be recalled, and the operation cannot proceed until each such delegation is returned or revoked. Note that in the case of multiply linked files, the delegation recall requirement applies even if the delegation was obtained through a different name than the one being renamed. In all cases in which delegations are recalled, the server is likely to return one or more NFS4ERR_DELAY errors while the delegation(s) remains outstanding, although it might not do that if the delegations are returned quickly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前を変更するオブジェクトに、RENAMEを実行するクライアント以外のクライアントが保持するファイル委任がある場合、委任を再呼び出しする必要があり、そのような各委任が返されるか取り消されるまで操作を続行できません。複数にリンクされたファイルの場合、名前が変更されている名前とは異なる名前で委任が取得された場合でも、委任取り消しの要件が適用されます。委任がリコールされるすべての場合において、サーバーは、委任が未処理のままである間、1つ以上のNFS4ERR_DELAYエラーを返す可能性がありますが、委任が迅速に返された場合はそうはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RENAME operation must be atomic to the client. The statement &#34;source and target directories MUST reside on the same file system on the server&#34; means that the fsid fields in the attributes for the directories are the same. If they reside on different file systems, the error NFS4ERR_XDEV is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENAME操作は、クライアントに対してアトミックである必要があります。 「ソースディレクトリとターゲットディレクトリはサーバー上の同じファイルシステムに存在する必要がある」というステートメントは、ディレクトリの属性のfsidフィールドが同じであることを意味します。それらが異なるファイルシステムに存在する場合、エラーNFS4ERR_XDEVが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the value of the fh_expire_type attribute for the object, the filehandle may or may not expire on a RENAME. However, server implementors are strongly encouraged to attempt to keep filehandles from expiring in this fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトのfh_expire_type属性の値に基づいて、ファイルハンドルはRENAMEで期限切れになる場合とされない場合があります。ただし、サーバーの実装者は、この方法でファイルハンドルが期限切れにならないようにすることを強くお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On some servers, the file names &#34;.&#34; and &#34;..&#34; are illegal as either oldname or newname, and will result in the error NFS4ERR_BADNAME. In addition, on many servers the case of oldname or newname being an alias for the source directory will be checked for. Such servers will return the error NFS4ERR_INVAL in these cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のサーバーでは、ファイル名は「。」です。および「..」はoldnameまたはnewnameとしては不正であり、エラーNFS4ERR_BADNAMEが発生します。さらに、多くのサーバーでは、oldnameまたはnewnameがソースディレクトリのエイリアスであるかどうかがチェックされます。このようなサーバーは、これらの場合にエラーNFS4ERR_INVALを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If either of the source or target filehandles are not directories, the server will return NFS4ERR_NOTDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースまたはターゲットのファイルハンドルのいずれかがディレクトリでない場合、サーバーはNFS4ERR_NOTDIRを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-27--Operation-31-RESTOREFH---Restore-Saved-Filehandle">
18.27. Operation 31: RESTOREFH - Restore Saved Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.27. 操作31：RESTOREFH-保存されたファイルハンドルの復元
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-27-1--ARGUMENTS">
18.27.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.27.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* SAVED_FH: */
   void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-27-2--RESULTS">
18.27.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.27.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RESTOREFH4res {
           /*
            * If status is NFS4_OK,
            *     new CURRENT_FH: value of saved fh
            */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-27-3--DESCRIPTION">
18.27.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.27.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RESTOREFH operation sets the current filehandle and stateid to the values in the saved filehandle and stateid. If there is no saved filehandle, then the server will return the error NFS4ERR_NOFILEHANDLE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESTOREFH操作は、現在のファイルハンドルと状態IDを、保存されたファイルハンドルと状態IDの値に設定します。保存されたファイルハンドルがない場合、サーバーはエラーNFS4ERR_NOFILEHANDLEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 16.2.3.1.1 for more details on the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルの詳細については、16.2.3.1.1項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 16.2.3.1.2 for more details on the current stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の状態IDの詳細については、セクション16.2.3.1.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-27-4--IMPLEMENTATION">
18.27.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.27.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Operations like OPEN and LOOKUP use the current filehandle to represent a directory and replace it with a new filehandle. Assuming that the previous filehandle was saved with a SAVEFH operator, the previous filehandle can be restored as the current filehandle. This is commonly used to obtain post-operation attributes for the directory, e.g.,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENやLOOKUPなどの操作では、現在のファイルハンドルを使用してディレクトリを表し、それを新しいファイルハンドルで置き換えます。以前のファイルハンドルがSAVEFH演算子で保存されたと仮定すると、以前のファイルハンドルを現在のファイルハンドルとして復元できます。これは通常、ディレクトリの操作後の属性を取得するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
PUTFH (directory filehandle) SAVEFH GETATTR attrbits (pre-op dir attrs) CREATE optbits &#34;foo&#34; attrs GETATTR attrbits (file attributes) RESTOREFH GETATTR attrbits (post-op dir attrs)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
PUTFH（ディレクトリファイルハンドル）SAVEFH GETATTR attrbits（pre-op dir attrs）CREATE optbits &#34;foo&#34; attrs GETATTR attrbits（file attributes）RESTOREFH GETATTR attrbits（post-op dir attrs）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-28--Operation-32-SAVEFH---Save-Current-Filehandle">
18.28. Operation 32: SAVEFH - Save Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.28. 操作32：SAVEFH-現在のファイルハンドルを保存
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-28-1--ARGUMENTS">
18.28.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.28.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* CURRENT_FH: */
   void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-28-2--RESULTS">
18.28.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.28.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SAVEFH4res {
           /*
            * If status is NFS4_OK,
            *    new SAVED_FH: value of current fh
            */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-28-3--DESCRIPTION">
18.28.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.28.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SAVEFH operation saves the current filehandle and stateid. If a previous filehandle was saved, then it is no longer accessible. The saved filehandle can be restored as the current filehandle with the RESTOREFH operator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SAVEFH操作は、現在のファイルハンドルと状態IDを保存します。以前のファイルハンドルが保存されている場合は、アクセスできなくなります。保存されたファイルハンドルは、RESTOREFHオペレーターを使用して現在のファイルハンドルとして復元できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 16.2.3.1.1 for more details on the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルの詳細については、16.2.3.1.1項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 16.2.3.1.2 for more details on the current stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の状態IDの詳細については、セクション16.2.3.1.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-28-4--IMPLEMENTATION">
18.28.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.28.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-29--Operation-33-SECINFO---Obtain-Available-Security">
18.29. Operation 33: SECINFO - Obtain Available Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.29. 操作33：SECINFO-利用可能なセキュリティを取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-29-1--ARGUMENTS">
18.29.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.29.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SECINFO4args {
           /* CURRENT_FH: directory */
           component4      name;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-29-2--RESULTS">
18.29.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.29.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * From RFC 2203
    */
   enum rpc_gss_svc_t {
           RPC_GSS_SVC_NONE        = 1,
           RPC_GSS_SVC_INTEGRITY   = 2,
           RPC_GSS_SVC_PRIVACY     = 3
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct rpcsec_gss_info {
           sec_oid4        oid;
           qop4            qop;
           rpc_gss_svc_t   service;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* RPCSEC_GSS has a value of &#39;6&#39; - See RFC 2203 */
   union secinfo4 switch (uint32_t flavor) {
    case RPCSEC_GSS:
            rpcsec_gss_info        flavor_info;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef secinfo4 SECINFO4resok&lt;&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union SECINFO4res switch (nfsstat4 status) {
    case NFS4_OK:
           /* CURRENTFH: consumed */
            SECINFO4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-29-3--DESCRIPTION">
18.29.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.29.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SECINFO operation is used by the client to obtain a list of valid RPC authentication flavors for a specific directory filehandle, file name pair. SECINFO should apply the same access methodology used for LOOKUP when evaluating the name. Therefore, if the requester does not have the appropriate access to LOOKUP the name, then SECINFO MUST behave the same way and return NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはSECINFO操作を使用して、特定のディレクトリファイルハンドルとファイル名のペアの有効なRPC認証フレーバーのリストを取得します。 SECINFOは、名前を評価するときにLOOKUPに使用されるものと同じアクセス方法を適用する必要があります。したがって、リクエスターが名前をLOOKUPに適切にアクセスできない場合、SECINFOは同じように動作し、NFS4ERR_ACCESSを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The result will contain an array that represents the security mechanisms available, with an order corresponding to the server&#39;s preferences, the most preferred being first in the array. The client is free to pick whatever security mechanism it both desires and supports, or to pick in the server&#39;s preference order the first one it supports. The array entries are represented by the secinfo4 structure. The field &#39;flavor&#39; will contain a value of AUTH_NONE, AUTH_SYS (as defined in RFC 5531 [3]), or RPCSEC_GSS (as defined in RFC 2203 [4]). The field flavor can also be any other security flavor registered with IANA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果には、サーバーの設定に対応する順序で利用可能なセキュリティメカニズムを表す配列が含まれます。最も優先されるのは配列の最初です。クライアントは、希望とサポートの両方のセキュリティメカニズムを自由に選択することも、サーバーが最初にサポートする優先順位を自由に選択することもできます。配列エントリは、secinfo4構造によって表されます。フィールド &#39;flavor&#39;には、AUTH_NONE、AUTH_SYS（RFC 5531 [3]で定義）、またはRPCSEC_GSS（RFC 2203 [4]で定義）の値が含まれます。フィールドフレーバーは、IANAに登録されている他のセキュリティフレーバーにすることもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the flavors AUTH_NONE and AUTH_SYS, no additional security information is returned. The same is true of many (if not most) other security flavors, including AUTH_DH. For a return value of RPCSEC_GSS, a security triple is returned that contains the mechanism object identifier (OID, as defined in RFC 2743 [7]), the quality of protection (as defined in RFC 2743 [7]), and the service type (as defined in RFC 2203 [4]). It is possible for SECINFO to return multiple entries with flavor equal to RPCSEC_GSS with different security triple values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUTH_NONEおよびAUTH_SYSフレーバーの場合、追加のセキュリティ情報は返されません。同じことは、AUTH_DHを含む他の多くの（ほとんどではないにしても）セキュリティフレーバーにも当てはまります。 RPCSEC_GSSの戻り値の場合、メカニズムオブジェクト識別子（RFC 2743 [7]で定義されているOID）、保護品質（RFC 2743 [7]で定義されている）、およびサービスタイプを含むセキュリティトリプルが返されます。 （RFC 2203 [4]で定義されています）。 SECINFOは、異なるセキュリティトリプル値を持つRPCSEC_GSSに等しいフレーバーを持つ複数のエントリを返すことが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle is consumed (see Section 2.6.3.1.1.8), and if the next operation after SECINFO tries to use the current filehandle, that operation will fail with the status NFS4ERR_NOFILEHANDLE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルが消費され（セクション2.6.3.1.1.8を参照）、SECINFOが現在のファイルハンドルを使用しようとした後の次の操作は、ステータスNFS4ERR_NOFILEHANDLEで失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the name has a length of zero, or if the name does not obey the UTF-8 definition (assuming UTF-8 capabilities are enabled; see Section 14.4), the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前の長さがゼロである場合、または名前がUTF-8定義に従っていない場合（UTF-8機能が有効になっていると想定。セクション14.4を参照）、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 2.6 for additional information on the use of SECINFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFOの使用に関する追加情報については、セクション2.6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-29-4--IMPLEMENTATION">
18.29.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.29.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The SECINFO operation is expected to be used by the NFS client when the error value of NFS4ERR_WRONGSEC is returned from another NFS operation. This signifies to the client that the server&#39;s security policy is different from what the client is currently using. At this point, the client is expected to obtain a list of possible security flavors and choose what best suits its policies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
SECINFO操作は、NFS4ERR_WRONGSECのエラー値が別のNFS操作から返されたときに、NFSクライアントによって使用されることが期待されています。これは、サーバーのセキュリティポリシーがクライアントが現在使用しているものとは異なることをクライアントに示します。この時点で、クライアントは可能なセキュリティフレーバーのリストを取得し、そのポリシーに最適なものを選択することが期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned, the server&#39;s security policies will determine when a client request receives NFS4ERR_WRONGSEC. See Table 8 for a list of operations that can return NFS4ERR_WRONGSEC. In addition, when READDIR returns attributes, the rdattr_error (Section 5.8.1.12) can contain NFS4ERR_WRONGSEC. Note that CREATE and REMOVE MUST NOT return NFS4ERR_WRONGSEC. The rationale for CREATE is that unless the target name exists, it cannot have a separate security policy from the parent directory, and the security policy of the parent was checked when its filehandle was injected into the COMPOUND request&#39;s operations stream (for similar reasons, an OPEN operation that creates the target MUST NOT return NFS4ERR_WRONGSEC). If the target name exists, while it might have a separate security policy, that is irrelevant because CREATE MUST return NFS4ERR_EXIST. The rationale for REMOVE is that while that target might have a separate security policy, the target is going to be removed, and so the security policy of the parent trumps that of the object being removed. RENAME and LINK MAY return NFS4ERR_WRONGSEC, but the NFS4ERR_WRONGSEC error applies only to the saved filehandle (see Section 2.6.3.1.2). Any NFS4ERR_WRONGSEC error on the current filehandle used by LINK and RENAME MUST be returned by the PUTFH, PUTPUBFH, PUTROOTFH, or RESTOREFH operation that injected the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前述のように、サーバーのセキュリティポリシーは、クライアント要求がNFS4ERR_WRONGSECを受信するタイミングを決定します。 NFS4ERR_WRONGSECを返す可能性のある操作のリストについては、表8を参照してください。さらに、READDIRが属性を返す場合、rdattr_error（セクション5.8.1.12）にNFS4ERR_WRONGSECを含めることができます。 CREATEとREMOVEはNFS4ERR_WRONGSECを返してはならないことに注意してください。 CREATEの理論的根拠は、ターゲット名が存在しない限り、親ディレクトリとは別のセキュリティポリシーを持つことができず、ファイルハンドルがCOMPOUNDリクエストのオペレーションストリームに挿入されたときに親のセキュリティポリシーがチェックされたことです（同様の理由により、ターゲットを作成するOPEN操作は、NFS4ERR_WRONGSECを返してはなりません（MUST NOT）。ターゲット名が存在する場合、別のセキュリティポリシーがある可能性がありますが、CREATEはNFS4ERR_EXISTを返さなければならないため、これは無関係です。 REMOVEの理論的根拠は、そのターゲットに個別のセキュリティポリシーがある場合でも、ターゲットが削除されるため、削除されるオブジェクトのセキュリティポリシーよりも親のセキュリティポリシーの方が優先されるということです。 RENAMEおよびLINKはNFS4ERR_WRONGSECを返す場合がありますが、NFS4ERR_WRONGSECエラーは保存されたファイルハンドルにのみ適用されます（セクション2.6.3.1.2を参照）。 LINKおよびRENAMEによって使用される現在のファイルハンドルでのNFS4ERR_WRONGSECエラーは、現在のファイルハンドルを挿入したPUTFH、PUTPUBFH、PUTROOTFH、またはRESTOREFH操作によって返される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the exception of LINK and RENAME, the set of operations that can return NFS4ERR_WRONGSEC represents the point at which the client can inject a filehandle into the &#34;current filehandle&#34; at the server. The filehandle is either provided by the client (PUTFH, PUTPUBFH, PUTROOTFH), generated as a result of a name-to-filehandle translation (LOOKUP and OPEN), or generated from the saved filehandle via RESTOREFH. As Section 2.6.3.1.1.1 states, a put filehandle operation followed by SAVEFH MUST NOT return NFS4ERR_WRONGSEC. Thus, the RESTOREFH operation, under certain conditions (see Section 2.6.3.1.1), is permitted to return NFS4ERR_WRONGSEC so that security policies can be honored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LINKとRENAMEを除いて、NFS4ERR_WRONGSECを返すことができる一連の操作は、クライアントがサーバーの「現在のファイルハンドル」にファイルハンドルを挿入できるポイントを表します。ファイルハンドルは、クライアント（PUTFH、PUTPUBFH、PUTROOTFH）によって提供されるか、名前からファイルハンドルへの変換（LOOKUPおよびOPEN）の結果として生成されるか、またはRESTOREFHを介して保存されたファイルハンドルから生成されます。セクション2.6.3.1.1.1で述べられているように、SAVEFHが後に続くput filehandle操作はNFS4ERR_WRONGSECを返してはなりません。したがって、RESTOREFH操作は、特定の条件下（セクション2.6.3.1.1を参照）でNFS4ERR_WRONGSECを返すことが許可されているため、セキュリティポリシーを遵守できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READDIR operation will not directly return the NFS4ERR_WRONGSEC error. However, if the READDIR request included a request for attributes, it is possible that the READDIR request&#39;s security triple did not match that of a directory entry. If this is the case and the client has requested the rdattr_error attribute, the server will return the NFS4ERR_WRONGSEC error in rdattr_error for the entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR操作は、NFS4ERR_WRONGSECエラーを直接返しません。ただし、READDIR要求に属性の要求が含まれている場合、READDIR要求のセキュリティトリプルがディレクトリエントリのセキュリティトリプルと一致しなかった可能性があります。これが当てはまり、クライアントがrdattr_error属性を要求した場合、サーバーはエントリのrdattr_errorでNFS4ERR_WRONGSECエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 To resolve an error return of NFS4ERR_WRONGSEC, the client does the following: o For LOOKUP and OPEN, the client will use SECINFO with the same current filehandle and name as provided in the original LOOKUP or OPEN to enumerate the available security triples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFS4ERR_WRONGSECのエラーリターンを解決するために、クライアントは次のことを行います。o LOOKUPおよびOPENの場合、クライアントは、元のLOOKUPまたはOPENで提供されているものと同じ現在のファイルハンドルおよび名前でSECINFOを使用して、利用可能なセキュリティトリプルを列挙します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For the rdattr_error, the client will use SECINFO with the same current filehandle as provided in the original READDIR. The name passed to SECINFO will be that of the directory entry (as returned from READDIR) that had the NFS4ERR_WRONGSEC error in the rdattr_error attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o rdattr_errorの場合、クライアントは、元のREADDIRで提供されているものと同じ現在のファイルハンドルでSECINFOを使用します。 SECINFOに渡される名前は、rdattr_error属性でNFS4ERR_WRONGSECエラーが発生した（READDIRから返された）ディレクトリエントリの名前になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For PUTFH, PUTROOTFH, PUTPUBFH, RESTOREFH, LINK, and RENAME, the client will use SECINFO_NO_NAME { style = SECINFO_STYLE4_CURRENT_FH }. The client will prefix the SECINFO_NO_NAME operation with the appropriate PUTFH, PUTPUBFH, or PUTROOTFH operation that provides the filehandle originally provided by the PUTFH, PUTPUBFH, PUTROOTFH, or RESTOREFH operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PUTFH、PUTROOTFH、PUTPUBFH、RESTOREFH、LINK、およびRENAMEの場合、クライアントはSECINFO_NO_NAME {style = SECINFO_STYLE4_CURRENT_FH}を使用します。クライアントは、SECINFO_NO_NAME操作の前に、PUTFH、PUTPUBFH、PUTROOTFH、またはRESTOREFH操作によって最初に提供されたファイルハンドルを提供する適切なPUTFH、PUTPUBFH、またはPUTROOTFH操作を付けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NOTE: In NFSv4.0, the client was required to use SECINFO, and had to reconstruct the parent of the original filehandle and the component name of the original filehandle. The introduction in NFSv4.1 of SECINFO_NO_NAME obviates the need for reconstruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：NFSv4.0では、クライアントはSECINFOを使用する必要があり、元のファイルハンドルの親と元のファイルハンドルのコンポーネント名を再構築する必要がありました。 NFSv4.1でのSECINFO_NO_NAMEの導入により、再構築の必要がなくなりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For LOOKUPP, the client will use SECINFO_NO_NAME { style = SECINFO_STYLE4_PARENT } and provide the filehandle that equals the filehandle originally provided to LOOKUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LOOKUPPの場合、クライアントはSECINFO_NO_NAME {style = SECINFO_STYLE4_PARENT}を使用し、LOOKUPPに最初に提供されていたファイルハンドルと等しいファイルハンドルを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 21 for a discussion on the recommendations for the security flavor used by SECINFO and SECINFO_NO_NAME.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFOおよびSECINFO_NO_NAMEで使用されるセキュリティフレーバーの推奨事項については、セクション21を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-30--Operation-34-SETATTR---Set-Attributes">
18.30. Operation 34: SETATTR - Set Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.30. 操作34：SETATTR-属性の設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-30-1--ARGUMENTS">
18.30.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.30.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETATTR4args {
           /* CURRENT_FH: target object */
           stateid4        stateid;
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-30-2--RESULTS">
18.30.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.30.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETATTR4res {
           nfsstat4        status;
           bitmap4         attrsset;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-30-3--DESCRIPTION">
18.30.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.30.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SETATTR operation changes one or more of the attributes of a file system object. The new attributes are specified with a bitmap and the attributes that follow the bitmap in bit order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTR操作は、ファイルシステムオブジェクトの1つ以上の属性を変更します。新しい属性は、ビットマップとビットマップのビットオーダーに続く属性で指定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The stateid argument for SETATTR is used to provide byte-range locking context that is necessary for SETATTR requests that set the size attribute. Since setting the size attribute modifies the file&#39;s data, it has the same locking requirements as a corresponding WRITE. Any SETATTR that sets the size attribute is incompatible with a share reservation that specifies OPEN4_SHARE_DENY_WRITE. The area between the old end-of-file and the new end-of-file is considered to be modified just as would have been the case had the area in question been specified as the target of WRITE, for the purpose of checking conflicts with byte-range locks, for those cases in which a server is implementing mandatory byte-range locking behavior. A valid stateid SHOULD always be specified. When the file size attribute is not set, the special stateid consisting of all bits equal to zero MAY be passed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTRのstateid引数は、サイズ属性を設定するSETATTR要求に必要なバイト範囲のロックコンテキストを提供するために使用されます。 size属性を設定するとファイルのデータが変更されるため、対応するWRITEと同じロック要件があります。サイズ属性を設定するSETATTRは、OPEN4_SHARE_DENY_WRITEを指定する共有予約と互換性がありません。古いファイルの終わりと新しいファイルの終わりの間の領域は、問題の領域がWRITEのターゲットとして指定されている場合と同様に、との競合をチェックするために変更されたと見なされます。バイト範囲ロック（サーバーが必須のバイト範囲ロック動作を実装している場合）。有効な状態IDを常に指定する必要があります（SHOULD）。ファイルサイズ属性が設定されていない場合、ゼロに等しいすべてのビットで構成される特別な状態IDが渡される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On either success or failure of the operation, the server will return the attrsset bitmask to represent what (if any) attributes were successfully set. The attrsset in the response is a subset of the attrmask field of the obj_attributes field in the argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作の成功または失敗のいずれかで、サーバーは、attrssetビットマスクを返し、正常に設定された属性（存在する場合）を表します。応答のattrssetは、引数のobj_attributesフィールドのattrmaskフィールドのサブセットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-30-4--IMPLEMENTATION">
18.30.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.30.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the request specifies the owner attribute to be set, the server SHOULD allow the operation to succeed if the current owner of the object matches the value specified in the request. Some servers may be implemented in a way as to prohibit the setting of the owner attribute unless the requester has privilege to do so. If the server is lenient in this one case of matching owner values, the client implementation may be simplified in cases of creation of an object (e.g., an exclusive create via OPEN) followed by a SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストが設定される所有者属性を指定する場合、オブジェクトの現在の所有者がリクエストで指定された値と一致する場合、サーバーは操作が成功することを許可する必要があります。一部のサーバーは、リクエスターがそうする特権を持たない限り、所有者属性の設定を禁止するような方法で実装される場合があります。所有者の値が一致するこの1つのケースでサーバーが寛容である場合、オブジェクトの作成（たとえば、OPENによる排他的な作成）の後にSETATTRを実行すると、クライアントの実装が簡略化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The file size attribute is used to request changes to the size of a file. A value of zero causes the file to be truncated, a value less than the current size of the file causes data from new size to the end of the file to be discarded, and a size greater than the current size of the file causes logically zeroed data bytes to be added to the end of the file. Servers are free to implement this using unallocated bytes (holes) or allocated data bytes set to zero. Clients should not make any assumptions regarding a server&#39;s implementation of this feature, beyond that the bytes in the affected byte-range returned by READ will be zeroed. Servers MUST support extending the file size via SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ファイルサイズ属性は、ファイルサイズの変更を要求するために使用されます。値0はファイルを切り捨て、ファイルの現在のサイズより小さい値は新しいサイズからファイルの終わりまでのデータを破棄し、ファイルの現在のサイズより大きいサイズは論理的にゼロになります。ファイルの最後に追加されるデータバイト。サーバーは、未割り当てバイト（穴）または割り当てられたデータバイトをゼロに設定して、これを自由に実装できます。クライアントは、この機能のサーバーの実装に関して、READによって返される影響を受けるバイト範囲のバイトがゼロになること以外は、何も想定しないでください。サーバーは、SETATTRによるファイルサイズの拡張をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTR is not guaranteed to be atomic. A failed SETATTR may partially change a file&#39;s attributes, hence the reason why the reply always includes the status and the list of attributes that were set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTRがアトミックであることは保証されていません。失敗したSETATTRは、ファイルの属性を部分的に変更する可能性があります。そのため、応答には常にステータスと設定された属性のリストが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the object whose attributes are being changed has a file delegation that is held by a client other than the one doing the SETATTR, the delegation(s) must be recalled, and the operation cannot proceed to actually change an attribute until each such delegation is returned or revoked. In all cases in which delegations are recalled, the server is likely to return one or more NFS4ERR_DELAY errors while the delegation(s) remains outstanding, although it might not do that if the delegations are returned quickly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性が変更されているオブジェクトに、SETATTRを実行しているクライアント以外のクライアントが保持するファイル委任がある場合、委任を再呼び出しする必要があり、そのような各委任が完了するまで、操作は実際に属性を変更できません。返却または取り消されました。委任がリコールされるすべての場合において、サーバーは、委任が未処理のままである間、1つ以上のNFS4ERR_DELAYエラーを返す可能性がありますが、委任が迅速に返された場合はそうはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the object whose attributes are being set is a directory and another client holds a directory delegation for that directory, then if enabled, asynchronous notifications will be generated when the set of attributes changed has a non-null intersection with the set of attributes for which notification is requested. Notifications of type NOTIFY4_CHANGE_DIR_ATTRS will be sent to the appropriate client(s), but the SETATTR is not delayed by waiting for these notifications to be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性が設定されているオブジェクトがディレクトリであり、別のクライアントがそのディレクトリのディレクトリ委譲を保持している場合、有効にすると、変更された属性のセットが対象の属性のセットとnull以外の共通部分を持つときに非同期通知が生成されます。通知が要求されます。タイプNOTIFY4_CHANGE_DIR_ATTRSの通知は適切なクライアントに送信されますが、SETATTRはこれらの通知が送信されるのを待つことによって遅延されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the object whose attributes are being set is a member of the directory for which another client holds a directory delegation, then asynchronous notifications will be generated when the set of attributes changed has a non-null intersection with the set of attributes for which notification is requested. Notifications of type NOTIFY4_CHANGE_CHILD_ATTRS will be sent to the appropriate clients, but the SETATTR is not delayed by waiting for these notifications to be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性が設定されているオブジェクトが、別のクライアントがディレクトリ委任を保持しているディレクトリのメンバーである場合、変更された属性のセットに、通知が設定されている属性のセットとのnull以外の交差があると、非同期通知が生成されます。要求した。 NOTIFY4_CHANGE_CHILD_ATTRSタイプの通知は適切なクライアントに送信されますが、SETATTRはこれらの通知が送信されるのを待機することによって遅延されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Changing the size of a file with SETATTR indirectly changes the time_modify and change attributes. A client must account for this as size changes can result in data deletion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTRを使用してファイルのサイズを変更すると、time_modifyおよびchange属性が間接的に変更されます。サイズを変更するとデータが削除される可能性があるため、クライアントはこれを考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attributes time_access_set and time_modify_set are write-only attributes constructed as a switched union so the client can direct the server in setting the time values. If the switched union specifies SET_TO_CLIENT_TIME4, the client has provided an nfstime4 to be used for the operation. If the switch union does not specify SET_TO_CLIENT_TIME4, the server is to use its current time for the SETATTR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性time_access_setおよびtime_modify_setは、クライアントがサーバーに時間値の設定を指示できるように、スイッチドユニオンとして構築された書き込み専用属性です。スイッチドユニオンがSET_TO_CLIENT_TIME4を指定している場合、クライアントは操作に使用するnfstime4を提供しています。スイッチユニオンでSET_TO_CLIENT_TIME4が指定されていない場合、サーバーはSETATTR操作に現在の時刻を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If server and client times differ, programs that compare client time to file times can break. A time synchronization protocol should be used to limit client/server time skew.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーとクライアントの時間が異なる場合、クライアントの時間とファイルの時間を比較するプログラムが機能しなくなる可能性があります。時間同期プロトコルを使用して、クライアント/サーバーの時間のずれを制限する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of a COMPOUND containing a VERIFY operation specifying only the change attribute, immediately followed by a SETATTR, provides a means whereby a client may specify a request that emulates the functionality of the SETATTR guard mechanism of NFSv3. Since the function of the guard mechanism is to avoid changes to the file attributes based on stale information, delays between checking of the guard condition and the setting of the attributes have the potential to compromise this function, as would the corresponding delay in the NFSv4 emulation. Therefore, NFSv4.1 servers SHOULD take care to avoid such delays, to the degree possible, when executing such a request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更属性のみを指定し、直後にSETATTRを指定するVERIFY操作を含むCOMPOUNDを使用すると、クライアントがNFSv3のSETATTRガードメカニズムの機能をエミュレートする要求を指定できるようになります。ガードメカニズムの機能は古い情報に基づくファイル属性の変更を回避することであるため、NFSv4エミュレーションの対応する遅延と同様に、ガード条件のチェックと属性の設定の間の遅延は、この機能を損なう可能性があります。 。したがって、NFSv4.1サーバーは、そのような要求を実行するとき、可能な限り、そのような遅延を回避するように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server does not support an attribute as requested by the client, the server SHOULD return NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがクライアントによって要求された属性をサポートしない場合、サーバーはNFS4ERR_ATTRNOTSUPPを返す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A mask of the attributes actually set is returned by SETATTR in all cases. That mask MUST NOT include attribute bits not requested to be set by the client. If the attribute masks in the request and reply are equal, the status field in the reply MUST be NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際に設定される属性のマスクは、すべての場合にSETATTRによって返されます。そのマスクには、クライアントによって設定されるように要求されていない属性ビットを含めてはなりません（MUST NOT）。リクエストとリプライの属性マスクが等しい場合、リプライのステータスフィールドはNFS4_OKでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-31--Operation-37-VERIFY---Verify-Same-Attributes">
18.31. Operation 37: VERIFY - Verify Same Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.31. 操作37：VERIFY-同じ属性を確認する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-31-1--ARGUMENTS">
18.31.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.31.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct VERIFY4args {
           /* CURRENT_FH: object */
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-31-2--RESULTS">
18.31.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.31.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct VERIFY4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-31-3--DESCRIPTION">
18.31.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.31.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The VERIFY operation is used to verify that attributes have the value assumed by the client before proceeding with the following operations in the COMPOUND request. If any of the attributes do not match, then the error NFS4ERR_NOT_SAME must be returned. The current filehandle retains its value after successful completion of the operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VERIFY操作は、COMPOUND要求で次の操作を進める前に、属性がクライアントによって想定された値を持っていることを確認するために使用されます。いずれかの属性が一致しない場合は、エラーNFS4ERR_NOT_SAMEを返す必要があります。現在のファイルハンドルは、操作が正常に完了した後もその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-31-4--IMPLEMENTATION">
18.31.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.31.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible use of the VERIFY operation is the following series of operations. With this, the client is attempting to verify that the file being removed will match what the client expects to be removed. This series can help prevent the unintended deletion of a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VERIFY操作の1つの可能な使用法は、次の一連の操作です。これにより、クライアントは、削除されるファイルが、クライアントが削除することを期待しているものと一致することを確認しようとしています。このシリーズは、ファイルの意図しない削除を防ぐのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
PUTFH (directory filehandle) LOOKUP (file name) VERIFY (filehandle == fh) PUTFH (directory filehandle) REMOVE (file name)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
PUTFH（ディレクトリファイルハンドル）LOOKUP（ファイル名）VERIFY（ファイルハンドル== fh）PUTFH（ディレクトリファイルハンドル）REMOVE（ファイル名）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This series does not prevent a second client from removing and creating a new file in the middle of this sequence, but it does help avoid the unintended result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このシリーズは、2番目のクライアントがこのシーケンスの途中で新しいファイルを削除および作成することを妨げませんが、意図しない結果を回避するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that a RECOMMENDED attribute is specified in the VERIFY operation and the server does not support that attribute for the file system object, the error NFS4ERR_ATTRNOTSUPP is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VERIFY操作でRECOMMENDED属性が指定されていて、サーバーがファイルシステムオブジェクトのその属性をサポートしていない場合、エラーNFS4ERR_ATTRNOTSUPPがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the attribute rdattr_error or any set-only attribute (e.g., time_modify_set) is specified, the error NFS4ERR_INVAL is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性rdattr_errorまたは任意のセットのみの属性（time_modify_setなど）が指定されている場合、エラーNFS4ERR_INVALがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-32--Operation-38-WRITE---Write-to-File">
18.32. Operation 38: WRITE - Write to File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.32. 操作38：書き込み-ファイルへの書き込み
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-32-1--ARGUMENTS">
18.32.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.32.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum stable_how4 {
           UNSTABLE4       = 0,
           DATA_SYNC4      = 1,
           FILE_SYNC4      = 2
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct WRITE4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           stable_how4     stable;
           opaque          data&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-32-2--RESULTS">
18.32.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.32.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct WRITE4resok {
           count4          count;
           stable_how4     committed;
           verifier4       writeverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union WRITE4res switch (nfsstat4 status) {
    case NFS4_OK:
            WRITE4resok    resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-32-3--DESCRIPTION">
18.32.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.32.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WRITE operation is used to write data to a regular file. The target file is specified by the current filehandle. The offset specifies the offset where the data should be written. An offset of zero specifies that the write should start at the beginning of the file. The count, as encoded as part of the opaque data parameter, represents the number of bytes of data that are to be written. If the count is zero, the WRITE will succeed and return a count of zero subject to permissions checking. The server MAY write fewer bytes than requested by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITE操作は、通常のファイルにデータを書き込むために使用されます。ターゲットファイルは、現在のファイルハンドルによって指定されます。オフセットは、データが書き込まれるオフセットを指定します。オフセット0は、ファイルの先頭から書き込みを開始することを指定します。不透明なデータパラメータの一部としてエンコードされたカウントは、書き込まれるデータのバイト数を表します。カウントがゼロの場合、WRITEは成功し、権限チェックの対象となるゼロのカウントを返します。サーバーは、クライアントが要求したよりも少ないバイトを書き込む場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client specifies with the stable parameter the method of how the data is to be processed by the server. If stable is FILE_SYNC4, the server MUST commit the data written plus all file system metadata to stable storage before returning results. This corresponds to the NFSv2 protocol semantics. Any other behavior constitutes a protocol violation. If stable is DATA_SYNC4, then the server MUST commit all of the data to stable storage and enough of the metadata to retrieve the data before returning. The server implementor is free to implement DATA_SYNC4 in the same fashion as FILE_SYNC4, but with a possible performance drop. If stable is UNSTABLE4, the server is free to commit any part of the data and the metadata to stable storage, including all or none, before returning a reply to the client. There is no guarantee whether or when any uncommitted data will subsequently be committed to stable storage. The only guarantees made by the server are that it will not destroy any data without changing the value of writeverf and that it will not commit the data and metadata at a level less than that requested by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、stableパラメーターを使用して、サーバーによるデータの処理方法を指定します。 stableがFILE_SYNC4の場合、サーバーは、結果を返す前に、書き込まれたデータとすべてのファイルシステムメタデータを安定したストレージにコミットする必要があります。これは、NFSv2プロトコルのセマンティクスに対応しています。その他の動作はプロトコル違反になります。 stableがDATA_SYNC4の場合、サーバーはすべてのデータを安定したストレージにコミットし、返される前にデータを取得するために十分なメタデータをコミットする必要があります。サーバーの実装者は、FILE_SYNC4と同じ方法でDATA_SYNC4を自由に実装できますが、パフォーマンスが低下する可能性があります。 stableがUNSTABLE4である場合、サーバーは、クライアントに応答を返す前に、データおよびメタデータのすべてまたは一部を含むすべてまたは一部を、安定したストレージに自由にコミットできます。コミットされていないデータが後で安定したストレージにコミットされるかどうか、またはいつコミットされるかは保証されません。サーバーが行う唯一の保証は、writeverfの値を変更せずにデータを破壊しないこと、およびクライアントが要求したレベルよりも低いレベルでデータとメタデータをコミットしないことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Except when special stateids are used, the stateid value for a WRITE request represents a value returned from a previous byte-range LOCK or OPEN request or the stateid associated with a delegation. The stateid identifies the associated owners if any and is used by the server to verify that the associated locks are still valid (e.g., have not been revoked).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特別な状態IDが使用される場合を除いて、書き込み要求の状態ID値は、以前のバイト範囲のLOCKまたはOPEN要求から返された値、または委任に関連付けられた状態IDを表します。 stateidは、関連付けられた所有者が存在する場合にそれを識別し、関連付けられたロックがまだ有効であること（たとえば、取り消されていないこと）を確認するためにサーバーによって使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon successful completion, the following results are returned. The count result is the number of bytes of data written to the file. The server may write fewer bytes than requested. If so, the actual number of bytes written starting at location, offset, is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正常に完了すると、次の結果が返されます。カウント結果は、ファイルに書き込まれたデータのバイト数です。サーバーは要求されたよりも少ないバイトを書き込む場合があります。その場合、オフセットで始まる場所に書き込まれた実際のバイト数が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server also returns an indication of the level of commitment of the data and metadata via committed. Per Table 11,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、commitedを介したデータとメタデータのコミットメントのレベルの指標も返します。表11に従って、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server MAY commit the data at a stronger level than requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、要求されたよりも強いレベルでデータをコミットできます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server MUST commit the data at a level at least as high as that committed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、少なくともコミットされたレベルと同じレベルでデータをコミットする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Valid combinations of the fields stable in the request and committed in the reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストで安定し、返信でコミットされるフィールドの有効な組み合わせ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            +------------+-----------------------------------+
            | stable     | committed                         |
            +------------+-----------------------------------+
            | UNSTABLE4  | FILE_SYNC4, DATA_SYNC4, UNSTABLE4 |
            | DATA_SYNC4 | FILE_SYNC4, DATA_SYNC4            |
            | FILE_SYNC4 | FILE_SYNC4                        |
            +------------+-----------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Table 11
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
表11
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The final portion of the result is the field writeverf. This field is the write verifier and is a cookie that the client can use to determine whether a server has changed instance state (e.g., server restart) between a call to WRITE and a subsequent call to either WRITE or COMMIT. This cookie MUST be unchanged during a single instance of the NFSv4.1 server and MUST be unique between instances of the NFSv4.1 server. If the cookie changes, then the client MUST assume that any data written with an UNSTABLE4 value for committed and an old writeverf in the reply has been lost and will need to be recovered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果の最後の部分はフィールドwriteverfです。このフィールドは書き込みベリファイアであり、クライアントがWRITEの呼び出しとWRITEまたはCOMMITの後続の呼び出しの間でサーバーがインスタンスの状態（サーバーの再起動など）を変更したかどうかを判断するために使用できるCookieです。このCookieは、NFSv4.1サーバーの単一のインスタンス中に変更されてはならず（MUST）、NFSv4.1サーバーのインスタンス間で一意である必要があります。 Cookieが変更された場合、クライアントは、コミット済みのUNSTABLE4値で書き込まれたデータと、応答内の古いwriteverfが失われており、回復する必要があると想定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If a client writes data to the server with the stable argument set to UNSTABLE4 and the reply yields a committed response of DATA_SYNC4 or UNSTABLE4, the client will follow up some time in the future with a COMMIT operation to synchronize outstanding asynchronous data and metadata with the server&#39;s stable storage, barring client error. It is possible that due to client crash or other error that a subsequent COMMIT will not be received by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントが安定した引数をUNSTABLE4に設定してサーバーにデータを書き込み、その応答がDATA_SYNC4またはUNSTABLE4のコミットされた応答を生成する場合、クライアントはCOMMIT操作でしばらく待って、未処理の非同期データとメタデータを同期します。サーバーの安定したストレージ。クライアントエラーはありません。クライアントのクラッシュまたはその他のエラーのために、後続のCOMMITがサーバーによって受信されない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a WRITE with a stateid value of all bits equal to zero, the server MAY allow the WRITE to be serviced subject to mandatory byte-range locks or the current share deny modes for the file. For a WRITE with a stateid value of all bits equal to 1, the server MUST NOT allow the WRITE operation to bypass locking checks at the server and otherwise is treated as if a stateid of all bits equal to zero were used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのビットのstateid値がゼロに等しいWRITEの場合、サーバーは、必須のバイト範囲ロックまたはファイルの現在の共有拒否モードに従って、WRITEのサービスを許可できます（MAY）。すべてのビットのstateid値が1であるWRITEの場合、サーバーはWRITE操作がサーバーでのロックチェックをバイパスすることを許可してはならず、そうでない場合は、すべてのビットが0のstateidが使用されたかのように扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-32-4--IMPLEMENTATION">
18.32.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.32.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible for the server to write fewer bytes of data than requested by the client. In this case, the server SHOULD NOT return an error unless no data was written at all. If the server writes less than the number of bytes specified, the client will need to send another WRITE to write the remaining data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがクライアントの要求よりも少ないバイト数のデータを書き込む可能性があります。この場合、データがまったく書き込まれていなければ、サーバーはエラーを返すべきではありません（SHOULD NOT）。サーバーが指定したバイト数より少ない数を書き込む場合、クライアントは残りのデータを書き込むために別のWRITEを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is assumed that the act of writing data to a file will cause the time_modified and change attributes of the file to be updated. However, these attributes SHOULD NOT be changed unless the contents of the file are changed. Thus, a WRITE request with count set to zero SHOULD NOT cause the time_modified and change attributes of the file to be updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データをファイルに書き込む動作により、ファイルのtime_modifiedおよびchange属性が更新されることが想定されています。ただし、これらの属性は、ファイルの内容が変更されない限り変更しないでください。したがって、カウントがゼロに設定されたWRITE要求は、ファイルのtime_modifiedおよびchange属性を更新する必要があります（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stable storage is persistent storage that survives:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安定したストレージは存続する永続的なストレージです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Repeated power failures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 繰り返し停電。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Hardware failures (of any board, power supply, etc.).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. ハードウェア障害（ボード、電源装置など）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Repeated software crashes and restarts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 繰り返しソフトウェアがクラッシュして再起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This definition does not address failure of the stable storage module itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この定義は、安定したストレージモジュール自体の障害には対応していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The verifier is defined to allow a client to detect different instances of an NFSv4.1 protocol server over which cached, uncommitted data may be lost. In the most likely case, the verifier allows the client to detect server restarts. This information is required so that the client can safely determine whether the server could have lost cached data. If the server fails unexpectedly and the client has uncommitted data from previous WRITE requests (done with the stable argument set to UNSTABLE4 and in which the result committed was returned as UNSTABLE4 as well), the server might not have flushed cached data to stable storage. The burden of recovery is on the client, and the client will need to retransmit the data to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ベリファイアは、キャッシュされたコミットされていないデータが失われる可能性があるNFSv4.1プロトコルサーバーのさまざまなインスタンスをクライアントが検出できるように定義されています。ほとんどの場合、ベリファイアにより、クライアントはサーバーの再起動を検出できます。この情報は、サーバーがキャッシュされたデータを失ったかどうかをクライアントが安全に判断できるようにするために必要です。サーバーが予期せず失敗し、クライアントが以前のWRITEリクエストからコミットされていないデータを持っている場合（stable引数がUNSTABLE4に設定されており、コミットされた結果もUNSTABLE4として返された場合）、サーバーはキャッシュデータを安定したストレージにフラッシュしていない可能性があります。リカバリの負担はクライアントにあり、クライアントはサーバーにデータを再送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A suggested verifier would be to use the time that the server was last started (if restarting the server results in lost buffers).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
推奨される検証方法は、サーバーが最後に起動された時刻を使用することです（サーバーを再起動するとバッファーが失われる場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reply&#39;s committed field allows the client to do more effective caching. If the server is committing all WRITE requests to stable storage, then it SHOULD return with committed set to FILE_SYNC4, regardless of the value of the stable field in the arguments. A server that uses an NVRAM accelerator may choose to implement this policy. The client can use this to increase the effectiveness of the cache by discarding cached data that has already been committed on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答のコミット済みフィールドにより、クライアントはより効果的なキャッシュを行うことができます。サーバーがすべてのWRITE要求を安定したストレージにコミットしている場合、引数のstableフィールドの値に関係なく、committedをFILE_SYNC4に設定して返す必要があります（SHOULD）。 NVRAMアクセラレータを使用するサーバーは、このポリシーの実装を選択できます。クライアントはこれを使用して、サーバー上ですでにコミットされているキャッシュデータを破棄することにより、キャッシュの効果を高めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some implementations may return NFS4ERR_NOSPC instead of NFS4ERR_DQUOT when a user&#39;s quota is exceeded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部の実装では、ユーザーのクォータを超えると、NFS4ERR_DQUOTではなくNFS4ERR_NOSPCが返される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that the current filehandle is of type NF4DIR, the server will return NFS4ERR_ISDIR. If the current file is a symbolic link, the error NFS4ERR_SYMLINK will be returned. Otherwise, if the current filehandle does not designate an ordinary file, the server will return NFS4ERR_WRONG_TYPE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルのタイプがNF4DIRの場合、サーバーはNFS4ERR_ISDIRを返します。現在のファイルがシンボリックリンクの場合、エラーNFS4ERR_SYMLINKが返されます。それ以外の場合、現在のファイルハンドルが通常のファイルを指定していないと、サーバーはNFS4ERR_WRONG_TYPEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If mandatory byte-range locking is in effect for the file, and the corresponding byte-range of the data to be written to the file is READ_LT or WRITE_LT locked by an owner that is not associated with the stateid, the server MUST return NFS4ERR_LOCKED. If so, the client MUST check if the owner corresponding to the stateid used with the WRITE operation has a conflicting READ_LT lock that overlaps with the byte-range that was to be written. If the stateid&#39;s owner has no conflicting READ_LT lock, then the client SHOULD try to get the appropriate write byte-range lock via the LOCK operation before re-attempting the WRITE. When the WRITE completes, the client SHOULD release the byte-range lock via LOCKU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須のバイト範囲ロックがファイルに対して有効であり、ファイルに書き込まれるデータの対応するバイト範囲が、stateidに関連付けられていない所有者によってREAD_LTまたはWRITE_LTロックされている場合、サーバーはNFS4ERR_LOCKEDを返す必要があります。その場合、クライアントは、WRITE操作で使用された状態IDに対応する所有者が、書き込まれる予定のバイト範囲と重複する競合するREAD_LTロックを持っているかどうかを確認する必要があります。状態IDの所有者が競合するREAD_LTロックを持たない場合、クライアントはWRITEを再試行する前に、LOCK操作を介して適切な書き込みバイト範囲ロックを取得する必要があります（SHOULD）。書き込みが完了すると、クライアントはLOCKUを介してバイト範囲ロックを解放する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If the stateid&#39;s owner had a conflicting READ_LT lock, then the client has no choice but to return an error to the application that attempted the WRITE. The reason is that since the stateid&#39;s owner had a READ_LT lock, either the server attempted to temporarily effectively upgrade this READ_LT lock to a WRITE_LT lock or the server has no upgrade capability. If the server attempted to upgrade the READ_LT lock and failed, it is pointless for the client to re-attempt the upgrade via the LOCK operation, because there might be another client also trying to upgrade. If two clients are blocked trying to upgrade the same lock, the clients deadlock. If the server has no upgrade capability, then it is pointless to try a LOCK operation to upgrade.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
状態IDの所有者が競合するREAD_LTロックを持っている場合、クライアントはWRITEを試行したアプリケーションにエラーを返す以外に選択肢はありません。その理由は、stateidの所有者がREAD_LTロックを持っているため、サーバーがこのREAD_LTロックを一時的に効果的にWRITE_LTロックにアップグレードしようとしたか、サーバーにアップグレード機能がないためです。サーバーがREAD_LTロックをアップグレードしようとして失敗した場合、別のクライアントもアップグレードしようとしている可能性があるため、クライアントがLOCK操作を介してアップグレードを再試行しても意味がありません。 2つのクライアントが同じロックをアップグレードしようとしてブロックされた場合、クライアントはデッドロックします。サーバーにアップグレード機能がない場合は、LOCK操作を実行してアップグレードしても意味がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If one or more other clients have delegations for the file being written, those delegations MUST be recalled, and the operation cannot proceed until those delegations are returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while the delegation remains outstanding. Normally, delegations will not be recalled as a result of a WRITE operation since the recall will occur as a result of an earlier OPEN. However, since it is possible for a WRITE to be done with a special stateid, the server needs to check for this case even though the client should have done an OPEN previously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つまたは複数の他のクライアントに、書き込まれるファイルの委任がある場合、それらの委任を再呼び出しする必要があり、これらの委任が返されるか取り消されるまで操作を続行できません。これが非常に迅速に発生する場合を除いて、委任が未解決のままである間に、1つ以上のNFS4ERR_DELAYエラーが要求に返されます。以前のOPENの結果として再呼び出しが行われるため、通常、WRITE操作の結果として委任は再呼び出しされません。ただし、特別な状態IDでWRITEを実行できるため、クライアントが以前にOPENを実行していたとしても、サーバーはこのケースを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-33--Operation-40-BACKCHANNELCTL---Backchannel-Control">
18.33. Operation 40: BACKCHANNEL_CTL - Backchannel Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.33. 操作40：BACKCHANNEL_CTL-バックチャネル制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-33-1--ARGUMENT">
18.33.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.33.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef opaque gsshandle4_t&lt;&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct gss_cb_handles4 {
           rpc_gss_svc_t           gcbp_service; /* RFC 2203 */
           gsshandle4_t            gcbp_handle_from_server;
           gsshandle4_t            gcbp_handle_from_client;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union callback_sec_parms4 switch (uint32_t cb_secflavor) {
   case AUTH_NONE:
           void;
   case AUTH_SYS:
           authsys_parms   cbsp_sys_cred; /* RFC 1831 */
   case RPCSEC_GSS:
           gss_cb_handles4 cbsp_gss_handles;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct BACKCHANNEL_CTL4args {
           uint32_t                bca_cb_program;
           callback_sec_parms4     bca_sec_parms&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-33-2--RESULT">
18.33.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.33.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct BACKCHANNEL_CTL4res {
           nfsstat4                bcr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-33-3--DESCRIPTION">
18.33.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.33.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The BACKCHANNEL_CTL operation replaces the backchannel&#39;s callback program number and adds (not replaces) RPCSEC_GSS handles for use by the backchannel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BACKCHANNEL_CTL操作は、バックチャネルのコールバックプログラム番号を置き換え、バックチャネルで使用するRPCSEC_GSSハンドルを追加します（置き換えません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The arguments of the BACKCHANNEL_CTL call are a subset of the CREATE_SESSION parameters. In the arguments of BACKCHANNEL_CTL, the bca_cb_program field and bca_sec_parms fields correspond respectively to the csa_cb_program and csa_sec_parms fields of the arguments of CREATE_SESSION (Section 18.36).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BACKCHANNEL_CTL呼び出しの引数は、CREATE_SESSIONパラメータのサブセットです。 BACKCHANNEL_CTLの引数では、bca_cb_programフィールドとbca_sec_parmsフィールドは、それぞれCREATE_SESSIONの引数のcsa_cb_programフィールドとcsa_sec_parmsフィールドに対応しています（セクション18.36）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BACKCHANNEL_CTL MUST appear in a COMPOUND that starts with SEQUENCE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BACKCHANNEL_CTLは、SEQUENCEで始まるCOMPOUNDに出現する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the RPCSEC_GSS handle identified by gcbp_handle_from_server does not exist on the server, the server MUST return NFS4ERR_NOENT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
gcbp_handle_from_serverで識別されるRPCSEC_GSSハンドルがサーバーに存在しない場合、サーバーはNFS4ERR_NOENTを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an RPCSEC_GSS handle is using the SSV context (see Section 2.10.9), then because each SSV RPCSEC_GSS handle shares a common SSV GSS context, there are security considerations specific to this situation discussed in Section 2.10.10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSSハンドルがSSVコンテキストを使用している場合（セクション2.10.9を参照）、各SSV RPCSEC_GSSハンドルは共通のSSV GSSコンテキストを共有するため、セクション2.10.10で説明されているこの状況に固有のセキュリティに関する考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
18.34. Operation 41: BIND_CONN_TO_SESSION - Associate Connection with Session
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
18.34. 操作41：BIND_CONN_TO_SESSION-接続をセッションに関連付ける
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-34-1--ARGUMENT">
18.34.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.34.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum channel_dir_from_client4 {
    CDFC4_FORE             = 0x1,
    CDFC4_BACK             = 0x2,
    CDFC4_FORE_OR_BOTH     = 0x3,
    CDFC4_BACK_OR_BOTH     = 0x7
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct BIND_CONN_TO_SESSION4args {
    sessionid4     bctsa_sessid;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
channel_dir_from_client4 bctsa_dir;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
channel_dir_from_client4 bctsa_dir;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    bool           bctsa_use_conn_in_rdma_mode;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-34-2--RESULT">
18.34.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.34.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum channel_dir_from_server4 {
    CDFS4_FORE     = 0x1,
    CDFS4_BACK     = 0x2,
    CDFS4_BOTH     = 0x3
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct BIND_CONN_TO_SESSION4resok {
    sessionid4     bctsr_sessid;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
channel_dir_from_server4 bctsr_dir;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
channel_dir_from_server4 bctsr_dir;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    bool           bctsr_use_conn_in_rdma_mode;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
union BIND_CONN_TO_SESSION4res switch (nfsstat4 bctsr_status) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
union BIND_CONN_TO_SESSION4resスイッチ（nfsstat4 bctsr_status）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case NFS4_OK: BIND_CONN_TO_SESSION4resok bctsr_resok4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースNFS4_OK：BIND_CONN_TO_SESSION4resok bctsr_resok4;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    default:       void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-34-3--DESCRIPTION">
18.34.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.34.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BIND_CONN_TO_SESSION is used to associate additional connections with a session. It MUST be used on the connection being associated with the session. It MUST be the only operation in the COMPOUND procedure. If SP4_NONE (Section 18.35) state protection is used, any principal, security flavor, or RPCSEC_GSS context MAY be used to invoke the operation. If SP4_MACH_CRED is used, RPCSEC_GSS MUST be used with the integrity or privacy services, using the principal that created the client ID. If SP4_SSV is used, RPCSEC_GSS with the SSV GSS mechanism (Section 2.10.9) and integrity or privacy MUST be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BIND_CONN_TO_SESSIONは、追加の接続をセッションに関連付けるために使用されます。セッションに関連付けられている接続で使用する必要があります。 COMPOUNDプロシージャの唯一の操作である必要があります。 SP4_NONE（セクション18.35）状態保護が使用される場合、プリンシパル、セキュリティフレーバー、またはRPCSEC_GSSコンテキストを使用して操作を呼び出すことができます（MAY）。 SP4_MACH_CREDを使用する場合、RPCSEC_GSSは、クライアントIDを作成したプリンシパルを使用して、整合性またはプライバシーサービスと共に使用する必要があります。 SP4_SSVを使用する場合は、SSV GSSメカニズム（セクション2.10.9）と整合性またはプライバシーを備えたRPCSEC_GSSを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If, when the client ID was created, the client opted for SP4_NONE state protection, the client is not required to use BIND_CONN_TO_SESSION to associate the connection with the session, unless the client wishes to associate the connection with the backchannel. When SP4_NONE protection is used, simply sending a COMPOUND request with a SEQUENCE operation is sufficient to associate the connection with the session specified in SEQUENCE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントIDの作成時にクライアントがSP4_NONE状態の保護を選択した場合、クライアントが接続をバッ​​クチャネルに関連付けたい場合を除き、クライアントはBIND_CONN_TO_SESSIONを使用して接続をセッションに関連付ける必要はありません。 SP4_NONE保護が使用されている場合、SEQUENCE操作でCOMPOUND要求を送信するだけで、接続をSEQUENCEで指定されたセッションに関連付けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The field bctsa_dir indicates whether the client wants to associate the connection with the fore channel or the backchannel or both channels. The value CDFC4_FORE_OR_BOTH indicates that the client wants to associate the connection with both the fore channel and backchannel, but will accept the connection being associated to just the fore channel. The value CDFC4_BACK_OR_BOTH indicates that the client wants to associate with both the fore channel and backchannel, but will accept the connection being associated with just the backchannel. The server replies in bctsr_dir which channel(s) the connection is associated with. If the client specified CDFC4_FORE, the server MUST return CDFS4_FORE. If the client specified CDFC4_BACK, the server MUST return CDFS4_BACK. If the client specified CDFC4_FORE_OR_BOTH, the server MUST return CDFS4_FORE or CDFS4_BOTH. If the client specified CDFC4_BACK_OR_BOTH, the server MUST return CDFS4_BACK or CDFS4_BOTH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドbctsa_dirは、クライアントが接続をフォアチャネル、バックチャネル、または両方のチャネルに関連付けるかどうかを示します。値CDFC4_FORE_OR_BOTHは、クライアントが接続をフォアチャネルとバックチャネルの両方に関連付けたいが、フォアチャネルのみに関連付けられている接続を受け入れることを示します。値CDFC4_BACK_OR_BOTHは、クライアントがフォアチャネルとバックチャネルの両方に関連付けたいが、バックチャネルだけに関連付けられている接続を受け入れることを示します。サーバーは、接続が関連付けられているチャネルをbctsr_dirで応答します。クライアントがCDFC4_FOREを指定した場合、サーバーはCDFS4_FOREを返す必要があります。クライアントがCDFC4_BACKを指定した場合、サーバーはCDFS4_BACKを返す必要があります。クライアントがCDFC4_FORE_OR_BOTHを指定した場合、サーバーはCDFS4_FOREまたはCDFS4_BOTHを返す必要があります。クライアントがCDFC4_BACK_OR_BOTHを指定した場合、サーバーはCDFS4_BACKまたはCDFS4_BOTHを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See the CREATE_SESSION operation (Section 18.36), and the description of the argument csa_use_conn_in_rdma_mode to understand bctsa_use_conn_in_rdma_mode, and the description of csr_use_conn_in_rdma_mode to understand bctsr_use_conn_in_rdma_mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bctsa_use_conn_in_rdma_modeを理解するには、CREATE_SESSION操作（セクション18.36）と引数csa_use_conn_in_rdma_modeの説明、およびbctsr_use_conn_in_rdma_modeを理解するにはcsr_use_conn_in_rdma_modeの説明を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Invoking BIND_CONN_TO_SESSION on a connection already associated with the specified session has no effect, and the server MUST respond with NFS4_OK, unless the client is demanding changes to the set of channels the connection is associated with. If so, the server MUST return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたセッションにすでに関連付けられている接続でBIND_CONN_TO_SESSIONを呼び出しても効果はありません。クライアントが接続が関連付けられているチャネルのセットへの変更を要求していない限り、サーバーはNFS4_OKで応答する必要があります。その場合、サーバーはNFS4ERR_INVALを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-34-4--IMPLEMENTATION">
18.34.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.34.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a session&#39;s channel loses all connections, depending on the client ID&#39;s state protection and type of channel, the client might need to use BIND_CONN_TO_SESSION to associate a new connection. If the server restarted and does not keep the reply cache in stable storage, the server will not recognize the session ID. The client will ultimately have to invoke EXCHANGE_ID to create a new client ID and session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションのチャネルがすべての接続を失った場合、クライアントIDの状態保護とチャネルのタイプによっては、クライアントがBIND_CONN_TO_SESSIONを使用して新しい接続を関連付ける必要がある場合があります。サーバーが再起動し、応答キャッシュを安定したストレージに保持しない場合、サーバーはセッションIDを認識しません。クライアントは最終的にEXCHANGE_IDを呼び出して、新しいクライアントIDとセッションを作成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Suppose SP4_SSV state protection is being used, and BIND_CONN_TO_SESSION is among the operations included in the spo_must_enforce set when the client ID was created (Section 18.35). If so, there is an issue if SET_SSV is sent, no response is returned, and the last connection associated with the client ID drops. The client, per the sessions model, MUST retry the SET_SSV. But it needs a new connection to do so, and MUST associate that connection with the session via a BIND_CONN_TO_SESSION authenticated with the SSV GSS mechanism. The problem is that the RPCSEC_GSS message integrity codes use a subkey derived from the SSV as the key and the SSV may have changed. While there are multiple recovery strategies, a single, general strategy is described here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
SP4_SSV状態保護が使用されていて、BIND_CONN_TO_SESSIONが、クライアントIDの作成時に設定されたspo_must_enforceセットに含まれる操作の中にあるとします（セクション18.35）。その場合、SET_SSVが送信され、応答が返されず、クライアントIDに関連付けられた最後の接続がドロップすると、問題が発生します。クライアントは、セッションモデルごとに、SET_SSVを再試行する必要があります。ただし、そのためには新しい接続が必要であり、SSV GSSメカニズムで認証されたBIND_CONN_TO_SESSIONを介してその接続をセッションに関連付ける必要があります。問題は、RPCSEC_GSSメッセージ整合性コードがSSVから派生したサブキーをキーとして使用しており、SSVが変更されている可能性があることです。複数の回復戦略がありますが、ここでは単一の一般的な戦略について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client reconnects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントが再接続します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client assumes that the SET_SSV was executed, and so sends BIND_CONN_TO_SESSION with the subkey (derived from the new SSV, i.e., what SET_SSV would have set the SSV to) used as the key for the RPCSEC_GSS credential message integrity codes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは、SET_SSVが実行されたと想定し、RPCSEC_GSSクレデンシャルメッセージの整合性コードのキーとして使用されるサブキー（新しいSSVから派生したもの、つまりSET_SSVがSSVに設定したもの）をBIND_CONN_TO_SESSIONに送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the request succeeds, this means that the original attempted SET_SSV did execute successfully. The client re-sends the original SET_SSV, which the server will reply to via the reply cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o リクエストが成功した場合、これは、最初に試行されたSET_SSVが正常に実行されたことを意味します。クライアントは元のSET_SSVを再送信します。サーバーはこれに応答キャッシュを介して応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the server returns an RPC authentication error, this means that the server&#39;s current SSV was not changed (and the SET_SSV was likely not executed). The client then tries BIND_CONN_TO_SESSION with the subkey derived from the old SSV as the key for the RPCSEC_GSS message integrity codes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーがRPC認証エラーを返した場合、これはサーバーの現在のSSVが変更されていない（そしてSET_SSVが実行されなかった可能性が高い）ことを意味します。次にクライアントは、RPCSEC_GSSメッセージ整合性コードのキーとして古いSSVから派生したサブキーを使用してBIND_CONN_TO_SESSIONを試行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The attempted BIND_CONN_TO_SESSION with the old SSV should succeed. If so, the client re-sends the original SET_SSV. If the original SET_SSV was not executed, then the server executes it. If the original SET_SSV was executed but failed, the server will return the SET_SSV from the reply cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 古いSSVで試行されたBIND_CONN_TO_SESSIONは成功するはずです。その場合、クライアントは元のSET_SSVを再送信します。元のSET_SSVが実行されなかった場合、サーバーはそれを実行します。元のSET_SSVが実行されたが失敗した場合、サーバーは応答キャッシュからSET_SSVを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-35--Operation-42-EXCHANGEID---Instantiate-Client-ID">
18.35. Operation 42: EXCHANGE_ID - Instantiate Client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.35. 操作42：EXCHANGE_ID-クライアントIDをインスタンス化します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The EXCHANGE_ID exchanges long-hand client and server identifiers (owners), and creates a client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCHANGE_IDは、長いクライアントとサーバーの識別子（所有者）を交換し、クライアントIDを作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-35-1--ARGUMENT">
18.35.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.35.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const EXCHGID4_FLAG_SUPP_MOVED_REFER    = 0x00000001;
   const EXCHGID4_FLAG_SUPP_MOVED_MIGR     = 0x00000002;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const EXCHGID4_FLAG_BIND_PRINC_STATEID = 0x00000100;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const EXCHGID4_FLAG_BIND_PRINC_STATEID = 0x00000100;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const EXCHGID4_FLAG_USE_NON_PNFS        = 0x00010000;
   const EXCHGID4_FLAG_USE_PNFS_MDS        = 0x00020000;
   const EXCHGID4_FLAG_USE_PNFS_DS         = 0x00040000;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const EXCHGID4_FLAG_MASK_PNFS = 0x00070000;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const EXCHGID4_FLAG_MASK_PNFS = 0x00070000;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const EXCHGID4_FLAG_UPD_CONFIRMED_REC_A = 0x40000000;
   const EXCHGID4_FLAG_CONFIRMED_R         = 0x80000000;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct state_protect_ops4 {
           bitmap4 spo_must_enforce;
           bitmap4 spo_must_allow;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ssv_sp_parms4 {
           state_protect_ops4      ssp_ops;
           sec_oid4                ssp_hash_algs&lt;&gt;;
           sec_oid4                ssp_encr_algs&lt;&gt;;
           uint32_t                ssp_window;
           uint32_t                ssp_num_gss_handles;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum state_protect_how4 {
           SP4_NONE = 0,
           SP4_MACH_CRED = 1,
           SP4_SSV = 2
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union state_protect4_a switch(state_protect_how4 spa_how) {
           case SP4_NONE:
                   void;
           case SP4_MACH_CRED:
                   state_protect_ops4      spa_mach_ops;
           case SP4_SSV:
                   ssv_sp_parms4           spa_ssv_parms;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct EXCHANGE_ID4args {
           client_owner4           eia_clientowner;
           uint32_t                eia_flags;
           state_protect4_a        eia_state_protect;
           nfs_impl_id4            eia_client_impl_id&lt;1&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-35-2--RESULT">
18.35.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.35.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ssv_prot_info4 {
    state_protect_ops4     spi_ops;
    uint32_t               spi_hash_alg;
    uint32_t               spi_encr_alg;
    uint32_t               spi_ssv_len;
    uint32_t               spi_window;
    gsshandle4_t           spi_handles&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union state_protect4_r switch(state_protect_how4 spr_how) {
    case SP4_NONE:
            void;
    case SP4_MACH_CRED:
            state_protect_ops4     spr_mach_ops;
    case SP4_SSV:
            ssv_prot_info4         spr_ssv_info;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct EXCHANGE_ID4resok {
    clientid4        eir_clientid;
    sequenceid4      eir_sequenceid;
    uint32_t         eir_flags;
    state_protect4_r eir_state_protect;
    server_owner4    eir_server_owner;
    opaque           eir_server_scope&lt;NFS4_OPAQUE_LIMIT&gt;;
    nfs_impl_id4     eir_server_impl_id&lt;1&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union EXCHANGE_ID4res switch (nfsstat4 eir_status) {
   case NFS4_OK:
    EXCHANGE_ID4resok      eir_resok4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   default:
    void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-35-3--DESCRIPTION">
18.35.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.35.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client uses the EXCHANGE_ID operation to register a particular client owner with the server. The client ID returned from this operation will be necessary for requests that create state on the server and will serve as a parent object to sessions created by the client. In order to confirm the client ID it must first be used, along with the returned eir_sequenceid, as arguments to CREATE_SESSION. If the flag EXCHGID4_FLAG_CONFIRMED_R is set in the result, eir_flags, then eir_sequenceid MUST be ignored, as it has no relevancy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはEXCHANGE_ID操作を使用して、特定のクライアント所有者をサーバーに登録します。この操作から返されるクライアントIDは、サーバー上に状態を作成する要求に必要であり、クライアントによって作成されたセッションの親オブジェクトとして機能します。クライアントIDを確認するには、最初に、クライアントIDを、返されたeir_sequenceidとともに、CREATE_SESSIONの引数として使用する必要があります。フラグEXCHGID4_FLAG_CONFIRMED_Rが結果eir_flagsに設定されている場合、eir_sequenceidは関連性がないため無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCHANGE_ID MAY be sent in a COMPOUND procedure that starts with SEQUENCE. However, when a client communicates with a server for the first time, it will not have a session, so using SEQUENCE will not be possible. If EXCHANGE_ID is sent without a preceding SEQUENCE, then it MUST be the only operation in the COMPOUND procedure&#39;s request. If it is not, the server MUST return NFS4ERR_NOT_ONLY_OP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCHANGE_IDは、SEQUENCEで始まるCOMPOUNDプロシージャで送信される場合があります。ただし、クライアントが初めてサーバーと通信するときは、セッションがないため、SEQUENCEを使用できません。 EXCHANGE_IDが先行するSEQUENCEなしで送信された場合、それはCOMPOUNDプロシージャのリクエストにおける唯一の操作でなければなりません。そうでない場合、サーバーはNFS4ERR_NOT_ONLY_OPを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The eia_clientowner field is composed of a co_verifier field and a co_ownerid string. As noted in Section 2.4, the co_ownerid describes the client, and the co_verifier is the incarnation of the client. An EXCHANGE_ID sent with a new incarnation of the client will lead to the server removing lock state of the old incarnation. Whereas an EXCHANGE_ID sent with the current incarnation and co_ownerid will result in an error or an update of the client ID&#39;s properties, depending on the arguments to EXCHANGE_ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
eia_clientownerフィールドは、co_verifierフィールドとco_ownerid文字列で構成されています。 2.4項で説明したように、co_owneridはクライアントを記述し、co_verifierはクライアントの化身です。クライアントの新しいインカネーションで送信されたEXCHANGE_IDにより、サーバーは古いインカネーションのロック状態を削除します。一方、現在のインカネーションおよびco_owneridとともに送信されたEXCHANGE_IDは、EXCHANGE_IDへの引数に応じて、エラーまたはクライアントIDのプロパティの更新になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MUST NOT use the same client ID for two different incarnations of an eir_clientowner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、eir_clientownerの2つの異なるインカネーションに同じクライアントIDを使用してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to the client ID and sequence ID, the server returns a server owner (eir_server_owner) and server scope (eir_server_scope). The former field is used for network trunking as described in Section 2.10.5. The latter field is used to allow clients to determine when client IDs sent by one server may be recognized by another in the event of file system migration (see Section 11.7.7).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、クライアントIDとシーケンスIDに加えて、サーバー所有者（eir_server_owner）とサーバースコープ（eir_server_scope）を返します。セクション2.10.5で説明されているように、前者のフィールドはネットワークトランキングに使用されます。後者のフィールドは、ファイルシステムの移行時に、あるサーバーから送信されたクライアントIDが別のサーバーに認識される時期をクライアントが判断できるようにするために使用されます（セクション11.7.7を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client ID returned by EXCHANGE_ID is only unique relative to the combination of eir_server_owner.so_major_id and eir_server_scope. Thus, if two servers return the same client ID, the onus is on the client to distinguish the client IDs on the basis of eir_server_owner.so_major_id and eir_server_scope. In the event two different servers claim matching server_owner.so_major_id and eir_server_scope, the client can use the verification techniques discussed in Section 2.10.5 to determine if the servers are distinct. If they are distinct, then the client will need to note the destination network addresses of the connections used with each server, and use the network address as the final discriminator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCHANGE_IDによって返されるクライアントIDは、eir_server_owner.so_major_idとeir_server_scopeの組み合わせに対してのみ一意です。したがって、2つのサーバーが同じクライアントIDを返す場合、eir_server_owner.so_major_idとeir_server_scopeに基づいてクライアントIDを区別する責任はクライアントにあります。 2つの異なるサーバーが一致するserver_owner.so_major_idとeir_server_scopeを要求した場合、クライアントはセクション2.10.5で説明した検証手法を使用して、サーバーが異なるかどうかを判断できます。それらが異なる場合、クライアントは、各サーバーで使用される接続の宛先ネットワークアドレスを記録し、そのネットワークアドレスを最終的な識別子として使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server, as defined by the unique identity expressed in the so_major_id of the server owner and the server scope, needs to track several properties of each client ID it hands out. The properties apply to the client ID and all sessions associated with the client ID. The properties are derived from the arguments and results of EXCHANGE_ID. The client ID properties include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、サーバー所有者のso_major_idとサーバースコープで表される一意のIDで定義されているように、配布する各クライアントIDのいくつかのプロパティを追跡する必要があります。プロパティは、クライアントIDと、クライアントIDに関連付けられたすべてのセッションに適用されます。プロパティは、EXCHANGE_IDの引数と結果から導出されます。クライアントIDのプロパティは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The capabilities expressed by the following bits, which come from the results of EXCHANGE_ID:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o EXCHANGE_IDの結果から得られる次のビットで表される機能：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* EXCHGID4_FLAG_SUPP_MOVED_REFER
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* EXCHGID4_FLAG_SUPP_MOVED_REFER
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* EXCHGID4_FLAG_SUPP_MOVED_MIGR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* EXCHGID4_FLAG_SUPP_MOVED_MIGR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* EXCHGID4_FLAG_BIND_PRINC_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* EXCHGID4_FLAG_BIND_PRINC_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* EXCHGID4_FLAG_USE_NON_PNFS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* EXCHGID4_FLAG_USE_NON_PNFS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* EXCHGID4_FLAG_USE_PNFS_MDS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* EXCHGID4_FLAG_USE_PNFS_MDS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* EXCHGID4_FLAG_USE_PNFS_DS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* EXCHGID4_FLAG_USE_PNFS_DS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
These properties may be updated by subsequent EXCHANGE_ID requests on confirmed client IDs though the server MAY refuse to change them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
これらのプロパティは、確認済みのクライアントIDに対する後続のEXCHANGE_IDリクエストによって更新される場合がありますが、サーバーはプロパティの変更を拒否する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The state protection method used, one of SP4_NONE, SP4_MACH_CRED, or SP4_SSV, as set by the spa_how field of the arguments to EXCHANGE_ID. Once the client ID is confirmed, this property cannot be updated by subsequent EXCHANGE_ID requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 使用される状態保護方式。SP4_NONE、SP4_MACH_CRED、またはSP4_SSVのいずれかで、EXCHANGE_IDへの引数のspa_howフィールドで設定されます。クライアントIDが確​​認されると、このプロパティは後続のEXCHANGE_IDリクエストでは更新できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For SP4_MACH_CRED or SP4_SSV state protection:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SP4_MACH_CREDまたはSP4_SSV状態保護の場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The list of operations (spo_must_enforce) that MUST use the specified state protection. This list comes from the results of EXCHANGE_ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 指定された状態保護を使用する必要がある操作（spo_must_enforce）のリスト。このリストは、EXCHANGE_IDの結果に基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The list of operations (spo_must_allow) that MAY use the specified state protection. This list comes from the results of EXCHANGE_ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 指定された状態保護を使用してもよい操作のリスト（spo_must_allow）。このリストは、EXCHANGE_IDの結果に基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Once the client ID is confirmed, these properties cannot be updated by subsequent EXCHANGE_ID requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントIDが確​​認されると、これらのプロパティは後続のEXCHANGE_IDリクエストで更新できなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For SP4_SSV protection:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SP4_SSV保護の場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The OID of the hash algorithm. This property is represented by one of the algorithms in the ssp_hash_algs field of the EXCHANGE_ID arguments. Once the client ID is confirmed, this property cannot be updated by subsequent EXCHANGE_ID requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ハッシュアルゴリズムのOID。このプロパティは、EXCHANGE_ID引数のssp_hash_algsフィールドのアルゴリズムの1つによって表されます。クライアントIDが確​​認されると、このプロパティは後続のEXCHANGE_IDリクエストでは更新できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The OID of the encryption algorithm. This property is represented by one of the algorithms in the ssp_encr_algs field of the EXCHANGE_ID arguments. Once the client ID is confirmed, this property cannot be updated by subsequent EXCHANGE_ID requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 暗号化アルゴリズムのOID。このプロパティは、EXCHANGE_ID引数のssp_encr_algsフィールドのアルゴリズムの1つによって表されます。クライアントIDが確​​認されると、このプロパティは後続のEXCHANGE_IDリクエストでは更新できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The length of the SSV. This property is represented by the spi_ssv_len field in the EXCHANGE_ID results. Once the client ID is confirmed, this property cannot be updated by subsequent EXCHANGE_ID requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* SSVの長さ。このプロパティは、EXCHANGE_IDの結果のspi_ssv_lenフィールドで表されます。クライアントIDが確​​認されると、このプロパティは後続のEXCHANGE_IDリクエストでは更新できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
There are REQUIRED and RECOMMENDED relationships among the length of the key of the encryption algorithm (&#34;key length&#34;), the length of the output of hash algorithm (&#34;hash length&#34;), and the length of the SSV (&#34;SSV length&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
暗号化アルゴリズムのキーの長さ（「キーの長さ」）、ハッシュアルゴリズムの出力の長さ（「ハッシュの長さ」）、およびSSVの長さ（「SSV長さ」）の間には、REQUIREDおよびRECOMMENDEDの関係があります。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
+ key length MUST be &lt;= hash length. This is because the keys used for the encryption algorithm are actually subkeys derived from the SSV, and the derivation is via the hash algorithm. The selection of an encryption algorithm with a key length that exceeded the length of the output of the hash algorithm would require padding, and thus weaken the use of the encryption algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
+ キーの長さはハッシュ長以下でなければなりません。これは、暗号化アルゴリズムに使用されるキーが実際にはSSVから派生したサブキーであり、派生はハッシュアルゴリズムを介するためです。ハッシュアルゴリズムの出力の長さを超えるキー長の暗号化アルゴリズムを選択すると、パディングが必要になるため、暗号化アルゴリズムの使用が弱められます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
+ hash length SHOULD be &lt;= SSV length. This is because the SSV is a key used to derive subkeys via an HMAC, and it is recommended that the key used as input to an HMAC be at least as long as the length of the HMAC&#39;s hash algorithm&#39;s output (see Section 3 of RFC2104 [11]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
+ ハッシュの長さは、SSVの長さ以下でなければなりません。これは、SSVがHMAC経由でサブキーを導出するために使用されるキーであり、HMACへの入力として使用されるキーは、少なくともHMACのハッシュアルゴリズムの出力の長さと同じ長さにすることをお勧めします（RFC2104のセクション3を参照）。 11]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
+ key length SHOULD be &lt;= SSV length. This is a transitive result of the above two invariants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
+ キーの長さは、SSVの長さ以下でなければなりません。これは、上記の2つの不変条件の推移的な結果です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
+ key length SHOULD be &gt;= hash length / 2. This is because the subkey derivation is via an HMAC and it is recommended that if the HMAC has to be truncated, it should not be truncated to less than half the hash length (see Section 4 of RFC2104 [11]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
+ キーの長さは&gt; =ハッシュ長/ 2である必要があります。これは、サブキーの派生がHMACを介して行われるためであり、HMACを切り捨てる必要がある場合は、ハッシュ長の半分未満に切り詰めないでください（セクション4を参照）。 RFC2104 [11]の）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Number of concurrent versions of the SSV the client and server will support (Section 2.10.9). This property is represented by spi_window in the EXCHANGE_ID results. The property may be updated by subsequent EXCHANGE_ID requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントとサーバーがサポートするSSVの同時バージョンの数（セクション2.10.9）。このプロパティは、EXCHANGE_IDの結果ではspi_windowによって表されます。プロパティは、後続のEXCHANGE_IDリクエストによって更新される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client&#39;s implementation ID as represented by the eia_client_impl_id field of the arguments. The property may be updated by subsequent EXCHANGE_ID requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 引数のeia_client_impl_idフィールドで表されるクライアントの実装ID。プロパティは、後続のEXCHANGE_IDリクエストによって更新される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server&#39;s implementation ID as represented by the eir_server_impl_id field of the reply. The property may be updated by replies to subsequent EXCHANGE_ID requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 応答のeir_server_impl_idフィールドで表されるサーバーの実装ID。プロパティは、後続のEXCHANGE_IDリクエストへの応答によって更新される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The eia_flags passed as part of the arguments and the eir_flags results allow the client and server to inform each other of their capabilities as well as indicate how the client ID will be used. Whether a bit is set or cleared on the arguments&#39; flags does not force the server to set or clear the same bit on the results&#39; side. Bits not defined above cannot be set in the eia_flags field. If they are, the server MUST reject the operation with NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数の一部として渡されたeia_flagsとeir_flagsの結果により、クライアントとサーバーはお互いの機能を通知し、クライアントIDの使用方法を示すことができます。引数のフラグでビットが設定またはクリアされても、サーバーは結果の側で同じビットを設定またはクリアしません。上記で定義されていないビットは、eia_flagsフィールドに設定できません。そうである場合、サーバーはNFS4ERR_INVALを使用して操作を拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The EXCHGID4_FLAG_UPD_CONFIRMED_REC_A bit can only be set in eia_flags; it is always off in eir_flags. The EXCHGID4_FLAG_CONFIRMED_R bit can only be set in eir_flags; it is always off in eia_flags. If the server recognizes the co_ownerid and co_verifier as mapping to a confirmed client ID, it sets EXCHGID4_FLAG_CONFIRMED_R in eir_flags. The EXCHGID4_FLAG_CONFIRMED_R flag allows a client to tell if the client ID it is trying to create already exists and is confirmed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aビットはeia_flagsでのみ設定できます。 eir_flagsでは常にオフです。 EXCHGID4_FLAG_CONFIRMED_Rビットはeir_flagsでのみ設定できます。 eia_flagsでは常にオフです。サーバーがco_owneridとco_verifierを確認済みのクライアントIDへのマッピングとして認識すると、eir_flagsにEXCHGID4_FLAG_CONFIRMED_Rを設定します。 EXCHGID4_FLAG_CONFIRMED_Rフラグを使用すると、クライアントは、作成しようとしているクライアントIDがすでに存在し、確認されているかどうかを確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is set in eia_flags, this means that the client is attempting to update properties of an existing confirmed client ID (if the client wants to update properties of an unconfirmed client ID, it MUST NOT set EXCHGID4_FLAG_UPD_CONFIRMED_REC_A). If so, it is RECOMMENDED that the client send the update EXCHANGE_ID operation in the same COMPOUND as a SEQUENCE so that the EXCHANGE_ID is executed exactly once. Whether the client can update the properties of client ID depends on the state protection it selected when the client ID was created, and the principal and security flavor it uses when sending the EXCHANGE_ID request. The situations described in items 6, 7, 8, or 9 of the second numbered list of Section 18.35.4 will apply. Note that if the operation succeeds and returns a client ID that is already confirmed, the server MUST set the EXCHGID4_FLAG_CONFIRMED_R bit in eir_flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aがeia_flagsで設定されている場合、これはクライアントが既存の確認済みクライアントIDのプロパティを更新しようとしていることを意味します（クライアントが未確認のクライアントIDのプロパティを更新する場合、EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aを設定してはなりません）。その場合、EXCHANGE_IDが1回だけ実行されるように、クライアントがSEQUENCEと同じCOMPOUNDで更新EXCHANGE_ID操作を送信することをお勧めします。クライアントがクライアントIDのプロパティを更新できるかどうかは、クライアントIDの作成時に選択した状態保護と、EXCHANGE_IDリクエストを送信するときに使用するプリンシパルとセキュリティフレーバーによって異なります。セクション18.35.4の2番目の番号付きリストの項目6、7、8、または9で説明されている状況が適用されます。操作が成功し、確認済みのクライアントIDを返す場合、サーバーはeir_flagsにEXCHGID4_FLAG_CONFIRMED_Rビットを設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is not set in eia_flags, this means that the client is trying to establish a new client ID; it is attempting to trunk data communication to the server (Section 2.10.5); or it is attempting to update properties of an unconfirmed client ID. The situations described in items 1, 2, 3, 4, or 5 of the second numbered list of Section 18.35.4 will apply. Note that if the operation succeeds and returns a client ID that was previously confirmed, the server MUST set the EXCHGID4_FLAG_CONFIRMED_R bit in eir_flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aがeia_flagsに設定されていない場合、これはクライアントが新しいクライアントIDを確立しようとしていることを意味します。サーバーへのデータ通信をトランクしようとしています（セクション2.10.5）。または、未確認のクライアントIDのプロパティを更新しようとしています。セクション18.35.4の2番目の番号付きリストの項目1、2、3、4、または5で説明されている状況が適用されます。操作が成功し、以前に確認されたクライアントIDを返す場合、サーバーはeir_flagsにEXCHGID4_FLAG_CONFIRMED_Rビットを設定する必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the EXCHGID4_FLAG_SUPP_MOVED_REFER flag bit is set, the client indicates that it is capable of dealing with an NFS4ERR_MOVED error as part of a referral sequence. When this bit is not set, it is still legal for the server to perform a referral sequence. However, a server may use the fact that the client is incapable of correctly responding to a referral, by avoiding it for that particular client. It may, for instance, act as a proxy for that particular file system, at some cost in performance, although it is not obligated to do so. If the server will potentially perform a referral, it MUST set EXCHGID4_FLAG_SUPP_MOVED_REFER in eir_flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCHGID4_FLAG_SUPP_MOVED_REFERフラグビットが設定されている場合、クライアントは、NFS4ERR_MOVEDエラーを参照シーケンスの一部として処理できることを示します。このビットが設定されていなくても、サーバーが参照シーケンスを実行することは依然として正当です。ただし、サーバーは、特定のクライアントに対して紹介を回避することにより、クライアントが紹介に正しく応答できないという事実を利用する場合があります。たとえば、特定のファイルシステムのプロキシとして機能する場合がありますが、パフォーマンスは多少低下しますが、そうする義務はありません。サーバーが参照を実行する可能性がある場合は、eir_flagsにEXCHGID4_FLAG_SUPP_MOVED_REFERを設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When the EXCHGID4_FLAG_SUPP_MOVED_MIGR is set, the client indicates that it is capable of dealing with an NFS4ERR_MOVED error as part of a file system migration sequence. When this bit is not set, it is still legal for the server to indicate that a file system has moved, when this in fact happens. However, a server may use the fact that the client is incapable of correctly responding to a migration in its scheduling of file systems to migrate so as to avoid migration of file systems being actively used. It may also hide actual migrations from clients unable to deal with them by acting as a proxy for a migrated file system for particular clients, at some cost in performance, although it is not obligated to do so. If the server will potentially perform a migration, it MUST set EXCHGID4_FLAG_SUPP_MOVED_MIGR in eir_flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
EXCHGID4_FLAG_SUPP_MOVED_MIGRが設定されている場合、クライアントは、ファイルシステムの移行シーケンスの一部としてNFS4ERR_MOVEDエラーを処理できることを示します。このビットが設定されていない場合でも、実際にこれが発生したときに、サーバーがファイルシステムが移動したことを示すことは依然として正当です。ただし、サーバーは、ファイルシステムの移行がアクティブに使用されないように、ファイルシステムの移行スケジュールでクライアントが移行に正しく応答できないという事実を利用する場合があります。また、特定のクライアントの移行済みファイルシステムのプロキシとして機能することで、実際の移行を処理できないクライアントから隠すこともできますが、パフォーマンスは多少犠牲になりますが、そうする義務はありません。サーバーが移行を実行する可能性がある場合は、eir_flagsにEXCHGID4_FLAG_SUPP_MOVED_MIGRを設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When EXCHGID4_FLAG_BIND_PRINC_STATEID is set, the client indicates that it wants the server to bind the stateid to the principal. This means that when a principal creates a stateid, it has to be the one to use the stateid. If the server will perform binding, it will return EXCHGID4_FLAG_BIND_PRINC_STATEID. The server MAY return EXCHGID4_FLAG_BIND_PRINC_STATEID even if the client does not request it. If an update to the client ID changes the value of EXCHGID4_FLAG_BIND_PRINC_STATEID&#39;s client ID property, the effect applies only to new stateids. Existing stateids (and all stateids with the same &#34;other&#34; field) that were created with stateid to principal binding in force will continue to have binding in force. Existing stateids (and all stateids with the same &#34;other&#34; field) that were created with stateid to principal not in force will continue to have binding not in force.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCHGID4_FLAG_BIND_PRINC_STATEIDが設定されている場合、クライアントは、サーバーがstateidをプリンシパルにバインドすることを望んでいることを示します。これは、プリンシパルがstateidを作成するとき、stateidを使用するためにプリンシパルである必要があることを意味します。サーバーがバインドを実行する場合、EXCHGID4_FLAG_BIND_PRINC_STATEIDを返します。クライアントが要求しなくても、サーバーはEXCHGID4_FLAG_BIND_PRINC_STATEIDを返す場合があります。クライアントIDの更新によってEXCHGID4_FLAG_BIND_PRINC_STATEIDのクライアントIDプロパティの値が変更された場合、影響は新しい状態IDにのみ適用されます。有効なプリンシパルバインディングにstateidを使用して作成された既存の状態ID（および同じ「その他」フィールドを持つすべての状態ID）は、引き続き有効なバインディングを持ちます。有効ではないプリンシパルに対してstateidを使用して作成された既存のstateid（および同じ &#34;other&#34;フィールドを持つすべてのstateid）は、有効ではないバインディングが引き続き存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The EXCHGID4_FLAG_USE_NON_PNFS, EXCHGID4_FLAG_USE_PNFS_MDS, and EXCHGID4_FLAG_USE_PNFS_DS bits are described in Section 13.1 and convey roles the client ID is to be used for in a pNFS environment. The server MUST set one of the acceptable combinations of these bits (roles) in eir_flags, as specified in Section 13.1. Note that the same client owner/server owner pair can have multiple roles. Multiple roles can be associated with the same client ID or with different client IDs. Thus, if a client sends EXCHANGE_ID from the same client owner to the same server owner multiple times, but specifies different pNFS roles each time, the server might return different client IDs. Given that different pNFS roles might have different client IDs, the client may ask for different properties for each role/client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCHGID4_FLAG_USE_NON_PNFS、EXCHGID4_FLAG_USE_PNFS_MDS、およびEXCHGID4_FLAG_USE_PNFS_DSビットは、セクション13.1で説明されており、クライアントIDがpNFS環境で使用される役割を伝えます。サーバーは、セクション13.1で指定されているように、eir_flagsでこれらのビット（ロール）の許容可能な組み合わせの1つを設定する必要があります。同じクライアント所有者/サーバー所有者のペアが複数の役割を持つことができることに注意してください。複数のロールを同じクライアントIDまたは異なるクライアントIDに関連付けることができます。したがって、クライアントが同じクライアントの所有者から同じサーバーの所有者にEXCHANGE_IDを複数回送信しても、毎回異なるpNFSロールを指定すると、サーバーは異なるクライアントIDを返す可能性があります。異なるpNFSロールが異なるクライアントIDを持っている場合、クライアントはロール/クライアントIDごとに異なるプロパティを要求する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The spa_how field of the eia_state_protect field specifies how the client wants to protect its client, locking, and session states from unauthorized changes (Section 2.10.8.3):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
eia_state_protectフィールドのspa_howフィールドは、クライアントがクライアント、ロック、およびセッションの状態を無許可の変更から保護する方法を指定します（セクション2.10.8.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SP4_NONE. The client does not request the NFSv4.1 server to enforce state protection. The NFSv4.1 server MUST NOT enforce state protection for the returned client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SP4_NONE。クライアントは、NFSv4.1サーバーに状態保護を強制するように要求しません。 NFSv4.1サーバーは、返されたクライアントIDに状態保護を強制してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o SP4_MACH_CRED. If spa_how is SP4_MACH_CRED, then the client MUST send the EXCHANGE_ID request with RPCSEC_GSS as the security flavor, and with a service of RPC_GSS_SVC_INTEGRITY or RPC_GSS_SVC_PRIVACY. If SP4_MACH_CRED is specified, then the client wants to use an RPCSEC_GSS-based machine credential to protect its state. The server MUST note the principal the EXCHANGE_ID operation was sent with, and the GSS mechanism used. These notes collectively comprise the machine credential.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
o SP4_MACH_CRED。 spa_howがSP4_MACH_CREDの場合、クライアントはRPCSEC_GSSをセキュリティフレーバーとして、RPC_GSS_SVC_INTEGRITYまたはRPC_GSS_SVC_PRIVACYのサービスを使用してEXCHANGE_ID要求を送信する必要があります。 SP4_MACH_CREDが指定されている場合、クライアントはRPCSEC_GSSベースのマシン資格情報を使用してその状態を保護する必要があります。サーバーは、EXCHANGE_ID操作の送信に使用されたプリンシパルと、使用されたGSSメカニズムに注意する必要があります。これらのメモは集合的にマシンのクレデンシャルを構成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
After the client ID is confirmed, as long as the lease associated with the client ID is unexpired, a subsequent EXCHANGE_ID operation that uses the same eia_clientowner.co_owner as the first EXCHANGE_ID MUST also use the same machine credential as the first EXCHANGE_ID. The server returns the same client ID for the subsequent EXCHANGE_ID as that returned from the first EXCHANGE_ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントIDが確​​認された後、クライアントIDに関連付けられたリースが期限切れでない限り、最初のEXCHANGE_IDと同じeia_clientowner.co_ownerを使用する後続のEXCHANGE_ID操作でも、最初のEXCHANGE_IDと同じマシン認証情報を使用する必要があります。サーバーは、後続のEXCHANGE_IDに対して、最初のEXCHANGE_IDから返されたものと同じクライアントIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SP4_SSV. If spa_how is SP4_SSV, then the client MUST send the EXCHANGE_ID request with RPCSEC_GSS as the security flavor, and with a service of RPC_GSS_SVC_INTEGRITY or RPC_GSS_SVC_PRIVACY. If SP4_SSV is specified, then the client wants to use the SSV to protect its state. The server records the credential used in the request as the machine credential (as defined above) for the eia_clientowner.co_owner. The CREATE_SESSION operation that confirms the client ID MUST use the same machine credential.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SP4_SSV。 spa_howがSP4_SSVの場合、クライアントはRPCSEC_GSSをセキュリティフレーバーとして、RPC_GSS_SVC_INTEGRITYまたはRPC_GSS_SVC_PRIVACYのサービスを使用してEXCHANGE_ID要求を送信する必要があります。 SP4_SSVが指定されている場合、クライアントはSSVを使用してその状態を保護する必要があります。サーバーは、要求で使用された資格情報をeia_clientowner.co_ownerのマシン資格情報（上記で定義）として記録します。クライアントIDを確認するCREATE_SESSION操作では、同じマシン認証情報を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client specifies SP4_MACH_CRED or SP4_SSV, it also provides two lists of operations (each expressed as a bitmap). The first list is spo_must_enforce and consists of those operations the client MUST send (subject to the server confirming the list of operations in the result of EXCHANGE_ID) with the machine credential (if SP4_MACH_CRED protection is specified) or the SSV-based credential (if SP4_SSV protection is used). The client MUST send the operations with RPCSEC_GSS credentials that specify the RPC_GSS_SVC_INTEGRITY or RPC_GSS_SVC_PRIVACY security service. Typically, the first list of operations includes EXCHANGE_ID, CREATE_SESSION, DELEGPURGE, DESTROY_SESSION, BIND_CONN_TO_SESSION, and DESTROY_CLIENTID. The client SHOULD NOT specify in this list any operations that require a filehandle because the server&#39;s access policies MAY conflict with the client&#39;s choice, and thus the client would then be unable to access a subset of the server&#39;s namespace.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがSP4_MACH_CREDまたはSP4_SSVを指定すると、2つの操作のリストも提供されます（それぞれがビットマップとして表現されます）。最初のリストはspo_must_enforceであり、マシンの資格情報（SP4_MACH_CRED保護が指定されている場合）またはSSVベースの資格情報（SP4_SSVの場合）を使用してクライアントが送信する必要がある操作（EXCHANGE_IDの結果で操作のリストを確認するサーバーに従う）で構成されます保護が使用されます）。クライアントは、RPC_GSS_SVC_INTEGRITYまたはRPC_GSS_SVC_PRIVACYセキュリティサービスを指定するRPCSEC_GSS資格情報を使用して操作を送信する必要があります。通常、最初の操作リストには、EXCHANGE_ID、CREATE_SESSION、DELEGPURGE、DESTROY_SESSION、BIND_CONN_TO_SESSION、およびDESTROY_CLIENTIDが含まれます。サーバーのアクセスポリシーはクライアントの選択と競合する可能性があるため、クライアントはこのリストでファイルハンドルを必要とする操作を指定してはなりません。したがって、クライアントはサーバーの名前空間のサブセットにアクセスできなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if SP4_SSV protection is specified, and the client indicates that CREATE_SESSION must be protected with SP4_SSV, because the SSV cannot exist without a confirmed client ID, the first CREATE_SESSION MUST instead be sent using the machine credential, and the server MUST accept the machine credential.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SP4_SSV保護が指定されていて、クライアントがCREATE_SESSIONをSP4_SSVで保護する必要があることを示している場合、SSVは確認済みのクライアントIDなしでは存在できないため、代わりに最初のCREATE_SESSIONをマシンの資格情報を使用して送信し、サーバーがマシンを受け入れる必要があることに注意してください。資格。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 There is a corresponding result, also called spo_must_enforce, of the operations for which the server will require SP4_MACH_CRED or SP4_SSV protection. Normally, the server&#39;s result equals the client&#39;s argument, but the result MAY be different. If the client requests one or more operations in the set { EXCHANGE_ID, CREATE_SESSION, DELEGPURGE, DESTROY_SESSION, BIND_CONN_TO_SESSION, DESTROY_CLIENTID }, then the result spo_must_enforce MUST include the operations the client requested from that set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーがSP4_MACH_CREDまたはSP4_SSV保護を必要とする操作の対応する結果（spo_must_enforceとも呼ばれます）があります。通常、サーバーの結果はクライアントの引数と同じですが、結果は異なる場合があります。クライアントがセット{EXCHANGE_ID、CREATE_SESSION、DELEGPURGE、DESTROY_SESSION、BIND_CONN_TO_SESSION、DESTROY_CLIENTID}の1つ以上の操作を要求する場合、結果のspo_must_enforceはそのセットからクライアントが要求した操作を含まなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If spo_must_enforce in the results has BIND_CONN_TO_SESSION set, then connection binding enforcement is enabled, and the client MUST use the machine (if SP4_MACH_CRED protection is used) or SSV (if SP4_SSV protection is used) credential on calls to BIND_CONN_TO_SESSION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果のspo_must_enforceにBIND_CONN_TO_SESSIONが設定されている場合、接続バインディングの強制が有効になり、クライアントはマシン（SP4_MACH_CRED保護が使用されている場合）またはSSV（SP4_SSV保護が使用されている場合）の資格情報をBIND_CONN_TO_SESSIONへの呼び出しに使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second list is spo_must_allow and consists of those operations the client wants to have the option of sending with the machine credential or the SSV-based credential, even if the object the operations are performed on is not owned by the machine or SSV credential.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目のリストはspo_must_allowであり、操作が実行されるオブジェクトがマシンまたはSSV資格情報によって所有されていない場合でも、クライアントがマシン資格情報またはSSVベースの資格情報で送信するオプションを必要とする操作で構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The corresponding result, also called spo_must_allow, consists of the operations the server will allow the client to use SP4_SSV or SP4_MACH_CRED credentials with. Normally, the server&#39;s result equals the client&#39;s argument, but the result MAY be different.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対応する結果はspo_must_allowとも呼ばれ、サーバーがクライアントにSP4_SSVまたはSP4_MACH_CRED資格情報を使用できるようにする操作で構成されます。通常、サーバーの結果はクライアントの引数と同じですが、結果は異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of spo_must_allow is to allow clients to solve the following conundrum. Suppose the client ID is confirmed with EXCHGID4_FLAG_BIND_PRINC_STATEID, and it calls OPEN with the RPCSEC_GSS credentials of a normal user. Now suppose the user&#39;s credentials expire, and cannot be renewed (e.g., a Kerberos ticket granting ticket expires, and the user has logged off and will not be acquiring a new ticket granting ticket). The client will be unable to send CLOSE without the user&#39;s credentials, which is to say the client has to either leave the state on the server or re-send EXCHANGE_ID with a new verifier to clear all state, that is, unless the client includes CLOSE on the list of operations in spo_must_allow and the server agrees.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
spo_must_allowの目的は、クライアントが次の難問を解決できるようにすることです。クライアントIDがEXCHGID4_FLAG_BIND_PRINC_STATEIDで確認され、通常のユーザーのRPCSEC_GSS資格情報でOPENを呼び出すとします。ここで、ユーザーの資格情報が期限切れになり、更新できないと仮定します（たとえば、Kerberosチケット認可チケットが期限切れになり、ユーザーはログオフして新しいチケット認可チケットを取得しなくなります）。クライアントは、ユーザーの資格情報なしではCLOSEを送信できません。つまり、クライアントはサーバー上に状態を残すか、新しいベリファイアを使用してEXCHANGE_IDを再送信して、すべての状態をクリアする必要があります。 spo_must_allowの操作のリストにあり、サーバーは同意します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SP4_SSV protection parameters also have:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SP4_SSV保護パラメーターには、次のものもあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ssp_hash_algs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ssp_hash_algs：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 This is the set of algorithms the client supports for the purpose of computing the digests needed for the internal SSV GSS mechanism and for the SET_SSV operation. Each algorithm is specified as an object identifier (OID). The REQUIRED algorithms for a server are id-sha1, id-sha224, id-sha256, id-sha384, and id-sha512 [28]. The algorithm the server selects among the set is indicated in spi_hash_alg, a field of spr_ssv_prot_info. The field spi_hash_alg is an index into the array ssp_hash_algs. If the server does not support any of the offered algorithms, it returns NFS4ERR_HASH_ALG_UNSUPP. If ssp_hash_algs is empty, the server MUST return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
これは、内部SSV GSSメカニズムとSET_SSV操作に必要なダイジェストを計算するためにクライアントがサポートする一連のアルゴリズムです。各アルゴリズムは、オブジェクト識別子（OID）として指定されます。サーバーに必要なアルゴリズムは、id-sha1、id-sha224、id-sha256、id-sha384、id-sha512です[28]。サーバーがセットから選択するアルゴリズムは、spr_ssv_prot_infoのフィールドであるspi_hash_algに示されています。フィールドspi_hash_algは、配列ssp_hash_algsへのインデックスです。サーバーが提供されたアルゴリズムのいずれもサポートしていない場合、サーバーはNFS4ERR_HASH_ALG_UNSUPPを返します。 ssp_hash_algsが空の場合、サーバーはNFS4ERR_INVALを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ssp_encr_algs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ssp_encr_algs：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This is the set of algorithms the client supports for the purpose of providing privacy protection for the internal SSV GSS mechanism. Each algorithm is specified as an OID. The REQUIRED algorithm for a server is id-aes256-CBC. The RECOMMENDED algorithms are id-aes192-CBC and id-aes128-CBC [29]. The selected algorithm is returned in spi_encr_alg, an index into ssp_encr_algs. If the server does not support any of the offered algorithms, it returns NFS4ERR_ENCR_ALG_UNSUPP. If ssp_encr_algs is empty, the server MUST return NFS4ERR_INVAL. Note that due to previously stated requirements and recommendations on the relationships between key length and hash length, some combinations of RECOMMENDED and REQUIRED encryption algorithm and hash algorithm either SHOULD NOT or MUST NOT be used. Table 12 summarizes the illegal and discouraged combinations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
これは、内部SSV GSSメカニズムにプライバシー保護を提供する目的でクライアントがサポートするアルゴリズムのセットです。各アルゴリズムはOIDとして指定されます。サーバーに必要なアルゴリズムはid-aes256-CBCです。推奨されるアルゴリズムは、id-aes192-CBCおよびid-aes128-CBC [29]です。選択したアルゴリズムは、ssp_encr_algsへのインデックスであるspi_encr_algに返されます。サーバーが提供されたアルゴリズムのいずれもサポートしていない場合、サーバーはNFS4ERR_ENCR_ALG_UNSUPPを返します。 ssp_encr_algsが空の場合、サーバーはNFS4ERR_INVALを返す必要があります。キーの長さとハッシュの長さの関係に関する前述の要件と推奨事項により、RECOMMENDEDおよびREQUIRED暗号化アルゴリズムとハッシュアルゴリズムの一部の組み合わせを使用する必要があるか、使用してはならないことに注意してください。表12は、違法および推奨されない組み合わせをまとめたものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ssp_window:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ssp_window：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This is the number of SSV versions the client wants the server to maintain (i.e., each successful call to SET_SSV produces a new version of the SSV). If ssp_window is zero, the server MUST return NFS4ERR_INVAL. The server responds with spi_window, which MUST NOT exceed ssp_window, and MUST be at least one. Any requests on the backchannel or fore channel that are using a version of the SSV that is outside the window will fail with an ONC RPC authentication error, and the requester will have to retry them with the same slot ID and sequence ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
これは、クライアントがサーバーに維持させたいSSVバージョンの数です（つまり、SET_SSVへの呼び出しが成功するたびに、SSVの新しいバージョンが生成されます）。 ssp_windowがゼロの場合、サーバーはNFS4ERR_INVALを返す必要があります。サーバーはspi_windowで応答します。これはssp_windowを超えてはならず（MUST）、少なくとも1つでなければなりません（MUST）。ウィンドウ外にあるバージョンのSSVを使用しているバックチャネルまたはフォアチャネルでの要求は、ONC RPC認証エラーで失敗し、リクエスターは同じスロットIDとシーケンスIDで再試行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ssp_num_gss_handles:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ssp_num_gss_handles：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This is the number of RPCSEC_GSS handles the server should create that are based on the GSS SSV mechanism (Section 2.10.9). It is not the total number of RPCSEC_GSS handles for the client ID. Indeed, subsequent calls to EXCHANGE_ID will add RPCSEC_GSS handles. The server responds with a list of handles in spi_handles. If the client asks for at least one handle and the server cannot create it, the server MUST return an error. The handles in spi_handles are not available for use until the client ID is confirmed, which could be immediately if EXCHANGE_ID returns EXCHGID4_FLAG_CONFIRMED_R, or upon successful confirmation from CREATE_SESSION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
これは、GSS SSVメカニズム（セクション2.10.9）に基づいてサーバーが作成する必要があるRPCSEC_GSSハンドルの数です。これは、クライアントIDのRPCSEC_GSSハンドルの総数ではありません。実際、以降のEXCHANGE_IDの呼び出しでは、RPCSEC_GSSハンドルが追加されます。サーバーは、spi_handles内のハンドルのリストで応答します。クライアントが少なくとも1つのハンドルを要求し、サーバーがそれを作成できない場合、サーバーはエラーを返さなければなりません（MUST）。 spi_handlesのハンドルは、クライアントIDが確​​認されるまで使用できません。これは、EXCHANGE_IDがEXCHGID4_FLAG_CONFIRMED_Rを返した場合、またはCREATE_SESSIONからの確認が成功した場合にすぐに発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
While a client ID can span all the connections that are connected to a server sharing the same eir_server_owner.so_major_id, the RPCSEC_GSS handles returned in spi_handles can only be used on connections connected to a server that returns the same the eir_server_owner.so_major_id and eir_server_owner.so_minor_id on each connection. It is permissible for the client to set ssp_num_gss_handles to zero; the client can create more handles with another EXCHANGE_ID call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントIDは、同じeir_server_owner.so_major_idを共有するサーバーに接続されているすべての接続にまたがることができますが、spi_handlesで返されるRPCSEC_GSSハンドルは、同じeir_server_owner.so_major_idおよびeir_server_owner.so_minor_idを返すサーバーに接続されている接続でのみ使用できます各接続で。クライアントがssp_num_gss_handlesをゼロに設定することは許可されています。クライアントは、別のEXCHANGE_ID呼び出しでさらにハンドルを作成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Because each SSV RPCSEC_GSS handle shares a common SSV GSS context, there are security considerations specific to this situation discussed in Section 2.10.10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
各SSV RPCSEC_GSSハンドルは共通のSSV GSSコンテキストを共有するため、セクション2.10.10で説明されているこの状況に固有のセキュリティに関する考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The seq_window (see Section 5.2.3.1 of RFC2203 [4]) of each RPCSEC_GSS handle in spi_handle MUST be the same as the seq_window of the RPCSEC_GSS handle used for the credential of the RPC request that the EXCHANGE_ID request was sent with.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
spi_handleの各RPCSEC_GSSハンドルのseq_window（RFC2203 [4]のセクション5.2.3.1を参照）は、EXCHANGE_IDリクエストが送信されたRPCリクエストの資格情報に使用されるRPCSEC_GSSハンドルのseq_windowと同じである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------------+----------------------+------------------------+
   | Encryption        | MUST NOT be combined | SHOULD NOT be combined |
   | Algorithm         | with                 | with                   |
   +-------------------+----------------------+------------------------+
   | id-aes128-CBC     |                      | id-sha384, id-sha512   |
   | id-aes192-CBC     | id-sha1              | id-sha512              |
   | id-aes256-CBC     | id-sha1, id-sha224   |                        |
   +-------------------+----------------------+------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Table 12
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
表12
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The arguments include an array of up to one element in length called eia_client_impl_id. If eia_client_impl_id is present, it contains the information identifying the implementation of the client. Similarly, the results include an array of up to one element in length called eir_server_impl_id that identifies the implementation of the server. Servers MUST accept a zero-length eia_client_impl_id array, and clients MUST accept a zero-length eir_server_impl_id array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数には、eia_client_impl_idと呼ばれる長さが最大1つの要素の配列が含まれます。 eia_client_impl_idが存在する場合は、クライアントの実装を識別する情報が含まれています。同様に、結果には、サーバーの実装を識別するeir_server_impl_idと呼ばれる長さが最大1つの要素の配列が含まれます。サーバーは長さがゼロのeia_client_impl_id配列を受け入れる必要があり、クライアントは長さがゼロのeir_server_impl_id配列を受け入れる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example use for implementation identifiers would be diagnostic software that extracts this information in an attempt to identify interoperability problems, performance workload behaviors, or general usage statistics. Since the intent of having access to this information is for planning or general diagnosis only, the client and server MUST NOT interpret this implementation identity information in a way that affects interoperational behavior of the implementation. The reason is that if clients and servers did such a thing, they might use fewer capabilities of the protocol than the peer can support, or the client and server might refuse to interoperate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装識別子の使用例は、相互運用性の問題、パフォーマンスワークロードの動作、または一般的な使用統計を特定するためにこの情報を抽出する診断ソフトウェアです。この情報にアクセスする意図は、計画または一般的な診断のみを目的としているため、クライアントとサーバーは、実装の相互運用動作に影響を与えるような方法でこの実装ID情報を解釈してはなりません。その理由は、クライアントとサーバーがそのようなことをした場合、ピアがサポートできるよりもプロトコルの機能が少なくなるか、クライアントとサーバーが相互運用を拒否する可能性があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because it is possible that some implementations will violate the protocol specification and interpret the identity information, implementations MUST allow the users of the NFSv4 client and server to set the contents of the sent nfs_impl_id structure to any value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部の実装はプロトコル仕様に違反し、ID情報を解釈する可能性があるため、実装では、NFSv4クライアントおよびサーバーのユーザーが送信されたnfs_impl_id構造の内容を任意の値に設定できるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-35-4--IMPLEMENTATION">
18.35.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.35.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server&#39;s client record is a 5-tuple:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのクライアントレコードは5タプルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. co_ownerid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. co_ownerid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The client identifier string, from the eia_clientowner structure of the EXCHANGE_ID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
EXCHANGE_ID4args構造のeia_clientowner構造からのクライアントIDストリング。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. co_verifier:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. co_verifier：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
A client-specific value used to indicate incarnations (where a client restart represents a new incarnation), from the eia_clientowner structure of the EXCHANGE_ID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
EXCHANGE_ID4args構造体のeia_clientowner構造体から、インカネーション（クライアントの再起動が新しいインカネーションを表す場合）を示すために使用されるクライアント固有の値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. principal:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 主要な：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The principal that was defined in the RPC header&#39;s credential and/or verifier at the time the client record was established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
クライアントレコードが確立されたときにRPCヘッダーの資格情報または検証者、あるいはその両方で定義されたプリンシパル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. client ID:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. クライアントID：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The shorthand client identifier, generated by the server and returned via the eir_clientid field in the EXCHANGE_ID4resok structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
サーバーによって生成され、EXCHANGE_ID4resok構造体のeir_clientidフィールドを介して返される短縮クライアントID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. confirmed:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 確認済み：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
A private field on the server indicating whether or not a client record has been confirmed. A client record is confirmed if there has been a successful CREATE_SESSION operation to confirm it. Otherwise, it is unconfirmed. An unconfirmed record is established by an EXCHANGE_ID call. Any unconfirmed record that is not confirmed within a lease period SHOULD be removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
クライアントレコードが確認されたかどうかを示すサーバー上のプライベートフィールド。確認のためのCREATE_SESSION操作が成功した場合、クライアントレコードが確認されます。それ以外の場合は未確認です。未確認のレコードは、EXCHANGE_ID呼び出しによって確立されます。リース期間内に確認されない未確認のレコードは削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following identifiers represent special values for the fields in the records.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の識別子は、レコード内のフィールドの特別な値を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ownerid_arg:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ownerid_arg：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The value of the eia_clientowner.co_ownerid subfield of the EXCHANGE_ID4args structure of the current request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
現在のリクエストのEXCHANGE_ID4args構造のeia_clientowner.co_owneridサブフィールドの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
verifier_arg:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
verifier_arg：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The value of the eia_clientowner.co_verifier subfield of the EXCHANGE_ID4args structure of the current request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
現在のリクエストのEXCHANGE_ID4args構造のeia_clientowner.co_verifierサブフィールドの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
old_verifier_arg:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
old_verifier_arg：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A value of the eia_clientowner.co_verifier field of a client record received in a previous request; this is distinct from verifier_arg.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
前のリクエストで受信したクライアントレコードのeia_clientowner.co_verifierフィールドの値。これは、verifier_argとは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
principal_arg:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
principal_arg：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The value of the RPCSEC_GSS principal for the current request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
現在の要求のRPCSEC_GSSプリンシパルの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
old_principal_arg:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
old_principal_arg：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A value of the principal of a client record as defined by the RPC header&#39;s credential or verifier of a previous request. This is distinct from principal_arg.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RPCヘッダーの資格情報または前の要求のベリファイアによって定義されたクライアントレコードのプリンシパルの値。これは、principal_argとは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientid_ret:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientid_ret：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The value of the eir_clientid field the server will return in the EXCHANGE_ID4resok structure for the current request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーが現在のリクエストのEXCHANGE_ID4resok構造体で返すeir_clientidフィールドの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
old_clientid_ret:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
old_clientid_ret：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The value of the eir_clientid field the server returned in the EXCHANGE_ID4resok structure for a previous request. This is distinct from clientid_ret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーが前のリクエストのEXCHANGE_ID4resok構造体で返したeir_clientidフィールドの値。これはclientid_retとは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
confirmed:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認済み：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The client ID has been confirmed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントIDが確​​認されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unconfirmed:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未確認：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The client ID has not been confirmed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントIDは確認されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since EXCHANGE_ID is a non-idempotent operation, we must consider the possibility that retries occur as a result of a client restart, network partition, malfunctioning router, etc. Retries are identified by the value of the eia_clientowner field of EXCHANGE_ID4args, and the method for dealing with them is outlined in the scenarios below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCHANGE_IDはべき等ではない操作であるため、クライアントの再起動、ネットワークパーティション、ルーターの誤動作などの結果として再試行が発生する可能性を考慮する必要があります。再試行は、EXCHANGE_ID4argsのeia_clientownerフィールドの値と、それらの扱いについては、以下のシナリオで概説されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The scenarios are described in terms of the client record(s) a server has for a given co_ownerid. Note that if the client ID was created specifying SP4_SSV state protection and EXCHANGE_ID as the one of the operations in spo_must_allow, then the server MUST authorize EXCHANGE_IDs with the SSV principal in addition to the principal that created the client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シナリオは、サーバーが特定のco_owneridに対して持つクライアントレコードの観点から説明されています。 SP4_SSV状態保護とEXCHANGE_IDをspo_must_allowの操作の1つとして指定してクライアントIDを作成した場合、サーバーはクライアントIDを作成したプリンシパルに加えてSSVプリンシパルでEXCHANGE_IDを承認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. New Owner ID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 新しい所有者ID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
If the server has no client records with eia_clientowner.co_ownerid matching ownerid_arg, and EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is not set in the EXCHANGE_ID, then a new shorthand client ID (let us call it clientid_ret) is generated, and the following unconfirmed record is added to the server&#39;s state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
サーバーに、eia_clientowner.co_owneridがownerid_argと一致するクライアントレコードがなく、EXCHGID4_FLAG_UPD_CONFIRMED_REC_AがEXCHANGE_IDに設定されていない場合、新しい短縮形のクライアントID（clientid_retと呼ぶ）が生成され、次の未確認のレコードがサーバーの状態に追加されます。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, unconfirmed }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ownerid_arg、verifier_arg、principal_arg、clientid_ret、未確認}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Subsequently, the server returns clientid_ret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
その後、サーバーはclientid_retを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Non-Update on Existing Client ID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 既存のクライアントIDの更新なし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
If the server has the following confirmed record, and the request does not have EXCHGID4_FLAG_UPD_CONFIRMED_REC_A set, then the request is the result of a retried request due to a faulty router or lost connection, or the client is trying to determine if it can perform trunking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
サーバーに次の確認済みレコードがあり、リクエストにEXCHGID4_FLAG_UPD_CONFIRMED_REC_Aが設定されていない場合、リクエストは、ルーターの不良または接続の切断が原因で再試行されたリクエストの結果であるか、クライアントがトランキングを実行できるかどうかを判断しようとしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, confirmed }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ownerid_arg、verifier_arg、principal_arg、clientid_ret、確認済み}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Since the record has been confirmed, the client must have received the server&#39;s reply from the initial EXCHANGE_ID request. Since the server has a confirmed record, and since EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is not set, with the possible exception of eir_server_owner.so_minor_id, the server returns the same result it did when the client ID&#39;s properties were last updated (or if never updated, the result when the client ID was created). The confirmed record is unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
レコードが確認されているため、クライアントは最初のEXCHANGE_IDリクエストからサーバーの応答を受信して​​いる必要があります。サーバーには確認済みのレコードがあり、EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aが設定されていないため、eir_server_owner.so_minor_idの例外が発生する可能性があるため、サーバーはクライアントIDのプロパティが最後に更新されたときと同じ結果を返します（または、更新されていない場合は、クライアントIDが作成されました）。確認済みのレコードは変更されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Client Collision
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. クライアントの衝突
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is not set, and if the server has the following confirmed record, then this request is likely the result of a chance collision between the values of the eia_clientowner.co_ownerid subfield of EXCHANGE_ID4args for two different clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aが設定されておらず、サーバーに次の確認済みレコードがある場合、この要求は、2つの異なるクライアントのEXCHANGE_ID4argsのeia_clientowner.co_owneridサブフィールドの値が衝突する可能性があるためと考えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ ownerid_arg, *, old_principal_arg, old_clientid_ret, confirmed }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ownerid_arg、*、old_principal_arg、old_clientid_ret、確認済み}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
If there is currently no state associated with old_clientid_ret, or if there is state but the lease has expired, then this case is effectively equivalent to the New Owner ID case of Paragraph 1. The confirmed record is deleted, the old_clientid_ret and its lock state are deleted, a new shorthand client ID is generated, and the following unconfirmed record is added to the server&#39;s state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
old_clientid_retに関連付けられた状態が現在ない場合、または状態はあるがリースの有効期限が切れている場合、このケースは、段落1の新規所有者IDのケースと実質的に同等です。確認されたレコードが削除され、old_clientid_retとそのロック状態は削除されると、新しい短縮クライアントIDが生成され、次の未確認のレコードがサーバーの状態に追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, unconfirmed }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ownerid_arg、verifier_arg、principal_arg、clientid_ret、未確認}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Subsequently, the server returns clientid_ret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
その後、サーバーはclientid_retを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
If old_clientid_ret has an unexpired lease with state, then no state of old_clientid_ret is changed or deleted. The server returns NFS4ERR_CLID_INUSE to indicate that the client should retry with a different value for the eia_clientowner.co_ownerid subfield of EXCHANGE_ID4args. The client record is not changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
old_clientid_retに有効期限が切れていない状態のリースがある場合、old_clientid_retの状態は変更または削除されません。サーバーはNFS4ERR_CLID_INUSEを返し、クライアントがEXCHANGE_ID4argsのeia_clientowner.co_owneridサブフィールドに異なる値で再試行する必要があることを示します。クライアントレコードは変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Replacement of Unconfirmed Record
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 未確認レコードの置き換え
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
If the EXCHGID4_FLAG_UPD_CONFIRMED_REC_A flag is not set, and the server has the following unconfirmed record, then the client is attempting EXCHANGE_ID again on an unconfirmed client ID, perhaps due to a retry, a client restart before client ID confirmation (i.e., before CREATE_SESSION was called), or some other reason.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aフラグが設定されておらず、サーバーに次の未確認のレコードがある場合、クライアントは未確認のクライアントIDでEXCHANGE_IDを再試行しています。 ）、またはその他の理由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          { ownerid_arg, *, *, old_clientid_ret, unconfirmed }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
It is possible that the properties of old_clientid_ret are different than those specified in the current EXCHANGE_ID. Whether or not the properties are being updated, to eliminate ambiguity, the server deletes the unconfirmed record, generates a new client ID (clientid_ret), and establishes the following unconfirmed record:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
old_clientid_retのプロパティが、現在のEXCHANGE_IDで指定されているプロパティと異なる可能性があります。プロパティが更新されているかどうかにかかわらず、あいまいさを排除するために、サーバーは未確認のレコードを削除し、新しいクライアントID（clientid_ret）を生成して、次の未確認のレコードを確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, unconfirmed }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ownerid_arg、verifier_arg、principal_arg、clientid_ret、未確認}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Client Restart
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. クライアントの再起動
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is not set, and if the server has the following confirmed client record, then this request is likely from a previously confirmed client that has restarted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aが設定されておらず、サーバーに次の確認済みクライアントレコードがある場合、このリクエストは、再起動された以前に確認されたクライアントからの可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ ownerid_arg, old_verifier_arg, principal_arg, old_clientid_ret, confirmed }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ownerid_arg、old_verifier_arg、principal_arg、old_clientid_ret、確認済み}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Since the previous incarnation of the same client will no longer be making requests, once the new client ID is confirmed by CREATE_SESSION, byte-range locks and share reservations should be released immediately rather than forcing the new incarnation to wait for the lease time on the previous incarnation to expire. Furthermore, session state should be removed since if the client had maintained that information across restart, this request would not have been sent. If the server supports neither the CLAIM_DELEGATE_PREV nor CLAIM_DELEG_PREV_FH claim types, associated delegations should be purged as well; otherwise, delegations are retained and recovery proceeds according to Section 10.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
同じクライアントの以前のインカネーションはリクエストを作成しなくなるため、新しいクライアントIDがCREATE_SESSIONによって確認されたら、新しいインカネーションがリース時間を待つのではなく、バイト範囲のロックと共有の予約をすぐに解放する必要があります。期限切れになる前の化身。さらに、クライアントが再起動時にその情報を保持していた場合、この要求は送信されなかったため、セッション状態を削除する必要があります。サーバーがCLAIM_DELEGATE_PREVクレームタイプもCLAIM_DELEG_PREV_FHクレームタイプもサポートしていない場合は、関連する委任も削除する必要があります。それ以外の場合、委任は保持され、セクション10.2.1に従って回復が進行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
After processing, clientid_ret is returned to the client and this client record is added:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
処理後、clientid_retがクライアントに返され、このクライアントレコードが追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, unconfirmed }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ownerid_arg、verifier_arg、principal_arg、clientid_ret、未確認}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The previously described confirmed record continues to exist, and thus the same ownerid_arg exists in both a confirmed and unconfirmed state at the same time. The number of states can collapse to one once the server receives an applicable CREATE_SESSION or EXCHANGE_ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
前述の確認済みレコードは引き続き存在するため、確認済みと未確認の両方の状態で同じownerid_argが同時に存在します。サーバーが適切なCREATE_SESSIONまたはEXCHANGE_IDを受信すると、状態の数は1に縮小する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ If the server subsequently receives a successful CREATE_SESSION that confirms clientid_ret, then the server atomically destroys the confirmed record and makes the unconfirmed record confirmed as described in Section 18.36.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ 続いてサーバーがclientid_retを確認する成功したCREATE_SESSIONを受信すると、サーバーは確認済みレコードをアトミ​​ックに破棄し、セクション18.36.4で説明されているように未確認レコードを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ If the server instead subsequently receives an EXCHANGE_ID with the client owner equal to ownerid_arg, one strategy is to simply delete the unconfirmed record, and process the EXCHANGE_ID as described in the entirety of Section 18.35.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ サーバーが代わりに、クライアント所有者がownerid_argと等しいEXCHANGE_IDを受信した場合、1つの戦略は、未確認のレコードを削除し、セクション18.35.4の全体で説明されているようにEXCHANGE_IDを処理することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Update
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 更新
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is set, and the server has the following confirmed record, then this request is an attempt at an update.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aが設定されていて、サーバーに以下の確認済みレコードがある場合、この要求は更新の試みです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, confirmed }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ownerid_arg、verifier_arg、principal_arg、clientid_ret、確認済み}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Since the record has been confirmed, the client must have received the server&#39;s reply from the initial EXCHANGE_ID request. The server allows the update, and the client record is left intact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
レコードが確認されているため、クライアントは最初のEXCHANGE_IDリクエストからサーバーの応答を受信して​​いる必要があります。サーバーは更新を許可し、クライアントレコードはそのまま残ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Update but No Confirmed Record
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. 更新されたが確認されていないレコード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is set, and the server has no confirmed record corresponding ownerid_arg, then the server returns NFS4ERR_NOENT and leaves any unconfirmed record intact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aが設定されていて、サーバーにownerid_argに対応する確認済みのレコードがない場合、サーバーはNFS4ERR_NOENTを返し、未確認のレコードはそのまま残します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Update but Wrong Verifier
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. 更新するが検証方法が間違っている
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is set, and the server has the following confirmed record, then this request is an illegal attempt at an update, perhaps because of a retry from a previous client incarnation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aが設定されていて、サーバーに次の確認済みのレコードがある場合、この要求は更新での不正な試みです。おそらく、以前のクライアントインカネーションからの再試行が原因です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          { ownerid_arg, old_verifier_arg, *, clientid_ret, confirmed }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The server returns NFS4ERR_NOT_SAME and leaves the client record intact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
サーバーはNFS4ERR_NOT_SAMEを返し、クライアントレコードをそのまま残します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. Update but Wrong Principal
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. 更新されたが間違ったプリンシパル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is set, and the server has the following confirmed record, then this request is an illegal attempt at an update by an unauthorized principal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aが設定されていて、サーバーに次の確認済みのレコードがある場合、この要求は不正なプリンシパルによる更新の不正な試みです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ ownerid_arg, verifier_arg, old_principal_arg, clientid_ret, confirmed }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
{ownerid_arg、verifier_arg、old_principal_arg、clientid_ret、確認済み}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The server returns NFS4ERR_PERM and leaves the client record intact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
サーバーはNFS4ERR_PERMを返し、クライアントレコードをそのまま残します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
18.36. Operation 43: CREATE_SESSION - Create New Session and Confirm Client ID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
18.36. 操作43：CREATE_SESSION-新しいセッションの作成とクライアントIDの確認
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-36-1--ARGUMENT">
18.36.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.36.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct channel_attrs4 {
           count4                  ca_headerpadsize;
           count4                  ca_maxrequestsize;
           count4                  ca_maxresponsesize;
           count4                  ca_maxresponsesize_cached;
           count4                  ca_maxoperations;
           count4                  ca_maxrequests;
           uint32_t                ca_rdma_ird&lt;1&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const CREATE_SESSION4_FLAG_PERSIST              = 0x00000001;
   const CREATE_SESSION4_FLAG_CONN_BACK_CHAN       = 0x00000002;
   const CREATE_SESSION4_FLAG_CONN_RDMA            = 0x00000004;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CREATE_SESSION4args {
           clientid4               csa_clientid;
           sequenceid4             csa_sequence;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
uint32_t csa_flags;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
uint32_t csa_flags;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           channel_attrs4          csa_fore_chan_attrs;
           channel_attrs4          csa_back_chan_attrs;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           uint32_t                csa_cb_program;
           callback_sec_parms4     csa_sec_parms&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-36-2--RESULT">
18.36.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.36.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CREATE_SESSION4resok {
           sessionid4              csr_sessionid;
           sequenceid4             csr_sequence;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
uint32_t csr_flags;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
uint32_t csr_flags;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           channel_attrs4          csr_fore_chan_attrs;
           channel_attrs4          csr_back_chan_attrs;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union CREATE_SESSION4res switch (nfsstat4 csr_status) {
   case NFS4_OK:
           CREATE_SESSION4resok    csr_resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-36-3--DESCRIPTION">
18.36.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.36.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used by the client to create new session objects on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、サーバー上に新しいセッションオブジェクトを作成するためにクライアントによって使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATE_SESSION can be sent with or without a preceding SEQUENCE operation in the same COMPOUND procedure. If CREATE_SESSION is sent with a preceding SEQUENCE operation, any session created by CREATE_SESSION has no direct relation to the session specified in the SEQUENCE operation, although the two sessions might be associated with the same client ID. If CREATE_SESSION is sent without a preceding SEQUENCE, then it MUST be the only operation in the COMPOUND procedure&#39;s request. If it is not, the server MUST return NFS4ERR_NOT_ONLY_OP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATE_SESSIONは、同じCOMPOUNDプロシージャで、先行するSEQUENCE操作の有無にかかわらず送信できます。先行するSEQUENCE操作でCREATE_SESSIONが送信される場合、2つのセッションが同じクライアントIDに関連付けられている可能性がありますが、CREATE_SESSIONによって作成されたセッションは、SEQUENCE操作で指定されたセッションと直接の関係はありません。先行するSEQUENCEなしでCREATE_SESSIONが送信される場合は、それがCOMPOUNDプロシージャの要求での唯一の操作でなければなりません。そうでない場合、サーバーはNFS4ERR_NOT_ONLY_OPを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to creating a session, CREATE_SESSION has the following effects:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションの作成に加えて、CREATE_SESSIONには次の効果があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The first session created with a new client ID serves to confirm the creation of that client&#39;s state on the server. The server returns the parameter values for the new session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 新しいクライアントIDで作成された最初のセッションは、サーバー上でのそのクライアントの状態の作成を確認するのに役立ちます。サーバーは、新しいセッションのパラメーター値を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The connection CREATE_SESSION that is sent over is associated with the session&#39;s fore channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 送信される接続CREATE_SESSIONは、セッションのフォアチャネルに関連付けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The arguments and results of CREATE_SESSION are described as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATE_SESSIONの引数と結果は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
csa_clientid:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
csa_clientid：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This is the client ID with which the new session will be associated. The corresponding result is csr_sessionid, the session ID of the new session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
これは、新しいセッションが関連付けられるクライアントIDです。対応する結果は、新しいセッションのセッションIDであるcsr_sessionidです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
csa_sequence:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
csa_sequence：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Each client ID serializes CREATE_SESSION via a per-client ID sequence number (see Section 18.36.4). The corresponding result is csr_sequence, which MUST be equal to csa_sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
各クライアントIDは、クライアントごとのIDシーケンス番号を介してCREATE_SESSIONをシリアル化します（セクション18.36.4を参照）。対応する結果はcsr_sequenceであり、csa_sequenceと等しい必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the next three arguments, the client offers a value that is to be a property of the session. Except where stated otherwise, it is RECOMMENDED that the server accept the value. If it is not acceptable, the server MAY use a different value. Regardless, the server MUST return the value the session will use (which will be either what the client offered, or what the server is insisting on) to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の3つの引数では、クライアントはセッションのプロパティとなる値を提供します。特に明記しない限り、サーバーが値を受け入れることをお勧めします。それが受け入れられない場合、サーバーは別の値を使用できます。いずれにせよ、サーバーは、セッションが使用する値（クライアントが提供したものか、サーバーが主張しているもののいずれか）をクライアントに返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
csa_flags:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
csa_flags：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The csa_flags field contains a list of the following flag bits:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
csa_flagsフィールドには、次のフラグビットのリストが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CREATE_SESSION4_FLAG_PERSIST:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CREATE_SESSION4_FLAG_PERSIST：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
If CREATE_SESSION4_FLAG_PERSIST is set, the client wants the server to provide a persistent reply cache. For sessions in which only idempotent operations will be used (e.g., a read-only session), clients SHOULD NOT set CREATE_SESSION4_FLAG_PERSIST. If the server does not or cannot provide a persistent reply cache, the server MUST NOT set CREATE_SESSION4_FLAG_PERSIST in the field csr_flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
CREATE_SESSION4_FLAG_PERSISTが設定されている場合、クライアントはサーバーが永続的な応答キャッシュを提供することを望んでいます。べき等演算のみが使用されるセッション（読み取り専用セッションなど）の場合、クライアントはCREATE_SESSION4_FLAG_PERSISTを設定してはなりません（SHOULD NOT）。サーバーが永続的な応答キャッシュを提供しない、または提供できない場合、サーバーはフィールドcsr_flagsにCREATE_SESSION4_FLAG_PERSISTを設定してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
If the server is a pNFS metadata server, for reasons described in Section 12.5.2 it SHOULD support CREATE_SESSION4_FLAG_PERSIST if it supports the layout_hint (Section 5.12.4) attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
サーバーがpNFSメタデータサーバーである場合、セクション12.5.2で説明されている理由により、layout_hint（セクション5.12.4）属性をサポートする場合、サーバーはCREATE_SESSION4_FLAG_PERSISTをサポートする必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CREATE_SESSION4_FLAG_CONN_BACK_CHAN:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CREATE_SESSION4_FLAG_CONN_BACK_CHAN：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
If CREATE_SESSION4_FLAG_CONN_BACK_CHAN is set in csa_flags, the client is requesting that the connection over which the CREATE_SESSION operation arrived be associated with the session&#39;s backchannel in addition to its fore channel. If the server agrees, it sets CREATE_SESSION4_FLAG_CONN_BACK_CHAN in the result field csr_flags. If CREATE_SESSION4_FLAG_CONN_BACK_CHAN is not set in csa_flags, then CREATE_SESSION4_FLAG_CONN_BACK_CHAN MUST NOT be set in csr_flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
CREATE_SESSION4_FLAG_CONN_BACK_CHANがcsa_flagsに設定されている場合、クライアントは、CREATE_SESSION操作が到着した接続が、その前のチャネルに加えてセッションのバックチャネルに関連付けられることを要求しています。サーバーが同意すると、サーバーは結果フィールドcsr_flagsにCREATE_SESSION4_FLAG_CONN_BACK_CHANを設定します。 CREATE_SESSION4_FLAG_CONN_BACK_CHANがcsa_flagsで設定されていない場合、CREATE_SESSION4_FLAG_CONN_BACK_CHANをcsr_flagsで設定してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CREATE_SESSION4_FLAG_CONN_RDMA:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CREATE_SESSION4_FLAG_CONN_RDMA：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If CREATE_SESSION4_FLAG_CONN_RDMA is set in csa_flags, and if the connection over which the CREATE_SESSION operation arrived is currently in non-RDMA mode but has the capability to operate in RDMA mode, then the client is requesting that the server &#34;step up&#34; to RDMA mode on the connection. If the server agrees, it sets CREATE_SESSION4_FLAG_CONN_RDMA in the result field csr_flags. If CREATE_SESSION4_FLAG_CONN_RDMA is not set in csa_flags, then CREATE_SESSION4_FLAG_CONN_RDMA MUST NOT be set in csr_flags. Note that once the server agrees to step up, it and the client MUST exchange all future traffic on the connection with RPC RDMA framing and not Record Marking ([8]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
CREATE_SESSION4_FLAG_CONN_RDMAがcsa_flagsに設定されており、CREATE_SESSION操作が到着した接続が現在非RDMAモードであるが、RDMAモードで動作する機能がある場合、クライアントはサーバーがRDMAモードに「ステップアップ」することを要求しています接続。サーバーが同意すると、結果フィールドcsr_flagsにCREATE_SESSION4_FLAG_CONN_RDMAが設定されます。 CREATE_SESSION4_FLAG_CONN_RDMAがcsa_flagsに設定されていない場合、CREATE_SESSION4_FLAG_CONN_RDMAはcsr_flagsに設定してはなりません（MUST NOT）。サーバーがステップアップすることに同意すると、サーバーとクライアントは、レコードマーキング（[8]）ではな​​く、RPC RDMAフレーミングとの接続で将来のすべてのトラフィックを交換する必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
csa_fore_chan_attrs, csa_fore_chan_attrs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
csa_fore_chan_attrs、csa_fore_chan_attrs：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The csa_fore_chan_attrs and csa_back_chan_attrs fields apply to attributes of the fore channel (which conveys requests originating from the client to the server), and the backchannel (the channel that conveys callback requests originating from the server to the client), respectively. The results are in corresponding structures called csr_fore_chan_attrs and csr_back_chan_attrs. The results establish attributes for each channel, and on all subsequent use of each channel of the session. Each structure has the following fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
csa_fore_chan_attrsおよびcsa_back_chan_attrsフィールドは、それぞれ、フォアチャネル（クライアントからサーバーに発信された要求を伝達する）およびバックチャネル（サーバーからクライアントに発信されるコールバック要求を伝達するチャネル）の属性に適用されます。結果は、csr_fore_chan_attrsおよびcsr_back_chan_attrsと呼ばれる対応する構造体にあります。結果は、各チャネル、およびセッションの各チャネルのその後のすべての使用に関する属性を確立します。各構造には次のフィールドがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ca_headerpadsize:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ca_headerpadsize：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The maximum amount of padding the requester is willing to apply to ensure that write payloads are aligned on some boundary at the replier. For each channel, the server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
リクエスタの境界に書き込みペイロードが確実に揃えられるように、リクエスタが適用しようとするパディングの最大量。各チャネルについて、サーバー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
+ will reply in ca_headerpadsize with its preferred value, or zero if padding is not in use, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
+ ca_headerpadsizeに適切な値で応答します。パディングが使用されていない場合はゼロ、および
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
+ MAY decrease this value but MUST NOT increase it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
+ この値を減らすことはできますが、増やすことはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ca_maxrequestsize:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ca_maxrequestsize：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The maximum size of a COMPOUND or CB_COMPOUND request that will be sent. This size represents the XDR encoded size of the request, including the RPC headers (including security flavor credentials and verifiers) but excludes any RPC transport framing headers. Imagine a request coming over a non-RDMA TCP/IP connection, and that it has a single Record Marking header preceding it. The maximum allowable count encoded in the header will be ca_maxrequestsize. If a requester sends a request that exceeds ca_maxrequestsize, the error NFS4ERR_REQ_TOO_BIG will be returned per the description in Section 2.10.6.4. For each channel, the server MAY decrease this value but MUST NOT increase it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
送信されるCOMPOUNDまたはCB_COMPOUNDリクエストの最大サイズ。このサイズは、RPCヘッダー（セキュリティフレーバー認証情報と検証を含む）を含む、リクエストのXDRエンコードサイズを表しますが、RPCトランスポートフレーミングヘッダーは除外されます。非RDMA TCP / IP接続を介して送信される要求と、その前に単一のレコードマーキングヘッダーがあると想像してください。ヘッダーにエンコードされた最大許容数はca_maxrequestsizeです。リクエスタがca_maxrequestsizeを超えるリクエストを送信すると、セクション2.10.6.4の説明に従ってエラーNFS4ERR_REQ_TOO_BIGが返されます。各チャネルについて、サーバーはこの値を減らしてもよいですが、増やしてはいけません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ca_maxresponsesize:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ca_maxresponsesize：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The maximum size of a COMPOUND or CB_COMPOUND reply that the requester will accept from the replier including RPC headers (see the ca_maxrequestsize definition). For each channel, the server MAY decrease this value, but MUST NOT increase it. However, if the client selects a value for ca_maxresponsesize such that a replier on a channel could never send a response, the server SHOULD return NFS4ERR_TOOSMALL in the CREATE_SESSION reply. After the session is created, if a requester sends a request for which the size of the reply would exceed this value, the replier will return NFS4ERR_REP_TOO_BIG, per the description in Section 2.10.6.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
RPCヘッダーを含むリクエスターからリクエスターが受け入れるCOMPOUNDまたはCB_COMPOUND応答の最大サイズ（ca_maxrequestsizeの定義を参照）。各チャネルについて、サーバーはこの値を減らしてもかまいませんが、増やしてはいけません（MUST NOT）。ただし、クライアントがca_maxresponsesizeの値を選択して、チャネル上の応答者が応答を送信できない場合、サーバーはCREATE_SESSION応答でNFS4ERR_TOOSMALLを返す必要があります（SHOULD）。セッションが作成された後、リクエスタが応答のサイズがこの値を超えるリクエストを送信すると、リプライヤはセクション2.10.6.4の説明に従ってNFS4ERR_REP_TOO_BIGを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ca_maxresponsesize_cached:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ca_maxresponsesize_cached：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Like ca_maxresponsesize, but the maximum size of a reply that will be stored in the reply cache (Section 2.10.6.1). For each channel, the server MAY decrease this value, but MUST NOT increase it. If, in the reply to CREATE_SESSION, the value of ca_maxresponsesize_cached of a channel is less than the value of ca_maxresponsesize of the same channel, then this is an indication to the requester that it needs to be selective about which replies it directs the replier to cache; for example, large replies from nonidempotent operations (e.g., COMPOUND requests with a READ operation) should not be cached. The requester decides which replies to cache via an argument to the SEQUENCE (the sa_cachethis field, see Section 18.46) or CB_SEQUENCE (the csa_cachethis field, see Section 20.9) operations. After the session is created, if a requester sends a request for which the size of the reply would exceed ca_maxresponsesize_cached, the replier will return NFS4ERR_REP_TOO_BIG_TO_CACHE, per the description in Section 2.10.6.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ca_maxresponsesizeに似ていますが、応答キャッシュに保存される応答の最大サイズ（セクション2.10.6.1）。各チャネルについて、サーバーはこの値を減らしてもかまいませんが、増やしてはいけません（MUST NOT）。 CREATE_SESSIONへの応答で、チャネルのca_maxresponsesize_cachedの値が同じチャネルのca_maxresponsesizeの値よりも小さい場合、これはリクエスターにキャッシュに指示する応答を選択する必要があることを要求者に示しています。 ;たとえば、べき等ではない操作（たとえば、READ操作を伴うCOMPOUNDリクエスト）からの大きな応答はキャッシュに入れるべきではありません。リクエスタは、SEQUENCE（sa_cachethisフィールド、セクション18.46を参照）またはCB_SEQUENCE（csa_cachethisフィールド、セクション20.9を参照）操作への引数を使用して、キャッシュする応答を決定します。セッションが作成された後、リクエスタが応答のサイズがca_maxresponsesize_cachedを超えるリクエストを送信すると、リプライヤはセクション2.10.6.4の説明に従ってNFS4ERR_REP_TOO_BIG_TO_CACHEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ca_maxoperations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ca_maxoperations：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The maximum number of operations the replier will accept in a COMPOUND or CB_COMPOUND. For the backchannel, the server MUST NOT change the value the client offers. For the fore channel, the server MAY change the requested value. After the session is created, if a requester sends a COMPOUND or CB_COMPOUND with more operations than ca_maxoperations, the replier MUST return NFS4ERR_TOO_MANY_OPS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
返信者がCOMPOUNDまたはCB_COMPOUNDで受け入れる操作の最大数。バックチャネルの場合、サーバーはクライアントが提供する値を変更してはなりません（MUST NOT）。フォアチャネルの場合、サーバーは要求された値を変更できます（MAY）。セッションが作成された後、リクエスタがca_maxoperationsよりも多くの操作でCOMPOUNDまたはCB_COMPOUNDを送信した場合、リプライヤはNFS4ERR_TOO_MANY_OPSを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ca_maxrequests:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ca_maxrequests：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The maximum number of concurrent COMPOUND or CB_COMPOUND requests the requester will send on the session. Subsequent requests will each be assigned a slot identifier by the requester within the range zero to ca_maxrequests - 1 inclusive. For the backchannel, the server MUST NOT change the value the client offers. For the fore channel, the server MAY change the requested value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
リクエスターがセッションで送信する同時COMPOUNDまたはCB_COMPOUND要求の最大数。後続のリクエストにはそれぞれ、0からca_maxrequests-1までの範囲内でリクエスターによってスロット識別子が割り当てられます。バックチャネルの場合、サーバーはクライアントが提供する値を変更してはなりません（MUST NOT）。フォアチャネルの場合、サーバーは要求された値を変更できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ca_rdma_ird:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Kardhm_hird：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
This array has a maximum of one element. If this array has one element, then the element contains the inbound RDMA read queue depth (IRD). For each channel, the server MAY decrease this value, but MUST NOT increase it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
この配列には最大1つの要素があります。この配列に要素が1つある場合、要素にはインバウンドRDMA読み取りキュー深度（IRD）が含まれます。各チャネルについて、サーバーはこの値を減らしてもかまいませんが、増やしてはいけません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
csa_cb_program
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
csa_cb_program
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This is the ONC RPC program number the server MUST use in any callbacks sent through the backchannel to the client. The server MUST specify an ONC RPC program number equal to csa_cb_program and an ONC RPC version number equal to 4 in callbacks sent to the client. If a CB_COMPOUND is sent to the client, the server MUST use a minor version number of 1. There is no corresponding result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
これは、バックチャネルを介してクライアントに送信されるコールバックでサーバーが使用する必要があるONC RPCプログラム番号です。サーバーは、クライアントに送信されるコールバックで、csa_cb_programに等しいONC RPCプログラム番号と4に等しいONC RPCバージョン番号を指定する必要があります。 CB_COMPOUNDがクライアントに送信される場合、サーバーは1のマイナーバージョン番号を使用する必要があります。対応する結果はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
csa_sec_parms
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
csa_sec_parms
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The field csa_sec_parms is an array of acceptable security credentials the server can use on the session&#39;s backchannel. Three security flavors are supported: AUTH_NONE, AUTH_SYS, and RPCSEC_GSS. If AUTH_NONE is specified for a credential, then this says the client is authorizing the server to use AUTH_NONE on all callbacks for the session. If AUTH_SYS is specified, then the client is authorizing the server to use AUTH_SYS on all callbacks, using the credential specified cbsp_sys_cred. If RPCSEC_GSS is specified, then the server is allowed to use the RPCSEC_GSS context specified in cbsp_gss_parms as the RPCSEC_GSS context in the credential of the RPC header of callbacks to the client. There is no corresponding result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
フィールドcsa_sec_parmsは、サーバーがセッションのバックチャネルで使用できる受け入れ可能なセキュリティ資格情報の配列です。 AUTH_NONE、AUTH_SYS、およびRPCSEC_GSSの3つのセキュリティフレーバーがサポートされています。資格情報にAUTH_NONEが指定されている場合、これは、クライアントがサーバーにセッションのすべてのコールバックでAUTH_NONEを使用することを許可していることを示しています。 AUTH_SYSが指定されている場合、クライアントは、指定された資格情報cbsp_sys_credを使用して、すべてのコールバックでAUTH_SYSを使用することをサーバーに許可しています。 RPCSEC_GSSが指定されている場合、サーバーは、cbsp_gss_parmsで指定されたRPCSEC_GSSコンテキストを、クライアントへのコールバックのRPCヘッダーの資格情報のRPCSEC_GSSコンテキストとして使用できます。対応する結果はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The RPCSEC_GSS context for the backchannel is specified via a pair of values of data type gsshandle4_t. The data type gsshandle4_t represents an RPCSEC_GSS handle, and is precisely the same as the data type of the &#34;handle&#34; field of the rpc_gss_init_res data type defined in Section 5.2.3.1, &#34;Context Creation Response - Successful Acceptance&#34;, of [4].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
バックチャネルのRPCSEC_GSSコンテキストは、データ型gsshandle4_tの値のペアを介して指定されます。データ型gsshandle4_tはRPCSEC_GSSハンドルを表し、[4]のセクション5.2.3.1、「Context Creation Response-Successful Acceptance」で定義されているrpc_gss_init_resデータ型の「handle」フィールドのデータ型とまったく同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The first RPCSEC_GSS handle, gcbp_handle_from_server, is the fore handle the server returned to the client (either in the handle field of data type rpc_gss_init_res or as one of the elements of the spi_handles field returned in the reply to EXCHANGE_ID) when the RPCSEC_GSS context was created on the server. The second handle, gcbp_handle_from_client, is the back handle to which the client will map the RPCSEC_GSS context. The server can immediately use the value of gcbp_handle_from_client in the RPCSEC_GSS credential in callback RPCs. That is, the value in gcbp_handle_from_client can be used as the value of the field &#34;handle&#34; in data type rpc_gss_cred_t (see Section 5, &#34;Elements of the RPCSEC_GSS Security Protocol&#34;, of [4]) in callback RPCs. The server MUST use the RPCSEC_GSS security service specified in gcbp_service, i.e., it MUST set the &#34;service&#34; field of the rpc_gss_cred_t data type in RPCSEC_GSS credential to the value of gcbp_service (see Section 5.3.1, &#34;RPC Request Header&#34;, of [4]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
RPCSEC_GSSコンテキストが作成されたときに、最初のRPCSEC_GSSハンドルgcbp_handle_from_serverは、サーバーがクライアントに返したフォアハンドルです（データ型rpc_gss_init_resのハンドルフィールド、またはEXCHANGE_IDへの応答で返されたspi_handlesフィールドの要素の1つとして）。サーバー上。 2番目のハンドルgcbp_handle_from_clientは、クライアントがRPCSEC_GSSコンテキストをマップするバックハンドルです。サーバーは、コールバックRPCのRPCSEC_GSS資格情報のgcbp_handle_from_clientの値をすぐに使用できます。つまり、gcbp_handle_from_clientの値は、コールバックRPCのデータ型rpc_gss_cred_t（[5]のセクション5「RPCSEC_GSSセキュリティプロトコルの要素」を参照）のフィールド「handle」の値として使用できます。サーバーはgcbp_serviceで指定されたRPCSEC_GSSセキュリティサービスを使用する必要があります。つまり、RPCSEC_GSS資格情報のrpc_gss_cred_tデータタイプの「サービス」フィールドをgcbp_serviceの値に設定する必要があります（セクション5.3.1、「RPCリクエストヘッダー」を参照）。 4]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the RPCSEC_GSS handle identified by gcbp_handle_from_server does not exist on the server, the server will return NFS4ERR_NOENT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
gcbp_handle_from_serverで識別されるRPCSEC_GSSハンドルがサーバーに存在しない場合、サーバーはNFS4ERR_NOENTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Within each element of csa_sec_parms, the fore and back RPCSEC_GSS contexts MUST share the same GSS context and MUST have the same seq_window (see Section 5.2.3.1 of RFC2203 [4]). The fore and back RPCSEC_GSS context state are independent of each other as far as the RPCSEC_GSS sequence number (see the seq_num field in the rpc_gss_cred_t data type of Sections 5 and 5.3.1 of [4]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
csa_sec_parmsの各要素内では、フォアとバックのRPCSEC_GSSコンテキストは同じGSSコンテキストを共有し、同じseq_windowを持っている必要があります（RFC2203 [5.2.3.1]のセクション5.2.3.1を参照）。フォアとバックのRPCSEC_GSSコンテキスト状態は、RPCSEC_GSSシーケンス番号（[4]のセクション5と5.3.1のrpc_gss_cred_tデータ型のseq_numフィールドを参照）までは互いに独立しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If an RPCSEC_GSS handle is using the SSV context (see Section 2.10.9), then because each SSV RPCSEC_GSS handle shares a common SSV GSS context, there are security considerations specific to this situation discussed in Section 2.10.10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RPCSEC_GSSハンドルがSSVコンテキストを使用している場合（セクション2.10.9を参照）、各SSV RPCSEC_GSSハンドルは共通のSSV GSSコンテキストを共有するため、セクション2.10.10で説明されているこの状況に固有のセキュリティに関する考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the session is created, the first SEQUENCE or CB_SEQUENCE received on a slot MUST have a sequence ID equal to 1; if not, the replier MUST return NFS4ERR_SEQ_MISORDERED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションが作成されると、スロットで受信した最初のSEQUENCEまたはCB_SEQUENCEのシーケンスIDは1でなければなりません。そうでない場合、応答者はNFS4ERR_SEQ_MISORDEREDを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-36-4--IMPLEMENTATION">
18.36.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.36.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To describe a possible implementation, the same notation for client records introduced in the description of EXCHANGE_ID is used with the following addition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能な実装を説明するために、EXCHANGE_IDの説明で紹介したクライアントレコードと同じ表記法を使用し、次のように追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
clientid_arg: The value of the csa_clientid field of the CREATE_SESSION4args structure of the current request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
clientid_arg：現在のリクエストのCREATE_SESSION4args構造のcsa_clientidフィールドの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since CREATE_SESSION is a non-idempotent operation, we need to consider the possibility that retries may occur as a result of a client restart, network partition, malfunctioning router, etc. For each client ID created by EXCHANGE_ID, the server maintains a separate reply cache (called the CREATE_SESSION reply cache) similar to the session reply cache used for SEQUENCE operations, with two distinctions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATE_SESSIONはべき等ではない操作であるため、クライアントの再起動、ネットワークパーティション、ルーターの誤動作などの結果として再試行が発生する可能性を考慮する必要があります。EXCHANGE_IDによって作成されたクライアントIDごとに、サーバーは個別の応答キャッシュを維持します（CREATE_SESSION応答キャッシュと呼ばれる）SEQUENCE操作に使用されるセッション応答キャッシュに似ていますが、2つの違いがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o First, this is a reply cache just for detecting and processing CREATE_SESSION requests for a given client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o まず、これは特定のクライアントIDに対するCREATE_SESSION要求を検出して処理するための応答キャッシュです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Second, the size of the client ID reply cache is of one slot (and as a result, the CREATE_SESSION request does not carry a slot number). This means that at most one CREATE_SESSION request for a given client ID can be outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2番目に、クライアントID応答キャッシュのサイズは1スロットです（その結果、CREATE_SESSION要求はスロット番号を持ちません）。これは、特定のクライアントIDに対して最大1つのCREATE_SESSIONリクエストが未解決である可能性があることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As previously stated, CREATE_SESSION can be sent with or without a preceding SEQUENCE operation. Even if a SEQUENCE precedes CREATE_SESSION, the server MUST maintain the CREATE_SESSION reply cache, which is separate from the reply cache for the session associated with a SEQUENCE. If CREATE_SESSION was originally sent by itself, the client MAY send a retry of the CREATE_SESSION operation within a COMPOUND preceded by a SEQUENCE. If CREATE_SESSION was originally sent in a COMPOUND that started with a SEQUENCE, then the client SHOULD send a retry in a COMPOUND that starts with a SEQUENCE that has the same session ID as the SEQUENCE of the original request. However, the client MAY send a retry in a COMPOUND that either has no preceding SEQUENCE, or has a preceding SEQUENCE that refers to a different session than the original CREATE_SESSION. This might be necessary if the client sends a CREATE_SESSION in a COMPOUND preceded by a SEQUENCE with session ID X, and session X no longer exists. Regardless, any retry of CREATE_SESSION, with or without a preceding SEQUENCE, MUST use the same value of csa_sequence as the original.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前述のように、CREATE_SESSIONは、先行するSEQUENCE操作の有無にかかわらず送信できます。 SEQUENCEがCREATE_SESSIONの前にある場合でも、サーバーは、SEQUENCEに関連付けられたセッションの応答キャッシュとは別のCREATE_SESSION応答キャッシュを維持する必要があります。 CREATE_SESSIONが最初にそれ自体で送信された場合、クライアントは、SEQUENCEに続くCOMPOUND内でCREATE_SESSION操作の再試行を送信できます（MAY）。 CREATE_SESSIONが最初にSEQUENCEで始まるCOMPOUNDで送信された場合、クライアントは、元の要求のSEQUENCEと同じセッションIDを持つSEQUENCEで始まるCOMPOUNDで再試行を送信する必要があります（SHOULD）。ただし、クライアントは、先行するSEQUENCEがないか、元のCREATE_SESSIONとは異なるセッションを参照する先行するSEQUENCEがあるCOMPOUNDで再試行を送信する場合があります。これは、クライアントがセッションID XのSEQUENCEの後に続くCOMPOUNDでCREATE_SESSIONを送信し、セッションXが存在しない場合に必要になることがあります。いずれにしても、先行するSEQUENCEの有無にかかわらず、CREATE_SESSIONの再試行では、元の値と同じcsa_sequenceの値を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the client received a reply to an EXCHANGE_ID operation that contains a new, unconfirmed client ID, the server expects the client to follow with a CREATE_SESSION operation to confirm the client ID. The server expects value of csa_sequenceid in the arguments to that CREATE_SESSION to be to equal the value of the field eir_sequenceid that was returned in results of the EXCHANGE_ID that returned the unconfirmed client ID. Before the server replies to that EXCHANGE_ID operation, it initializes the client ID slot to be equal to eir_sequenceid - 1 (accounting for underflow), and records a contrived CREATE_SESSION result with a &#34;cached&#34; result of NFS4ERR_SEQ_MISORDERED. With the client ID slot thus initialized, the processing of the CREATE_SESSION operation is divided into four phases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、未確認の新しいクライアントIDを含むEXCHANGE_ID操作への応答を受け取った後、クライアントがCREATE_SESSION操作を実行してクライアントIDを確認することを期待します。サーバーは、そのCREATE_SESSIONへの引数のcsa_sequenceidの値が、未確認のクライアントIDを返したEXCHANGE_IDの結果として返されたフィールドeir_sequenceidの値と等しいことを期待しています。サーバーは、そのEXCHANGE_ID操作に応答する前に、クライアントIDスロットを初期化してeir_sequenceid-1（アンダーフローを考慮）に等しくし、不自然なCREATE_SESSION結果を「キャッシュされた」NFS4ERR_SEQ_MISORDEREDの結果とともに記録します。クライアントIDスロットがこのように初期化されると、CREATE_SESSION操作の処理は4つのフェーズに分割されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Client record look up. The server looks up the client ID in its client record table. If the server contains no records with client ID equal to clientid_arg, then most likely the client&#39;s state has been purged during a period of inactivity, possibly due to a loss of connectivity. NFS4ERR_STALE_CLIENTID is returned, and no changes are made to any client records on the server. Otherwise, the server goes to phase 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. クライアントレコードの検索。サーバーは、クライアントレコードテーブルでクライアントIDを検索します。クライアントIDがclientid_argに等しいレコードがサーバーに含まれていない場合、おそらく接続が失われたことが原因で、クライアントの状態が非アクティブな期間中に消去された可能性があります。 NFS4ERR_STALE_CLIENTIDが返され、サーバー上のクライアントレコードは変更されません。それ以外の場合、サーバーはフェーズ2に進みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Sequence ID processing. If csa_sequenceid is equal to the sequence ID in the client ID&#39;s slot, then this is a replay of the previous CREATE_SESSION request, and the server returns the cached result. If csa_sequenceid is not equal to the sequence ID in the slot, and is more than one greater (accounting for wraparound), then the server returns the error NFS4ERR_SEQ_MISORDERED, and does not change the slot. If csa_sequenceid is equal to the slot&#39;s sequence ID + 1 (accounting for wraparound), then the slot&#39;s sequence ID is set to csa_sequenceid, and the CREATE_SESSION processing goes to the next phase. A subsequent new CREATE_SESSION call over the same client ID MUST use a csa_sequenceid that is one greater than the sequence ID in the slot.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. シーケンスID処理。 csa_sequenceidがクライアントIDのスロットのシーケンスIDと等しい場合、これは前のCREATE_SESSIONリクエストの再生であり、サーバーはキャッシュされた結果を返します。 csa_sequenceidがスロット内のシーケンスIDと等しくなく、1より大きい場合（ラップアラウンドを考慮して）、サーバーはエラーNFS4ERR_SEQ_MISORDEREDを返し、スロットを変更しません。 csa_sequenceidがスロットのシーケンスID + 1（ラップアラウンドを考慮）と等しい場合、スロットのシーケンスIDはcsa_sequenceidに設定され、CREATE_SESSION処理は次のフェーズに進みます。同じクライアントIDに対する後続の新しいCREATE_SESSION呼び出しでは、スロット内のシーケンスIDよりも1つ大きいcsa_sequenceidを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Client ID confirmation. If this would be the first session for the client ID, the CREATE_SESSION operation serves to confirm the client ID. Otherwise, the client ID confirmation phase is skipped and only the session creation phase occurs. Any case in which there is more than one record with identical values for client ID represents a server implementation error. Operation in the potential valid cases is summarized as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. クライアントIDの確認。これがクライアントIDの最初のセッションである場合、CREATE_SESSION操作はクライアントIDを確認するために機能します。それ以外の場合、クライアントID確認フェーズはスキップされ、セッション作成フェーズのみが発生します。クライアントIDに同じ値を持つレコードが複数ある場合は、サーバー実装エラーを表します。考えられる有効なケースでの操作は、次のように要約されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Successful Confirmation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* 成功した確認
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
If the server has the following unconfirmed record, then this is the expected confirmation of an unconfirmed record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
サーバーに次の未確認レコードがある場合、これは未確認レコードの予想される確認です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
{ ownerid, verifier, principal_arg, clientid_arg, unconfirmed }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
{ownerid、verifier、principal_arg、clientid_arg、未確認}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
As noted in Section 18.35.4, the server might also have the following confirmed record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
18.35.4項で説明したように、サーバーには次の確認済みレコードも含まれる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
{ ownerid, old_verifier, principal_arg, old_clientid, confirmed }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
{ownerid、old_verifier、principal_arg、old_clientid、確認済み}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
The server schedules the replacement of both records with:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
サーバーは、両方のレコードの置換を次のようにスケジュールします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
{ ownerid, verifier, principal_arg, clientid_arg, confirmed }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
{ownerid、verifier、principal_arg、clientid_arg、確認済み}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
The processing of CREATE_SESSION continues on to session creation. Once the session is successfully created, the scheduled client record replacement is committed. If the session is not successfully created, then no changes are made to any client records on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
CREATE_SESSIONの処理は、セッションの作成に続きます。セッションが正常に作成されると、スケジュールされたクライアントレコードの置換がコミットされます。セッションが正常に作成されない場合、サーバー上のクライアントレコードは変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Unsuccessful Confirmation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* 確認できませんでした
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
If the server has the following record, then the client has changed principals after the previous EXCHANGE_ID request, or there has been a chance collision between shorthand client identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
サーバーに次のレコードがある場合、クライアントは前回のEXCHANGE_ID要求の後でプリンシパルを変更したか、または省略形のクライアント識別子の間に衝突が発生した可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             { *, *, old_principal_arg, clientid_arg, * }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Neither of these cases is permissible. Processing stops and NFS4ERR_CLID_INUSE is returned to the client. No changes are made to any client records on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
これらのケースはどちらも許可されていません。処理が停止し、NFS4ERR_CLID_INUSEがクライアントに返されます。サーバー上のクライアントレコードは変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Session creation. The server confirmed the client ID, either in this CREATE_SESSION operation, or a previous CREATE_SESSION operation. The server examines the remaining fields of the arguments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. セッションの作成。サーバーは、このCREATE_SESSION操作または以前のCREATE_SESSION操作でクライアントIDを確認しました。サーバーは、引数の残りのフィールドを調べます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The server creates the session by recording the parameter values used (including whether the CREATE_SESSION4_FLAG_PERSIST flag is set and has been accepted by the server) and allocating space for the session reply cache (if there is not enough space, the server returns NFS4ERR_NOSPC). For each slot in the reply cache, the server sets the sequence ID to zero, and records an entry containing a COMPOUND reply with zero operations and the error NFS4ERR_SEQ_MISORDERED. This way, if the first SEQUENCE request sent has a sequence ID equal to zero, the server can simply return what is in the reply cache: NFS4ERR_SEQ_MISORDERED. The client initializes its reply cache for receiving callbacks in the same way, and similarly, the first CB_SEQUENCE operation on a slot after session creation MUST have a sequence ID of one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
サーバーは、使用されたパラメーター値（CREATE_SESSION4_FLAG_PERSISTフラグが設定され、サーバーによって受け入れられているかどうかを含む）を記録し、セッション応答キャッシュ用のスペースを割り当てることでセッションを作成します（十分なスペースがない場合、サーバーはNFS4ERR_NOSPCを返します）。サーバーは、応答キャッシュの各スロットについて、シーケンスIDをゼロに設定し、ゼロ操作のCOMPOUND応答とエラーNFS4ERR_SEQ_MISORDEREDを含むエントリを記録します。このようにして、送信された最初のSEQUENCE要求のシーケンスIDがゼロの場合、サーバーは単に応答キャッシュにあるNFS4ERR_SEQ_MISORDEREDを返すことができます。クライアントは、同じ方法でコールバックを受信するための応答キャッシュを初期化します。同様に、セッション作成後のスロットに対する最初のCB_SEQUENCE操作には、シーケンスIDとして1が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
If the session state is created successfully, the server associates the session with the client ID provided by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
セッション状態が正常に作成されると、サーバーは、セッションをクライアントから提供されたクライアントIDに関連付けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
When a request that had CREATE_SESSION4_FLAG_CONN_RDMA set needs to be retried, the retry MUST be done on a new connection that is in non-RDMA mode. If properties of the new connection are different enough that the arguments to CREATE_SESSION need to change, then a non-retry MUST be sent. The server will eventually dispose of any session that was created on the original connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
CREATE_SESSION4_FLAG_CONN_RDMAが設定されているリクエストを再試行する必要がある場合、非RDMAモードの新しい接続で再試行を行う必要があります。新しい接続のプロパティが十分に異なり、CREATE_SESSIONの引数を変更する必要がある場合は、再試行しないで送信する必要があります。サーバーは最終的に、元の接続で作成されたセッションを破棄します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 On the backchannel, the client and server might wish to have many slots, in some cases perhaps more that the fore channel, in order to deal with the situations where the network link has high latency and is the primary bottleneck for response to recalls. If so, and if the client provides too few slots to the backchannel, the server might limit the number of recallable objects it gives to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ネットワークリンクの待ち時間が長く、リコールへの応答の主なボトルネックとなっている状況に対処するために、バックチャネルでは、クライアントとサーバーが多くのスロット、場合によってはフォアチャネルよりも多くのスロットを必要とする場合があります。その場合、クライアントがバックチャネルに提供するスロットが少なすぎると、サーバーはクライアントに提供する再呼び出し可能なオブジェクトの数を制限する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementing RPCSEC_GSS callback support requires changes to both the client and server implementations of RPCSEC_GSS. One possible set of changes includes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSSコールバックサポートを実装するには、RPCSEC_GSSのクライアント実装とサーバー実装の両方を変更する必要があります。可能な変更のセットの1つは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Adding a data structure that wraps the GSS-API context with a reference count.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GSS-APIコンテキストを参照カウントでラップするデータ構造を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o New functions to increment and decrement the reference count. If the reference count is decremented to zero, the wrapper data structure and the GSS-API context it refers to would be freed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 参照カウントを増分および減分する新しい関数。参照カウントが0に減少すると、ラッパーデータ構造とそれが参照するGSS-APIコンテキストが解放されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Change RPCSEC_GSS to create the wrapper data structure upon receiving GSS-API context from gss_accept_sec_context() and gss_init_sec_context(). The reference count would be initialized to 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o gss_accept_sec_context()およびgss_init_sec_context()からGSS-APIコンテキストを受信すると、RPCSEC_GSSを変更してラッパーデータ構造を作成します。参照カウントは1に初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Adding a function to map an existing RPCSEC_GSS handle to a pointer to the wrapper data structure. The reference count would be incremented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 既存のRPCSEC_GSSハンドルをラッパーデータ構造へのポインターにマップする関数を追加します。参照カウントは増加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Adding a function to create a new RPCSEC_GSS handle from a pointer to the wrapper data structure. The reference count would be incremented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ポインターからラッパーデータ構造への新しいRPCSEC_GSSハンドルを作成する関数を追加します。参照カウントは増加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Replacing calls from RPCSEC_GSS that free GSS-API contexts, with calls to decrement the reference count on the wrapper data structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GSS-APIコンテキストを解放するRPCSEC_GSSからの呼び出しを、ラッパーデータ構造の参照カウントをデクリメントする呼び出しに置き換えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-37--Operation-44-DESTROYSESSION---Destroy-a-Session">
18.37. Operation 44: DESTROY_SESSION - Destroy a Session
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.37. 操作44：DESTROY_SESSION-セッションを破棄します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-37-1--ARGUMENT">
18.37.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.37.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DESTROY_SESSION4args {
           sessionid4      dsa_sessionid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-37-2--RESULT">
18.37.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.37.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DESTROY_SESSION4res {
           nfsstat4        dsr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-37-3--DESCRIPTION">
18.37.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.37.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DESTROY_SESSION operation closes the session and discards the session&#39;s reply cache, if any. Any remaining connections associated with the session are immediately disassociated. If the connection has no remaining associated sessions, the connection MAY be closed by the server. Locks, delegations, layouts, wants, and the lease, which are all tied to the client ID, are not affected by DESTROY_SESSION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESTROY_SESSION操作はセッションを閉じ、セッションの応答キャッシュがあればそれを破棄します。セッションに関連付けられている残りの接続は、すぐに関連付けが解除されます。接続に関連するセッションが残っていない場合、接続はサーバーによって閉じられる場合があります。すべてクライアントIDに関連付けられているロック、委任、レイアウト、要求、およびリースは、DESTROY_SESSIONの影響を受けません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESTROY_SESSION MUST be invoked on a connection that is associated with the session being destroyed. In addition, if SP4_MACH_CRED state protection was specified when the client ID was created, the RPCSEC_GSS principal that created the session MUST be the one that destroys the session, using RPCSEC_GSS privacy or integrity. If SP4_SSV state protection was specified when the client ID was created, RPCSEC_GSS using the SSV mechanism (Section 2.10.9) MUST be used, with integrity or privacy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
破棄するセッションに関連付けられている接続でDESTROY_SESSIONを呼び出す必要があります。さらに、クライアントIDの作成時にSP4_MACH_CRED状態保護が指定されている場合、セッションを作成したRPCSEC_GSSプリンシパルは、RPCSEC_GSSプライバシーまたは整合性を使用して、セッションを破棄するものでなければなりません（MUST）。クライアントIDの作成時にSP4_SSV状態保護が指定されていた場合は、SSVメカニズム（2.10.9節）を使用するRPCSEC_GSSを使用して、整合性またはプライバシーを確​​保する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the COMPOUND request starts with SEQUENCE, and if the sessionids specified in SEQUENCE and DESTROY_SESSION are the same, then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDリクエストがSEQUENCEで始まる場合、およびSEQUENCEとDESTROY_SESSIONで指定されたセッションIDが同じ場合、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DESTROY_SESSION MUST be the final operation in the COMPOUND request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DESTROY_SESSIONは、COMPOUNDリクエストの最後の操作である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It is advisable to avoid placing DESTROY_SESSION in a COMPOUND request with other state-modifying operations, because the DESTROY_SESSION will destroy the reply cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DESTROY_SESSIONは応答キャッシュを破棄するため、他の状態変更操作を伴うCOMPOUNDリクエストにDESTROY_SESSIONを配置しないことをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Because the session and its reply cache are destroyed, a client that retries the request may receive an error in reply to the retry, even though the original request was successful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セッションとその応答キャッシュが破棄されるため、要求を再試行するクライアントは、元の要求が成功した場合でも、再試行に対する応答でエラーを受け取ることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the COMPOUND request starts with SEQUENCE, and if the sessionids specified in SEQUENCE and DESTROY_SESSION are different, then DESTROY_SESSION can appear in any position of the COMPOUND request (except for the first position). The two sessionids can belong to different client IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND要求がSEQUENCEで始まる場合、およびSEQUENCEとDESTROY_SESSIONで指定されたセッションIDが異なる場合、DESTROY_SESSIONはCOMPOUND要求の任意の位置（最初の位置を除く）に表示されます。 2つのセッションIDは、異なるクライアントIDに属することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the COMPOUND request does not start with SEQUENCE, and if DESTROY_SESSION is not the sole operation, then server MUST return NFS4ERR_NOT_ONLY_OP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND要求がSEQUENCEで始まらない場合、およびDESTROY_SESSIONが唯一の操作ではない場合、サーバーはNFS4ERR_NOT_ONLY_OPを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If there is a backchannel on the session and the server has outstanding CB_COMPOUND operations for the session which have not been replied to, then the server MAY refuse to destroy the session and return an error. If so, then in the event the backchannel is down, the server SHOULD return NFS4ERR_CB_PATH_DOWN to inform the client that the backchannel needs to be repaired before the server will allow the session to be destroyed. Otherwise, the error CB_BACK_CHAN_BUSY SHOULD be returned to indicate that there are CB_COMPOUNDs that need to be replied to. The client SHOULD reply to all outstanding CB_COMPOUNDs before re-sending DESTROY_SESSION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
セッションにバックチャネルがあり、サーバーが応答していないセッションに対して未処理のCB_COMPOUND操作を持っている場合、サーバーはセッションの破棄を拒否してエラーを返す場合があります。その場合、バックチャネルがダウンしている場合、サーバーはNFS4ERR_CB_PATH_DOWNを返し、サーバーがセッションの破棄を許可する前にバックチャネルを修復する必要があることをクライアントに通知する必要があります（SHOULD）。それ以外の場合、エラーCB_BACK_CHAN_BUSYを返して、応答する必要があるCB_COMPOUNDがあることを示します。クライアントは、DESTROY_SESSIONを再送信する前に、すべての未解決のCB_COMPOUNDに応答する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-38--Operation-45-FREESTATEID---Free-Stateid-with-No-Locks">
18.38. Operation 45: FREE_STATEID - Free Stateid with No Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.38. 操作45：FREE_STATEID-ロックのない無料のStateid
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-38-1--ARGUMENT">
18.38.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.38.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct FREE_STATEID4args {
           stateid4        fsa_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-38-2--RESULT">
18.38.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.38.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct FREE_STATEID4res {
           nfsstat4        fsr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-38-3--DESCRIPTION">
18.38.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.38.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The FREE_STATEID operation is used to free a stateid that no longer has any associated locks (including opens, byte-range locks, delegations, and layouts). This may be because of client LOCKU operations or because of server revocation. If there are valid locks (of any kind) associated with the stateid in question, the error NFS4ERR_LOCKS_HELD will be returned, and the associated stateid will not be freed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FREE_STATEID操作は、関連付けられたロック（オープン、バイト範囲ロック、委任、およびレイアウトを含む）がなくなった状態IDを解放するために使用されます。これは、クライアントのLOCKU操作またはサーバーの取り消しが原因である可能性があります。問題のステートIDに関連付けられた（任意の種類の）有効なロックがある場合、エラーNFS4ERR_LOCKS_HELDが返され、関連付けられたステートIDは解放されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a stateid is freed that had been associated with revoked locks, by sending the FREE_STATEID operation, the client acknowledges the loss of those locks. This allows the server, once all such revoked state is acknowledged, to allow that client again to reclaim locks, without encountering the edge conditions discussed in Section 8.4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
取り消されたロックに関連付けられていたstateidが解放されると、FREE_STATEID操作を送信することにより、クライアントはそれらのロックが失われたことを確認します。これにより、サーバーは、取り消された状態がすべて確認されると、セクション8.4.2で説明したエッジ条件に遭遇することなく、クライアントが再びロックを再要求できるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a successful FREE_STATEID is done for a given stateid, any subsequent use of that stateid will result in an NFS4ERR_BAD_STATEID error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所定のstateidに対してFREE_STATEIDが正常に実行されると、その後そのstateidを使用すると、NFS4ERR_BAD_STATEIDエラーが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-39--Operation-46-GETDIRDELEGATION---Get-a-Directory-Delegation">
18.39. Operation 46: GET_DIR_DELEGATION - Get a Directory Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.39. 操作46：GET_DIR_DELEGATION-ディレクトリの委任を取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-39-1--ARGUMENT">
18.39.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.39.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef nfstime4 attr_notice4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef nfstime4 attr_notice4;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GET_DIR_DELEGATION4args {
           /* CURRENT_FH: delegated directory */
           bool            gdda_signal_deleg_avail;
           bitmap4         gdda_notification_types;
           attr_notice4    gdda_child_attr_delay;
           attr_notice4    gdda_dir_attr_delay;
           bitmap4         gdda_child_attributes;
           bitmap4         gdda_dir_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-39-2--RESULT">
18.39.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.39.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GET_DIR_DELEGATION4resok {
           verifier4       gddr_cookieverf;
           /* Stateid for get_dir_delegation */
           stateid4        gddr_stateid;
           /* Which notifications can the server support */
           bitmap4         gddr_notification;
           bitmap4         gddr_child_attributes;
           bitmap4         gddr_dir_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum gddrnf4_status {
           GDD4_OK         = 0,
           GDD4_UNAVAIL    = 1
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union GET_DIR_DELEGATION4res_non_fatal
    switch (gddrnf4_status gddrnf_status) {
    case GDD4_OK:
     GET_DIR_DELEGATION4resok      gddrnf_resok4;
    case GDD4_UNAVAIL:
     bool                          gddrnf_will_signal_deleg_avail;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union GET_DIR_DELEGATION4res
    switch (nfsstat4 gddr_status) {
    case NFS4_OK:
     GET_DIR_DELEGATION4res_non_fatal      gddr_res_non_fatal4;
    default:
     void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-39-3--DESCRIPTION">
18.39.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.39.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The GET_DIR_DELEGATION operation is used by a client to request a directory delegation. The directory is represented by the current filehandle. The client also specifies whether it wants the server to notify it when the directory changes in certain ways by setting one or more bits in a bitmap. The server may refuse to grant the delegation. In that case, the server will return NFS4ERR_DIRDELEG_UNAVAIL. If the server decides to hand out the delegation, it will return a cookie verifier for that directory. If the cookie verifier changes when the client is holding the delegation, the delegation will be recalled unless the client has asked for notification for this event.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GET_DIR_DELEGATION操作は、ディレクトリ委任を要求するためにクライアントによって使用されます。ディレクトリは、現在のファイルハンドルによって表されます。また、クライアントは、ビットマップに1つ以上のビットを設定して、ディレクトリが特定の方法で変更されたときにサーバーに通知するかどうかを指定します。サーバーは委任の許可を拒否する場合があります。その場合、サーバーはNFS4ERR_DIRDELEG_UNAVAILを返します。サーバーが委任を渡すことを決定した場合、サーバーはそのディレクトリのCookieベリファイアを返します。クライアントが委任を保持しているときにCookieベリファイアが変更されると、クライアントがこのイベントの通知を要求しない限り、委任は取り消されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server will also return a directory delegation stateid, gddr_stateid, as a result of the GET_DIR_DELEGATION operation. This stateid will appear in callback messages related to the delegation, such as notifications and delegation recalls. The client will use this stateid to return the delegation voluntarily or upon recall. A delegation is returned by calling the DELEGRETURN operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、GET_DIR_DELEGATION操作の結果として、ディレクトリ委任の状態IDであるgddr_stateidも返します。この状態IDは、通知や委任の取り消しなど、委任に関連するコールバックメッセージに表示されます。クライアントはこのステートIDを使用して、自発的またはリコール時に委任を返します。 DELEGRETURN操作を呼び出すと、委任が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server might not be able to support notifications of certain events. If the client asks for such notifications, the server MUST inform the client of its inability to do so as part of the GET_DIR_DELEGATION reply by not setting the appropriate bits in the supported notifications bitmask, gddr_notification, contained in the reply. The server MUST NOT add bits to gddr_notification that the client did not request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、特定のイベントの通知をサポートできない場合があります。クライアントがそのような通知を要求する場合、サーバーは、応答に含まれるサポートされる通知ビットマスクであるgddr_notificationに適切なビットを設定しないことにより、GET_DIR_DELEGATION応答の一部として通知できないことをクライアントに通知する必要があります。サーバーは、クライアントが要求しなかったビットをgddr_notificationに追加してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The GET_DIR_DELEGATION operation can be used for both normal and named attribute directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GET_DIR_DELEGATION操作は、通常の属性ディレクトリと名前付き属性ディレクトリの両方に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If client sets gdda_signal_deleg_avail to TRUE, then it is registering with the client a &#34;want&#34; for a directory delegation. If the delegation is not available, and the server supports and will honor the &#34;want&#34;, the results will have gddrnf_will_signal_deleg_avail set to TRUE and no error will be indicated on return. If so, the client should expect a future CB_RECALLABLE_OBJ_AVAIL operation to indicate that a directory delegation is available. If the server does not wish to honor the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがgdda_signal_deleg_availをTRUEに設定した場合、クライアントはディレクトリ委任の「希望」をクライアントに登録しています。委任が利用できず、サーバーが &#34;want&#34;をサポートして受け入れる場合、結果はgddrnf_will_signal_deleg_availをTRUEに設定し、戻り時にエラーは示されません。その場合、クライアントは将来のCB_RECALLABLE_OBJ_AVAIL操作を期待して、ディレクトリの委任が利用可能であることを示す必要があります。サーバーがを受け入れたくない場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;want&#34; or is not able to do so, it returns the error NFS4ERR_DIRDELEG_UNAVAIL. If the delegation is immediately available, the server SHOULD return it with the response to the operation, rather than via a callback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「したい」またはそれができない場合は、エラーNFS4ERR_DIRDELEG_UNAVAILを返します。委任がすぐに利用できる場合、サーバーは、コールバック経由ではなく、操作への応答とともにそれを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client makes a request for a directory delegation while it already holds a directory delegation for that directory (including the case where it has been recalled but not yet returned by the client or revoked by the server), the server MUST reply with the value of gddr_status set to NFS4_OK, the value of gddrnf_status set to GDD4_UNAVAIL, and the value of gddrnf_will_signal_deleg_avail set to FALSE. The delegation the client held before the request remains intact, and its state is unchanged. The current stateid is not changed (see Section 16.2.3.1.2 for a description of the current stateid).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがディレクトリ委譲をすでに要求しているときに、そのディレクトリの委任を保持している場合（クライアントによって呼び出されたが、まだクライアントから返されていないか、サーバーによって取り消されていない場合を含む）、サーバーは値で応答する必要があります。 gddr_statusをNFS4_OKに設定し、gddrnf_statusの値をGDD4_UNAVAILに設定し、gddrnf_will_signal_deleg_availの値をFALSEに設定します。リクエストの前にクライアントが保持していた委任はそのまま残り、その状態は変更されません。現在の状態IDは変更されません（現在の状態IDの説明については、セクション16.2.3.1.2を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-39-4--IMPLEMENTATION">
18.39.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.39.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Directory delegations provide the benefit of improving cache consistency of namespace information. This is done through synchronous callbacks. A server must support synchronous callbacks in order to support directory delegations. In addition to that, asynchronous notifications provide a way to reduce network traffic as well as improve client performance in certain conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ディレクトリ委任には、名前空間情報のキャッシュの一貫性を向上させるという利点があります。これは同期コールバックを通じて行われます。サーバーは、ディレクトリの委任をサポートするために同期コールバックをサポートする必要があります。さらに、非同期通知は、ネットワークトラフィックを削減し、特定の状況でのクライアントのパフォーマンスを向上させる方法を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notifications are specified in terms of potential changes to the directory. A client can ask to be notified of events by setting one or more bits in gdda_notification_types. The client can ask for notifications on addition of entries to a directory (by setting the NOTIFY4_ADD_ENTRY in gdda_notification_types), notifications on entry removal (NOTIFY4_REMOVE_ENTRY), renames (NOTIFY4_RENAME_ENTRY), directory attribute changes (NOTIFY4_CHANGE_DIR_ATTRIBUTES), and cookie verifier changes (NOTIFY4_CHANGE_COOKIE_VERIFIER) by setting one or more corresponding bits in the gdda_notification_types field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知は、ディレクトリへの潜在的な変更に関して指定されます。クライアントは、gdda_notification_typesに1つ以上のビットを設定することにより、イベントの通知を要求できます。クライアントは、（gdda_notification_typesでNOTIFY4_ADD_ENTRYを設定することにより）ディレクトリへのエントリの追加に関する通知、エントリの削除に関する通知（NOTIFY4_REMOVE_ENTRY）、名前の変更（NOTIFY4_RENAME_ENTRY）、ディレクトリ属性の変更（NOTIFY4_CHANGE_DIR_ATTRIBUTES_）を要求できます。 gdda_notification_typesフィールドに1つ以上の対応するビットを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client can also ask for notifications of changes to attributes of directory entries (NOTIFY4_CHANGE_CHILD_ATTRIBUTES) in order to keep its attribute cache up to date. However, any changes made to child attributes do not cause the delegation to be recalled. If a client is interested in directory entry caching or negative name caching, it can set the gdda_notification_types appropriately to its particular need and the server will notify it of all changes that would otherwise invalidate its name cache. The kind of notification a client asks for may depend on the directory size, its rate of change, and the applications being used to access that directory. The enumeration of the conditions under which a client might ask for a notification is out of the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、属性キャッシュを最新の状態に保つために、ディレクトリエントリ（NOTIFY4_CHANGE_CHILD_ATTRIBUTES）の属性に対する変更の通知を要求することもできます。ただし、子属性に変更を加えても、委任は取り消されません。クライアントがディレクトリエントリキャッシングまたはネガティブネームキャッシングに関心がある場合、クライアントは特定の必要性に応じてgdda_notification_typesを適切に設定でき、サーバーは名前キャッシュを無効にするすべての変更を通知します。クライアントが要求する通知の種類は、ディレクトリサイズ、その変更率、およびそのディレクトリへのアクセスに使用されているアプリケーションによって異なります。クライアントが通知を要求する可能性のある条件の列挙は、この仕様の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For attribute notifications, the client will set bits in the gdda_dir_attributes bitmap to indicate which attributes it wants to be notified of. If the server does not support notifications for changes to a certain attribute, it SHOULD NOT set that attribute in the supported attribute bitmap specified in the reply (gddr_dir_attributes). The client will also set in the gdda_child_attributes bitmap the attributes of directory entries it wants to be notified of, and the server will indicate in gddr_child_attributes which attributes of directory entries it will notify the client of.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性通知の場合、クライアントはgdda_dir_attributesビットマップにビットを設定して、通知する属性を示します。サーバーが特定の属性への変更の通知をサポートしていない場合は、応答で指定されているサポートされている属性ビットマップ（gddr_dir_attributes）にその属性を設定しないでください（SHOULD NOT）。クライアントは、gdda_child_attributesビットマップで、通知するディレクトリエントリの属性も設定し、サーバーは、クライアントに通知するディレクトリエントリの属性をgddr_child_attributesで示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client will also let the server know if it wants to get the notification as soon as the attribute change occurs or after a certain delay by setting a delay factor; gdda_child_attr_delay is for attribute changes to directory entries and gdda_dir_attr_delay is for attribute changes to the directory. If this delay factor is set to zero, that indicates to the server that the client wants to be notified of any attribute changes as soon as they occur. If the delay factor is set to N seconds, the server will make a best-effort guarantee that attribute updates are synchronized within N seconds. If the client asks for a delay factor that the server does not support or that may cause significant resource consumption on the server by causing the server to send a lot of notifications, the server should not commit to sending out notifications for attributes and therefore must not set the appropriate bit in the gddr_child_attributes and gddr_dir_attributes bitmaps in the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、クライアントは、属性の変更が発生した直後に、または遅延係数を設定して特定の遅延の後に通知を取得するかどうかをサーバーに通知します。 gdda_child_attr_delayはディレクトリエントリの属性変更用で、gdda_dir_attr_delayはディレクトリの属性変更用です。この遅延係数がゼロに設定されている場合は、属性の変更が発生したらすぐにクライアントに通知することをサーバーに要求します。遅延係数がN秒に設定されている場合、サーバーは、属性の更新がN秒以内に同期されることをベストエフォートで保証します。クライアントがサーバーがサポートしていない、またはサーバーに大量の通知を送信させることによりサーバー上でかなりのリソース消費を引き起こす可能性がある遅延要因を要求する場合、サーバーは属性の通知の送信にコミットしてはならないため、応答のgddr_child_attributesおよびgddr_dir_attributesビットマップに適切なビットを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MUST use a security tuple (Section 2.6.1) that the directory or its applicable ancestor (Section 2.6) is exported with. If not, the server MUST return NFS4ERR_WRONGSEC to the operation that both precedes GET_DIR_DELEGATION and sets the current filehandle (see Section 2.6.3.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、ディレクトリまたはその適用可能な祖先（セクション2.6）のエクスポートに使用されるセキュリティタプル（セクション2.6.1）を使用する必要があります。そうでない場合、サーバーはNFS4ERR_WRONGSECをGET_DIR_DELEGATIONに先行する操作と現在のファイルハンドルを設定する操作の両方に返す必要があります（セクション2.6.3.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The directory delegation covers all the entries in the directory except the parent entry. That means if a directory and its parent both hold directory delegations, any changes to the parent will not cause a notification to be sent for the child even though the child&#39;s parent entry points to the parent directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ディレクトリの委任は、親エントリを除くディレクトリ内のすべてのエントリをカバーします。つまり、ディレクトリとその親の両方がディレクトリ委任を保持している場合、子の親エントリが親ディレクトリを指していても、親への変更によって子に通知が送信されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-40--Operation-47-GETDEVICEINFO---Get-Device-Information">
18.40. Operation 47: GETDEVICEINFO - Get Device Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.40. 操作47：GETDEVICEINFO-デバイス情報の取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-40-1--ARGUMENT">
18.40.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.40.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETDEVICEINFO4args {
           deviceid4       gdia_device_id;
           layouttype4     gdia_layout_type;
           count4          gdia_maxcount;
           bitmap4         gdia_notify_types;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-40-2--RESULT">
18.40.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.40.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETDEVICEINFO4resok {
           device_addr4    gdir_device_addr;
           bitmap4         gdir_notification;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union GETDEVICEINFO4res switch (nfsstat4 gdir_status) {
   case NFS4_OK:
           GETDEVICEINFO4resok     gdir_resok4;
   case NFS4ERR_TOOSMALL:
           count4                  gdir_mincount;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-40-3--DESCRIPTION">
18.40.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.40.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The GETDEVICEINFO operation returns pNFS storage device address information for the specified device ID. The client identifies the device information to be returned by providing the gdia_device_id and gdia_layout_type that uniquely identify the device. The client provides gdia_maxcount to limit the number of bytes for the result. This maximum size represents all of the data being returned within the GETDEVICEINFO4resok structure and includes the XDR overhead. The server may return less data. If the server is unable to return any information within the gdia_maxcount limit, the error NFS4ERR_TOOSMALL will be returned. However, if gdia_maxcount is zero, NFS4ERR_TOOSMALL MUST NOT be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETDEVICEINFO操作は、指定されたデバイスIDのpNFSストレージデバイスアドレス情報を返します。クライアントは、デバイスを一意に識別するgdia_device_idおよびgdia_layout_typeを提供することにより、返されるデバイス情報を識別します。クライアントはgdia_maxcountを提供して、結果のバイト数を制限します。この最大サイズは、GETDEVICEINFO4resok構造内で返されるすべてのデータを表し、XDRオーバーヘッドが含まれます。サーバーが返すデータが少なくなる場合があります。サーバーがgdia_maxcount制限内の情報を返すことができない場合、エラーNFS4ERR_TOOSMALLが返されます。ただし、gdia_maxcountがゼロの場合、NFS4ERR_TOOSMALLを返してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The da_layout_type field of the gdir_device_addr returned by the server MUST be equal to the gdia_layout_type specified by the client. If it is not equal, the client SHOULD ignore the response as invalid and behave as if the server returned an error, even if the client does have support for the layout type returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーによって返されるgdir_device_addrのda_layout_typeフィールドは、クライアントによって指定されたgdia_layout_typeと等しい必要があります。等しくない場合、クライアントは返されたレイアウトタイプをサポートしていても、応答を無効として無視し、サーバーがエラーを返したかのように動作する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client also provides a notification bitmap, gdia_notify_types, for the device ID mapping notification for which it is interested in receiving; the server must support device ID notifications for the notification request to have affect. The notification mask is composed in the same manner as the bitmap for file attributes (Section 3.3.7). The numbers of bit positions are listed in the notify_device_type4 enumeration type (Section 20.12). Only two enumerated values of notify_device_type4 currently apply to GETDEVICEINFO: NOTIFY_DEVICEID4_CHANGE and NOTIFY_DEVICEID4_DELETE (see Section 20.12).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、受信に関心のあるデバイスIDマッピング通知用の通知ビットマップgdia_notify_typesも提供します。通知リクエストが影響を与えるには、サーバーがデバイスID通知をサポートしている必要があります。通知マスクは、ファイル属性のビットマップと同じ方法で構成されます（セクション3.3.7）。ビット位置の数は、notify_device_type4列挙型（セクション20.12）にリストされています。現在、GETDEVICEINFOに適用されるnotify_device_type4の2つの列挙値、NOTIFY_DEVICEID4_CHANGEおよびNOTIFY_DEVICEID4_DELETE（セクション20.12を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notification bitmap applies only to the specified device ID. If a client sends a GETDEVICEINFO operation on a deviceID multiple times, the last notification bitmap is used by the server for subsequent notifications. If the bitmap is zero or empty, then the device ID&#39;s notifications are turned off.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知ビットマップは、指定されたデバイスIDにのみ適用されます。クライアントが1つのdeviceIDに対してGETDEVICEINFO操作を複数回送信すると、サーバーは最後の通知ビットマップを使用して後続の通知を行います。ビットマップがゼロまたは空の場合、デバイスIDの通知はオフになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client wants to just update or turn off notifications, it MAY send a GETDEVICEINFO operation with gdia_maxcount set to zero. In that event, if the device ID is valid, the reply&#39;s da_addr_body field of the gdir_device_addr field will be of zero length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが通知を単に更新またはオフにする場合は、gdia_maxcountをゼロに設定してGETDEVICEINFO操作を送信できます（MAY）。その場合、デバイスIDが有効であれば、応答のgdir_device_addrフィールドのda_addr_bodyフィールドの長さがゼロになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an unknown device ID is given in gdia_device_id, the server returns NFS4ERR_NOENT. Otherwise, the device address information is returned in gdir_device_addr. Finally, if the server supports notifications for device ID mappings, the gdir_notification result will contain a bitmap of which notifications it will actually send to the client (via CB_NOTIFY_DEVICEID, see Section 20.12).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不明なデバイスIDがgdia_device_idで指定されている場合、サーバーはNFS4ERR_NOENTを返します。それ以外の場合、デバイスアドレス情報はgdir_device_addrに返されます。最後に、サーバーがデバイスIDマッピングの通知をサポートしている場合、gdir_notificationの結果には、実際にクライアントに送信する通知のビットマップが含まれます（CB_NOTIFY_DEVICEIDを介して、セクション20.12を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If NFS4ERR_TOOSMALL is returned, the results also contain gdir_mincount. The value of gdir_mincount represents the minimum size necessary to obtain the device information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_TOOSMALLが返される場合、結果にはgdir_mincountも含まれます。 gdir_mincountの値は、デバイス情報を取得するために必要な最小サイズを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-40-4--IMPLEMENTATION">
18.40.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.40.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Aside from updating or turning off notifications, another use case for gdia_maxcount being set to zero is to validate a device ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知を更新またはオフにする以外に、gdia_maxcountをゼロに設定する別のユースケースは、デバイスIDを検証することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client SHOULD request a notification for changes or deletion of a device ID to device address mapping so that the server can allow the client gracefully use a new mapping, without having pending I/O fail abruptly, or force layouts using the device ID to be recalled or revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、デバイスIDからデバイスアドレスへのマッピングの変更または削除の通知を要求する必要があります。これにより、サーバーは、保留中のI / Oが突然失敗することなく、クライアントが新しいマッピングを適切に使用できるようにしたり、デバイスIDを使用してレイアウトを強制したりできます。リコールまたは取り消されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 It is possible that GETDEVICEINFO (and GETDEVICELIST) will race with CB_NOTIFY_DEVICEID, i.e., CB_NOTIFY_DEVICEID arrives before the client gets and processes the response to GETDEVICEINFO or GETDEVICELIST. The analysis of the race leverages the fact that the server MUST NOT delete a device ID that is referred to by a layout the client has.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
GETDEVICEINFO（およびGETDEVICELIST）がCB_NOTIFY_DEVICEIDと競合する可能性があります。つまり、クライアントがGETDEVICEINFOまたはGETDEVICELISTへの応答を取得して処理する前にCB_NOTIFY_DEVICEIDが到着します。レースの分析は、サーバーがクライアントが持っているレイアウトによって参照されるデバイスIDを削除してはならないという事実を利用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o CB_NOTIFY_DEVICEID deletes a device ID. If the client believes it has layouts that refer to the device ID, then it is possible that layouts referring to the deleted device ID have been revoked. The client should send a TEST_STATEID request using the stateid for each layout that might have been revoked. If TEST_STATEID indicates that any layouts have been revoked, the client must recover from layout revocation as described in Section 12.5.6. If TEST_STATEID indicates that at least one layout has not been revoked, the client should send a GETDEVICEINFO operation on the supposedly deleted device ID to verify that the device ID has been deleted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o CB_NOTIFY_DEVICEIDはデバイスIDを削除します。デバイスIDを参照するレイアウトがあるとクライアントが確信している場合、削除されたデバイスIDを参照するレイアウトが取り消されている可能性があります。クライアントは、取り消された可能性のある各レイアウトのstateidを使用してTEST_STATEIDリクエストを送信する必要があります。 TEST_STATEIDがレイアウトが取り消されたことを示している場合、クライアントはセクション12.5.6で説明されているようにレイアウトの取り消しから回復する必要があります。 TEST_STATEIDが、少なくとも1つのレイアウトが取り消されていないことを示している場合、クライアントは、削除されたと思われるデバイスIDにGETDEVICEINFO操作を送信して、デバイスIDが削除されたことを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If GETDEVICEINFO indicates that the device ID does not exist, then the client assumes the server is faulty and recovers by sending an EXCHANGE_ID operation. If GETDEVICEINFO indicates that the device ID does exist, then while the server is faulty for sending an erroneous device ID deletion notification, the degree to which it is faulty does not require the client to create a new client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
GETDEVICEINFOがデバイスIDが存在しないことを示している場合、クライアントはサーバーに障害があると見なし、EXCHANGE_ID操作を送信して回復します。 GETDEVICEINFOがデバイスIDが存在することを示している場合、サーバーが誤ったデバイスID削除通知を送信するための障害が発生している間、その障害の程度によって、クライアントが新しいクライアントIDを作成する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the client does not have layouts that refer to the device ID, no harm is done. The client should mark the device ID as deleted, and when GETDEVICEINFO or GETDEVICELIST results are received that indicate that the device ID has been in fact deleted, the device ID should be removed from the client&#39;s cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントにデバイスIDを参照するレイアウトがない場合、害はありません。クライアントはデバイスIDを削除済みとしてマークする必要があり、デバイスIDが実際に削除されたことを示すGETDEVICEINFOまたはGETDEVICELISTの結果を受け取ったら、デバイスIDをクライアントのキャッシュから削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o CB_NOTIFY_DEVICEID indicates that a device ID&#39;s device addressing mappings have changed. The client should assume that the results from the in-progress GETDEVICEINFO will be stale for the device ID once received, and so it should send another GETDEVICEINFO on the device ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o CB_NOTIFY_DEVICEIDは、デバイスIDのデバイスアドレス指定マッピングが変更されたことを示します。クライアントは、進行中のGETDEVICEINFOからの結果が受信されるとデバイスIDに対して失効すると想定する必要があるため、デバイスIDで別のGETDEVICEINFOを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
18.41. Operation 48: GETDEVICELIST - Get All Device Mappings for a File System
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
18.41. 操作48：GETDEVICELIST-ファイルシステムのすべてのデバイスマッピングを取得する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-41-1--ARGUMENT">
18.41.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.41.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETDEVICELIST4args {
           /* CURRENT_FH: object belonging to the file system */
           layouttype4     gdla_layout_type;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* number of deviceIDs to return */
           count4          gdla_maxdevices;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           nfs_cookie4     gdla_cookie;
           verifier4       gdla_cookieverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-41-2--RESULT">
18.41.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.41.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETDEVICELIST4resok {
           nfs_cookie4             gdlr_cookie;
           verifier4               gdlr_cookieverf;
           deviceid4               gdlr_deviceid_list&lt;&gt;;
           bool                    gdlr_eof;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union GETDEVICELIST4res switch (nfsstat4 gdlr_status) {
   case NFS4_OK:
           GETDEVICELIST4resok     gdlr_resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-41-3--DESCRIPTION">
18.41.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.41.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used by the client to enumerate all of the device IDs that a server&#39;s file system uses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはこの操作を使用して、サーバーのファイルシステムが使用するすべてのデバイスIDを列挙します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The client provides a current filehandle of a file object that belongs to the file system (i.e., all file objects sharing the same fsid as that of the current filehandle) and the layout type in gdia_layout_type. Since this operation might require multiple calls to enumerate all the device IDs (and is thus similar to the READDIR (Section 18.23) operation), the client also provides gdia_cookie and gdia_cookieverf to specify the current cursor position in the list. When the client wants to read from the beginning of the file system&#39;s device mappings, it sets gdla_cookie to zero. The field gdla_cookieverf MUST be ignored by the server when gdla_cookie is zero. The client provides gdla_maxdevices to limit the number of device IDs in the result. If gdla_maxdevices is zero, the server MUST return NFS4ERR_INVAL. The server MAY return fewer device IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントは、ファイルシステムに属するファイルオブジェクトの現在のファイルハンドル（つまり、現在のファイルハンドルと同じfsidを共有するすべてのファイルオブジェクト）およびgdia_layout_typeのレイアウトタイプを提供します。この操作では、すべてのデバイスIDを列挙するために複数の呼び出しが必要になる場合があるため（READDIR（セクション18.23）操作と同様）、クライアントはgdia_cookieおよびgdia_cookieverfを提供して、リスト内の現在のカーソル位置を指定します。クライアントがファイルシステムのデバイスマッピングの最初から読み取る場合、gdla_cookieをゼロに設定します。 gdla_cookieがゼロの場合、フィールドgdla_cookieverfはサーバーによって無視される必要があります。クライアントはgdla_maxdevicesを提供して、結果のデバイスIDの数を制限します。 gdla_maxdevicesがゼロの場合、サーバーはNFS4ERR_INVALを返さなければなりません（MUST）。サーバーは、より少ないデバイスIDを返す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The successful response to the operation will contain the cookie, gdlr_cookie, and the cookie verifier, gdlr_cookieverf, to be used on the subsequent GETDEVICELIST. A gdlr_eof value of TRUE signifies that there are no remaining entries in the server&#39;s device list. Each element of gdlr_deviceid_list contains a device ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作に対する正常な応答には、後続のGETDEVICELISTで使用されるcookie、gdlr_cookie、およびcookieベリファイア、gdlr_cookieverfが含まれます。 gdlr_eof値がTRUEの場合は、サーバーのデバイスリストにエントリが残っていないことを示します。 gdlr_deviceid_listの各要素には、デバイスIDが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-41-4--IMPLEMENTATION">
18.41.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.41.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example of the use of this operation is for pNFS clients and servers that use LAYOUT4_BLOCK_VOLUME layouts. In these environments it may be helpful for a client to determine device accessibility upon first file system access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作の使用例は、LAYOUT4_BLOCK_VOLUMEレイアウトを使用するpNFSクライアントおよびサーバーの場合です。これらの環境では、クライアントが最初のファイルシステムアクセス時にデバイスのアクセス可能性を判断することが役立つ場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-42--Operation-49-LAYOUTCOMMIT---Commit-Writes-Made-Using-a-Layout">
18.42. Operation 49: LAYOUTCOMMIT - Commit Writes Made Using a Layout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.42. 操作49：LAYOUTCOMMIT-レイアウトを使用して行われた書き込みのコミット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-42-1--ARGUMENT">
18.42.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.42.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union newtime4 switch (bool nt_timechanged) {
   case TRUE:
           nfstime4           nt_time;
   case FALSE:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union newoffset4 switch (bool no_newoffset) {
   case TRUE:
           offset4           no_offset;
   case FALSE:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LAYOUTCOMMIT4args {
           /* CURRENT_FH: file */
           offset4                 loca_offset;
           length4                 loca_length;
           bool                    loca_reclaim;
           stateid4                loca_stateid;
           newoffset4              loca_last_write_offset;
           newtime4                loca_time_modify;
           layoutupdate4           loca_layoutupdate;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-42-2--RESULT">
18.42.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.42.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union newsize4 switch (bool ns_sizechanged) {
   case TRUE:
           length4         ns_size;
   case FALSE:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LAYOUTCOMMIT4resok {
           newsize4                locr_newsize;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LAYOUTCOMMIT4res switch (nfsstat4 locr_status) {
   case NFS4_OK:
           LAYOUTCOMMIT4resok      locr_resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-42-3--DESCRIPTION">
18.42.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.42.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LAYOUTCOMMIT operation commits changes in the layout represented by the current filehandle, client ID (derived from the session ID in the preceding SEQUENCE operation), byte-range, and stateid. Since layouts are sub-dividable, a smaller portion of a layout, retrieved via LAYOUTGET, can be committed. The byte-range being committed is specified through the byte-range (loca_offset and loca_length). This byte-range MUST overlap with one or more existing layouts previously granted via LAYOUTGET (Section 18.43), each with an iomode of LAYOUTIOMODE4_RW. In the case where the iomode of any held layout segment is not LAYOUTIOMODE4_RW, the server should return the error NFS4ERR_BAD_IOMODE. For the case where the client does not hold matching layout segment(s) for the defined byte-range, the server should return the error NFS4ERR_BAD_LAYOUT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTCOMMIT操作は、現在のファイルハンドル、クライアントID（前のSEQUENCE操作のセッションIDから派生）、バイト範囲、および状態IDで表されるレイアウトの変更をコミットします。レイアウトは分割可能であるため、LAYOUTGETを介して取得したレイアウトのより小さな部分をコミットできます。コミットされるバイト範囲は、バイト範囲（loca_offsetおよびloca_length）によって指定されます。このバイト範囲は、それぞれがLAYOUTIOMODE4_RWのiomodeを持つLAYOUTGET（セクション18.43）を介して以前に許可された1つ以上の既存のレイアウトと重複する必要があります。保持されているレイアウトセグメントのiomodeがLAYOUTIOMODE4_RWではない場合、サーバーはエラーNFS4ERR_BAD_IOMODEを返す必要があります。クライアントが定義されたバイト範囲の一致するレイアウトセグメントを保持していない場合、サーバーはエラーNFS4ERR_BAD_LAYOUTを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LAYOUTCOMMIT operation indicates that the client has completed writes using a layout obtained by a previous LAYOUTGET. The client may have only written a subset of the data range it previously requested. LAYOUTCOMMIT allows it to commit or discard provisionally allocated space and to update the server with a new end-of-file. The layout referenced by LAYOUTCOMMIT is still valid after the operation completes and can be continued to be referenced by the client ID, filehandle, byte-range, layout type, and stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTCOMMIT操作は、クライアントが以前のLAYOUTGETで取得したレイアウトを使用して書き込みを完了したことを示します。クライアントは、以前に要求したデータ範囲のサブセットのみを書き込んだ可能性があります。 LAYOUTCOMMITを使用すると、暫定的に割り当てられたスペースをコミットまたは破棄し、サーバーを新しいファイルの終わりで更新できます。 LAYOUTCOMMITによって参照されるレイアウトは、操作が完了した後も引き続き有効であり、クライアントID、ファイルハンドル、バイト範囲、レイアウトタイプ、およびステートIDによって引き続き参照できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If the loca_reclaim field is set to TRUE, this indicates that the client is attempting to commit changes to a layout after the restart of the metadata server during the metadata server&#39;s recovery grace period (see Section 12.7.4). This type of request may be necessary when the client has uncommitted writes to provisionally allocated byte-ranges of a file that were sent to the storage devices before the restart of the metadata server. In this case, the layout provided by the client MUST be a subset of a writable layout that the client held immediately before the restart of the metadata server. The value of the field loca_stateid MUST be a value that the metadata server returned before it restarted. The metadata server is free to accept or reject this request based on its own internal metadata consistency checks. If the metadata server finds that the layout provided by the client does not pass its consistency checks, it MUST reject the request with the status NFS4ERR_RECLAIM_BAD. The successful completion of the LAYOUTCOMMIT request with loca_reclaim set to TRUE does NOT provide the client with a layout for the file. It simply commits the changes to the layout specified in the loca_layoutupdate field. To obtain a layout for the file, the client must send a LAYOUTGET request to the server after the server&#39;s grace period has expired. If the metadata server receives a LAYOUTCOMMIT request with loca_reclaim set to TRUE when the metadata server is not in its recovery grace period, it MUST reject the request with the status NFS4ERR_NO_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
loca_reclaimフィールドがTRUEに設定されている場合、これは、メタデータサーバーの再起動猶予期間中にメタデータサーバーの再起動後にクライアントがレイアウトへの変更をコミットしようとしていることを示します（セクション12.7.4を参照）。このタイプのリクエストは、メタデータサーバーの再起動前にストレージデバイスに送信されたファイルの暫定的に割り当てられたバイト範囲へのコミットされていない書き込みがクライアントにある場合に必要になることがあります。この場合、クライアントによって提供されるレイアウトは、メタデータサーバーの再起動の直前にクライアントが保持した書き込み可能なレイアウトのサブセットである必要があります。 loca_stateidフィールドの値は、メタデータサーバーが再起動する前に返した値である必要があります。メタデータサーバーは、独自の内部メタデータ整合性チェックに基づいて、この要求を自由に受け入れたり拒否したりできます。メタデータサーバーは、クライアントから提供されたレイアウトが整合性チェックに合格しないことを検出した場合、ステータスNFS4ERR_RECLAIM_BADで要求を拒否する必要があります。 loca_reclaimをTRUEに設定してLAYOUTCOMMIT要求を正常に完了しても、クライアントにファイルのレイアウトは提供されません。 loca_layoutupdateフィールドで指定されたレイアウトへの変更をコミットするだけです。ファイルのレイアウトを取得するには、サーバーの猶予期間が終了した後で、クライアントがLAYOUTGET要求をサーバーに送信する必要があります。メタデータサーバーが回復猶予期間にないときに、メタデータサーバーがloca_reclaimがTRUEに設定されたLAYOUTCOMMIT要求を受信した場合、ステータスNFS4ERR_NO_GRACEで要求を拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Setting the loca_reclaim field to TRUE is required if and only if the committed layout was acquired before the metadata server restart. If the client is committing a layout that was acquired during the metadata server&#39;s grace period, it MUST set the &#34;reclaim&#34; field to FALSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーの再起動前にコミットされたレイアウトが取得された場合にのみ、loca_reclaimフィールドをTRUEに設定する必要があります。クライアントがメタデータサーバーの猶予期間中に取得されたレイアウトをコミットする場合、「再利用」フィールドをFALSEに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The loca_stateid is a layout stateid value as returned by previously successful layout operations (see Section 12.5.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
loca_stateidは、以前に成功したレイアウト操作（セクション12.5.3を参照）によって返されるレイアウトのstateid値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The loca_last_write_offset field specifies the offset of the last byte written by the client previous to the LAYOUTCOMMIT. Note that this value is never equal to the file&#39;s size (at most it is one byte less than the file&#39;s size) and MUST be less than or equal to NFS4_MAXFILEOFF. Also, loca_last_write_offset MUST overlap the range described by loca_offset and loca_length. The metadata server may use this information to determine whether the file&#39;s size needs to be updated. If the metadata server updates the file&#39;s size as the result of the LAYOUTCOMMIT operation, it must return the new size (locr_newsize.ns_size) as part of the results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
loca_last_write_offsetフィールドは、LAYOUTCOMMITの前にクライアントによって書き込まれた最後のバイトのオフセットを指定します。この値はファイルのサイズと等しくなることはなく（多くてもファイルのサイズより1バイト小さい）、NFS4_MAXFILEOFF以下でなければならないことに注意してください。また、loca_last_write_offsetは、loca_offsetおよびloca_lengthによって記述された範囲と重複する必要があります。メタデータサーバーはこの情報を使用して、ファイルのサイズを更新する必要があるかどうかを判断します。メタデータサーバーがLAYOUTCOMMIT操作の結果としてファイルのサイズを更新する場合、結果の一部として新しいサイズ（locr_newsize.ns_size）を返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The loca_time_modify field allows the client to suggest a modification time it would like the metadata server to set. The metadata server may use the suggestion or it may use the time of the LAYOUTCOMMIT operation to set the modification time. If the metadata server uses the client-provided modification time, it should ensure that time does not flow backwards. If the client wants to force the metadata server to set an exact time, the client should use a SETATTR operation in a COMPOUND right after LAYOUTCOMMIT. See Section 12.5.4 for more details. If the client desires the resultant modification time, it should construct the COMPOUND so that a GETATTR follows the LAYOUTCOMMIT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
loca_time_modifyフィールドを使用すると、クライアントは、メタデータサーバーに設定する変更時刻を提案できます。メタデータサーバーは提案を使用するか、LAYOUTCOMMIT操作の時間を使用して変更時間を設定します。メタデータサーバーがクライアントから提供された変更時刻を使用する場合、時刻が逆方向に流れないようにする必要があります。クライアントがメタデータサーバーに正確な時刻を設定するよう強制したい場合、クライアントはLAYOUTCOMMITの直後のCOMPOUNDでSETATTR操作を使用する必要があります。詳細については、セクション12.5.4を参照してください。クライアントが結果の変更時間を希望する場合、GETATTRがLAYOUTCOMMITに従うようにCOMPOUNDを構築する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The loca_layoutupdate argument to LAYOUTCOMMIT provides a mechanism for a client to provide layout-specific updates to the metadata server. For example, the layout update can describe what byte-ranges of the original layout have been used and what byte-ranges can be deallocated. There is no NFSv4.1 file layout-specific layoutupdate4 structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTCOMMITのloca_layoutupdate引数は、クライアントがメタデータサーバーにレイアウト固有の更新を提供するためのメカニズムを提供します。たとえば、レイアウトの更新では、元のレイアウトのどのバイト範囲が使用され、どのバイト範囲が割り当て解除できるかを記述できます。 NFSv4.1ファイルレイアウト固有のlayoutupdate4構造はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layout information is more verbose for block devices than for objects and files because the latter two hide the details of block allocation behind their storage protocols. At the minimum, the client needs to communicate changes to the end-of-file location back to the server, and, if desired, its view of the file&#39;s modification time. For block/volume layouts, it needs to specify precisely which blocks have been used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
後者の2つは、ストレージプロトコルの背後にあるブロック割り当ての詳細を隠しているため、オブジェクトやファイルよりも、ブロックデバイスの方がレイアウト情報が冗長です。少なくとも、クライアントはファイルの終わりの場所への変更をサーバーに伝え、必要に応じて、ファイルの変更時刻のビューを伝える必要があります。ブロック/ボリュームレイアウトの場合、使用されているブロックを正確に指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the layout identified in the arguments does not exist, the error NFS4ERR_BADLAYOUT is returned. The layout being committed may also be rejected if it does not correspond to an existing layout with an iomode of LAYOUTIOMODE4_RW.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数で指定されたレイアウトが存在しない場合、エラーNFS4ERR_BADLAYOUTが返されます。 LAYOUTIOMODE4_RWのiomodeを持つ既存のレイアウトに対応していない場合、コミットされるレイアウトも拒否される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value and the current stateid retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持し、現在の状態IDはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-42-4--IMPLEMENTATION">
18.42.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.42.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MAY also use LAYOUTCOMMIT with the loca_reclaim field set to TRUE to convey hints to modified file attributes or to report layout-type specific information such as I/O errors for object-based storage layouts, as normally done during normal operation. Doing so may help the metadata server to recover files more efficiently after restart. For example, some file system implementations may require expansive recovery of file system objects if the metadata server does not get a positive indication from all clients holding a LAYOUTIOMODE4_RW layout that they have successfully completed all their writes. Sending a LAYOUTCOMMIT (if required) and then following with LAYOUTRETURN can provide such an indication and allow for graceful and efficient recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはまた、loca_reclaimフィールドをTRUEに設定してLAYOUTCOMMITを使用して、変更されたファイル属性にヒントを伝えたり、通常の操作中に通常行われるように、オブジェクトベースのストレージレイアウトのI / Oエラーなどのレイアウトタイプ固有の情報を報告したりできます。そうすることで、メタデータサーバーが再起動後にファイルをより効率的に回復できるようになります。たとえば、メタデータサーバーがすべての書き込みを正常に完了したというLAYOUTIOMODE4_RWレイアウトを保持しているすべてのクライアントから肯定的な指示を受け取らない場合、一部のファイルシステム実装では、ファイルシステムオブジェクトの大規模なリカバリが必要になる場合があります。 LAYOUTCOMMITを送信し（必要な場合）、LAYOUTRETURNを実行すると、そのような指示が提供され、正常で効率的な回復が可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If loca_reclaim is TRUE, the metadata server is free to either examine or ignore the value in the field loca_stateid. The metadata server implementation might or might not encode in its layout stateid information that allows the metadate server to perform a consistency check on the LAYOUTCOMMIT request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
loca_reclaimがTRUEの場合、メタデータサーバーはフィールドloca_stateidの値を自由に調査または無視できます。メタデータサーバーの実装は、メタデータサーバーがLAYOUTCOMMIT要求の整合性チェックを実行できるようにするレイアウトのstateid情報をエンコードする場合とエンコードしない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-43--Operation-50-LAYOUTGET---Get-Layout-Information">
18.43. Operation 50: LAYOUTGET - Get Layout Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.43. 操作50：LAYOUTGET-レイアウト情報を取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-43-1--ARGUMENT">
18.43.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.43.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LAYOUTGET4args {
           /* CURRENT_FH: file */
           bool                    loga_signal_layout_avail;
           layouttype4             loga_layout_type;
           layoutiomode4           loga_iomode;
           offset4                 loga_offset;
           length4                 loga_length;
           length4                 loga_minlength;
           stateid4                loga_stateid;
           count4                  loga_maxcount;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-43-2--RESULT">
18.43.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.43.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LAYOUTGET4resok {
           bool               logr_return_on_close;
           stateid4           logr_stateid;
           layout4            logr_layout&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LAYOUTGET4res switch (nfsstat4 logr_status) {
   case NFS4_OK:
           LAYOUTGET4resok     logr_resok4;
   case NFS4ERR_LAYOUTTRYLATER:
           bool                logr_will_signal_layout_avail;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-43-3--DESCRIPTION">
18.43.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.43.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The LAYOUTGET operation requests a layout from the metadata server for reading or writing the file given by the filehandle at the byte-range specified by offset and length. Layouts are identified by the client ID (derived from the session ID in the preceding SEQUENCE operation), current filehandle, layout type (loga_layout_type), and the layout stateid (loga_stateid). The use of the loga_iomode field depends upon the layout type, but should reflect the client&#39;s data access intent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
LAYOUTGET操作は、オフセットと長さで指定されたバイト範囲で、ファイルハンドルによって指定されたファイルを読み書きするために、メタデータサーバーにレイアウトを要求します。レイアウトは、クライアントID（前のSEQUENCE操作のセッションIDから派生）、現在のファイルハンドル、レイアウトタイプ（loga_layout_type）、およびレイアウトステートID（loga_stateid）によって識別されます。 loga_iomodeフィールドの使用はレイアウトタイプによって異なりますが、クライアントのデータアクセスインテントを反映する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the metadata server is in a grace period, and does not persist layouts and device ID to device address mappings, then it MUST return NFS4ERR_GRACE (see Section 8.4.2.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーが猶予期間内にあり、レイアウトとデバイスIDからデバイスアドレスへのマッピングを保持しない場合、NFS4ERR_GRACEを返さなければなりません（セクション8.4.2.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LAYOUTGET operation returns layout information for the specified byte-range: a layout. The client actually specifies two ranges, both starting at the offset in the loga_offset field. The first range is between loga_offset and loga_offset + loga_length - 1 inclusive. This range indicates the desired range the client wants the layout to cover. The second range is between loga_offset and loga_offset + loga_minlength - 1 inclusive. This range indicates the required range the client needs the layout to cover. Thus, loga_minlength MUST be less than or equal to loga_length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTGET操作は、指定されたバイト範囲（レイアウト）のレイアウト情報を返します。クライアントは実際には2つの範囲を指定し、どちらもloga_offsetフィールドのオフセットから始まります。最初の範囲は、loga_offsetとloga_offset + loga_length-1の間です。この範囲は、クライアントがレイアウトでカバーしたい望​​ましい範囲を示します。 2番目の範囲は、loga_offsetとloga_offset + loga_minlength-1の間です。この範囲は、クライアントがレイアウトをカバーするために必要な必要範囲を示します。したがって、loga_minlengthは、loga_length以下でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a length field is set to NFS4_UINT64_MAX, this indicates a desire (when loga_length is NFS4_UINT64_MAX) or requirement (when loga_minlength is NFS4_UINT64_MAX) to get a layout from loga_offset through the end-of-file, regardless of the file&#39;s length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さフィールドがNFS4_UINT64_MAXに設定されている場合、これは、ファイルの長さに関係なく、loga_offsetからファイルの終わりまでレイアウトを取得したいという要望（loga_lengthがNFS4_UINT64_MAXの場合）または要件（loga_minlengthがNFS4_UINT64_MAXの場合）を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following rules govern the relationships among, and the minima of, loga_length, loga_minlength, and loga_offset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のルールは、loga_length、loga_minlength、およびloga_offset間の関係と、それらの最小値を管理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If loga_length is less than loga_minlength, the metadata server MUST return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o loga_lengthがloga_minlengthより小さい場合、メタデータサーバーはNFS4ERR_INVALを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If loga_minlength is zero, this is an indication to the metadata server that the client desires any layout at offset loga_offset or less that the metadata server has &#34;readily available&#34;. Readily is subjective, and depends on the layout type and the pNFS server implementation. For example, some metadata servers might have to pre-allocate stable storage when they receive a request for a range of a file that goes beyond the file&#39;s current length. If loga_minlength is zero and loga_length is greater than zero, this tells the metadata server what range of the layout the client would prefer to have. If loga_length and loga_minlength are both zero, then the client is indicating that it desires a layout of any length with the ending offset of the range no less than the value specified loga_offset, and the starting offset at or below loga_offset. If the metadata server does not have a layout that is readily available, then it MUST return NFS4ERR_LAYOUTTRYLATER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o loga_minlengthがゼロの場合、これは、クライアントがオフセットloga_offset以下のレイアウトを希望し、メタデータサーバーが「すぐに利用可能」であることをメタデータサーバーに示しています。簡単に主観的であり、レイアウトの種類とpNFSサーバーの実装によって異なります。たとえば、一部のメタデータサーバーは、ファイルの現在の長さを超える範囲のファイルのリクエストを受け取ったときに、安定したストレージを事前に割り当てる必要がある場合があります。 loga_minlengthがゼロで、loga_lengthがゼロより大きい場合、これは、クライアントが希望するレイアウトの範囲をメタデータサーバーに通知します。 loga_lengthとloga_minlengthの両方がゼロの場合、クライアントは、指定された値loga_offset以上の範囲の終了オフセットと、loga_offset以下の開始オフセットを持つ任意の長さのレイアウトが必要であることを示しています。メタデータサーバーにすぐに利用できるレイアウトがない場合は、NFS4ERR_LAYOUTTRYLATERを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the sum of loga_offset and loga_minlength exceeds NFS4_UINT64_MAX, and loga_minlength is not NFS4_UINT64_MAX, the error NFS4ERR_INVAL MUST result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o loga_offsetとloga_minlengthの合計がNFS4_UINT64_MAXを超え、loga_minlengthがNFS4_UINT64_MAXでない場合、エラーNFS4ERR_INVALが発生する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the sum of loga_offset and loga_length exceeds NFS4_UINT64_MAX, and loga_length is not NFS4_UINT64_MAX, the error NFS4ERR_INVAL MUST result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o loga_offsetとloga_lengthの合計がNFS4_UINT64_MAXを超え、loga_lengthがNFS4_UINT64_MAXでない場合、エラーNFS4ERR_INVALが発生する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the metadata server has performed the above checks on loga_offset, loga_minlength, and loga_offset, the metadata server MUST return a layout according to the rules in Table 13.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーが上記のチェックをloga_offset、loga_minlength、およびloga_offsetに対して実行した後、メタデータサーバーは表13のルールに従ってレイアウトを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
 Acceptable layouts based on loga_minlength. Note: u64m = NFS4_UINT64_MAX; a_off = loga_offset; a_minlen = loga_minlength.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
loga_minlengthに基づく許容可能なレイアウト。注：u64m = NFS4_UINT64_MAX; a_off = loga_offset; a_minlen = loga_minlength。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----------+-----------+----------+----------+---------------------+
   | Layout    | Layout    | Layout   | Layout   | Layout length of    |
   | iomode of | a_minlen  | iomode   | offset   | reply               |
   | request   | of        | of reply | of reply |                     |
   |           | request   |          |          |                     |
   +-----------+-----------+----------+----------+---------------------+
   | _READ     | u64m      | MAY be   | MUST be  | MUST be &gt;= file     |
   |           |           | _READ    | &lt;= a_off | length - layout     |
   |           |           |          |          | offset              |
   | _READ     | u64m      | MAY be   | MUST be  | MUST be u64m        |
   |           |           | _RW      | &lt;= a_off |                     |
   | _READ     | &gt; 0 and &lt; | MAY be   | MUST be  | MUST be &gt;= MIN(file |
   |           | u64m      | _READ    | &lt;= a_off | length, a_minlen +  |
   |           |           |          |          | a_off) - layout     |
   |           |           |          |          | offset              |
   | _READ     | &gt; 0 and &lt; | MAY be   | MUST be  | MUST be &gt;= a_off -  |
   |           | u64m      | _RW      | &lt;= a_off | layout offset +     |
   |           |           |          |          | a_minlen            |
   | _READ     | 0         | MAY be   | MUST be  | MUST be &gt; 0         |
   |           |           | _READ    | &lt;= a_off |                     |
   | _READ     | 0         | MAY be   | MUST be  | MUST be &gt; 0         |
   |           |           | _RW      | &lt;= a_off |                     |
   | _RW       | u64m      | MUST be  | MUST be  | MUST be u64m        |
   |           |           | _RW      | &lt;= a_off |                     |
   | _RW       | &gt; 0 and &lt; | MUST be  | MUST be  | MUST be &gt;= a_off -  |
   |           | u64m      | _RW      | &lt;= a_off | layout offset +     |
   |           |           |          |          | a_minlen            |
   | _RW       | 0         | MUST be  | MUST be  | MUST be &gt; 0         |
   |           |           | _RW      | &lt;= a_off |                     |
   +-----------+-----------+----------+----------+---------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Table 13
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
表13
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If loga_minlength is not zero and the metadata server cannot return a layout according to the rules in Table 13, then the metadata server MUST return the error NFS4ERR_BADLAYOUT. If loga_minlength is zero and the metadata server cannot or will not return a layout according to the rules in Table 13, then the metadata server MUST return the error NFS4ERR_LAYOUTTRYLATER. Assuming that loga_length is greater than loga_minlength or equal to zero, the metadata server SHOULD return a layout according to the rules in Table 14.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
loga_minlengthがゼロではなく、メタデータサーバーが表13のルールに従ってレイアウトを返すことができない場合、メタデータサーバーはエラーNFS4ERR_BADLAYOUTを返す必要があります。 loga_minlengthがゼロで、メタデータサーバーが表13の規則に従ってレイアウトを返せない、または返さない場合、メタデータサーバーはエラーNFS4ERR_LAYOUTTRYLATERを返さなければなりません（MUST）。 loga_lengthがloga_minlengthより大きいかゼロに等しいと想定すると、メタデータサーバーは、表14のルールに従ってレイアウトを返す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Desired layouts based on loga_length. The rules of Table 13 MUST be applied first. Note: u64m = NFS4_UINT64_MAX; a_off = loga_offset; a_len = loga_length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
loga_lengthに基づく望ましいレイアウト。表13のルールを最初に適用する必要があります。注：u64m = NFS4_UINT64_MAX; a_off = loga_offset; a_len = loga_length。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------+------------+-----------+-----------+-----------------+
   | Layout     | Layout     | Layout    | Layout    | Layout length   |
   | iomode of  | a_len of   | iomode of | offset of | of reply        |
   | request    | request    | reply     | reply     |                 |
   +------------+------------+-----------+-----------+-----------------+
   | _READ      | u64m       | MAY be    | MUST be   | SHOULD be u64m  |
   |            |            | _READ     | &lt;= a_off  |                 |
   | _READ      | u64m       | MAY be    | MUST be   | SHOULD be u64m  |
   |            |            | _RW       | &lt;= a_off  |                 |
   | _READ      | &gt; 0 and &lt;  | MAY be    | MUST be   | SHOULD be &gt;=    |
   |            | u64m       | _READ     | &lt;= a_off  | a_off - layout  |
   |            |            |           |           | offset + a_len  |
   | _READ      | &gt; 0 and &lt;  | MAY be    | MUST be   | SHOULD be &gt;=    |
   |            | u64m       | _RW       | &lt;= a_off  | a_off - layout  |
   |            |            |           |           | offset + a_len  |
   | _READ      | 0          | MAY be    | MUST be   | SHOULD be &gt;     |
   |            |            | _READ     | &lt;= a_off  | a_off - layout  |
   |            |            |           |           | offset          |
   | _READ      | 0          | MAY be    | MUST be   | SHOULD be &gt;     |
   |            |            | _READ     | &lt;= a_off  | a_off - layout  |
   |            |            |           |           | offset          |
   | _RW        | u64m       | MUST be   | MUST be   | SHOULD be u64m  |
   |            |            | _RW       | &lt;= a_off  |                 |
   | _RW        | &gt; 0 and &lt;  | MUST be   | MUST be   | SHOULD be &gt;=    |
   |            | u64m       | _RW       | &lt;= a_off  | a_off - layout  |
   |            |            |           |           | offset + a_len  |
   | _RW        | 0          | MUST be   | MUST be   | SHOULD be &gt;     |
   |            |            | _RW       | &lt;= a_off  | a_off - layout  |
   |            |            |           |           | offset          |
   +------------+------------+-----------+-----------+-----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Table 14
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
表14
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The loga_stateid field specifies a valid stateid. If a layout is not currently held by the client, the loga_stateid field represents a stateid reflecting the correspondingly valid open, byte-range lock, or delegation stateid. Once a layout is held on the file by the client, the loga_stateid field MUST be a stateid as returned from a previous LAYOUTGET or LAYOUTRETURN operation or provided by a CB_LAYOUTRECALL operation (see Section 12.5.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
loga_stateidフィールドは、有効な状態IDを指定します。レイアウトが現在クライアントによって保持されていない場合、loga_stateidフィールドは、対応する有効なオープン、バイト範囲ロック、または委任のstateidを反映するstateidを表します。レイアウトがクライアントによってファイルに保持されると、loga_stateidフィールドは、前のLAYOUTGETまたはLAYOUTRETURN操作から返された、またはCB_LAYOUTRECALL操作によって提供された状態IDである必要があります（セクション12.5.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The loga_maxcount field specifies the maximum layout size (in bytes) that the client can handle. If the size of the layout structure exceeds the size specified by maxcount, the metadata server will return the NFS4ERR_TOOSMALL error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
loga_maxcountフィールドは、クライアントが処理できる最大レイアウトサイズ（バイト単位）を指定します。レイアウト構造のサイズがmaxcountで指定されたサイズを超える場合、メタデータサーバーはNFS4ERR_TOOSMALLエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The returned layout is expressed as an array, logr_layout, with each element of type layout4. If a file has a single striping pattern, then logr_layout SHOULD contain just one entry. Otherwise, if the requested range overlaps more than one striping pattern, logr_layout will contain the required number of entries. The elements of logr_layout MUST be sorted in ascending order of the value of the lo_offset field of each element. There MUST be no gaps or overlaps in the range between two successive elements of logr_layout. The lo_iomode field in each element of logr_layout MUST be the same.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
返されるレイアウトは、タイプlayout4の各要素を持つ配列logr_layoutとして表されます。ファイルに単一のストライピングパターンがある場合、logr_layoutには1つのエントリのみが含まれる必要があります（SHOULD）。それ以外の場合、要求された範囲が複数のストライピングパターンと重複する場合、logr_layoutには必要な数のエントリが含まれます。 logr_layoutの要素は、各要素のlo_offsetフィールドの値の昇順でソートする必要があります。 logr_layoutの2つの連続する要素間の範囲にギャップまたはオーバーラップがあってはなりません（MUST）。 logr_layoutの各要素のlo_iomodeフィールドは同じである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 13 and Table 14 both refer to a returned layout iomode, offset, and length. Because the returned layout is encoded in the logr_layout array, more description is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表13と表14はどちらも、返されるレイアウトのiomode、オフセット、および長さを参照しています。返されるレイアウトはlogr_layout配列にエンコードされているため、詳細な説明が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iomode
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iomode
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The value of the returned layout iomode listed in Table 13 and Table 14 is equal to the value of the lo_iomode field in each element of logr_layout. As shown in Table 13 and Table 14, the metadata server MAY return a layout with an lo_iomode different from the requested iomode (field loga_iomode of the request). If it does so, it MUST ensure that the lo_iomode is more permissive than the loga_iomode requested. For example, this behavior allows an implementation to upgrade LAYOUTIOMODE4_READ requests to LAYOUTIOMODE4_RW requests at its discretion, within the limits of the layout type specific protocol. A lo_iomode of either LAYOUTIOMODE4_READ or LAYOUTIOMODE4_RW MUST be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表13および表14にリストされている返されたレイアウトiomodeの値は、logr_layoutの各要素のlo_iomodeフィールドの値と同じです。表13と表14に示すように、メタデータサーバーは、要求されたiomode（要求のフィールドloga_iomode）とは異なるlo_iomodeのレイアウトを返す場合があります。その場合、lo_iomodeが要求されたloga_iomodeよりも寛容であることを確認する必要があります。たとえば、この動作により、実装は、レイアウトタイプ固有のプロトコルの制限内で、LAYOUTIOMODE4_READリクエストを独自の裁量でLAYOUTIOMODE4_RWリクエストにアップグレードできます。 LAYOUTIOMODE4_READまたはLAYOUTIOMODE4_RWのいずれかのlo_iomodeを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
offset
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オフセット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The value of the returned layout offset listed in Table 13 and Table 14 is always equal to the lo_offset field of the first element logr_layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表13および表14にリストされている、返されたレイアウトオフセットの値は、常に最初のエレメントlogr_layoutのlo_offsetフィールドと等しくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When setting the value of the returned layout length, the situation is complicated by the possibility that the special layout length value NFS4_UINT64_MAX is involved. For a logr_layout array of N elements, the lo_length field in the first N-1 elements MUST NOT be NFS4_UINT64_MAX. The lo_length field of the last element of logr_layout can be NFS4_UINT64_MAX under some conditions as described in the following list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
返されるレイアウト長の値を設定する場合、特別なレイアウト長の値NFS4_UINT64_MAXが含まれる可能性があるため、状況は複雑になります。 N要素のlogr_layout配列の場合、最初のN-1要素のlo_lengthフィールドはNFS4_UINT64_MAXであってはなりません（MUST NOT）。次のリストで説明するように、logr_layoutの最後の要素のlo_lengthフィールドは、いくつかの条件下でNFS4_UINT64_MAXになる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* If an applicable rule of Table 13 states that the metadata server MUST return a layout of length NFS4_UINT64_MAX, then the lo_length field of the last element of logr_layout MUST be NFS4_UINT64_MAX.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 表13の該当するルールで、メタデータサーバーが長さNFS4_UINT64_MAXのレイアウトを返す必要があると記載されている場合、logr_layoutの最後の要素のlo_lengthフィールドはNFS4_UINT64_MAXでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* If an applicable rule of Table 13 states that the metadata server MUST NOT return a layout of length NFS4_UINT64_MAX, then the lo_length field of the last element of logr_layout MUST NOT be NFS4_UINT64_MAX.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 表13の該当するルールで、メタデータサーバーが長さNFS4_UINT64_MAXのレイアウトを返してはならないことを示している場合、logr_layoutの最後の要素のlo_lengthフィールドはNFS4_UINT64_MAXであってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* If an applicable rule of Table 14 states that the metadata server SHOULD return a layout of length NFS4_UINT64_MAX, then the lo_length field of the last element of logr_layout SHOULD be NFS4_UINT64_MAX.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 表14の該当するルールで、メタデータサーバーが長さNFS4_UINT64_MAXのレイアウトを返す必要があると記載されている場合、logr_layoutの最後の要素のlo_lengthフィールドはNFS4_UINT64_MAXである必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* When the value of the returned layout length of Table 13 and Table 14 is not NFS4_UINT64_MAX, then the returned layout length is equal to the sum of the lo_length fields of each element of logr_layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 表13および表14の戻されたレイアウト長の値がNFS4_UINT64_MAXでない場合、戻されたレイアウト長は、logr_layoutの各エレメントのlo_lengthフィールドの合計に等しくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The logr_return_on_close result field is a directive to return the layout before closing the file. When the metadata server sets this return value to TRUE, it MUST be prepared to recall the layout in the case in which the client fails to return the layout before close. For the metadata server that knows a layout must be returned before a close of the file, this return value can be used to communicate the desired behavior to the client and thus remove one extra step from the client&#39;s and metadata server&#39;s interaction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
logr_return_on_close結果フィールドは、ファイルを閉じる前にレイアウトを返すディレクティブです。メタデータサーバーがこの戻り値をTRUEに設定する場合、クライアントが閉じる前にレイアウトを返すことができない場合に備えて、レイアウトを呼び出す準備をしておく必要があります。ファイルを閉じる前にレイアウトを返す必要があることを認識しているメタデータサーバーの場合、この戻り値を使用して目的の動作をクライアントに通知し、クライアントとメタデータサーバーの相互作用から1つの余分なステップを削除できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The logr_stateid stateid is returned to the client for use in subsequent layout related operations. See Sections 8.2, 12.5.3, and 12.5.5.2 for a further discussion and requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
logr_stateid stateidは、後続のレイアウト関連操作で使用するためにクライアントに返されます。詳細な説明と要件については、セクション8.2、12.5.3、および12.5.5.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The format of the returned layout (lo_content) is specific to the layout type. The value of the layout type (lo_content.loc_type) for each of the elements of the array of layouts returned by the metadata server (logr_layout) MUST be equal to the loga_layout_type specified by the client. If it is not equal, the client SHOULD ignore the response as invalid and behave as if the metadata server returned an error, even if the client does have support for the layout type returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
返されるレイアウト（lo_content）のフォーマットは、レイアウトタイプに固有です。メタデータサーバー（logr_layout）によって返されるレイアウトの配列の各要素のレイアウトタイプ（lo_content.loc_type）の値は、クライアントによって指定されたloga_layout_typeと等しい必要があります。等しくない場合、クライアントは、応答が無効であることを無視し、クライアントが返されたレイアウトタイプをサポートしていても、メタデータサーバーがエラーを返したかのように動作する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If neither the requested file nor its containing file system support layouts, the metadata server MUST return NFS4ERR_LAYOUTUNAVAILABLE. If the layout type is not supported, the metadata server MUST return NFS4ERR_UNKNOWN_LAYOUTTYPE. If layouts are supported but no layout matches the client provided layout identification, the metadata server MUST return NFS4ERR_BADLAYOUT. If an invalid loga_iomode is specified, or a loga_iomode of LAYOUTIOMODE4_ANY is specified, the metadata server MUST return NFS4ERR_BADIOMODE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求されたファイルもそれを含むファイルシステムもレイアウトをサポートしない場合、メタデータサーバーはNFS4ERR_LAYOUTUNAVAILABLEを返さなければなりません（MUST）。レイアウトタイプがサポートされていない場合、メタデータサーバーはNFS4ERR_UNKNOWN_LAYOUTTYPEを返す必要があります。レイアウトはサポートされているが、クライアントが提供するレイアウトIDに一致するレイアウトがない場合、メタデータサーバーはNFS4ERR_BADLAYOUTを返さなければなりません（MUST）。無効なloga_iomodeが指定されている場合、またはLAYOUTIOMODE4_ANYのloga_iomodeが指定されている場合、メタデータサーバーはNFS4ERR_BADIOMODEを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the layout for the file is unavailable due to transient conditions, e.g., file sharing prohibits layouts, the metadata server MUST return NFS4ERR_LAYOUTTRYLATER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一時的な状態が原因でファイルのレイアウトが使用できない場合（ファイル共有でレイアウトが禁止されているなど）、メタデータサーバーはNFS4ERR_LAYOUTTRYLATERを返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the layout request is rejected due to an overlapping layout recall, the metadata server MUST return NFS4ERR_RECALLCONFLICT. See Section 12.5.5.2 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトの呼び出しが重複しているためにレイアウト要求が拒否された場合、メタデータサーバーはNFS4ERR_RECALLCONFLICTを返す必要があります。詳細については、セクション12.5.5.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the layout conflicts with a mandatory byte-range lock held on the file, and if the storage devices have no method of enforcing mandatory locks, other than through the restriction of layouts, the metadata server SHOULD return NFS4ERR_LOCKED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトがファイルに保持されている必須のバイト範囲ロックと競合する場合、およびストレージデバイスにレイアウトの制限以外に必須のロックを強制する方法がない場合、メタデータサーバーはNFS4ERR_LOCKEDを返す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If client sets loga_signal_layout_avail to TRUE, then it is registering with the client a &#34;want&#34; for a layout in the event the layout cannot be obtained due to resource exhaustion. If the metadata server supports and will honor the &#34;want&#34;, the results will have logr_will_signal_layout_avail set to TRUE. If so, the client should expect a CB_RECALLABLE_OBJ_AVAIL operation to indicate that a layout is available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがloga_signal_layout_availをTRUEに設定すると、リソース不足のためにレイアウトを取得できない場合に、クライアントにレイアウトの「希望」が登録されます。メタデータサーバーが「欲しい」をサポートし、尊重する場合、結果はlogr_will_signal_layout_availがTRUEに設定されます。その場合、クライアントはCB_RECALLABLE_OBJ_AVAIL操作がレイアウトが使用可能であることを示すことを期待する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value and the current stateid is updated to match the value as returned in the results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持し、現在の状態IDは結果で返される値と一致するように更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-43-4--IMPLEMENTATION">
18.43.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.43.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Typically, LAYOUTGET will be called as part of a COMPOUND request after an OPEN operation and results in the client having location information for the file. This requires that loga_stateid be set to the special stateid that tells the metadata server to use the current stateid, which is set by OPEN (see Section 16.2.3.1.2). A client may also hold a layout across multiple OPENs. The client specifies a layout type that limits what kind of layout the metadata server will return. This prevents metadata servers from granting layouts that are unusable by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、LAYOUTGETは、OPEN操作の後にCOMPOUND要求の一部として呼び出され、クライアントがファイルの場所情報を取得します。これには、loga_stateidを、OPENによって設定される現在の状態IDを使用するようにメタデータサーバーに指示する特別な状態IDに設定する必要があります（セクション16.2.3.1.2を参照）。クライアントは、複数のOPENにわたってレイアウトを保持することもできます。クライアントは、メタデータサーバーが返すレイアウトの種類を制限するレイアウトタイプを指定します。これにより、メタデータサーバーがクライアントが使用できないレイアウトを許可することを防ぎます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As indicated by Table 13 and Table 14, the specification of LAYOUTGET allows a pNFS client and server considerable flexibility. A pNFS client can take several strategies for sending LAYOUTGET. Some examples are as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表13と表14に示すように、LAYOUTGETの仕様により、pNFSクライアントとサーバーにかなりの柔軟性が与えられます。 pNFSクライアントは、LAYOUTGETを送信するためのいくつかの戦略を取ることができます。いくつかの例は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If LAYOUTGET is preceded by OPEN in the same COMPOUND request and the OPEN requests OPEN4_SHARE_ACCESS_READ access, the client might opt to request a _READ layout with loga_offset set to zero, loga_minlength set to zero, and loga_length set to NFS4_UINT64_MAX. If the file has space allocated to it, that space is striped over one or more storage devices, and there is either no conflicting layout or the concept of a conflicting layout does not apply to the pNFS server&#39;s layout type or implementation, then the metadata server might return a layout with a starting offset of zero, and a length equal to the length of the file, if not NFS4_UINT64_MAX. If the length of the file is not a multiple of the pNFS server&#39;s stripe width (see Section 13.2 for a formal definition), the metadata server might round up the returned layout&#39;s length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 同じCOMPOUND要求でLAYOUTGETの前にOPENがあり、OPENがOPEN4_SHARE_ACCESS_READアクセスを要求する場合、クライアントは、loga_offsetをゼロ、loga_minlengthをゼロ、loga_lengthをNFS4_UINT64_MAXに設定して_READレイアウトを要求することを選択できます。ファイルにスペースが割り当てられている場合、そのスペースは1つ以上のストレージデバイスにストライプ化され、競合するレイアウトがないか、競合するレイアウトの概念がpNFSサーバーのレイアウトタイプまたは実装に適用されない場合、メタデータサーバーNFS4_UINT64_MAXでない場合、ゼロの開始オフセットとファイルの長さに等しい長さのレイアウトを返す可能性があります。ファイルの長さがpNFSサーバーのストライプ幅の倍数でない場合（正式な定義については、セクション13.2を参照）、メタデータサーバーが返されるレイアウトの長さを切り上げる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If LAYOUTGET is preceded by OPEN in the same COMPOUND request, and the OPEN requests OPEN4_SHARE_ACCESS_WRITE access and does not truncate the file, the client might opt to request a _RW layout with loga_offset set to zero, loga_minlength set to zero, and loga_length set to the file&#39;s current length (if known), or NFS4_UINT64_MAX. As with the previous case, under some conditions the metadata server might return a layout that covers the entire length of the file or beyond.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 同じCOMPOUND要求でLAYOUTGETの前にOPENがあり、OPENがOPEN4_SHARE_ACCESS_WRITEアクセスを要求してファイルを切り捨てない場合、クライアントは、loga_offsetをゼロに設定し、loga_minlengthをゼロに設定し、loga_lengthをファイルの現在の長さ（わかっている場合）、またはNFS4_UINT64_MAX。前のケースと同様に、条件によっては、メタデータサーバーがファイルの全長またはそれ以上をカバーするレイアウトを返す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o This strategy is as above, but the OPEN truncates the file. In this case, the client might anticipate it will be writing to the file from offset zero, and so loga_offset and loga_minlength are set to zero, and loga_length is set to the value of threshold4_write_iosize. The metadata server might return a layout from offset zero with a length at least as long as threshold4_write_iosize.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o この戦略は上記と同じですが、OPENはファイルを切り捨てます。この場合、クライアントはオフセット0からファイルに書き込むことを予期している可能性があるため、loga_offsetとloga_minlengthはゼロに設定され、loga_lengthはthreshold4_write_iosizeの値に設定されます。メタデータサーバーは、少なくともthreshold4_write_iosizeと同じ長さのオフセット0からレイアウトを返す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o A process on the client invokes a request to read from offset 10000 for length 50000. The client is using buffered I/O, and has buffer sizes of 4096 bytes. The client intends to map the request of the process into a series of READ requests starting at offset 8192. The end offset needs to be higher than 10000 + 50000 = 60000, and the next offset that is a multiple of 4096 is 61440. The difference between 61440 and that starting offset of the layout is 53248 (which is the product of 4096 and 15). The value of threshold4_read_iosize is less than 53248, so the client sends a LAYOUTGET request with loga_offset set to 8192, loga_minlength set to 53248, and loga_length set to the file&#39;s length (if known) minus 8192 or NFS4_UINT64_MAX (if the file&#39;s length is not known). Since this LAYOUTGET request exceeds the metadata server&#39;s threshold, it grants the layout, possibly with an initial offset of zero, with an end offset of at least 8192 + 53248 - 1 = 61439, but preferably a layout with an offset aligned on the stripe width and a length that is a multiple of the stripe width.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
oクライアント上のプロセスが、長さ50000のオフセット10000から読み取る要求を呼び出します。クライアントはバッファードI / Oを使用しており、バッファーサイズは4096バイトです。クライアントは、プロセスの要求をオフセット8192から始まる一連のREAD要求にマップする予定です。終了オフセットは10000 + 50000 = 60000より大きくする必要があり、4096の倍数である次のオフセットは61440です。 61440とレイアウトの開始オフセットの間は53248（4096と15の積）です。 threshold4_read_iosizeの値は53248未満であるため、クライアントは、loga_offsetを8192に設定し、loga_minlengthを53248に設定し、loga_lengthをファイルの長さ（既知の場合）から8192に設定するか、NFS4_UINT64_MAX（ファイルの長さが不明の場合）に設定してLAYOUTGETリクエストを送信します。 ）。このLAYOUTGETリクエストはメタデータサーバーのしきい値を超えるため、レイアウトを許可します。初期オフセットはゼロ、終了オフセットは少なくとも8192 + 53248-1 = 61439ですが、ストライプ幅にオフセットが調整されたレイアウトが望ましいです。ストライプ幅の倍数の長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o This strategy is as above, but the client is not using buffered I/O, and instead all internal I/O requests are sent directly to the server. The LAYOUTGET request has loga_offset equal to 10000 and loga_minlength set to 50000. The value of loga_length is set to the length of the file. The metadata server is free to return a layout that fully overlaps the requested range, with a starting offset and length aligned on the stripe width.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o この戦略は上記と同じですが、クライアントはバッファI / Oを使用せず、代わりにすべての内部I / O要求がサーバーに直接送信されます。 LAYOUTGET要求では、loga_offsetが10000に等しく、loga_minlengthが50000に設定されています。loga_lengthの値は、ファイルの長さに設定されます。メタデータサーバーは、要求された範囲と完全に重なるレイアウトを自由に返すことができます。開始オフセットと長さは、ストライプ幅に合わせて調整されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Again, a process on the client invokes a request to read from offset 10000 for length 50000 (i.e. a range with a starting offset of 10000 and an ending offset of 69999), and buffered I/O is in use. The client is expecting that the server might not be able to return the layout for the full I/O range. The client intends to map the request of the process into a series of thirteen READ requests starting at offset 8192, each with length 4096, with a total length of 53248 (which equals 13 * 4096), which fully contains the range that client&#39;s process wants to read. Because the value of threshold4_read_iosize is equal to 4096, it is practical and reasonable for the client to use several LAYOUTGET operations to complete the series of READs. The client sends a LAYOUTGET request with loga_offset set to 8192, loga_minlength set to 4096, and loga_length set to 53248 or higher. The server will grant a layout possibly with an initial offset of zero, with an end offset of at least 8192 + 4096 - 1 = 12287, but preferably a layout with an offset aligned on the stripe width and a length that is a multiple of the stripe width. This will allow the client to make forward progress, possibly sending more LAYOUTGET operations for the remainder of the range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o この場合も、クライアント上のプロセスが長さ50000のオフセット10000（つまり、開始オフセットが10000で終了オフセットが69999の範囲）から読み取る要求を呼び出し、バッファリングされたI / Oが使用されています。クライアントは、サーバーがI / O範囲全体のレイアウトを返すことができない可能性があることを予期しています。クライアントは、プロセスの要求をオフセット8192から始まる一連の13個のREAD要求にマップすることを意図しており、それぞれが長さ4096、全長53248（13 * 4096）であり、クライアントのプロセスが必要とする範囲を完全に含みます。読む。 threshold4_read_iosizeの値は4096に等しいため、クライアントが複数のLAYOUTGET操作を使用して一連のREADを完了することは実用的で合理的です。クライアントは、loga_offsetを8192に、loga_minlengthを4096に、loga_lengthを53248以上に設定して、LAYOUTGET要求を送信します。サーバーは、最初のオフセットがゼロで、終了オフセットが少なくとも8192 + 4096-1 = 12287であるレイアウトを許可しますが、ストライプの幅と長さの倍数である長さにオフセットが調整されたレイアウトが望ましいです。ストライプ幅。これにより、クライアントは前進し、おそらく範囲の残りの部分にさらにLAYOUTGET操作を送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An NFS client detects a sequential read pattern, and so sends a LAYOUTGET operation that goes well beyond any current or pending read requests to the server. The server might likewise detect this pattern, and grant the LAYOUTGET request. Once the client reads from an offset of the file that represents 50% of the way through the range of the last layout it received, in order to avoid stalling I/O that would wait for a layout, the client sends more operations from an offset of the file that represents 50% of the way through the last layout it received. The client continues to request layouts with byte-ranges that are well in advance of the byte-ranges of recent and/or read requests of processes running on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSクライアントは順次読み取りパターンを検出するため、現在または保留中の読み取り要求をはるかに超えるLAYOUTGET操作をサーバーに送信します。サーバーも同様にこのパターンを検出し、LAYOUTGETリクエストを許可します。クライアントが最後に受信したレイアウトの範囲全体の50％を表すファイルのオフセットから読み取ると、レイアウトを待機するI / Oのストールを回避するために、クライアントはオフセットからより多くの操作を送信します最後に受け取ったレイアウトの50％を表すファイルのクライアントは、クライアントで実行されているプロセスの最近の要求や読み取り要求のバイト範囲よりもかなり前のバイト範囲でレイアウトを要求し続けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o This strategy is as above, but the client fails to detect the pattern, but the server does. The next time the metadata server gets a LAYOUTGET, it returns a layout with a length that is well beyond loga_minlength.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o この戦略は上記のとおりですが、クライアントはパターンを検出できませんが、サーバーはパターンを検出します。次にメタデータサーバーがLAYOUTGETを取得すると、loga_minlengthをはるかに超える長さのレイアウトが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A client is using buffered I/O, and has a long queue of write-behinds to process and also detects a sequential write pattern. It sends a LAYOUTGET for a layout that spans the range of the queued write-behinds and well beyond, including ranges beyond the filer&#39;s current length. The client continues to send LAYOUTGET operations once the write-behind queue reaches 50% of the maximum queue length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントはバッファI / Oを使用しており、処理する後書きの長いキューがあり、順次書き込みパターンも検出します。ファイラーの現在の長さを超える範囲を含む、キューに入れられた後書きの範囲にまたがるレイアウトのLAYOUTGETを送信します。後書きキューが最大キュー長の50％に達すると、クライアントはLAYOUTGET操作を送信し続けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the client has obtained a layout referring to a particular device ID, the metadata server MUST NOT delete the device ID until the layout is returned or revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが特定のデバイスIDを参照するレイアウトを取得すると、メタデータサーバーは、レイアウトが返されるか取り消されるまで、デバイスIDを削除してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_NOTIFY_DEVICEID can race with LAYOUTGET. One race scenario is that LAYOUTGET returns a device ID for which the client does not have device address mappings, and the metadata server sends a CB_NOTIFY_DEVICEID to add the device ID to the client&#39;s awareness and meanwhile the client sends GETDEVICEINFO on the device ID. This scenario is discussed in Section 18.40.4. Another scenario is that the CB_NOTIFY_DEVICEID is processed by the client before it processes the results from LAYOUTGET. The client will send a GETDEVICEINFO on the device ID. If the results from GETDEVICEINFO are received before the client gets results from LAYOUTGET, then there is no longer a race. If the results from LAYOUTGET are received before the results from GETDEVICEINFO, the client can either wait for results of GETDEVICEINFO or send another one to get possibly more up-to-date device address mappings for the device ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_NOTIFY_DEVICEIDはLAYOUTGETと競合する可能性があります。 1つのレースシナリオは、LAYOUTGETがクライアントにデバイスアドレスマッピングがないデバイスIDを返し、メタデータサーバーがCB_NOTIFY_DEVICEIDを送信してデバイスIDをクライアントの認識に追加し、その間にクライアントがデバイスIDでGETDEVICEINFOを送信するというものです。このシナリオについては、セクション18.40.4で説明します。別のシナリオは、CB_NOTIFY_DEVICEIDがLAYOUTGETからの結果を処理する前にクライアントによって処理されることです。クライアントはデバイスIDでGETDEVICEINFOを送信します。クライアントがLAYOUTGETから結果を取得する前にGETDEVICEINFOからの結果が受信された場合、競合はありません。 LAYOUTGETの結果がGETDEVICEINFOの結果よりも前に受信される場合、クライアントはGETDEVICEINFOの結果を待つか、別の結果を送信して、デバイスIDの最新のデバイスアドレスマッピングを取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-44--Operation-51-LAYOUTRETURN---Release-Layout-Information">
18.44. Operation 51: LAYOUTRETURN - Release Layout Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.44. 操作51：LAYOUTRETURN-リリースレイアウト情報
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-44-1--ARGUMENT">
18.44.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.44.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Constants used for LAYOUTRETURN and CB_LAYOUTRECALL */
   const LAYOUT4_RET_REC_FILE      = 1;
   const LAYOUT4_RET_REC_FSID      = 2;
   const LAYOUT4_RET_REC_ALL       = 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum layoutreturn_type4 {
           LAYOUTRETURN4_FILE = LAYOUT4_RET_REC_FILE,
           LAYOUTRETURN4_FSID = LAYOUT4_RET_REC_FSID,
           LAYOUTRETURN4_ALL  = LAYOUT4_RET_REC_ALL
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct layoutreturn_file4 {
           offset4         lrf_offset;
           length4         lrf_length;
           stateid4        lrf_stateid;
           /* layouttype4 specific data */
           opaque          lrf_body&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union layoutreturn4 switch(layoutreturn_type4 lr_returntype) {
           case LAYOUTRETURN4_FILE:
                   layoutreturn_file4      lr_layout;
           default:
                   void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LAYOUTRETURN4args {
           /* CURRENT_FH: file */
           bool                    lora_reclaim;
           layouttype4             lora_layout_type;
           layoutiomode4           lora_iomode;
           layoutreturn4           lora_layoutreturn;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-44-2--RESULT">
18.44.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.44.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union layoutreturn_stateid switch (bool lrs_present) {
   case TRUE:
           stateid4                lrs_stateid;
   case FALSE:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LAYOUTRETURN4res switch (nfsstat4 lorr_status) {
   case NFS4_OK:
           layoutreturn_stateid    lorr_stateid;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-44-3--DESCRIPTION">
18.44.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.44.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 This operation returns from the client to the server one or more layouts represented by the client ID (derived from the session ID in the preceding SEQUENCE operation), lora_layout_type, and lora_iomode. When lr_returntype is LAYOUTRETURN4_FILE, the returned layout is further identified by the current filehandle, lrf_offset, lrf_length, and lrf_stateid. If the lrf_length field is NFS4_UINT64_MAX, all bytes of the layout, starting at lrf_offset, are returned. When lr_returntype is LAYOUTRETURN4_FSID, the current filehandle is used to identify the file system and all layouts matching the client ID, the fsid of the file system, lora_layout_type, and lora_iomode are returned. When lr_returntype is LAYOUTRETURN4_ALL, all layouts matching the client ID, lora_layout_type, and lora_iomode are returned and the current filehandle is not used. After this call, the client MUST NOT use the returned layout(s) and the associated storage protocol to access the file data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
この操作は、クライアントからサーバーに、クライアントID（前のSEQUENCE操作のセッションIDから派生）、lora_layout_type、およびlora_iomodeで表される1つ以上のレイアウトを返します。 lr_returntypeがLAYOUTRETURN4_FILEの場合、返されるレイアウトは、現在のファイルハンドル、lrf_offset、lrf_length、およびlrf_stateidによってさらに識別されます。 lrf_lengthフィールドがNFS4_UINT64_MAXの場合、lrf_offsetから始まるレイアウトのすべてのバイトが返されます。 lr_returntypeがLAYOUTRETURN4_FSIDの場合、現在のファイルハンドルを使用してファイルシステムが識別され、クライアントID、ファイルシステムのfsid、lora_layout_type、lora_iomodeに一致するすべてのレイアウトが返されます。 lr_returntypeがLAYOUTRETURN4_ALLの場合、クライアントID、lora_layout_type、およびlora_iomodeに一致するすべてのレイアウトが返され、現在のファイルハンドルは使用されません。この呼び出しの後、クライアントは返されたレイアウトと関連するストレージプロトコルを使用してファイルデータにアクセスしてはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the set of layouts designated in the case of LAYOUTRETURN4_FSID or LAYOUTRETURN4_ALL is empty, then no error results. In the case of LAYOUTRETURN4_FILE, the byte-range specified is returned even if it is a subdivision of a layout previously obtained with LAYOUTGET, a combination of multiple layouts previously obtained with LAYOUTGET, or a combination including some layouts previously obtained with LAYOUTGET, and one or more subdivisions of such layouts. When the byte-range does not designate any bytes for which a layout is held for the specified file, client ID, layout type and mode, no error results. See Section 12.5.5.2.1.5 for considerations with &#34;bulk&#34; return of layouts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTRETURN4_FSIDまたはLAYOUTRETURN4_ALLの場合に指定されたレイアウトのセットが空の場合、エラーは発生しません。 LAYOUTRETURN4_FILEの場合、LAYOUTGETで以前に取得したレイアウトのサブディビジョン、LAYOUTGETで以前に取得した複数のレイアウトの組み合わせ、またはLAYOUTGETで以前に取得したいくつかのレイアウトを含む組み合わせ、および1つでも、指定されたバイト範囲が返されます。このようなレイアウトのサブディビジョン。バイト範囲が、指定されたファイル、クライアントID、レイアウトタイプ、およびモードのレイアウトが保持されるバイトを指定していない場合、エラーは発生しません。レイアウトの「バルク」リターンに関する考慮事項については、セクション12.5.5.2.1.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layout being returned may be a subset or superset of a layout specified by CB_LAYOUTRECALL. However, if it is a subset, the recall is not complete until the full recalled scope has been returned. Recalled scope refers to the byte-range in the case of LAYOUTRETURN4_FILE, the use of LAYOUTRETURN4_FSID, or the use of LAYOUTRETURN4_ALL. There must be a LAYOUTRETURN with a matching scope to complete the return even if all current layout ranges have been previously individually returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
返されるレイアウトは、CB_LAYOUTRECALLで指定されたレイアウトのサブセットまたはスーパーセットです。ただし、それがサブセットである場合、完全に再呼び出しされたスコープが返されるまで、再呼び出しは完了しません。呼び出されたスコープは、LAYOUTRETURN4_FILE、LAYOUTRETURN4_FSIDの使用、またはLAYOUTRETURN4_ALLの使用の場合のバイト範囲を指します。すべての現在のレイアウト範囲が以前に個別に返されていたとしても、返却を完了するには、一致するスコープを持つLAYOUTRETURNが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For all lr_returntype values, an iomode of LAYOUTIOMODE4_ANY specifies that all layouts that match the other arguments to LAYOUTRETURN (i.e., client ID, lora_layout_type, and one of current filehandle and range; fsid derived from current filehandle; or LAYOUTRETURN4_ALL) are being returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのlr_returntype値について、LAYOUTIOMODE4_ANYのiomodeは、LAYOUTRETURNの他の引数（つまり、クライアントID、lora_layout_type、および現在のファイルハンドルと範囲の1つ、現在のファイルハンドルから派生したfsid、またはLAYOUTRETURN4_ALL）に一致するすべてのレイアウトが返されることを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that lr_returntype is LAYOUTRETURN4_FILE, the lrf_stateid provided by the client is a layout stateid as returned from previous layout operations. Note that the &#34;seqid&#34; field of lrf_stateid MUST NOT be zero. See Sections 8.2, 12.5.3, and 12.5.5.2 for a further discussion and requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lr_returntypeがLAYOUTRETURN4_FILEの場合、クライアントから提供されたlrf_stateidは、前のレイアウト操作から返されたレイアウト状態IDです。 lrf_stateidの「seqid」フィールドはゼロであってはならないことに注意してください。詳細な説明と要件については、セクション8.2、12.5.3、および12.5.5.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Return of a layout or all layouts does not invalidate the mapping of storage device ID to a storage device address. The mapping remains in effect until specifically changed or deleted via device ID notification callbacks. Of course if there are no remaining layouts that refer to a previously used device ID, the server is free to delete a device ID without a notification callback, which will be the case when notifications are not in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
レイアウトまたはすべてのレイアウトを返しても、ストレージデバイスIDのストレージデバイスアドレスへのマッピングは無効になりません。マッピングは、デバイスID通知コールバックによって明確に変更または削除されるまで有効です。もちろん、以前に使用されたデバイスIDを参照するレイアウトが残っていない場合、サーバーは通知コールバックなしでデバイスIDを自由に削除できます。これは、通知が有効でない場合に当てはまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the lora_reclaim field is set to TRUE, the client is attempting to return a layout that was acquired before the restart of the metadata server during the metadata server&#39;s grace period. When returning layouts that were acquired during the metadata server&#39;s grace period, the client MUST set the lora_reclaim field to FALSE. The lora_reclaim field MUST be set to FALSE also when lr_layoutreturn is LAYOUTRETURN4_FSID or LAYOUTRETURN4_ALL. See LAYOUTCOMMIT (Section 18.42) for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lora_reclaimフィールドがTRUEに設定されている場合、クライアントは、メタデータサーバーの猶予期間中にメタデータサーバーの再起動前に取得されたレイアウトを返そうとしています。メタデータサーバーの猶予期間中に取得されたレイアウトを返す場合、クライアントはlora_reclaimフィールドをFALSEに設定する必要があります。 lr_layoutreturnがLAYOUTRETURN4_FSIDまたはLAYOUTRETURN4_ALLの場合も、lora_reclaimフィールドをFALSEに設定する必要があります。詳細については、LAYOUTCOMMIT（セクション18.42）を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Layouts may be returned when recalled or voluntarily (i.e., before the server has recalled them). In either case, the client must properly propagate state changed under the context of the layout to the storage device(s) or to the metadata server before returning the layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトは、リコール時または自発的に（つまり、サーバーがそれらをリコールする前に）返される場合があります。どちらの場合も、レイアウトを返す前に、クライアントはレイアウトのコンテキストで変更された状態をストレージデバイスまたはメタデータサーバーに適切に伝達する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client returns the layout in response to a CB_LAYOUTRECALL where the lor_recalltype field of the clora_recall field was LAYOUTRECALL4_FILE, the client should use the lor_stateid value from CB_LAYOUTRECALL as the value for lrf_stateid. Otherwise, it should use logr_stateid (from a previous LAYOUTGET result) or lorr_stateid (from a previous LAYRETURN result). This is done to indicate the point in time (in terms of layout stateid transitions) when the recall was sent. The client uses the precise lora_recallstateid value and MUST NOT set the stateid&#39;s seqid to zero; otherwise, NFS4ERR_BAD_STATEID MUST be returned. NFS4ERR_OLD_STATEID can be returned if the client is using an old seqid, and the server knows the client should not be using the old seqid. For example, the client uses the seqid on slot 1 of the session, receives the response with the new seqid, and uses the slot to send another request with the old seqid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが、clora_recallフィールドのlor_recalltypeフィールドがLAYOUTRECALL4_FILEであったCB_LAYOUTRECALLに応答してレイアウトを返す場合、クライアントはCB_LAYOUTRECALLのlor_stateid値をlrf_stateidの値として使用する必要があります。それ以外の場合は、logr_stateid（以前のLAYOUTGET結果から）またはlorr_stateid（以前のLAYRETURN結果から）を使用する必要があります。これは、再呼び出しが送信された時点（レイアウトステートIDの遷移に関して）を示すために行われます。クライアントは正確なlora_recallstateid値を使用し、stateidのseqidをゼロに設定してはなりません（MUST NOT）。それ以外の場合は、NFS4ERR_BAD_STATEIDを返す必要があります。 NFS4ERR_OLD_STATEIDは、クライアントが古いseqidを使用していて、サーバーがクライアントが古いseqidを使用してはならないことを認識している場合に返される可能性があります。たとえば、クライアントはセッションのスロット1でseqidを使用し、新しいseqidで応答を受信し、スロットを使用して古いseqidで別の要求を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client fails to return a layout in a timely manner, then the metadata server SHOULD use its control protocol with the storage devices to fence the client from accessing the data referenced by the layout. See Section 12.5.5 for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがレイアウトをタイムリーに返さなかった場合、メタデータサーバーは、ストレージデバイスでその制御プロトコルを使用して、クライアントがレイアウトで参照されているデータにアクセスできないようにする必要があります。詳細については、セクション12.5.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the LAYOUTRETURN request sets the lora_reclaim field to TRUE after the metadata server&#39;s grace period, NFS4ERR_NO_GRACE is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーの猶予期間の後にLAYOUTRETURN要求がlora_reclaimフィールドをTRUEに設定すると、NFS4ERR_NO_GRACEが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the LAYOUTRETURN request sets the lora_reclaim field to TRUE and lr_returntype is set to LAYOUTRETURN4_FSID or LAYOUTRETURN4_ALL, NFS4ERR_INVAL is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTRETURN要求がlora_reclaimフィールドをTRUEに設定し、lr_returntypeがLAYOUTRETURN4_FSIDまたはLAYOUTRETURN4_ALLに設定されている場合、NFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client sets the lr_returntype field to LAYOUTRETURN4_FILE, then the lrs_stateid field will represent the layout stateid as updated for this operation&#39;s processing; the current stateid will also be updated to match the returned value. If the last byte of any layout for the current file, client ID, and layout type is being returned and there are no remaining pending CB_LAYOUTRECALL operations for which a LAYOUTRETURN operation must be done, lrs_present MUST be FALSE, and no stateid will be returned. In addition, the COMPOUND request&#39;s current stateid will be set to the all-zeroes special stateid (see Section 16.2.3.1.2). The server MUST reject with NFS4ERR_BAD_STATEID any further use of the current stateid in that COMPOUND until the current stateid is re-established by a later stateid-returning operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがlr_returntypeフィールドをLAYOUTRETURN4_FILEに設定した場合、lrs_stateidフィールドは、この操作の処理で更新されたレイアウトの状態IDを表します。現在の状態IDも、戻り値と一致するように更新されます。現在のファイル、クライアントID、およびレイアウトタイプのレイアウトの最後のバイトが返され、LAYOUTRETURN操作を実行する必要がある保留中のCB_LAYOUTRECALL操作が残っていない場合、lrs_presentはFALSEでなければならず、stateidは返されません。さらに、COMPOUNDリクエストの現在の状態IDは、すべてゼロの特別な状態IDに設定されます（セクション16.2.3.1.2を参照）。サーバーは、現在の状態IDが後の状態IDを返す操作によって再確立されるまで、NFS4ERR_BAD_STATEIDを使用して、そのCOMPOUNDで現在の状態IDをさらに使用することを拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the EXCHGID4_FLAG_BIND_PRINC_STATEID capability is set on the client ID (see Section 18.35), the server will require that the principal, security flavor, and if applicable, the GSS mechanism, combination that acquired the layout also be the one to send LAYOUTRETURN. This might not be possible if credentials for the principal are no longer available. The server will allow the machine credential or SSV credential (see Section 18.35) to send LAYOUTRETURN if LAYOUTRETURN&#39;s operation code was set in the spo_must_allow result of EXCHANGE_ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCHGID4_FLAG_BIND_PRINC_STATEID機能がクライアントIDに設定されている場合（セクション18.35を参照）、サーバーは、レイアウトを取得したプリンシパル、セキュリティフレーバー、および該当する場合はGSSメカニズムの組み合わせが、LAYOUTRETURNを送信するものであることを要求します。プリンシパルの資格情報が使用できなくなった場合、これは不可能である可能性があります。 EXCHANGE_IDのspo_must_allow結果にLAYOUTRETURNの操作コードが設定されている場合、サーバーはマシン資格情報またはSSV資格情報（セクション18.35を参照）がLAYOUTRETURNを送信できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-44-4--IMPLEMENTATION">
18.44.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.44.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The final LAYOUTRETURN operation in response to a CB_LAYOUTRECALL callback MUST be serialized with any outstanding, intersecting LAYOUTRETURN operations. Note that it is possible that while a client is returning the layout for some recalled range, the server may recall a superset of that range (e.g., LAYOUTRECALL4_ALL); the final return operation for the latter must block until the former layout recall is done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_LAYOUTRECALLコールバックに応答する最後のLAYOUTRETURN操作は、未処理の交差するLAYOUTRETURN操作でシリアル化する必要があります。クライアントがリコールされた範囲のレイアウトを返している間に、サーバーがその範囲のスーパーセットをリコールする可能性があることに注意してください（例：LAYOUTRECALL4_ALL）。後者の最後の戻り操作は、前のレイアウトの呼び出しが完了するまでブロックする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Returning all layouts in a file system using LAYOUTRETURN4_FSID is typically done in response to a CB_LAYOUTRECALL for that file system as the final return operation. Similarly, LAYOUTRETURN4_ALL is used in response to a recall callback for all layouts. It is possible that the client already returned some outstanding layouts via individual LAYOUTRETURN calls and the call for LAYOUTRETURN4_FSID or LAYOUTRETURN4_ALL marks the end of the LAYOUTRETURN sequence. See Section 12.5.5.1 for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTRETURN4_FSIDを使用してファイルシステムのすべてのレイアウトを返すことは、通常、そのファイルシステムのCB_LAYOUTRECALLに応答して行われ、最後の戻り操作として行われます。同様に、LAYOUTRETURN4_ALLは、すべてのレイアウトの再呼び出しコールバックに応答して使用されます。クライアントが既に個々のLAYOUTRETURN呼び出しを介していくつかの未解決のレイアウトを返し、LAYOUTRETURN4_FSIDまたはLAYOUTRETURN4_ALLの呼び出しがLAYOUTRETURNシーケンスの終わりをマークしている可能性があります。詳細については、セクション12.5.5.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the client has returned all layouts referring to a particular device ID, the server MAY delete the device ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが特定のデバイスIDを参照するすべてのレイアウトを返したら、サーバーはデバイスIDを削除してもよい（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-45--Operation-52-SECINFONONAME---Get-Security-on-Unnamed-Object">
18.45. Operation 52: SECINFO_NO_NAME - Get Security on Unnamed Object
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.45. 操作52：SECINFO_NO_NAME-名前のないオブジェクトのセキュリティを取得する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-45-1--ARGUMENT">
18.45.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.45.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum secinfo_style4 {
           SECINFO_STYLE4_CURRENT_FH       = 0,
           SECINFO_STYLE4_PARENT           = 1
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* CURRENT_FH: object or child directory */
   typedef secinfo_style4 SECINFO_NO_NAME4args;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-45-2--RESULT">
18.45.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.45.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* CURRENTFH: consumed if status is NFS4_OK */
   typedef SECINFO4res SECINFO_NO_NAME4res;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-45-3--DESCRIPTION">
18.45.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.45.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Like the SECINFO operation, SECINFO_NO_NAME is used by the client to obtain a list of valid RPC authentication flavors for a specific file object. Unlike SECINFO, SECINFO_NO_NAME only works with objects that are accessed by filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFO操作と同様に、SECINFO_NO_NAMEはクライアントによって使用され、特定のファイルオブジェクトの有効なRPC認証フレーバーのリストを取得します。 SECINFOとは異なり、SECINFO_NO_NAMEはファイルハンドルによってアクセスされるオブジェクトでのみ機能します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two styles of SECINFO_NO_NAME, as determined by the value of the secinfo_style4 enumeration. If SECINFO_STYLE4_CURRENT_FH is passed, then SECINFO_NO_NAME is querying for the required security for the current filehandle. If SECINFO_STYLE4_PARENT is passed, then SECINFO_NO_NAME is querying for the required security of the current filehandle&#39;s parent. If the style selected is SECINFO_STYLE4_PARENT, then SECINFO should apply the same access methodology used for LOOKUPP when evaluating the traversal to the parent directory. Therefore, if the requester does not have the appropriate access to LOOKUPP the parent, then SECINFO_NO_NAME must behave the same way and return NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
secinfo_style4列挙の値によって決定されるように、SECINFO_NO_NAMEには2つのスタイルがあります。 SECINFO_STYLE4_CURRENT_FHが渡された場合、SECINFO_NO_NAMEは現在のファイルハンドルに必要なセキュリティを照会しています。 SECINFO_STYLE4_PARENTが渡された場合、SECINFO_NO_NAMEは現在のファイルハンドルの親に必要なセキュリティを照会しています。選択したスタイルがSECINFO_STYLE4_PARENTの場合、親ディレクトリへのトラバーサルを評価するときに、SECINFOはLOOKUPPに使用されるのと同じアクセス方法を適用する必要があります。したがって、リクエスターが親であるLOOKUPPへの適切なアクセス権を持っていない場合、SECINFO_NO_NAMEは同じように動作し、NFS4ERR_ACCESSを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If PUTFH, PUTPUBFH, PUTROOTFH, or RESTOREFH returns NFS4ERR_WRONGSEC, then the client resolves the situation by sending a COMPOUND request that consists of PUTFH, PUTPUBFH, or PUTROOTFH immediately followed by SECINFO_NO_NAME, style SECINFO_STYLE4_CURRENT_FH. See Section 2.6 for instructions on dealing with NFS4ERR_WRONGSEC error returns from PUTFH, PUTROOTFH, PUTPUBFH, or RESTOREFH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUTFH、PUTPUBFH、PUTROOTFH、またはRESTOREFHがNFS4ERR_WRONGSECを返す場合、クライアントは、PUTFH、PUTPUBFH、またはPUTROOTFHの直後にSECINFO_NO_NAME、スタイルSECINFO_STYLE4_CURRENT_FHが続くCOMPOUND要求を送信することにより、状況を解決します。 PUTFH、PUTROOTFH、PUTPUBFH、またはRESTOREFHからのNFS4ERR_WRONGSECエラー戻りの処理方法については、セクション2.6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If SECINFO_STYLE4_PARENT is specified and there is no parent directory, SECINFO_NO_NAME MUST return NFS4ERR_NOENT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFO_STYLE4_PARENTが指定されていて、親ディレクトリがない場合、SECINFO_NO_NAMEはNFS4ERR_NOENTを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle is consumed (see Section 2.6.3.1.1.8), and if the next operation after SECINFO_NO_NAME tries to use the current filehandle, that operation will fail with the status NFS4ERR_NOFILEHANDLE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルが消費され（セクション2.6.3.1.1.8を参照）、SECINFO_NO_NAMEの後の次の操作で現在のファイルハンドルを使用しようとすると、その操作はステータスNFS4ERR_NOFILEHANDLEで失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Everything else about SECINFO_NO_NAME is the same as SECINFO. See the discussion on SECINFO (Section 18.29.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFO_NO_NAMEに関する他のすべてはSECINFOと同じです。 SECINFO（セクション18.29.3）に関する説明を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-45-4--IMPLEMENTATION">
18.45.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.45.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See the discussion on SECINFO (Section 18.29.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFO（セクション18.29.4）に関する説明を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
18.46. Operation 53: SEQUENCE - Supply Per-Procedure Sequencing and Control
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
18.46. 操作53：シーケンス-手順ごとのシーケンスと制御を提供
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-46-1--ARGUMENT">
18.46.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.46.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SEQUENCE4args {
           sessionid4     sa_sessionid;
           sequenceid4    sa_sequenceid;
           slotid4        sa_slotid;
           slotid4        sa_highest_slotid;
           bool           sa_cachethis;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-46-2--RESULT">
18.46.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.46.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const SEQ4_STATUS_CB_PATH_DOWN                  = 0x00000001;
   const SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRING      = 0x00000002;
   const SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED       = 0x00000004;
   const SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED     = 0x00000008;
   const SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED    = 0x00000010;
   const SEQ4_STATUS_ADMIN_STATE_REVOKED           = 0x00000020;
   const SEQ4_STATUS_RECALLABLE_STATE_REVOKED      = 0x00000040;
   const SEQ4_STATUS_LEASE_MOVED                   = 0x00000080;
   const SEQ4_STATUS_RESTART_RECLAIM_NEEDED        = 0x00000100;
   const SEQ4_STATUS_CB_PATH_DOWN_SESSION          = 0x00000200;
   const SEQ4_STATUS_BACKCHANNEL_FAULT             = 0x00000400;
   const SEQ4_STATUS_DEVID_CHANGED                 = 0x00000800;
   const SEQ4_STATUS_DEVID_DELETED                 = 0x00001000;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SEQUENCE4resok {
           sessionid4      sr_sessionid;
           sequenceid4     sr_sequenceid;
           slotid4         sr_slotid;
           slotid4         sr_highest_slotid;
           slotid4         sr_target_highest_slotid;
           uint32_t        sr_status_flags;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union SEQUENCE4res switch (nfsstat4 sr_status) {
   case NFS4_OK:
           SEQUENCE4resok  sr_resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-46-3--DESCRIPTION">
18.46.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.46.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SEQUENCE operation is used by the server to implement session request control and the reply cache semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQUENCE操作は、セッション要求制御と応答キャッシュのセマンティクスを実装するためにサーバーによって使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQUENCE MUST appear as the first operation of any COMPOUND in which it appears. The error NFS4ERR_SEQUENCE_POS will be returned when it is found in any position in a COMPOUND beyond the first. Operations other than SEQUENCE, BIND_CONN_TO_SESSION, EXCHANGE_ID, CREATE_SESSION, and DESTROY_SESSION, MUST NOT appear as the first operation in a COMPOUND. Such operations MUST yield the error NFS4ERR_OP_NOT_IN_SESSION if they do appear at the start of a COMPOUND.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQUENCEは、それが出現するCOMPOUNDの最初の操作として出現する必要があります。エラーNFS4ERR_SEQUENCE_POSは、COMPOUNDの最初の位置を超えた位置で見つかった場合に返されます。 SEQUENCE、BIND_CONN_TO_SESSION、EXCHANGE_ID、CREATE_SESSION、およびDESTROY_SESSION以外の操作は、COMPOUNDの最初の操作として表示しないでください。 COMPOUNDの先頭に表示される場合、このような操作はエラーNFS4ERR_OP_NOT_IN_SESSIONを生成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If SEQUENCE is received on a connection not associated with the session via CREATE_SESSION or BIND_CONN_TO_SESSION, and connection association enforcement is enabled (see Section 18.35), then the server returns NFS4ERR_CONN_NOT_BOUND_TO_SESSION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATE_SESSIONまたはBIND_CONN_TO_SESSIONを介してセッションに関連付けられていない接続でSEQUENCEを受信し、接続の関連付けの強制が有効になっている場合（項18.35を参照）、サーバーはNFS4ERR_CONN_NOT_BOUND_TO_SESSIONを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sa_sessionid argument identifies the session to which this request applies. The sr_sessionid result MUST equal sa_sessionid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sa_sessionid引数は、この要求が適用されるセッションを識別します。 sr_sessionidの結果は、sa_sessionidと等しくなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sa_slotid argument is the index in the reply cache for the request. The sa_sequenceid field is the sequence number of the request for the reply cache entry (slot). The sr_slotid result MUST equal sa_slotid. The sr_sequenceid result MUST equal sa_sequenceid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sa_slotid引数は、要求の応答キャッシュ内のインデックスです。 sa_sequenceidフィールドは、応答キャッシュエントリ（スロット）の要求のシーケンス番号です。 sr_slotidの結果は、sa_slotidと等しくなければなりません。 sr_sequenceidの結果は、sa_sequenceidと等しくなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The sa_highest_slotid argument is the highest slot ID for which the client has a request outstanding; it could be equal to sa_slotid. The server returns two &#34;highest_slotid&#34; values: sr_highest_slotid and sr_target_highest_slotid. The former is the highest slot ID the server will accept in future SEQUENCE operation, and SHOULD NOT be less than the value of sa_highest_slotid (but see Section 2.10.6.1 for an exception). The latter is the highest slot ID the server would prefer the client use on a future SEQUENCE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
sa_highest_slotid引数は、クライアントに未解決の要求がある最大のスロットIDです。これは、sa_slotidと等しい場合があります。サーバーは2つの「highest_slotid」値を返します：sr_highest_slotidとsr_target_highest_slotid。前者は、サーバーが今後のSEQUENCE操作で受け入れる最大のスロットIDであり、sa_highest_slotidの値よりも小さくしてはなりません（ただし、例外については、セクション2.10.6.1を参照）。後者は、サーバーがクライアントが将来のSEQUENCE操作で使用することを好む最高のスロットIDです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If sa_cachethis is TRUE, then the client is requesting that the server cache the entire reply in the server&#39;s reply cache; therefore, the server MUST cache the reply (see Section 2.10.6.1.3). The server MAY cache the reply if sa_cachethis is FALSE. If the server does not cache the entire reply, it MUST still record that it executed the request at the specified slot and sequence ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sa_cachethisがTRUEの場合、クライアントはサーバーが応答全体をサーバーの応答キャッシュにキャッシュすることを要求しています。したがって、サーバーは応答をキャッシュする必要があります（セクション2.10.6.1.3を参照）。 sa_cachethisがFALSEの場合、サーバーは応答をキャッシュできます（MAY）。サーバーが応答全体をキャッシュしない場合でも、サーバーは指定されたスロットとシーケンスIDで要求を実行したことを記録する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The response to the SEQUENCE operation contains a word of status flags (sr_status_flags) that can provide to the client information related to the status of the client&#39;s lock state and communications paths. Note that any status bits relating to lock state MAY be reset when lock state is lost due to a server restart (even if the session is persistent across restarts; session persistence does not imply lock state persistence) or the establishment of a new client instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQUENCE操作への応答には、クライアントのロック状態と通信パスのステータスに関する情報をクライアントに提供できるステータスフラグ（sr_status_flags）が含まれています。ロック状態に関連するステータスビットは、サーバーの再起動（セッションが再起動後も永続的である場合でも、セッションの永続性はロック状態の永続性を意味しない）または新しいクライアントインスタンスの確立によりロック状態が失われるとリセットされる可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_CB_PATH_DOWN When set, indicates that the client has no operational backchannel path for any session associated with the client ID, making it necessary for the client to re-establish one. This bit remains set on all SEQUENCE responses on all sessions associated with the client ID until at least one backchannel is available on any session associated with the client ID. If the client fails to re-establish a backchannel for the client ID, it is subject to having recallable state revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_CB_PATH_DOWN設定されている場合、クライアントが、クライアントIDに関連付けられたセッションに対して動作可能なバックチャネルパスを持たないことを示し、クライアントが1つを再確立する必要があります。このビットは、クライアントIDに関連付けられたセッションで少なくとも1つのバックチャネルが使用可能になるまで、クライアントIDに関連付けられたすべてのセッションのすべてのSEQUENCE応答で設定されたままになります。クライアントがクライアントIDのバックチャネルの再確立に失敗した場合、再呼び出し可能な状態が取り消される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_CB_PATH_DOWN_SESSION When set, indicates that the session has no operational backchannel. There are two reasons why SEQ4_STATUS_CB_PATH_DOWN_SESSION may be set and not SEQ4_STATUS_CB_PATH_DOWN. First is that a callback operation that applies specifically to the session (e.g., CB_RECALL_SLOT, see Section 20.8) needs to be sent. Second is that the server did send a callback operation, but the connection was lost before the reply. The server cannot be sure whether or not the client received the callback operation, and so, per rules on request retry, the server MUST retry the callback operation over the same session. The SEQ4_STATUS_CB_PATH_DOWN_SESSION bit is the indication to the client that it needs to associate a connection to the session&#39;s backchannel. This bit remains set on all SEQUENCE responses of the session until a connection is associated with the session&#39;s a backchannel. If the client fails to re-establish a backchannel for the session, it is subject to having recallable state revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_CB_PATH_DOWN_SESSION設定されている場合、セッションに操作可能なバックチャネルがないことを示します。 SEQ4_STATUS_CB_PATH_DOWNではなく、SEQ4_STATUS_CB_PATH_DOWN_SESSIONが設定される理由は2つあります。 1つ目は、セッションに特に適用されるコールバック操作（CB_RECALL_SLOTなど）を送信する必要があることです。 2つ目は、サーバーがコールバック操作を送信したが、応答の前に接続が失われたことです。サーバーは、クライアントがコールバック操作を受信したかどうかを確認できないため、リクエストの再試行に関するルールに従って、サーバーは同じセッションでコールバック操作を再試行する必要があります。 SEQ4_STATUS_CB_PATH_DOWN_SESSIONビットは、セッションのバックチャネルへの接続を関連付ける必要があることをクライアントに示します。このビットは、接続がセッションのバックチャネルに関連付けられるまで、セッションのすべてのSEQUENCE応答で設定されたままになります。クライアントがセッションのバックチャネルの再確立に失敗した場合、クライアントは再呼び出し可能な状態が取り消される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRING When set, indicates that all GSS contexts or RPCSEC_GSS handles assigned to the session&#39;s backchannel will expire within a period equal to the lease time. This bit remains set on all SEQUENCE replies until at least one of the following are true:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRING設定されている場合、セッションのバックチャネルに割り当てられているすべてのGSSコンテキストまたはRPCSEC_GSSハンドルがリース時間と同じ期間内に期限切れになることを示します。このビットは、以下の少なくとも1つが当てはまるまで、すべてのSEQUENCE応答で設定されたままになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* All SSV RPCSEC_GSS handles on the session&#39;s backchannel have been destroyed and all non-SSV GSS contexts have expired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* セッションのバックチャネルのすべてのSSV RPCSEC_GSSハンドルが破棄され、SSV以外のすべてのGSSコンテキストが期限切れになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* At least one more SSV RPCSEC_GSS handle has been added to the backchannel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 少なくとも1つのSSV RPCSEC_GSSハンドルがバックチャネルに追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The expiration time of at least one non-SSV GSS context of an RPCSEC_GSS handle is beyond the lease period from the current time (relative to the time of when a SEQUENCE response was sent)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* RPCSEC_GSSハンドルの少なくとも1つの非SSV GSSコンテキストの有効期限が、現在の時間からのリース期間を超えています（SEQUENCE応答が送信された時間と比較して）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED When set, indicates all non-SSV GSS contexts and all SSV RPCSEC_GSS handles assigned to the session&#39;s backchannel have expired or have been destroyed. This bit remains set on all SEQUENCE replies until at least one non-expired non-SSV GSS context for the session&#39;s backchannel has been established or at least one SSV RPCSEC_GSS handle has been assigned to the backchannel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED設定されている場合、セッションのバックチャネルに割り当てられているすべての非SSV GSSコンテキストとすべてのSSV RPCSEC_GSSハンドルが期限切れまたは破棄されていることを示します。このビットは、セッションのバックチャネルの少なくとも1つの期限切れでない非SSV GSSコンテキストが確立されるか、少なくとも1つのSSV RPCSEC_GSSハンドルがバックチャネルに割り当てられるまで、すべてのSEQUENCE応答で設定されたままになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED When set, indicates that the lease has expired and as a result the server released all of the client&#39;s locking state. This status bit remains set on all SEQUENCE replies until the loss of all such locks has been acknowledged by use of FREE_STATEID (see Section 18.38), or by establishing a new client instance by destroying all sessions (via DESTROY_SESSION), the client ID (via DESTROY_CLIENTID), and then invoking EXCHANGE_ID and CREATE_SESSION to establish a new client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED設定されている場合、リースが期限切れになり、その結果、サーバーがクライアントのロック状態をすべて解放したことを示します。このステータスビットは、FREE_STATEIDを使用して（セクション18.38を参照）、またはすべてのセッションを破棄して（DESTROY_SESSIONを介して）新しいクライアントインスタンスを確立し、クライアントID（を介して）によって新しいクライアントインスタンスを確立するまで、すべてのSEQUENCE応答で設定されたままになります。 DESTROY_CLIENTID）、次にEXCHANGE_IDとCREATE_SESSIONを呼び出して、新しいクライアントIDを確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED When set, indicates that some subset of the client&#39;s locks have been revoked due to expiration of the lease period followed by another client&#39;s conflicting LOCK operation. This status bit remains set on all SEQUENCE replies until the loss of all such locks has been acknowledged by use of FREE_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED設定されている場合、リース期間の満了後にクライアントのロックの一部のサブセットが取り消され、その後、別のクライアントの競合するLOCK操作が行われたことを示します。このステータスビットは、FREE_STATEIDを使用してそのようなロックがすべて失われたことが確認されるまで、すべてのSEQUENCE応答で設定されたままになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_ADMIN_STATE_REVOKED When set, indicates that one or more locks have been revoked without expiration of the lease period, due to administrative action. This status bit remains set on all SEQUENCE replies until the loss of all such locks has been acknowledged by use of FREE_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_ADMIN_STATE_REVOKED設定されている場合、管理アクションが原因で、リース期間が満了せずに1つ以上のロックが取り消されたことを示します。このステータスビットは、FREE_STATEIDを使用してそのようなロックがすべて失われたことが確認されるまで、すべてのSEQUENCE応答で設定されたままになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_RECALLABLE_STATE_REVOKED When set, indicates that one or more recallable objects have been revoked without expiration of the lease period, due to the client&#39;s failure to return them when recalled, which may be a consequence of there being no working backchannel and the client failing to re-establish a backchannel per the SEQ4_STATUS_CB_PATH_DOWN, SEQ4_STATUS_CB_PATH_DOWN_SESSION, or SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED status flags. This status bit remains set on all SEQUENCE replies until the loss of all such locks has been acknowledged by use of FREE_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_RECALLABLE_STATE_REVOKED設定されている場合、1つ以上のリコール可能なオブジェクトが、リコール時にクライアントがオブジェクトを返せなかったためにリース期間が満了せずに取り消されたことを示します。これは、有効なバックチャネルがなく、クライアントが再SEQ4_STATUS_CB_PATH_DOWN、SEQ4_STATUS_CB_PATH_DOWN_SESSION、またはSEQ4_STATUS_CB_GSS_CONTEXTS_EXPIREDステータスフラグごとにバックチャネルを確立します。このステータスビットは、FREE_STATEIDを使用してそのようなロックがすべて失われたことが確認されるまで、すべてのSEQUENCE応答で設定されたままになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_LEASE_MOVED When set, indicates that responsibility for lease renewal has been transferred to one or more new servers. This condition will continue until the client receives an NFS4ERR_MOVED error and the server receives the subsequent GETATTR for the fs_locations or fs_locations_info attribute for an access to each file system for which a lease has been moved to a new server. See Section 11.7.7.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_LEASE_MOVED設定されている場合、リースの更新の責任が1つ以上の新しいサーバーに転送されたことを示します。この状態は、クライアントがNFS4ERR_MOVEDエラーを受け取り、サーバーが、リースが新しいサーバーに移動された各ファイルシステムへのアクセスのfs_locationsまたはfs_locations_info属性の後続のGETATTRを受け取るまで続きます。セクション11.7.7.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_RESTART_RECLAIM_NEEDED When set, indicates that due to server restart, the client must reclaim locking state. Until the client sends a global RECLAIM_COMPLETE (Section 18.51), every SEQUENCE operation will return SEQ4_STATUS_RESTART_RECLAIM_NEEDED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_RESTART_RECLAIM_NEEDED設定されている場合、サーバーの再起動により、クライアントがロック状態を取り戻す必要があることを示します。クライアントがグローバルRECLAIM_COMPLETE（セクション18.51）を送信するまで、すべてのSEQUENCE操作はSEQ4_STATUS_RESTART_RECLAIM_NEEDEDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_BACKCHANNEL_FAULT The server has encountered an unrecoverable fault with the backchannel (e.g., it has lost track of the sequence ID for a slot in the backchannel). The client MUST stop sending more requests on the session&#39;s fore channel, wait for all outstanding requests to complete on the fore and back channel, and then destroy the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_BACKCHANNEL_FAULTサーバーは、バックチャネルで回復不能な障害を検出しました（たとえば、バックチャネルのスロットのシーケンスIDの追跡を失いました）。クライアントは、セッションのフォアチャネルでこれ以上のリクエストの送信を停止し、すべての未処理のリクエストがフォアチャネルとバックチャネルで完了するのを待ってから、セッションを破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_DEVID_CHANGED The client is using device ID notifications and the server has changed a device ID mapping held by the client. This flag will stay present until the client has obtained the new mapping with GETDEVICEINFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_DEVID_CHANGEDクライアントはデバイスID通知を使用しており、サーバーはクライアントが保持するデバイスIDマッピングを変更しました。このフラグは、クライアントがGETDEVICEINFOを使用して新しいマッピングを取得するまで存在し続けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_DEVID_DELETED The client is using device ID notifications and the server has deleted a device ID mapping held by the client. This flag will stay in effect until the client sends a GETDEVICEINFO on the device ID with a null value in the argument gdia_notify_types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQ4_STATUS_DEVID_DELETEDクライアントはデバイスID通知を使用しており、サーバーはクライアントが保持しているデバイスIDマッピングを削除しました。このフラグは、クライアントが引数gdia_notify_typesにnull値を指定してデバイスIDでGETDEVICEINFOを送信するまで有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value of the sa_sequenceid argument relative to the cached sequence ID on the slot falls into one of three cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スロットのキャッシュされたシーケンスIDに対するsa_sequenceid引数の値は、3つのケースのいずれかに該当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the difference between sa_sequenceid and the server&#39;s cached sequence ID at the slot ID is two (2) or more, or if sa_sequenceid is less than the cached sequence ID (accounting for wraparound of the unsigned sequence ID value), then the server MUST return NFS4ERR_SEQ_MISORDERED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o スロットIDでのsa_sequenceidとサーバーのキャッシュされたシーケンスIDの差が2（2）以上の場合、またはsa_sequenceidがキャッシュされたシーケンスID（署名されていないシーケンスID値のラップアラウンドを考慮）より小さい場合、サーバーは返さなければなりません（MUST）。 NFS4ERR_SEQ_MISORDERED。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If sa_sequenceid and the cached sequence ID are the same, this is a retry, and the server replies with what is recorded in the reply cache. The lease is possibly renewed as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sa_sequenceidとキャッシュされたシーケンスIDが同じ場合、これは再試行であり、サーバーは応答キャッシュに記録されている内容で応答します。リースは、以下のように更新される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If sa_sequenceid is one greater (accounting for wraparound) than the cached sequence ID, then this is a new request, and the slot&#39;s sequence ID is incremented. The operations subsequent to SEQUENCE, if any, are processed. If there are no other operations, the only other effects are to cache the SEQUENCE reply in the slot, maintain the session&#39;s activity, and possibly renew the lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sa_sequenceidがキャッシュされたシーケンスIDよりも1つ大きい（ラップアラウンドを考慮している）場合、これは新しい要求であり、スロットのシーケンスIDが増分されます。 SEQUENCEに続く操作があれば、それが処理されます。他の操作がない場合、他の唯一の影響は、SEQUENCE応答をスロットにキャッシュし、セッションのアクティビティを維持し、場合によってはリースを更新することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client reuses a slot ID and sequence ID for a completely different request, the server MAY treat the request as if it is a retry of what it has already executed. The server MAY however detect the client&#39;s illegal reuse and return NFS4ERR_SEQ_FALSE_RETRY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが完全に異なるリクエストのスロットIDとシーケンスIDを再利用する場合、サーバーはそのリクエストを、それがすでに実行したものの再試行であるかのように扱うことができます（MAY）。ただし、サーバーはクライアントの不正な再利用を検出して、NFS4ERR_SEQ_FALSE_RETRYを返す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If SEQUENCE returns an error, then the state of the slot (sequence ID, cached reply) MUST NOT change, and the associated lease MUST NOT be renewed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQUENCEがエラーを返す場合、スロットの状態（シーケンスID、キャッシュされた応答）を変更してはならず（MUST NOT）、関連するリースを更新してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If SEQUENCE returns NFS4_OK, then the associated lease MUST be renewed (see Section 8.3), except if SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED is returned in sr_status_flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQUENCEがNFS4_OKを返す場合、sr_status_flagsでSEQ4_STATUS_EXPIRED_ALL_STATE_REVOKEDが返される場合を除いて、関連するリースを更新する必要があります（セクション8.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-46-4--IMPLEMENTATION">
18.46.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.46.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MUST maintain a mapping of session ID to client ID in order to validate any operations that follow SEQUENCE that take a stateid as an argument and/or result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、stateidを引数または結果として取るSEQUENCEに続く操作を検証するために、セッションIDからクライアントIDへのマッピングを維持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client establishes a persistent session, then a SEQUENCE received after a server restart might encounter requests performed and recorded in a persistent reply cache before the server restart. In this case, SEQUENCE will be processed successfully, while requests that were not previously performed and recorded are rejected with NFS4ERR_DEADSESSION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが永続的なセッションを確立する場合、サーバーの再起動後に受信したSEQUENCEは、サーバーの再起動前に実行され、永続的な応答キャッシュに記録された要求に遭遇する可能性があります。この場合、SEQUENCEは正常に処理されますが、以前に実行および記録されていない要求はNFS4ERR_DEADSESSIONで拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on which of the operations within the COMPOUND were successfully performed before the server restart, these operations will also have replies sent from the server reply cache. Note that when these operations establish locking state, it is locking state that applies to the previous server instance and to the previous client ID, even though the server restart, which logically happened after these operations, eliminated that state. In the case of a partially executed COMPOUND, processing may reach an operation not processed during the earlier server instance, making this operation a new one and not performable on the existing session. In this case, NFS4ERR_DEADSESSION will be returned from that operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND内のどの操作がサーバーの再起動前に正常に実行されたかに応じて、これらの操作にはサーバーの応答キャッシュから返信が送信されます。これらの操作がロック状態を確立すると、これらの操作の後に論理的に発生したサーバーの再起動によってその状態が解消されたとしても、以前のサーバーインスタンスと以前のクライアントIDに適用されるロック状態であることに注意してください。 COMPOUNDが部分的に実行された場合、処理は以前のサーバーインスタンスで処理されなかった操作に到達する可能性があり、この操作は新しい操作になり、既存のセッションでは実行できません。この場合、NFS4ERR_DEADSESSIONがその操作から返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-47--Operation-54-SETSSV---Update-SSV-for-a-Client-ID">
18.47. Operation 54: SET_SSV - Update SSV for a Client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.47. 操作54：SET_SSV-クライアントIDのSSVを更新する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-47-1--ARGUMENT">
18.47.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.47.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ssa_digest_input4 {
           SEQUENCE4args sdi_seqargs;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SET_SSV4args {
           opaque          ssa_ssv&lt;&gt;;
           opaque          ssa_digest&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-47-2--RESULT">
18.47.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.47.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ssr_digest_input4 {
           SEQUENCE4res sdi_seqres;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SET_SSV4resok {
           opaque          ssr_digest&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union SET_SSV4res switch (nfsstat4 ssr_status) {
   case NFS4_OK:
           SET_SSV4resok   ssr_resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-47-3--DESCRIPTION">
18.47.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.47.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used to update the SSV for a client ID. Before SET_SSV is called the first time on a client ID, the SSV is zero. The SSV is the key used for the SSV GSS mechanism (Section 2.10.9)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、クライアントIDのSSVを更新するために使用されます。 SET_SSVがクライアントIDで初めて呼び出される前は、SSVはゼロです。 SSVは、SSV GSSメカニズム（セクション2.10.9）に使用されるキーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SET_SSV MUST be preceded by a SEQUENCE operation in the same COMPOUND. It MUST NOT be used if the client did not opt for SP4_SSV state protection when the client ID was created (see Section 18.35); the server returns NFS4ERR_INVAL in that case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SET_SSVの前には、同じCOMPOUND内のSEQUENCE操作が必要です。クライアントIDの作成時にクライアントがSP4_SSV状態保護を選択しなかった場合は使用しないでください（セクション18.35を参照）。その場合、サーバーはNFS4ERR_INVALを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The field ssa_digest is computed as the output of the HMAC (RFC 2104 [11]) using the subkey derived from the SSV4_SUBKEY_MIC_I2T and current SSV as the key (see Section 2.10.9 for a description of subkeys), and an XDR encoded value of data type ssa_digest_input4. The field sdi_seqargs is equal to the arguments of the SEQUENCE operation for the COMPOUND procedure that SET_SSV is within.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドssa_digestは、SSV4_SUBKEY_MIC_I2Tから派生したサブキーと現在のSSVをキーとして使用してHMAC（RFC 2104 [11]）の出力として計算されます（サブキーの説明についてはセクション2.10.9を参照）。データ型ssa_digest_input4。フィールドsdi_seqargsは、SET_SSVが含まれているCOMPOUNDプロシージャのSEQUENCE操作の引数と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The argument ssa_ssv is XORed with the current SSV to produce the new SSV. The argument ssa_ssv SHOULD be generated randomly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数ssa_ssvは現在のSSVとXORされて、新しいSSVを生成します。引数ssa_ssvはランダムに生成する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the response, ssr_digest is the output of the HMAC using the subkey derived from SSV4_SUBKEY_MIC_T2I and new SSV as the key, and an XDR encoded value of data type ssr_digest_input4. The field sdi_seqres is equal to the results of the SEQUENCE operation for the COMPOUND procedure that SET_SSV is within.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答では、ssr_digestは、SSV4_SUBKEY_MIC_T2Iおよび新しいSSVから派生したサブキーをキーとして使用するHMACの出力であり、データ型ssr_digest_input4のXDRエンコード値です。フィールドsdi_seqresは、SET_SSVが含まれているCOMPOUNDプロシージャのSEQUENCE操作の結果と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As noted in Section 18.35, the client and server can maintain multiple concurrent versions of the SSV. The client and server each MUST maintain an internal SSV version number, which is set to one the first time SET_SSV executes on the server and the client receives the first SET_SSV reply. Each subsequent SET_SSV increases the internal SSV version number by one. The value of this version number corresponds to the smpt_ssv_seq, smt_ssv_seq, sspt_ssv_seq, and ssct_ssv_seq fields of the SSV GSS mechanism tokens (see Section 2.10.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション18.35で説明したように、クライアントとサーバーは、SSVの複数の同時バージョンを維持できます。クライアントとサーバーはそれぞれ、内部SSVバージョン番号を維持する必要があります。これは、サーバーでSET_SSVが初めて実行され、クライアントが最初のSET_SSV応答を受信したときに1に設定されます。後続の各SET_SSVは、内部SSVバージョン番号を1つ増やします。このバージョン番号の値は、SSV GSSメカニズムトークン（セクション2.10.9を参照）のsmpt_ssv_seq、smt_ssv_seq、sspt_ssv_seq、およびssct_ssv_seqフィールドに対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-47-4--IMPLEMENTATION">
18.47.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.47.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When the server receives ssa_digest, it MUST verify the digest by computing the digest the same way the client did and comparing it with ssa_digest. If the server gets a different result, this is an error, NFS4ERR_BAD_SESSION_DIGEST. This error might be the result of another SET_SSV from the same client ID changing the SSV. If so, the client recovers by sending a SET_SSV operation again with a recomputed digest based on the subkey of the new SSV. If the transport connection is dropped after the SET_SSV request is sent, but before the SET_SSV reply is received, then there are special considerations for recovery if the client has no more connections associated with sessions associated with the client ID of the SSV. See Section 18.34.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーはssa_digestを受信すると、クライアントが行ったのと同じ方法でダイジェストを計算し、それをssa_digestと比較することにより、ダイジェストを検証する必要があります。サーバーが異なる結果を得る場合、これはエラー、NFS4ERR_BAD_SESSION_DIGESTです。このエラーは、同じクライアントIDからの別のSET_SSVがSSVを変更した結果である可能性があります。その場合、クライアントは、新しいSSVのサブキーに基づいて再計算されたダイジェストを使用してSET_SSV操作を再度送信することで回復します。 SET_SSV要求が送信された後、SET_SSV応答が受信される前にトランスポート接続がドロップされた場合、SSVのクライアントIDに関連付けられたセッションに関連付けられた接続がクライアントにない場合は、回復に関する特別な考慮事項があります。セクション18.34.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients SHOULD NOT send an ssa_ssv that is equal to a previous ssa_ssv, nor equal to a previous or current SSV (including an ssa_ssv equal to zero since the SSV is initialized to zero when the client ID is created).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、以前のssa_ssvに等しい、または以前または現在のSSVに等しいssa_ssvを送信しないでください（クライアントIDの作成時にSSVがゼロに初期化されるため、ゼロに等しいssa_ssvを含む）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients SHOULD send SET_SSV with RPCSEC_GSS privacy. Servers MUST support RPCSEC_GSS with privacy for any COMPOUND that has { SEQUENCE, SET_SSV }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはRPCSEC_GSSプライバシーでSET_SSVを送信する必要があります（SHOULD）。サーバーは、{SEQUENCE、SET_SSV}を持つCOMPOUNDのプライバシーを備えたRPCSEC_GSSをサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client SHOULD NOT send SET_SSV with the SSV GSS mechanism&#39;s credential because the purpose of SET_SSV is to seed the SSV from non-SSV credentials. Instead, SET_SSV SHOULD be sent with the credential of a user that is accessing the client ID for the first time (Section 2.10.8.3). However, if the client does send SET_SSV with SSV credentials, the digest protecting the arguments uses the value of the SSV before ssa_ssv is XORed in, and the digest protecting the results uses the value of the SSV after the ssa_ssv is XORed in.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SET_SSVの目的はSSV以外の資格情報からSSVをシードすることであるため、クライアントは、SSV GSSメカニズムの資格情報を使用してSET_SSVを送信しないでください。代わりに、SET_SSVは、クライアントIDに初めてアクセスするユーザーの資格情報を使用して送信する必要があります（セクション2.10.8.3）。ただし、クライアントがSSV資格情報とともにSET_SSVを送信する場合、引数を保護するダイジェストはssa_ssvがXORされる前にSSVの値を使用し、結果を保護するダイジェストはssa_ssvがXORされた後のSSVの値を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-48--Operation-55-TESTSTATEID---Test-Stateids-for-Validity">
18.48. Operation 55: TEST_STATEID - Test Stateids for Validity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.48. 操作55：TEST_STATEID-妥当性についてのStateidのテスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-48-1--ARGUMENT">
18.48.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.48.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct TEST_STATEID4args {
           stateid4        ts_stateids&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-48-2--RESULT">
18.48.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.48.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct TEST_STATEID4resok {
           nfsstat4        tsr_status_codes&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union TEST_STATEID4res switch (nfsstat4 tsr_status) {
       case NFS4_OK:
           TEST_STATEID4resok tsr_resok4;
       default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-48-3--DESCRIPTION">
18.48.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.48.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TEST_STATEID operation is used to check the validity of a set of stateids. It can be used at any time, but the client should definitely use it when it receives an indication that one or more of its stateids have been invalidated due to lock revocation. This occurs when the SEQUENCE operation returns with one of the following sr_status_flags set:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEST_STATEID操作は、一連の状態IDの有効性をチェックするために使用されます。これはいつでも使用できますが、クライアントは、ロックの取り消しによりその1つ以上のstateidが無効化されているという指示を受け取ったときに、必ず使用する必要があります。これは、SEQUENCE操作が次のsr_status_flagsセットのいずれかで戻るときに発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SEQ4_STATUS_EXPIRED_ADMIN_STATE_REVOKED
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SEQ4_STATUS_EXPIRED_ADMIN_STATE_REVOKED
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SEQ4_STATUS_EXPIRED_RECALLABLE_STATE_REVOKED
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SEQ4_STATUS_EXPIRED_RECALLABLE_STATE_REVOKED
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client can use TEST_STATEID one or more times to test the validity of its stateids. Each use of TEST_STATEID allows a large set of such stateids to be tested and avoids problems with earlier stateids in a COMPOUND request from interfering with the checking of subsequent stateids, as would happen if individual stateids were tested by a series of corresponding by operations in a COMPOUND request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはTEST_STATEIDを1回以上使用して、stateidの有効性をテストできます。 TEST_STATEIDを使用するたびに、そのような状態IDの大規模なセットをテストでき、COMPOUNDリクエストの以前の状態IDの問題が後続の状態IDのチェックを妨害するのを防ぎます。これは、個々の状態IDが一連の対応するby操作によってテストされた場合に発生します。 COMPOUNDリクエスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each stateid, the server returns the status code that would be returned if that stateid were to be used in normal operation. Returning such a status indication is not an error and does not cause COMPOUND processing to terminate. Checks for the validity of the stateid proceed as they would for normal operations with a number of exceptions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ステートIDについて、サーバーは、そのステートIDが通常の操作で使用された場合に返されるステータスコードを返します。そのような状況表示を返すことはエラーではなく、COMPOUND処理が終了することはありません。多数の例外を除いて、通常の操作の場合と同様に、stateidの有効性のチェックが続行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There is no check for the type of stateid object, as would be the case for normal use of a stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o stateidの通常の使用の場合のように、stateidオブジェクトのタイプのチェックはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There is no reference to the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 現在のファイルハンドルへの参照はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Special stateids are always considered invalid (they result in the error code NFS4ERR_BAD_STATEID).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 特別な状態IDは常に無効と見なされます（その結果、エラーコードNFS4ERR_BAD_STATEIDが発生します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All stateids are interpreted as being associated with the client for the current session. Any possible association with a previous instance of the client (as stale stateids) is not considered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての状態IDは、現在のセッションのクライアントに関連付けられていると解釈されます。クライアントの以前のインスタンスとの関連付け（古い状態IDとして）は考慮されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The valid status values in the returned status_code array are NFS4ERR_OK, NFS4ERR_BAD_STATEID, NFS4ERR_OLD_STATEID, NFS4ERR_EXPIRED, NFS4ERR_ADMIN_REVOKED, and NFS4ERR_DELEG_REVOKED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
返されるstatus_code配列の有効なステータス値は、NFS4ERR_OK、NFS4ERR_BAD_STATEID、NFS4ERR_OLD_STATEID、NFS4ERR_EXPIRED、NFS4ERR_ADMIN_REVOKED、およびNFS4ERR_DELEG_REVOKEDです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-48-4--IMPLEMENTATION">
18.48.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.48.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Sections 8.2.2 and 8.2.4 for a discussion of stateid structure, lifetime, and validation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateid構造、有効期間、および検証の説明については、セクション8.2.2および8.2.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-49--Operation-56-WANTDELEGATION---Request-Delegation">
18.49. Operation 56: WANT_DELEGATION - Request Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.49. 操作56：WANT_DELEGATION-依頼の依頼
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-49-1--ARGUMENT">
18.49.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.49.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union deleg_claim4 switch (open_claim_type4 dc_claim) {
   /*
    * No special rights to object.  Ordinary delegation
    * request of the specified object.  Object identified
    * by filehandle.
    */
   case CLAIM_FH: /* new to v4.1 */
           /* CURRENT_FH: object being delegated */
           void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Right to file based on a delegation granted
    * to a previous boot instance of the client.
    * File is specified by filehandle.
    */
   case CLAIM_DELEG_PREV_FH: /* new to v4.1 */
           /* CURRENT_FH: object being delegated */
           void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Right to the file established by an open previous
    * to server reboot.  File identified by filehandle.
    * Used during server reclaim grace period.
    */
   case CLAIM_PREVIOUS:
           /* CURRENT_FH: object being reclaimed */
           open_delegation_type4   dc_delegate_type;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct WANT_DELEGATION4args {
           uint32_t        wda_want;
           deleg_claim4    wda_claim;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-49-2--RESULT">
18.49.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.49.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union WANT_DELEGATION4res switch (nfsstat4 wdr_status) {
   case NFS4_OK:
           open_delegation4 wdr_resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-49-3--DESCRIPTION">
18.49.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.49.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where this description mandates the return of a specific error code for a specific condition, and where multiple conditions apply, the server MAY return any of the mandated error codes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この説明が特定の条件の特定のエラーコードの戻りを要求する場合、および複数の条件が適用される場合、サーバーは必須のエラーコードのいずれかを返す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation allows a client to:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作により、クライアントは次のことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Get a delegation on all types of files except directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ディレクトリを除くすべてのタイプのファイルの委任を取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Register a &#34;want&#34; for a delegation for the specified file object, and be notified via a callback when the delegation is available. The server MAY support notifications of availability via callbacks. If the server does not support registration of wants, it MUST NOT return an error to indicate that, and instead MUST return with ond_why set to WND4_CONTENTION or WND4_RESOURCE and ond_server_will_push_deleg or ond_server_will_signal_avail set to FALSE. When the server indicates that it will notify the client by means of a callback, it will either provide the delegation using a CB_PUSH_DELEG operation or cancel its promise by sending a CB_WANTS_CANCELLED operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 指定されたファイルオブジェクトの委任の「want」を登録し、委任が使用可能になったときにコールバックを介して通知されます。サーバーは、コールバックを介した可用性の通知をサポートする場合があります。サーバーが要求の登録をサポートしていない場合は、それを示すエラーを返さないでください。代わりに、ond_whyをWND4_CONTENTIONまたはWND4_RESOURCEに設定し、ond_server_will_push_delegまたはond_server_will_signal_availをFALSEに設定して返す必要があります。サーバーがコールバックによってクライアントに通知することを示す場合、サーバーはCB_PUSH_DELEG操作を使用して委任を提供するか、CB_WANTS_CANCELLED操作を送信してプロミスをキャンセルします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Cancel a want for a delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 委任の要求をキャンセルします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client SHOULD NOT set OPEN4_SHARE_ACCESS_READ and SHOULD NOT set OPEN4_SHARE_ACCESS_WRITE in wda_want. If it does, the server MUST ignore them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはwda_wantでOPEN4_SHARE_ACCESS_READを設定するべきではなく（SHOULD NOT）、OPEN4_SHARE_ACCESS_WRITEを設定すべきではありません（SHOULD NOT）。存在する場合、サーバーはそれらを無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The meanings of the following flags in wda_want are the same as they are in OPEN, except as noted below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wda_wantの以下のフラグの意味は、以下に記載されている場合を除いて、OPENの場合と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_SHARE_ACCESS_WANT_READ_DELEG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_SHARE_ACCESS_WANT_READ_DELEG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o OPEN4_SHARE_ACCESS_WANT_ANY_DELEG o OPEN4_SHARE_ACCESS_WANT_NO_DELEG. Unlike the OPEN operation, this flag SHOULD NOT be set by the client in the arguments to WANT_DELEGATION, and MUST be ignored by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
o OPEN4_SHARE_ACCESS_WANT_ANY_DELEG o OPEN4_SHARE_ACCESS_WANT_NO_DELEG。 OPEN操作とは異なり、このフラグはWANT_DELEGATIONへの引数でクライアントによって設定されるべきではなく（SHOULD NOT）、サーバーによって無視されなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_SHARE_ACCESS_WANT_CANCEL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_SHARE_ACCESS_WANT_CANCEL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The handling of the above flags in WANT_DELEGATION is the same as in OPEN. Information about the delegation and/or the promises the server is making regarding future callbacks are the same as those described in the open_delegation4 structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WANT_DELEGATIONでの上記のフラグの処理は、OPENと同じです。委任に関する情報や将来のコールバックに関してサーバーが行う約束は、open_delegation4構造体で説明されているものと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The successful results of WANT_DELEGATION are of data type open_delegation4, which is the same data type as the &#34;delegation&#34; field in the results of the OPEN operation (see Section 18.16.3). The server constructs wdr_resok4 the same way it constructs OPEN&#39;s &#34;delegation&#34; with one difference: WANT_DELEGATION MUST NOT return a delegation type of OPEN_DELEGATE_NONE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WANT_DELEGATIONの正常な結果は、open_delegation4のデータ型です。これは、OPEN操作の結果の「委任」フィールドと同じデータ型です（セクション18.16.3を参照）。サーバーは、OPENの「委任」を作成するのと同じ方法でwdr_resok4を作成しますが、WANT_DELEGATIONはOPEN_DELEGATE_NONEの委任タイプを返してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If ((wda_want &amp; OPEN4_SHARE_ACCESS_WANT_DELEG_MASK) &amp; ~OPEN4_SHARE_ACCESS_WANT_NO_DELEG) is zero, then the client is indicating no explicit desire or non-desire for a delegation and the server MUST return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（（wda_want＆OPEN4_SHARE_ACCESS_WANT_DELEG_MASK）＆〜OPEN4_SHARE_ACCESS_WANT_NO_DELEG）がゼロの場合、クライアントは委任に対する明示的な要求または非要求を示しておらず、サーバーはNFS4ERR_INVALを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client uses the OPEN4_SHARE_ACCESS_WANT_CANCEL flag in the WANT_DELEGATION operation to cancel a previously requested want for a delegation. Note that if the server is in the process of sending the delegation (via CB_PUSH_DELEG) at the time the client sends a cancellation of the want, the delegation might still be pushed to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、WANT_DELEGATION操作のOPEN4_SHARE_ACCESS_WANT_CANCELフラグを使用して、以前に要求された委任の要求をキャンセルします。クライアントが要求のキャンセルを送信するときに、サーバーが委任を（CB_PUSH_DELEGを介して）送信している場合でも、委任はクライアントにプッシュされる可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If WANT_DELEGATION fails to return a delegation, and the server returns NFS4_OK, the server MUST set the delegation type to OPEN4_DELEGATE_NONE_EXT, and set od_whynone, as described in Section 18.16. Write delegations are not available for file types that are not writable. This includes file objects of types NF4BLK, NF4CHR, NF4LNK, NF4SOCK, and NF4FIFO. If the client requests OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG without OPEN4_SHARE_ACCESS_WANT_READ_DELEG on an object with one of the aforementioned file types, the server must set wdr_resok4.od_whynone.ond_why to WND4_WRITE_DELEG_NOT_SUPP_FTYPE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WANT_DELEGATIONが委任を返せず、サーバーがNFS4_OKを返す場合、サーバーは、委任タイプをOPEN4_DELEGATE_NONE_EXTに設定し、セクション18.16で説明されているようにod_whynoneを設定する必要があります。書き込み委任は、書き込み不可のファイルタイプでは使用できません。これには、NF4BLK、NF4CHR、NF4LNK、NF4SOCK、およびNF4FIFOタイプのファイルオブジェクトが含まれます。クライアントが前述のファイルタイプの1つを持つオブジェクトに対してOPEN4_SHARE_ACCESS_WANT_READ_DELEGなしでOPEN4_SHARE_ACCESS_WANT_WRITE_DELEGを要求する場合、サーバーはwdr_resok4.od_whynone.ond_whyをWND4_WRITE_DELEG_NOT_SUPP_FTYPEに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-49-4--IMPLEMENTATION">
18.49.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.49.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A request for a conflicting delegation is not normally intended to trigger the recall of the existing delegation. Servers may choose to treat some clients as having higher priority such that their wants will trigger recall of an existing delegation, although that is expected to be an unusual situation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
競合する委任の要求は、通常、既存の委任の取り消しをトリガーするためのものではありません。サーバーは、一部のクライアントをより高い優先度として扱うことを選択する場合があります。これは、異常な状況であると予想されますが、それらの要求が既存の委任の取り消しをトリガーするようにするためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers will generally recall delegations assigned by WANT_DELEGATION on the same basis as those assigned by OPEN. CB_RECALL will generally be done only when other clients perform operations inconsistent with the delegation. The normal response to aging of delegations is to use CB_RECALL_ANY, in order to give the client the opportunity to keep the delegations most useful from its point of view.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは通常、OPENによって割り当てられたものと同じ基準で、WANT_DELEGATIONによって割り当てられた委任を呼び出します。 CB_RECALLは通常、他のクライアントが委任と矛盾する操作を実行する場合にのみ実行されます。委任のエージングに対する通常の応答は、クライアントに、その観点から最も有用な委任を保持する機会を与えるために、CB_RECALL_ANYを使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-50--Operation-57-DESTROYCLIENTID---Destroy-a-Client-ID">
18.50. Operation 57: DESTROY_CLIENTID - Destroy a Client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.50. 操作57：DESTROY_CLIENTID-クライアントIDを破棄します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-50-1--ARGUMENT">
18.50.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.50.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DESTROY_CLIENTID4args {
           clientid4       dca_clientid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-50-2--RESULT">
18.50.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.50.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DESTROY_CLIENTID4res {
           nfsstat4        dcr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-50-3--DESCRIPTION">
18.50.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.50.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DESTROY_CLIENTID operation destroys the client ID. If there are sessions (both idle and non-idle), opens, locks, delegations, layouts, and/or wants (Section 18.49) associated with the unexpired lease of the client ID, the server MUST return NFS4ERR_CLIENTID_BUSY. DESTROY_CLIENTID MAY be preceded with a SEQUENCE operation as long as the client ID derived from the session ID of SEQUENCE is not the same as the client ID to be destroyed. If the client IDs are the same, then the server MUST return NFS4ERR_CLIENTID_BUSY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESTROY_CLIENTID操作はクライアントIDを破棄します。セッション（アイドルと非アイドルの両方）、オープン、ロック、委任、レイアウト、および/またはクライアントIDの期限切れ前のリースに関連付けられた要求（セクション18.49）がある場合、サーバーはNFS4ERR_CLIENTID_BUSYを返さなければなりません（MUST）。 SEQUENCEのセッションIDから導出されたクライアントIDが破棄されるクライアントIDと同じでない限り、DESTROY_CLIENTIDの前にSEQUENCE操作を行うことができます。クライアントIDが同じ場合、サーバーはNFS4ERR_CLIENTID_BUSYを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If DESTROY_CLIENTID is not prefixed by SEQUENCE, it MUST be the only operation in the COMPOUND request (otherwise, the server MUST return NFS4ERR_NOT_ONLY_OP). If the operation is sent without a SEQUENCE preceding it, a client that retransmits the request may receive an error in response, because the original request might have been successfully executed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESTROY_CLIENTIDの前にSEQUENCEがない場合は、それがCOMPOUND要求での唯一の操作でなければなりません（そうでない場合、サーバーはNFS4ERR_NOT_ONLY_OPを返さなければなりません）。操作の前にSEQUENCEを付けずに操作を送信すると、元の要求が正常に実行された可能性があるため、要求を再送信するクライアントが応答としてエラーを受け取る場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-50-4--IMPLEMENTATION">
18.50.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.50.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESTROY_CLIENTID allows a server to immediately reclaim the resources consumed by an unused client ID, and also to forget that it ever generated the client ID. By forgetting that it ever generated the client ID, the server can safely reuse the client ID on a future EXCHANGE_ID operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESTROY_CLIENTIDを使用すると、サーバーは未使用のクライアントIDによって消費されたリソースをすぐに再利用でき、クライアントIDを生成したことを忘れることもできます。サーバーはクライアントIDを生成したことを忘れることにより、将来のEXCHANGE_ID操作でクライアントIDを安全に再利用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-51--Operation-58-RECLAIMCOMPLETE---Indicates-Reclaims-Finished">
18.51. Operation 58: RECLAIM_COMPLETE - Indicates Reclaims Finished
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.51. 操作58：RECLAIM_COMPLETE-再利用が終了したことを示します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-51-1--ARGUMENT">
18.51.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.51.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RECLAIM_COMPLETE4args {
           /*
            * If rca_one_fs TRUE,
            *
            *    CURRENT_FH: object in
            *    file system reclaim is
            *    complete for.
            */
           bool            rca_one_fs;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-51-2--RESULTS">
18.51.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.51.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RECLAIM_COMPLETE4res {
           nfsstat4        rcr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-51-3--DESCRIPTION">
18.51.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.51.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A RECLAIM_COMPLETE operation is used to indicate that the client has reclaimed all of the locking state that it will recover, when it is recovering state due to either a server restart or the transfer of a file system to another server. There are two types of RECLAIM_COMPLETE operations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RECLAIM_COMPLETE操作は、サーバーの再起動またはファイルシステムの別のサーバーへの転送によって状態が回復しているときに、クライアントが回復するすべてのロック状態を取り戻したことを示すために使用されます。 RECLAIM_COMPLETE操作には2つのタイプがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When rca_one_fs is FALSE, a global RECLAIM_COMPLETE is being done. This indicates that recovery of all locks that the client held on the previous server instance have been completed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o rca_one_fsがFALSEの場合、グローバルなRECLAIM_COMPLETEが実行されています。これは、クライアントが以前のサーバーインスタンスで保持していたすべてのロックの回復が完了したことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When rca_one_fs is TRUE, a file system-specific RECLAIM_COMPLETE is being done. This indicates that recovery of locks for a single fs (the one designated by the current filehandle) due to a file system transition have been completed. Presence of a current filehandle is only required when rca_one_fs is set to TRUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o rca_one_fsがTRUEの場合、ファイルシステム固有のRECLAIM_COMPLETEが実行されています。これは、ファイルシステムの移行による単一のfs（現在のファイルハンドルで指定されたもの）のロックの回復が完了したことを示します。現在のファイルハンドルの存在は、rca_one_fsがTRUEに設定されている場合にのみ必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a RECLAIM_COMPLETE is done, there can be no further reclaim operations for locks whose scope is defined as having completed recovery. Once the client sends RECLAIM_COMPLETE, the server will not allow the client to do subsequent reclaims of locking state for that scope and, if these are attempted, will return NFS4ERR_NO_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RECLAIM_COMPLETEが完了すると、回復が完了したものとしてスコープが定義されているロックの再利用操作はできなくなります。クライアントがRECLAIM_COMPLETEを送信すると、サーバーはクライアントがそのスコープのロック状態を再利用することを許可せず、これらが試みられた場合、NFS4ERR_NO_GRACEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever a client establishes a new client ID and before it does the first non-reclaim operation that obtains a lock, it MUST send a RECLAIM_COMPLETE with rca_one_fs set to FALSE, even if there are no locks to reclaim. If non-reclaim locking operations are done before the RECLAIM_COMPLETE, an NFS4ERR_GRACE error will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが新しいクライアントIDを確立し、ロックを取得する最初の非再利用操作を実行する前に、再利用するロックがない場合でも、rca_one_fsをFALSEに設定してRECLAIM_COMPLETEを送信する必要があります。 RECLAIM_COMPLETEの前に非再利用ロック操作が行われた場合、NFS4ERR_GRACEエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, when the client accesses a file system on a new server, before it sends the first non-reclaim operation that obtains a lock on this new server, it MUST send a RECLAIM_COMPLETE with rca_one_fs set to TRUE and current filehandle within that file system, even if there are no locks to reclaim. If non-reclaim locking operations are done on that file system before the RECLAIM_COMPLETE, an NFS4ERR_GRACE error will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、クライアントが新しいサーバーのファイルシステムにアクセスする場合、この新しいサーバーでロックを取得する最初の非再利用操作を送信する前に、rca_one_fsをTRUEに設定し、そのファイルシステム内の現在のファイルハンドルでRECLAIM_COMPLETEを送信する必要があります。再利用するロックがない場合でも。 RECLAIM_COMPLETEの前にそのファイルシステムで非再利用ロック操作が行われた場合、NFS4ERR_GRACEエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any locks not reclaimed at the point at which RECLAIM_COMPLETE is done become non-reclaimable. The client MUST NOT attempt to reclaim them, either during the current server instance or in any subsequent server instance, or on another server to which responsibility for that file system is transferred. If the client were to do so, it would be violating the protocol by representing itself as owning locks that it does not own, and so has no right to reclaim. See Section 8.4.3 for a discussion of edge conditions related to lock reclaim.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RECLAIM_COMPLETEが実行された時点で再利用されなかったロックは、再利用できなくなります。クライアントは、現在のサーバーインスタンス中または後続のサーバーインスタンス中、またはそのファイルシステムの責任が転送される別のサーバー上で、それらを再利用しようとしてはなりません（MUST NOT）。クライアントがそうする場合、それは自分が所有していないロックを所有していると表現することによってプロトコルに違反しているため、再利用する権利がありません。ロックの再利用に関連するエッジ条件の説明については、セクション8.4.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By sending a RECLAIM_COMPLETE, the client indicates readiness to proceed to do normal non-reclaim locking operations. The client should be aware that such operations may temporarily result in NFS4ERR_GRACE errors until the server is ready to terminate its grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RECLAIM_COMPLETEを送信することにより、クライアントは通常の非再利用ロック操作を実行する準備ができていることを示します。クライアントは、サーバーが猶予期間を終了する準備ができるまで、そのような操作が一時的にNFS4ERR_GRACEエラーを引き起こす可能性があることに注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-51-4--IMPLEMENTATION">
18.51.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.51.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers will typically use the information as to when reclaim activity is complete to reduce the length of the grace period. When the server maintains in persistent storage a list of clients that might have had locks, it is in a position to use the fact that all such clients have done a RECLAIM_COMPLETE to terminate the grace period and begin normal operations (i.e., grant requests for new locks) sooner than it might otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは通常、猶予期間の長さを短縮するために、再利用アクティビティがいつ完了したかに関する情報を使用します。サーバーが永続的ストレージでロックを保持している可能性のあるクライアントのリストを維持している場合、そのようなすべてのクライアントがRECLAIM_COMPLETEを実行して猶予期間を終了し、通常の操作（つまり、新しいリクエストを許可）を開始するという立場にありますロック）それ以外の場合よりも早く。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Latency can be minimized by doing a RECLAIM_COMPLETE as part of the COMPOUND request in which the last lock-reclaiming operation is done. When there are no reclaims to be done, RECLAIM_COMPLETE should be done immediately in order to allow the grace period to end as soon as possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後のロック再利用操作が行われるCOMPOUND要求の一部としてRECLAIM_COMPLETEを実行することにより、待ち時間を最小限に抑えることができます。実行すべき再利用がない場合は、猶予期間ができるだけ早く終了するように、RECLAIM_COMPLETEをすぐに実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RECLAIM_COMPLETE should only be done once for each server instance or occasion of the transition of a file system. If it is done a second time, the error NFS4ERR_COMPLETE_ALREADY will result. Note that because of the session feature&#39;s retry protection, retries of COMPOUND requests containing RECLAIM_COMPLETE operation will not result in this error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RECLAIM_COMPLETEは、サーバーインスタンスごと、またはファイルシステムの移行時に1回だけ実行する必要があります。もう一度実行すると、エラーNFS4ERR_COMPLETE_ALREADYが発生します。セッション機能の再試行保護のため、RECLAIM_COMPLETE操作を含むCOMPOUND要求を再試行しても、このエラーは発生しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a RECLAIM_COMPLETE is sent, the client effectively acknowledges any locks not yet reclaimed as lost. This allows the server to re-enable the client to recover locks if the occurrence of edge conditions, as described in Section 8.4.3, had caused the server to disable the client from recovering locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RECLAIM_COMPLETEが送信されると、クライアントは、まだ失われていないと再利用されていないロックを事実上承認します。これにより、サーバーがクライアントを再度有効にしてロックを回復できるようになります（8.4.3で説明したエッジ条件の発生により、サーバーがクライアントによるロックの回復を無効にした場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-52--Operation-10044-ILLEGAL---Illegal-Operation">
18.52. Operation 10044: ILLEGAL - Illegal Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.52. 操作10044：違法-違法操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-52-1--ARGUMENTS">
18.52.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.52.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-52-2--RESULTS">
18.52.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.52.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ILLEGAL4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-52-3--DESCRIPTION">
18.52.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.52.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is a placeholder for encoding a result to handle the case of the client sending an operation code within COMPOUND that is not supported. See the COMPOUND procedure description for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、サポートされていないCOMPOUND内の操作コードを送信するクライアントのケースを処理する結果をエンコードするためのプレースホルダーです。詳細については、COMPOUNDプロシージャの説明を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The status field of ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ILLEGAL4resのステータスフィールドはNFS4ERR_OP_ILLEGALに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18-52-4--IMPLEMENTATION">
18.52.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.52.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A client will probably not send an operation with code OP_ILLEGAL but if it does, the response will be ILLEGAL4res just as it would be with any other invalid operation code. Note that if the server gets an illegal operation code that is not OP_ILLEGAL, and if the server checks for legal operation codes during the XDR decode phase, then the ILLEGAL4res would not be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
クライアントはおそらくコードOP_ILLEGALで操作を送信しませんが、送信すると、他の無効な操作コードの場合と同様に、応答はILLEGAL4resになります。サーバーがOP_ILLEGAL以外の不正な操作コードを取得した場合、およびサーバーがXDRデコードフェーズ中に有効な操作コードをチェックした場合、ILLEGAL4resは返されないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19--NFSv4-1-Callback-Procedures">
19. NFSv4.1 Callback Procedures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. NFSv4.1コールバック手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedures used for callbacks are defined in the following sections. In the interest of clarity, the terms &#34;client&#34; and &#34;server&#34; refer to NFS clients and servers, despite the fact that for an individual callback RPC, the sense of these terms would be precisely the opposite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コールバックに使用される手順は、次のセクションで定義されています。明確にするために、「クライアント」と「サーバー」という用語はNFSのクライアントとサーバーを指しますが、個々のコールバックRPCの場合、これらの用語の意味はまったく逆になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both procedures, CB_NULL and CB_COMPOUND, MUST be implemented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_NULLとCB_COMPOUNDの両方のプロシージャを実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19-1--Procedure-0-CBNULL---No-Operation">
19.1. Procedure 0: CB_NULL - No Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.1. 手順0：CB_NULL-操作なし
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19-1-1--ARGUMENTS">
19.1.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.1.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19-1-2--RESULTS">
19.1.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.1.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19-1-3--DESCRIPTION">
19.1.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.1.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_NULL is the standard ONC RPC NULL procedure, with the standard void argument and void response. Even though there is no direct functionality associated with this procedure, the server will use CB_NULL to confirm the existence of a path for RPCs from the server to client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_NULLは、標準のvoid引数とvoid応答を持つ、標準のONC RPC NULLプロシージャです。この手順に直接関連する機能はありませんが、サーバーはCB_NULLを使用して、サーバーからクライアントへのRPCのパスの存在を確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19-1-4--ERRORS">
19.1.4. ERRORS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.1.4. エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
None.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
なし。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19-2--Procedure-1-CBCOMPOUND---Compound-Operations">
19.2. Procedure 1: CB_COMPOUND - Compound Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2. 手順1：CB_COMPOUND-複合操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19-2-1--ARGUMENTS">
19.2.1. ARGUMENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2.1. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum nfs_cb_opnum4 {
           OP_CB_GETATTR           = 3,
           OP_CB_RECALL            = 4,
   /* Callback operations new to NFSv4.1 */
           OP_CB_LAYOUTRECALL      = 5,
           OP_CB_NOTIFY            = 6,
           OP_CB_PUSH_DELEG        = 7,
           OP_CB_RECALL_ANY        = 8,
           OP_CB_RECALLABLE_OBJ_AVAIL = 9,
           OP_CB_RECALL_SLOT       = 10,
           OP_CB_SEQUENCE          = 11,
           OP_CB_WANTS_CANCELLED   = 12,
           OP_CB_NOTIFY_LOCK       = 13,
           OP_CB_NOTIFY_DEVICEID   = 14,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 OP_CB_ILLEGAL = 10044 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OP_CB_ILLEGAL = 10044};
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_cb_argop4 switch (unsigned argop) {
    case OP_CB_GETATTR:
         CB_GETATTR4args           opcbgetattr;
    case OP_CB_RECALL:
         CB_RECALL4args            opcbrecall;
    case OP_CB_LAYOUTRECALL:
         CB_LAYOUTRECALL4args      opcblayoutrecall;
    case OP_CB_NOTIFY:
         CB_NOTIFY4args            opcbnotify;
    case OP_CB_PUSH_DELEG:
         CB_PUSH_DELEG4args        opcbpush_deleg;
    case OP_CB_RECALL_ANY:
         CB_RECALL_ANY4args        opcbrecall_any;
    case OP_CB_RECALLABLE_OBJ_AVAIL:
         CB_RECALLABLE_OBJ_AVAIL4args opcbrecallable_obj_avail;
    case OP_CB_RECALL_SLOT:
         CB_RECALL_SLOT4args       opcbrecall_slot;
    case OP_CB_SEQUENCE:
         CB_SEQUENCE4args          opcbsequence;
    case OP_CB_WANTS_CANCELLED:
         CB_WANTS_CANCELLED4args   opcbwants_cancelled;
    case OP_CB_NOTIFY_LOCK:
         CB_NOTIFY_LOCK4args       opcbnotify_lock;
    case OP_CB_NOTIFY_DEVICEID:
         CB_NOTIFY_DEVICEID4args   opcbnotify_deviceid;
    case OP_CB_ILLEGAL:            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_COMPOUND4args {
           utf8str_cs      tag;
           uint32_t        minorversion;
           uint32_t        callback_ident;
           nfs_cb_argop4   argarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19-2-2--RESULTS">
19.2.2. RESULTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_cb_resop4 switch (unsigned resop) {
    case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;
    case OP_CB_RECALL:     CB_RECALL4res   opcbrecall;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* new NFSv4.1 operations */
    case OP_CB_LAYOUTRECALL:
                           CB_LAYOUTRECALL4res
                                           opcblayoutrecall;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_CB_NOTIFY: CB_NOTIFY4res opcbnotify;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_CB_NOTIFY：CB_NOTIFY4res opcbnotify;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_CB_PUSH_DELEG: CB_PUSH_DELEG4res opcbpush_deleg;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_CB_PUSH_DELEG：CB_PUSH_DELEG4res opcbpush_deleg;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_CB_RECALL_ANY: CB_RECALL_ANY4res opcbrecall_any;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_CB_RECALL_ANY：CB_RECALL_ANY4res opcbrecall_any;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_CB_RECALLABLE_OBJ_AVAIL: CB_RECALLABLE_OBJ_AVAIL4res opcbrecallable_obj_avail;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_CB_RECALLABLE_OBJ_AVAIL：CB_RECALLABLE_OBJ_AVAIL4res opcbrecallable_obj_avail;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_CB_RECALL_SLOT: CB_RECALL_SLOT4res opcbrecall_slot;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_CB_RECALL_SLOT：CB_RECALL_SLOT4res opcbrecall_slot;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_CB_SEQUENCE: CB_SEQUENCE4res opcbsequence;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_CB_SEQUENCE：CB_SEQUENCE4res opcbsequence;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_CB_WANTS_CANCELLED: CB_WANTS_CANCELLED4res opcbwants_cancelled;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_CB_WANTS_CANCELLED：CB_WANTS_CANCELLED4res opcbwants_cancelled;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_CB_NOTIFY_LOCK: CB_NOTIFY_LOCK4res opcbnotify_lock;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_CB_NOTIFY_LOCK：CB_NOTIFY_LOCK4res opcbnotify_lock;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
case OP_CB_NOTIFY_DEVICEID: CB_NOTIFY_DEVICEID4res opcbnotify_deviceid;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ケースOP_CB_NOTIFY_DEVICEID：CB_NOTIFY_DEVICEID4res opcbnotify_deviceid;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Not new operation */
    case OP_CB_ILLEGAL:    CB_ILLEGAL4res  opcbillegal;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_COMPOUND4res {
           nfsstat4 status;
           utf8str_cs      tag;
           nfs_cb_resop4   resarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19-2-3--DESCRIPTION">
19.2.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_COMPOUND procedure is used to combine one or more of the callback procedures into a single RPC request. The main callback RPC program has two main procedures: CB_NULL and CB_COMPOUND. All other operations use the CB_COMPOUND procedure as a wrapper.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUNDプロシージャは、1つ以上のコールバックプロシージャを1つのRPC要求に結合するために使用されます。メインコールバックRPCプログラムには、CB_NULLとCB_COMPOUNDの2つのメインプロシージャがあります。他のすべての操作は、ラッパーとしてCB_COMPOUNDプロシージャを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During the processing of the CB_COMPOUND procedure, the client may find that it does not have the available resources to execute any or all of the operations within the CB_COMPOUND sequence. Refer to Section 2.10.6.4 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUNDプロシージャの処理中に、クライアントは、CB_COMPOUNDシーケンス内の操作の一部またはすべてを実行するために使用できるリソースがないことに気付く場合があります。詳細はセクション2.10.6.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The minorversion field of the arguments MUST be the same as the minorversion of the COMPOUND procedure used to create the client ID and session. For NFSv4.1, minorversion MUST be set to 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数のマイナーバージョンフィールドは、クライアントIDとセッションの作成に使用されるCOMPOUNDプロシージャのマイナーバージョンと同じである必要があります。 NFSv4.1では、minorversionを1に設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Contained within the CB_COMPOUND results is a &#34;status&#34; field. This status MUST be equal to the status of the last operation that was executed within the CB_COMPOUND procedure. Therefore, if an operation incurred an error, then the &#34;status&#34; value will be the same error value as is being returned for the operation that failed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUNDの結果には、「ステータス」フィールドが含まれています。このステータスは、CB_COMPOUNDプロシージャ内で実行された最後の操作のステータスと同じである必要があります。したがって、操作でエラーが発生した場合、「ステータス」の値は、失敗した操作に対して返されるエラー値と同じになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;tag&#34; field is handled the same way as that of the COMPOUND procedure (see Section 16.2.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「タグ」フィールドは、COMPOUNDプロシージャと同じ方法で処理されます（16.2.3項を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Illegal operation codes are handled in the same way as they are handled for the COMPOUND procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不正な操作コードは、COMPOUNDプロシージャで処理されるのと同じ方法で処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19-2-4--IMPLEMENTATION">
19.2.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_COMPOUND procedure is used to combine individual operations into a single RPC request. The client interprets each of the operations in turn. If an operation is executed by the client and the status of that operation is NFS4_OK, then the next operation in the CB_COMPOUND procedure is executed. The client continues this process until there are no more operations to be executed or one of the operations has a status value other than NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUNDプロシージャは、個々の操作を1つのRPC要求に結合するために使用されます。クライアントは各操作を順番に解釈します。操作がクライアントによって実行され、その操作のステータスがNFS4_OKの場合、CB_COMPOUNDプロシージャの次の操作が実行されます。クライアントは、実行する操作がなくなるか、操作の1つがNFS4_OK以外のステータス値になるまで、このプロセスを続行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19-2-5--ERRORS">
19.2.5. ERRORS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2.5. エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUND will of course return every error that each operation on the backchannel can return (see Table 7). However, if CB_COMPOUND returns zero operations, obviously the error returned by COMPOUND has nothing to do with an error returned by an operation. The list of errors CB_COMPOUND will return if it processes zero operations includes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もちろん、CB_COMPOUNDは、バックチャネルの各操作が返す可能性のあるすべてのエラーを返します（表7を参照）。ただし、CB_COMPOUNDが操作を返さない場合、COMPOUNDが返すエラーは、操作が返すエラーとは関係ありません。ゼロ操作を処理する場合にCB_COMPOUNDが返すエラーのリストには、次のものが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-25">
CB_COMPOUND error returns
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-25">
CB_COMPOUNDエラーが返される
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------------------------+------------------------------------+
   | Error                        | Notes                              |
   +------------------------------+------------------------------------+
   | NFS4ERR_BADCHAR              | The tag argument has a character   |
   |                              | the replier does not support.      |
   | NFS4ERR_BADXDR               |                                    |
   | NFS4ERR_DELAY                |                                    |
   | NFS4ERR_INVAL                | The tag argument is not in UTF-8   |
   |                              | encoding.                          |
   | NFS4ERR_MINOR_VERS_MISMATCH  |                                    |
   | NFS4ERR_SERVERFAULT          |                                    |
   | NFS4ERR_TOO_MANY_OPS         |                                    |
   | NFS4ERR_REP_TOO_BIG          |                                    |
   | NFS4ERR_REP_TOO_BIG_TO_CACHE |                                    |
   | NFS4ERR_REQ_TOO_BIG          |                                    |
   +------------------------------+------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Table 15
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
表15
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20--NFSv4-1-Callback-Operations">
20. NFSv4.1 Callback Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. NFSv4.1コールバック操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-1--Operation-3-CBGETATTR---Get-Attributes">
20.1. Operation 3: CB_GETATTR - Get Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1. 操作3：CB_GETATTR-属性の取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-1-1--ARGUMENT">
20.1.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_GETATTR4args {
           nfs_fh4 fh;
           bitmap4 attr_request;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-1-2--RESULT">
20.1.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_GETATTR4resok {
           fattr4  obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union CB_GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            CB_GETATTR4resok       resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-1-3--DESCRIPTION">
20.1.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_GETATTR operation is used by the server to obtain the current modified state of a file that has been OPEN_DELEGATE_WRITE delegated. The size and change attributes are the only ones guaranteed to be serviced by the client. See Section 10.4.3 for a full description of how the client and server are to interact with the use of CB_GETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはCB_GETATTR操作を使用して、OPEN_DELEGATE_WRITE委任されたファイルの現在の変更状態を取得します。サイズおよび変更属性は、クライアントによるサービスが保証されている唯一の属性です。クライアントとサーバーがCB_GETATTRの使用と対話する方法の詳細については、セクション10.4.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the filehandle specified is not one for which the client holds an OPEN_DELEGATE_WRITE delegation, an NFS4ERR_BADHANDLE error is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたファイルハンドルが、クライアントがOPEN_DELEGATE_WRITE委任を保持しているものではない場合、NFS4ERR_BADHANDLEエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-1-4--IMPLEMENTATION">
20.1.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client returns attrmask bits and the associated attribute values only for the change attribute, and attributes that it may change (time_modify, and size).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、変更属性とそれが変更する可能性のある属性（time_modify、およびサイズ）に対してのみ、attrmaskビットと関連する属性値を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-2--Operation-4-CBRECALL---Recall-a-Delegation">
20.2. Operation 4: CB_RECALL - Recall a Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.2. 操作4：CB_RECALL-委任を取り消す
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-2-1--ARGUMENT">
20.2.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.2.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_RECALL4args {
           stateid4        stateid;
           bool            truncate;
           nfs_fh4         fh;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-2-2--RESULT">
20.2.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.2.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_RECALL4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-2-3--DESCRIPTION">
20.2.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.2.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_RECALL operation is used to begin the process of recalling a delegation and returning it to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_RECALL操作は、委任を取り消してサーバーに返すプロセスを開始するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The truncate flag is used to optimize recall for a file object that is a regular file and is about to be truncated to zero. When it is TRUE, the client is freed of the obligation to propagate modified data for the file to the server, since this data is irrelevant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
切り捨てフラグは、通常のファイルであり、ゼロに切り詰めようとしているファイルオブジェクトの再呼び出しを最適化するために使用されます。 TRUEの場合、ファイルの変更されたデータは無関係であるため、クライアントはファイルに変更されたデータをサーバーに伝達する義務から解放されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the handle specified is not one for which the client holds a delegation, an NFS4ERR_BADHANDLE error is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたハンドルがクライアントが委任を保持しているものではない場合、NFS4ERR_BADHANDLEエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the stateid specified is not one corresponding to an OPEN delegation for the file specified by the filehandle, an NFS4ERR_BAD_STATEID is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定された状態IDが、ファイルハンドルで指定されたファイルのOPEN委任に対応するものではない場合、NFS4ERR_BAD_STATEIDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-2-4--IMPLEMENTATION">
20.2.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.2.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client SHOULD reply to the callback immediately. Replying does not complete the recall except when the value of the reply&#39;s status field is neither NFS4ERR_DELAY nor NFS4_OK. The recall is not complete until the delegation is returned using a DELEGRETURN operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはすぐにコールバックに応答する必要があります。応答は、応答の状況フィールドの値がNFS4ERR_DELAYでもNFS4_OKでもない場合を除いて、再呼び出しを完了しません。 DELEGRETURN操作を使用して委任が返されるまで、再呼び出しは完了しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-3--Operation-5-CBLAYOUTRECALL---Recall-Layout-from-Client">
20.3. Operation 5: CB_LAYOUTRECALL - Recall Layout from Client
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.3. 操作5：CB_LAYOUTRECALL-クライアントからのレイアウトの呼び出し
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-3-1--ARGUMENT">
20.3.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.3.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * NFSv4.1 callback arguments and results
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum layoutrecall_type4 {
           LAYOUTRECALL4_FILE = LAYOUT4_RET_REC_FILE,
           LAYOUTRECALL4_FSID = LAYOUT4_RET_REC_FSID,
           LAYOUTRECALL4_ALL  = LAYOUT4_RET_REC_ALL
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct layoutrecall_file4 {
           nfs_fh4         lor_fh;
           offset4         lor_offset;
           length4         lor_length;
           stateid4        lor_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union layoutrecall4 switch(layoutrecall_type4 lor_recalltype) {
   case LAYOUTRECALL4_FILE:
           layoutrecall_file4 lor_layout;
   case LAYOUTRECALL4_FSID:
           fsid4              lor_fsid;
   case LAYOUTRECALL4_ALL:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_LAYOUTRECALL4args {
           layouttype4             clora_type;
           layoutiomode4           clora_iomode;
           bool                    clora_changed;
           layoutrecall4           clora_recall;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-3-2--RESULT">
20.3.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.3.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_LAYOUTRECALL4res {
           nfsstat4        clorr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-3-3--DESCRIPTION">
20.3.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.3.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_LAYOUTRECALL operation is used by the server to recall layouts from the client; as a result, the client will begin the process of returning layouts via LAYOUTRETURN. The CB_LAYOUTRECALL operation specifies one of three forms of recall processing with the value of layoutrecall_type4. The recall is for one of the following: a specific layout of a specific file (LAYOUTRECALL4_FILE), an entire file system ID (LAYOUTRECALL4_FSID), or all file systems (LAYOUTRECALL4_ALL).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_LAYOUTRECALL操作は、サーバーがクライアントからレイアウトを呼び出すために使用されます。その結果、クライアントはLAYOUTRETURNを介してレイアウトを返すプロセスを開始します。 CB_LAYOUTRECALL操作は、layoutrecall_type4の値を使用して、3つの形式の再呼び出し処理の1つを指定します。再呼び出しは、特定のファイルの特定のレイアウト（LAYOUTRECALL4_FILE）、ファイルシステム全体のID（LAYOUTRECALL4_FSID）、またはすべてのファイルシステム（LAYOUTRECALL4_ALL）のいずれかに対するものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The behavior of the operation varies based on the value of the layoutrecall_type4. The value and behaviors are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作の動作は、layoutrecall_type4の値によって異なります。値と動作は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTRECALL4_FILE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTRECALL4_FILE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 For a layout to match the recall request, the values of the following fields must match those of the layout: clora_type, clora_iomode, lor_fh, and the byte-range specified by lor_offset and lor_length. The clora_iomode field may have a special value of LAYOUTIOMODE4_ANY. The special value LAYOUTIOMODE4_ANY will match any iomode originally returned in a layout; therefore, it acts as a wild card. The other special value used is for lor_length. If lor_length has a value of NFS4_UINT64_MAX, the lor_length field means the maximum possible file size. If a matching layout is found, it MUST be returned using the LAYOUTRETURN operation (see Section 18.44). An example of the field&#39;s special value use is if clora_iomode is LAYOUTIOMODE4_ANY, lor_offset is zero, and lor_length is NFS4_UINT64_MAX, then the entire layout is to be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
レイアウトが再呼び出し要求と一致するためには、次のフィールドの値がレイアウトの値と一致する必要があります：clora_type、clora_iomode、lor_fh、およびlor_offsetとlor_lengthで指定されたバイト範囲。 clora_iomodeフィールドには、LAYOUTIOMODE4_ANYという特別な値が含まれる場合があります。特別な値LAYOUTIOMODE4_ANYは、元々レイアウトで返されたすべてのiomodeと一致します。したがって、ワイルドカードとして機能します。使用される他の特別な値はlor_lengthです。 lor_lengthの値がNFS4_UINT64_MAXの場合、lor_lengthフィールドは可能な最大ファイルサイズを意味します。一致するレイアウトが見つかった場合は、LAYOUTRETURN操作を使用してそれを返す必要があります（セクション18.44を参照）。フィールドの特別な値の使用例は、clora_iomodeがLAYOUTIOMODE4_ANY、lor_offsetがゼロ、lor_lengthがNFS4_UINT64_MAXの場合、レイアウト全体が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The NFS4ERR_NOMATCHING_LAYOUT error is only returned when the client does not hold layouts for the file or if the client does not have any overlapping layouts for the specification in the layout recall.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_NOMATCHING_LAYOUTエラーが返されるのは、クライアントがファイルのレイアウトを保持していない場合、またはクライアントがレイアウト再呼び出しの仕様に重複するレイアウトを持っていない場合のみです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTRECALL4_FSID and LAYOUTRECALL4_ALL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTRECALL4_FSIDおよびLAYOUTRECALL4_ALL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If LAYOUTRECALL4_FSID is specified, the fsid specifies the file system for which any outstanding layouts MUST be returned. If LAYOUTRECALL4_ALL is specified, all outstanding layouts MUST be returned. In addition, LAYOUTRECALL4_FSID and LAYOUTRECALL4_ALL specify that all the storage device ID to storage device address mappings in the affected file system(s) are also recalled. The respective LAYOUTRETURN with either LAYOUTRETURN4_FSID or LAYOUTRETURN4_ALL acknowledges to the server that the client invalidated the said device mappings. See Section 12.5.5.2.1.5 for considerations with &#34;bulk&#34; recall of layouts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
LAYOUTRECALL4_FSIDが指定されている場合、fsidは未解決のレイアウトを返す必要があるファイルシステムを指定します。 LAYOUTRECALL4_ALLが指定されている場合、すべての未解決のレイアウトを返す必要があります。さらに、LAYOUTRECALL4_FSIDおよびLAYOUTRECALL4_ALLは、影響を受けるファイルシステム内のすべてのストレージデバイスIDからストレージデバイスアドレスへのマッピングもリコールされることを指定します。 LAYOUTRETURN4_FSIDまたはLAYOUTRETURN4_ALLのいずれかを持つそれぞれのLAYOUTRETURNは、クライアントが上記のデバイスマッピングを無効にしたことをサーバーに確認します。レイアウトの「バルク」リコールに関する考慮事項については、セクション12.5.5.2.1.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The NFS4ERR_NOMATCHING_LAYOUT error is only returned when the client does not hold layouts and does not have valid deviceid mappings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_NOMATCHING_LAYOUTエラーは、クライアントがレイアウトを保持しておらず、有効なデバイスIDマッピングがない場合にのみ返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In processing the layout recall request, the client also varies its behavior based on the value of the clora_changed field. This field is used by the server to provide additional context for the reason why the layout is being recalled. A FALSE value for clora_changed indicates that no change in the layout is expected and the client may write modified data to the storage devices involved; this must be done prior to returning the layout via LAYOUTRETURN. A TRUE value for clora_changed indicates that the server is changing the layout. Examples of layout changes and reasons for a TRUE indication are the following: the metadata server is restriping the file or a permanent error has occurred on a storage device and the metadata server would like to provide a new layout for the file. Therefore, a clora_changed value of TRUE indicates some level of change for the layout and the client SHOULD NOT write and commit modified data to the storage devices. In this case, the client writes and commits data through the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウト再呼び出し要求を処理する際、クライアントはclora_changedフィールドの値に基づいてその動作も変化させます。サーバーはこのフィールドを使用して、レイアウトが呼び出される理由に応じて追加のコンテキストを提供します。 clora_changedのFALSE値は、レイアウトの変更が予期されておらず、クライアントが変更されたデータを関連するストレージデバイスに書き込む可能性があることを示します。これは、LAYOUTRETURNを介してレイアウトを返す前に行う必要があります。 clora_changedのTRUE値は、サーバーがレイアウトを変更していることを示します。レイアウトの変更とTRUE表示の理由の例は次のとおりです。メタデータサーバーがファイルを再ストライピングしている、またはストレージデバイスで永続的なエラーが発生し、メタデータサーバーがファイルに新しいレイアウトを提供しようとしています。したがって、clora_changed値がTRUEの場合は、レイアウトにある程度の変更があったことを示し、クライアントは変更されたデータをストレージデバイスに書き込んでコミットしてはいけません（SHOULD NOT）。この場合、クライアントはメタデータサーバーを通じてデータの書き込みとコミットを行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 12.5.3 for a description of how the lor_stateid field in the arguments is to be constructed. Note that the &#34;seqid&#34; field of lor_stateid MUST NOT be zero. See Sections 8.2, 12.5.3, and 12.5.5.2 for a further discussion and requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数のlor_stateidフィールドの作成方法については、セクション12.5.3を参照してください。 lor_stateidの「seqid」フィールドがゼロであってはならないことに注意してください。詳細な説明と要件については、セクション8.2、12.5.3、および12.5.5.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-3-4--IMPLEMENTATION">
20.3.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.3.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client&#39;s processing for CB_LAYOUTRECALL is similar to CB_RECALL (recall of file delegations) in that the client responds to the request before actually returning layouts via the LAYOUTRETURN operation. While the client responds to the CB_LAYOUTRECALL immediately, the operation is not considered complete (i.e., considered pending) until all affected layouts are returned to the server via the LAYOUTRETURN operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのCB_LAYOUTRECALLの処理は、クライアントが実際にLAYOUTRETURN操作を介してレイアウトを返す前に要求に応答するという点で、CB_RECALL（ファイルの委任の呼び出し）に似ています。クライアントはCB_LAYOUTRECALLに即座に応答しますが、影響を受けるすべてのレイアウトがLAYOUTRETURN操作を介してサーバーに返されるまで、操作は完了したとは見なされません（つまり、保留中と見なされます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before returning the layout to the server via LAYOUTRETURN, the client should wait for the response from in-process or in-flight READ, WRITE, or COMMIT operations that use the recalled layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTRETURNを介してレイアウトをサーバーに返す前に、クライアントは、呼び出されたレイアウトを使用するインプロセスまたは処理中のREAD、WRITE、またはCOMMIT操作からの応答を待つ必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client is holding modified data that is affected by a recalled layout, the client has various options for writing the data to the server. As always, the client may write the data through the metadata server. In fact, the client may not have a choice other than writing to the metadata server when the clora_changed argument is TRUE and a new layout is unavailable from the server. However, the client may be able to write the modified data to the storage device if the clora_changed argument is FALSE; this needs to be done before returning the layout via LAYOUTRETURN. If the client were to obtain a new layout covering the modified data&#39;s byte-range, then writing to the storage devices is an available alternative. Note that before obtaining a new layout, the client must first return the original layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが、呼び出されたレイアウトの影響を受ける変更されたデータを保持している場合、クライアントには、サーバーにデータを書き込むためのさまざまなオプションがあります。いつものように、クライアントはメタデータサーバーを介してデータを書き込むことができます。実際、clora_changed引数がTRUEであり、サーバーから新しいレイアウトを利用できない場合、クライアントはメタデータサーバーに書き込む以外に選択肢がない場合があります。ただし、clora_changed引数がFALSEの場合、クライアントは変更されたデータをストレージデバイスに書き込むことができます。これは、LAYOUTRETURNを介してレイアウトを返す前に行う必要があります。クライアントが変更されたデータのバイト範囲をカバーする新しいレイアウトを取得する場合は、ストレージデバイスへの書き込みが利用できます。新しいレイアウトを取得する前に、クライアントは最初に元のレイアウトを返す必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of modified data being written while the layout is held, the client must use LAYOUTCOMMIT operations at the appropriate time; as required LAYOUTCOMMIT must be done before the LAYOUTRETURN. If a large amount of modified data is outstanding, the client may send LAYOUTRETURNs for portions of the recalled layout; this allows the server to monitor the client&#39;s progress and adherence to the original recall request. However, the last LAYOUTRETURN in a sequence of returns MUST specify the full range being recalled (see Section 12.5.5.1 for details).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトが保持されている間に変更されたデータが書き込まれる場合、クライアントは適切なときにLAYOUTCOMMIT操作を使用する必要があります。必要に応じて、LAYOUTREMITの前にLAYOUTCOMMITを実行する必要があります。大量の変更データが未処理の場合、クライアントは、呼び出されたレイアウトの一部に対してLAYOUTRETURNを送信することがあります。これにより、サーバーはクライアントの進行状況と元の再呼び出し要求の順守を監視できます。ただし、一連のリターンの最後のLAYOUTRETURNは、リコールされる全範囲を指定する必要があります（詳細については、セクション12.5.5.1を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server needs to delete a device ID and there are layouts referring to the device ID, CB_LAYOUTRECALL MUST be invoked to cause the client to return all layouts referring to the device ID before the server can delete the device ID. If the client does not return the affected layouts, the server MAY revoke the layouts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがデバイスIDを削除する必要があり、デバイスIDを参照するレイアウトがある場合、サーバーがデバイスIDを削除する前に、クライアントがデバイスIDを参照するすべてのレイアウトを返すようにCB_LAYOUTRECALLを呼び出す必要があります。クライアントが影響を受けるレイアウトを返さない場合、サーバーはレイアウトを取り消す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-4--Operation-6-CBNOTIFY---Notify-Client-of-Directory-Changes">
20.4. Operation 6: CB_NOTIFY - Notify Client of Directory Changes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.4. 操作6：CB_NOTIFY-ディレクトリの変更をクライアントに通知
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-4-1--ARGUMENT">
20.4.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.4.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Directory notification types.
    */
   enum notify_type4 {
           NOTIFY4_CHANGE_CHILD_ATTRS = 0,
           NOTIFY4_CHANGE_DIR_ATTRS = 1,
           NOTIFY4_REMOVE_ENTRY = 2,
           NOTIFY4_ADD_ENTRY = 3,
           NOTIFY4_RENAME_ENTRY = 4,
           NOTIFY4_CHANGE_COOKIE_VERIFIER = 5
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Changed entry information.  */
   struct notify_entry4 {
           component4      ne_file;
           fattr4          ne_attrs;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Previous entry information */
   struct prev_entry4 {
           notify_entry4   pe_prev_entry;
           /* what READDIR returned for this entry */
           nfs_cookie4     pe_prev_entry_cookie;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct notify_remove4 {
           notify_entry4   nrm_old_entry;
           nfs_cookie4     nrm_old_entry_cookie;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct notify_add4 {
           /*
            * Information on object
            * possibly renamed over.
            */
           notify_remove4      nad_old_entry&lt;1&gt;;
           notify_entry4       nad_new_entry;
           /* what READDIR would have returned for this entry */
           nfs_cookie4         nad_new_entry_cookie&lt;1&gt;;
           prev_entry4         nad_prev_entry&lt;1&gt;;
           bool                nad_last_entry;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct notify_attr4 {
           notify_entry4   na_changed_entry;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct notify_rename4 {
           notify_remove4  nrn_old_entry;
           notify_add4     nrn_new_entry;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct notify_verifier4 {
           verifier4       nv_old_cookieverf;
           verifier4       nv_new_cookieverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Objects of type notify_&lt;&gt;4 and
    * notify_device_&lt;&gt;4 are encoded in this.
    */
   typedef opaque notifylist4&lt;&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct notify4 {
           /* composed from notify_type4 or notify_deviceid_type4 */
           bitmap4         notify_mask;
           notifylist4     notify_vals;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_NOTIFY4args {
           stateid4    cna_stateid;
           nfs_fh4     cna_fh;
           notify4     cna_changes&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-4-2--RESULT">
20.4.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.4.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_NOTIFY4res {
           nfsstat4    cnr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-4-3--DESCRIPTION">
20.4.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.4.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The CB_NOTIFY operation is used by the server to send notifications to clients about changes to delegated directories. The registration of notifications for the directories occurs when the delegation is established using GET_DIR_DELEGATION. These notifications are sent over the backchannel. The notification is sent once the original request has been processed on the server. The server will send an array of notifications for changes that might have occurred in the directory. The notifications are sent as list of pairs of bitmaps and values. See Section 3.3.7 for a description of how NFSv4.1 bitmaps work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーはCB_NOTIFY操作を使用して、委任されたディレクトリの変更に関する通知をクライアントに送信します。ディレクトリの通知の登録は、GET_DIR_DELEGATIONを使用して委任が確立されたときに行われます。これらの通知は、バックチャネルを介して送信されます。元のリクエストがサーバーで処理されると、通知が送信されます。サーバーは、ディレクトリで発生した可能性のある変更の通知の配列を送信します。通知は、ビットマップと値のペアのリストとして送信されます。 NFSv4.1ビットマップがどのように機能するかについては、セクション3.3.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server has more notifications than can fit in the CB_COMPOUND request, it SHOULD send a sequence of serial CB_COMPOUND requests so that the client&#39;s view of the directory does not become confused. For example, if the server indicates that a file named &#34;foo&#34; is added and that the file &#34;foo&#34; is removed, the order in which the client receives these notifications needs to be the same as the order in which the corresponding operations occurred on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーにCB_COMPOUND要求に収まらないほどの通知がある場合は、一連のシリアルCB_COMPOUND要求を送信して、クライアントのディレクトリのビューが混乱しないようにする必要があります（SHOULD）。たとえば、「foo」という名前のファイルが追加され、ファイル「foo」が削除されたことをサーバーが示す場合、クライアントがこれらの通知を受信する順序は、対応する操作が発生した順序と同じである必要があります。サーバー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client holding the delegation makes any changes in the directory that cause files or sub-directories to be added or removed, the server will notify that client of the resulting change(s). If the client holding the delegation is making attribute or cookie verifier changes only, the server does not need to send notifications to that client. The server will send the following information for each operation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任を保持しているクライアントがディレクトリに変更を加えると、ファイルやサブディレクトリが追加または削除され、サーバーはその変更をクライアントに通知します。委任を保持しているクライアントが属性またはcookie検証を変更するだけの場合、サーバーはそのクライアントに通知を送信する必要はありません。サーバーは、操作ごとに次の情報を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTIFY4_ADD_ENTRY The server will send information about the new directory entry being created along with the cookie for that entry. The entry information (data type notify_add4) includes the component name of the entry and attributes. The server will send this type of entry when a file is actually being created, when an entry is being added to a directory as a result of a rename across directories (see below), and when a hard link is being created to an existing file. If this entry is added to the end of the directory, the server will set the nad_last_entry flag to TRUE. If the file is added such that there is at least one entry before it, the server will also return the previous entry information (nad_prev_entry, a variable-length array of up to one element. If the array is of zero length, there is no previous entry), along with its cookie. This is to help clients find the right location in their file name caches and directory caches where this entry should be cached. If the new entry&#39;s cookie is available, it will be in the nad_new_entry_cookie (another variable-length array of up to one element) field. If the addition of the entry causes another entry to be deleted (which can only happen in the rename case) atomically with the addition, then information on this entry is reported in nad_old_entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTIFY4_ADD_ENTRYサーバーは、作成中の新しいディレクトリエントリに関する情報を、そのエントリのCookieとともに送信します。エントリ情報（データ型notify_add4）には、エントリのコンポーネント名と属性が含まれます。サーバーは、ファイルが実際に作成されているとき、ディレクトリ間で名前を変更した結果としてエントリがディレクトリに追加されているとき（以下を参照）、および既存のファイルへのハードリンクが作成されているときに、このタイプのエントリを送信します。このエントリがディレクトリの最後に追加されると、サーバーはnad_last_entryフラグをTRUEに設定します。その前に少なくとも1つのエントリがあるようにファイルが追加された場合、サーバーは前のエントリ情報（nad_prev_entry、最大1つの要素の可変長配列です。配列が長さゼロの場合、前のエントリ）とそのCookie。これは、クライアントが、このエントリをキャッシュする必要があるファイル名キャッシュとディレクトリキャッシュ内の適切な場所を見つけるのに役立ちます。新しいエントリのCookieが使用可能な場合、それはnad_new_entry_cookie（最大1つの要素の別の可変長配列）フィールドにあります。エントリを追加すると、別のエントリが（名前の変更の場合にのみ発生する）アトミックに削除される場合、このエントリの情報はnad_old_entryで報告されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTIFY4_REMOVE_ENTRY The server will send information about the directory entry being deleted. The server will also send the cookie value for the deleted entry so that clients can get to the cached information for this entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTIFY4_REMOVE_ENTRYサーバーは、削除されるディレクトリエントリに関する情報を送信します。サーバーは削除されたエントリのCookie値も送信するため、クライアントはこのエントリのキャッシュされた情報にアクセスできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTIFY4_RENAME_ENTRY The server will send information about both the old entry and the new entry. This includes the name and attributes for each entry. In addition, if the rename causes the deletion of an entry (i.e., the case of a file renamed over), then this is reported in nrn_new_new_entry.nad_old_entry. This notification is only sent if both entries are in the same directory. If the rename is across directories, the server will send a remove notification to one directory and an add notification to the other directory, assuming both have a directory delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTIFY4_RENAME_ENTRYサーバーは、古いエントリと新しいエントリの両方に関する情報を送信します。これには、各エントリの名前と属性が含まれます。さらに、名前の変更によってエントリが削除された場合（つまり、ファイルの名前が上書きされた場合）、これはnrn_new_new_entry.nad_old_entryで報告されます。この通知は、両方のエントリが同じディレクトリにある場合にのみ送信されます。名前の変更が複数のディレクトリにまたがっている場合、サーバーは削除通知を1つのディレクトリに送信し、追加通知を他のディレクトリに送信します（両方にディレクトリ委任があると想定）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTIFY4_CHANGE_CHILD_ATTRS/NOTIFY4_CHANGE_DIR_ATTRS The client will use the attribute mask to inform the server of attributes for which it wants to receive notifications. This change notification can be requested for changes to the attributes of the directory as well as changes to any file&#39;s attributes in the directory by using two separate attribute masks. The client cannot ask for change attribute notification for a specific file. One attribute mask covers all the files in the directory. Upon any attribute change, the server will send back the values of changed attributes. Notifications might not make sense for some file system-wide attributes, and it is up to the server to decide which subset it wants to support. The client can negotiate the frequency of attribute notifications by letting the server know how often it wants to be notified of an attribute change. The server will return supported notification frequencies or an indication that no notification is permitted for directory or child attributes by setting the dir_notif_delay and dir_entry_notif_delay attributes, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTIFY4_CHANGE_CHILD_ATTRS / NOTIFY4_CHANGE_DIR_ATTRSクライアントは属性マスクを使用して、通知を受信する属性をサーバーに通知します。この変更通知は、2つの個別の属性マスクを使用して、ディレクトリの属性の変更や、ディレクトリ内のファイルの属性の変更を要求することができます。クライアントは、特定のファイルの属性変更通知を要求できません。 1つの属性マスクは、ディレクトリ内のすべてのファイルをカバーします。属性が変更されると、サーバーは変更された属性の値を送り返します。一部のファイルシステム全体の属性では通知が意味をなさない場合があり、サポートするサブセットを決定するのはサーバーの責任です。クライアントは、属性の変更を通知する頻度をサーバーに通知することにより、属性通知の頻度をネゴシエートできます。サーバーは、dir_notif_delayおよびdir_entry_notif_delay属性をそれぞれ設定することにより、サポートされる通知頻度またはディレクトリまたは子属性の通知が許可されていないことを示す通知を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTIFY4_CHANGE_COOKIE_VERIFIER If the cookie verifier changes while a client is holding a delegation, the server will notify the client so that it can invalidate its cookies and re-send a READDIR to get the new set of cookies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTIFY4_CHANGE_COOKIE_VERIFIERクライアントが委任を保持している間にCookieベリファイアが変更されると、サーバーはクライアントに通知して、Cookieを無効にし、READDIRを再送信して新しいCookieのセットを取得できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
20.5. Operation 7: CB_PUSH_DELEG - Offer Previously Requested Delegation to Client
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
20.5. 操作7：CB_PUSH_DELEG-以前に要求された委任をクライアントに提供する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-5-1--ARGUMENT">
20.5.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.5.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_PUSH_DELEG4args {
           nfs_fh4          cpda_fh;
           open_delegation4 cpda_delegation;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-5-2--RESULT">
20.5.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.5.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_PUSH_DELEG4res {
           nfsstat4 cpdr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-5-3--DESCRIPTION">
20.5.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.5.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_PUSH_DELEG is used by the server both to signal to the client that the delegation it wants (previously indicated via a want established from an OPEN or WANT_DELEGATION operation) is available and to simultaneously offer the delegation to the client. The client has the choice of accepting the delegation by returning NFS4_OK to the server, delaying the decision to accept the offered delegation by returning NFS4ERR_DELAY, or permanently rejecting the offer of the delegation by returning NFS4ERR_REJECT_DELEG. When a delegation is rejected in this fashion, the want previously established is permanently deleted and the delegation is subject to acquisition by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはCB_PUSH_DELEGを使用して、サーバーに必要な委任（以前はOPENまたはWANT_DELEGATION操作から確立された要求によって指定された）が利用可能であることをクライアントに通知すると同時に、クライアントに委任を提供します。クライアントは、NFS4_OKをサーバーに返すことによって委任を受け入れるか、NFS4ERR_DELAYを返すことによって提供された委任を受け入れる決定を遅らせるか、またはNFS4ERR_REJECT_DELEGを返すことによって委任の提案を永久に拒否するかを選択できます。この方法で委任が拒否されると、以前に確立された要求は完全に削除され、委任は別のクライアントによる取得の対象になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-5-4--IMPLEMENTATION">
20.5.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.5.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client does return NFS4ERR_DELAY and there is a conflicting delegation request, the server MAY process it at the expense of the client that returned NFS4ERR_DELAY. The client&#39;s want will not be cancelled, but MAY be processed behind other delegation requests or registered wants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがNFS4ERR_DELAYを返し、委任要求が競合している場合、サーバーは、NFS4ERR_DELAYを返したクライアントを犠牲にしてそれを処理できます（MAY）。クライアントの要求はキャンセルされませんが、他の委任要求または登録された要求の背後で処理される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client returns a status other than NFS4_OK, NFS4ERR_DELAY, or NFS4ERR_REJECT_DELAY, the want remains pending, although servers may decide to cancel the want by sending a CB_WANTS_CANCELLED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがNFS4_OK、NFS4ERR_DELAY、またはNFS4ERR_REJECT_DELAY以外のステータスを返した場合、サーバーはCB_WANTS_CANCELLEDを送信して要求を取り消す可能性がありますが、要求は保留中のままです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-6--Operation-8-CBRECALLANY---Keep-Any-N-Recallable-Objects">
20.6. Operation 8: CB_RECALL_ANY - Keep Any N Recallable Objects
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.6. 操作8：CB_RECALL_ANY-N個のリコール可能なオブジェクトを保持
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-6-1--ARGUMENT">
20.6.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.6.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const RCA4_TYPE_MASK_RDATA_DLG          = 0;
   const RCA4_TYPE_MASK_WDATA_DLG          = 1;
   const RCA4_TYPE_MASK_DIR_DLG            = 2;
   const RCA4_TYPE_MASK_FILE_LAYOUT        = 3;
   const RCA4_TYPE_MASK_BLK_LAYOUT         = 4;
   const RCA4_TYPE_MASK_OBJ_LAYOUT_MIN     = 8;
   const RCA4_TYPE_MASK_OBJ_LAYOUT_MAX     = 9;
   const RCA4_TYPE_MASK_OTHER_LAYOUT_MIN   = 12;
   const RCA4_TYPE_MASK_OTHER_LAYOUT_MAX   = 15;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct  CB_RECALL_ANY4args      {
           uint32_t        craa_objects_to_keep;
           bitmap4         craa_type_mask;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-6-2--RESULT">
20.6.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.6.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_RECALL_ANY4res {
           nfsstat4        crar_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-6-3--DESCRIPTION">
20.6.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.6.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server may decide that it cannot hold all of the state for recallable objects, such as delegations and layouts, without running out of resources. In such a case, while not optimal, the server is free to recall individual objects to reduce the load.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、リソースを使い果たすことなく、委任やレイアウトなどの再呼び出し可能なオブジェクトのすべての状態を保持できないと判断する場合があります。このような場合、最適ではありませんが、サーバーは個々のオブジェクトを自由に呼び出して負荷を軽減できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the general purpose of such recallable objects as delegations is to eliminate client interaction with the server, the server cannot interpret lack of recent use as indicating that the object is no longer useful. The absence of visible use is consistent with a delegation keeping potential operations from being sent to the server. In the case of layouts, while it is true that the usefulness of a layout is indicated by the use of the layout when storage devices receive I/O requests, because there is no mandate that a storage device indicate to the metadata server any past or present use of a layout, the metadata server is not likely to know which layouts are good candidates to recall in response to low resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任などの再呼び出し可能なオブジェクトの一般的な目的はサーバーとのクライアントの対話を排除することであるため、サーバーは最近の使用の欠如をオブジェクトがもはや有用ではないことを示すものとして解釈できません。目に見える使用がないことは、潜在的な操作がサーバーに送信されないようにする委任と一致しています。レイアウトの場合、ストレージデバイスがI / O要求を受け取ったときにレイアウトを使用することでレイアウトの有用性が示されることは事実ですが、ストレージデバイスが過去またはレイアウトの現在の使用では、メタデータサーバーは、リソースが少ない場合にどのレイアウトがリコールするのに適しているかを知る可能性が低くなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to implement an effective reclaim scheme for such objects, the server&#39;s knowledge of available resources must be used to determine when objects must be recalled with the clients selecting the actual objects to be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このようなオブジェクトに効果的な再利用スキームを実装するには、利用可能なリソースに関するサーバーの知識を使用して、返される実際のオブジェクトを選択するクライアントでオブジェクトをいつ呼び出す必要があるかを判断する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server implementations may differ in their resource allocation requirements. For example, one server may share resources among all classes of recallable objects, whereas another may use separate resource pools for layouts and for delegations, or further separate resources by types of delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの実装は、リソース割り当て要件が異なる場合があります。たとえば、1つのサーバーはリコール可能なオブジェクトのすべてのクラス間でリソースを共有し、別のサーバーはレイアウトと委任に個別のリソースプールを使用するか、委任のタイプごとにさらに個別のリソースを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a given resource pool is over-utilized, the server can send a CB_RECALL_ANY to clients holding recallable objects of the types involved, allowing it to keep a certain number of such objects and return any excess. A mask specifies which types of objects are to be limited. The client chooses, based on its own knowledge of current usefulness, which of the objects in that class should be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のリソースプールが過剰に使用されている場合、サーバーはCB_RECALL_ANYを関連するタイプの再呼び出し可能なオブジェクトを保持しているクライアントに送信して、特定の数のそのようなオブジェクトを保持し、超過分を返すことができます。マスクは、制限するオブジェクトのタイプを指定します。クライアントは、現在の有用性に関する独自の知識に基づいて、そのクラスのどのオブジェクトを返すかを選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number of bits are defined. For some of these, ranges are defined and it is up to the definition of the storage protocol to specify how these are to be used. There are ranges reserved for object-based storage protocols and for other experimental storage protocols. An RFC defining such a storage protocol needs to specify how particular bits within its range are to be used. For example, it may specify a mapping between attributes of the layout (read vs. write, size of area) and the bit to be used, or it may define a field in the layout where the associated bit position is made available by the server to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのビットが定義されています。これらの一部では、範囲が定義されており、使用方法を指定するのはストレージプロトコルの定義次第です。オブジェクトベースのストレージプロトコルおよびその他の実験的なストレージプロトコル用に予約された範囲があります。このようなストレージプロトコルを定義するRFCでは、その範囲内の特定のビットをどのように使用するかを指定する必要があります。たとえば、レイアウトの属性（読み取りと書き込み、領域のサイズ）と使用するビットの間のマッピングを指定したり、関連するビット位置がサーバーによって利用可能になるレイアウト内のフィールドを定義したりできます。クライアントに。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RCA4_TYPE_MASK_RDATA_DLG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RCA4_TYPE_MASK_RDATA_DLG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The client is to return OPEN_DELEGATE_READ delegations on non-directory file objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントは、非ディレクトリファイルオブジェクトのOPEN_DELEGATE_READ委任を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RCA4_TYPE_MASK_WDATA_DLG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RCA4_TYPE_MASK_WDATA_DLG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The client is to return OPEN_DELEGATE_WRITE delegations on regular file objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントは、通常のファイルオブジェクトのOPEN_DELEGATE_WRITE委任を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RCA4_TYPE_MASK_DIR_DLG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RCA4_TYPE_MASK_DIR_DLG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The client is to return directory delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントはディレクトリの委任を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RCA4_TYPE_MASK_FILE_LAYOUT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RCA4_TYPE_MASK_FILE_LAYOUT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The client is to return layouts of type LAYOUT4_NFSV4_1_FILES.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントは、タイプLAYOUT4_NFSV4_1_FILESのレイアウトを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RCA4_TYPE_MASK_BLK_LAYOUT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RCA4_TYPE_MASK_BLK_LAYOUT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
See [41] for a description.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
説明については、[41]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RCA4_TYPE_MASK_OBJ_LAYOUT_MIN to RCA4_TYPE_MASK_OBJ_LAYOUT_MAX
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RCA4_TYPE_MASK_OBJ_LAYOUT_MINからRCA4_TYPE_MASK_OBJ_LAYOUT_MAX
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
See [40] for a description.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
説明は[40]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RCA4_TYPE_MASK_OTHER_LAYOUT_MIN to RCA4_TYPE_MASK_OTHER_LAYOUT_MAX
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RCA4_TYPE_MASK_OTHER_LAYOUT_MINからRCA4_TYPE_MASK_OTHER_LAYOUT_MAX
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This range is reserved for telling the client to recall layouts of experimental or site-specific layout types (see Section 3.3.13).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この範囲は、実験的またはサイト固有のレイアウトタイプのレイアウトをリコールするようクライアントに指示するために予約されています（セクション3.3.13を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a bit is set in the type mask that corresponds to an undefined type of recallable object, NFS4ERR_INVAL MUST be returned. When a bit is set that corresponds to a defined type of object but the client does not support an object of the type, NFS4ERR_INVAL MUST NOT be returned. Future minor versions of NFSv4 may expand the set of valid type mask bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未定義のリコール可能なオブジェクトのタイプに対応するタイプマスクにビットが設定されている場合、NFS4ERR_INVALが返される必要があります。オブジェクトの定義されたタイプに対応するビットが設定されているが、クライアントがそのタイプのオブジェクトをサポートしていない場合、NFS4ERR_INVALを返してはならない（MUST NOT）。 NFSv4の将来のマイナーバージョンでは、有効なタイプマスクビットのセットが拡張される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_RECALL_ANY specifies a count of objects that the client may keep as opposed to a count that the client must return. This is to avoid a potential race between a CB_RECALL_ANY that had a count of objects to free with a set of client-originated operations to return layouts or delegations. As a result of the race, the client and server would have differing ideas as to how many objects to return. Hence, the client could mistakenly free too many.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_RECALL_ANYは、クライアントが返す必要があるカウントとは対照的に、クライアントが保持できるオブジェクトのカウントを指定します。これは、オブジェクト数を解放したCB_RECALL_ANYと、レイアウトまたは委任を返すためにクライアントが生成した操作のセットとの間の潜在的な競合を回避するためです。競争の結果として、クライアントとサーバーは、返すオブジェクトの数に関して異なる考えを持つことになります。したがって、クライアントは誤って多くを解放する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If resource demands prompt it, the server may send another CB_RECALL_ANY with a lower count, even if it has not yet received an acknowledgment from the client for a previous CB_RECALL_ANY with the same type mask. Although the possibility exists that these will be received by the client in an order different from the order in which they were sent, any such permutation of the callback stream is harmless. It is the job of the client to bring down the size of the recallable object set in line with each CB_RECALL_ANY received, and until that obligation is met, it cannot be cancelled or modified by any subsequent CB_RECALL_ANY for the same type mask. Thus, if the server sends two CB_RECALL_ANYs, the effect will be the same as if the lower count was sent, whatever the order of recall receipt. Note that this means that a server may not cancel the effect of a CB_RECALL_ANY by sending another recall with a higher count. When a CB_RECALL_ANY is received and the count is already within the limit set or is above a limit that the client is working to get down to, that callback has no effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースの要求によりプロンプトが表示された場合、サーバーは、同じタイプのマスクを持つ以前のCB_RECALL_ANYの確認をクライアントからまだ受け取っていない場合でも、より少ないカウントの別のCB_RECALL_ANYを送信できます。これらが送信された順序とは異なる順序でクライアントによって受信される可能性はありますが、そのようなコールバックストリームの順列は無害です。クライアントの仕事は、受け取った各CB_RECALL_ANYに合わせてリコール可能なオブジェクトセットのサイズを下げることであり、その義務が満たされるまで、同じタイプマスクの後続のCB_RECALL_ANYによってキャンセルまたは変更することはできません。したがって、サーバーが2つのCB_RECALL_ANYを送信する場合、リコールの受信順序に関係なく、より少ないカウントが送信された場合と同じ結果になります。これは、サーバーがより高いカウントで別の再呼び出しを送信することによってCB_RECALL_ANYの効果をキャンセルできないことを意味することに注意してください。 CB_RECALL_ANYが受信され、カウントがすでに設定された制限内にあるか、クライアントが到達するために動作している制限を超えている場合、そのコールバックは効果がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers are generally free to deny recallable objects when insufficient resources are available. Note that the effect of such a policy is implicitly to give precedence to existing objects relative to requested ones, with the result that resources might not be optimally used. To prevent this, servers are well advised to make the point at which they start sending CB_RECALL_ANY callbacks somewhat below that at which they cease to give out new delegations and layouts. This allows the client to purge its less-used objects whenever appropriate and so continue to have its subsequent requests given new resources freed up by object returns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは一般に、十分なリソースが利用できない場合、呼び出し可能なオブジェクトを自由に拒否できます。このようなポリシーの効果は、要求されたオブジェクトよりも既存のオブジェクトに優先順位を与えるために暗黙的に行われるため、リソースが最適に使用されない可能性があることに注意してください。これを防ぐために、サーバーはCB_RECALL_ANYコールバックの送信を開始する時点を、新しい委任とレイアウトを提供するのをやめる時点よりもやや下にすることをお勧めします。これにより、クライアントは使用頻度の低いオブジェクトを適切なタイミングでパージできるため、オブジェクトが返すことで新しいリソースが解放された場合、後続のリクエストを継続できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-6-4--IMPLEMENTATION">
20.6.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.6.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client can choose to return any type of object specified by the mask. If a server wishes to limit the use of objects of a specific type, it should only specify that type in the mask it sends. Should the client fail to return requested objects, it is up to the server to handle this situation, typically by sending specific recalls (i.e., sending CB_RECALL operations) to properly limit resource usage. The server should give the client enough time to return objects before proceeding to specific recalls. This time should not be less than the lease period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、マスクで指定された任意のタイプのオブジェクトを返すことを選択できます。サーバーが特定のタイプのオブジェクトの使用を制限したい場合は、送信するマスクでそのタイプのみを指定する必要があります。クライアントが要求されたオブジェクトを返せなかった場合、リソースの使用を適切に制限するために特定の再呼び出しを送信する（つまり、CB_RECALL操作を送信する）ことにより、この状況を処理するのはサーバーの役割です。サーバーは、特定の再呼び出しに進む前にオブジェクトを返すのに十分な時間をクライアントに与える必要があります。この時間はリース期間を下回ってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
20.7. Operation 9: CB_RECALLABLE_OBJ_AVAIL - Signal Resources for Recallable Objects
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
20.7. 操作9：CB_RECALLABLE_OBJ_AVAIL-リコール可能なオブジェクトの信号リソース
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-7-1--ARGUMENT">
20.7.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.7.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef CB_RECALL_ANY4args CB_RECALLABLE_OBJ_AVAIL4args;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef CB_RECALL_ANY4args CB_RECALLABLE_OBJ_AVAIL4args;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-7-2--RESULT">
20.7.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.7.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_RECALLABLE_OBJ_AVAIL4res {
           nfsstat4        croa_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-7-3--DESCRIPTION">
20.7.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.7.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_RECALLABLE_OBJ_AVAIL is used by the server to signal the client that the server has resources to grant recallable objects that might previously have been denied by OPEN, WANT_DELEGATION, GET_DIR_DELEG, or LAYOUTGET.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_RECALLABLE_OBJ_AVAILはサーバーによって使用され、サーバーに、以前にOPEN、WANT_DELEGATION、GET_DIR_DELEG、またはLAYOUTGETによって拒否された可能性のある再呼び出し可能なオブジェクトを付与するリソースがあることをクライアントに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The argument craa_objects_to_keep means the total number of recallable objects of the types indicated in the argument type_mask that the server believes it can allow the client to have, including the number of such objects the client already has. A client that tries to acquire more recallable objects than the server informs it can have runs the risk of having objects recalled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数craa_objects_to_keepは、クライアントがすでに持つことができるオブジェクトの数を含む、サーバーがクライアントが持つことを許可できるとサーバーが信じる引数type_maskで示されたタイプの再呼び出し可能なオブジェクトの総数を意味します。サーバーが通知できるよりも多くの再呼び出し可能なオブジェクトを取得しようとするクライアントは、オブジェクトが再呼び出しされるリスクを負う可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server is not obligated to reserve the difference between the number of the objects the client currently has and the value of craa_objects_to_keep, nor does delaying the reply to CB_RECALLABLE_OBJ_AVAIL prevent the server from using the resources of the recallable objects for another purpose. Indeed, if a client responds slowly to CB_RECALLABLE_OBJ_AVAIL, the server might interpret the client as having reduced capability to manage recallable objects, and so cancel or reduce any reservation it is maintaining on behalf of the client. Thus, if the client desires to acquire more recallable objects, it needs to reply quickly to CB_RECALLABLE_OBJ_AVAIL, and then send the appropriate operations to acquire recallable objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、クライアントが現在保持しているオブジェクトの数とcraa_objects_to_keepの値の差を予約する義務はありません。また、CB_RECALLABLE_OBJ_AVAILへの応答を遅らせても、サーバーが別の目的でリコール可能なオブジェクトのリソースを使用できなくなります。実際、クライアントがCB_RECALLABLE_OBJ_AVAILへの応答が遅い場合、サーバーはクライアントをリコール可能なオブジェクトを管理する機能が低下していると解釈し、クライアントに代わって維持している予約をキャンセルまたは削減する場合があります。したがって、クライアントがより多くの再呼び出し可能なオブジェクトを取得したい場合、クライアントはCB_RECALLABLE_OBJ_AVAILにすばやく応答し、適切な操作を送信して再呼び出し可能なオブジェクトを取得する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-8--Operation-10-CBRECALLSLOT---Change-Flow-Control-Limits">
20.8. Operation 10: CB_RECALL_SLOT - Change Flow Control Limits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.8. 操作10：CB_RECALL_SLOT-フロー制御制限の変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-8-1--ARGUMENT">
20.8.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.8.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_RECALL_SLOT4args {
           slotid4       rsa_target_highest_slotid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-8-2--RESULT">
20.8.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.8.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_RECALL_SLOT4res {
           nfsstat4   rsr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-8-3--DESCRIPTION">
20.8.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.8.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_RECALL_SLOT operation requests the client to return session slots, and if applicable, transport credits (e.g., RDMA credits for connections associated with the operations channel) of the session&#39;s fore channel. CB_RECALL_SLOT specifies rsa_target_highest_slotid, the value of the target highest slot ID the server wants for the session. The client MUST then progress toward reducing the session&#39;s highest slot ID to the target value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_RECALL_SLOT操作は、クライアントにセッションスロットを返すように要求し、該当する場合は、セッションのフォアチャネルの転送クレジット（操作チャネルに関連付けられた接続のRDMAクレジットなど）を転送します。 CB_RECALL_SLOTは、サーバーがセッションに必要とするターゲットの最大スロットIDの値であるrsa_target_highest_slotidを指定します。次に、クライアントは、セッションの最大スロットIDをターゲット値に減らす方向に進む必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the session has only non-RDMA connections associated with its operations channel, then the client need only wait for all outstanding requests with a slot ID &gt; rsa_target_highest_slotid to complete, then send a single COMPOUND consisting of a single SEQUENCE operation, with the sa_highestslot field set to rsa_target_highest_slotid. If there are RDMA-based connections associated with operation channel, then the client needs to also send enough zero-length &#34;RDMA Send&#34; messages to take the total RDMA credit count to rsa_target_highest_slotid + 1 or below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションにそのオペレーションチャネルに関連付けられた非RDMA接続のみがある場合、クライアントは、スロットID&gt; rsa_target_highest_slotidの未解決の要求がすべて完了するのを待つだけでよく、次に、sa_highestslotフィールドを使用して、単一のSEQUENCEオペレーションで構成される単一のCOMPOUNDを送信します。 rsa_target_highest_slotidに設定します。オペレーションチャネルに関連付けられたRDMAベースの接続がある場合、クライアントは、RDMAクレジットの総数をrsa_target_highest_slotid + 1以下にするために、十分な長さの「RDMA Send」メッセージも送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-8-4--IMPLEMENTATION">
20.8.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.8.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client fails to reduce highest slot it has on the fore channel to what the server requests, the server can force the issue by asserting flow control on the receive side of all connections bound to the fore channel, and then finish servicing all outstanding requests that are in slots greater than rsa_target_highest_slotid. Once that is done, the server can then open the flow control, and any time the client sends a new request on a slot greater than rsa_target_highest_slotid, the server can return NFS4ERR_BADSLOT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがフォアチャネルにある最上位のスロットをサーバーが要求するスロットに削減できない場合、サーバーは、フォアチャネルにバインドされているすべての接続の受信側でフロー制御をアサートして問題を強制し、未解決のすべての要求のサービスを終了できます。これらは、rsa_target_highest_slotidより大きいスロットにあります。これが完了すると、サーバーはフロー制御を開くことができ、クライアントがrsa_target_highest_slotidより大きいスロットで新しい要求を送信するたびに、サーバーはNFS4ERR_BADSLOTを返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
20.9. Operation 11: CB_SEQUENCE - Supply Backchannel Sequencing and Control
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
20.9. 操作11：CB_SEQUENCE-バックチャネルのシーケンスと制御の供給
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-9-1--ARGUMENT">
20.9.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.9.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct referring_call4 {
           sequenceid4     rc_sequenceid;
           slotid4         rc_slotid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct referring_call_list4 {
           sessionid4      rcl_sessionid;
           referring_call4 rcl_referring_calls&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_SEQUENCE4args {
           sessionid4           csa_sessionid;
           sequenceid4          csa_sequenceid;
           slotid4              csa_slotid;
           slotid4              csa_highest_slotid;
           bool                 csa_cachethis;
           referring_call_list4 csa_referring_call_lists&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-9-2--RESULT">
20.9.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.9.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_SEQUENCE4resok {
           sessionid4         csr_sessionid;
           sequenceid4        csr_sequenceid;
           slotid4            csr_slotid;
           slotid4            csr_highest_slotid;
           slotid4            csr_target_highest_slotid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union CB_SEQUENCE4res switch (nfsstat4 csr_status) {
   case NFS4_OK:
           CB_SEQUENCE4resok   csr_resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-9-3--DESCRIPTION">
20.9.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.9.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_SEQUENCE operation is used to manage operational accounting for the backchannel of the session on which a request is sent. The contents include the session ID to which this request belongs, the slot ID and sequence ID used by the server to implement session request control and exactly once semantics, and exchanged slot ID maxima that are used to adjust the size of the reply cache. In each CB_COMPOUND request, CB_SEQUENCE MUST appear once and MUST be the first operation. The error NFS4ERR_SEQUENCE_POS MUST be returned when CB_SEQUENCE is found in any position in a CB_COMPOUND beyond the first. If any other operation is in the first position of CB_COMPOUND, NFS4ERR_OP_NOT_IN_SESSION MUST be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_SEQUENCE操作は、要求が送信されるセッションのバックチャネルの運用アカウンティングを管理するために使用されます。コンテンツには、このリクエストが属するセッションID、セッションリクエストコントロールと1回限りのセマンティクスを実装するためにサーバーが使用するスロットIDとシーケンスID、および応答キャッシュのサイズを調整するために使用される交換されたスロットIDの最大値が含まれます。各CB_COMPOUNDリクエストでは、CB_SEQUENCEが1回出現し、最初の操作である必要があります。 CB_SEQUENCEが最初を超えてCB_COMPOUNDの任意の位置で見つかった場合、エラーNFS4ERR_SEQUENCE_POSを返さなければなりません（MUST）。他の操作がCB_COMPOUNDの最初の位置にある場合、NFS4ERR_OP_NOT_IN_SESSIONを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 18.46.3 for a description of how slots are processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スロットの処理方法については、セクション18.46.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If csa_cachethis is TRUE, then the server is requesting that the client cache the reply in the callback reply cache. The client MUST cache the reply (see Section 2.10.6.1.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
csa_cachethisがTRUEの場合、サーバーはクライアントが応答をコールバック応答キャッシュにキャッシュすることを要求しています。クライアントは応答をキャッシュしなければなりません（セクション2.10.6.1.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The csa_referring_call_lists array is the list of COMPOUND requests, identified by session ID, slot ID, and sequence ID. These are requests that the client previously sent to the server. These previous requests created state that some operation(s) in the same CB_COMPOUND as the csa_referring_call_lists are identifying. A session ID is included because leased state is tied to a client ID, and a client ID can have multiple sessions. See Section 2.10.6.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
csa_referring_call_lists配列は、セッションID、スロットID、およびシーケンスIDで識別されるCOMPOUNDリクエストのリストです。これらは、クライアントが以前にサーバーに送信した要求です。作成されたこれらの以前の要求は、csa_referring_call_listsと同じCB_COMPOUND内の一部の操作が識別していることを示しています。リース状態はクライアントIDに関連付けられ、クライアントIDは複数のセッションを持つことができるため、セッションIDが含まれています。セクション2.10.6.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value of the csa_sequenceid argument relative to the cached sequence ID on the slot falls into one of three cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スロットのキャッシュされたシーケンスIDに対するcsa_sequenceid引数の値は、3つのケースのいずれかに該当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the difference between csa_sequenceid and the client&#39;s cached sequence ID at the slot ID is two (2) or more, or if csa_sequenceid is less than the cached sequence ID (accounting for wraparound of the unsigned sequence ID value), then the client MUST return NFS4ERR_SEQ_MISORDERED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o csa_sequenceidとスロットIDでのクライアントのキャッシュされたシーケンスIDの差が2（2）以上の場合、またはcsa_sequenceidがキャッシュされたシーケンスID（署名されていないシーケンスID値のラップアラウンドを考慮）より小さい場合、クライアントは返す必要があります。 NFS4ERR_SEQ_MISORDERED。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If csa_sequenceid and the cached sequence ID are the same, this is a retry, and the client returns the CB_COMPOUND request&#39;s cached reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o csa_sequenceidとキャッシュされたシーケンスIDが同じ場合、これは再試行であり、クライアントはCB_COMPOUNDリクエストのキャッシュされた応答を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If csa_sequenceid is one greater (accounting for wraparound) than the cached sequence ID, then this is a new request, and the slot&#39;s sequence ID is incremented. The operations subsequent to CB_SEQUENCE, if any, are processed. If there are no other operations, the only other effects are to cache the CB_SEQUENCE reply in the slot, maintain the session&#39;s activity, and when the server receives the CB_SEQUENCE reply, renew the lease of state related to the client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o csa_sequenceidがキャッシュされたシーケンスIDよりも1つ大きい（ラップアラウンドを考慮している）場合、これは新しいリクエストであり、スロットのシーケンスIDがインクリメントされます。 CB_SEQUENCEに続く操作があれば、それが処理されます。他に操作がない場合、他の唯一の影響は、CB_SEQUENCE応答をスロットにキャッシュし、セッションのアクティビティを維持し、サーバーがCB_SEQUENCE応答を受信したときに、クライアントIDに関連する状態のリースを更新することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server reuses a slot ID and sequence ID for a completely different request, the client MAY treat the request as if it is a retry of what it has already executed. The client MAY however detect the server&#39;s illegal reuse and return NFS4ERR_SEQ_FALSE_RETRY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが完全に異なるリクエストのスロットIDとシーケンスIDを再利用する場合、クライアントはそのリクエストを、それがすでに実行したものの再試行であるかのように扱うことができます（MAY）。ただし、クライアントはサーバーの不正な再利用を検出して、NFS4ERR_SEQ_FALSE_RETRYを返す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If CB_SEQUENCE returns an error, then the state of the slot (sequence ID, cached reply) MUST NOT change. See Section 2.10.6.1.3 for the conditions when the error NFS4ERR_RETRY_UNCACHED_REP might be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_SEQUENCEがエラーを返す場合、スロットの状態（シーケンスID、キャッシュされた応答）を変更してはなりません（MUST NOT）。エラーNFS4ERR_RETRY_UNCACHED_REPが返される可能性がある条件については、セクション2.10.6.1.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client returns two &#34;highest_slotid&#34; values: csr_highest_slotid and csr_target_highest_slotid. The former is the highest slot ID the client will accept in a future CB_SEQUENCE operation, and SHOULD NOT be less than the value of csa_highest_slotid (but see
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、2つの「highest_slotid」値、csr_highest_slotidとcsr_target_highest_slotidを返します。前者は、クライアントが将来のCB_SEQUENCE操作で受け入れる最大のスロットIDであり、csa_highest_slotidの値より小さくしてはなりません（ただし、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 2.10.6.1 for an exception). The latter is the highest slot ID the client would prefer the server use on a future CB_SEQUENCE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例外については、セクション2.10.6.1）。後者は、クライアントが将来のCB_SEQUENCE操作でサーバーが使用することを好む最高のスロットIDです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
20.10. Operation 12: CB_WANTS_CANCELLED - Cancel Pending Delegation Wants
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
20.10. 操作12：CB_WANTS_CANCELLED-保留中の委任をキャンセル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-10-1--ARGUMENT">
20.10.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.10.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_WANTS_CANCELLED4args {
           bool cwca_contended_wants_cancelled;
           bool cwca_resourced_wants_cancelled;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-10-2--RESULT">
20.10.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.10.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_WANTS_CANCELLED4res {
           nfsstat4        cwcr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-10-3--DESCRIPTION">
20.10.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.10.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_WANTS_CANCELLED operation is used to notify the client that some or all of the wants it registered for recallable delegations and layouts have been cancelled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_WANTS_CANCELLED操作を使用して、クライアントに、呼び出し可能な委任とレイアウトに登録されている要求の一部またはすべてが取り消されたことを通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If cwca_contended_wants_cancelled is TRUE, this indicates that the server will not be pushing to the client any delegations that become available after contention passes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cwca_contended_wants_cancelledがTRUEの場合、これは、サーバーが競合の通過後に使用可能になる委任をクライアントにプッシュしないことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If cwca_resourced_wants_cancelled is TRUE, this indicates that the server will not notify the client when there are resources on the server to grant delegations or layouts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cwca_resourced_wants_cancelledがTRUEの場合、これは、サーバー上に委任またはレイアウトを付与するリソースがあるときにサーバーがクライアントに通知しないことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After receiving a CB_WANTS_CANCELLED operation, the client is free to attempt to acquire the delegations or layouts it was waiting for, and possibly re-register wants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_WANTS_CANCELLED操作を受け取った後、クライアントは、待機していた委任またはレイアウトを自由に取得して、必要に応じて再登録できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-10-4--IMPLEMENTATION">
20.10.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.10.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client has an OPEN, WANT_DELEGATION, or GET_DIR_DELEGATION request outstanding, when a CB_WANTS_CANCELLED is sent, the server may need to make clear to the client whether a promise to signal delegation availability happened before the CB_WANTS_CANCELLED and is thus covered by it, or after the CB_WANTS_CANCELLED in which case it was not covered by it. The server can make this distinction by putting the appropriate requests into the list of referring calls in the associated CB_SEQUENCE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが未処理のOPEN、WANT_DELEGATION、またはGET_DIR_DELEGATION要求を持っている場合、CB_WANTS_CANCELLEDが送信されると、サーバーはクライアントに、委任の可用性を通知する約束がCB_WANTS_CANCELLEDの前に発生したためにカバーされるかどうかを明確にする必要がある場合があります。 CB_WANTS_CANCELLED。この場合、対象外でした。サーバーは、関連するCB_SEQUENCE内の参照呼び出しのリストに適切な要求を入れることにより、この区別を行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
20.11. Operation 13: CB_NOTIFY_LOCK - Notify Client of Possible Lock Availability
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
20.11. 操作13：CB_NOTIFY_LOCK-可能なロックの可用性をクライアントに通知
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-11-1--ARGUMENT">
20.11.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.11.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_NOTIFY_LOCK4args {
       nfs_fh4     cnla_fh;
       lock_owner4 cnla_lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-11-2--RESULT">
20.11.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.11.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_NOTIFY_LOCK4res {
           nfsstat4        cnlr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-11-3--DESCRIPTION">
20.11.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.11.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server can use this operation to indicate that a byte-range lock for the given file and lock-owner, previously requested by the client via an unsuccessful LOCK operation, might be available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはこの操作を使用して、以前に失敗したLOCK操作を介してクライアントによって要求された、指定されたファイルとロック所有者のバイト範囲ロックが使用可能であることを示すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This callback is meant to be used by servers to help reduce the latency of blocking locks in the case where they recognize that a client that has been polling for a blocking byte-range lock may now be able to acquire the lock. If the server supports this callback for a given file, it MUST set the OPEN4_RESULT_MAY_NOTIFY_LOCK flag when responding to successful opens for that file. This does not commit the server to the use of CB_NOTIFY_LOCK, but the client may use this as a hint to decide how frequently to poll for locks derived from that open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このコールバックは、ブロッキングバイト範囲ロックをポーリングしていたクライアントがロックを取得できるようになったことをサーバーが認識した場合に、ブロッキングロックの待機時間を短縮するためにサーバーが使用することを目的としています。サーバーが特定のファイルに対してこのコールバックをサポートしている場合、そのファイルの正常なオープンに応答するときに、OPEN4_RESULT_MAY_NOTIFY_LOCKフラグを設定する必要があります。これはサーバーにCB_NOTIFY_LOCKの使用をコミットしませんが、クライアントはこれをヒントとして使用して、そのオープンから派生したロックをポーリングする頻度を決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an OPEN operation results in an upgrade, in which the stateid returned has an &#34;other&#34; value matching that of a stateid already allocated, with a new &#34;seqid&#34; indicating a change in the lock being represented, then the value of the OPEN4_RESULT_MAY_NOTIFY_LOCK flag when responding to that new OPEN controls handling from that point going forward. When parallel OPENs are done on the same file and open-owner, the ordering of the &#34;seqid&#34; fields of the returned stateids (subject to wraparound) are to be used to select the controlling value of the OPEN4_RESULT_MAY_NOTIFY_LOCK flag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN操作の結果、アップグレードが発生し、返されたstateidがすでに割り当てられているstateidの値と一致する「その他」の値を持ち、新しい「seqid」が表されているロックの変更を示している場合、OPEN4_RESULT_MAY_NOTIFY_LOCKフラグの値その新しいOPENに応答すると、その時点からの処理が制御されます。同じファイルとopen-ownerで並列OPENが行われる場合、返されたステートID（ラップアラウンドの対象）の「seqid」フィールドの順序を使用して、OPEN4_RESULT_MAY_NOTIFY_LOCKフラグの制御値を選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-11-4--IMPLEMENTATION">
20.11.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.11.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MUST NOT grant the byte-range lock to the client unless and until it receives a LOCK operation from the client. Similarly, the client receiving this callback cannot assume that it now has the lock or that a subsequent LOCK operation for the lock will be successful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、クライアントからLOCK操作を受信しない限り、クライアントにバイト範囲ロックを許可してはなりません（MUST NOT）。同様に、このコールバックを受信するクライアントは、現在ロックがあること、またはロックに対する後続のLOCK操作が成功することを想定できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server is not required to implement this callback, and even if it does, it is not required to use it in any particular case. Therefore, the client must still rely on polling for blocking locks, as described in Section 9.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはこのコールバックを実装する必要はありません。実装する場合でも、特定のケースで使用する必要はありません。したがって、クライアントは、セクション9.6で説明されているように、ブロックロックのポーリングに依拠する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, the client is not required to implement this callback, and even it does, is still free to ignore it. Therefore, the server MUST NOT assume that the client will act based on the callback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、クライアントはこのコールバックを実装する必要はありません。実装されていても、自由に無視できます。したがって、サーバーは、クライアントがコールバックに基づいて動作することを想定してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
20.12. Operation 14: CB_NOTIFY_DEVICEID - Notify Client of Device ID Changes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
20.12. 操作14：CB_NOTIFY_DEVICEID-デバイスIDの変更をクライアントに通知
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-12-1--ARGUMENT">
20.12.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.12.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Device notification types.
    */
   enum notify_deviceid_type4 {
           NOTIFY_DEVICEID4_CHANGE = 1,
           NOTIFY_DEVICEID4_DELETE = 2
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* For NOTIFY4_DEVICEID4_DELETE */
   struct notify_deviceid_delete4 {
           layouttype4     ndd_layouttype;
           deviceid4       ndd_deviceid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* For NOTIFY4_DEVICEID4_CHANGE */
   struct notify_deviceid_change4 {
           layouttype4     ndc_layouttype;
           deviceid4       ndc_deviceid;
           bool            ndc_immediate;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_NOTIFY_DEVICEID4args {
           notify4 cnda_changes&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-12-2--RESULT">
20.12.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.12.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_NOTIFY_DEVICEID4res {
           nfsstat4        cndr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-12-3--DESCRIPTION">
20.12.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.12.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_NOTIFY_DEVICEID operation is used by the server to send notifications to clients about changes to pNFS device IDs. The registration of device ID notifications is optional and is done via GETDEVICEINFO. These notifications are sent over the backchannel once the original request has been processed on the server. The server will send an array of notifications, cnda_changes, as a list of pairs of bitmaps and values. See Section 3.3.7 for a description of how NFSv4.1 bitmaps work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはCB_NOTIFY_DEVICEID操作を使用して、pNFSデバイスIDの変更に関する通知をクライアントに送信します。デバイスID通知の登録はオプションであり、GETDEVICEINFOを介して行われます。これらの通知は、元の要求がサーバーで処理されると、バックチャネルを介して送信されます。サーバーは、ビットマップと値のペアのリストとして、通知の配列cnda_changesを送信します。 NFSv4.1ビットマップがどのように機能するかについては、セクション3.3.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with CB_NOTIFY (Section 20.4.3), it is possible the server has more notifications than can fit in a CB_COMPOUND, thus requiring multiple CB_COMPOUNDs. Unlike CB_NOTIFY, serialization is not an issue because unlike directory entries, device IDs cannot be re-used after being deleted (Section 12.2.10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_NOTIFY（セクション20.4.3）と同様に、サーバーにはCB_COMPOUNDに収まらないほど多くの通知があり、複数のCB_COMPOUNDが必要になる可能性があります。 CB_NOTIFYとは異なり、ディレクトリエントリとは異なり、デバイスIDは削除された後は再利用できません（セクション12.2.10）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All device ID notifications contain a device ID and a layout type. The layout type is necessary because two different layout types can share the same device ID, and the common device ID can have completely different mappings for each layout type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのデバイスID通知には、デバイスIDとレイアウトタイプが含まれています。 2つの異なるレイアウトタイプが同じデバイスIDを共有でき、共通のデバイスIDが各レイアウトタイプに対して完全に異なるマッピングを持つ可能性があるため、レイアウトタイプが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server will send the following notifications:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは次の通知を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTIFY_DEVICEID4_CHANGE A previously provided device-ID-to-device-address mapping has changed and the client uses GETDEVICEINFO to obtain the updated mapping. The notification is encoded in a value of data type notify_deviceid_change4. This data type also contains a boolean field, ndc_immediate, which if TRUE indicates that the change will be enforced immediately, and so the client might not be able to complete any pending I/O to the device ID. If ndc_immediate is FALSE, then for an indefinite time, the client can complete pending I/O. After pending I/O is complete, the client SHOULD get the new device-ID-to-device-address mappings before sending new I/O requests to the storage devices addressed by the device ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTIFY_DEVICEID4_CHANGE以前に提供されたデバイスIDからデバイスアドレスへのマッピングが変更され、クライアントはGETDEVICEINFOを使用して更新されたマッピングを取得します。通知は、データ型notify_deviceid_change4の値にエンコードされます。このデータ型には、ブールフィールドndc_immediateも含まれています。これは、TRUEが変更がすぐに適用されることを示しているため、クライアントがデバイスIDへの保留中のI / Oを完了できない場合があります。 ndc_immediateがFALSEの場合、無期限にクライアントは保留中のI / Oを完了することができます。保留中のI / Oが完了した後、クライアントは、デバイスIDでアドレス指定されたストレージデバイスに新しいI / O要求を送信する前に、新しいデバイスIDからデバイスアドレスへのマッピングを取得する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTIFY4_DEVICEID_DELETE Deletes a device ID from the mappings. This notification MUST NOT be sent if the client has a layout that refers to the device ID. In other words, if the server is sending a delete device ID notification, one of the following is true for layouts associated with the layout type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTIFY4_DEVICEID_DELETEマッピングからデバイスIDを削除します。クライアントがデバイスIDを参照するレイアウトを持っている場合、この通知を送信してはなりません（MUST NOT）。つまり、サーバーがデバイスIDの削除通知を送信している場合、レイアウトタイプに関連付けられているレイアウトには、次のいずれかが当てはまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The client never had a layout referring to that device ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントは、そのデバイスIDを参照するレイアウトを持っていませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The client has returned all layouts referring to that device ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* クライアントは、そのデバイスIDを参照するすべてのレイアウトを返しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The server has revoked all layouts referring to that device ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* サーバーは、そのデバイスIDを参照するすべてのレイアウトを取り消しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The notification is encoded in a value of data type notify_deviceid_delete4. After a server deletes a device ID, it MUST NOT reuse that device ID for the same layout type until the client ID is deleted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
通知は、データ型notify_deviceid_delete4の値にエンコードされます。サーバーがデバイスIDを削除した後、クライアントIDが削除されるまで、同じレイアウトタイプにそのデバイスIDを再利用してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-13--Operation-10044-CBILLEGAL---Illegal-Callback-Operation">
20.13. Operation 10044: CB_ILLEGAL - Illegal Callback Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.13. 操作10044：CB_ILLEGAL-不正なコールバック操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-13-1--ARGUMENT">
20.13.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.13.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
void;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-13-2--RESULT">
20.13.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.13.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * CB_ILLEGAL: Response for illegal operation numbers
    */
   struct CB_ILLEGAL4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-13-3--DESCRIPTION">
20.13.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.13.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is a placeholder for encoding a result to handle the case of the server sending an operation code within CB_COMPOUND that is not defined in the NFSv4.1 specification. See Section 19.2.3 for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、NFSv4.1仕様で定義されていないCB_COMPOUND内で操作コードを送信するサーバーのケースを処理する結果をエンコードするためのプレースホルダーです。詳細については、19.2.3項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The status field of CB_ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_ILLEGAL4resのステータスフィールドはNFS4ERR_OP_ILLEGALに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="20-13-4--IMPLEMENTATION">
20.13.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.13.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A server will probably not send an operation with code OP_CB_ILLEGAL, but if it does, the response will be CB_ILLEGAL4res just as it would be with any other invalid operation code. Note that if the client gets an illegal operation code that is not OP_ILLEGAL, and if the client checks for legal operation codes during the XDR decode phase, then an instance of data type CB_ILLEGAL4res will not be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
サーバーはおそらくコードOP_CB_ILLEGALの操作を送信しませんが、送信した場合、応答は他の無効な操作コードの場合と同様にCB_ILLEGAL4resになります。クライアントがOP_ILLEGALではない不正なオペレーションコードを取得した場合、およびクライアントがXDRデコードフェーズ中に正当なオペレーションコードをチェックした場合、データ型CB_ILLEGAL4resのインスタンスは返されないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="21--Security-Considerations">
21. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Historically, the authentication model of NFS was based on the entire machine being the NFS client, with the NFS server trusting the NFS client to authenticate the end-user. The NFS server in turn shared its files only to specific clients, as identified by the client&#39;s source network address. Given this model, the AUTH_SYS RPC security flavor simply identified the end-user using the client to the NFS server. When processing NFS responses, the client ensured that the responses came from the same network address and port number to which the request was sent. While such a model is easy to implement and simple to deploy and use, it is unsafe. Thus, NFSv4.1 implementations are REQUIRED to support a security model that uses end-to-end authentication, where an end-user on a client mutually authenticates (via cryptographic schemes that do not expose passwords or keys in the clear on the network) to a principal on an NFS server. Consideration is also given to the integrity and privacy of NFS requests and responses. The issues of end-to-end mutual authentication, integrity, and privacy are discussed in Section 2.2.1.1.1. There are specific considerations when using Kerberos V5 as described in Section 2.2.1.1.1.2.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
歴史的に、NFSの認証モデルは、マシン全体がNFSクライアントであることに基づいており、NFSサーバーはNFSクライアントを信頼してエンドユーザーを認証していました。 NFSサーバーは、クライアントのソースネットワークアドレスで識別されるように、特定のクライアントのみにファイルを共有しました。このモデルを前提として、AUTH_SYS RPCセキュリティフレーバーは、NFSサーバーに対してクライアントを使用するエンドユーザーを単純に識別しました。 NFS応答を処理するとき、クライアントは、要求が送信されたのと同じネットワークアドレスとポート番号から応答が送信されることを確認しました。このようなモデルは実装が簡単で、展開と使用が簡単ですが、安全ではありません。したがって、NFSv4.1実装は、クライアントのエンドユーザーが相互に認証するエンドツーエンド認証を使用するセキュリティモデルをサポートするために必要です（ネットワーク上でパスワードまたはキーを平文で公開しない暗号化スキームを介して） NFSサーバー上のプリンシパルに。 NFSの要求と応答の整合性とプライバシーについても考慮されます。エンドツーエンドの相互認証、整合性、およびプライバシーの問題については、2.2.1.1.1項で説明します。セクション2.2.1.1.1.2.1.1で説明されているように、Kerberos V5を使用する場合は特定の考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that being REQUIRED to implement does not mean REQUIRED to use; AUTH_SYS can be used by NFSv4.1 clients and servers. However, AUTH_SYS is merely an OPTIONAL security flavor in NFSv4.1, and so interoperability via AUTH_SYS is not assured.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装する必要があるということは、使用する必要があるという意味ではないことに注意してください。 AUTH_SYSは、NFSv4.1クライアントおよびサーバーで使用できます。ただし、AUTH_SYSはNFSv4.1の単なるオプションのセキュリティフレーバーであるため、AUTH_SYSを介した相互運用性は保証されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For reasons of reduced administration overhead, better performance, and/or reduction of CPU utilization, users of NFSv4.1 implementations might decline to use security mechanisms that enable integrity protection on each remote procedure call and response. The use of mechanisms without integrity leaves the user vulnerable to a man-in-the-middle of the NFS client and server that modifies the RPC request and/or the response. While implementations are free to provide the option to use weaker security mechanisms, there are three operations in particular that warrant the implementation overriding user choices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
管理オーバーヘッドの削減、パフォーマンスの向上、および/またはCPU使用率の削減の理由により、NFSv4.1実装のユーザーは、各リモートプロシージャコールと応答で整合性保護を可能にするセキュリティメカニズムの使用を拒否する場合があります。整合性のないメカニズムを使用すると、RPC要求や応答を変更するNFSクライアントおよびサーバーの中間者に対して脆弱になります。実装はより弱いセキュリティメカニズムを使用するオプションを自由に提供できますが、特にユーザーの選択を上書きする実装を保証する3つの操作があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 o The first two such operations are SECINFO and SECINFO_NO_NAME. It is RECOMMENDED that the client send both operations such that they are protected with a security flavor that has integrity protection, such as RPCSEC_GSS with either the rpc_gss_svc_integrity or rpc_gss_svc_privacy service. Without integrity protection encapsulating SECINFO and SECINFO_NO_NAME and their results, a man-in-the-middle could modify results such that the client might select a weaker algorithm in the set allowed by the server, making the client and/or server vulnerable to further attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
oそのような最初の2つの操作は、SECINFOおよびSECINFO_NO_NAMEです。クライアントは、rpc_gss_svc_integrityまたはrpc_gss_svc_privacyサービスのいずれかを使用したRPCSEC_GSSなどの整合性保護を備えたセキュリティフレーバーで保護されるように、両方の操作を送信することをお勧めします。 SECINFOおよびSECINFO_NO_NAMEとそれらの結果をカプセル化する整合性保護がないと、中間者が結果を変更して、クライアントがサーバーによって許可されたセットでより弱いアルゴリズムを選択し、クライアントやサーバーがさらなる攻撃に対して脆弱になる可能性があります。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The third operation that SHOULD use integrity protection is any GETATTR for the fs_locations and fs_locations_info attributes, in order to mitigate the severity of a man-in-the-middle attack. The attack has two steps. First the attacker modifies the unprotected results of some operation to return NFS4ERR_MOVED. Second, when the client follows up with a GETATTR for the fs_locations or fs_locations_info attributes, the attacker modifies the results to cause the client to migrate its traffic to a server controlled by the attacker. With integrity protection, this attack is mitigated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 整合性保護を使用する必要がある3番目の操作は、中間者攻撃の重大度を軽減するために、fs_locationsおよびfs_locations_info属性のGETATTRです。攻撃には2つのステップがあります。まず、攻撃者は何らかの操作の保護されていない結果を変更して、NFS4ERR_MOVEDを返します。次に、クライアントがfs_locationsまたはfs_locations_info属性のGETATTRをフォローアップすると、攻撃者は結果を変更して、攻撃者が制御するサーバーにクライアントにトラフィックを移行させます。整合性保護により、この攻撃は軽減されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Relative to previous NFS versions, NFSv4.1 has additional security considerations for pNFS (see Sections 12.9 and 13.12), locking and session state (see Section 2.10.8.3), and state recovery during grace period (see Section 8.4.2.1.1). With respect to locking and session state, if SP4_SSV state protection is being used, Section 2.10.10 has specific security considerations for the NFSv4.1 client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のNFSバージョンと比較して、NFSv4.1には、pNFS（セクション12.9および13.12を参照）、ロックおよびセッション状態（セクション2.10.8.3を参照）、および猶予期間中の状態回復（セクション8.4.2.1.1を参照）に関する追加のセキュリティ考慮事項があります。 。ロックおよびセッション状態に関して、SP4_SSV状態保護が使用されている場合、セクション2.10.10には、NFSv4.1クライアントおよびサーバーに関する特定のセキュリティ上の考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22--IANA-Considerations">
22. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22. IANAに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section uses terms that are defined in [55].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、[55]で定義されている用語を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-1--Named-Attribute-Definitions">
22.1. Named Attribute Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.1. 名前付き属性の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA created a registry called the &#34;NFSv4 Named Attribute Definitions Registry&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは「NFSv4名前付き属性定義レジストリ」と呼ばれるレジストリを作成しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 protocol supports the association of a file with zero or more named attributes. The namespace identifiers for these attributes are defined as string names. The protocol does not define the specific assignment of the namespace for these file attributes. The IANA registry promotes interoperability where common interests exist. While application developers are allowed to define and use attributes as needed, they are encouraged to register the attributes with IANA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1プロトコルは、0個以上の名前付き属性を持つファイルの関連付けをサポートします。これらの属性の名前空間識別子は、文字列名として定義されます。プロトコルは、これらのファイル属性の名前空間の特定の割り当てを定義していません。 IANAレジストリは、共通の利益が存在する場合の相互運用性を促進します。アプリケーション開発者は必要に応じて属性を定義して使用することができますが、IANAに属性を登録することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Such registered named attributes are presumed to apply to all minor versions of NFSv4, including those defined subsequently to the registration. If the named attribute is intended to be limited to specific minor versions, this will be clearly stated in the registry&#39;s assignment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような登録された名前付き属性は、登録後に定義されたものを含め、NFSv4のすべてのマイナーバージョンに適用されると想定されています。名前付き属性が特定のマイナーバージョンに限定されることが意図されている場合、これはレジストリの割り当てで明確に述べられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All assignments to the registry are made on a First Come First Served basis, per Section 4.1 of [55]. The policy for each assignment is Specification Required, per Section 4.1 of [55].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリへのすべての割り当ては、[55]のセクション4.1に従って、先着順で行われます。各割り当てのポリシーは、[55]のセクション4.1に記載の仕様が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Under the NFSv4.1 specification, the name of a named attribute can in theory be up to 2^32 - 1 bytes in length, but in practice NFSv4.1 clients and servers will be unable to handle a string that long. IANA should reject any assignment request with a named attribute that exceeds 128 UTF-8 characters. To give the IESG the flexibility to set up bases of assignment of Experimental Use and Standards Action, the prefixes of &#34;EXPE&#34; and &#34;STDS&#34; are Reserved. The named attribute with a zero-length name is Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1仕様では、名前付き属性の名前は理論的には最大2 ^ 32-1バイトですが、実際にはNFSv4.1クライアントとサーバーはその長い文字列を処理できません。 IANAは、128 UTF-8文字を超える名前付き属性を持つ割り当て要求を拒否する必要があります。 IESGに実験的使用と標準アクションの割り当てのベースを設定する柔軟性を与えるために、「EXPE」と「STDS」のプレフィックスは予約されています。長さがゼロの名前付きの名前付き属性は予約済みです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The prefix &#34;PRIV&#34; is designated for Private Use. A site that wants to make use of unregistered named attributes without risk of conflicting with an assignment in IANA&#39;s registry should use the prefix &#34;PRIV&#34; in all of its named attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接頭辞「PRIV」は私的使用に指定されています。 IANAのレジストリでの割り当てと競合するリスクなしに未登録の名前付き属性を利用したいサイトは、すべての名前付き属性でプレフィックス「PRIV」を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because some NFSv4.1 clients and servers have case-insensitive semantics, the fifteen additional lower case and mixed case permutations of each of &#34;EXPE&#34;, &#34;PRIV&#34;, and &#34;STDS&#34; are Reserved (e.g., &#34;expe&#34;, &#34;expE&#34;, &#34;exPe&#34;, etc. are Reserved). Similarly, IANA must not allow two assignments that would conflict if both named attributes were converted to a common case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のNFSv4.1クライアントとサーバーは大文字と小文字を区別しないセマンティクスを持っているため、「EXPE」、「PRIV」、および「STDS」のそれぞれの15の追加の小文字と大文字と小文字の組み合わせは予約されています（たとえば、「expe」、「expE」 、「exPe」などは予約済みです）。同様に、IANAは、両方の名前付き属性が共通のケースに変換された場合に競合する2つの割り当てを許可してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registry of named attributes is a list of assignments, each containing three fields for each assignment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付き属性のレジストリは、割り当てのリストであり、割り当てごとに3つのフィールドが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. A US-ASCII string name that is the actual name of the attribute. This name must be unique. This string name can be 1 to 128 UTF-8 characters long.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 属性の実際の名前であるUS-ASCII文字列名。この名前は一意である必要があります。この文字列名には、1〜128文字のUTF-8文字を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. A reference to the specification of the named attribute. The reference can consume up to 256 bytes (or more if IANA permits).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 名前付き属性の仕様への参照。参照は最大256バイト（IANAが許可する場合はそれ以上）を消費する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The point of contact of the registrant. The point of contact can consume up to 256 bytes (or more if IANA permits).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 登録者の連絡先。連絡先は最大256バイト（IANAが許可する場合はそれ以上）を消費する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-1-1--Initial-Registry">
22.1.1. Initial Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.1.1. 初期レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is no initial registry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期レジストリはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-1-2--Updating-Registrations">
22.1.2. Updating Registrations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.1.2. 登録の更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registrant is always permitted to update the point of contact field. Any other change will require Expert Review or IESG Approval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録者は、連絡先フィールドの更新を常に許可されています。その他の変更には、エキスパートレビューまたはIESG承認が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-2--Device-ID-Notifications">
22.2. Device ID Notifications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.2. デバイスID通知
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA created a registry called the &#34;NFSv4 Device ID Notifications Registry&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは「NFSv4デバイスID通知レジストリ」と呼ばれるレジストリを作成しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The potential exists for new notification types to be added to the CB_NOTIFY_DEVICEID operation (see Section 20.12). This can be done via changes to the operations that register notifications, or by adding new operations to NFSv4. This requires a new minor version of NFSv4, and requires a Standards Track document from the IETF. Another way to add a notification is to specify a new layout type (see Section 22.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい通知タイプがCB_NOTIFY_DEVICEID操作に追加される可能性があります（セクション20.12を参照）。これは、通知を登録する操作を変更するか、NFSv4に新しい操作を追加することで実行できます。これには、NFSv4の新しいマイナーバージョンが必要であり、IETFのStandards Trackドキュメントが必要です。通知を追加するもう1つの方法は、新しいレイアウトタイプを指定することです（セクション22.4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hence, all assignments to the registry are made on a Standards Action basis per Section 4.1 of [55], with Expert Review required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、レジストリへのすべての割り当ては、[55]のセクション4.1に従って標準アクションベースで行われ、エキスパートレビューが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registry is a list of assignments, each containing five fields per assignment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリは割り当てのリストであり、割り当てごとに5つのフィールドが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The name of the notification type. This name must have the prefix &#34;NOTIFY_DEVICEID4_&#34;. This name must be unique.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 通知タイプの名前。この名前には、接頭辞「NOTIFY_DEVICEID4_」が必要です。この名前は一意である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The value of the notification. IANA will assign this number, and the request from the registrant will use TBD1 instead of an actual value. IANA MUST use a whole number that can be no higher than 2^32-1, and should be the next available value. The value assigned must be unique. A Designated Expert must be used to ensure that when the name of the notification type and its value are added to the NFSv4.1 notify_deviceid_type4 enumerated data type in the NFSv4.1 XDR description ([13]), the result continues to be a valid XDR description.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 通知の値。 IANAがこの番号を割り当て、登録者からの要求は実際の値の代わりにTBD1を使用します。 IANAは2 ^ 32-1以下の整数を使用する必要があり、次に使用可能な値である必要があります。割り当てられる値は一意である必要があります。 Designated Expertを使用して、通知タイプの名前とその値がNFSv4.1 XDR記述（[13]）のNFSv4.1 notify_deviceid_type4列挙データタイプに追加されても、結果が引き続き有効であることを確認する必要があります。 XDRの説明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The Standards Track RFC(s) that describe the notification. If the RFC(s) have not yet been published, the registrant will use RFCTBD2, RFCTBD3, etc. instead of an actual RFC number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 通知を説明する標準トラックRFC。 RFCがまだ公開されていない場合、登録者は実際のRFC番号の代わりにRFCTBD2、RFCTBD3などを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. How the RFC introduces the notification. This is indicated by a single US-ASCII value. If the value is N, it means a minor revision to the NFSv4 protocol. If the value is L, it means a new pNFS layout type. Other values can be used with IESG Approval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. RFCによる通知の導入方法。これは、単一のUS-ASCII値によって示されます。値がNの場合、NFSv4プロトコルのマイナーリビジョンを意味します。値がLの場合、それは新しいpNFSレイアウトタイプを意味します。 IESG承認では他の値を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. The minor versions of NFSv4 that are allowed to use the notification. While these are numeric values, IANA will not allocate and assign them; the author of the relevant RFCs with IESG Approval assigns these numbers. Each time there is a new minor version of NFSv4 approved, a Designated Expert should review the registry to make recommended updates as needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 通知の使用が許可されているNFSv4のマイナーバージョン。これらは数値ですが、IANAはそれらを割り当てたり割り当てたりしません。 IESG承認を伴う関連RFCの作成者は、これらの番号を割り当てます。 NFSv4の新しいマイナーバージョンが承認されるたびに、Designated Expertはレジストリを確認し、必要に応じて推奨される更新を行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-2-1--Initial-Registry">
22.2.1. Initial Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.2.1. 初期レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial registry is in Table 16. Note that the next available value is zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期レジストリーは表16にあります。次に使用可能な値はゼロであることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------------------+-------+---------+-----+----------------+
   | Notification Name       | Value | RFC     | How | Minor Versions |
   +-------------------------+-------+---------+-----+----------------+
   | NOTIFY_DEVICEID4_CHANGE | 1     | RFC5661 | N   | 1              |
   | NOTIFY_DEVICEID4_DELETE | 2     | RFC5661 | N   | 1              |
   +-------------------------+-------+---------+-----+----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
Table 16: Initial Device ID Notification Assignments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
表16：初期のデバイスID通知の割り当て
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-2-2--Updating-Registrations">
22.2.2. Updating Registrations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.2.2. 登録の更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The update of a registration will require IESG Approval on the advice of a Designated Expert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録の更新には、指定専門家の助言によるIESG承認が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-3--Object-Recall-Types">
22.3. Object Recall Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.3. オブジェクト呼び出しタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA created a registry called the &#34;NFSv4 Recallable Object Types Registry&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは「NFSv4 Recallable Object Types Registry」と呼ばれるレジストリを作成しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The potential exists for new object types to be added to the CB_RECALL_ANY operation (see Section 20.6). This can be done via changes to the operations that add recallable types, or by adding new operations to NFSv4. This requires a new minor version of NFSv4, and requires a Standards Track document from IETF. Another way to add a new recallable object is to specify a new layout type (see Section 22.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいオブジェクトタイプがCB_RECALL_ANY操作に追加される可能性があります（セクション20.6を参照）。これは、リコール可能なタイプを追加する操作を変更するか、NFSv4に新しい操作を追加することで実行できます。これには、NFSv4の新しいマイナーバージョンが必要であり、IETFのStandards Trackドキュメントが必要です。新しいリコール可能なオブジェクトを追加するもう1つの方法は、新しいレイアウトタイプを指定することです（22.4項を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All assignments to the registry are made on a Standards Action basis per Section 4.1 of [55], with Expert Review required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリへのすべての割り当ては、[55]のセクション4.1に従って標準アクションベースで行われ、エキスパートレビューが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recallable object types are 32-bit unsigned numbers. There are no Reserved values. Values in the range 12 through 15, inclusive, are designated for Private Use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
呼び出し可能なオブジェクトタイプは、32ビットの符号なし数値です。予約値はありません。 12から15までの範囲の値は、私用に指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registry is a list of assignments, each containing five fields per assignment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリは割り当てのリストであり、割り当てごとに5つのフィールドが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The name of the recallable object type. This name must have the prefix &#34;RCA4_TYPE_MASK_&#34;. The name must be unique.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 再呼び出し可能なオブジェクトタイプの名前。この名前には、接頭辞「RCA4_TYPE_MASK_」が必要です。名前は一意である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 2. The value of the recallable object type. IANA will assign this number, and the request from the registrant will use TBD1 instead of an actual value. IANA MUST use a whole number that can be no higher than 2^32-1, and should be the next available value. The value must be unique. A Designated Expert must be used to ensure that when the name of the recallable type and its value are added to the NFSv4 XDR description [13], the result continues to be a valid XDR description.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.再呼び出し可能なオブジェクトタイプの値。 IANAがこの番号を割り当て、登録者からの要求は実際の値の代わりにTBD1を使用します。 IANAは2 ^ 32-1以下の整数を使用する必要があり、次に使用可能な値である必要があります。値は一意である必要があります。 Designable Expertを使用して、再呼び出し可能なタイプの名前とその値がNFSv4 XDR記述[13]に追加されても、結果が引き続き有効なXDR記述であることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The Standards Track RFC(s) that describe the recallable object type. If the RFC(s) have not yet been published, the registrant will use RFCTBD2, RFCTBD3, etc. instead of an actual RFC number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 再呼び出し可能なオブジェクトタイプを説明する標準トラックRFC。 RFCがまだ公開されていない場合、登録者は実際のRFC番号の代わりにRFCTBD2、RFCTBD3などを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. How the RFC introduces the recallable object type. This is indicated by a single US-ASCII value. If the value is N, it means a minor revision to the NFSv4 protocol. If the value is L, it means a new pNFS layout type. Other values can be used with IESG Approval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. RFCがリコール可能なオブジェクトタイプを導入する方法。これは、単一のUS-ASCII値によって示されます。値がNの場合、NFSv4プロトコルのマイナーリビジョンを意味します。値がLの場合、それは新しいpNFSレイアウトタイプを意味します。 IESG承認では他の値を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. The minor versions of NFSv4 that are allowed to use the recallable object type. While these are numeric values, IANA will not allocate and assign them; the author of the relevant RFCs with IESG Approval assigns these numbers. Each time there is a new minor version of NFSv4 approved, a Designated Expert should review the registry to make recommended updates as needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 再呼び出し可能なオブジェクトタイプを使用できるNFSv4のマイナーバージョン。これらは数値ですが、IANAはそれらを割り当てたり割り当てたりしません。 IESG承認を伴う関連RFCの作成者は、これらの番号を割り当てます。 NFSv4の新しいマイナーバージョンが承認されるたびに、Designated Expertはレジストリを確認し、必要に応じて推奨される更新を行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-3-1--Initial-Registry">
22.3.1. Initial Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.3.1. 初期レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial registry is in Table 17. Note that the next available value is five.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期レジストリは表17にあります。次に使用可能な値は5であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------------------------+-------+--------+-----+------------+
   | Recallable Object Type Name   | Value | RFC    | How | Minor      |
   |                               |       |        |     | Versions   |
   +-------------------------------+-------+--------+-----+------------+
   | RCA4_TYPE_MASK_RDATA_DLG      | 0     | RFC    | N   | 1          |
   |                               |       | 5661   |     |            |
   | RCA4_TYPE_MASK_WDATA_DLG      | 1     | RFC    | N   | 1          |
   |                               |       | 5661   |     |            |
   | RCA4_TYPE_MASK_DIR_DLG        | 2     | RFC    | N   | 1          |
   |                               |       | 5661   |     |            |
   | RCA4_TYPE_MASK_FILE_LAYOUT    | 3     | RFC    | N   | 1          |
   |                               |       | 5661   |     |            |
   | RCA4_TYPE_MASK_BLK_LAYOUT     | 4     | RFC    | L   | 1          |
   |                               |       | 5661   |     |            |
   | RCA4_TYPE_MASK_OBJ_LAYOUT_MIN | 8     | RFC    | L   | 1          |
   |                               |       | 5661   |     |            |
   | RCA4_TYPE_MASK_OBJ_LAYOUT_MAX | 9     | RFC    | L   | 1          |
   |                               |       | 5661   |     |            |
   +-------------------------------+-------+--------+-----+------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
Table 17: Initial Recallable Object Type Assignments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
表17：呼び出し可能な初期オブジェクトタイプの割り当て
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-3-2--Updating-Registrations">
22.3.2. Updating Registrations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.3.2. 登録の更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The update of a registration will require IESG Approval on the advice of a Designated Expert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録の更新には、指定専門家の助言によるIESG承認が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-4--Layout-Types">
22.4. Layout Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.4. レイアウトの種類
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA created a registry called the &#34;pNFS Layout Types Registry&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは「pNFSレイアウトタイプレジストリ」と呼ばれるレジストリを作成しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All assignments to the registry are made on a Standards Action basis, with Expert Review required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリへのすべての割り当ては、エキスパートレビューが必要な標準アクションベースで行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Layout types are 32-bit numbers. The value zero is Reserved. Values in the range 0x80000000 to 0xFFFFFFFF inclusive are designated for Private Use. IANA will assign numbers from the range 0x00000001 to 0x7FFFFFFF inclusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトタイプは32ビットの数値です。値ゼロは予約済みです。 0x80000000から0xFFFFFFFFまでの範囲の値は、私用に指定されています。 IANAは0x00000001から0x7FFFFFFFまでの範囲の数値を割り当てます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registry is a list of assignments, each containing five fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリは、それぞれ5つのフィールドを含む割り当てのリストです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The name of the layout type. This name must have the prefix &#34;LAYOUT4_&#34;. The name must be unique.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. レイアウトタイプの名前。この名前には、接頭辞「LAYOUT4_」が必要です。名前は一意である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The value of the layout type. IANA will assign this number, and the request from the registrant will use TBD1 instead of an actual value. The value assigned must be unique. A Designated Expert must be used to ensure that when the name of the layout type and its value are added to the NFSv4.1 layouttype4 enumerated data type in the NFSv4.1 XDR description ([13]), the result continues to be a valid XDR description.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. レイアウトタイプの値。 IANAがこの番号を割り当て、登録者からの要求は実際の値の代わりにTBD1を使用します。割り当てられる値は一意である必要があります。 Designated Expertを使用して、レイアウトタイプの名前とその値がNFSv4.1 XDR記述（[13]）のNFSv4.1 layouttype4列挙データタイプに追加されても、結果が引き続き有効であることを確認する必要があります。 XDRの説明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The Standards Track RFC(s) that describe the notification. If the RFC(s) have not yet been published, the registrant will use RFCTBD2, RFCTBD3, etc. instead of an actual RFC number. Collectively, the RFC(s) must adhere to the guidelines listed in Section 22.4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 通知を説明する標準トラックRFC。 RFCがまだ公開されていない場合、登録者は実際のRFC番号の代わりにRFCTBD2、RFCTBD3などを使用します。集合的に、RFCはセクション22.4.3にリストされているガイドラインに準拠する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. How the RFC introduces the layout type. This is indicated by a single US-ASCII value. If the value is N, it means a minor revision to the NFSv4 protocol. If the value is L, it means a new pNFS layout type. Other values can be used with IESG Approval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. RFCがレイアウトタイプを導入する方法。これは、単一のUS-ASCII値によって示されます。値がNの場合、NFSv4プロトコルのマイナーリビジョンを意味します。値がLの場合、それは新しいpNFSレイアウトタイプを意味します。 IESG承認では他の値を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. The minor versions of NFSv4 that are allowed to use the notification. While these are numeric values, IANA will not allocate and assign them; the author of the relevant RFCs with IESG Approval assigns these numbers. Each time there is a new minor version of NFSv4 approved, a Designated Expert should review the registry to make recommended updates as needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 通知の使用が許可されているNFSv4のマイナーバージョン。これらは数値ですが、IANAはそれらを割り当てたり割り当てたりしません。 IESG承認を伴う関連RFCの作成者は、これらの番号を割り当てます。 NFSv4の新しいマイナーバージョンが承認されるたびに、Designated Expertはレジストリを確認し、必要に応じて推奨される更新を行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-4-1--Initial-Registry">
22.4.1. Initial Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.4.1. 初期レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial registry is in Table 18.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期レジストリは表18にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    +-----------------------+-------+----------+-----+----------------+
    | Layout Type Name      | Value | RFC      | How | Minor Versions |
    +-----------------------+-------+----------+-----+----------------+
    | LAYOUT4_NFSV4_1_FILES | 0x1   | RFC 5661 | N   | 1              |
    | LAYOUT4_OSD2_OBJECTS  | 0x2   | RFC 5664 | L   | 1              |
    | LAYOUT4_BLOCK_VOLUME  | 0x3   | RFC 5663 | L   | 1              |
    +-----------------------+-------+----------+-----+----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
Table 18: Initial Layout Type Assignments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
表18：初期レイアウトタイプの割り当て
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-4-2--Updating-Registrations">
22.4.2. Updating Registrations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.4.2. 登録の更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The update of a registration will require IESG Approval on the advice of a Designated Expert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録の更新には、指定専門家の助言によるIESG承認が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-4-3--Guidelines-for-Writing-Layout-Type-Specifications">
22.4.3. Guidelines for Writing Layout Type Specifications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.4.3. レイアウトタイプの仕様を記述するためのガイドライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The author of a new pNFS layout specification must follow these steps to obtain acceptance of the layout type as a Standards Track RFC:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいpNFSレイアウト仕様の作成者は、標準トラックRFCとしてのレイアウトタイプの承認を得るために、次の手順に従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The author devises the new layout specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 著者は新しいレイアウト仕様を考案します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The new layout type specification MUST, at a minimum:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 新しいレイアウトタイプの仕様は、最低限、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Define the contents of the layout-type-specific fields of the following data types:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* 次のデータ型のレイアウトタイプ固有のフィールドの内容を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ the da_addr_body field of the device_addr4 data type;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ device_addr4データ型のda_addr_bodyフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ the loh_body field of the layouthint4 data type;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ layouthint4データ型のloh_bodyフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ the loc_body field of layout_content4 data type (which in turn is the lo_content field of the layout4 data type);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ layout_content4データ型のloc_bodyフィールド（これは、layout4データ型のlo_contentフィールドです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ the lou_body field of the layoutupdate4 data type;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ layoutupdate4データ型のlou_bodyフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Describe or define the storage access protocol used to access the storage devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* ストレージデバイスへのアクセスに使用されるストレージアクセスプロトコルを説明または定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Describe whether revocation of layouts is supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* レイアウトの取り消しがサポートされているかどうかを説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* At a minimum, describe the methods of recovery from:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* 少なくとも、以下からの回復方法を説明してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
1. Failure and restart for client, server, storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
1. クライアント、サーバー、ストレージデバイスの障害と再起動。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
2. Lease expiration from perspective of the active client, server, storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
2. アクティブなクライアント、サーバー、ストレージデバイスから見たリースの有効期限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
3. Loss of layout state resulting in fencing of client access to storage devices (for an example, see Section 12.7.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
3. レイアウト状態が失われ、ストレージデバイスへのクライアントアクセスがフェンシングされる（例については、セクション12.7.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Include an IANA considerations section, which will in turn include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* IANAの考慮事項のセクションを含めます。セクションには次のものが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ A request to IANA for a new layout type per Section 22.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ セクション22.4に基づく新しいレイアウトタイプのIANAへのリクエスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ A list of requests to IANA for any new recallable object types for CB_RECALL_ANY; each entry is to be presented in the form described in Section 22.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ CB_RECALL_ANYの新しい再呼び出し可能なオブジェクトタイプに対するIANAへのリクエストのリスト。各エントリは、セクション22.3で説明されている形式で提示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ A list of requests to IANA for any new notification values for CB_NOTIFY_DEVICEID; each entry is to be presented in the form described in Section 22.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
+ CB_NOTIFY_DEVICEIDの新しい通知値に対するIANAへのリクエストのリスト。各エントリは、セクション22.2で説明されている形式で提示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Include a security considerations section. This section MUST explain how the NFSv4.1 authentication, authorization, and access-control models are preserved. That is, if a metadata server would restrict a READ or WRITE operation, how would pNFS via the layout similarly restrict a corresponding input or output operation?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* セキュリティに関する考慮事項のセクションを含めます。このセクションでは、NFSv4.1認証、承認、およびアクセス制御モデルがどのように保持されるかを説明する必要があります。つまり、メタデータサーバーが読み取りまたは書き込み操作を制限する場合、レイアウトを介したpNFSは、対応する入力または出力操作を同様に制限しますか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The author documents the new layout specification as an Internet-Draft.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 著者は、新しいレイアウト仕様をInternet-Draftとして文書化しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The author submits the Internet-Draft for review through the IETF standards process as defined in &#34;The Internet Standards Process-- Revision 3&#34; (BCP 9). The new layout specification will be submitted for eventual publication as a Standards Track RFC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 著者は、「インターネット標準プロセス-リビジョン3」（BCP 9）で定義されているIETF標準プロセスによるレビューのためにインターネットドラフトを提出します。新しいレイアウト仕様は、Standards Track RFCとして最終的に公開するために提出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. The layout specification progresses through the IETF standards process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. レイアウト仕様は、IETF標準プロセスを通じて進行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-5--Path-Variable-Definitions">
22.5. Path Variable Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.5. パス変数の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section deals with the IANA considerations associated with the variable substitution feature for location names as described in Section 11.10.3. As described there, variables subject to substitution consist of a domain name and a specific name within that domain, with the two separated by a colon. There are two sets of IANA considerations here:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、セクション11.10.3で説明されている場所名の変数置換機能に関連するIANAの考慮事項について説明します。そこで説明されているように、置換の対象となる変数は、ドメイン名とそのドメイン内の特定の名前で構成され、2つはコロンで区切られています。ここでは、IANAに関する2つの考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The list of variable names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 変数名のリスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. For each variable name, the list of possible values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 変数名ごとに、可能な値のリスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, there will be one registry for the list of variable names, and possibly one registry for listing the values of each variable name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、変数名のリスト用のレジストリが1つあり、各変数名の値をリストするためのレジストリが1つある可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-5-1--Path-Variables-Registry">
22.5.1. Path Variables Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.5.1. パス変数レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA created a registry called the &#34;NFSv4 Path Variables Registry&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは「NFSv4パス変数レジストリ」と呼ばれるレジストリを作成しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-5-1-1--Path-Variable-Values">
22.5.1.1. Path Variable Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.5.1.1. パス変数値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Variable names are of the form &#34;${&#34;, followed by a domain name, followed by a colon (&#34;:&#34;), followed by a domain-specific portion of the variable name, followed by &#34;}&#34;. When the domain name is &#34;ietf.org&#34;, all variables names must be registered with IANA on a Standards Action basis, with Expert Review required. Path variables with registered domain names neither part of nor equal to ietf.org are assigned on a Hierarchical Allocation basis (delegating to the domain owner) and thus of no concern to IANA, unless the domain owner chooses to register a variable name from his domain. If the domain owner chooses to do so, IANA will do so on a First Come First Serve basis. To accommodate registrants who do not have their own domain, IANA will accept requests to register variables with the prefix &#34;${FCFS.ietf.org:&#34; on a First Come First Served basis. Assignments on a First Come First Basis do not require Expert Review, unless the registrant also wants IANA to establish a registry for the values of the registered variable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
変数名は &#34;$ {&#34;、ドメイン名、コロン（ &#34;：&#34;）、変数名のドメイン固有の部分、 &#34;}&#34;の形式です。ドメイン名が「ietf.org」の場合、すべての変数名は標準アクションベースでIANAに登録する必要があり、エキスパートレビューが必要です。ドメイン名が自分のドメインから変数名を登録することを選択しない限り、ietf.orgの一部でもないドメイン名でもパス変数は階層的割り当てベース（ドメイン所有者に委任）で割り当てられるため、IANAには関係ありません。 。ドメイン所有者がそうすることを選択した場合、IANAは先着順で行います。独自のドメインを持たない登録者に対応するため、IANAは、先着順で接頭辞「$ {FCFS.ietf.org：」を付けて変数を登録する要求を受け入れます。登録者がIANAに登録された変数の値のレジストリを確立することも望まない限り、先着順の割り当てはエキスパートレビューを必要としません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registry is a list of assignments, each containing three fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリは割り当てのリストであり、それぞれに3つのフィールドが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The name of the variable. The name of this variable must start with a &#34;${&#34; followed by a registered domain name, followed by &#34;:&#34;, or it must start with &#34;${FCFS.ietf.org&#34;. The name must be no more than 64 UTF-8 characters long. The name must be unique.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 変数の名前。この変数の名前は、「$ {」で始まり、その後に登録済みドメイン名、「：」が続くか、または「$ {FCFS.ietf.org」で始まる必要があります。名前は、UTF-8文字で64文字以下にする必要があります。名前は一意である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. For assignments made on Standards Action basis, the Standards Track RFC(s) that describe the variable. If the RFC(s) have not yet been published, the registrant will use RFCTBD1, RFCTBD2, etc. instead of an actual RFC number. Note that the RFCs do not have to be a part of an NFS minor version. For assignments made on a First Come First Serve basis, an explanation (consuming no more than 1024 bytes, or more if IANA permits) of the purpose of the variable. A reference to the explanation can be substituted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 標準アクションベースで行われた割り当ての場合、変数を説明する標準トラックRFC。 RFCがまだ公開されていない場合、登録者は実際のRFC番号の代わりにRFCTBD1、RFCTBD2などを使用します。 RFCがNFSマイナーバージョンの一部である必要はないことに注意してください。先着順で行われる割り当ての場合、変数の目的の説明（1024バイト以下、またはIANAが許可する場合はそれ以上を消費）。説明への参照を置き換えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The point of contact, including an email address. The point of contact can consume up to 256 bytes (or more if IANA permits). For assignments made on a Standards Action basis, the point of contact is always IESG.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. メールアドレスを含む連絡先。連絡先は最大256バイト（IANAが許可する場合はそれ以上）を消費する可能性があります。標準アクションベースで行われた割り当ての場合、連絡先は常にIESGです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-5-1-1-1--Initial-Registry">
22.5.1.1.1. Initial Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.5.1.1.1. 初期レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial registry is in Table 19.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期レジストリは表19にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         +------------------------+----------+------------------+
         | Variable Name          | RFC      | Point of Contact |
         +------------------------+----------+------------------+
         | ${ietf.org:CPU_ARCH}   | RFC 5661 | IESG             |
         | ${ietf.org:OS_TYPE}    | RFC 5661 | IESG             |
         | ${ietf.org:OS_VERSION} | RFC 5661 | IESG             |
         +------------------------+----------+------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
Table 19: Initial List of Path Variables
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
表19：パス変数の初期リスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created registries for the values of the variable names ${ietf.org:CPU_ARCH} and ${ietf.org:OS_TYPE}. See Sections 22.5.2 and 22.5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、変数名$ {ietf.org:CPU_ARCH}および$ {ietf.org:OS_TYPE}の値のレジストリを作成しました。セクション22.5.2および22.5.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the values of the variable ${ietf.org:OS_VERSION}, no registry is needed as the specifics of the values of the variable will vary with the value of ${ietf.org:OS_TYPE}. Thus, values for ${ietf.org: OS_VERSION} are on a Hierarchical Allocation basis and are of no concern to IANA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変数$ {ietf.org:OS_VERSION}の値の場合、変数の値の詳細は$ {ietf.org:OS_TYPE}の値によって異なるため、レジストリは必要ありません。したがって、$ {ietf.org：OS_VERSION}の値は階層割り当てに基づいており、IANAには関係ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-5-1-1-2--Updating-Registrations">
22.5.1.1.2. Updating Registrations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.5.1.1.2. 登録の更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The update of an assignment made on a Standards Action basis will require IESG Approval on the advice of a Designated Expert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
標準アクションベースで行われた割り当ての更新には、指定専門家の助言によるIESG承認が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registrant can always update the point of contact of an assignment made on a First Come First Serve basis. Any other update will require Expert Review.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録者は、先着順で行われた割り当ての連絡先をいつでも更新できます。その他のアップデートにはエキスパートレビューが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-5-2--Values-for-the-ietf-orgCPUARCH-Variable">
22.5.2. Values for the ${ietf.org:CPU_ARCH} Variable
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.5.2. $ {ietf.org:CPU_ARCH}変数の値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA created a registry called the &#34;NFSv4 ${ietf.org:CPU_ARCH} Value Registry&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは「NFSv4 $ {ietf.org:CPU_ARCH} Value Registry」と呼ばれるレジストリを作成しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assignments to the registry are made on a First Come First Serve basis. The zero-length value of ${ietf.org:CPU_ARCH} is Reserved. Values with a prefix of &#34;PRIV&#34; are designated for Private Use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリへの割り当ては、先着順で行われます。 $ {ietf.org:CPU_ARCH}の長さがゼロの値は予約されています。接頭辞が「PRIV」の値は、私用に指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registry is a list of assignments, each containing three fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリは割り当てのリストであり、それぞれに3つのフィールドが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. A value of the ${ietf.org:CPU_ARCH} variable. The value must be 1 to 32 UTF-8 characters long. The value must be unique.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. $ {ietf.org:CPU_ARCH}変数の値。値は1から32文字のUTF-8文字でなければなりません。値は一意である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. An explanation (consuming no more than 1024 bytes, or more if IANA permits) of what CPU architecture the value denotes. A reference to the explanation can be substituted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 値が示すCPUアーキテクチャの説明（消費するのは1024バイト以下、IANAが許可する場合はそれ以上）。説明への参照を置き換えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The point of contact, including an email address. The point of contact can consume up to 256 bytes (or more if IANA permits).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. メールアドレスを含む連絡先。連絡先は最大256バイト（IANAが許可する場合はそれ以上）を消費する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-5-2-1--Initial-Registry">
22.5.2.1. Initial Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.5.2.1. 初期レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is no initial registry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期レジストリはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-5-2-2--Updating-Registrations">
22.5.2.2. Updating Registrations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.5.2.2. 登録の更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registrant is free to update the assignment, i.e., change the explanation and/or point-of-contact fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録者は割り当てを自由に更新できます。つまり、説明や連絡先フィールドを変更できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-5-3--Values-for-the-ietf-orgOSTYPE-Variable">
22.5.3. Values for the ${ietf.org:OS_TYPE} Variable
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.5.3. $ {ietf.org:OS_TYPE}変数の値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA created a registry called the &#34;NFSv4 ${ietf.org:OS_TYPE} Value Registry&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは「NFSv4 $ {ietf.org:OS_TYPE} Value Registry」と呼ばれるレジストリを作成しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assignments to the registry are made on a First Come First Serve basis. The zero-length value of ${ietf.org:OS_TYPE} is Reserved. Values with a prefix of &#34;PRIV&#34; are designated for Private Use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリへの割り当ては、先着順で行われます。 $ {ietf.org:OS_TYPE}の長さがゼロの値は予約されています。接頭辞が「PRIV」の値は、私用に指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registry is a list of assignments, each containing three fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリは割り当てのリストであり、それぞれに3つのフィールドが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. A value of the ${ietf.org:OS_TYPE} variable. The value must be 1 to 32 UTF-8 characters long. The value must be unique.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. $ {ietf.org:OS_TYPE}変数の値。値は1から32文字のUTF-8文字でなければなりません。値は一意である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. An explanation (consuming no more than 1024 bytes, or more if IANA permits) of what CPU architecture the value denotes. A reference to the explanation can be substituted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 値が示すCPUアーキテクチャの説明（消費するのは1024バイト以下、IANAが許可する場合はそれ以上）。説明への参照を置き換えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The point of contact, including an email address. The point of contact can consume up to 256 bytes (or more if IANA permits).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. メールアドレスを含む連絡先。連絡先は最大256バイト（IANAが許可する場合はそれ以上）を消費する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-5-3-1--Initial-Registry">
22.5.3.1. Initial Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.5.3.1. 初期レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is no initial registry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期レジストリはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="22-5-3-2--Updating-Registrations">
22.5.3.2. Updating Registrations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.5.3.2. 登録の更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registrant is free to update the assignment, i.e., change the explanation and/or point of contact fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録者は、割り当てを自由に更新できます。つまり、説明や連絡先フィールドを変更できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="23--References">
23. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
23. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="23-1--Normative-References">
23.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
23.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Bradner、S。、「RFCで使用して要件レベルを示すためのキーワード」、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Eisler, M., Ed., &#34;XDR: External Data Representation Standard&#34;, STD 67, RFC 4506, May 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Eisler、M。、編、「XDR：外部データ表現標準」、STD 67、RFC 4506、2006年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Thurlow, R., &#34;RPC: Remote Procedure Call Protocol Specification Version 2&#34;, RFC 5531, May 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Thurlow、R。、「RPC：リモートプロシージャコールプロトコル仕様バージョン2」、RFC 5531、2009年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] Eisler, M., Chiu, A., and L. Ling, &#34;RPCSEC_GSS Protocol Specification&#34;, RFC 2203, September 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] Eisler、M.、Chiu、A。、およびL. Ling、「RPCSEC_GSS Protocol Specification」、RFC 2203、1997年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Zhu, L., Jaganathan, K., and S. Hartman, &#34;The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism Version 2&#34;, RFC 4121, July 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Zhu、L.、Jaganathan、K。、およびS. Hartman、「Kerberosバージョン5 Generic Security Serviceアプリケーションプログラムインターフェイス（GSS-API）メカニズムバージョン2」、RFC 4121、2005年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] The Open Group, &#34;Section 3.191 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232&#34;, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] The Open Group、「Open Group Base Specifications Issue 6 IEEE Std 1003.1、2004 Edition、HTML Version（www.opengroup.org）、ISBN 1931624232のベース定義の第3章のセクション3.191」、2004年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Linn, J., &#34;Generic Security Service Application Program Interface Version 2, Update 1&#34;, RFC 2743, January 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Linn、J。、「Generic Security Service Application Program Interface Version 2、Update 1」、RFC 2743、2000年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] Talpey, T. and B. Callaghan, &#34;Remote Direct Memory Access Transport for Remote Procedure Call&#34;, RFC 5666, January 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] Talpey、T.およびB. Callaghan、「リモートプロシージャコール用のリモートダイレクトメモリアクセストランスポート」、RFC 5666、2010年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] Talpey, T. and B. Callaghan, &#34;Network File System (NFS) Direct Data Placement&#34;, RFC 5667, January 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] Talpey、T。およびB. Callaghan、「Network File System（NFS）Direct Data Placement」、RFC 5667、2010年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] Recio, R., Metzler, B., Culley, P., Hilland, J., and D. Garcia, &#34;A Remote Direct Memory Access Protocol Specification&#34;, RFC 5040, October 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] Recio、R.、Metzler、B.、Culley、P.、Hilland、J。、およびD. Garcia、「A Remote Direct Memory Access Protocol Specification」、RFC 5040、2007年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[11] Krawczyk, H., Bellare, M., and R. Canetti, &#34;HMAC: Keyed-Hashing for Message Authentication&#34;, RFC 2104, February 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[11] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、1997年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[12] Eisler, M., &#34;RPCSEC_GSS Version 2&#34;, RFC 5403, February 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[12] Eisler、M。、「RPCSEC_GSSバージョン2」、RFC 5403、2009年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[13] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Minor Version 1 External Data Representation Standard (XDR) Description&#34;, RFC 5662, January 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[13] Shepler、S.、Ed。、Eisler、M.、Ed。、and D. Noveck、Ed。、 &#34;Network File System（NFS）Version 4 Minor Version 1 External Data Representation Standard（XDR）Description&#34;、RFC 5662、January 2010。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[14] The Open Group, &#34;Section 3.372 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232&#34;, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[14] The Open Group、「Open Group Base Specifications Issue 6 IEEE Std 1003.1、2004 Edition、HTML Version（www.opengroup.org）、ISBN 1931624232のベース定義の第3章のセクション3.372」、2004年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[15] Eisler, M., &#34;IANA Considerations for Remote Procedure Call (RPC) Network Identifiers and Universal Address Formats&#34;, RFC 5665, January 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[15] アイスラー、M。、「リモートプロシージャコール（RPC）ネットワーク識別子とユニバーサルアドレス形式に関するIANAの考慮事項」、RFC 5665、2010年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[16] The Open Group, &#34;Section &#39;read()&#39; of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232&#34;, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[16] オープングループ、「オープングループの基本仕様のシステムインターフェースのセクション「read()」、IEEE Std 1003.1、2004年版、HTMLバージョン（www.opengroup.org）、ISBN 1931624232」、2004年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17] The Open Group, &#34;Section &#39;readdir()&#39; of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232&#34;, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17] The Open Group、「Open Group Base Specifications Issue 6 IEEE Std 1003.1、2004 Edition、HTML Version（www.opengroup.org）、ISBN 1931624232のシステムインターフェイスのセクション「readdir()」、2004。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[18] The Open Group, &#34;Section &#39;write()&#39; of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232&#34;, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[18] オープングループ、「オープングループの基本仕様のシステムインターフェースのセクション「write()」、IEEE Std 1003.1、2004年版、HTMLバージョン（www.opengroup.org）、ISBN 1931624232」、2004年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[19] Hoffman, P. and M. Blanchet, &#34;Preparation of Internationalized Strings (&#34;stringprep&#34;)&#34;, RFC 3454, December 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[19] Hoffman、P.およびM. Blanchet、「Preparation of Internationalized Strings（ &#34;stringprep&#34;）」、RFC 3454、2002年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[20] The Open Group, &#34;Section &#39;chmod()&#39; of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232&#34;, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[20] The Open Group、「The Open Group Base Specifications Issue 6 IEEE Std 1003.1、2004 Edition、HTML Version（www.opengroup.org）、ISBN 1931624232」のシステムインターフェイスの「chmod()」セクション、2004年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[21] International Organization for Standardization, &#34;Information Technology - Universal Multiple-octet coded Character Set (UCS) - Part 1: Architecture and Basic Multilingual Plane&#34;, ISO Standard 10646-1, May 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[21] 国際標準化機構、「情報技術-ユニバーサルマルチオクテットコード化文字セット（UCS）-パート1：アーキテクチャと基本的な多言語プレーン」、ISO標準10646-1、1993年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[22] Alvestrand, H., &#34;IETF Policy on Character Sets and Languages&#34;, BCP 18, RFC 2277, January 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[22] Alvestrand、H。、「文字セットと言語に関するIETFポリシー」、BCP 18、RFC 2277、1998年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[23] Hoffman, P. and M. Blanchet, &#34;Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)&#34;, RFC 3491, March 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[23] ホフマン、P。およびM.ブランシェ、「Nameprep：国際化ドメイン名（IDN）のStringprepプロファイル」、RFC 3491、2003年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[24] The Open Group, &#34;Section &#39;fcntl()&#39; of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232&#34;, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[24] The Open Group、「Open Group Base Specifications Issue 6 IEEE Std 1003.1、2004 Edition、HTMLバージョン（www.opengroup.org）、ISBN 1931624232のシステムインターフェイスのセクション「fcntl()」、2004。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[25] The Open Group, &#34;Section &#39;fsync()&#39; of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232&#34;, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[25] The Open Group、「Open Group Base Specifications Issue 6 IEEE Std 1003.1、2004 Edition、HTMLバージョン（www.opengroup.org）、ISBN 1931624232のシステムインターフェイスのセクション「fsync()」、2004。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[26] The Open Group, &#34;Section &#39;getpwnam()&#39; of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232&#34;, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[26] The Open Group、「Open Group Base Specifications Issue 6 IEEE Std 1003.1、2004 Edition、HTMLバージョン（www.opengroup.org）、ISBN 1931624232のシステムインターフェイスのセクション「getpwnam()」、2004。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[27] The Open Group, &#34;Section &#39;unlink()&#39; of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232&#34;, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[27] The Open Group、「Open Group Base Specifications Issue 6 IEEE Std 1003.1、2004 Edition、HTMLバージョン（www.opengroup.org）、ISBN 1931624232のシステムインターフェイスのセクション「unlink()」、2004。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[28] Schaad, J., Kaliski, B., and R. Housley, &#34;Additional Algorithms and Identifiers for RSA Cryptography for use in the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&#34;, RFC 4055, June 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[28] Schaad、J.、Kaliski、B。、およびR. Housley、「インターネットX.509公開鍵インフラストラクチャ証明書および証明書失効リスト（CRL）プロファイルで使用するRSA暗号化の追加のアルゴリズムおよび識別子」、RFC 4055、2005年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[29] National Institute of Standards and Technology, &#34;Cryptographic Algorithm Object Registration&#34;, URL http://csrc.nist.gov/ groups/ST/crypto_apps_infra/csor/algorithms.html, November 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[29] 米国国立標準技術研究所、「Cryptographic Algorithm Object Registration」、URL http://csrc.nist.gov/ groups / ST / crypto_apps_infra / csor / algorithms.html、2007年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="23-2--Informative-References">
23.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
23.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[30] Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame, C., Eisler, M., and D. Noveck, &#34;Network File System (NFS) version 4 Protocol&#34;, RFC 3530, April 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[30] Shepler、S.、Callaghan、B.、Robinson、D.、Thurlow、R.、Beame、C.、Eisler、M.、and D. Noveck、 &#34;Network File System（NFS）version 4 Protocol&#34;、RFC 3530、 2003年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[31] Callaghan, B., Pawlowski, B., and P. Staubach, &#34;NFS Version 3 Protocol Specification&#34;, RFC 1813, June 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[31] Callaghan、B.、Pawlowski、B。、およびP. Staubach、「NFSバージョン3プロトコル仕様」、RFC 1813、1995年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[32] Eisler, M., &#34;LIPKEY - A Low Infrastructure Public Key Mechanism Using SPKM&#34;, RFC 2847, June 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[32] Eisler、M。、「LIPKEY-SPKMを使用した低インフラストラクチャ公開キーメカニズム」、RFC 2847、2000年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[33] Eisler, M., &#34;NFS Version 2 and Version 3 Security Issues and the NFS Protocol&#39;s Use of RPCSEC_GSS and Kerberos V5&#34;, RFC 2623, June 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[33] Eisler、M。、「NFSバージョン2およびバージョン3のセキュリティ問題とNFSプロトコルによるRPCSEC_GSSおよびKerberos V5の使用」、RFC 2623、1999年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[34] Juszczak, C., &#34;Improving the Performance and Correctness of an NFS Server&#34;, USENIX Conference Proceedings, June 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[34] Juszczak、C。、「NFSサーバーのパフォーマンスと正確さの向上」、USENIX会議議事録、1990年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[35] Reynolds, J., Ed., &#34;Assigned Numbers: RFC 1700 is Replaced by an On-line Database&#34;, RFC 3232, January 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[35] Reynolds、J.、Ed。、「割り当てられた番号：RFC 1700はオンラインデータベースに置き換えられました」、RFC 3232、2002年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[36] Srinivasan, R., &#34;Binding Protocols for ONC RPC Version 2&#34;, RFC 1833, August 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[36] Srinivasan、R。、「Binding Protocols for ONC RPC Version 2」、RFC 1833、1995年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[37] Werme, R., &#34;RPC XID Issues&#34;, USENIX Conference Proceedings, February 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[37] Werme、R。、「RPC XIDの問題」、USENIX会議議事録、1996年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[38] Nowicki, B., &#34;NFS: Network File System Protocol specification&#34;, RFC 1094, March 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[38] Nowicki、B。、「NFS：ネットワークファイルシステムプロトコル仕様」、RFC 1094、1989年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[39] Bhide, A., Elnozahy, E., and S. Morgan, &#34;A Highly Available Network Server&#34;, USENIX Conference Proceedings, January 1991.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[39] Bhide、A.、Elnozahy、E。、およびS. Morgan、「A Highly Available Network Server」、USENIX Conference Proceedings、1991年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[40] Halevy, B., Welch, B., and J. Zelenka, &#34;Object-Based Parallel NFS (pNFS) Operations&#34;, RFC 5664, January 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[40] Halevy、B.、Welch、B。、およびJ. Zelenka、「Object-Based Parallel NFS（pNFS）Operations」、RFC 5664、2010年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[41] Black, D., Glasgow, J., and S. Fridella, &#34;Parallel NFS (pNFS) Block/Volume Layout&#34;, RFC 5663, January 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[41] Black、D.、Glasgow、J。、およびS. Fridella、「Parallel NFS（pNFS）Block / Volume Layout」、RFC 5663、2010年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[42] Callaghan, B., &#34;WebNFS Client Specification&#34;, RFC 2054, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[42] Callaghan、B。、「WebNFSクライアント仕様」、RFC 2054、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[43] Callaghan, B., &#34;WebNFS Server Specification&#34;, RFC 2055, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[43] Callaghan、B。、「WebNFSサーバー仕様」、RFC 2055、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[44] IESG, &#34;IESG Processing of RFC Errata for the IETF Stream&#34;, July 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[44] IESG、「IETF StreamのRFCエラータのIESG処理」、2008年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[45] Shepler, S., &#34;NFS Version 4 Design Considerations&#34;, RFC 2624, June 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[45] Shepler、S。、「NFSバージョン4の設計上の考慮事項」、RFC 2624、1999年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[46] The Open Group, &#34;Protocols for Interworking: XNFS, Version 3W, ISBN 1-85912-184-5&#34;, February 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[46] オープングループ、「Interworkingのプロトコル：XNFS、バージョン3W、ISBN 1-85912-184-5」、1998年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[47] Floyd, S. and V. Jacobson, &#34;The Synchronization of Periodic Routing Messages&#34;, IEEE/ACM Transactions on Networking 2(2), pp. 122-136, April 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[47] Floyd、S. and V. Jacobson、 &#34;The Synchronization of Periodic Routing Messages&#34;、IEEE / ACM Transactions on Networking 2（2）、pp。122-136、April 1994。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[48] Satran, J., Meth, K., Sapuntzakis, C., Chadalapaka, M., and E. Zeidner, &#34;Internet Small Computer Systems Interface (iSCSI)&#34;, RFC 3720, April 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[48] Satran、J.、Meth、K.、Sapuntzakis、C.、Chadalapaka、M.、and E. Zeidner、 &#34;Internet Small Computer Systems Interface（iSCSI）&#34;、RFC 3720、April 2004。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[49] Snively, R., &#34;Fibre Channel Protocol for SCSI, 2nd Version (FCP-2)&#34;, ANSI/INCITS 350-2003, Oct 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[49] Snively、R。、「SCSIのファイバーチャネルプロトコル、第2バージョン（FCP-2）」、ANSI / INCITS 350-2003、2003年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[50] Weber, R., &#34;Object-Based Storage Device Commands (OSD)&#34;, ANSI/ INCITS 400-2004, July 2004, &lt;http://www.t10.org/ftp/t10/drafts/osd/osd-r10.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[50] Weber、R。、「Object-Based Storage Device Commands（OSD）」、ANSI / INCITS 400-2004、2004年7月、&lt;http://www.t10.org/ftp/t10/drafts/osd/osd-r10。 pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[51] Carns, P., Ligon III, W., Ross, R., and R. Thakur, &#34;PVFS: A Parallel File System for Linux Clusters.&#34;, Proceedings of the 4th Annual Linux Showcase and Conference, 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[51] Carns、P.、Ligon III、W.、Ross、R。、およびR. Thakur、「PVFS：Linux Clustersの並列ファイルシステム」、第4回Linuxショーケースおよび会議の議事録、2000年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[52] The Open Group, &#34;The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition&#34;, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[52] The Open Group、「The Open Group Base Specifications Issue 6、IEEE Std 1003.1、2004 Edition」、2004。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[53] Callaghan, B., &#34;NFS URL Scheme&#34;, RFC 2224, October 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[53] Callaghan、B。、「NFS URLスキーム」、RFC 2224、1997年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[54] Chiu, A., Eisler, M., and B. Callaghan, &#34;Security Negotiation for WebNFS&#34;, RFC 2755, January 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[54] Chiu、A.、Eisler、M。、およびB. Callaghan、「WebNFSのセキュリティネゴシエーション」、RFC 2755、2000年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[55] Narten, T. and H. Alvestrand, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 5226, May 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[55] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 5226、2008年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--Acknowledgments">
Appendix A. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial text for the SECINFO extensions were edited by Mike Eisler with contributions from Peng Dai, Sergey Klyushin, and Carl Burnett.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFO拡張の最初のテキストは、Peng Dai、Sergey Klyushin、およびCarl Burnettの貢献によりMike Eislerによって編集されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial text for the SESSIONS extensions were edited by Tom Talpey, Spencer Shepler, Jon Bauman with contributions from Charles Antonelli, Brent Callaghan, Mike Eisler, John Howard, Chet Juszczak, Trond Myklebust, Dave Noveck, John Scott, Mike Stolarchuk, and Mark Wittle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SESSIONS拡張の最初のテキストは、Tom Talpey、Spencer Shepler、Jon Baumanによって編集され、Charles Antonelli、Brent Callaghan、Mike Eisler、John Howard、Chet Juszczak、Trond Myklebust、Dave Noveck、John Scott、Mike Stolarchuk、Markウィトル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initial text relating to multi-server namespace features, including the concept of referrals, were contributed by Dave Noveck, Carl Burnett, and Charles Fan with contributions from Ted Anderson, Neil Brown, and Jon Haswell.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
紹介の概念を含むマルチサーバー名前空間機能に関連する最初のテキストは、Ted Anderson、Neil Brown、およびJon Haswellからの寄稿とともに、Dave Noveck、Carl Burnett、およびCharles Fanによって寄稿されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial text for the Directory Delegations support were contributed by Saadia Khan with input from Dave Noveck, Mike Eisler, Carl Burnett, Ted Anderson, and Tom Talpey.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Directory Delegationsのサポートの最初のテキストは、Dave Noveck、Mike Eisler、Carl Burnett、Ted Anderson、およびTom Talpeyからの入力により、Saadia Khanによって提供されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial text for the ACL explanations were contributed by Sam Falkner and Lisa Week.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACLの説明の最初のテキストは、Sam FalknerとLisa Weekによって寄稿されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pNFS work was inspired by the NASD and OSD work done by Garth Gibson. Gary Grider has also been a champion of high-performance parallel I/O. Garth Gibson and Peter Corbett started the pNFS effort with a problem statement document for the IETF that formed the basis for the pNFS work in NFSv4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSの作業は、Garth Gibsonが行ったNASDおよびOSDの作業に触発されました。 Gary Griderは、高性能パラレルI / Oのチャンピオンでもあります。 Garth GibsonとPeter Corbettは、NFSv4.1でのpNFS作業の基礎を形成したIETFの問題ステートメントドキュメントからpNFSの取り組みを開始しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial text for the parallel NFS support was edited by Brent Welch and Garth Goodson. Additional authors for those documents were Benny Halevy, David Black, and Andy Adamson. Additional input came from the informal group that contributed to the construction of the initial pNFS drafts; specific acknowledgment goes to Gary Grider, Peter Corbett, Dave Noveck, Peter Honeyman, and Stephen Fridella.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
並列NFSサポートの最初のテキストは、Brent WelchとGarth Goodsonによって編集されました。これらの文書の追加の著者は、Benny Halevy、David Black、Andy Adamsonでした。追加のインプットは、初期のpNFSドラフトの作成に貢献した非公式グループからのものでした。具体的な謝辞は、ゲイリーグリダー、ピーターコーベット、デイブノベック、ピーターハニーマン、スティーブンフリデラです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fredric Isaman found several errors in draft versions of the ONC RPC XDR description of the NFSv4.1 protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fredric Isamanは、NFSv4.1プロトコルのONC RPC XDR記述のドラフトバージョンにいくつかのエラーを発見しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Audrey Van Belleghem provided, in numerous ways, essential co-ordination and management of the process of editing the specification documents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オードリー・ヴァン・ベレゲムは、仕様書を編集するプロセスの重要な調整と管理をさまざまな方法で提供しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Richard Jernigan gave feedback on the file layout&#39;s striping pattern design.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Richard Jerniganが、ファイルレイアウトのストライプ化パターン設計についてフィードバックしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several formal inspection teams were formed to review various areas of the protocol. All the inspections found significant errors and room for improvement. NFSv4.1&#39;s inspection teams were:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルのさまざまな領域をレビューするために、いくつかの正式な検査チームが編成されました。すべての検査で重大なエラーと改善の余地が見つかりました。 NFSv4.1の検査チームは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ACLs, with the following inspectors: Sam Falkner, Bruce Fields, Rahul Iyer, Saadia Khan, Dave Noveck, Lisa Week, Mario Wurzl, and Alan Yoder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ACL、および次の検査官：Sam Falkner、Bruce Fields、Rahul Iyer、Saadia Khan、Dave Noveck、Lisa Week、Mario Wurzl、Alan Yoder。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Sessions, with the following inspectors: William Brown, Tom Doeppner, Robert Gordon, Benny Halevy, Fredric Isaman, Rick Macklem, Trond Myklebust, Dave Noveck, Karen Rochford, John Scott, and Peter Shah.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セッションと次のインスペクター：ウィリアムブラウン、トムドップナー、ロバートゴードン、ベニーヘレビー、フレドリックイサマン、リックマックルム、トロンドマイクルバスト、デイブノベック、カレンロッチフォード、ジョンスコット、ピーターシャー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Initial pNFS inspection, with the following inspectors: Andy Adamson, David Black, Mike Eisler, Marc Eshel, Sam Falkner, Garth Goodson, Benny Halevy, Rahul Iyer, Trond Myklebust, Spencer Shepler, and Lisa Week.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o アンディアダムソン、デビッドブラック、マイクアイスラー、マークエシェル、サムフォークナー、ガースグッドソン、ベニーヘレビー、ラフルイイヤー、トロンドマイクルバスト、スペンサーシェプラー、リサウィークの最初のpNFS検査。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Global namespace, with the following inspectors: Mike Eisler, Dan Ellard, Craig Everhart, Fredric Isaman, Trond Myklebust, Dave Noveck, Theresa Raj, Spencer Shepler, Renu Tewari, and Robert Thurlow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 次のインスペクターを持つグローバル名前空間：Mike Eisler、Dan Ellard、Craig Everhart、Fredric Isaman、Trond Myklebust、Dave Noveck、Theresa Raj、Spencer Shepler、Renu Tewari、およびRobert Thurlow。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1 file layout type, with the following inspectors: Andy Adamson, Marc Eshel, Sam Falkner, Garth Goodson, Rahul Iyer, Trond Myklebust, and Lisa Week.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1ファイルレイアウトタイプ。インスペクターは、Andy Adamson、Marc Eshel、Sam Falkner、Garth Goodson、Rahul Iyer、Trond Myklebust、Lisa Weekです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1 locking and directory delegations, with the following inspectors: Mike Eisler, Pranoop Erasani, Robert Gordon, Saadia Khan, Eric Kustarz, Dave Noveck, Spencer Shepler, and Amy Weaver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1ロックおよびディレクトリ委任。インスペクターは、マイクアイスラー、プラヌープエラサニ、ロバートゴードン、サーディアカーン、エリッククスターズ、デイブノベック、スペンサーシェプラー、エイミーウィーバーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o EXCHANGE_ID and DESTROY_CLIENTID, with the following inspectors: Mike Eisler, Pranoop Erasani, Robert Gordon, Benny Halevy, Fredric Isaman, Saadia Khan, Ricardo Labiaga, Rick Macklem, Trond Myklebust, Spencer Shepler, and Brent Welch.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o EXCHANGE_IDとDESTROY_CLIENTID、および次のインスペクター：マイク・アイスラー、プラヌープ・エラサニ、ロバート・ゴードン、ベニー・ヘレヴィ、フレドリック・イサマン、サーディア・カーン、リカルド・ラビアガ、リック・マックレム、トロンド・マイクルバスト、スペンサー・シェプラー、ブレント・ウェルチ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Final pNFS inspection, with the following inspectors: Andy Adamson, Mike Eisler, Mark Eshel, Sam Falkner, Jason Glasgow, Garth Goodson, Robert Gordon, Benny Halevy, Dean Hildebrand, Rahul Iyer, Suchit Kaura, Trond Myklebust, Anatoly Pinchuk, Spencer Shepler, Renu Tewari, Lisa Week, and Brent Welch.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Andy Adamson、Mike Eisler、Mark Eshel、Sam Falkner、Jason Glasgow、Garth Goodson、Robert Gordon、Benny Halevy、Dean Hildebrand、Rahul Iyer、Suchit Kaura、Trond Myklebust、Anatoly Pinchuk、Spencer Shepler 、Renu Tewari、Lisa Week、Brent Welch。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A review team worked together to generate the tables of assignments of error sets to operations and make sure that each such assignment had two or more people validating it. Participating in the process were Andy Adamson, Mike Eisler, Sam Falkner, Garth Goodson, Robert Gordon, Trond Myklebust, Dave Noveck, Spencer Shepler, Tom Talpey, Amy Weaver, and Lisa Week.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レビューチームが協力して、エラーセットの操作への割り当てのテーブルを生成し、そのような割り当てごとに2人以上の人がそれを検証していることを確認しました。このプロセスに参加したのは、アンディアダムソン、マイクアイスラー、サムフォークナー、ガースグッドソン、ロバートゴードン、トロンドミルクルバスト、デイブノベック、スペンサーシェプラー、トムタルペイ、エイミーウィーバー、リサウィークでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jari Arkko, David Black, Scott Bradner, Lisa Dusseault, Lars Eggert, Chris Newman, and Tim Polk provided valuable review and guidance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jari Arkko、David Black、Scott Bradner、Lisa Dusseault、Lars Eggert、Chris Newman、およびTim Polkは、貴重なレビューとガイダンスを提供しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Olga Kornievskaia found several errors in the SSV specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Olga KornievskaiaがSSV仕様にいくつかのエラーを見つけました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ricardo Labiaga found several places where the use of RPCSEC_GSS was underspecified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ricardo Labiagaは、RPCSEC_GSSの使用が十分に指定されていない場所をいくつか見つけました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Those who provided miscellaneous comments include: Andy Adamson, Sunil Bhargo, Alex Burlyga, Pranoop Erasani, Bruce Fields, Vadim Finkelstein, Jason Goldschmidt, Vijay K. Gurbani, Sergey Klyushin, Ricardo Labiaga, James Lentini, Anshul Madan, Daniel Muntz, Daniel Picken, Archana Ramani, Jim Rees, Mahesh Siddheshwar, Tom Talpey, and Peter Varga.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その他のコメントには、アンディアダムソン、スニルバーゴ、アレックスブリガ、プラヌープエラサニ、ブルースフィールズ、ヴァディムフィンケルシュタイン、ジェイソンゴールドシュミット、ビジェイK.グルバニ、セルゲイクリシン、リカルドラビアガ、ジェームズレンティーニ、アンシュルマダン、ダニエルムンツ、ダニエルピッケンが含まれます。 、アーチャナ・ラマニ、ジム・リース、マヘシュ・シドヘシュワル、トム・タルペイ、ピーター・ヴァルガ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Spencer Shepler (editor) Storspeed, Inc. 7808 Moonflower Drive Austin, TX 78750 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Spencer Shepler（editor）Storspeed、Inc. 7808 Moonflower Drive Austin、TX 78750 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1-512-402-5811 ext 8530
   EMail: shepler@storspeed.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mike Eisler (editor) NetApp 5765 Chase Point Circle Colorado Springs, CO 80919 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mike Eisler（editor）NetApp 5765 Chase Point Circle Colorado Springs、CO 80919 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1-719-599-9026
   EMail: mike@eisler.com
   URI:   http://www.eisler.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Noveck (editor) NetApp 1601 Trapelo Road, Suite 16 Waltham, MA 02451 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Noveck（editor）NetApp 1601 Trapelo Road、Suite 16 Waltham、MA 02451 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1-781-768-5347
   EMail: dnoveck@netapp.com
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
