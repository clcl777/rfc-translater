<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 8931 - IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Selective Fragment Recovery 日本語訳</title>
  <meta name="description" content="RFC 8931 は、RFC 4944 を更新し、個々のフラグメントを経路上のメッシュを介して転送し、エンドツーエンドで回復するプロトコルを提供します。ネットワークを保護するための過負荷制御機能も備えています。">

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">8931</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc8931">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 8931 - IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Selective Fragment Recovery 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc8931">
            https://datatracker.ietf.org/doc/html/rfc8931
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 8931 - 低電力無線パーソナルエリアネットワーク（6LOWPAN）選択的フラグメントリカバリのIPv6</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] RFC 8931 は、RFC 4944 を更新し、個々のフラグメントを経路上のメッシュを介して転送し、エンドツーエンドで回復するプロトコルを提供します。ネットワークを保護するための過負荷制御機能も備えています。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                   P. Thubert, Ed.
Request for Comments: 8931                                 Cisco Systems
Updates: 4944                                              November 2020
Category: Standards Track
ISSN: 2070-1721
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Selective Fragment Recovery
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
低電力無線パーソナルエリアネットワーク（6LOWPAN）選択的フラグメントリカバリのIPv6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document updates RFC 4944 with a protocol that forwards individual fragments across a route-over mesh and recovers them end to end, with congestion control capabilities to protect the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、ルートオーバーメッシュを介して個々のフラグメントを転送し、ネットワークを保護するための輻輳制御機能を伴って、それらを終了し、それらを復元するプロトコルでRFC 4944を更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはインターネット規格のトラック文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表します。それは公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による出版の承認を受けました。インターネット規格に関する詳細情報は、RFC 7841のセクション2で利用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8931.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書の現在のステータス、任意のエラータ、およびフィードバックを提供する方法は、https://www.rfc-editor.org/info/frfc8931で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（C）2020 IETFの信頼と文書著者として識別された人。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、このドキュメントの発行日に有効なBCP 78およびIETFドキュメントに関連するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するお客様の権利と制限について説明しているため、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust LegalProvisionsのセクション4.eで説明されているSimplifiedBSD Licenseテキストが含まれている必要があり、Simplified BSDLicenseで説明されているように保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction
   2.  Terminology
     2.1.  Requirements Language
     2.2.  Background
     2.3.  Other Terms
   3.  Updating RFC 4944
   4.  Extending RFC 8930
     4.1.  Slack in the First Fragment
     4.2.  Gap between Frames
     4.3.  Congestion Control
     4.4.  Modifying the First Fragment
   5.  New Dispatch Types and Headers
     5.1.  Recoverable Fragment Dispatch Type and Header
     5.2.  RFRAG Acknowledgment Dispatch Type and Header
   6.  Fragment Recovery
     6.1.  Forwarding Fragments
       6.1.1.  Receiving the First Fragment
       6.1.2.  Receiving the Next Fragments
     6.2.  Receiving RFRAG Acknowledgments
     6.3.  Aborting the Transmission of a Fragmented Packet
     6.4.  Applying Recoverable Fragmentation along a Diverse Path
   7.  Management Considerations
     7.1.  Protocol Parameters
     7.2.  Observing the Network
   8.  Security Considerations
   9.  IANA Considerations
   10. References
     10.1.  Normative References
     10.2.  Informative References
   Appendix A.  Rationale
   Appendix B.  Requirements
   Appendix C.  Considerations on Congestion Control
   Acknowledgments
   Author&#39;s Address
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In most Low-Power and Lossy Network (LLN) applications, the bulk of the traffic consists of small chunks of data (on the order of a few bytes to a few tens of bytes) at a time. Given that an IEEE Std 802.15.4 [IEEE.802.15.4] frame can carry a payload of 74 bytes or more, fragmentation is usually not required. However, and though this happens only occasionally, a number of mission-critical applications do require the capability to transfer larger chunks of data, for instance, to support the firmware upgrade of the LLN nodes or the extraction of logs from LLN nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどの低電力および非損失ネットワーク（LLN）アプリケーションでは、トラフィックの大部分は、一度に（数バイトから数十バイトに数バイト程度の）データの小さなチャンクからなる。IEEE STD 802.15.4 [IEEE.802.15.4]フレームが74バイト以上のペイロードを持つことができることを考えると、断片化は通常必要ありません。ただし、これは時折しか起こりませんが、多くのミッションクリティカルなアプリケーションでは、LLNノードのファームウェアのアップグレードまたはLLNノードからのログの抽出をサポートするための、より大きなデータのチャンクを転送する機能が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the former case, the large chunk of data is transferred to the LLN node, whereas in the latter case, the large chunk flows away from the LLN node. In both cases, the size can be on the order of 10 KB or more, and an end-to-end reliable transport is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前者の場合、データの大きなチャンクがLLNノードに転送されますが、後者の場合、大きなチャンクはLLNノードから流れます。どちらの場合も、サイズは10 KB以上のオーダーであり、エンドツーエンドの信頼できる輸送が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;Transmission of IPv6 Packets over IEEE 802.15.4 Networks&#34; [RFC4944] defines the original IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) datagram fragmentation mechanism for LLNs. One critical issue with this original design is that routing an IPv6 [RFC8200] packet across a route-over mesh requires the reassembly of the packet at each hop. &#34;An Architecture for IPv6 over the TSCH mode of IEEE 802.15.4&#34; [6TiSCH] indicates that this may cause latency along a path and impact critical resources such as memory and battery; to alleviate those undesirable effects, it recommends using a 6LoWPAN Fragment Forwarding (6LFF) technique.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「IEEE 802.15.4ネットワーク上のIPv6パケットの送信」[RFC4944]は、LLN用の低電力無線パーソナルエリアネットワーク（6LOWPAN）データグラム断片化メカニズムを介した元のIPv6を定義します。このオリジナルデザインに関する1つの重要な問題は、経路オーバーメッシュ全体でIPv6 [RFC8200]パケットをルーティングすることで、各ホップでパケットの再組み立てが必要です。「IEEE 802.15.4のTSCHモードを介したIPv6のアーキテクチャは、これがパスに沿って待ち時間を引き起こし、メモリやバッテリなどの重要なリソースに影響を与える可能性があることを示しています。これらの望ましくない効果を軽減するために、6lowpanフラグメント転送（6LFF）技術を使用することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;On Forwarding 6LoWPAN Fragments over a Multihop IPv6 Network&#34; [RFC8930] specifies the generic behavior that all 6LFF techniques including this specification follow, and it presents the associated caveats. In particular, the routing information is fully indicated in the first fragment, which is always forwarded first. With this specification, the first fragment is identified by a Sequence of 0 as opposed to a dispatch type in [RFC4944]. A state is formed and used to forward all the next fragments along the same path. The Datagram_Tag is locally significant to the Layer 2 source of the packet and is swapped at each hop; see Section 6. This specification encodes the Datagram_Tag in 1 byte, which will saturate if more than 256 datagrams transit in fragmented form over a single hop at the same time. This is not realistic at the time of this writing. Should this happen in a new 6LoWPAN technology, a node will need to use several link-layer addresses to increase its indexing capacity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「マルチホップIPv6ネットワーク経由で6lowpanフラグメントを転送する」[RFC8930]は、この仕様を含むすべての6LFF技術が続く一般的な動作を指定し、関連する警告を提示します。特に、ルーティング情報は最初のフラグメントに完全に示されており、これは常に最初に転送されます。本明細書では、[RFC4944]のディスパッチタイプとは対照的に、最初のフラグメントが0のシーケンスで識別されます。状態が形成され、同じ経路に沿ってすべての次のフラグメントを転送するために使用される。Datagram_tagは、パケットのレイヤ2のソースにローカルに重要であり、各ホップでスワップされます。セクション6を参照してください。この仕様は、1バイトでデータグラムを符号化します。これは、256以上のデータグラムが断片化された形式で断片化された形式でシングルホップで同時に遷移するかどうかを彩度します。これはこの書き込み時に現実的ではありません。これが新しい6LOWPANテクノロジで発生する場合、ノードは索引付け容量を増やすためにいくつかのリンク層アドレスを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;Virtual reassembly buffers in 6LoWPAN&#34; [LWIG-FRAG] proposes a 6LFF technique that is compatible with [RFC4944] without the need to define a new protocol. However, adding that capability alone to the local implementation of the original 6LoWPAN fragmentation would not address the inherent fragility of fragmentation (see [RFC8900]), in particular, the issues of resources locked on the reassembling endpoint and the wasted transmissions due to the loss of a single fragment in a whole datagram. [Kent] compares the unreliable delivery of fragments with a mechanism it calls &#34;selective acknowledgments&#34; that recovers the loss of a fragment individually. The paper illustrates the benefits that can be derived from such a method; see Figures 1, 2, and 3 in Section 2.3 of [Kent]. [RFC4944] has no selective recovery, and the whole datagram fails when one fragment is not delivered to the reassembling endpoint. Constrained memory resources are blocked on the reassembling endpoint until it times out, possibly causing the loss of subsequent packets that cannot be received for the lack of buffers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「6lowpanの仮想再構成バッファ」[LWIG-Frag]は、新しいプロトコルを定義する必要なしに[RFC4944]と互換性のある6LFFテクニックを提案しています。ただし、オリジナルの6LOWPANフラグメンテーションの局所実装に単独でのみを追加すると、断片化の固有の脆弱性に対処しない（[RFC8900]参照）、特に、再組み立てエンドポイントにロックされたリソースの問題と損失による無駄な送信の問題があります。データグラム全体の単一のフラグメントの。 [ケント]は、フラグメントの信頼性の低い配信を、フラグメントの損失を個別に回復する「選択的承認」と呼びます。この論文は、そのような方法から導き出すことができる利点を説明する。 [ケント]のセクション2.3の図1,2、および3を参照してください。 [RFC4944]は選択的な回復をしていないため、1つのフラグメントが再組み立てエンドポイントに配信されない場合、データグラム全体は失敗します。制約されたメモリリソースは、それがタイムアウトするまで、再組み立てエンドポイントでブロックされ、バッファの欠如に対して受信できない後続のパケットの損失を引き起こす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
That problem is exacerbated when forwarding fragments over multiple hops since a loss at an intermediate hop will not be discovered by either the fragmenting or the reassembling endpoints. Should this happen, the source will keep on sending fragments, wasting even more resources in the network since the datagram cannot arrive in its entirety, which possibly contributes to the condition that caused the loss. [RFC4944] is lacking a congestion control to avoid participating in a saturation that may have caused the loss of the fragment. It has no signaling to abort a multi-fragment transmission at any time and from either end, and if the capability to forward fragments is implemented, clean up the related state in the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
中間ホップでの損失は、断片化または再組み立てエンドポイントのいずれかによって発見されないので、その問題は複数のホップにわたってフラグメントを転送するときに悪化される。これが起こると、ソースはフラグメントを送信し続け、データグラム全体が到着できないため、ネットワーク内でさらに多くのリソースを無駄にします。これはおそらく損失を引き起こした状態に貢献します。[RFC4944]は、フラグメントの損失を引き起こした可能性がある飽和に参加しないように輻輳制御を欠いています。マルチフラグメント伝送をいつでも中止するシグナリングはありません。どちらの端からも、フラグメントを転送する機能が実装されている場合は、ネットワーク内の関連状態をクリーンアップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification provides a method to forward fragments over, typically, a few hops in a route-over 6LoWPAN mesh and a selective acknowledgment to recover individual fragments between 6LoWPAN endpoints. The method can help limit the congestion loss in the network and addresses the requirements in Appendix B. Flow control is out of scope since the endpoints are expected to be able to store the full datagram. Deployments are expected to be managed and homogeneous, and an incremental transition requires a flag day.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、典型的には、6LOWPANメッシュ内の数のホップ、および6LOWPANエンドポイント間で個々のフラグメントを回復するための選択的確認応答を順に転送する方法を提供する。この方法は、ネットワーク内の輻輳損失を制限し、付録Bの要件に対処するのに役立ちます。エンドポイントは全データグラムを保存できると予想されるため、フロー制御は範囲外です。展開は管理されていて均質になると予想され、増分遷移はフラグの日を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Terminology">
2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1--Requirements-Language">
2.1. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. 要件言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, および &#34;OPTIONAL&#34; はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2--Background">
2.2. Background
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. バックグラウンド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   This document uses 6LoWPAN terms and concepts that are presented in
   &#34;IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs):
   Overview, Assumptions, Problem Statement, and Goals&#34; [RFC4919];
   &#34;Transmission of IPv6 Packets over IEEE 802.15.4 Networks&#34; [RFC4944];
   and &#34;Problem Statement and Requirements for IPv6 over Low-Power
   Wireless Personal Area Network (6LoWPAN) Routing&#34; [RFC6606].
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8930] discusses the generic concept of a Virtual Reassembly Buffer (VRB) and specifies behaviors and caveats that are common to a large family of 6LFF techniques including the mechanism specified by this document, which is fully inherited from that specification. It also defines terms used in this document: Compressed Form, Datagram_Tag, Datagram_Size, Fragment_Offset, and 6LoWPAN Fragment Forwarding endpoint (commonly abbreviated as only &#34;endpoint&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8930]仮想再構成バッファ（VRB）の一般的な概念について説明し、この文書で指定されたメカニズムを含む、6LFF技術の大ファミリに共通の動作と警告を指定します。これはその仕様から完全に継承されています。また、この文書で使用されている用語を定義します。圧縮形式、Datagram_tag、Datagram_size、fragmant_offset、および6lowpanフラグメント転送エンドポイント（一般に「エンドポイント」と同様に略）します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Past experience with fragmentation has shown that misassociated or lost fragments can lead to poor network behavior and, occasionally, trouble at the application layer. The reader is encouraged to read &#34;IPv4 Reassembly Errors at High Data Rates&#34; [RFC4963] and follow the references for more information. That experience led to the definition of the &#34;Path MTU Discovery for IP version 6&#34; [RFC8201] protocol that limits fragmentation over the Internet. Specifically, in the case of UDP, valuable additional information can be found in &#34;UDP Usage Guidelines&#34; [RFC8085].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメンテーションの過去の経験が、誤解されたまたは失われたフラグメントが、ネットワークの動作が悪く、時々、アプリケーション層でのトラブルにつながる可能性があることが示されています。リーダーは、「IPv4の再構成エラーが高いデータレートで読み込む」[RFC4963]を読み、詳細については参照に従ってください。その経験は、インターネット上の断片化を制限する「IPバージョン6のPATH MTUディスカバリ」の定義をもたらしました。具体的には、UDPの場合、「UDP使用上のガイドライン」[RFC8085]に貴重な追加情報を見つけることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;The Benefits of Using Explicit Congestion Notification (ECN)&#34; [RFC8087] provides useful information on the potential benefits and pitfalls of using ECN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「明示的輻輳通知（ECN）を使用することの利点は、[RFC8087]はECNを使用する潜在的な利益と落とし穴に関する有用な情報を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Quoting &#34;Multiprotocol Label Switching Architecture&#34; [RFC3031]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;Multiprotocol Label Switche Architecture&#34;の引用[RFC3031]：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |  With MPLS, &#34;packets are &#34;labeled&#34; before they are forwarded [along
   |  a Label Switched Path (LSP)].  At subsequent hops, there is no
   |  further analysis of the packet&#39;s network layer header.  Rather,
   |  the label is used as an index into a table which specifies the
   |  next hop, and a new label&#34;.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8930] leverages MPLS to forward fragments that actually do not have a network-layer header, since the fragmentation occurs below IP, and this specification makes it reversible so the reverse path can be followed as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8930]実際にネットワーク層ヘッダを持たないフラグメントを順番に活用し、断片化がIPを下回るため、この仕様にはリバースパスに従うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3--Other-Terms">
2.3. Other Terms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. その他の用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification uses the following terms:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は以下の用語を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFRAG: Recoverable Fragment
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFRAG：回収可能な断片
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFRAG-ACK: Recoverable Fragment Acknowledgment
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFRAG-ACK：回復可能なフラグメント確認
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFRAG Acknowledgment Request: An RFRAG with the Acknowledgment Request flag (&#34;X&#34; flag) set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFRAG確認応答要求：確認応答要求フラグ（ &#34;X&#34;フラグ）を設定したRFRAG。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NULL bitmap: Refers to a bitmap with all bits set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NULLビットマップ：すべてのビットがゼロに設定されたビットマップを参照します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FULL bitmap: Refers to a bitmap with all bits set to one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フルビットマップ：すべてのビットを1つに設定したビットマップを参照します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reassembling endpoint: The receiving endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントを再組み立てする：受信エンドポイント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fragmenting endpoint: The sending endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメントエンドポイント：送信エンドポイント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Forward direction: The direction of a path, which is followed by the RFRAG.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
順方向：経路の方向に続くRFRAGが続く。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reverse direction: The reverse direction of a path, which is taken by the RFRAG-ACK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
逆方向：RFRAG-ACKによって取られる経路の逆方向。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Updating-RFC-4944">
3. Updating RFC 4944
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. RFC 4944を更新する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification updates the fragmentation mechanism that is specified in [RFC4944] for use in route-over LLNs by providing a model where fragments can be forwarded end to end across a 6LoWPAN LLN and where fragments that are lost on the way can be recovered individually. A new format for fragments is introduced, and new dispatch types are defined in Section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、6LOWPAN LLNを介して終了し、途中で途中で失われるフラグメントを個別に回復できるように、経路上LLNで使用するために[RFC4944]で指定されている断片化メカニズムを更新します。フラグメントのための新しいフォーマットが導入され、新しいディスパッチタイプがセクション5で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8138] allows modifying the size of a packet en route by removing the consumed hops in a compressed Routing Header. This requires that Fragment_Offset and Datagram_Size (defined in Section 5.1) also be modified en route, which is difficult to do in the uncompressed form. This specification expresses those fields in the compressed form and allows modifying them en route easily (more in Section 4.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8138]圧縮されたルーティングヘッダーに消費されたホップを削除することで、Packet ENルートのサイズを変更できます。これには、fragment_offsetとdatagram_size（セクション5.1で定義）も修正されていない途中で、非圧縮形式では困難です。この仕様は、圧縮された形式でそれらのフィールドを表し、それらを簡単に変更することを可能にします（4.4節）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To be consistent with Section 2 of [RFC6282], for the fragmentation mechanism described in Section 5.3 of [RFC4944], any header that cannot fit within the first fragment MUST NOT be compressed when using the fragmentation mechanism described in this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4944]のセクション5.3に記載されているフラグメンテーションメカニズムのセクション2のセクション2と一致するために、この仕様で説明したフラグメンテーションメカニズムを使用すると、最初のフラグメント内に収まることができないヘッダーを圧縮してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Extending-RFC-8930">
4. Extending RFC 8930
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. RFC 8930を拡張する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification implements the generic 6LFF technique defined in [RFC8930] and provides end-to-end fragment recovery and congestion control mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は[RFC8930]で定義されている一般的な6LFF手法を実装し、エンドツーエンドのフラグメントリカバリと輻輳制御メカニズムを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Slack-in-the-First-Fragment">
4.1. Slack in the First Fragment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 最初の断片でたるみます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8930] allows for a refragmentation operation in intermediate nodes, whereby the trailing bytes from a given fragment may be left in the VRB to be added as the heading bytes in the next fragment. This solves the case when the outgoing fragment needs more space than the incoming fragment; that case may arise when the 6LoWPAN header compression is not as efficient on the outgoing link or if the Link MTU is reduced.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8930]中間ノードでのリフレージ処理を可能にし、それによって所与のフラグメントからの後続バイトを次のフラグメント内の見出しバイトとして追加するVRB内に残すことができる。これは、発信フラグメントが入力フラグメントよりも多くのスペースを必要とする場合を解決する。その場合、6LOWPANヘッダ圧縮が発信リンク上でも効率的ではない場合、またはリンクMTUが縮小されている場合に発生する可能性がある。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification cannot allow that refragmentation operation since the fragments are recovered end to end based on a sequence number. The Fragment_Size MUST be tailored to fit the minimal MTU along the path, and the first fragment that contains a 6LoWPAN compressed header MUST have enough slack to enable a less-efficient compression in the next hops to still fit within the Link MTU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、フラグメントがシーケンス番号に基づいて終了して末尾に回復されるため、そのためのその他の停止動作を許可することはできません。fragment_sizeは、パスに沿って最小のMTUを合わせるように調整されなければならず、6lowpan圧縮ヘッダーを含む最初のフラグメントは、次のホップ内の効率的な圧縮を依然としてリンクMTU内に収まるように可能にするのに十分なスラックを持っていなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For instance, if the fragmenting endpoint is also the 6LoWPAN compression endpoint, it will elide the Interface ID (IID) of the source IPv6 address when it matches the link-layer address [RFC6282]. In that case, it MUST leave slack in the first fragment as the if MTU on the first hop was 8 bytes less, so the next hop can expand the IID within the same fragment within MTU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、フラグメント化エンドポイントが6LOWPAN圧縮エンドポイントでもある場合は、リンクレイヤアドレス[RFC6282]と一致すると、ソースIPv6アドレスのインターフェイスID（IID）を除外します。その場合、最初のホップ上のIF MTUが8バイト少なかったため、最初のフラグメントにスラックを残す必要があるため、次のホップはMTU内の同じフラグメント内でIIDを拡張できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Gap-between-Frames">
4.2. Gap between Frames
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. フレーム間のギャップ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8930] requires that a configurable interval of time be inserted between transmissions to the same next hop and, in particular, between fragments of a same datagram. In the case of half duplex interfaces, this inter-frame gap ensures that the next hop is done forwarding the previous frame and is capable of receiving the next one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8930]同じ時間の間隔を同じネクストホップ、特に同じデータグラムのフラグメント間の間に挿入することができます。半二重インタフェースの場合、このフレーム間ギャップは次のホップが前のフレームを転送し、次のホップを受信することができることを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of a mesh operating at a single frequency with omnidirectional antennas, a larger inter-frame gap is required to protect the frame against hidden terminal collisions with the previous frame of the same flow that is still progressing along a common path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
全方向性アンテナを用いて単一周波数で動作するメッシュの場合、フレーム間ギャップは、隠れた端子衝突に対してフレームを共通の経路に沿って進行中の同じフローの前のフレームと保護するために必要とされる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The inter-frame gap is useful even for unfragmented datagrams, but it becomes a necessity for fragments that are typically generated in a fast sequence and are all sent over the exact same path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレーム間ギャップは、折り返しされていないデータグラムに対してさえも有用であるが、それは典型的には高速シーケンスで生成されるフラグメントに対する必要性となり、全てまったく同じ経路を介して送信される。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--Congestion-Control">
4.3. Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 渋滞管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The inter-frame gap is the only protection that [RFC8930] imposes by default. This document enables grouping fragments in windows and requesting intermediate acknowledgments, so the number of in-flight fragments can be bounded. This document also adds an ECN mechanism that can be used to protect the network by adapting the size of the window, the size of the fragments, and/or the inter-frame gap.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレーム間ギャップは、デフォルトで[RFC8930]が課す唯一の保護です。このドキュメントは、Windowsでフラグメントをグループ化し、中間確認応答を要求することを可能にします。したがって、飛行中のフラグメントの数を制限することができます。この文書はまた、ウィンドウのサイズ、フラグメントのサイズ、および/またはフレーム間ギャップを適応させることによってネットワークを保護するために使用できるECNメカニズムを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification enables the fragmenting endpoint to apply a congestion control mechanism to tune those parameters, but the mechanism itself is out of scope. In most cases, the expectation is that most datagrams will require only a few fragments, and that only the last fragment will be acknowledged. A basic implementation of the fragmenting endpoint is NOT REQUIRED to vary the size of the window, the duration of the inter-frame gap, or the size of a fragment in the middle of the transmission of a datagram, and it MAY ignore the ECN signal or simply reset the window to 1 (see Appendix C) until the end of this datagram upon detecting a congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様では、フラグメント化エンドポイントがそれらのパラメータを調整するために輻輳制御メカニズムを適用することを可能にしますが、メカニズム自体は範囲外です。ほとんどの場合、期待はほとんどのデータグラムがいくつかのフラグメントしか必要としないことであり、最後のフラグメントだけが確認されます。断片化エンドポイントの基本的な実装は、ウィンドウのサイズ、フレーム間ギャップの持続時間、またはデータグラムの送信の中央のフラグメントのサイズを変える必要はなく、それはECN信号を無視することができる。または、輻輳を検出すると、このデータグラムの終わりまでウィンドウを1（付録Cを参照）にリセットするだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An intermediate node that experiences a congestion MAY set the ECN bit in a fragment, and the reassembling endpoint echoes the ECN bit at most once at the next opportunity to acknowledge back.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳を経験する中間ノードは、フラグメント内のECNビットを設定し、再組み立てエンドポイントは次の機会に答えるために一度にECNビットをエコーします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The size of the fragments is typically computed from the Link MTU to maximize the size of the resulting frames. The size of the window and the duration of the inter-frame gap SHOULD be configurable, to reduce the chances of congestion and to follow the general recommendations in [RFC8930], respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメントのサイズは通常、結果として得られるフレームのサイズを最大にするためにリンクMTUから計算されます。ウィンドウのサイズとフレーム間ギャップの持続時間は、それぞれ輻輳の可能性を減らし、[RFC8930]の一般的な推奨事項に従うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4--Modifying-the-First-Fragment">
4.4. Modifying the First Fragment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 最初のフラグメントを変更します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The compression of the hop limit, of the source and destination addresses in the IPv6 header, and of the Routing Header, which are all in the first fragment, may change en route in a route-over mesh LLN. If the size of the first fragment is modified, then the intermediate node MUST adapt the Datagram_Size, encoded in the Fragment_Size field, to reflect that difference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6ヘッダーのソースアドレスおよび宛先アドレスの圧縮、および最初のフラグメント内のルーティングヘッダーの圧縮は、経路上のメッシュLLN内のENルートを変更することができる。最初のフラグメントのサイズが変更された場合、中間ノードはその違いを反映するために、fragment_sizeフィールドにエンコードされたDatagram_Sizeを適応させる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intermediate node MUST also save the difference of Datagram_Size of the first fragment in the VRB and add it to the Fragment_Offset of all the subsequent fragments that it forwards for that datagram. In the case of a Source Routing Header 6LoWPAN Routing Header (SRH-6LoRH) [RFC8138] being consumed and thus reduced, that difference is negative, meaning that the Fragment_Offset is decremented by the number of bytes that were consumed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
中間ノードはまた、VRB内の最初のフラグメントのデータグラム拡大の違いを保存し、それをそのデータグラムに対して転送したすべての後続のフラグメントのfragment_offsetに追加する必要があります。ソースルーティングヘッダ6lowpanルーティングヘッダ（SRH  -  6138）[RFC8138]が消費され、したがって減少すると、その差は負であり、その差は消費されたバイト数によってデクリメントされることを意味する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--New-Dispatch-Types-and-Headers">
5. New Dispatch Types and Headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 新しいディスパッチタイプとヘッダー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an alternative to the 6LoWPAN fragmentation sub-layer [RFC4944] to emulate a Link MTU up to 2048 bytes for the upper layer, which can be the 6LoWPAN header compression sub-layer that is defined in &#34;Compression Format for IPv6 Datagrams over IEEE 802.15.4-Based Networks&#34; [RFC6282]. This specification also provides a reliable transmission of the fragments over a multi-hop 6LoWPAN route-over mesh network and a minimal congestion control to reduce the chances of congestion loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、6lowpanフラグメンテーションサブレイヤー[RFC4944]の代わりを指定して、「IPv6データグラムの圧縮形式」で定義されている6LOWPANヘッダー圧縮サブレイヤーである6LOWPANヘッダー圧縮サブレイヤーになることができます。IEEE 802.15.4ベースのネットワーク[RFC6282]。この仕様は、マルチホップ6LOWPANルートオーバーメッシュネットワーク上でのフラグメントの信頼性の高い送信と、輻輳損失の可能性を低減するための最小限の輻輳制御を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A 6LoWPAN Fragment Forwarding [RFC8930] technique derived from MPLS enables the forwarding of individual fragments across a 6LoWPAN route-over mesh without reassembly at each hop. The Datagram_Tag is used as a label; it is locally unique to the node that owns the source link-layer address of the fragment, so together the link-layer address and the label can identify the fragment globally within the lifetime of the datagram. A node may build the Datagram_Tag in its own locally significant way, as long as the chosen Datagram_Tag stays unique to the particular datagram for its lifetime. The result is that the label does not need to be globally unique, but it must be swapped at each hop as the source link-layer address changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPLSから導出された6LOWPANフラグメント転送[RFC8930]技術は、各ホップでの再組み立てなしで6LOWPANルートオーバーメッシュを横切る個々のフラグメントを転送することを可能にする。Datagram_tagはラベルとして使用されます。フラグメントのソースリンク層アドレスを所有するノードにローカルに固有のものであるので、リンク層アドレスとラベルはデータグラムの存続期間内にグローバルに識別することができます。選択されたDatagram_tagがその生涯のために特定のデータグラムに固有のままである限り、ノードはそれ自体でDatagram_tagを構築することができる。その結果、ラベルはグローバルに一意である必要がないが、ソースリンク層アドレスが変更されると各ホップでスワップされなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following sections, a Datagram_Tag extends the semantics defined in &#34;Fragmentation Type and Header&#34; (see Section 5.3 of [RFC4944]). The Datagram_Tag is a locally unique identifier for the datagram from the perspective of the sender. This means that the Datagram_Tag identifies a datagram uniquely in the network when associated with the source of the datagram. As the datagram gets forwarded, the source changes, and the Datagram_Tag must be swapped as detailed in [RFC8930].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクションでは、datagram_tagは &#34;fragmentation typeとheader&#34;で定義されているセマンティクスを拡張します（[RFC4944]のセクション5.3を参照）。datagram_tagは、送信者の観点からデータグラムのローカルに一意の識別子です。つまり、Datagram_tagは、データグラムのソースに関連付けられているときにネットワーク内でデータグラムを一意に識別することを意味します。データグラムが転送されると、ソースが変わり、Datagram_tagは[RFC8930]に詳述されているようにスワップする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification extends [RFC4944] with two new dispatch types for RFRAG and the RFRAG-ACK that is received back. The new 6LoWPAN dispatch types are taken from [RFC8025], as indicated in Table 1 of Section 9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、RFRAGの2つの新しいディスパッチタイプとRFRAG-ACKの2つの新しいディスパッチタイプとともに、受信されたRFC4944です。セクション9の表1に示すように、新しい6LOWPANディスパッチタイプが[RFC8025]から取得されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--Recoverable-Fragment-Dispatch-Type-and-Header">
5.1. Recoverable Fragment Dispatch Type and Header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 回復可能なフラグメントディスパッチタイプとヘッダー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this specification, if the packet is compressed, the size and offset of the fragments are expressed with respect to the compressed form of the packet, as opposed to the uncompressed (native) form.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本明細書では、パケットが圧縮されている場合、圧縮されていない（ネイティブ）フォームとは対照的に、フラグメントのサイズおよびオフセットは、パケットの圧縮形式に関して表現される。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The format of the fragment header is shown in Figure 1. It is the same for all fragments even though the Fragment_Offset is overloaded. The format has a length and an offset, as well as a Sequence field. This would be redundant if the offset was computed as the product of the Sequence by the length, but this is not the case. The position of a fragment in the reassembly buffer is correlated with neither the value of the Sequence field nor the order in which the fragments are received. This enables splitting fragments to cope with an MTU deduction; see the example of fragment Sequence 5 that is retried end to end as smaller fragment Sequences 13 and 14 in Section 6.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメントヘッダーのフォーマットを図1に示します.fragment_offsetがオーバーロードされていても、すべてのフラグメントで同じです。フォーマットは、シーケンスフィールドと同様に長さとオフセットを持ちます。オフセットがシーケンスの積として長さによって計算された場合、これは冗長になりますが、これはそうではありません。再構成バッファ内のフラグメントの位置は、シーケンスフィールドの値もフラグメントが受信される順序でも相関していません。これにより、分割フラグメントをMTU控除に対処することができます。セクション6.2では、より小さなフラグメント配列13および14として終了する断片配列5の例を参照のこと。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first fragment is recognized by a Sequence of 0; it carries its Fragment_Size and the Datagram_Size of the compressed packet before it is fragmented, whereas the other fragments carry their Fragment_Size and Fragment_Offset. The last fragment for a datagram is recognized when its Fragment_Offset and its Fragment_Size add up to the stored Datagram_Size of the packet identified by the sender link-layer address and the Datagram_Tag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第1の断片は0のシーケンスによって認識される。それは断片化される前に、そのfragment_sizeと圧縮パケットのデータグラムズサイズを描画しますが、他のフラグメントはそれらのfragment_sizeとfragment_offsetを持ちます。データグラムの最後のフラグメントは、そのfragment_offsetとそのfragment_sizeが、送信者リンク層アドレスとDatagram_tagによって識別されたパケットの格納されたデータグラム拡張に追加されるときに認識されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                              1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                       |1 1 1 0 1 0 0|E|  Datagram_Tag |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |X| Sequence|   Fragment_Size   |       Fragment_Offset         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-48">
X set == Ack-Request
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-48">
x set == ack-request.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Figure 1: RFRAG Dispatch Type and Header
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
図1：RFRAGディスパッチタイプとヘッダー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
X: 1 bit; Ack-Request. When set, the fragmenting endpoint requires an RFRAG Acknowledgment from the reassembling endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
x：1ビット。ACK要求設定すると、断片化エンドポイントは、再組み立てエンドポイントからRFRAG確認応答を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
E: 1 bit; Explicit Congestion Notification. The &#34;E&#34; flag is cleared by the source of the fragment and set by intermediate routers to signal that this fragment experienced congestion along its path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
E：1ビット。明示的な輻輳通知「E」フラグはフラグメントのソースによってクリアされ、中間ルータによって設定されてこのフラグメントがそのパスに沿って輻輳を経験したことを知らせる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fragment_Size: 10-bit unsigned integer. The size of this fragment in a unit that depends on link-layer technology. Unless overridden by a more specific specification, that unit is the byte, which allows fragments up to 1023 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragment_size：10ビットの符号なし整数。リンク層技術に依存するユニット内のこのフラグメントのサイズ。より具体的な仕様によって上書きされない限り、その単位はバイトです。これは最大1023バイトのフラグメントを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Datagram_Tag: 8 bits. An identifier of the datagram that is locally unique to the link-layer sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Datagram_tag：8ビットリンク層送信者にローカルに固有のデータグラムの識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sequence: 5-bit unsigned integer. The sequence number of the fragment in the acknowledgment bitmap. Fragments are numbered as [0..N], where N is in [0..31]. A Sequence of 0 indicates the first fragment in a datagram, but non-zero values are not indicative of the position in the reassembly buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス：5ビット符号なし整数。確認応答ビットマップ内のフラグメントのシーケンス番号。フラグメントは[0..N]として番号付けされ、ここでNは[0..31]にある。1のシーケンスはデータグラム内の最初のフラグメントを示しますが、ゼロ以外の値は再組み立てバッファ内の位置を示していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fragment_Offset: 16-bit unsigned integer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragment_offset：16ビットの符号なし整数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
When the Fragment_Offset is set to a non-zero value, its semantics depend on the value of the Sequence field as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
fragment_offsetがゼロ以外の値に設定されている場合、そのセマンティクスは次のようにシーケンスフィールドの値によって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* For a first fragment (i.e., with a Sequence of 0), this field indicates the Datagram_Size of the compressed datagram, to help the reassembling endpoint allocate an adapted buffer for the reception and reassembly operations. The fragment may be stored for local reassembly. Alternatively, it may be routed based on the destination IPv6 address. In that case, a VRB state must be installed as described in Section 6.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 第1のフラグメント（すなわち、0のシーケンスを有する）の場合、このフィールドは圧縮データグラムのデータグラムを示し、エンドポイントの再組み立てが受信および再構成演算のために適合されたバッファを割り当てるのを助ける。フラグメントは局所的な再構成のために記憶されてもよい。あるいは、宛先IPv6アドレスに基づいてルーティングされてもよい。その場合、6.1.1項の説明に従ってVRB状態をインストールする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* When the Sequence is not 0, this field indicates the offset of the fragment in the compressed form of the datagram. The fragment may be added to a local reassembly buffer or forwarded based on an existing VRB as described in Section 6.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* シーケンスが0ではない場合、このフィールドはデータグラムの圧縮形式のフラグメントのオフセットを示します。フラグメントは、セクション6.1.2に記載されているように、既存のVRBに基づいてローカルの再構成バッファに追加されてもよい。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A Fragment_Offset that is set to a value of 0 indicates an abort condition, and all states regarding the datagram should be cleaned up once the processing of the fragment is complete; the processing of the fragment depends on whether there is a VRB already established for this datagram and if the next hop is still reachable:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
値0に設定されているfragment_offsetは中止状態を示し、データグラムに関するすべての状態はフラグメントの処理が完了するとクリーンアップされる必要があります。フラグメントの処理は、このデータグラムに対してすでに確立されているVRBがあるかどうかによって、次のホップがまだ到達可能である場合に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* if a VRB already exists and the next hop is still reachable, the fragment is to be forwarded along the associated LSP as described in Section 6.1.2, without checking the value of the Sequence field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* VRBがすでに存在し、次のホップが依然として到達可能である場合、そのフラグメントは、シーケンスフィールドの値をチェックすることなく、セクション6.1.2で説明されているように関連するLSPに沿って転送されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* else, if the Sequence is 0, then the fragment is to be routed as described in Section 6.1.1, but no state is conserved afterwards. In that case, the session, if it exists, is aborted, and the packet is also forwarded in an attempt to clean up the next hops along the path indicated by the IPv6 header (possibly including a Routing Header).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* そうでなければ、シーケンスが0の場合、そのフラグメントはセクション6.1.1で説明されているようにルーティングされますが、その後状態は保存されません。その場合、セッションが存在する場合は中止され、パケットはIPv6ヘッダー（ある場合もルーティングヘッダーを含む）が示すパスに沿って次のホップをクリーンアップしようとする試みに転送されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* else (the Sequence is non-zero and either no VRB exists or the next hop is unavailable), the fragment cannot be forwarded or routed; the fragment is discarded and an abort RFRAG-ACK is sent back to the source as described in Section 6.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* そうでなければ（シーケンスはゼロ以外で、VRBが存在しないか、次のホップが使用できない）、フラグメントは転送またはルーティングされません。フラグメントは破棄され、ABORT RFRAG-ACKがセクション6.1.2に記載されているようにソースに送り返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recoverable Fragments are sequenced, and a bitmap is used in the RFRAG Acknowledgment to indicate the received fragments by setting the individual bits that correspond to their sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
回復可能なフラグメントがシーケンスされ、ビットマップがRFRAG確認応答で使用され、それらの配列に対応する個々のビットを設定することによって受信された断片を示す。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is no requirement on the reassembling endpoint to check that the received fragments are consecutive and non-overlapping. This may be useful, in particular, in the case where the MTU changes and a fragment Sequence is retried with a smaller Fragment_Size, with the remainder of the original fragment being retried with new Sequence values. The fragmenting endpoint knows that the datagram is fully received when the acknowledged fragments cover the whole datagram, which is implied by a FULL bitmap.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信したフラグメントが連続して非重複していることを確認するために、エンドポイントを再割り当てにする必要はありません。これは、特に、MTUが変更され、フラグメントシーケンスがより小さなfragment_sizeで再試行され、残りの部分は新しいシーケンス値で再試行される場合に有用であり得る。断片化エンドポイントは、認証されたフラグメントがデータグラム全体をカバーしたときにデータグラムが完全に受信され、これは全ビットマップによって暗黙的に受信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--RFRAG-Acknowledgment-Dispatch-Type-and-Header">
5.2. RFRAG Acknowledgment Dispatch Type and Header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. RFRAG承認ディスパッチタイプとヘッダー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification also defines a 4-byte RFRAG Acknowledgment Bitmap that is used by the reassembling endpoint to selectively confirm the reception of individual fragments. A given offset in the bitmap maps one to one with a given sequence number and indicates which fragment is acknowledged as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様はまた、個々のフラグメントの受信を選択的に確認するために再組み立てエンドポイントによって使用される4バイトのRFRAG確認応答ビットマップを定義します。ビットマップ内の与えられたオフセットは、あるシーケンス番号を持つ1対1にマッピングされ、次のようにどのフラグメントが確認されているかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           RFRAG Acknowledgment Bitmap                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        ^                 ^
        |                 |    bitmap indicating whether:
        |                 +----- Fragment with Sequence 9 was received
        +----------------------- Fragment with Sequence 0 was received
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Figure 2: RFRAG Acknowledgment Bitmap Encoding
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
図2：RFRAG肯定応答ビットマップエンコーディング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 3 shows an example RFRAG Acknowledgment Bitmap that indicates that all fragments from Sequence 0 to 20 were received, except for fragments 1, 2, and 16, which were lost and must be retried.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図3は、失われた断片1,2、および16を除いて、シーケンス0から20のすべてのフラグメントが受信されたことを示す例示的なRFRAG確認応答ビットマップを示す。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |1|0|0|1|1|1|1|1|1|1|1|1|1|1|1|1|0|1|1|1|1|0|0|0|0|0|0|0|0|0|0|0|
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Figure 3: Example RFRAG Acknowledgment Bitmap
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
図3：RFRAG確認応答ビットマップの例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RFRAG Acknowledgment Bitmap is included in an RFRAG Acknowledgment header, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFrag確認応答ビットマップは、次のようにRFrag確認応答ヘッダに含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                       |1 1 1 0 1 0 1|E|  Datagram_Tag |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          RFRAG Acknowledgment Bitmap (32 bits)                |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Figure 4: RFRAG Acknowledgment Dispatch Type and Header
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
図4：RFRAG確認応答ディスパッチタイプとヘッダー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
E: 1 bit; Explicit Congestion Notification Echo.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
E：1ビット。明示的な輻輳通知エコー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
When set, the fragmenting endpoint indicates that at least one of the acknowledged fragments was received with an Explicit Congestion Notification, indicating that the path followed by the fragments is subject to congestion. See more details in Appendix C.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
設定すると、断片化エンドポイントは、承認されたフラグメントの少なくとも1つが明示的な輻輳通知で受信され、その後のフラグメントが輻輳の対象となることを示します。付録Cの詳細を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Datagram_Tag: 8 bits; an identifier of the datagram that is locally unique to the link-layer recipient.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Datagram_tag：8ビットリンク層受信者にローカルに固有のデータグラムの識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFRAG Acknowledgment Bitmap: An RFRAG Acknowledgment Bitmap, whereby setting the bit at offset x indicates that fragment x was received, as shown in Figure 2. A NULL bitmap indicates that the fragmentation process is aborted. A FULL bitmap indicates that the fragmentation process is complete; all fragments were received at the reassembly endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFRAG肯定応答ビットマップ：rFRAG肯定応答ビットマップ。図2に示すように、オフセットXのビットを設定することを示す。フルビットマップは、フラグメンテーションプロセスが完了したことを示します。すべてのフラグメントは再組み立てエンドポイントで受信されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Fragment-Recovery">
6. Fragment Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. フラグメントの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RFRAG header is used to transport a fragment and optionally request an RFRAG-ACK that confirms the reception of one or more fragments. An RFRAG-ACK is carried as a standalone fragment header (i.e., with no 6LoWPAN payload) in a message that is propagated back to the fragmenting endpoint. To achieve this, each hop that performed an MPLS-like operation on fragments reverses that operation for the RFRAG-ACK by sending a frame from the next hop to the previous hop as known by its link-layer address in the VRB. The Datagram_Tag in the RFRAG-ACK is unique to the reassembling endpoint and is enough information for an intermediate hop to locate the VRB that contains the Datagram_Tag used by the previous hop and the Layer 2 information associated with it (interface and link-layer address).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFRAGヘッダは、フラグメントを輸送し、任意選択で1つ以上のフラグメントの受信を確認するRFRAG  -  ACKを要求するために使用される。RFRAG-ACKは、断片化エンドポイントに伝播されるメッセージに、スタンドアロンフラグメントヘッダー（すなわち6LOWPANペイロードのない）として搬送される。これを達成するために、フラグメントに対してMPLS様操作を実行した各ホップは、VRB内のリンク層アドレスによって知られているように、RFRAG  -  ACKの動作をrFRAG  -  ACKの動作を元に戻す。RFRAG-ACKのDatagram_tagは、再組み立てエンドポイントに固有のもので、前のホップで使用されているDATRAMGRAM_TAGを含むVRBを見つけるのに十分な情報であり、それに関連したレイヤ2の情報（インタフェースとリンク層アドレス）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fragmenting endpoint (i.e., the node that fragments the packets at the 6LoWPAN level) also controls the number of acknowledgments by setting the Ack-Request flag in the RFRAG packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
断片化エンドポイント（すなわち、6LOWPANレベルのパケットをフラグメント化するノード）も、RFRAGパケット内のack要求フラグを設定することによって肯定応答の数を制御する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fragmenting endpoint may set the Ack-Request flag on any fragment to perform congestion control by limiting the number of outstanding fragments, which are the fragments that have been sent but for which reception or loss was not positively confirmed by the reassembling endpoint. The maximum number of outstanding fragments is controlled by the Window-Size. It is configurable and may vary in case of ECN notification. When the endpoint that reassembles the packets at the 6LoWPAN level receives a fragment with the Ack-Request flag set, it MUST send an RFRAG-ACK back to the originator to confirm reception of all the fragments it has received so far.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
断片化エンドポイントは、送信されたフラグメントであるが、受信または損失が再割り当てエンドポイントによって積極的に確認されていなかった、輻輳制御を実行するために任意のフラグメント上にack要求フラグを設定することができる。未解決のフラグメントの最大数は、ウィンドウサイズによって制御されます。それは設定可能で、ECN通知の場合にはさまざまです。6LOWPANレベルのパケットにアセスポイントを再組み立てするエンドポイントがACK要求フラグセットを含むフラグメントを受信すると、これまでに受信したすべてのフラグメントの受信を確認するために、RFRAG-ACKをオリジネータに送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Ack-Request (&#34;X&#34;) set in an RFRAG marks the end of a window. This flag MUST be set on the last fragment if the fragmenting endpoint wishes to perform an automatic repeat request (ARQ) process for the datagram, and it MAY be set in any intermediate fragment for the purpose of congestion control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFRAGに設定されているACK要求（ &#34;x&#34;）はウィンドウの終わりをマークします。断片化エンドポイントがデータグラムに対して自動繰り返し要求（ARQ）プロセスを実行したい場合は、最後のフラグメントに設定する必要があり、輻輳制御の目的で任意の中間フラグメントに設定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This ARQ process MUST be protected by a Retransmission Timeout (RTO) timer, and the fragment that carries the &#34;X&#34; flag MAY be retried upon a timeout for a configurable number of times (see Section 7.1) with an exponential backoff. Upon exhaustion of the retries, the fragmenting endpoint may either abort the transmission of the datagram or resend the first fragment with an &#34;X&#34; flag set in order to establish a new path for the datagram and obtain the list of fragments that were received over the old path in the acknowledgment bitmap. When the fragmenting endpoint knows that an underlying link-layer mechanism protects the fragments, it may refrain from using the RFRAG Acknowledgment mechanism and never set the Ack-Request bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このARQプロセスは再送信タイムアウト（RTO）タイマーによって保護されなければならず、指数関数的なバックオフで構成可能な回数のタイムアウト時にタイムアウト時に再試行されてもよい。再試行の枯渇時に、断片化エンドポイントはデータグラムの送信を中止したり、データグラムのための新しいパスを確立したり、受信されたフラグメントのリストを取得するためにセットされた「x」フラグを持つ最初のフラグメントを再送することができます。確認応答ビットマップの古いパス。断片化エンドポイントが、基礎となるリンク層メカニズムがフラグメントを保護することを知っている場合、RFRAG確認応答メカニズムを使用し、ACK要求ビットを設定しないことを控えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reassembling endpoint MAY issue unsolicited acknowledgments. An unsolicited acknowledgment signals to the fragmenting endpoint that it can resume sending in case it has reached its maximum number of outstanding fragments. Another use is to inform the fragmenting endpoint that the reassembling endpoint aborted the processing of an individual datagram.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再組み立てエンドポイントは、迷惑な承認を発行することができます。それが最大数の未解決のフラグメント数に達した場合に送信を再開できる断片化エンドポイントへの迷惑な確認応答信号。もう1つの使用は、再組み立てエンドポイントが個々のデータグラムの処理を中止したことを断片化したエンドポイントに通知することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RFRAG Acknowledgment carries an ECN indication for congestion control (see Appendix C). The reassembling endpoint of a fragment with the &#34;E&#34; (ECN) flag set MUST echo that information at most once by setting the &#34;E&#34; (ECN) flag in the next RFRAG-ACK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFRAG確認応答は、輻輳制御のためのECN表示を担当します（付録Cを参照）。「E」（ECN）フラグセットを有するフラグメントのアンセミングエンドポイントは、次のRFRAG  -  ACKに「E」（ECN）フラグを設定することによって、その情報を最大1回要請する必要がある。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to protect the datagram, the fragmenting endpoint transfers a controlled number of fragments and flags to the last fragment of a window with an RFRAG Acknowledgment Request. The reassembling endpoint MUST acknowledge a fragment with the acknowledgment request bit set. If any fragment immediately preceding an acknowledgment request is still missing, the reassembling endpoint MAY intentionally delay its acknowledgment to allow in-transit fragments to arrive. Because it might defeat the round-trip time computation, delaying the acknowledgment should be configurable and not enabled by default.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データグラムを保護するために、断片化エンドポイントは、RFrag確認応答要求を使用して、制御された数のフラグメントとフラグをウィンドウの最後のフラグメントに転送します。再組み立てエンドポイントは、確認応答要求ビットセットを含むフラグメントを承認する必要があります。肯定応答要求の直前のフラグメントがまだ欠落している場合、再割り当てエンドポイントは意図的にその確認を遅らせて遷移のフラグメントを到着させることができる。往復時間の計算を倒す可能性があるため、確認応答を遅らせる必要があり、デフォルトでは有効になっていないはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When enough fragments are received to cover the whole datagram, the reassembling endpoint reconstructs the packet, passes it to the upper layer, sends an RFRAG-ACK on the reverse path with a FULL bitmap, and arms a short timer, e.g., on the order of an average round-trip time in the network. The FULL bitmap is used as opposed to a bitmap that acknowledges only the received fragments to let the intermediate nodes know that the datagram is fully received. As the timer runs, the reassembling endpoint absorbs the fragments that were still in flight for that datagram without creating a new state, acknowledging the ones that bear an Ack-Request with an FRAG Acknowledgment and the FULL bitmap. The reassembling endpoint aborts the communication if fragments with a matching source and Datagram-Tag continue to be received after the timer expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データグラム全体をカバーするのに十分な断片を受信すると、再組み立てエンドポイントはパケットを再構成し、それを上位層に渡し、完全なビットマップとの逆パスにRFRAG-ACKを送信し、短いタイマー、例えば順番に短いタイマーを駆動します。ネットワークにおける平均往復時間の。フルビットマップは、データグラムが完全に受信されていることを中間ノードに知らせるために受信したフラグメントのみを確認するビットマップとは対照的に使用されます。タイマーが実行されると、再組み立てエンドポイントは、新しい状態を作成せずにまだそのデータグラムのフライト内にあるフラグメントを吸収し、agk-requestおよびfull bitmapを使用してACK-Requestを獲得するものを認めます。一致するソースとデータグラムタグを持つフラグメントが期限切れになった後に継続して受信され続ける場合、再組み立てエンドポイントは通信を中止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that acknowledgments might consume precious resources, so the use of unsolicited acknowledgments SHOULD be configurable and not enabled by default.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認応答は貴重なリソースを消費する可能性があるため、迷惑な確認応答を使用することで、デフォルトで有効になっていない必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An observation is that streamlining the forwarding of fragments generally reduces the latency over the LLN mesh, providing room for retries within existing upper-layer reliability mechanisms. The fragmenting endpoint protects the transmission over the LLN mesh with a retry timer that is configured for a use case and may be adapted dynamically, e.g., according to the method detailed in [RFC6298]. It is expected that the upper-layer retry mechanism obeys the recommendations in [RFC8085], in which case a single round of fragment recovery should fit within the upper-layer recovery timers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
観察は、フラグメントの転送を合理化することは一般にLLNメッシュに対する待ち時間を減少させることであり、既存の上層信頼性メカニズム内の再試行のための部屋を提供する。断片化エンドポイントは、使用例のために構成されているリトライタイマと共にLLNメッシュを介して送信を保護し、例えば、[RFC6298]に詳述された方法に従って動的に適合させることができる。上位層の再試行メカニズムは[RFC8085]で推奨事項に従うことが予想され、その場合、単一ラウンドのフラグメントリカバリが上位リカバリタイマに適合するはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fragments MUST be sent in a round-robin fashion: the sender MUST send all the fragments for a first time before it retries any lost fragment; lost fragments MUST be retried in sequence, oldest first. This mechanism enables the receiver to acknowledge fragments that were delayed in the network before they are retried.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメントはラウンドロビンファッションで送信する必要があります。送信者は、失われたフラグメントを再試行する前に、すべてのフラグメントを初めて送信する必要があります。失われたフラグメントは、最も古く、最も古い順番に再試行する必要があります。このメカニズムにより、受信側はネットワーク内で遅延されたフラグメントを再試行する前に確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a single radio frequency is used by contiguous hops, the fragmenting endpoint SHOULD insert a delay between the frames (e.g., carrying fragments) that are sent to the same next hop. The delay SHOULD cover multiple transmissions so as to let a frame progress a few hops and avoid hidden terminal issues. This precaution is not required on channel hopping technologies such as Time-Slotted Channel Hopping (TSCH) [RFC6554], where nodes that communicate at Layer 2 are scheduled to send and receive, respectively, and different hops operate on different channels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一の無線周波数が連続ホップによって使用されるとき、フラグメント化エンドポイントは、同じネクストホップに送信されるフレーム（例えば、フラグメント）間の遅延を挿入するべきである。フレームが数ホップを進行させ、隠された端末の問題を回避できるように、遅延は複数の送信をカバーする必要があります。この予防措置は、タイムスロットチャネルホッピング（TSCH）[RFC6554]などのチャネルホッピング技術では必要ありません。ここで、レイヤ2で通信するノードはそれぞれ送信および受信がスケジュールされ、異なるホップが異なるチャンネルで動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1--Forwarding-Fragments">
6.1. Forwarding Fragments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 転送フラグメント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification inherits from [RFC8930] and proposes a Virtual Reassembly Buffer technique to forward fragments with no intermediate reconstruction of the entire datagram.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は[RFC8930]から継承し、データグラム全体の中間再構成なしでフラグメントを転送するための仮想再構成バッファ技術を提案します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IPv6 header MUST be placed in the first fragment in full to enable the routing decision. The first fragment is routed and creates an LSP from the fragmenting endpoint to the reassembling endpoint. The next fragments are label switched along that LSP. As a consequence, the next fragments can only follow the path that was set up by the first fragment; they cannot follow an alternate route. The Datagram_Tag is used to carry the label, which is swapped in each hop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルーティング決定を可能にするために、IPv6ヘッダーを最初のフラグメントに置く必要があります。最初のフラグメントはルーティングされ、断片化エンドポイントから再組み立てエンドポイントへLSPを作成します。次のフラグメントはそのLSPに沿ってラベルが切り替わります。結果として、次のフラグメントは、最初のフラグメントによって設定されたパスにのみ従うことができます。彼らは代替経路をたどることができません。Datagram_tagは、各ホップにスワップされているラベルを伝送するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the first fragment is too large for the path MTU, it will repeatedly fail and never establish an LSP. In that case, the fragmenting endpoint MAY retry the same datagram with a smaller Fragment_Size, in which case it MUST abort the original attempt and use a new Datagram_Tag for the new attempt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PATH MTUにとって最初のフラグメントが大きすぎると、それは繰り返し失敗し、LSPを確立することはありません。その場合、フラグメント化エンドポイントは同じデータグラムを小さなfragment_sizeで再試行することができ、その場合、元の試みを中止し、新しい試みのために新しいDatagram_tagを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1-1--Receiving-the-First-Fragment">
6.1.1. Receiving the First Fragment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1. 最初の断片を受け取る
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In route-over mode, the source and destination link-layer addresses in a frame change at each hop. The label that is formed and placed in the Datagram_Tag by the sender is associated with the source link-layer address and only valid (and temporarily unique) for that source link-layer address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルートオーバーモードでは、各ホップでフレームの変更内の送信元リンク層と宛先のリンク層がアドレス指定されます。送信者によって形成されデータグラムτに配置されたラベルは、ソースリンク層アドレスに関連付けられ、そのソースリンク層アドレスに対してのみ有効（そして一時的に一意）に関連付けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receiving the first fragment (i.e., with a Sequence of 0), an intermediate router creates a VRB and the associated LSP state indexed by the incoming interface, the previous-hop link-layer address, and the Datagram_Tag and forwards the fragment along the IPv6 route that matches the destination IPv6 address in the IPv6 header until it reaches the reassembling endpoint, as prescribed by [RFC8930]. The LSP state enables matching the next incoming fragments of a datagram to the abstract forwarding information of the next interface, source and next-hop link-layer addresses, and the swapped Datagram_Tag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第1のフラグメント（すなわち、0のシーケンスを有する）を受信すると、中間ルータは、着信インターフェース、前のホップ層アドレス、およびデータグラムτによって索引付けされたVRBおよび関連するLSP状態を作成し、その断片を転送する。[RFC8930]で規定されているように、IPv6ヘッダーの宛先IPv6アドレスと一致するIPv6ルート。LSP状態は、データグラムの次の着信フラグメントを次のインターフェイス、ソースリンク層アドレス、スワップされたDatagram_tagの抽象転送情報と一致させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, the router also forms a reverse LSP state indexed by the interface to the next hop, the link-layer address the router uses as source for that datagram, and the swapped Datagram_Tag. This reverse LSP state enables matching the tuple (interface, destination link-layer address, Datagram_Tag) found in an RFRAG-ACK to the abstract forwarding information (previous interface, previous link-layer address, Datagram_Tag) used to forward the RFRAG-ACK back to the fragmenting endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、ルータは、インターフェイスによってインデックスされたリバースLSP状態をネクストホップに挿入し、ルータがそのデータグラムのソースとして使用され、スワップされたDatagram_tagが使用されます。この逆LSP状態により、RFRAG-ACKで見つかったTUPLE（インタフェース、宛先リンク層アドレス、Datagram_tag）をRFRAG-ACKの転送に使用される抽象転送情報（前のインタフェース、前のリンクレイヤアドレス、Datagram_tag）にマッチングできます。断片化の終点に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1-2--Receiving-the-Next-Fragments">
6.1.2. Receiving the Next Fragments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2. 次のフラグメントを受信します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receiving the next fragment (i.e., with a non-zero Sequence), an intermediate router looks up an LSP indexed by the tuple (incoming interface, previous-hop link-layer address, Datagram_Tag) found in the fragment. If it is found, the router forwards the fragment using the associated VRB as prescribed by [RFC8930].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のフラグメントを受信すると（すなわち、非ゼロシーケンスを有する）、中間ルータは、フラグメント内に見つかったタプル（着信インターフェース、前のホップリンク層アドレス、データグラム名）によって索引付けされたLSPを検索する。見つかった場合、ルータは[RFC8930]で規定されているように関連するVRBを使用してフラグメントを転送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the VRB for the tuple is not found, the router builds an RFRAG-ACK to abort the transmission of the packet. The resulting message has the following information:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タプルのVRBが見つからない場合、ルータはパケットの送信を中止するためにRFRAG-ACKを構築します。結果のメッセージには次の情報があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The source and destination link-layer addresses are swapped from those found in the fragment, and the same interface is used
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ソースおよび宛先のリンク層アドレスはフラグメント内のものからスワップされ、同じインターフェイスが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The Datagram_Tag is set to the Datagram_Tag found in the fragment
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* datagram_tagは、フラグメント内にあるdatagram_tagに設定されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* A NULL bitmap is used to signal the abort condition
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ヌルビットマップは中止状態を知らせるために使用されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At this point, the router is all set and can send the RFRAG-ACK back to the previous router. The RFRAG-ACK should normally be forwarded all the way to the source using the reverse LSP state in the VRBs in the intermediate routers as described in the next section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この時点で、ルータはすべて設定されており、RFRAG-ACKを前のルータに送り返すことができます。次のセクションで説明されているように、RFRAG-ACKは通常、中間ルータ内のVRBSの逆LSP状態を使用してソースにすべて転送されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8930] indicates that the reassembling endpoint stores &#34;the actual packet data from the fragments received so far, in a form that makes it possible to detect when the whole packet has been received and can be processed or forwarded&#34;. How this is computed is implementation specific, but it relies on receiving all the bytes up to the Datagram_Size indicated in the first fragment. An implementation may receive overlapping fragments as the result of retries after an MTU change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8930]アプライを受信したフラグメントからの実際のパケットデータを、パケット全体が受信され、処理または転送できるようにすることができるようにするための形式で、再検査エンドポイントが「実際のパケットデータ」を記憶することを示している。これがどのように計算されているかは実装固有ですが、最初のフラグメントに示されているDatagram_Sizeまでのすべてのバイトを受信することに依存しています。実装は、MTUの変更後の再試行の結果として重複フラグメントを受信することができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2--Receiving-RFRAG-Acknowledgments">
6.2. Receiving RFRAG Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. RFRAG承認を受信します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receipt of an RFRAG-ACK, the router looks up a reverse LSP indexed by the interface and destination link-layer address of the received frame and the received Datagram_Tag in the RFRAG-ACK. If it is found, the router forwards the fragment using the associated VRB as prescribed by [RFC8930], but it uses the reverse LSP so that the RFRAG-ACK flows back to the fragmenting endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFRAG  -  ACKを受信すると、ルータは、受信フレームのインタフェースおよび宛先リンク層アドレスおよびRFRAG  -  ACK内の受信データグラムτによって索引付けされた逆LSPを検索する。見つかった場合、ルータは[RFC8930]で規定されているように関連するVRBを使用してフラグメントを転送しますが、RFRAG-ACKが断片化エンドポイントに戻ってリバースLSPを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the reverse LSP is not found, the router MUST silently drop the RFRAG-ACK message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リバースLSPが見つからない場合、ルータはRFRAG-ACKメッセージを黙ってドロップする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Either way, if the RFRAG-ACK indicates that the fragment was entirely received (FULL bitmap), it arms a short timer, and upon timeout, the VRB and all the associated states are destroyed. Until the timer elapses, fragments of that datagram may still be received, e.g., if the RFRAG-ACK was lost on the path back, and the source retried the last fragment. In that case, the router generates an RFRAG-ACK with a FULL bitmap back to the fragmenting endpoint if an acknowledgment was requested; else, it silently drops the fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらの方法でも、rfrag-ackがフラグメントが完全に受信されたことを示している場合（フルビットマップ）、それは短いタイマーをアームし、タイムアウト時に、VRBとすべての関連状態が破壊されます。タイマーが経過するまで、そのデータグラムのフラグメントは、rfrag-ackがパス上に失われた場合、およびソースが最後のフラグメントを再試行するかもしれません。その場合、肯定応答が要求された場合、ルータはフルビットマップを断片化エンドポイントに戻すRFRAG-ACKを生成します。そうでなければ、それは静かに断片を落とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification does not provide a method to discover the number of hops or the minimal value of MTU along those hops. In a typical case, the MTU is constant and is the same across the network. But should the minimal MTU along the path decrease, it is possible to retry a long fragment (say a Sequence of 5) with several shorter fragments with a Sequence that was not used before (e.g., 13 and 14). Fragment 5 is marked as abandoned and will not be retried anymore. Note that when this mechanism is in place, it is hard to predict the total number of fragments that will be needed or the final shape of the bitmap that would cover the whole packet. This is why the FULL bitmap is used when the reassembling endpoint gets the whole datagram regardless of which fragments were actually used to do so. Intermediate nodes will know unambiguously that the process is complete. Note that Path MTU Discovery is out of scope for this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、ホップ数またはそれらのホップに沿ってMTUの最小値を発見する方法を提供しません。典型的な場合では、MTUは一定であり、ネットワーク全体で同じです。しかし、経路に沿った最小のMTUが減少する場合、前に（例えば、13および14）使用されなかった配列を有するいくつかの短い断片を有する長いフラグメント（5のシーケンス）を再試行することが可能である。フラグメント5は放棄されたとマークされており、もう再試行されません。このメカニズムが整っているときは、パケット全体をカバーするビットマップの最終形状または最終形状の合計数を予測するのが困難です。これが、どのフラグメントが実際に使用されているかにかかわらず、再組み立てエンドポイントがデータグラム全体を取得するときにフルビットマップが使用される理由です。中間ノードは、プロセスが完了したことを明確に知っています。PATU MTUディスカバリーはこの文書の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3--Aborting-the-Transmission-of-a-Fragmented-Packet">
6.3. Aborting the Transmission of a Fragmented Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. 断片化されたパケットの送信を中止する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reset is signaled on the forward path with a pseudo fragment that has the Fragment_Offset set to 0. The sender of a reset SHOULD also set the Sequence and Fragment_Size field to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リセットは、Fragment_Offsetが0に設定されている疑似フラグメントを使用して順方向経路上にシグナリングされます。リセットの送信者は、シーケンスとfragment_sizeフィールドも0に設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the fragmenting endpoint or a router on the path decides that a packet should be dropped and the fragmentation process aborted, it generates a reset pseudo fragment and forwards it down the fragment path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
断片化エンドポイントまたはパス上のルータがドロップされ、フラグメンテーションプロセスが中止されるべきであることを決定すると、リセット疑似フラグメントを生成し、それをフラグメントパスを転送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each router along the path forwards the pseudo fragment in turn based on the VRB state. If an acknowledgment is not requested, the VRB and all associated states are destroyed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
経路に沿った各ルータは、VRB状態に基づいて擬似フラグメントを順番に転送します。確認応答が要求されていない場合は、VRBとすべての関連状態が破棄されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon reception of the pseudo fragment, the reassembling endpoint cleans up all resources for the packet associated with the Datagram_Tag. If an acknowledgment is requested, the reassembling endpoint responds with a NULL bitmap.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
疑似フラグメントを受信すると、reacsemblingエンドポイントはDatagram_tagに関連付けられているパケットのすべてのリソースをクリーンアップします。確認応答が要求されている場合は、再組み立てエンドポイントはNULLビットマップで応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On the other hand, the reassembling endpoint might need to abort the processing of a fragmented packet for internal reasons, for instance, if it is out of reassembly buffers, already uses all 256 possible values of the Datagram_Tag, or keeps receiving fragments beyond a reasonable time while it considers that this packet is already fully reassembled and was passed to the upper layer. In that case, the reassembling endpoint SHOULD indicate so to the fragmenting endpoint with a NULL bitmap in an RFRAG-ACK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方、再組み立てエンドポイントは、内部理由で断片化されたパケットの処理を中止する必要があるかもしれません。たとえば、再組み立てバッファの不可能な場合は、既にDatagram_tagのすべての256個の可能な値を使用するか、または妥当ながらフラグメントを受け取ります。このパケットがすでに完全に再組み立てされていると考える間、上位層に渡されたことがわかります。その場合、Reassemblingエンドポイントは、RFRAG-ACKのNULLビットマップを使用してフラグメント化エンドポイントに指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RFRAG-ACK is forwarded all the way back to the source of the packet and cleans up all resources on the path. Upon an acknowledgment with a NULL bitmap, the fragmenting endpoint MUST abort the transmission of the fragmented datagram with one exception: in the particular case of the first fragment, it MAY decide to retry via an alternate next hop instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFRAG-ACKはパケットの送信元に戻り、パス上のすべてのリソースを消去します。NULLビットマップを使用して確認応答すると、フラグメント化エンドポイントは、1つの例外を持つフラグメント化されたデータグラムの送信を中止しなければなりません。最初のフラグメントの特定のケースでは、代わりに代替の次のホップを介して再試行することを決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4--Applying-Recoverable-Fragmentation-along-a-Diverse-Path">
6.4. Applying Recoverable Fragmentation along a Diverse Path
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. 多様な経路に沿って回収可能な断片化を適用する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The text above can be read with the assumption of a serial path between a source and a destination. The IPv6 over the TSCH mode of IEEE 802.15.4e (6TiSCH) architecture (see Section 4.5.3 of [6TiSCH]) defines the concept of a Track that can be a complex path between a source and a destination with Packet ARQ, Replication, Elimination, and Overhearing (PAREO) along the Track. This specification can be used along any subset of the complex Track where the first fragment is flooded. The last RFRAG Acknowledgment is flooded on that same subset in the reverse direction. Intermediate RFRAG Acknowledgments can be flooded on any sub-subset of that reverse subset that reaches back to the source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のテキストは、ソースと宛先の間のシリアルパスを想定して読み取ることができます。IEEE 802.15.4E（6Tisch）アーキテクチャのTSCHモード（[6tisch）のTSCHモードでIPv6（[6tisch]のセクション4.5.3を参照）は、パケットARQ、レプリケーション、レプリケーションを使用して、ソースと宛先の間の複雑なパスになることができるトラックの概念を定義します。トラックに沿った除去、過熱（パレオ）。この仕様は、最初のフラグメントがフラッディングされている複素トラックの任意のサブセットに沿って使用できます。最後のRFRAG確認応答は、その同じサブセットに逆方向にあふれています。中間RFRAG肯定応答は、ソースに戻るその逆のサブセットの任意のサブサブセットにフラッディングできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Management-Considerations">
7. Management Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 管理に関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification extends [RFC8930] and requires the same parameters in the reassembling endpoint and on intermediate nodes. There is no new parameter as echoing ECN is always on. These parameters typically include the reassembly timeout at the reassembling endpoint, an inactivity cleanup timer on the intermediate nodes, and the number of messages that can be processed in parallel in all nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は[RFC8930]を拡張し、再組み立てエンドポイントと中間ノードに同じパラメータを必要とします。エコーECNが常にオンになっているので、新しいパラメータはありません。これらのパラメータは通常、再組み立てエンドポイントでの再構成タイムアウト、中間ノード上の非アクティブクリーンアップタイマ、およびすべてのノードで並列に処理できるメッセージの数を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The configuration settings introduced by this specification only apply to the fragmenting endpoint, which is in full control of the transmission. LLNs vary a lot in size (there can be thousands of nodes in a mesh), in speed (from 10 Kbps to several Mbps at the PHY layer), in traffic density, and in optimizations that are desired (e.g., the selection of a Routing Protocol for LLNs (RPL) [RFC6550] Objective Function [RFC6552] impacts the shape of the routing graph).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様によって導入された構成設定は、送信を完全に制御する断片化エンドポイントにのみ適用されます。LLNSは大きさが多い（メッシュ内に数千のノードがある可能性がある）、トラフィック密度、および望まれる最適化（例えば、の選択など）の速度（10kbpsから数Mbpsまで）LLNS（RPL）のルーティングプロトコル[RFC6550]目標関数[RFC6552]は、ルーティンググラフの形状に影響します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For that reason, only very generic guidance can be given on the settings of the fragmenting endpoint and on whether complex algorithms are needed to perform congestion control or to estimate the round-trip time. To cover the most complex use cases, this specification enables the fragmenting endpoint to vary the fragment size, the window size, and the inter-frame gap based on the number of losses, the observed variations of the round-trip time, and the setting of the ECN bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのため、断片化エンドポイントの設定と、複雑なアルゴリズムが輻輳制御を実行するため、または往復時間を推定するのかについて、非常に一般的なガイダンスのみを与えることができます。最も複雑なユースケースをカバーするために、この仕様では、フラグメント化エンドポイントは、損失数、幅の幅の変動、往復時間のバリエーション、および設定に基づいて、フラグメントサイズ、ウィンドウサイズ、およびフレーム間ギャップを変えることができます。ECNビットの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1--Protocol-Parameters">
7.1. Protocol Parameters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. プロトコルパラメータ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The management system SHOULD be capable of providing the parameters listed in this section, and an implementation MUST abide by those parameters and, in particular, never exceed the minimum and maximum configured boundaries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
管理システムはこのセクションにリストされているパラメータを提供することができ、実装はそれらのパラメータによって従う必要があり、特に最小および最大構成の境界を超えないようにしてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation should consider the generic recommendations from the IETF in the matter of congestion control and rate management for IP datagrams in [RFC8085]. An implementation may perform congestion control by using a dynamic value of the window size (Window_Size), adapting the fragment size (Fragment_Size), and potentially reducing the load by inserting an inter-frame gap that is longer than necessary. In a large network where nodes contend for the bandwidth, a larger Fragment_Size consumes less bandwidth but also reduces fluidity and incurs higher chances of loss in transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、[RFC8085]のIPデータグラムの輻輳制御とレート管理の問題のIETFからの一般的な推奨事項を考慮する必要があります。実装は、ウィンドウサイズ（window_size）の動的値を使用し、フラグメントサイズ（fragment_size）を適合させ、必要以上に長いフレーム間ギャップを挿入することによって負荷を潜在的に低減することによって輻輳制御を実行することができる。ノードが帯域幅に競合する大規模ネットワークでは、より大きなフラグメント_SIZEは帯域幅が少ないだけでなく、流動性を低下させ、伝送中の損失の可能性が高くなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is controlled by the following parameters:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは次のパラメータによって制御されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inter-frame gap: The inter-frame gap indicates the minimum amount of time between transmissions. The inter-frame gap controls the rate at which fragments are sent, the ratio of air time, and the amount of memory in intermediate nodes that a particular datagram will use. It can be used as a flow control, a congestion control, and/ or a collision control measure. It MUST be set at a minimum to a value that protects the propagation of one transmission against collision with next [RFC8930]. In a wireless network that uses the same frequency along a path, this may represent the time for a frame to progress over multiple hops (see more in Section 4.2). It SHOULD be augmented beyond this as necessary to protect the network against congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレーム間ギャップ：フレーム間ギャップは、送信間の最小時間を示します。フレーム間ギャップは、特定のデータグラムが使用する中間ノードにおけるフラグメント、空気時間の比、およびメモリの量を制御する。それはフロー制御、輻輳制御、および/または衝突制御尺度として使用することができる。次の[RFC8930]との衝突に対する1つの伝送の伝播を保護する値まで最小限に設定する必要があります。パスに沿って同じ周波数を使用する無線ネットワークでは、これはフレームの時間を複数のホップにわたって進行させる時間を表すことができる（セクション4.2を参照）。ネットワークを輻輳から保護するために必要に応じてこれを超えて増強する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MinFragmentSize: The MinFragmentSize is the minimum value for the Fragment_Size. It MUST be lower than the minimum value of smallest 1-hop MTU that can be encountered along the path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MinFragmentsize：MinFragmentsizeはfragment_sizeの最小値です。パスに沿って遭遇する可能性がある最小1ホップMTUの最小値より低い必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OptFragmentSize: The OptFragmentSize is the value for the Fragment_Size that the fragmenting endpoint should use to start with. It is greater than or equal to MinFragmentSize. It is less than or equal to MaxFragmentSize. For the first fragment, it must account for the expansion of the IPv6 addresses and of the Hop Limit field within MTU. For all fragments, it is a balance between the expected fluidity and the overhead of link-layer and 6LoWPAN headers. For a small MTU, the idea is to keep it close to the maximum, whereas for larger MTUs, it might make sense to keep it short enough so that the duty cycle of the transmitter is bounded, e.g., to transmit at least 10 frames per second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OptFragmentsize：OptFragmentsizeは、フラグメント化されたエンドポイントが起動するために使用するfragment_sizeの値です。それはMinFragansize以上です。それはMaxFragmentsize以下のものです。最初のフラグメントでは、IPv6アドレスの拡張とMTU内のホップリミットフィールドの拡張を説明する必要があります。すべてのフラグメントについては、予想される流動性とリンク層と6lowpanヘッダーのオーバーヘッドのバランスです。小さなMTUの場合、その考えはそれを最大に近づけることですが、より大きなMTUのためには、トランスミッタのデューティサイクルが境界が制限されるように理性があるかもしれません。第二。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MaxFragmentSize: The MaxFragmentSize is the maximum value for the Fragment_Size. It MUST be lower than the maximum value of the smallest 1-hop MTU that can be encountered along the path. A large value augments the chances of buffer bloat and transmission loss. The value MUST be less than 512 if the unit that is defined for the PHY layer is the byte.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MaxFragmentsize：maxFragmentsizeはfragment_sizeの最大値です。パスに沿って遭遇する可能性がある最小の1ホップMTUの最大値より低くなければなりません。大きな値は、バッファぼけと伝送損失の可能性を増大させる。PHYレイヤに定義されている単位がバイトである場合、値は512未満でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Window_Size: The Window_Size MUST be at least 1 and less than 33.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
window_size：window_sizeは1以上33未満でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* If the round-trip time is known, the Window_Size SHOULD be set to the round-trip time divided by the time per fragment; that is, the time to transmit a fragment plus the inter-frame gap.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 往復時間がわかっている場合、window_sizeはフラグメントあたりの時間で割った往復時間に設定する必要があります。つまり、フラグメントとフレーム間ギャップを送信する時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Otherwise:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
さもないと：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* A window_size of 32 indicates that only the last fragment is to be acknowledged in each round. This is the RECOMMENDED value in a half-duplex LLN where the fragment acknowledgment consumes roughly the same bandwidth on the same links as the fragments themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 32のwindow_sizeは、最後のフラグメントのみが各ラウンドで確認されることを示します。これは、フラグメント確認応答がフラグメント自体と同じリンク上でほぼ同じ帯域幅を消費する半二重LLNの推奨値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* If it is set to a smaller value, more acks are generated. In a full-duplex network, the load on the forward path will be lower, and a small value of 3 SHOULD be configured.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 小さい値に設定されている場合は、より多くのACKが生成されます。全二重ネットワークでは、順方向パスの負荷が低くなり、3つの小さい値を設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation may perform its estimate of the RTO or use a configured one. The ARQ process is controlled by the following parameters:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装はRTOの推定値を実行するか、または設定されたものを使用することができる。ARQプロセスは、次のパラメータによって制御されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MinARQTimeOut: The minimum amount of time a node should wait for an RFRAG Acknowledgment before it takes the next action. It MUST be more than the maximum expected round-trip time in the respective network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MinarqTimeout：ノードが次のアクションを実行する前に、ノードがRFRAG確認を待機する最小時間。それはそれぞれのネットワークにおける最大予想往復時間以上でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OptARQTimeOut: The initial value of the RTO, which is the amount of time that a fragmenting endpoint should wait for an RFRAG Acknowledgment before it takes the next action. It is greater than or equal to MinARQTimeOut. It is less than or equal to MaxARQTimeOut. See Appendix C for recommendations on computing the round-trip time. By default, a value of 3 times the maximum expected round-trip time in the respective network is RECOMMENDED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OptarqTimeout：RTOの初期値。フラグメントエンドポイントが次のアクションを取る前にRFRAG確認応答を待つ時間です。それはMinarqTimeout以上です。maxarqtimeout以下である。往復時間の計算に関する推奨事項については、付録Cを参照してください。デフォルトでは、各ネットワーク内の最大予想往復時間の3倍の値をお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MaxARQTimeOut: The maximum amount of time a node should wait for the RFRAG Acknowledgment before it takes the next action. It must cover the longest expected round-trip time and be several times less than the timeout that covers the recomposition buffer at the reassembling endpoint, which is typically on the order of the minute. An upper bound can be estimated to ensure that the datagram is either fully transmitted or dropped before an upper layer decides to retry it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxarqtimeout：ノードが次のアクションを取得する前に、ノードがRFRAG確認応答を待つ最大時間。それは最長の予想される往復時間をカバーしなければなりません、そして、再組み立てエンドポイントで再構成バッファをカバーするタイムアウトより数倍小さい、これは通常は分のオーダーです。上位層が再試行することを決定する前にデータグラムが完全に送信またはドロップされるようにするために、上限を推定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MaxFragRetries: The maximum number of retries for a particular fragment. A default value of 3 is RECOMMENDED. An upper bound can be estimated to ensure that the datagram is either fully transmitted or dropped before an upper layer decides to retry it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MaxFragraties：特定のフラグメントの再試行回数の最大数。デフォルト値3をお勧めします。上位層が再試行することを決定する前にデータグラムが完全に送信またはドロップされるようにするために、上限を推定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MaxDatagramRetries: The maximum number of retries from scratch for a particular datagram. A default value of 1 is RECOMMENDED. An upper bound can be estimated to ensure that the datagram is either fully transmitted or dropped before an upper layer decides to retry it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MaxDatagramRetries：特定のデータグラムのスクラッチからの再試行回数。デフォルト値1をお勧めします。上位層が再試行することを決定する前にデータグラムが完全に送信またはドロップされるようにするために、上限を推定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation may be capable of performing congestion control based on ECN; see Appendix C. This is controlled by the following parameter:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、ECNに基づいて輻輳制御を実行することができる。付録Cを参照してください。これは次のパラメータによって制御されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UseECN: Indicates whether the fragmenting endpoint should react to ECN. The fragmenting endpoint may react to ECN by varying the Window_Size between MinWindowSize and MaxWindowSize, varying the Fragment_Size between MinFragmentSize and MaxFragmentSize, and/or increasing or reducing the inter-frame gap. With this specification, if UseECN is set and a fragmenting endpoint detects a congestion, it may apply a congestion control method until the end of the datagram, whereas if UseECN is reset, the endpoint does not react to congestion. Future specifications may provide additional parameters and capabilities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
USEECN：フラグメント化エンドポイントがECNに反応するかどうかを示します。断片化エンドポイントは、MinWindowsizeとMaxWindowsizeとの間のwindow_sizeを変えることによってECNに反応して、MinFragmentsizeとMaxFragmentsizeとの間のfragment_sizeを変え、フレーム間ギャップを増減させることができます。この仕様では、useecnが設定され、断片化エンドポイントが輻輳を検出した場合、データグラムの終わりまで輻輳制御方法を適用することができますが、USEECNがリセットされている場合、エンドポイントは輻輳に反応しません。将来の仕様は、追加のパラメータと機能を提供し得る。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-2--Observing-the-Network">
7.2. Observing the Network
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. ネットワークを観察する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The management system should monitor the number of retries and ECN settings that can be observed from the perspective of the fragmenting endpoint with respect to the reassembling endpoint and reciprocally. It may then tune the optimum size of Fragment_Size and of Window_Size, OptFragmentSize, and OptWindowSize, respectively, at the fragmenting endpoint towards a particular reassembling endpoint, which is applicable to the next datagrams. It will preferably tune the inter-frame gap to increase the spacing between fragments of the same datagram and reduce the buffer bloat in the intermediate node that holds one or more fragments of that datagram.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
管理システムは、再組み立てエンドポイントに関して断片化エンドポイントの観点から見た再試行およびECN設定の数を監視する必要があります。次に、フラグメント化されたエンドポイントに断片化されたエンドポイントで、Fragment_Sizeの最適なサイズとwindow_size、optfragmentsize、およびoptwindowsizeを調整することができます。これは次のデータグラムに適用されます。それは、同じデータグラムのフラグメント間の間隔を増加させ、そのデータグラムの1つまたは複数のフラグメントを保持する中間ノード内のバッファぼりを減らすために、フレーム間ギャップを調整することが好ましい。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Security-Considerations">
8. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an instantiation of a 6LFF technique and inherits from the generic description in [RFC8930]. The considerations in the Security Considerations section of [RFC8930] equally apply to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは6LFFテクニックのインスタンス化を指定し、[RFC8930]の一般的な説明から継承します。[RFC8930]の[セキュリティ上の考慮事項]セクションの考慮事項は、この文書にも同様に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to the threats detailed therein, an attacker that is on path can prematurely end the transmission of a datagram by sending a RFRAG Acknowledgment to the fragmenting endpoint. It can also cause extra transmissions of fragments by resetting bits in the RFRAG Acknowledgment Bitmap and of RFRAG Acknowledgments by forcing the Ack-Request bit in fragments that it forwards.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そこに詳述されている脅威に加えて、経路上にある攻撃者は、断片化エンドポイントにRFRAG確認応答を送信することによってデータグラムの送信を時期尚早に終了させることができる。それはまた、RFRAG確認応答ビットマップのビットをリセットすることによってフラグメントの追加的な送信を引き起こす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As indicated in [RFC8930], secure joining and link-layer security are REQUIRED to protect against those attacks, as the fragmentation protocol does not include any native security mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8930]に示されているように、断片化プロトコルにはネイティブのセキュリティメカニズムが含まれていないため、安全な参加とリンク層のセキュリティはこれらの攻撃から保護するために必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification does not recommend a particular algorithm for the estimation of the duration of the RTO that covers the detection of the loss of a fragment with the &#34;X&#34; flag set; regardless, an attacker on the path may slow down or discard packets, which in turn can affect the throughput of fragmented packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、「X」フラグセットを用いたフラグメントの損失の検出を網羅するRTOの持続時間を推定するための特定のアルゴリズムを推奨するものではない。とにかく、パス上の攻撃者はパケットを遅くまたは破棄することができ、それは断片化されたパケットのスループットに影響を与える可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Compared to [RFC4944], this specification reduces the Datagram_Tag to 8 bits, and the tag wraps faster than with [RFC4944]. But for a constrained network where a node is expected to be able to hold only one or a few large packets in memory, 256 is still a large number. Also, the acknowledgment mechanism allows cleaning up the state rapidly once the packet is fully transmitted or aborted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4944]と比較して、この仕様はDatagram_tagを8ビットに縮小し、タグは[RFC4944]よりも速くラップされます。しかし、ノードがメモリ内の1つか数つの大きなパケットだけを保持できるようになると予想される制約付きネットワークでは、256はまだ大きい数です。また、肯定応答メカニズムは、パケットが完全に送信または中止されると、状態を迅速にクリーンアップすることを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The abstract Virtual Recovery Buffer from [RFC8930] may be used to perform a Denial-of-Service (DoS) attack against the intermediate routers since the routers need to maintain a state per flow. The particular VRB implementation technique described in [LWIG-FRAG] allows realigning which data goes in which fragment; this causes the intermediate node to store a portion of the data, which adds an attack vector that is not present with this specification. With this specification, the data that is transported in each fragment is conserved, and the state to keep does not include any data that would not fit in the previous fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8930]からの抽象仮想回復バッファを使用して、ルータはフローごとに状態を維持する必要があるため、中間ルータに対してサービス拒否（DOS）攻撃を実行できます。[lwig-frag]で説明されている特定のVRB実装手法では、どのデータがどのフラグメントになるかを実現できます。これにより、中間ノードはデータの一部を格納し、この仕様には存在しない攻撃ベクトルを追加します。この仕様では、各フラグメントで転送されるデータは保存され、保持する状態には、前のフラグメントに収まらないデータは含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--IANA-Considerations">
9. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document allocates two patterns for a total of four dispatch values for Recoverable Fragments from the &#34;Dispatch Type Field&#34; registry that was created by [RFC4944] and reformatted by &#34;IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Paging Dispatch&#34; [RFC8025].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、[RFC4944]によって作成され、[RFC4944]によって作成され、「IPv6を介した[IPv6）によって作成された「Dispatch Typeフィールド」レジストリの合計4つのパターンを割り当てます。[6LOWPAN）ページングディスパッチ &#34;RFC8025]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------+------+----------------------------------+-----------+
   | Bit Pattern | Page | Header Type                      | Reference |
   +-------------+------+----------------------------------+-----------+
   | 11 10100x   | 0    | RFRAG - Recoverable Fragment     | RFC 8931  |
   +-------------+------+----------------------------------+-----------+
   | 11 10100x   | 1-14 | Unassigned                       |           |
   +-------------+------+----------------------------------+-----------+
   | 11 10100x   | 15   | Reserved for Experimental Use    | RFC 8025  |
   +-------------+------+----------------------------------+-----------+
   | 11 10101x   | 0    | RFRAG-ACK - RFRAG                | RFC 8931  |
   |             |      | Acknowledgment                   |           |
   +-------------+------+----------------------------------+-----------+
   | 11 10101x   | 1-14 | Unassigned                       |           |
   +-------------+------+----------------------------------+-----------+
   | 11 10101x   | 15   | Reserved for Experimental Use    | RFC 8025  |
   +-------------+------+----------------------------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Table 1: Additional Dispatch Value Bit Patterns
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
表1：追加のディスパッチ値ビットパターン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--References">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-1--Normative-References">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] BRADNER、S、「RFCSで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;https：//www.rfc-editor.org/info/RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4919] Kushalnagar, N., Montenegro, G., and C. Schumacher, &#34;IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs): Overview, Assumptions, Problem Statement, and Goals&#34;, RFC 4919, DOI 10.17487/RFC4919, August 2007, &lt;https://www.rfc-editor.org/info/rfc4919&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4919] Kushalnagar、N.、Montenegro、G.、Schumacher、C. Schumacher、「低電力無線パーソナルエリアネットワーク（6lowpans）：概要、仮定、問題ステートメント、および目標、RFC 4919、DOI 10.17487 / RFC49192007年8月、&lt;https：//www.rfc-editor.org/info/rfc4919&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4944] Montenegro, G., Kushalnagar, N., Hui, J., and D. Culler, &#34;Transmission of IPv6 Packets over IEEE 802.15.4 Networks&#34;, RFC 4944, DOI 10.17487/RFC4944, September 2007, &lt;https://www.rfc-editor.org/info/rfc4944&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4944]モンテネグロ、G.、Kushalnagar、N.、Hui、J.、およびD.Culler、「IEEE 802.15.4ネットワーク上のIPv6パケットの送信」、RFC 4944、DOI 10.17487 / RFC4944、2007年9月、&lt;https：//www.rfc-editor.org/info/rfc4944&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6282] Hui, J., Ed. and P. Thubert, &#34;Compression Format for IPv6 Datagrams over IEEE 802.15.4-Based Networks&#34;, RFC 6282, DOI 10.17487/RFC6282, September 2011, &lt;https://www.rfc-editor.org/info/rfc6282&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6282] HUI、J.、ED。2011年9月、2011年9月、2011年9月、&lt;https：//www.rfc-editor.org/info/rfc6282、&lt;https：//www.rfc-editor.org/info/rfc6282&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, &#34;Computing TCP&#39;s Retransmission Timer&#34;, RFC 6298, DOI 10.17487/RFC6298, June 2011, &lt;https://www.rfc-editor.org/info/rfc6298&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6298] Paxson、V.、Allman、M.、Chu、J.、およびM.Sargent、「コンピューティングTCPの再送信タイマー」、RFC 6298、DOI 10.17487 / RFC6298、2011年6月、&lt;https：///www.rfc-editor.org/info/rfc6298&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6606] Kim, E., Kaspar, D., Gomez, C., and C. Bormann, &#34;Problem Statement and Requirements for IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Routing&#34;, RFC 6606, DOI 10.17487/RFC6606, May 2012, &lt;https://www.rfc-editor.org/info/rfc6606&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6606] KIM、E.、KASPAR、D.、Gomez、C、およびC. Bormann、「低電力無線パーソナルエリアネットワーク（6LOWPAN）ルーティングにおけるIPv6の要件」、RFC 6606、DOI 10.17487 /rfc6606、2012年5月、&lt;https://www.rfc-editor.org/info/rfc6606&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8025] Thubert, P., Ed. and R. Cragie, &#34;IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Paging Dispatch&#34;, RFC 8025, DOI 10.17487/RFC8025, November 2016, &lt;https://www.rfc-editor.org/info/rfc8025&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8025] Thubert、P.、ED。そしてR. Cragie、「低電力無線パーソナルエリアネットワーク（6lowpan）ページングディスパッチ」、RFC 8025、DOI 10.17487 / RFC8025、2016年11月、&lt;https：//www.rfc-editor.org/info/rfc8025&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8138] Thubert, P., Ed., Bormann, C., Toutain, L., and R. Cragie, &#34;IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Routing Header&#34;, RFC 8138, DOI 10.17487/RFC8138, April 2017, &lt;https://www.rfc-editor.org/info/rfc8138&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8138] Thubert、P.、ED。、Bormann、C、Toutain、L.、R. Cragie、R.Cragie、「低電力無線パーソナルエリアネットワーク（6LOWPAN）ルーティングヘッダ」、RFC 8138、DOI 10.17487 / RFC8138、2017年4月、&lt;https://www.rfc-editor.org/info/rfc8138&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba、B、「RFC 2119キーワードの大文字の曖昧さ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、&lt;https：//www.rfc-editor.org/info/RFC8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8200] Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6 (IPv6) Specification&#34;, STD 86, RFC 8200, DOI 10.17487/RFC8200, July 2017, &lt;https://www.rfc-editor.org/info/rfc8200&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8200] The&#39;th、S.およびR.hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、STD 86、RFC 8200、DOI 10.17487 / RFC8200、2017年7月、&lt;https：//www.rfc-editor.org/ info / rfc8200&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8930] Watteyne, T., Ed., Thubert, P., Ed., and C. Bormann, &#34;On Forwarding 6LoWPAN (IPv6 over Low-Power Wireless Personal Area Network) Fragments over a Multi-Hop IPv6 Network&#34;, RFC 8930, DOI 10.17487/RFC8930, November 2020, &lt;https://www.rfc-editor.org/info/rfc8930&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8930] Watteyne、T.、ED。、Thubert、P.、Ed。、およびC. Bormann、Multi-Hop IPv6ネットワーク上での転送6LOWPAN（低電力無線パーソナルエリアネットワーク上のIPv6）フラグメント &#34;、RFC8930、DOI 10.17487 / RFC8930、2020年11月、&lt;https：//www.rfc-editor.org/info/rfc8930&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-2--Informative-References">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6TiSCH] Thubert, P., &#34;An Architecture for IPv6 over the TSCH mode of IEEE 802.15.4&#34;, Work in Progress, Internet-Draft, draft-ietf-6tisch-architecture-29, 27 August 2020, &lt;https://tools.ietf.org/html/draft-ietf-6tisch-architecture-29&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6tisch] Thubert、P.、「IEEE 802.15.4のTSCHモードでのIPv6のためのアーキテクチャーのためのアーキテクチャ」、インターネットドラフト、ドラフト -  IETF-6Tisch-Architecture-29,29,27、&lt;https：//tools.ietf.org/html/draft-ietf-6tisch-Architecture-29&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IEEE.802.15.4] IEEE, &#34;IEEE Standard for Low-Rate Wireless Networks&#34;, IEEE Standard 802.15.4-2015, DOI 10.1109/IEEESTD.2016.7460875, April 2016, &lt;http://ieeexplore.ieee.org/document/7460875/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IEEE.802.15.4] IEEE、「低速ワイヤレスネットワークのためのIEEE規格」、IEEEスタンダード802.15.4-2015、DOI 10.1109 / IEEESTD.2016.7460875、&lt;http://ieeexplore.ieee.org/document/ 7460875 /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Kent] Kent, C. and J. Mogul, &#34;Fragmentation Considered Harmful&#34;, SIGCOMM &#39;87: Proceedings of the ACM workshop on Frontiers in computer communications technology, pp. 390-401, DOI 10.1145/55483.55524, August 1987, &lt;http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-87-3.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ケント]ケント、C.およびJ.Mogul、「フラグメンテーションは有害と見なす」、SIGCOMM &#39;87：コンピュータ通信技術のフロンティアのACMワークショップの議事録、PP。390-401、DOI 10.1145 / 55483.55524、&lt;http：//www.hpl.hp.com/techreports/compaq-dec/wrl-87-3.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LWIG-FRAG] Bormann, C. and T. Watteyne, &#34;Virtual reassembly buffers in 6LoWPAN&#34;, Work in Progress, Internet-Draft, draft-ietf-lwig-6lowpan-virtual-reassembly-02, 9 March 2020, &lt;https://tools.ietf.org/html/draft-ietf-lwig-6lowpan-virtual-reassembly-02&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[lwig-frag] Bormann、C.およびT.Watteyne、「6lowpanでの仮想再構成バッファ」、進行中の作業、インターネットドラフト、ドラフト -  LWIG-6LOWPAN-Virtual-Reassembly-02,202月9日、&lt;HTTPS：//tools.ietf.org/html/draft-ietf-lwig-6lowpan-virtual-reassembly-02&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2914] Floyd, S., &#34;Congestion Control Principles&#34;, BCP 41, RFC 2914, DOI 10.17487/RFC2914, September 2000, &lt;https://www.rfc-editor.org/info/rfc2914&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2914] Floyd、S.、「輻輳制御原理」、BCP 41、RFC 2914、DOI 10.17487 / RFC2914、2000年9月、&lt;https：//www.rfc-editor.org/info/rfc2914&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3031] Rosen, E., Viswanathan, A., and R. Callon, &#34;Multiprotocol Label Switching Architecture&#34;, RFC 3031, DOI 10.17487/RFC3031, January 2001, &lt;https://www.rfc-editor.org/info/rfc3031&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3031]ローゼン、E.、Viswanathan、A.およびR.Callon、 &#34;Multiprotocol Label Switche Architecture&#34;、RFC 3031、DOI 10.17487 / RFC3031、2001年1月、&lt;https：//www.rfc-editor.org/info/ RFC3031&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, &#34;The Addition of Explicit Congestion Notification (ECN) to IP&#34;, RFC 3168, DOI 10.17487/RFC3168, September 2001, &lt;https://www.rfc-editor.org/info/rfc3168&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168] Ramakrishnan、K.、Floyd、S.、およびD. Black、「IPへの明示的輻輳通知（ECN）の追加」、RFC 3168、DOI 10.17487 / RFC3168、2001年9月、&lt;https：// www。rfc-editor.org/info/rfc3168&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4963] Heffner, J., Mathis, M., and B. Chandler, &#34;IPv4 Reassembly Errors at High Data Rates&#34;, RFC 4963, DOI 10.17487/RFC4963, July 2007, &lt;https://www.rfc-editor.org/info/rfc4963&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4963] Heffner、J.、Mathis、M.およびB.Chandler、2007年7月、&lt;https：///www.rfc-編集者。ORG / INFO / RFC4963&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5033] Floyd, S. and M. Allman, &#34;Specifying New Congestion Control Algorithms&#34;, BCP 133, RFC 5033, DOI 10.17487/RFC5033, August 2007, &lt;https://www.rfc-editor.org/info/rfc5033&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5033] Floyd、S.およびM. Allman、「新しい輻輳制御アルゴリズムの指定」、BCP 133、RFC 5033、DOI 10.17487 / RFC5033、2007年8月、&lt;https：//www.rfc-editor.org/info/rfc5033&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman, M., Paxson, V., and E. Blanton, &#34;TCP Congestion Control&#34;, RFC 5681, DOI 10.17487/RFC5681, September 2009, &lt;https://www.rfc-editor.org/info/rfc5681&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman、M.、Paxson、V.およびE.Blanton、「TCP輻輳制御」、RFC 5681、DOI 10.17487 / RFC5681、2009年9月、&lt;https：//www.rfc-editor.org/info/RFC5681&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6550] Winter, T., Ed., Thubert, P., Ed., Brandt, A., Hui, J., Kelsey, R., Levis, P., Pister, K., Struik, R., Vasseur, JP., and R. Alexander, &#34;RPL: IPv6 Routing Protocol for Low-Power and Lossy Networks&#34;, RFC 6550, DOI 10.17487/RFC6550, March 2012, &lt;https://www.rfc-editor.org/info/rfc6550&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6550]冬、T.、ED。、Thubert、P.、Ed。、Brandt、A.、Hui、J.、Kelsey、R.、Levis、P.、Pister、K.、Struik、R.、Vasseur、JP。、およびR.RPL：低消費電力ネットワークの「RPL：IPv6ルーティングプロトコル」、RFC 6550、DOI 10.17487 / RFC6550、2012年3月、&lt;https：//www.rfc-editor.org/info/RFC6550&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6552] Thubert, P., Ed., &#34;Objective Function Zero for the Routing Protocol for Low-Power and Lossy Networks (RPL)&#34;, RFC 6552, DOI 10.17487/RFC6552, March 2012, &lt;https://www.rfc-editor.org/info/rfc6552&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6552] Thubert、P.、ED。、「低消費電力および非損失ネットワーク（RPL）」、RFC 6552、DOI 10.17487 / RFC6552、2012年3月、&lt;https：///www.rfcのための客観的関数ゼロ-editor.org/info/rfc6552&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6554] Hui, J., Vasseur, JP., Culler, D., and V. Manral, &#34;An IPv6 Routing Header for Source Routes with the Routing Protocol for Low-Power and Lossy Networks (RPL)&#34;, RFC 6554, DOI 10.17487/RFC6554, March 2012, &lt;https://www.rfc-editor.org/info/rfc6554&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6554] HUI、J.、Vasseur、JP、Culler、D.、およびV. Manral、「低電力および非損失ネットワーク（RPL）」（RPL） &#34;、RFC 6554を備えたソースルート用のIPv6ルーティングヘッダー。DOI 10.17487 / RFC6554、2012年3月、&lt;https：//www.rfc-editor.org/info/rfc6554&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7554] Watteyne, T., Ed., Palattella, M., and L. Grieco, &#34;Using IEEE 802.15.4e Time-Slotted Channel Hopping (TSCH) in the Internet of Things (IoT): Problem Statement&#34;, RFC 7554, DOI 10.17487/RFC7554, May 2015, &lt;https://www.rfc-editor.org/info/rfc7554&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7554] Watteyne、T.、ED。、Palattella、M.、およびL.Grieco、「IEEE 802.15.4Eタイムスロットチャンネルホッピング（TSCH）（IoT）：問題声明 &#34;、RFC 7554、DOI 10.17487 / RFC7554、2015年5月、&lt;https://www.rfc-editor.org/info/rfc7554&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7567] Baker, F., Ed. and G. Fairhurst, Ed., &#34;IETF Recommendations Regarding Active Queue Management&#34;, BCP 197, RFC 7567, DOI 10.17487/RFC7567, July 2015, &lt;https://www.rfc-editor.org/info/rfc7567&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7567] Baker、F.、ED。G. FairHurst、Ed。、「アクティブキュー管理に関するIETF勧告」、BCP 197、RFC 7567、DOI 10.17487 / RFC7567、2015年7月、&lt;https：//www.rfc-editor.org/info/rfc7567&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8085] Eggert, L., Fairhurst, G., and G. Shepherd, &#34;UDP Usage Guidelines&#34;, BCP 145, RFC 8085, DOI 10.17487/RFC8085, March 2017, &lt;https://www.rfc-editor.org/info/rfc8085&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8085] eggert、L.、Fairhurst、G.、およびG.Shepherd、 &#34;UDP使用ガイドライン&#34;、BCP 145、RFC 8085、DOI 10.17487 / RFC8085、2017年3月、&lt;https：//www.rfc-editor.org/ info / rfc8085&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8087] Fairhurst, G. and M. Welzl, &#34;The Benefits of Using Explicit Congestion Notification (ECN)&#34;, RFC 8087, DOI 10.17487/RFC8087, March 2017, &lt;https://www.rfc-editor.org/info/rfc8087&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8087] FairHurst、G.およびM. Welzl、「明示的輻輳通知（ECN）を使用する利点」、RFC 8087、DOI 10.17487 / RFC8087、2017年3月、&lt;https：//www.rfc-editor.org/info/ RFC8087&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8201] McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed., &#34;Path MTU Discovery for IP version 6&#34;, STD 87, RFC 8201, DOI 10.17487/RFC8201, July 2017, &lt;https://www.rfc-editor.org/info/rfc8201&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8201] McCann、J.、Theer、S.、Mogul、J.、およびR. Hinden、Ed。、「IPバージョン6のためのパスMTUディスカバリー」、STD 87、RFC 8201、DOI 10.17487 / RFC8201、2017年7月、&lt;https://www.rfc-editor.org/info/rfc8201&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8900] Bonica, R., Baker, F., Huston, G., Hinden, R., Troan, O., and F. Gont, &#34;IP Fragmentation Considered Fragile&#34;, BCP 230, RFC 8900, DOI 10.17487/RFC8900, September 2020, &lt;https://www.rfc-editor.org/info/rfc8900&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8900]ボニャ、R.、Baker、F.、Huston、G.、Hinden、R.、Troan、O.、F.ゴント、「IPフラグメンテーションと見なす」、BCP 230、RFC 8900、DOI 10.17487 / RFC8900、2020年9月、&lt;https://www.rfc-editor.org/info/rfc8900&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--Rationale">
Appendix A. Rationale
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A.根拠
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are a number of uses for large packets in Wireless Sensor Networks. Such usages may not be the most typical or represent the largest amount of traffic over the LLN; however, the associated functionality can be critical enough to justify extra care for ensuring effective transport of large packets across the LLN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
無線センサネットワーク内の大型パケットには多くの用途があります。そのような用途は、最も典型的ではないか、またはLLNを介して最大のトラフィックを表すことができます。ただし、関連する機能性は、LLN全体で大きなパケットの効果的なトランスポートを確保するための特別な注意を正当化するのに十分なほど重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The list of those usages includes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの用途のリストには以下が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Towards the LLN node:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LLNノードに向かって：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Firmware update: For example, a new version of the LLN node software is downloaded from a system manager over unicast or multicast services. Such a reflashing operation typically involves updating a large number of similar LLN nodes over a relatively short period of time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ファームウェアアップデート：たとえば、新しいバージョンのLLNノードソフトウェアは、UnicastまたはMulticast Servicesを介したシステムマネージャからダウンロードされます。そのようなリフレッシュ動作は、典型的には、比較的短い期間にわたって多数の類似のLLNノードを更新することを含む。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packages of commands: A number of commands or a full configuration can be packaged as a single message to ensure consistency and enable atomic execution or complete rollback. Until such commands are fully received and interpreted, the intended operation will not take effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
コマンドのパッケージ：いくつかのコマンドまたは完全な構成を単一のメッセージとしてパッケージ化することができ、一貫性を確保し、アトミック実行または完全なロールバックを有効にすることができます。そのようなコマンドが完全に受信され解釈されるまで、意図された操作は有効になりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the LLN node:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LLNノードから：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Waveform captures: A number of consecutive samples are measured at a high rate for a short time and then are transferred from a sensor to a gateway or an edge server as a single large report.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
波形キャプチャ：いくつかの連続したサンプルが短時間で高速で測定され、次いでセンサーからゲートウェイへ、またはエッジサーバーからエッジサーバーに転送されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Data logs: LLN nodes may generate large logs of sampled data for later extraction. LLN nodes may also generate system logs to assist in diagnosing problems on the node or network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
データログ：LLNノードは、後で抽出するためにサンプリングされたデータの大きなログを生成することがあります。LLNノードはまた、ノードまたはネットワーク上の問題の診断を支援するためにシステムログを生成することができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Large data packets: Rich data types might require more than one fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
大きなデータパケット：豊富なデータ型には、複数のフラグメントが必要になる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Uncontrolled firmware download or waveform upload can easily result in a massive increase of the traffic and saturate the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御されていないファームウェアのダウンロードまたは波形のアップロードは、トラフィックの大幅な増加とネットワークを飽和させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a fragment is lost in transmission, the lack of recovery in the original fragmentation system of RFC 4944 implies that all fragments would need to be resent, further contributing to the congestion that caused the initial loss and potentially leading to congestion collapse.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメントが送信中に失われると、RFC 4944の元のフラグメンテーションシステムにおける回復の欠如は、すべてのフラグメントを再送信する必要があることを意味し、初期損失を引き起こし、潜在的に輻輳崩壊につながる潜在的に輻輳に貢献することを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This saturation may lead to excessive radio interference or random early discard (leaky bucket) in relaying nodes. Additional queuing and memory congestion may result while waiting for a low-power next hop to emerge from its sleep state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この飽和は、中継ノード内の過度の無線干渉またはランダム早期廃棄（漏れ型バケット）をもたらし得る。低電力の次ホップがそのスリープ状態から出現するのを待っている間、追加のキューイングおよびメモリの輻輳が発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Considering that RFC 4944 defines an MTU as 1280 bytes, and that in most incarnations (except 802.15.4g) an IEEE Std 802.15.4 frame can limit the link-layer payload to as few as 74 bytes, a packet might be fragmented into at least 18 fragments at the 6LoWPAN shim layer. Taking into account the worst-case header overhead for 6LoWPAN Fragmentation and Mesh Addressing headers will increase the number of required fragments to around 32. This level of fragmentation is much higher than that traditionally experienced over the Internet with IPv4 fragments. At the same time, the use of radios increases the probability of transmission loss, and mesh-under techniques compound that risk over multiple hops.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 4944が1280バイトとしてMTUを定義し、ほとんどの場合（802.15.4Gを除く）IEEE STD 802.15.4フレームがリンクレイヤペイロードを74バイトに限定することができることを考えると、パケットが断片化される可能性があります。6lowpanシム層での最低18のフラグメント。6LOWPANフラグメンテーションおよびメッシュアドレス指定ヘッダのための最悪のケースのヘッダオーバーヘッドを考慮すると、必要なフラグメントの数が約32に増加する。このレベルの断片化は、伝統的にIPv4フラグメントを介して経験されたものよりはるかに高い。同時に、無線機の使用は伝送損失の可能性を高め、そして複数のホップにわたって危険にさらすメッシュ下技術。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mechanisms such as TCP or application-layer segmentation could be used to support end-to-end reliable transport. One option to support bulk data transfer over a frame-size-constrained LLN is to set the Maximum Segment Size to fit within the link maximum frame size. However, doing so can add significant header overhead to each 802.15.4 frame and cause extraneous acknowledgments across the LLN compared to the method in this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPやアプリケーション層のセグメンテーションなどのメカニズムを使用して、エンドツーエンドの信頼できる輸送をサポートできます。フレームサイズの制約付きLLNを介してバルクデータ転送をサポートする1つの選択肢は、リンク最大フレームサイズ内に適合する最大セグメントサイズを設定することです。しかしながら、そうすることで、各802.15.4フレームに大きなヘッダオーバーヘッドを追加し、この仕様の方法と比較してLLN全体で無関係な確認応答を引き起こす可能性がある。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-B--Requirements">
Appendix B. Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録B.要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For one-hop communications, a number of LLN link layers propose a local acknowledgment mechanism that is enough to detect and recover the loss of fragments. In a multi-hop environment, an end-to-end fragment recovery mechanism might be a good complement to a hop-by-hop Medium Access Control (MAC) recovery. This document introduces a simple protocol to recover individual fragments between 6LFF endpoints that may be multiple hops away.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1ホップ通信のために、いくつかのLLNリンク層は、フラグメントの損失を検出および回復するのに十分な局所確認メカニズムを提案する。マルチホップ環境では、エンドツーエンドフラグメントリカバリメカニズムは、ホップバイホップ媒体アクセス制御（MAC）リカバリへの優れた補完的であり得る。この文書は、複数のホップである可能性がある6LFFエンドポイント間で個々のフラグメントを回復するための簡単なプロトコルを紹介します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The method addresses the following requirements of an LLN:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メソッドは、LLNの以下の要件に対処します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Number of fragments: The recovery mechanism must support highly fragmented packets, with a maximum of 32 fragments per packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメント数：リカバリメカニズムは、高度に断片化されたパケットをサポートしなければなりません。パケットごとに最大32のフラグメントがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Minimum acknowledgment overhead: Because the radio is half duplex, and because of silent time spent in the various medium access mechanisms, an acknowledgment consumes roughly as many resources as a data fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最小肯定応答オーバーヘッド：ラジオが半二重で、さまざまな媒体アクセスメカニズムに費やされた静かな時間のために、確認応答はデータフラグメントとほぼ多くのリソースを消費します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The new end-to-end fragment recovery mechanism should be able to acknowledge multiple fragments in a single message and not require an acknowledgment at all if fragments are already protected at a lower layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
新しいエンドツーエンドフラグメントリカバリメカニズムは、単一のメッセージ内の複数のフラグメントを確認できるはずであり、フラグメントが既に下位レイヤで保護されている場合は、肯定応答を必要としません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Controlled latency: The recovery mechanism must succeed or give up within the time boundary imposed by the recovery process of the upper-layer protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御された待ち時間：回復メカニズムは、上層プロトコルの回復プロセスによって課される時間境界内に成功またはあきらめる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Optional congestion control: The aggregation of multiple concurrent flows may lead to the saturation of the radio network and congestion collapse.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションの輻輳制御：複数の同時フローの集約は、無線ネットワークの彩度と輻輳崩壊につながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The recovery mechanism should provide means for controlling the number of fragments in transit over the LLN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
回復メカニズムは、LLNの輸送中のフラグメント数を制御するための手段を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-C--Considerations-on-Congestion-Control">
Appendix C. Considerations on Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録C C.輻輳制御に関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Considering that a multi-hop LLN can be a very sensitive environment due to the limited queuing capabilities of a large population of its nodes, this document recommends a simple and conservative approach to congestion control, based on TCP congestion avoidance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチホップLLNが、そのノードの大きな人口の限られたキューイング機能のために非常に敏感な環境になる可能性があることを考えると、この文書はTCPの輻輳回避に基づいて、輻輳制御へのシンプルで保守的なアプローチを推奨しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Congestion on the forward path is assumed in case of packet loss, and packet loss is assumed upon timeout. This document allows controlling the number of outstanding fragments that have been transmitted, but for which an acknowledgment was not yet received, and that are still covered by the ARQ timer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット損失の場合には、順方向パスの輻輳が想定され、パケット損失はタイムアウト時に想定されます。この文書では、送信された未解決のフラグメントの数を制御することができますが、確認応答がまだ受信されていないため、まだARQタイマーによってカバーされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Congestion on the forward path can also be indicated by an ECN mechanism. Though whether and how ECN [RFC3168] is carried out over the LoWPAN is out of scope, this document provides a way for the destination endpoint to echo an ECN indication back to the fragmenting endpoint in an acknowledgment message as represented in Figure 4 in Section 5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
順方向経路上の輻輳は、ECNメカニズムによっても示され得る。ECN [RFC3168]がローパンの上でどのように実行されているかは範囲外であるかどうかは、セクション5.2の図4に示すように、宛先エンドポイントが肯定応答メッセージの断片化エンドポイントにECN表示をエコーする方法を提供します。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the support of echoing the ECN at the reassembling endpoint is mandatory, this specification only provides a minimalistic behavior on the fragmenting endpoint. If an &#34;E&#34; flag is received, the window SHOULD be reduced at least by 1 and at max to 1. Halving the window for each &#34;E&#34; flag received could be a good compromise, but it needs further experimentation. A very simple implementation may just reset the window to 1, so the fragments are sent and acknowledged one by one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再組み立てエンドポイントでECNをエコーするサポートは必須ですが、この仕様は断片化エンドポイントで最小限の動作を提供します。「E」フラグが受信された場合、ウィンドウは少なくとも1で最大1までに減少されるべきである。非常に単純な実装では、ウィンドウを1にリセットするだけで、フラグメントは1つずつ送信され、確認されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that any action that has been performed upon detection of congestion only applies for the transmission of one datagram, and the next datagram starts with the configured Window_Size again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳の検出時に実行されたアクションは、1つのデータグラムの送信にのみ適用され、次のデータグラムは再度構成されたwindow_sizeで始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The exact use of the Acknowledgment Request flag and of the window are left to implementation. An optimistic implementation could send all the fragments up to Window_Size, setting the Acknowledgment Request &#34;X&#34; flag only on the last fragment; wait for the bitmap, which means a gap of half a round-trip time; and resend the losses. A pessimistic implementation could set the &#34;X&#34; flag on the first fragment to check that the path works and open the window only upon receiving the RFRAG-ACK. It could then set an &#34;X&#34; flag again on the second fragment and use the window as a credit to send up to Window_Size before it is blocked. In that case, if the RFRAG-ACK comes back before the window starves, the gating factor is the inter-frame gap. If the RFRAG-ACK does not arrive in time, the Window_Size is the gating factor, and the transmission of the datagram is delayed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認応答要求フラグとウィンドウの正確な使用は実装に残されています。楽観的な実装では、window_sizeまでのすべてのフラグメントを送信し、肯定応答要求 &#34;x&#34;フラグを最後のフラグメントでのみ設定できます。ビットマップを待ちます。つまり、半分の往復時間のギャップを意味します。そして損失を再開します。悲観的な実装は、最初のフラグメント上の &#34;x&#34;フラグを設定して、パスがrfrag-ackを受信したときにのみウィンドウを開くことを確認することができます。その後、2番目のフラグメントで「X」フラグを再度設定し、ブロックされる前にWindow_Sizeに送信するためにウィンドウとしてウィンドウを使用することができます。その場合、rFRAG-ACKがウィンドウの枯渇前に戻ってくると、ゲーティング係数はフレーム間ギャップです。RFRAG-ACKが時間内に到着しない場合、window_sizeはゲーティングファクタであり、データグラムの送信は遅延されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It must be noted that even though the inter-frame gap can be used as a flow control or a congestion control measure, it also plays a critical role in wireless collision avoidance. In particular, when a mesh operates on the same channel over multiple hops, the forwarding of a fragment over a certain hop may collide with the forwarding of the next fragment that is following over a previous hop but that is in the same interference domain. To prevent this, the fragmenting endpoint is required to pace individual fragments within a transmit window with an inter-frame gap. This is needed to ensure that a given fragment is sent only when the previous fragment has had a chance to progress beyond the interference domain of this hop. In the case of 6TiSCH [6TiSCH], which operates over the Time-Slotted Channel Hopping (TSCH) mode of operation of IEEE 802.15.4 [RFC7554], a fragment is forwarded over a different channel at a different time, and it makes full sense to transmit the next fragment as soon as the previous fragment has had its chance to be forwarded at the next hop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレーム間ギャップをフロー制御または輻輳制御尺度として使用することができるとしても、それはまた無線衝突回避において重要な役割を果たすことに留意されたい。特に、メッシュが複数のホップを介して同じチャネル上で動作するとき、特定のホップ上のフラグメントの転送は、前のホップを超えるが、同じ干渉ドメイン内にある次のフラグメントの転送と衝突する可能性がある。これを防ぐために、フラグメント化エンドポイントは、フレーム間ギャップを使用して送信ウィンドウ内の個々のフラグメントをペースするために必要とされる。これは、前のフラグメントがこのホップの干渉ドメインを超えて進行する機会がある場合にのみ、特定のフラグメントが送信されるようにするために必要です。 IEEE 802.15.4 [RFC7554]のタイムスロットチャネルホッピング（TSCH）動作モードで動作する6tisch [6tisch]の場合、フラグメントは異なる時間で異なるチャネルを介して転送され、それは完全になります前のフラグメントが次のホップで転送される可能性があるとすぐに次のフラグメントを送信することを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on the setting of the Window_Size and the inter-frame gap, how the window is used, and the number of hops, the Window_Size may or may not become the gating factor that blocks the transmission. If the sender uses the Window_Size as a credit:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
window_sizeとフレーム間ギャップの設定、ウィンドウの使用方法、およびホップ数、Window_Sizeは、送信をブロックするゲーティングファクタにならない場合があります。送信者がクレジットとしてwindow_sizeを使用している場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* a conservative Window_Size of, say, 3 will be the gating factor that limits the transmission rate of the sender -- and causes transmission gaps longer than the inter-frame gap -- as soon as the number of hops exceeds 3 in a TSCH network and 5-9 in a single frequency mesh. The more hops the more the starving window will add to latency of the transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 保守的なWINDOR_SIZEは、SENDERの伝送速度を制限するゲーティング係数となり、HOPの数がTSCHネットワークで3を超えるとすぐに、フレーム間ギャップよりも長い伝送ギャップを引き起こす。5-9単一の周波数メッシュ。より多くのホップが多いほど、飢え窓が変速機の待ち時間に加えられる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The recommendation to align the Window-Size to the round-trip time divided by the time per fragment aligns the Window-Size to the time it takes to get the RFAG_ACK before the window starves. A Window-Size that is higher than that increases the chances of a congestion but does not improve the forward throughput. Considering that the RFRAG-ACK takes the same path as the fragment with the assumption that it travels at roughly the same speed, an inter-frame gap that separates fragments by 2 hops leads to a Window_Size that is roughly the number of hops.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ウィンドウサイズをフラグメントあたりの時間で割った丸いトリップ時間に分割する推奨事項は、ウィンドウの星を星の前にRFAG_ACKを取得するのにかかる時間に整列させます。それよりも高いウィンドウサイズは、輻輳の可能性を高めますが、前方スループットを向上させません。RFRAG-ACKが概略で同じ速度で移動すると仮定してフラグメントと同じ経路をとることを考えると、フラグメントを2ホップに分離するフレーム間ギャップは、おおよそホップ数であるWINDOW_SIZEにつながります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Setting the Window-Size to 32 minimizes the cost of the acknowledgment in a constrained network and frees bandwidth for the fragments in a half-duplex network. Using it increases the risk of congestion if a bottleneck forms, but it optimizes the use of resources under normal conditions. When it is used, the only protection for the network is the inter-frame gap, which must be chosen wisely to prevent the formation of a bottleneck.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ウィンドウサイズを32に設定すると、拘束ネットワーク内の確認応答のコストが最小化され、半二重ネットワーク内のフラグメントの帯域幅を解放します。それを使用すると、ボトルネックの場合は輻輳のリスクが高まりますが、通常の条件下でのリソースの使用を最適化します。使用されると、ネットワークの唯一の保護はフレーム間ギャップです。これはボトルネックの形成を防ぐために賢明に選択されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the standpoint of a source 6LoWPAN endpoint, an outstanding fragment is a fragment that was sent but for which no explicit acknowledgment was yet received. This means that the fragment might be on the path or received but not yet acknowledged, or the acknowledgment might be on the path back. It is also possible that either the fragment or the acknowledgment was lost on the way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソース6LOWPANエンドポイントの観点から、優れたフラグメントは送信されたフラグメントですが、明示的な確認応答がまだ受信されていません。つまり、フラグメントはパス上にあるか受信されていないがまだ認識されていないこと、または確認応答がパス上にある場合があります。途中でフラグメントまたは確認応答のいずれかが失われたことも可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the fragmenting endpoint standpoint, all outstanding fragments might still be in the network and contribute to its congestion. There is an assumption, though, that after a certain amount of time, a frame is either received or lost, so it is not causing congestion anymore. This amount of time can be estimated based on the round-trip time between the 6LoWPAN endpoints. For the lack of a more adapted technique, the method detailed in &#34;Computing TCP&#39;s Retransmission Timer&#34; [RFC6298] may be used for that computation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
断片化エンドポイントの観点からは、未解決のフラグメントはすべてネットワーク内にある可能性があり、その輻輳に貢献します。ただし、一定時間後、フレームが受信または紛失しているため、輻輳が発生していないという仮定があります。この時間は、6LOWPANエンドポイント間の往復時間に基づいて推定できます。より適応な技術がないために、「TCPの再送信タイマの計算」[RFC6298]に詳述されている方法をその計算に使用することができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification provides the necessary tools for the fragmenting endpoint to take congestion control actions and protect the network, but it leaves the implementation free to select the action to be taken. The intention is to use it to build experience and specify more precisely the congestion control actions in one or more future specifications. &#34;Congestion Control Principles&#34; [RFC2914] and &#34;Specifying New Congestion Control Algorithms&#34; [RFC5033] provide indications and wisdom that should help through this process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様では、断片化エンドポイントに輻輳制御アクションを実行してネットワークを保護するための必要なツールが提供されていますが、実行するアクションを選択することができます。その意図は、それを使用して経験を構築し、1つ以上の将来の仕様でより正確に輻輳制御の行動を指定することです。「輻輳制御原則」[RFC2914]と「新しい輻輳制御アルゴリズムの指定」[RFC5033]このプロセスを支援する必要がある適応と知恵を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7567] and [RFC5681] provide deeper information on why congestion control is needed and how TCP handles it. Basically, the goal here is to manage the number of fragments present in the network; this is achieved by reducing the number of outstanding fragments over a congested path by throttling the sources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7567]および[RFC5681]は、輻輳制御が必要なのか、およびTCPがどのように処理するかについてのより深い情報を提供します。基本的に、ここでの目標は、ネットワーク内に存在するフラグメントの数を管理することです。これは、ソースを調整することによって輻輳している経路上の優れたフラグメントの数を減らすことによって達成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The author wishes to thank Michel Veillette, Dario Tedeschi, Laurent Toutain, Carles Gomez Montenegro, Thomas Watteyne, and Michael Richardson for their in-depth reviews and comments. Also, many thanks to Roman Danyliw, Peter Yee, Colin Perkins, Tirumaleswar Reddy.K, Éric Vyncke, Warren Kumari, Magnus Westerlund, Erik Nordmark, and especially Benjamin Kaduk and Mirja Kühlewind for their careful reviews and help during the IETF Last Call and IESG review process. Thanks to Jonathan Hui, Jay Werb, Christos Polyzois, Soumitri Kolavennu, Pat Kinney, Margaret Wasserman, Richard Kelsey, Carsten Bormann, and Harry Courtice for their various contributions in the long process that lead to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者は、Michel Veillette、Dario Tedeschi、Laurent Toutain、Carles Gomez Montenegro、Thomas Watteyne、およびMichael Richardson、およびその詳細なレビューとコメントをお寄せいただきありがとうございます。また、Roman Danyliw、Peter Yee、Colin Perkins、Tirumaleswar reddy.k、ÉricVyncke、Agren Westerlund、Erik Nordmark、Erik Nordmark、特にBenjamin KadukとMirjaKühlewindのおかげで、IETFの最後のコールの間、IESGレビュープロセスJonathan Hui、Jay Werb、Christos Polyzois、Soumitri Kolavennu、Pat Kinney、Margaret Wasserman、Richard Kelsey、Carsten Borsten Bormann、およびハリーコレツツのために、この文書につながります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者の住所
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pascal Thubert (editor) Cisco Systems, Inc. Building D 45 Allee des Ormes - BP1200 06254 MOUGINS - Sophia Antipolis France
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pascal Thubert（編集）Cisco Systems、Inc。Cisco Systems、Inc。建物D 45 Allee Des Ormes  -  BP1200 06254 Mougins  -  Sophia Antipolis France
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +33 497 23 26 34
   Email: pthubert@cisco.com
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
