<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 4226 - HOTP: An HMAC-Based One-Time Password Algorithm 日本語訳</title>
  <meta name="description" content="RFC 4226は、HMAC（Hash-based Message Authentication Code）を使用した一回限りのパスワード（OTP）アルゴリズムであるHOTP（HMAC-Based One-Time Password Algorithm）について定義しています。この文書の目的は、静的なパスワードの代わりに使用される、より安全な認証手段を提供することです。HOTPは、主に二要素認証システムで利用され、ユーザーが事前に共有された秘密とカウンターを基に生成した一度きりのパスワードを使用して認証を行います。このアルゴリズムは、オンラインバンキング、VPNアクセス、セキュアなログインシステムなどで広く採用されています。関連するRFCとしては、RFC 6238（TOTP: Time-Based One-Time Password Algorithm）があり、時間に基づくOTP生成の拡張を提供しています。">

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">4226</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc4226">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 4226 - HOTP: An HMAC-Based One-Time Password Algorithm 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc4226">
            https://datatracker.ietf.org/doc/html/rfc4226
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 4226 - HOTP：HMACベースのワンタイムパスワードアルゴリズム</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] RFC 4226は、HMAC（Hash-based Message Authentication Code）を使用した一回限りのパスワード（OTP）アルゴリズムであるHOTP（HMAC-Based One-Time Password Algorithm）について定義しています。この文書の目的は、静的なパスワードの代わりに使用される、より安全な認証手段を提供することです。HOTPは、主に二要素認証システムで利用され、ユーザーが事前に共有された秘密とカウンターを基に生成した一度きりのパスワードを使用して認証を行います。このアルゴリズムは、オンラインバンキング、VPNアクセス、セキュアなログインシステムなどで広く採用されています。関連するRFCとしては、RFC 6238（TOTP: Time-Based One-Time Password Algorithm）があり、時間に基づくOTP生成の拡張を提供しています。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                         D. M&#39;Raihi
Request for Comments: 4226                                      VeriSign
Category: Informational                                       M. Bellare
                                                                    UCSD
                                                            F. Hoornaert
                                                                   Vasco
                                                             D. Naccache
                                                                 Gemplus
                                                                O. Ranen
                                                                 Aladdin
                                                           December 2005
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
HOTP: An HMAC-Based One-Time Password Algorithm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
HOTP：HMACベースのワンタイムパスワードアルゴリズム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモはインターネットコミュニティに関する情報を提供します。インターネット規格はあらゆる種類の標準を指定していません。このメモの分布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2005).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット社会（2005）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes an algorithm to generate one-time password values, based on Hashed Message Authentication Code (HMAC). A security analysis of the algorithm is presented, and important parameters related to the secure deployment of the algorithm are discussed. The proposed algorithm can be used across a wide range of network applications ranging from remote Virtual Private Network (VPN) access, Wi-Fi network logon to transaction-oriented Web applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、ハッシュされたメッセージ認証コード（HMAC）に基づいて、1回限りのパスワード値を生成するためのアルゴリズムについて説明します。アルゴリズムのセキュリティ分析が提示され、アルゴリズムの安全な展開に関連する重要なパラメータが議論されている。提案されたアルゴリズムは、リモート仮想プライベートネットワーク（VPN）アクセス、Wi-Fiネットワークログオンからトランザクション指向Webアプリケーションまでの幅広いネットワークアプリケーションにまたがって使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This work is a joint effort by the OATH (Open AuTHentication) membership to specify an algorithm that can be freely distributed to the technical community. The authors believe that a common and shared algorithm will facilitate adoption of two-factor authentication on the Internet by enabling interoperability across commercial and open-source implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この作品は、技術コミュニティに自由に配布できるアルゴリズムを指定するための宣誓（認証）メンバーシップによる共同努力です。著者らは、コモンと共有アルゴリズムが、商業およびオープンソースの実装にまたがる相互運用性を可能にすることによって、インターネット上の2要素認証の採用を促進すると考えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1. Overview ........................................................3
   2. Introduction ....................................................3
   3. Requirements Terminology ........................................4
   4. Algorithm Requirements ..........................................4
   5. HOTP Algorithm ..................................................5
      5.1. Notation and Symbols .......................................5
      5.2. Description ................................................6
      5.3. Generating an HOTP Value ...................................6
      5.4. Example of HOTP Computation for Digit = 6 ..................7
   6. Security Considerations .........................................8
   7. Security Requirements ...........................................9
      7.1. Authentication Protocol Requirements .......................9
      7.2. Validation of HOTP Values .................................10
      7.3. Throttling at the Server ..................................10
      7.4. Resynchronization of the Counter ..........................11
      7.5. Management of Shared Secrets ..............................11
   8. Composite Shared Secrets .......................................14
   9. Bi-Directional Authentication ..................................14
   10. Conclusion ....................................................15
   11. Acknowledgements ..............................................15
   12. Contributors ..................................................15
   13. References ....................................................15
      13.1. Normative References .....................................15
      13.2. Informative References ...................................16
   Appendix A - HOTP Algorithm Security: Detailed Analysis ...........17
      A.1. Definitions and Notations .................................17
      A.2. The Idealized Algorithm: HOTP-IDEAL .......................17
      A.3. Model of Security .........................................18
      A.4. Security of the Ideal Authentication Algorithm ............19
           A.4.1. From Bits to Digits ................................19
           A.4.2. Brute Force Attacks ................................21
           A.4.3. Brute force attacks are the best possible attacks ..22
      A.5. Security Analysis of HOTP .................................23
   Appendix B - SHA-1 Attacks ........................................25
      B.1. SHA-1 Status ..............................................25
      B.2. HMAC-SHA-1 Status .........................................26
      B.3. HOTP Status ...............................................26
   Appendix C - HOTP Algorithm: Reference Implementation .............27
   Appendix D - HOTP Algorithm: Test Values ..........................32
   Appendix E - Extensions ...........................................33
      E.1. Number of Digits ..........................................33
      E.2. Alphanumeric Values .......................................33
      E.3. Sequence of HOTP values ...................................34
      E.4. A Counter-Based Resynchronization Method ..................34
      E.5. Data Field ................................................35
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Overview">
1. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The document introduces first the context around an algorithm that generates one-time password values based on HMAC [BCK1] and, thus, is named the HMAC-Based One-Time Password (HOTP) algorithm. In Section 4, the algorithm requirements are listed and in Section 5, the HOTP algorithm is described. Sections 6 and 7 focus on the algorithm security. Section 8 proposes some extensions and improvements, and Section 10 concludes this document. In Appendix A, the interested reader will find a detailed, full-fledged analysis of the algorithm security: an idealized version of the algorithm is evaluated, and then the HOTP algorithm security is analyzed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、HMAC [BCK1]に基づいて1回限りのパスワード値を生成するアルゴリズムの周囲のコンテキストを最初に導入し、したがって、HMACベースのワンタイムパスワード（HOTP）アルゴリズムと呼ばれます。セクション4では、アルゴリズムの要件をリストし、セクション5では、HOTPアルゴリズムについて説明します。セクション6と7はアルゴリズムのセキュリティに焦点を当てています。セクション8はいくつかの拡張と改善を提案し、セクション10はこの文書を締めくくります。付録Aでは、興味のあるリーダーがアルゴリズムのセキュリティの詳細で本格的な分析を見つけるでしょう：アルゴリズムの理想的なバージョンが評価され、その後HOTPアルゴリズムのセキュリティが分析されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Introduction">
2. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Today, deployment of two-factor authentication remains extremely limited in scope and scale. Despite increasingly higher levels of threats and attacks, most Internet applications still rely on weak authentication schemes for policing user access. The lack of interoperability among hardware and software technology vendors has been a limiting factor in the adoption of two-factor authentication technology. In particular, the absence of open specifications has led to solutions where hardware and software components are tightly coupled through proprietary technology, resulting in high-cost solutions, poor adoption, and limited innovation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
今日、2要素認証の展開は、スコープとスケールが非常に限られています。ますます高いレベルの脅威と攻撃にもかかわらず、ほとんどのインターネットアプリケーションはまだユーザーアクセスのポリシングのための弱い認証方式に依存しています。ハードウェアおよびソフトウェア技術のベンダーの間の相互運用性の欠如は、2要素認証技術の採用における制限要因となっています。特に、オープン仕様の欠如は、ハードウェアおよびソフトウェアコンポーネントが独自の技術を介して厳重に結合されているソリューションをもたらし、高コストのソリューション、採用不良、および革新が限られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the last two years, the rapid rise of network threats has exposed the inadequacies of static passwords as the primary mean of authentication on the Internet. At the same time, the current approach that requires an end user to carry an expensive, single-function device that is only used to authenticate to the network is clearly not the right answer. For two-factor authentication to propagate on the Internet, it will have to be embedded in more flexible devices that can work across a wide range of applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
過去2年間で、ネットワークの脅威の急激な上昇は、インターネット上の認証の主な平均として静的パスワードの不適切さを公開しています。同時に、ネットワークを認証するためにのみ使用される高価な単一機能デバイスを、正しい回答ではないことを要求する現在のアプローチが明らかにはわかりません。2要素認証のためにインターネット上で伝播するためには、幅広いアプリケーションにまたがるより柔軟なデバイスに埋め込む必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ability to embed this base technology while ensuring broad interoperability requires that it be made freely available to the broad technical community of hardware and software developers. Only an open-system approach will ensure that basic two-factor authentication primitives can be built into the next generation of consumer devices such as USB mass storage devices, IP phones, and personal digital assistants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
幅広い相互運用性を確保しながらこの基本技術を埋め込む能力は、ハードウェアおよびソフトウェア開発者の幅広い技術コミュニティに自由に利用できるようにする必要があります。オープンシステムアプローチのみが、USB大容量記憶装置、IP電話、およびパーソナルデジタルアシスタントなどの次世代のコンシューマデバイスに基本的な2要素認証プリミティブを構築できるようにするでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 One-Time Password is certainly one of the simplest and most popular forms of two-factor authentication for securing network access. For example, in large enterprises, Virtual Private Network access often requires the use of One-Time Password tokens for remote user authentication. One-Time Passwords are often preferred to stronger forms of authentication such as Public-Key Infrastructure (PKI) or biometrics because an air-gap device does not require the installation of any client desktop software on the user machine, therefore allowing them to roam across multiple machines including home computers, kiosks, and personal digital assistants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ワンタイムパスワードは確かにネットワークアクセスを保護するための2要素認証の最も簡単で人気のある形式のいずれかです。たとえば、大規模な企業では、仮想プライベートネットワークアクセスには、リモートユーザー認証のワンタイムパスワードトークンの使用が必要です。ワンタイムパスワードは、エアギャップデバイスがユーザーマシン上でのクライアントデスクトップソフトウェアのインストールを必要としないため、公開鍵インフラストラクチャ（PKI）またはバイオメトリクスなどの認証の強い形式が頻繁に優先されることがよくあります。ホームコンピュータ、キオスク、およびパーソナルデジタルアシスタントを含む複数のマシン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document proposes a simple One-Time Password algorithm that can be implemented by any hardware manufacturer or software developer to create interoperable authentication devices and software agents. The algorithm is event-based so that it can be embedded in high-volume devices such as Java smart cards, USB dongles, and GSM SIM cards. The presented algorithm is made freely available to the developer community under the terms and conditions of the IETF Intellectual Property Rights [RFC3979].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、相互運用可能な認証装置やソフトウェアエージェントを作成するために、任意のハードウェア製造元またはソフトウェア開発者によって実装できる単純なワンタイムパスワードアルゴリズムを提案しています。アルゴリズムはイベントベースで、Javaスマートカード、USBドングル、GSM SIMカードなどの大容量デバイスに埋め込むことができます。提示されたアルゴリズムは、IETF知的財産権の契約条件下で開発者コミュニティで自由に利用可能にされています[RFC3979]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors of this document are members of the Open AuTHentication initiative [OATH]. The initiative was created in 2004 to facilitate collaboration among strong authentication technology providers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書の著者はオープン認証イニシアチブ[宣誓]のメンバーです。強力な認証技術プロバイダ間のコラボレーションを容易にするために、イニシアチブは2004年に作成されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Requirements-Terminology">
3. Requirements Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 要求用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「必須」、「必須」、「必要ではない」、「しない」、「推奨する」、「推奨する」、「5月」、および「オプション」、「オプション」、「オプション」、「オプション」、「オプション」、「オプション」、[RFC2119]に記載されているように解釈されること。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Algorithm-Requirements">
4. Algorithm Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. アルゴリズムの要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section presents the main requirements that drove this algorithm design. A lot of emphasis was placed on end-consumer usability as well as the ability for the algorithm to be implemented by low-cost hardware that may provide minimal user interface capabilities. In particular, the ability to embed the algorithm into high-volume SIM and Java cards was a fundamental prerequisite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この節では、このアルゴリズム設計を推進した主な要件を示します。最小限のユーザインタフェース機能を提供する可能性がある低コストのハードウェアによって、エンドの消費者の使いやすさとアルゴリズムを実装する能力が大変な重点を置かれました。特に、アルゴリズムを大量のSIMおよびJavaカードに埋め込む能力は、基本的な前提条件でした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R1 - The algorithm MUST be sequence- or counter-based: one of the goals is to have the HOTP algorithm embedded in high-volume devices such as Java smart cards, USB dongles, and GSM SIM cards.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R1  - アルゴリズムはシーケンス - またはカウンタベースでなければなりません。ゴールの1つは、Javaスマートカード、USBドングル、GSM SIMカードなどの大量のデバイスにHOTPアルゴリズムを組み込んだことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R2 - The algorithm SHOULD be economical to implement in hardware by minimizing requirements on battery, number of buttons, computational horsepower, and size of LCD display.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R2  - このアルゴリズムは、バッテリの要件、ボタンの数、計算馬力、およびLCDディスプレイのサイズの要件を最小限に抑えることによって、ハードウェアで実装する経済的であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R3 - The algorithm MUST work with tokens that do not support any numeric input, but MAY also be used with more sophisticated devices such as secure PIN-pads.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R3  - アルゴリズムは、数値入力をサポートしていないトークンで動作する必要がありますが、セキュアピンパッドなどのより洗練されたデバイスでも使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R4 - The value displayed on the token MUST be easily read and entered by the user: This requires the HOTP value to be of reasonable length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R4  - トークンに表示されている値は、ユーザーによって簡単に読み取られて入力する必要があります。これにより、HOTP値が妥当な長さになることが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HOTP value must be at least a 6-digit value. It is also desirable that the HOTP value be &#39;numeric only&#39; so that it can be easily entered on restricted devices such as phones.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HOTP値は少なくとも6桁の値でなければなりません。HOTP値が「数値のみ」であるため、電話などの制限付き装置に簡単に入力できることも望ましい。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R5 - There MUST be user-friendly mechanisms available to resynchronize the counter. Section 7.4 and Appendix E.4 details the resynchronization mechanism proposed in this document
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R5  - カウンタを再同期するために使用可能なユーザーフレンドリーなメカニズムがある必要があります。セクション7.4および付録E.4は、この文書で提案されている再同期メカニズムを詳細
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R6 - The algorithm MUST use a strong shared secret. The length of the shared secret MUST be at least 128 bits. This document RECOMMENDs a shared secret length of 160 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R6  - アルゴリズムは強力な共有秘密を使用しなければなりません。共有秘密の長さは少なくとも128ビットでなければなりません。この文書は160ビットの共有秘密長を推奨しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--HOTP-Algorithm">
5. HOTP Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. HotPアルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this section, we introduce the notation and describe the HOTP algorithm basic blocks -- the base function to compute an HMAC-SHA-1 value and the truncation method to extract an HOTP value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、表記を紹介し、HOTPアルゴリズム基本ブロック -  HMAC-SHA-1値を計算するための基本関数とHotP値を抽出するためのトランケーション法を記述します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--Notation-and-Symbols">
5.1. Notation and Symbols
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 表記法と記号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A string always means a binary string, meaning a sequence of zeros and ones.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
文字列は常にバイナリ文字列を意味し、ゼロと1のシーケンスを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If s is a string, then |s| denotes its length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sが文字列の場合、その後
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If n is a number, then |n| denotes its absolute value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nが数値の場合、その後
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If s is a string, then s[i] denotes its i-th bit. We start numbering the bits at 0, so s = s[0]s[1]...s[n-1] where n = |s| is the length of s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sが文字列である場合、s [i]はそのi番目のビットを表す。ビットの番号を0に始めますので、s = s [0] s [1] ... s [n-1]ここでn =
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let StToNum (String to Number) denote the function that as input a string s returns the number whose binary representation is s. (For example, StToNum(110) = 6.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sttonum（文字列to numver）を入力として文字列sが2進表現がsを返す関数を表す。（例えば、Sttonum（110）= 6）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here is a list of symbols used in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはこの文書で使用されているシンボルのリストです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Symbol  Represents
   -------------------------------------------------------------------
   C       8-byte counter value, the moving factor.  This counter
           MUST be synchronized between the HOTP generator (client)
           and the HOTP validator (server).
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
K shared secret between client and server; each HOTP generator has a different and unique secret K.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kクライアントとサーバー間の秘密を共有しました。各HotPジェネレータには、異なる独自の秘密Kがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
T throttling parameter: the server will refuse connections from a user after T unsuccessful authentication attempts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tスロットルパラメータ：認証失敗の試行後に、サーバーはユーザーからの接続を拒否します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
s resynchronization parameter: the server will attempt to verify a received authenticator across s consecutive counter values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
■再同期パラメータ：サーバーは、S連続したカウンタ値で受信したオーセンティケータを検証しようとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Digit number of digits in an HOTP value; system parameter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
桁数HOTP値の桁数。システムパラメータ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--Description">
5.2. Description
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. description
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HOTP algorithm is based on an increasing counter value and a static symmetric key known only to the token and the validation service. In order to create the HOTP value, we will use the HMAC-SHA-1 algorithm, as defined in RFC 2104 [BCK2].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HOTPアルゴリズムは、トークンと検証サービスにのみ知られている静的対称鍵と静的対称鍵とに基づいています。HOTP値を作成するために、RFC 2104 [BCK2]で定義されているように、HMAC-SHA-1アルゴリズムを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As the output of the HMAC-SHA-1 calculation is 160 bits, we must truncate this value to something that can be easily entered by a user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HMAC-SHA-1計算の出力が160ビットであるため、ユーザーが簡単に入力できるものにこの値を切り捨てる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- Truncate represents the function that converts an HMAC-SHA-1 value into an HOTP value as defined in Section 5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- Truncateは、セクション5.3で定義されているように、HMAC-SHA-1値をHOTP値に変換する関数を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Key (K), the Counter (C), and Data values are hashed high-order byte first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キー（k）、カウンタ（c）、およびデータ値は、最初に高次バイトをハッシュした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HOTP values generated by the HOTP generator are treated as big endian.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HotP Generatorによって生成されたHOTP値は大きなエンディアンとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3--Generating-an-HOTP-Value">
5.3. Generating an HOTP Value
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. HotP値を生成します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We can describe the operations in 3 distinct steps:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3つの異なるステップで操作を説明することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Step 1: Generate an HMAC-SHA-1 value Let HS = HMAC-SHA-1(K,C)  // HS
   is a 20-byte string
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Step 2: Generate a 4-byte string (Dynamic Truncation)
   Let Sbits = DT(HS)   //  DT, defined below,
                        //  returns a 31-bit string
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Step 3: Compute an HOTP value
   Let Snum  = StToNum(Sbits)   // Convert S to a number in
                                    0...2^{31}-1
   Return D = Snum mod 10^Digit //  D is a number in the range
                                    0...10^{Digit}-1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Truncate function performs Step 2 and Step 3, i.e., the dynamic truncation and then the reduction modulo 10^Digit. The purpose of the dynamic offset truncation technique is to extract a 4-byte dynamic binary code from a 160-bit (20-byte) HMAC-SHA-1 result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
切り捨て機能は、ステップ2およびステップ3、すなわち動的切り捨て、次いで減少モジュロ10 ^桁を実行する。動的オフセット切り捨て技術の目的は、160ビット（20バイト）のHMAC-SHA-1の結果から4バイトの動的バイナリコードを抽出することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    DT(String) // String = String[0]...String[19]
     Let OffsetBits be the low-order 4 bits of String[19]
     Offset = StToNum(OffsetBits) // 0 &lt;= OffSet &lt;= 15
     Let P = String[OffSet]...String[OffSet+3]
     Return the Last 31 bits of P
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reason for masking the most significant bit of P is to avoid confusion about signed vs. unsigned modulo computations. Different processors perform these operations differently, and masking out the signed bit removes all ambiguity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pの最上位ビットをマスキングする理由は、符号付きVS.符号なしモジュロ計算についての混乱を避けることです。さまざまなプロセッサがこれらの操作を異ならず実行し、署名されたビットをマスキングすると、すべてのあいまいさが削除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MUST extract a 6-digit code at a minimum and possibly 7 and 8-digit code. Depending on security requirements, Digit = 7 or more SHOULD be considered in order to extract a longer HOTP value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、最小およびおそらく7桁のコードで6桁のコードを抽出する必要があります。セキュリティ要件に応じて、より長いHOTP値を抽出するために、Digit = 7以上を考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following paragraph is an example of using this technique for Digit = 6, i.e., that a 6-digit HOTP value is calculated from the HMAC value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の段落は、この技術をDIGIT = 6、すなわち6桁のHOTP値をHMAC値から計算することの一例である。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4--Example-of-HOTP-Computation-for-Digit--6">
5.4. Example of HOTP Computation for Digit = 6
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. DIGIT = 6のHOTP計算の例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following code example describes the extraction of a dynamic binary code given that hmac_result is a byte array with the HMAC-SHA-1 result:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のコード例は、HMAC_RESULTがHMAC-SHA-1の結果を持つバイト配列であることを考えると、動的バイナリコードの抽出を説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        int offset   =  hmac_result[19] &amp; 0xf ;
        int bin_code = (hmac_result[offset]  &amp; 0x7f) &lt;&lt; 24
           | (hmac_result[offset+1] &amp; 0xff) &lt;&lt; 16
           | (hmac_result[offset+2] &amp; 0xff) &lt;&lt;  8
           | (hmac_result[offset+3] &amp; 0xff) ;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHA-1 HMAC Bytes (Example)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHA-1 HMACバイト（例）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   -------------------------------------------------------------
   | Byte Number                                               |
   -------------------------------------------------------------
   |00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|
   -------------------------------------------------------------
   | Byte Value                                                |
   -------------------------------------------------------------
   |1f|86|98|69|0e|02|ca|16|61|85|50|ef|7f|19|da|8e|94|5b|55|5a|
   -------------------------------***********----------------++|
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The last byte (byte 19) has the hex value 0x5a. * The value of the lower 4 bits is 0xa (the offset value). * The offset value is byte 10 (0xa). * The value of the 4 bytes starting at byte 10 is 0x50ef7f19, which is the dynamic binary code DBC1. * The MSB of DBC1 is 0x50 so DBC2 = DBC1 = 0x50ef7f19 . * HOTP = DBC2 modulo 10^6 = 872921.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 最後のバイト（バイト19）は16進値0x5aを有する。*下位4ビットの値は0xa（オフセット値）です。*オフセット値はバイト10（0xa）です。*バイト10から始まる4バイトの値は、ダイナミックバイナリコードDBC1である0x50ef7F19です。※DBC1のMSBは0x50ですので、dbc2 = dbc1 = 0x50ef7f19です。* HOTP = DBC2モジュロ10 ^ 6 = 872921。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We treat the dynamic binary code as a 31-bit, unsigned, big-endian integer; the first byte is masked with a 0x7f.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ダイナミックバイナリコードを31ビット、符号なし、ビッグエンディアン整数として扱います。最初のバイトは0x7fでマスクされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We then take this number modulo 1,000,000 (10^6) to generate the 6- digit HOTP value 872921 decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その後、この番号モジュロ1,000,000（10 ^ 6）を取り、6桁のHOTP値872921 10進数を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Security-Considerations">
6. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The conclusion of the security analysis detailed in the Appendix is that, for all practical purposes, the outputs of the Dynamic Truncation (DT) on distinct counter inputs are uniformly and independently distributed 31-bit strings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付録に詳述されているセキュリティ分析の締結は、すべての実用的な目的のために、異なるカウンタ入力上の動的切り捨て（DT）の出力が一律に独立して31ビットの文字列に分布していることである。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security analysis then details the impact of the conversion from a string to an integer and the final reduction modulo 10^Digit, where Digit is the number of digits in an HOTP value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティ分析は、文字列から整数への変換の影響と最終的な削減モジュロ10 ^桁の影響を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The analysis demonstrates that these final steps introduce a negligible bias, which does not impact the security of the HOTP algorithm, in the sense that the best possible attack against the HOTP function is the brute force attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
分析は、これらの最終ステップがHOTP機能に対する最良の攻撃がブルートフォース攻撃であるという意味で、HOTPアルゴリズムのセキュリティに影響を与えない無視できないバイアスを導入することを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming an adversary is able to observe numerous protocol exchanges and collect sequences of successful authentication values. This adversary, trying to build a function F to generate HOTP values based on his observations, will not have a significant advantage over a random guess.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
敵対者が多数のプロトコル交換を観察し、認証値の成功したシーケンスを収集することができると仮定します。彼の観察に基づいてHotP値を生成するための関数fを構築しようとするこの敵対者は、ランダムな推測よりも大きな利点を持たないでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The logical conclusion is simply that the best strategy will once again be to perform a brute force attack to enumerate and try all the possible values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
論理的な結論は、最良の戦略が再び列挙してすべての可能な値を試してみるためにも、最良の戦略が再びブルートフォース攻撃を実行することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Considering the security analysis in the Appendix of this document, without loss of generality, we can approximate closely the security of the HOTP algorithm by the following formula:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般性を失うことなく、この文書の付録のセキュリティ分析を考慮すると、次の式でHOTPアルゴリズムのセキュリティを密接に近似しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            Sec = sv/10^Digit
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Where:
     - Sec is the probability of success of the adversary;
     - s is the look-ahead synchronization window size;
     - v is the number of verification attempts;
     - Digit is the number of digits in HOTP values.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Obviously, we can play with s, T (the Throttling parameter that would limit the number of attempts by an attacker), and Digit until achieving a certain level of security, still preserving the system usability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
明らかに、S、T（攻撃者による試行回数を制限するスロットルパラメータ）で再生することができ、一定レベルのセキュリティを達成するまでの数字はシステムの使いやすさを保ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Security-Requirements">
7. Security Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. セキュリティ要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any One-Time Password algorithm is only as secure as the application and the authentication protocols that implement it. Therefore, this section discusses the critical security requirements that our choice of algorithm imposes on the authentication protocol and validation software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1回限りのパスワードアルゴリズムは、アプリケーションと同じくらい安全なものと、実装する認証プロトコルです。したがって、このセクションでは、認証プロトコルと検証ソフトウェアにアルゴリズムの選択が課されるという重大なセキュリティ要件について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The parameters T and s discussed in this section have a significant impact on the security -- further details in Section 6 elaborate on the relations between these parameters and their impact on the system security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションで説明されているパラメータtとsは、セキュリティに大きな影響を与えます - セクション6のさらなる詳細は、これらのパラメータとシステムセキュリティへの影響の影響について詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is also important to remark that the HOTP algorithm is not a substitute for encryption and does not provide for the privacy of data transmission. Other mechanisms should be used to defeat attacks aimed at breaking confidentiality and privacy of transactions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HOTPアルゴリズムが暗号化の代わりにならず、データ伝送のプライバシーを提供しないと注意することも重要です。他のメカニズムは、機密性と取引のプライバシーを破ることを目的とした攻撃を軽減するために使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1--Authentication-Protocol-Requirements">
7.1. Authentication Protocol Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 認証プロトコルの要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We introduce in this section some requirements for a protocol P implementing HOTP as the authentication method between a prover and a verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、ProverとVerifierとの間の認証方法としてHOTPを実装するプロトコルPのいくつかの要件を紹介します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RP1 - P MUST support two-factor authentication, i.e., the communication and verification of something you know (secret code such as a Password, Pass phrase, PIN code, etc.) and something you have (token). The secret code is known only to the user and usually entered with the One-Time Password value for authentication purpose (two-factor authentication).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RP1  -  Pは、2要素認証、すなわち、あなたが知っているものの通信と検証（パスワードなどの秘密コード、パスフレーズ、ピンコードなど）とあなたが持っているもの（トークン）をサポートしなければなりません。秘密コードは、ユーザーだけが知られており、通常は認証目的のためのワンタイムパスワード値（2要素認証）で入力されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RP2 - P SHOULD NOT be vulnerable to brute force attacks. This implies that a throttling/lockout scheme is RECOMMENDED on the validation server side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RP2  -  Pはブルートフォース攻撃に対して脆弱ではありません。これは、検証サーバ側でスロットル/ロックアウト方式を推奨することを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RP3 - P SHOULD be implemented over a secure channel in order to protect users&#39; privacy and avoid replay attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RP3  -  Pは、ユーザーのプライバシーを保護し、再生攻撃を避けるために安全なチャネルを介して実装されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-2--Validation-of-HOTP-Values">
7.2. Validation of HOTP Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. HOTP値の検証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HOTP client (hardware or software token) increments its counter and then calculates the next HOTP value HOTP client. If the value received by the authentication server matches the value calculated by the client, then the HOTP value is validated. In this case, the server increments the counter value by one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HOTPクライアント（ハードウェアまたはソフトウェアトークン）はそのカウンタをインクリメントしてから、次のHOTP値HotPクライアントを計算します。認証サーバによって受信された値がクライアントによって計算された値と一致する場合、HotP値は検証されます。この場合、サーバはカウンタ値を1つずつ増分します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the value received by the server does not match the value calculated by the client, the server initiate the resynch protocol (look-ahead window) before it requests another pass.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーによって受信された値がクライアントによって計算された値と一致しない場合、サーバーは別のパスを要求する前にResynchプロトコル（先読みウィンドウ）を開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the resynch fails, the server asks then for another authentication pass of the protocol to take place, until the maximum number of authorized attempts is reached.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再シンチが失敗した場合、サーバーは、許可された試行の最大数に達するまで、プロトコルの別の認証パスを実行するために尋ねます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If and when the maximum number of authorized attempts is reached, the server SHOULD lock out the account and initiate a procedure to inform the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
許可された試行の最大数に達すると、サーバーはアカウントをロックアウトしてユーザーに通知するための手順を開始する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-3--Throttling-at-the-Server">
7.3. Throttling at the Server
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. サーバーでのスロットル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Truncating the HMAC-SHA-1 value to a shorter value makes a brute force attack possible. Therefore, the authentication server needs to detect and stop brute force attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HMAC-SHA-1値を短い値に切り捨てると、ブルートフォース攻撃が可能になります。したがって、認証サーバーはブルートフォース攻撃を検出して停止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We RECOMMEND setting a throttling parameter T, which defines the maximum number of possible attempts for One-Time Password validation. The validation server manages individual counters per HOTP device in order to take note of any failed attempt. We RECOMMEND T not to be too large, particularly if the resynchronization method used on the server is window-based, and the window size is large. T SHOULD be set as low as possible, while still ensuring that usability is not significantly impacted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1回限りのパスワード検証の可能な試行の最大数を定義するスロットルパラメータTを設定することをお勧めします。検証サーバーは、失敗した試みに注目するために、HotPデバイスごとの個々のカウンタを管理します。特にサーバで使用されている再同期メソッドがウィンドウベースで、ウィンドウサイズが大きい場合は、大きすぎないことをお勧めします。使用可能性が著しく影響を与えないようにしながら、Tはできるだけ低く設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another option would be to implement a delay scheme to avoid a brute force attack. After each failed attempt A, the authentication server would wait for an increased T*A number of seconds, e.g., say T = 5, then after 1 attempt, the server waits for 5 seconds, at the second failed attempt, it waits for 5*2 = 10 seconds, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もう1つの選択肢は、ブルートフォース攻撃を回避するための遅延方式を実装することです。失敗した各試行Aの後、認証サーバは、T = 5、例えばT = 5の秒数を増やすのを待ち、次に1回の試行後、サーバは5秒間待ってから5秒間待ってから、5を待つ* 2 = 10秒など
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The delay or lockout schemes MUST be across login sessions to prevent attacks based on multiple parallel guessing techniques.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
遅延スキームまたはロックアウトスキームは、複数の並列推測技術に基づく攻撃を防ぐためにログインセッション間でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-4--Resynchronization-of-the-Counter">
7.4. Resynchronization of the Counter
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. カウンタの再同期化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the server&#39;s counter value is only incremented after a successful HOTP authentication, the counter on the token is incremented every time a new HOTP is requested by the user. Because of this, the counter values on the server and on the token might be out of synchronization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのカウンタ値は、HOTP認証が成功した後にのみインクリメントされますが、新しいHOTPがユーザーから要求されるたびにトークンのカウンタが増加します。このため、サーバー上のカウンタ値とトークンのカウンタ値が同期している可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We RECOMMEND setting a look-ahead parameter s on the server, which defines the size of the look-ahead window. In a nutshell, the server can recalculate the next s HOTP-server values, and check them against the received HOTP client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
先読みウィンドウのサイズを定義するサーバーに先読みのパラメータSを設定することをお勧めします。一言で言えば、サーバーは次のH HotP-Serverの値を再計算し、受信したHotPクライアントに対してそれらをチェックすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Synchronization of counters in this scenario simply requires the server to calculate the next HOTP values and determine if there is a match. Optionally, the system MAY require the user to send a sequence of (say, 2, 3) HOTP values for resynchronization purpose, since forging a sequence of consecutive HOTP values is even more difficult than guessing a single HOTP value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このシナリオのカウンタの同期には、サーバーが次のHOTP値を計算し、一致があるかどうかを判断する必要があります。任意選択で、システムは、連続したHOTP値の順序を単一のHOTP値を推測するよりもさらに困難であるため、ユーザに再同期的な目的のための順序（例えば、2,3）のHOTP値を送信することを要求することができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The upper bound set by the parameter s ensures the server does not go on checking HOTP values forever (causing a denial-of-service attack) and also restricts the space of possible solutions for an attacker trying to manufacture HOTP values. s SHOULD be set as low as possible, while still ensuring that usability is not impacted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パラメータの上限セットSは、サーバーが永久に永遠にHOTP値を確認しないことを確認し、攻撃者がHotP値を製造しようとしているための可能な解決策のスペースを制限します。■使用可能性が影響を及ぼさないようにしながら、Sはできるだけ低く設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-5--Management-of-Shared-Secrets">
7.5. Management of Shared Secrets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. 共用秘密の管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operations dealing with the shared secrets used to generate and verify OTP values must be performed securely, in order to mitigate risks of any leakage of sensitive information. We describe in this section different modes of operations and techniques to perform these different operations with respect to the state of the art in data security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
機密情報の漏洩のリスクを軽減するために、OTP値を生成し検証するために使用される共有秘密を処理するために使用されなければならない。このセクションでは、データセキュリティにおける最新技術に関してこれらの異なる動作を実行するためのさまざまな動作モードとテクニックのモードについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We can consider two different avenues for generating and storing (securely) shared secrets in the Validation system:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
検証システムで共有秘密を生成して保存するための2つの異なる手当を検討することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Deterministic Generation: secrets are derived from a master seed, both at provisioning and verification stages and generated on-the-fly whenever it is required. * Random Generation: secrets are generated randomly at provisioning stage and must be stored immediately and kept secure during their life cycle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 決定論的生成：秘密は、プロビジョニングおよび検証段階で、およびそれが必要とされるたびにオンザフライで生成されたマスターシードから派生しています。*ランダム発生：秘密は、プロビジョニング段階でランダムに生成され、すぐに保存し、ライフサイクルの間安全に保たれなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Deterministic Generation
   ------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A possible strategy is to derive the shared secrets from a master secret. The master secret will be stored at the server only. A tamper-resistant device MUST be used to store the master key and derive the shared secrets from the master key and some public information. The main benefit would be to avoid the exposure of the shared secrets at any time and also avoid specific requirements on storage, since the shared secrets could be generated on-demand when needed at provisioning and validation time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能な戦略は、マスターシークレットから共有秘密を導き出すことです。マスターシークレットはサーバーにのみ保存されます。マスターキーを保管し、マスターキーといくつかの公開情報から共有された秘密を導き出すために、耐タンパーのデバイスを使用する必要があります。主な利点は、共有秘密の露出を回避し、プロビジョニングおよび検証の時間に必要な場合に共有された秘密がオンデマンドで生成される可能性があるため、Shared Secretsがストレージ上の特定の要件を回避することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We distinguish two different cases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つの異なるケースを区別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- A single master key MK is used to derive the shared secrets; each HOTP device has a different secret, K_i = SHA-1 (MK,i) where i stands for a public piece of information that identifies uniquely the HOTP device such as a serial number, a token ID, etc. Obviously, this is in the context of an application or service -- different application or service providers will have different secrets and settings. - Several master keys MK_i are used and each HOTP device stores a set of different derived secrets, {K_i,j = SHA-1(MK_i,j)} where j stands for a public piece of information identifying the device. The idea would be to store ONLY the active master key at the validation server, in the Hardware Security Module (HSM), and keep in a safe place, using secret sharing methods such as [Shamir] for instance. In this case, if a master secret MK_i is compromised, then it is possible to switch to another secret without replacing all the devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- シングルマスターキーMKを使用して共有秘密を導出する。各HOTPデバイスには、シリアル番号、トークンIDなどのHOTPデバイス、トークンIDなどの一意的に識別される公開情報が明らかに、これが存在するアプリケーションまたはサービスのコンテキスト - さまざまなアプリケーションまたはサービスプロバイダーには、秘密と設定が異なります。 - いくつかのマスタキーMK_Iが使用され、各HotPデバイスは異なる派生秘密のセットを格納し、ここでJはデバイスを識別する公開情報を表す。このアイデアは、検証サーバーのアクティブマスターキーのみをハードウェアセキュリティモジュール（HSM）に格納し、例えば[Shamir]などの秘密の共有方法を使用して安全な場所に保存することです。この場合、マスターシークレットMK_Iが危険にさらされている場合、すべてのデバイスを交換することなく別の秘密に切り替えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The drawback in the deterministic case is that the exposure of the master secret would obviously enable an attacker to rebuild any shared secret based on correct public information. The revocation of all secrets would be required, or switching to a new set of secrets in the case of multiple master keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
決定論的な場合の欠点は、マスターシークレットのエクスポージャーが明らかに攻撃者が正しい公開情報に基づいて共有秘密を再構築できることです。複数のマスターキーの場合、すべての秘密の取り消しが必要です。または複数のマスターキーの場合は新しい秘密セットに切り替えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On the other hand, the device used to store the master key(s) and generate the shared secrets MUST be tamper resistant. Furthermore, the HSM will not be exposed outside the security perimeter of the validation system, therefore reducing the risk of leakage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方、マスターキーを保存し、共有秘密を生成するために使用される装置は、耐タンパーでなければなりません。さらに、HSMは検証システムのセキュリティ境界の外側に露出しないため、漏洩のリスクが低下します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Random Generation
   -----------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The shared secrets are randomly generated. We RECOMMEND following the recommendations in [RFC4086] and selecting a good and secure random source for generating these secrets. A (true) random generator requires a naturally occurring source of randomness. Practically, there are two possible avenues to consider for the generation of the shared secrets:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有秘密はランダムに生成されます。[RFC4086]の推奨事項に従って、これらの秘密を生成するための良い安全なランダムソースを選択することをお勧めします。（真）ランダムジェネレータでは、天然に発生したランダム性源が必要です。実際には、共有秘密の生成について考慮すべき2つの方法があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 * Hardware-based generators: they exploit the randomness that occurs in physical phenomena. A nice implementation can be based on oscillators and built in such ways that active attacks are more difficult to perform.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
*ハードウェアベースの発電機：物理現象で発生したランダム性を悪用しています。素敵な実装は発振器に基づいており、そのような方法で活発な攻撃が実行が難しいという方法で構築できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 * Software-based generators: designing a good software random generator is not an easy task. A simple, but efficient, implementation should be based on various sources and apply to the sampled sequence a one-way function such as SHA-1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
*ソフトウェアベースのジェネレータ：優れたソフトウェアランダムジェネレータの設計は簡単な作業ではありません。シンプルだが効率的な実装は、さまざまなソースに基づいており、サンプリングされたシーケンスにSHA-1などの一方向機能に適用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We RECOMMEND selecting proven products, being hardware or software generators, for the computation of shared secrets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有秘密の計算のために、実績のある製品、ハードウェアまたはソフトウェアジェネレータであることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We also RECOMMEND storing the shared secrets securely, and more specifically encrypting the shared secrets when stored using tamper-resistant hardware encryption and exposing them only when required: for example, the shared secret is decrypted when needed to verify an HOTP value, and re-encrypted immediately to limit exposure in the RAM for a short period of time. The data store holding the shared secrets MUST be in a secure area, to avoid as much as possible direct attack on the validation system and secrets database.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、共有秘密を安全に保存することをお勧めし、耐タンパーのハードウェア暗号化を使用して保存したときに共有秘密を暗号化し、必要な場合にのみそれらを公開している場合は、共有秘密を暗号化することをお勧めします。たとえば、Shared Secretは、HotP値を検証するために必要なときに復号化されます。すぐに暗号化されてRAMの露出を短時間制限します。共有された秘密を保持しているデータストアは、検証システムと秘密データベースに対するできる限り直接攻撃を回避するために安全な領域になければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Particularly, access to the shared secrets should be limited to programs and processes required by the validation system only. We will not elaborate on the different security mechanisms to put in place, but obviously, the protection of shared secrets is of the uttermost importance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に、共有秘密へのアクセスは、検証システムのみに必要なプログラムやプロセスに限定されるべきです。私たちは整備されるさまざまなセキュリティメカニズムについて詳しく述べることはできませんが、明らかに共有秘密の保護は最新の重要性です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Composite-Shared-Secrets">
8. Composite Shared Secrets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. コンポジット共有秘密
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It may be desirable to include additional authentication factors in the shared secret K. These additional factors can consist of any data known at the token but not easily obtained by others. Examples of such data include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの追加の要因は、トークンで知られているが他のものによって容易に得られないデータからなることができる。そのようなデータの例は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* PIN or Password obtained as user input at the token * Phone number * Any unique identifier programmatically available at the token
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* トークン*電話番号でユーザー入力として取得されたPINまたはパスワード*トークンでプログラムで利用可能な一意の識別子
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this scenario, the composite shared secret K is constructed during the provisioning process from a random seed value combined with one or more additional authentication factors. The server could either build on-demand or store composite secrets -- in any case, depending on implementation choice, the token only stores the seed value. When the token performs the HOTP calculation, it computes K from the seed value and the locally derived or input values of the other authentication factors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このシナリオでは、複合共有シークレットKは、1つまたは複数の追加の認証要因と組み合わされたランダムシード値からプロビジョニングプロセス中に構築されます。サーバーは、オンデマンドまたはストアコンポジット秘密を構築することができます - いずれに応じて、実装の選択に応じて、トークンはシード値のみを格納します。トークンがHOTP計算を実行すると、シード値と他の認証係数の局所的に導出されたまたは入力値からkを計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of composite shared secrets can strengthen HOTP-based authentication systems through the inclusion of additional authentication factors at the token. To the extent that the token is a trusted device, this approach has the further benefit of not requiring exposure of the authentication factors (such as the user input PIN) to other devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンポジット共有秘密の使用は、トークンに追加の認証要素を含めることによってHOTPベースの認証システムを強化することができます。トークンが信頼できるデバイスである限り、このアプローチは、認証要因（ユーザ入力端子など）を他の機器に露出させないというさらなる利点を有する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--Bi-Directional-Authentication">
9. Bi-Directional Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 双方向認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interestingly enough, the HOTP client could also be used to authenticate the validation server, claiming that it is a genuine entity knowing the shared secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
興味深いことに、HotPクライアントは検証サーバーを認証するために使用され、それが共有された秘密を知っている本物のエンティティであると主張することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Since the HOTP client and the server are synchronized and share the
   same secret (or a method to recompute it), a simple 3-pass protocol
   could be put in place:
   1- The end user enter the TokenID and a first OTP value OTP1;
   2- The server checks OTP1 and if correct, sends back OTP2;
   3- The end user checks OTP2 using his HOTP device and if correct,
      uses the web site.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Obviously, as indicated previously, all the OTP communications have to take place over a secure channel, e.g., SSL/TLS, IPsec connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
明らかに、前述のように、すべてのOTP通信は、SSL / TLS、IPsec接続を安全なチャネルで行わなければならない。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--Conclusion">
10. Conclusion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 結論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes HOTP, a HMAC-based One-Time Password algorithm. It also recommends the preferred implementation and related modes of operations for deploying the algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、HOTP、HMACベースのワンタイムパスワードアルゴリズムについて説明します。アルゴリズムを展開するための好ましい実装形態および関連する動作モードもまた推奨される。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The document also exhibits elements of security and demonstrates that the HOTP algorithm is practical and sound, the best possible attack being a brute force attack that can be prevented by careful implementation of countermeasures in the validation server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書はまた、セキュリティの要素を示し、HOTPアルゴリズムが実用的で健全であることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Eventually, several enhancements have been proposed, in order to improve security if needed for specific applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最終的には、特定のアプリケーションに必要な場合はセキュリティを向上させるために、いくつかの機能強化が提案されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11--Acknowledgements">
11. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. 謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors would like to thank Siddharth Bajaj, Alex Deacon, Loren Hart, and Nico Popp for their help during the conception and redaction of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者らは、Siddharth Bajaj、Alex Deacon、Loren Hart、およびNico Poppに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12--Contributors">
12. Contributors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. 貢献者
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors of this document would like to emphasize the role of three persons who have made a key contribution to this document:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書の著者は、この文書に重要な貢献をした3人の人の役割を強調したいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Laszlo Elteto is system architect with SafeNet, Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Laszlo EltetoはSafenet、Inc。のシステムアーキテクトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Ernesto Frutos is director of Engineering with Authenex, Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Ernesto FrutosはAuthenex、Inc。のエンジニアリングディレクターです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Fred McClain is Founder and CTO with Boojum Mobile, Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Fred McClainは創設者とBoojum Mobile、Inc。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Without their advice and valuable inputs, this document would not be the same.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
彼らのアドバイスや貴重な入力がなければ、この文書は同じではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13--References">
13. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-1--Normative-References">
13.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BCK1] M. Bellare, R. Canetti and H. Krawczyk, &#34;Keyed Hash Functions and Message Authentication&#34;, Proceedings of Crypto&#39;96, LNCS Vol. 1109, pp. 1-15.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BCK1] M. Bellare、R. CanettiおよびH. Krawczyk、「キー付きハッシュ関数およびメッセージ認証」、Crypto&#39;96、LNCS Vol。1109、PP。1-15。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BCK2] Krawczyk, H., Bellare, M., and R. Canetti, &#34;HMAC: Keyed-Hashing for Message Authentication&#34;, RFC 2104, February 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BCK2] Krawczyk、H.、Bellare、M.、およびR. Canetti、「HMAC：メッセージ認証のための鍵付きハジング」、RFC 2104、1997年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S、「RFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3979] Bradner, S., &#34;Intellectual Property Rights in IETF Technology&#34;, BCP 79, RFC 3979, March 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3979] BRADNER、S、「IETF技術における知的財産権」、BCP 79、RFC 3979、2005年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086] Eastlake, D., 3rd, Schiller, J., and S. Crocker, &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086, June 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086]イーストレイク、D.、第3、Schiller、J.、およびS. Crocker、「セキュリティのためのランダム性要件」、BCP 106、RFC 4086、2005年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13-2--Informative-References">
13.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OATH] Initiative for Open AuTHentication http://www.openauthentication.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[宣誓]オープン認証のためのイニシアチブhttp://www.openauthentication.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PrOo] B. Preneel and P. van Oorschot, &#34;MD-x MAC and building fast MACs from hash functions&#34;, Advances in Cryptology CRYPTO &#39;95, Lecture Notes in Computer Science Vol. 963, D. Coppersmith ed., Springer-Verlag, 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PRO] B. PreneelとP. van Oorschot、「ハッシュ関数からのMD-X MacとBuilsing Fast Mac」、Cryptology Crypto &#39;95、Computer Science Vol。963、D.Coppersmith、Springer-Verlag、1995。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Crack]    Crack in SHA-1 code &#39;stuns&#39; security gurus
              http://www.eetimes.com/showArticle.jhtml?
              articleID=60402150
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Sha1]     Bruce Schneier.  SHA-1 broken.  February 15, 2005.
              http://www.schneier.com/blog/archives/2005/02/
              sha1_broken.html
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Res]      Researchers: Digital encryption standard flawed
              http://news.com.com/
              Researchers+Digital+encryption+standard+flawed/
              2100-1002-5579881.html?part=dht&amp;tag=ntop&amp;tag=nl.e703
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Shamir] How to Share a Secret, by Adi Shamir. In Communications of the ACM, Vol. 22, No. 11, pp. 612-613, November, 1979.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Shamir] ADI Shamirによって秘密を共有する方法。ACMの通信では、Vol。22、No.11、pp.612-613、1979年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix A - HOTP Algorithm Security: Detailed Analysis
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録A  -  HOTPアルゴリズムのセキュリティ：詳細な分析
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security analysis of the HOTP algorithm is summarized in this section. We first detail the best attack strategies, and then elaborate on the security under various assumptions and the impact of the truncation and make some recommendations regarding the number of digits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HOTPアルゴリズムのセキュリティ分析をこのセクションにまとめる。私たちは最初に最高の攻撃戦略を詳しく説明してから、さまざまな仮定の下でセキュリティを詳しく説明し、切り捨ての影響を与え、数字の数に関していくつかの推奨事項を作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We focus this analysis on the case where Digit = 6, i.e., an HOTP function that produces 6-digit values, which is the bare minimum recommended in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Digit = 6、すなわち6桁の値を生成するHOTP関数は、この解析に焦点を当てます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-1--Definitions-and-Notations">
A.1. Definitions and Notations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. 定義と表記法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We denote by {0,1}^l the set of all strings of length l.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{0,1} ^ Lでは、長さLのすべての文字列の集合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Let Z_{n} = {0,.., n - 1}.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Let IntDiv(a,b) denote the integer division algorithm that takes
   input integers a, b where a &gt;= b &gt;= 1 and returns integers (q,r)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
the quotient and remainder, respectively, of the division of a by b. (Thus, a = bq + r and 0 &lt;= r &lt; b.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a by bの分割の商と残りの商品。（したがって、A = BQ R、0 &lt;= R &lt;b。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let H: {0,1}^k x {0,1}^c --&gt; {0,1}^n be the base function that takes a k-bit key K and c-bit counter C and returns an n-bit output H(K,C). (In the case of HOTP, H is HMAC-SHA-1; we use this formal definition for generalizing our proof of security.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
h：{0,1} ^ kx {0,1} ^ ^ c  - &gt; {0,1} ^ nは、Kビット鍵KとCビットカウンタCをとる基本関数であり、N-を返します。ビット出力H（k、c）。（HOTPの場合、HはHMAC-SHA-1です。この正式な定義は、セキュリティの証明を一般化するために使用します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-2--The-Idealized-Algorithm-HOTP-IDEAL">
A.2. The Idealized Algorithm: HOTP-IDEAL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. 理想化されたアルゴリズム：hotp-eidial.
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We now define an idealized counterpart of the HOTP algorithm. In this algorithm, the role of H is played by a random function that forms the key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これで、HOTPアルゴリズムの理想化された相手方を定義します。このアルゴリズムでは、hの役割はキーを形成するランダムな関数によって再生されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   To be more precise, let Maps(c,n) denote the set of all functions
   mapping from {0,1}^c to {0,1}^n.  The idealized algorithm has key
   space Maps(c,n), so that a &#34;key&#34; for such an algorithm is a function
   h from {0,1}^c to {0,1}^n.  We imagine this key (function) to be
   drawn at random.  It is not feasible to implement this idealized
   algorithm, since the key, being a function from {0,1}^c to {0,1}^n,
   is way too large to even store.  So why consider it?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Our security analysis will show that as long as H satisfies a certain well-accepted assumption, the security of the actual and idealized algorithms is for all practical purposes the same. The task that really faces us, then, is to assess the security of the idealized algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々のセキュリティ分析は、hが一定の妥当な仮定を満たす限り、実際の理想的なアルゴリズムのセキュリティはすべて同じ目的のためのものであることを示す。本当に私たちに直面しているタスクは、理想化されたアルゴリズムのセキュリティを評価することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In analyzing the idealized algorithm, we are concentrating on assessing the quality of the design of the algorithm itself, independently of HMAC-SHA-1. This is in fact the important issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
理想化されたアルゴリズムを分析する際には、HMAC-SHA-1とは無関係に、アルゴリズム自体の設計の品質を評価することに集中しています。これは実際には重要な問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-3--Model-of-Security">
A.3. Model of Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.3. セキュリティのモデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The model exhibits the type of threats or attacks that are being considered and enables one to assess the security of HOTP and HOTP-IDEAL. We denote ALG as either HOTP or HOTP-IDEAL for the purpose of this security analysis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このモデルは、検討されている脅威や攻撃の種類を示し、HOTPとHOTPのセキュリティを評価することができます。このセキュリティ分析の目的で、HOTPまたはHOTPのどちらかとしてALGを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The scenario we are considering is that a user and server share a key K for ALG. Both maintain a counter C, initially zero, and the user authenticates itself by sending ALG(K,C) to the server. The latter accepts if this value is correct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちが検討しているシナリオは、ユーザーとサーバーがALGのためのキーKを共有することです。カウンタC、最初はゼロを維持し、ユーザはALG（k、c）をサーバに送信することによってそれ自体を認証する。この値が正しい場合は後者が受け入れます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to protect against accidental increment of the user counter, the server, upon receiving a value z, will accept as long as z equals ALG(K,i) for some i in the range C,...,C + s-1, where s is the resynchronization parameter and C is the server counter. If it accepts with some value of i, it then increments its counter to i+1. If it does not accept, it does not change its counter value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザカウンタの偶発的な増分から保護するために、値zを受信すると、サーバは、zがC、...、C S  -  1の範囲内のALG（k、i）がa al（k、i）である限り受け入れるであろう。ここで、sは再同期パラメータで、Cはサーバーカウンタです。それがいくつかの値で受け入れている場合は、そのカウンタをI 1にインクリメントします。受け入れない場合は、そのカウンタ値は変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The model we specify captures what an adversary can do and what it needs to achieve in order to &#34;win&#34;. First, the adversary is assumed to be able to eavesdrop, meaning, to see the authenticator transmitted by the user. Second, the adversary wins if it can get the server to accept an authenticator relative to a counter value for which the user has never transmitted an authenticator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モデルは、敵対者ができることとそれが「勝利」するために達成する必要があるものを捉えます。まず、敵対者は、ユーザーが送信したオーセンティケータを見るために盗聴することができると想定されています。第二に、敵対者は、ユーザが認証者を送信したことがないカウンタ値を基準にしてサーバを認証者に受け入れることができる場合に勝利する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The formal adversary, which we denote by B, starts out knowing which algorithm ALG is being used, knowing the system design, and knowing all system parameters. The one and only thing it is not given a priori is the key K shared between the user and the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bで表す正式な敵対者は、どのアルゴリズムALGが使用されているか、システム設計を知っているか、およびすべてのシステムパラメータを知ることを知っています。それが先験的に与えられていないものだけではなく、ユーザーとサーバーの間で共有されているキーKです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The model gives B full control of the scheduling of events. It has access to an authenticator oracle representing the user. By calling this oracle, the adversary can ask the user to authenticate itself and get back the authenticator in return. It can call this oracle as often as it wants and when it wants, using the authenticators it accumulates to perhaps &#34;learn&#34; how to make authenticators itself. At any time, it may also call a verification oracle, supplying the latter with a candidate authenticator of its choice. It wins if the server accepts this accumulator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モデルはBイベントのスケジューリングの完全な制御を与えます。ユーザーを表すオーセンティケータオラクルにアクセスできます。このOracleを呼び出すことで、敵対者はユーザーに自分自身を認証し、認証者を返すように依頼することができます。これは、このオラクルを望んでいるのと同じくらい頻繁に呼び、いつ、それが際立ったときにそれが累積した認証者を「学習」自体の作り方」を「学習」します。いつでも、検証オラクルを呼び出して、後者をその選択の候補認証者に供給することもできます。サーバーがこのアキュムレータを受け入れると勝ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider the following game involving an adversary B that is attempting to compromise the security of an authentication algorithm ALG: K x {0,1}^c --&gt; R.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認証アルゴリズムalgのセキュリティを危うくしようとしている敵対的Bを含む次のゲームを考慮してください.K X {0,1} ^ C  -  R.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initializations - A key K is selected at random from K, a counter C is initialized to 0, and the Boolean value win is set to false.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期化 -  Key kがkからランダムに選択され、カウンタCが0に初期化され、ブール値Winがfalseに設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Game execution - Adversary B is provided with the two following oracles:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ゲームの実行 - 敵対者Bは、次の2つの企業があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Oracle AuthO()
   --------------
      A = ALG(K,C)
      C = C + 1
      Return O to B
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Oracle VerO(A)
   --------------
      i = C
      While (i &lt;= C + s - 1 and Win == FALSE) do
         If A == ALG(K,i) then Win = TRUE; C = i + 1
         Else i = i + 1
      Return Win to B
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AuthO() is the authenticator oracle and VerO(A) is the verification oracle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
autho（）はオーセンティケーターOracleで、Vero（A）は検証Oracleです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon execution, B queries the two oracles at will. Let Adv(B) be the probability that win gets set to true in the above game. This is the probability that the adversary successfully impersonates the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実行時に、Bは2つの造られます。上記のゲームでは、勝利が勝利する確率になる可能性があります。これは、敵対者がユーザーを首尾よく偽装する確率です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Our goal is to assess how large this value can be as a function of the number v of verification queries made by B, the number a of authenticator oracle queries made by B, and the running time t of B. This will tell us how to set the throttle, which effectively upper bounds v.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちの目標は、Bによって行われたAuthenticator Oracleクエリの数字A、Bの実行時刻T、BのランニングタイムTの数値A、およびBのランニングタイムTの数値vの関数として、この値を評価することです。スロットルを設定します。これは効果的に上限vです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-4--Security-of-the-Ideal-Authentication-Algorithm">
A.4. Security of the Ideal Authentication Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4. 理想認証アルゴリズムのセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section summarizes the security analysis of HOTP-IDEAL, starting with the impact of the conversion modulo 10^Digit and then focusing on the different possible attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、変換モジュロ10 ^桁の影響から始めて、その後異なる可能な攻撃に焦点を当ててから、HOTP理想のセキュリティ分析を要約します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-4-1--From-Bits-to-Digits">
A.4.1. From Bits to Digits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.1. ビットから数字へ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The dynamic offset truncation of a random n-bit string yields a random 31-bit string. What happens to the distribution when it is taken modulo m = 10^Digit, as done in HOTP? The following lemma estimates the biases in the outputs in this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ランダムなnビット列の動的オフセット切り捨ては、ランダムな31ビット文字列を生成します。HOTPで行われたように、M = 10 ^桁のモジュロM = 10 ^桁の桁数が得られるのは何ですか？次のLEMMAは、この場合の出力のバイアスを推定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Lemma 1
   -------
   Let N &gt;= m &gt;= 1 be integers, and let (q,r) = IntDiv(N,m).  For z in
   Z_{m} let:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          P_{N,m}(z) = Pr [x mod m = z : x randomly pick in Z_{n}]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Then for any z in Z_{m}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それからz_ {m}のzのzについて
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   P_{N,m}(z) =   (q + 1) / N    if 0 &lt;= z &lt; r
                  q / N          if r &lt;= z &lt; m
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Proof of Lemma 1
   ----------------
   Let the random variable X be uniformly distributed over Z_{N}.  Then:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   P_{N,m}(z)  = Pr [X mod m = z]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                = Pr [X &lt; mq] * Pr [X mod m = z| X &lt; mq]
                + Pr [mq &lt;= X &lt; N] * Pr [X mod m = z| mq &lt;= X &lt; N]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                = mq/N * 1/m +
                   (N - mq)/N * 1 / (N - mq)     if 0 &lt;= z &lt; N - mq
                   0                             if N - mq &lt;= z &lt;= m
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                = q/N +
                   r/N * 1 / r                   if 0 &lt;= z &lt; N - mq
                   0                             if r &lt;= z &lt;= m
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Simplifying yields the claimed equation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単純化は要求された式を歩留まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let N = 2^31, d = 6, and m = 10^d. If x is chosen at random from Z_{N} (meaning, is a random 31-bit string), then reducing it to a 6- digit number by taking x mod m does not yield a random 6-digit number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
n = 2 ^ 31、d = 6、およびm = 10 ^ dとする。xがz_ {n}からランダムに選択された場合（つまりランダムな31ビット文字列）、x mod mを取ることによって6桁の数値を減らすことはランダムな6桁の数字を生成しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rather, x mod m is distributed as shown in the following table:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
むしろ、X MOD Mは次の表に示すように分散されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Values               Probability that each appears as output
   ----------------------------------------------------------------
   0,1,...,483647       2148/2^31 roughly equals to 1.00024045/10^6
   483648,...,999999    2147/2^31 roughly equals to 0.99977478/10^6
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If X is uniformly distributed over Z_{2^31} (meaning, is a random 31-bit string), then the above shows the probabilities for different outputs of X mod 10^6. The first set of values appears with probability slightly greater than 10^-6, the rest with probability slightly less, meaning that the distribution is slightly non-uniform.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
xがz_ {2 ^ 31}（つまりランダムな31ビット文字列）を介して一様に分布している場合、上記はX MOD 10 ^ 6の異なる出力に対する確率を示しています。最初の値のセットは、10 ^ -6よりわずかに大きい確率で、確率はわずかに少ない残り、つまり分布はわずかに不均一です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, as the table above indicates, the bias is small, and as we will see later, negligible: the probabilities are very close to 10^-6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかしながら、上の表は示されているので、バイアスは小さいので、後で見ても見られるように、確率は10 ^ -6に非常に近い。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-4-2--Brute-Force-Attacks">
A.4.2. Brute Force Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.2. ブルートフォース攻撃
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the authenticator consisted of d random digits, then a brute force attack using v verification attempts would succeed with probability sv/10^Digit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーセンティケータがDランダムな数字で構成されている場合、V検証試行を使用したブルートフォース攻撃は確率SV / 10 ^桁で成功します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, an adversary can exploit the bias in the outputs of HOTP-IDEAL, predicted by Lemma 1, to mount a slightly better attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかしながら、敵対者は、LEMMA 1によって予測されたHOTP  - 理想の出力におけるバイアスを利用して、わずかに優れた攻撃を取り付けることができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Namely, it makes authentication attempts with authenticators that are the most likely values, meaning the ones in the range 0,...,r - 1, where (q,r) = IntDiv(2^31,10^Digit).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すなわち、最も可能性の高い値であるオーセンティケーターを使用して認証を試みます。これは、0、...、R-1の範囲内のもの、ここで（q、r）= intdiv（2 ^ 31,10 ^桁）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following specifies an adversary in our model of security that mounts the attack. It estimates the success probability as a function of the number of verification queries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、攻撃をマウントするセキュリティのモデルの敵対者を指定しています。それは、検証クエリの数の関数としての成功確率を推定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For simplicity, we assume that the number of verification queries is at most r. With N = 2^31 and m = 10^6, we have r = 483,648, and the throttle value is certainly less than this, so this assumption is not much of a restriction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
簡単にするために、検証クエリの数が最大であると仮定します。n = 2 ^ 31およびm = 10 ^ 6では、r = 483,648であり、スロットル値は確かにこれよりも小さいので、この仮定はそれほど制限のなかった。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Proposition 1
   -------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Suppose m = 10^Digit &lt; 2^31, and let (q,r) = IntDiv(2^31,m).  Assume
   s &lt;= m.  The brute-force-attack adversary B-bf attacks HOTP using v
   &lt;= r verification oracle queries.  This adversary makes no
   authenticator oracle queries, and succeeds with probability
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                    Adv(B-bf) = 1 - (1 - v(q+1)/2^31)^s
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
which is roughly equal to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはほぼ同じです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             sv * (q+1)/2^31
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With m = 10^6 we get q = 2,147. In that case, the brute force attack using v verification attempts succeeds with probability
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
M = 10 ^ 6では、Q = 2,147が得られます。その場合、V検証試行を使用したブルートフォース攻撃は確率で成功します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Adv(B-bf) roughly = sv * 2148/2^31 = sv * 1.00024045/10^6
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As this equation shows, the resynchronization parameter s has a significant impact in that the adversary&#39;s success probability is proportional to s. This means that s cannot be made too large without compromising security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この式が示すように、再同期パラメータsは、敵の成功確率がsに比例するという点で大きな影響を及ぼします。これは、セキュリティを犠牲にすることなくSを大きすぎることができないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4.3. Brute force attacks are the best possible attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4.3. ブルートフォース攻撃は可能な限り最高の攻撃です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A central question is whether there are attacks any better than the brute force one. In particular, the brute force attack did not attempt to collect authenticators sent by the user and try to cryptanalyze them in an attempt to learn how to better construct authenticators. Would doing this help? Is there some way to &#34;learn&#34; how to build authenticators that result in a higher success rate than given by the brute-force attack?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
中心的な問題は、ブルートフォースよりも攻撃が優れているかどうかです。特に、ブルートフォース攻撃は、ユーザーが送信した認証者を集め、認証者をより適切に構築する方法を学びようとしてみてください。この助けをしているのですか？ブルートフォース攻撃によって与えられるよりも高い成功率をもたらす認証者を構築する方法を「学ぶ」ための方法はありますか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following says the answer to these questions is no. No matter what strategy the adversary uses, and even if it sees, and tries to exploit, the authenticators from authentication attempts of the user, its success probability will not be above that of the brute force attack -- this is true as long as the number of authentications it observes is not incredibly large. This is valuable information regarding the security of the scheme.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、これらの質問に対する答えはノーです。敵対者がどのような戦略であっても、たとえそれが見ていて、そしてそれが誰かを見て、そして悪用しようとしていても、ユーザの認証の試みからの認証能力は、その成功確率はブルートフォース攻撃のそれほど上回らないであろう。それが観察する認証数は信じられないほど大きくありません。これはスキームのセキュリティに関する貴重な情報です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Proposition 2 ------------- Suppose m = 10^Digit &lt; 2^31, and let
   (q,r) = IntDiv(2^31,m).  Let B be any adversary attacking HOTP-IDEAL
   using v verification oracle queries and a &lt;= 2^c - s authenticator
   oracle queries.  Then
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        Adv(B) &lt; = sv * (q+1)/ 2^31
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: This result is conditional on the adversary not seeing more than 2^c - s authentications performed by the user, which is hardly restrictive as long as c is large enough.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：この結果は、ユーザーが2 ^ C  -  S以上の認証を見ていない致命者に関する条件付きであり、Cが十分に大きい限り制限がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With m = 10^6, we get q = 2,147. In that case, Proposition 2 says that any adversary B attacking HOTP-IDEAL and making v verification attempts succeeds with probability at most
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
M = 10 ^ 6では、Q = 2,147になります。その場合、命題2は、HOTP理想を攻撃し、V検証の試みを行うことが一番なしに成功したと述べています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Equation 1
   ----------
              sv * 2148/2^31 roughly = sv * 1.00024045/10^6
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning, B&#39;s success rate is not more than that achieved by the brute force attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
意味、Bの成功率は、ブルートフォース攻撃によって達成されたもの以上のものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-5--Security-Analysis-of-HOTP">
A.5. Security Analysis of HOTP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.5. Hotpのセキュリティ分析
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We have analyzed, in the previous sections, the security of the idealized counterparts HOTP-IDEAL of the actual authentication algorithm HOTP. We now show that, under appropriate and well-believed assumption on H, the security of the actual algorithms is essentially the same as that of its idealized counterpart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際の認証アルゴリズムのHOTPの理想的な理想的な理想的な対応物のセキュリティを前のセクションで分析しました。我々は今、適切でゆったりとした仮定の下で、実際のアルゴリズムのセキュリティは、その理想化された相手方のセキュリティと基本的に同じであることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The assumption in question is that H is a secure pseudorandom function, or PRF, meaning that its input-output values are indistinguishable from those of a random function in practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
問題の仮定は、Hが安全な疑似乱数関数、またはPRFであり、その入力出力値は実際にはランダム関数のものと区別がつかないことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider an adversary A that is given an oracle for a function f: {0,1}^c --&gt; {0, 1}^n and eventually outputs a bit. We denote Adv(A) as the prf-advantage of A, which represents how well the adversary does at distinguishing the case where its oracle is H(K,.) from the case where its oracle is a random function of {0,1}^c to {0,1}^n.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関数f：{0,1} ^ c  - &gt; {0,1} ^ nに対してOracleが与えられた敵対Aを検討し、最終的にビットを出力します。ADV（A）をAのPRFアドバンテージとして、OracleがOracleが{0,1のランダムな関数である場合から区別しているかを区別することができるかを表す。{0,1} ^ nから{0,1} ^ n。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible attack is based on exhaustive search for the key K. If A runs for t steps and T denotes the time to perform one computation of H, its prf-advantage from this attack turns out to be (t/T)2^-k. Another possible attack is a birthday one [PrOo], whereby A can attain advantage p^2/2^n in p oracle queries and running time about pT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つの可能な攻撃は、キーKの徹底的な検索に基づいています.TステップとTの実行がHの1つの計算を実行する時間を表す場合、この攻撃からのPRFアドバンテージは（T / T）2  - です。k。もう1つの可能な攻撃は誕生日1 [Proo]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Our assumption is that these are the best possible attacks. This translates into the following.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちの仮定は、これらが最高の可能な攻撃であることです。これは次のところに変換されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Assumption 1
   ------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let T denotes the time to perform one computation of H. Then if A is any adversary with running time at most t and making at most p oracle queries,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
aの1つの計算を実行する時間を表す.Aが走行時間が経過し、ほとんどのP Oracle Queriesで行われた場合、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       Adv(A) &lt;= (t/T)/2^k + p^2/2^n
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In practice, this assumption means that H is very secure as PRF. For example, given that k = n = 160, an attacker with running time 2^60 and making 2^40 oracle queries has advantage at most (about) 2^-80.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際には、この仮定は、HがPRFとして非常に安全であることを意味します。たとえば、k = n = 160であることを考えると、実行時間2 ^ 60の攻撃者、および2 ^ 40 Oracleクエリには、最大（約）2 ^ -80が有利です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Theorem 1
   ---------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Suppose m = 10^Digit &lt; 2^31, and let (q,r) = IntDiv(2^31,m).  Let B
   be any adversary attacking HOTP using v verification oracle queries,
   a &lt;= 2^c - s authenticator oracle queries, and running time t.  Let T
   denote the time to perform one computation of H.  If Assumption 1 is
   true, then
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Adv(B) &lt;= sv * (q + 1)/2^31 + (t/T)/2^k + ((sv + a)^2)/2^n
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In practice, the (t/T)2^-k + ((sv + a)^2)2^-n term is much smaller than the sv(q + 1)/2^n term, so that the above says that for all practical purposes the success rate of an adversary attacking HOTP is sv(q + 1)/2^n, just as for HOTP-IDEAL, meaning the HOTP algorithm is in practice essentially as good as its idealized counterpart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際には、（T / T）2 ^ -K（（SV A）^ 2）2 ^ -N項はSV（Q 1）/ 2 ^ N項よりもはるかに小さいので、上記はすべてについて実用的な目的は、攻撃の攻撃の成功率は、HOTP理想と同じくらいSV（Q 1）/ 2 ^ Nです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case m = 10^6 of a 6-digit output, this means that an adversary making v authentication attempts will have a success rate that is at most that of Equation 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6桁の出力のM = 10 ^ 6の場合、これは、逆のv認証試行が、ほとんどの式1の成功率を持つことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, consider an adversary with running time at most 2^60 that sees at most 2^40 authentication attempts of the user. Both these choices are very generous to the adversary, who will typically not have these resources, but we are saying that even such a powerful adversary will not have more success than indicated by Equation 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、最大2 ^ 60で実行されているランニングタイムを持つ敵対者を検討してください。これらの選択は両方とも敵対者に非常に寛大ですが、通常これらのリソースを持っていませんが、そのような強力な敵対者でさえ、式1で示されるよりも多くの成功を持たないと言っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We can safely assume sv &lt;= 2^40 due to the throttling and bounds on s. So:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SV &lt;= 2 ^ 40をSV &lt;= 2 ^ 40と仮定することができます。そう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       (t/T)/2^k + ((sv + a)^2)/2^n  &lt;= 2^60/2^160 + (2^41)^2/2^160
                                    roughly &lt;= 2^-78
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
which is much smaller than the success probability of Equation 1 and negligible compared to it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、式1の成功確率よりはるかに小さく、それと比較して無視できる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix B - SHA-1 Attacks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録B  -  SHA-1攻撃
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This sections addresses the impact of the recent attacks on SHA-1 on the security of the HMAC-SHA-1-based HOTP. We begin with some discussion of the situation of SHA-1 and then discuss the relevance to HMAC-SHA-1 and HOTP. Cited references are in Section 13.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、HMAC-SHA-1ベースのHOTPのセキュリティに対するSHA-1に対する最近の攻撃の影響について説明します。SHA-1の状況についてのいくつかの議論から始めて、HMAC-SHA-1とHOTPとの関連性について説明します。引用文献はセクション13にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-1--SHA-1-Status">
B.1. SHA-1 Status
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.1. SHA-1ステータス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A collision for a hash function h means a pair x,y of different inputs such that h(x)=h(y). Since SHA-1 outputs 160 bits, a birthday attack finds a collision in 2^{80} trials. (A trial means one computation of the function.) This was thought to be the best possible until Wang, Yin, and Yu announced on February 15, 2005, that they had an attack finding collisions in 2^{69} trials.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハッシュ関数hの衝突は、H（x）= h（y）のような異なる入力のペアx、yを意味する。SHA-1は160ビットを出力するので、誕生日攻撃は2 ^ {80}試験で衝突を見つけます。これは、2005年2月15日に2 ^ {69}試験で衝突を発見した攻撃を受けたことを発表したと考えられたものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Is SHA-1 broken? For most practical purposes, we would say probably not, since the resources needed to mount the attack are huge. Here is one way to get a sense of it: we can estimate it is about the same as the time we would need to factor a 760-bit RSA modulus, and this is currently considered out of reach.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sha-1は壊れていますか？ほとんどの実用的な目的のために、攻撃をマウントするのに必要なリソースが大きいので、おそらく私たちはおそらく言うでしょう。ここに感覚を得る1つの方法があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Burr of NIST is quoted in [Crack] as saying &#34;Large national intelligence agencies could do this in a reasonable amount of time with a few million dollars in computer time&#34;. However, the computation may be out of reach of all but such well-funded agencies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「大規模な国家知能機関は、コンピュータの時間に数百万ドルで妥当な時間でこれを行うことができる」と言って、NISTのバリが「クラック」で引用されています。ただし、計算は、そのような充実した機関全ての範囲の範囲外であり得る。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One should also ask what impact finding SHA-1 collisions actually has on security of real applications such as signatures. To exploit a collision x,y to forge signatures, you need to somehow obtain a signature of x and then you can forge a signature of y. How damaging this is depends on the content of y: the y created by the attack may not be meaningful in the application context. Also, one needs a chosen-message attack to get the signature of x. This seems possible in some contexts, but not others. Overall, it is not clear that the impact on the security of signatures is significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHA-1衝突を見つけることは、実際に署名などの実際のアプリケーションのセキュリティに与える影響についても尋ねるべきです。衝突X、Yを求めるために衝突Xを搾取するには、どういうわけかXの署名を取得する必要があります。これがどのように損害を与えるかはYの内容によって異なります。攻撃によって作成されたYは、アプリケーションのコンテキストでは意味がありません。また、xの署名を取得するための選択されたメッセージ攻撃が必要です。これはいくつかの状況では可能性がありますが、他のものではありません。全体として、署名のセキュリティへの影響が重要であることは明らかではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Indeed, one can read in the press that SHA-1 is &#34;broken&#34; [Sha1] and that encryption and SSL are &#34;broken&#34; [Res]. The media have a tendency to magnify events: it would hardly be interesting to announce in the news that a team of cryptanalysts did very interesting theoretical work in attacking SHA-1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確かに、SHA-1が「壊れた」[SHA1]であり、その暗号化とSSLが「壊れた」[RES]であるプレスで読むことができます。メディアはイベントを拡大する傾向があります。暗号化のチームがSHA-1を攻撃する際に非常に興味深い仕事をしたというニュースで発表するのは面白いでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cryptographers are excited too. But mainly because this is an important theoretical breakthrough. Attacks can only get better with time: it is therefore important to monitor any progress in hash functions cryptanalysis and be prepared for any really practical break with a sound migration plan for the future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化器も興奮しています。しかし主にこれは重要な理論的な進歩です。攻撃は時間とともに良くなることができるだけです。したがって、ハッシュ関数の暗号解読の進歩を監視し、将来のサウンド移行計画で本当に実用的な休憩のために準備することが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-2--HMAC-SHA-1-Status">
B.2. HMAC-SHA-1 Status
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.2. HMAC-SHA-1ステータス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The new attacks on SHA-1 have no impact on the security of HMAC-SHA-1. The best attack on the latter remains one needing a sender to authenticate 2^{80} messages before an adversary can create a forgery. Why?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHA-1への新しい攻撃は、HMAC-SHA-1のセキュリティに影響を与えません。後者の最良の攻撃は、敵対者が偽造を作成することができる前に、送信者が2 ^ {80}メッセージを認証するために送信者を必要としています。どうして？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HMAC is not a hash function. It is a message authentication code (MAC) that uses a hash function internally. A MAC depends on a secret key, while hash functions don&#39;t. What one needs to worry about with a MAC is forgery, not collisions. HMAC was designed so that collisions in the hash function (here SHA-1) do not yield forgeries for HMAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HMACはハッシュ関数ではありません。それは内部的にハッシュ関数を使用するメッセージ認証コード（Mac）です。MACは秘密鍵によって異なりますが、ハッシュ関数はしません。Macで心配する必要があるのは、衝突ではなく偽造です。HACは、ハッシュ関数（ここでのSHA-1）内の衝突がHMACのための偽造物を生み出さないように設計されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recall that HMAC-SHA-1(K,x) = SHA-1(K_o,SHA-1(K_i,x)) where the keys K_o,K_i are derived from K. Suppose the attacker finds a pair x,y such that SHA-1(K_i,x) = SHA-1(K_i,y). (Call this a hidden-key collision.) Then if it can obtain the MAC of x (itself a tall order), it can forge the MAC of y. (These values are the same.) But finding hidden-key collisions is harder than finding collisions, because the attacker does not know the hidden key K_i. All it may have is some outputs of HMAC-SHA-1 with key K. To date, there are no claims or evidence that the recent attacks on SHA-1 extend to find hidden-key collisions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
k_o、k_iがKから導出されるHMAC-SHA-1（K_O、SHA-1（k_i、x））を思い出します。攻撃者がペアXを見つけたとします。SHA-1（K_I、X）= SHA-1（K_I、Y）。（これは隠れた衝突を呼び出します。）次に、XのMacを取得できる場合は、Macをyのmacを鍛造できます。（これらの値は同じです。）しかし、攻撃者が隠しキーK_Iを知らないため、隠蔽キーの衝突を見つけることは衝突を見つけるよりも難しいです。今日までのHMAC-SHA-1のいくつかの出力は、これまでに、最近のSHA-1に対する最近の攻撃が隠れた衝突を見つけるために延長されたという主張または証拠はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Historically, the HMAC design has already proven itself in this regard. MD5 is considered broken in that collisions in this hash function can be found relatively easily. But there is still no attack on HMAC-MD5 better than the trivial 2^{64} time birthday one. (MD5 outputs 128 bits, not 160.) We are seeing this strength of HMAC coming into play again in the SHA-1 context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
歴史的に、HMACデザインはすでにこの点でそれ自体を証明しています。MD5は、このハッシュ関数における衝突が比較的容易に見つけることができるという点で壊れていると考えられる。しかし、些細な2 ^ {64}の時間誕生日よりもHMAC-MD5にまだ攻撃はありません。（MD5出力128ビット、160）私たちは、HMACの強さがSHA-1コンテキストで再びプレイするのを見ています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-3--HOTP-Status">
B.3. HOTP Status
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.3. HOTPのステータス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since no new weakness has surfaced in HMAC-SHA-1, there is no impact on HOTP. The best attacks on HOTP remain those described in the document, namely, to try to guess output values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HMAC-SHA-1に新たな弱点が浮上していないため、HOTPに影響はありません。HOTPに対する最良の攻撃は、文書に記載されているもの、すなわち出力値を推測しようとしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security proof of HOTP requires that HMAC-SHA-1 behave like a pseudorandom function. The quality of HMAC-SHA-1 as a pseudorandom function is not impacted by the new attacks on SHA-1, and so neither is this proven guarantee.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HOTPのセキュリティ証明には、HMAC-SHA-1が疑似ランダム機能のように動作することが必要です。疑似ランダム関数としてのHMAC-SHA-1の品質は、SHA-1への新しい攻撃によって影響を受けません。したがって、これは証明されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix C - HOTP Algorithm: Reference Implementation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録C  -  HOTPアルゴリズム：参照実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * OneTimePasswordAlgorithm.java
    * OATH Initiative,
    * HOTP one-time password algorithm
    *
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Copyright (C) 2004, OATH.  All rights reserved.
    *
    * License to copy and use this software is granted provided that it
    * is identified as the &#34;OATH HOTP Algorithm&#34; in all material
    * mentioning or referencing this software or this function.
    *
    * License is also granted to make and use derivative works provided
    * that such works are identified as
    *  &#34;derived from OATH HOTP algorithm&#34;
    * in all material mentioning or referencing the derived work.
    *
    * OATH (Open AuTHentication) and its members make no
    * representations concerning either the merchantability of this
    * software or the suitability of this software for any particular
    * purpose.
    *
    * It is provided &#34;as is&#34; without express or implied warranty
    * of any kind and OATH AND ITS MEMBERS EXPRESSaLY DISCLAIMS
    * ANY WARRANTY OR LIABILITY OF ANY KIND relating to this software.
    *
    * These notices must be retained in any copies of any part of this
    * documentation and/or software.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
package org.openauthentication.otp;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
package org.openauthentication.OTP;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   import java.io.IOException;
   import java.io.File;
   import java.io.DataInputStream;
   import java.io.FileInputStream ;
   import java.lang.reflect.UndeclaredThrowableException;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   import java.security.GeneralSecurityException;
   import java.security.NoSuchAlgorithmException;
   import java.security.InvalidKeyException;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   import javax.crypto.Mac;
   import javax.crypto.spec.SecretKeySpec;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /**
    * This class contains static methods that are used to calculate the
    * One-Time Password (OTP) using
    * JCE to provide the HMAC-SHA-1.
    *
    * @author Loren Hart
    * @version 1.0
    */
   public class OneTimePasswordAlgorithm {
       private OneTimePasswordAlgorithm() {}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       // These are used to calculate the check-sum digits.
       //                                0  1  2  3  4  5  6  7  8  9
       private static final int[] doubleDigits =
                       { 0, 2, 4, 6, 8, 1, 3, 5, 7, 9 };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /**
        * Calculates the checksum using the credit card algorithm.
        * This algorithm has the advantage that it detects any single
        * mistyped digit and any single transposition of
        * adjacent digits.
        *
        * @param num the number to calculate the checksum for
        * @param digits number of significant places in the number
        *
        * @return the checksum of num
        */
       public static int calcChecksum(long num, int digits) {
           boolean doubleDigit = true;
           int     total = 0;
           while (0 &lt; digits--) {
               int digit = (int) (num % 10);
               num /= 10;
               if (doubleDigit) {
                   digit = doubleDigits[digit];
               }
               total += digit;
               doubleDigit = !doubleDigit;
           }
           int result = total % 10;
           if (result &gt; 0) {
               result = 10 - result;
           }
           return result;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /**
        * This method uses the JCE to provide the HMAC-SHA-1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
* algorithm. * HMAC computes a Hashed Message Authentication Code and * in this case SHA1 is the hash algorithm used. * * @param keyBytes the bytes to use for the HMAC-SHA-1 key * @param text the message or text to be authenticated. * * @throws NoSuchAlgorithmException if no provider makes * either HmacSHA1 or HMAC-SHA-1 * digest algorithms available. * @throws InvalidKeyException * The secret provided was not a valid HMAC-SHA-1 key. * */
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
* アルゴリズム。* HMACはハッシュメッセージ認証コードを計算し、この場合、SHA1は使用されるハッシュアルゴリズムです。* * @param keybytes hmac-sha-1キー* @param text認証されるメッセージまたはテキストを使用するバイト。* * @THROWS NOSUCHARGORITHMExceptionプロバイダーが使用可能なHMACSHA1またはHMAC-SHA-1 *ダイジェストアルゴリズムのいずれかを作る場合。* @THROWS InvalidKeyException *提供された秘密は有効なHMAC-SHA-1キーではありませんでした。* * /
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       public static byte[] hmac_sha1(byte[] keyBytes, byte[] text)
           throws NoSuchAlgorithmException, InvalidKeyException
       {
   //        try {
               Mac hmacSha1;
               try {
                   hmacSha1 = Mac.getInstance(&#34;HmacSHA1&#34;);
               } catch (NoSuchAlgorithmException nsae) {
                   hmacSha1 = Mac.getInstance(&#34;HMAC-SHA-1&#34;);
               }
               SecretKeySpec macKey =
           new SecretKeySpec(keyBytes, &#34;RAW&#34;);
               hmacSha1.init(macKey);
               return hmacSha1.doFinal(text);
   //        } catch (GeneralSecurityException gse) {
   //            throw new UndeclaredThrowableException(gse);
   //        }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       private static final int[] DIGITS_POWER
     // 0 1  2   3    4     5      6       7        8
     = {1,10,100,1000,10000,100000,1000000,10000000,100000000};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /**
        * This method generates an OTP value for the given
        * set of parameters.
        *
        * @param secret       the shared secret
        * @param movingFactor the counter, time, or other value that
        *                     changes on a per use basis.
        * @param codeDigits   the number of digits in the OTP, not
        *                     including the checksum, if any.
        * @param addChecksum  a flag that indicates if a checksum digit
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        *                     should be appended to the OTP.
        * @param truncationOffset the offset into the MAC result to
        *                     begin truncation.  If this value is out of
        *                     the range of 0 ... 15, then dynamic
        *                     truncation  will be used.
        *                     Dynamic truncation is when the last 4
        *                     bits of the last byte of the MAC are
        *                     used to determine the start offset.
        * @throws NoSuchAlgorithmException if no provider makes
        *                     either HmacSHA1 or HMAC-SHA-1
        *                     digest algorithms available.
        * @throws InvalidKeyException
        *                     The secret provided was not
        *                     a valid HMAC-SHA-1 key.
        *
        * @return A numeric String in base 10 that includes
        * {@link codeDigits} digits plus the optional checksum
        * digit if requested.
        */
       static public String generateOTP(byte[] secret,
                  long movingFactor,
             int codeDigits,
                  boolean addChecksum,
             int truncationOffset)
           throws NoSuchAlgorithmException, InvalidKeyException
       {
           // put movingFactor value into text byte array
     String result = null;
     int digits = addChecksum ? (codeDigits + 1) : codeDigits;
           byte[] text = new byte[8];
           for (int i = text.length - 1; i &gt;= 0; i--) {
               text[i] = (byte) (movingFactor &amp; 0xff);
               movingFactor &gt;&gt;= 8;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           // compute hmac hash
           byte[] hash = hmac_sha1(secret, text);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           // put selected bytes into result int
           int offset = hash[hash.length - 1] &amp; 0xf;
     if ( (0&lt;=truncationOffset) &amp;&amp;
            (truncationOffset&lt;(hash.length-4)) ) {
         offset = truncationOffset;
     }
           int binary =
               ((hash[offset] &amp; 0x7f) &lt;&lt; 24)
               | ((hash[offset + 1] &amp; 0xff) &lt;&lt; 16)
               | ((hash[offset + 2] &amp; 0xff) &lt;&lt; 8)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
| (hash[offset + 3] &amp; 0xff);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">

        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           int otp = binary % DIGITS_POWER[codeDigits];
     if (addChecksum) {
         otp =  (otp * 10) + calcChecksum(otp, codeDigits);
     }
     result = Integer.toString(otp);
     while (result.length() &lt; digits) {
         result = &#34;0&#34; + result;
     }
     return result;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix D - HOTP Algorithm: Test Values
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録D  -  HOTPアルゴリズムテスト値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following test data uses the ASCII string &#34;12345678901234567890&#34; for the secret:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のテストデータは、SecretについてASCII文字列 &#34;12345678901234567890&#34;を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Secret = 0x3132333435363738393031323334353637383930
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 1 details for each count, the intermediate HMAC value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表1各カウント、中間HMAC値の詳細。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Count    Hexadecimal HMAC-SHA-1(secret, count)
   0        cc93cf18508d94934c64b65d8ba7667fb7cde4b0
   1        75a48a19d4cbe100644e8ac1397eea747a2d33ab
   2        0bacb7fa082fef30782211938bc1c5e70416ff44
   3        66c28227d03a2d5529262ff016a1e6ef76557ece
   4        a904c900a64b35909874b33e61c5938a8e15ed1c
   5        a37e783d7b7233c083d4f62926c7a25f238d0316
   6        bc9cd28561042c83f219324d3c607256c03272ae
   7        a4fb960c0bc06e1eabb804e5b397cdc4b45596fa
   8        1b3c89f65e6c9e883012052823443f048b4332db
   9        1637409809a679dc698207310c8c7fc07290d9e5
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 2 details for each count the truncated values (both in hexadecimal and decimal) and then the HOTP value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表2切り捨てられた値（16進数と10進数の両方）、次にHOTP値の詳細について詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Truncated Count Hexadecimal Decimal HOTP 0 4c93cf18 1284755224 755224 1 41397eea 1094287082 287082 2 82fef30 137359152 359152 3 66ef7655 1726969429 969429 4 61c5938a 1640338314 338314 5 33c083d4 868254676 254676 6 7256c032 1918287922 287922 7 4e5b397 82162583 162583 8 2823443f 673399871 399871 9 2679dc69 645520489 520489
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
04c93cf181284755224755224141397eea1094287082287082282fef30137359152359152366ef76551726969429969429461c5938a1640338314338314533c083d486825467625467667256c032191828792228792274e5b3978216258316258382823443f67339987139987192679dc69645520489520489進小数点HOTPカウント切り捨て
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix E - Extensions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録E  - 拡張子
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We introduce in this section several enhancements to the HOTP algorithm. These are not recommended extensions or part of the standard algorithm, but merely variations that could be used for customized implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、HOTPアルゴリズムのいくつかの機能強化を紹介します。これらは推奨されていません。標準アルゴリズムの推奨されていませんが、単にカスタマイズされた実装に使用できるバリエーションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="E-1--Number-of-Digits">
E.1. Number of Digits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.1. 数字数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A simple enhancement in terms of security would be to extract more digits from the HMAC-SHA-1 value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティに関する単純な強化は、HMAC-SHA-1値からさらに数字を抽出することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For instance, calculating the HOTP value modulo 10^8 to build an 8- digit HOTP value would reduce the probability of success of the adversary from sv/10^6 to sv/10^8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、8桁のHOTP値を構築するためにHOTP値Modulo 10 ^ 8を計算すると、SV / 10 ^ 6からSV / 10 ^ 8までの敵対者の成功の可能性が低下します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This could give the opportunity to improve usability, e.g., by increasing T and/or s, while still achieving a better security overall. For instance, s = 10 and 10v/10^8 = v/10^7 &lt; v/10^6 which is the theoretical optimum for 6-digit code when s = 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、依然としてより良いセキュリティを達成しながら、Tおよび/またはSを増やすことによってユーザビリティを向上させる機会を与える可能性がある。例えば、S = 1のときに6桁のコードに対して理論的に最適なS = 10および10V / 10 ^ 8 = v / 10 ^ 7 &lt;v / 10 ^ 6。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="E-2--Alphanumeric-Values">
E.2. Alphanumeric Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.2. 英数字の値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another option is to use A-Z and 0-9 values; or rather a subset of 32 symbols taken from the alphanumerical alphabet in order to avoid any confusion between characters: 0, O, and Q as well as l, 1, and I are very similar, and can look the same on a small display.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もう1つの選択肢は、A-Zと0-9の値を使用することです。またはむしろ文字数：0、O、QだけでなくL、1、およびIは非常に似ており、小さなディスプレイで同じように見えることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The immediate consequence is that the security is now in the order of sv/32^6 for a 6-digit HOTP value and sv/32^8 for an 8-digit HOTP value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当面の結果は、セキュリティが6桁のHOTP値に対してSV / 32 ^ 6の順序で、8桁のHOTP値でSV / 32 ^ 8の順序であることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32^6 &gt; 10^9 so the security of a 6-alphanumeric HOTP code is slightly better than a 9-digit HOTP value, which is the maximum length of an HOTP code supported by the proposed algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32 ^ 6&gt; 10 ^ 9なので、6-英数字のHOTPコードのセキュリティは9桁のHOTP値よりわずかに優れており、これは提案されたアルゴリズムでサポートされているHOTPコードの最大長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32^8 &gt; 10^12 so the security of an 8-alphanumeric HOTP code is significantly better than a 9-digit HOTP value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32 ^ 8&gt; 10 ^ 12では、8文字のHOTPコードのセキュリティは9桁のHOTP値よりもかなり優れています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on the application and token/interface used for displaying and entering the HOTP value, the choice of alphanumeric values could be a simple and efficient way to improve security at a reduced cost and impact on users.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HOTP値の表示と入力に使用されるアプリケーションとトークン/インターフェイスに応じて、英数字の値の選択は、コストの削減とユーザーへの影響でセキュリティを向上させるための簡単で効率的な方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="E-3--Sequence-of-HOTP-Values">
E.3. Sequence of HOTP Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.3. HOTP値のシーケンス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As we suggested for the resynchronization to enter a short sequence (say, 2 or 3) of HOTP values, we could generalize the concept to the protocol, and add a parameter L that would define the length of the HOTP sequence to enter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再同期を推奨して、HOTP値の短いシーケンス（つまり、2または3）を入力すると、概念をプロトコルに一般化し、入力するHOTPシーケンスの長さを定義するパラメータLを追加することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Per default, the value L SHOULD be set to 1, but if security needs to be increased, users might be asked (possibly for a short period of time, or a specific operation) to enter L HOTP values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デフォルトでは、値Lは1に設定する必要がありますが、セキュリティを増やす必要がある場合は、ユーザーがL HOTP値を入力するようにユーザーが求められます（おそらく特定の操作）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is another way, without increasing the HOTP length or using alphanumeric values to tighten security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、HOTPの長さを増やすこと、または英数字の値を使用してセキュリティを締め付けることなく別の方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: The system MAY also be programmed to request synchronization on a regular basis (e.g., every night, twice a week, etc.) and to achieve this purpose, ask for a sequence of L HOTP values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：システムは、定期的に同期を要求するようにプログラムされてもよく、この目的を達成するために、一連のL HOTP値を問い合わせることもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="E-4--A-Counter-Based-Resynchronization-Method">
E.4. A Counter-Based Resynchronization Method
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.4. カウンタベースの再同期方式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this case, we assume that the client can access and send not only the HOTP value but also other information, more specifically, the counter value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合、クライアントはHOTP値だけでなく他の情報、より具体的にはカウンタ値にアクセスして送信できるとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A more efficient and secure method for resynchronization is possible in this case. The client application will not send the HOTP-client value only, but the HOTP-client and the related C-client counter value, the HOTP value acting as a message authentication code of the counter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合、再同期化のためのより効率的で安全な方法が可能です。クライアントアプリケーションは、HOTPクライアント値のみを送信しませんが、HOTP-Clientと関連するCクライアントカウンタ値、HOTP値はカウンタのメッセージ認証コードとして機能します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Resynchronization Counter-based Protocol (RCP)
   ----------------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server accepts if the following are all true, where C-server is its own current counter value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、以下の場合、C-Serverはそれ自身の現在のカウンタ値である場合に該当する場合に受け入れます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1) C-client &gt;= C-server
   2) C-client - C-server &lt;= s
   3) Check that HOTP client is valid HOTP(K,C-Client)
   4) If true, the server sets C to C-client + 1 and client is
      authenticated
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this case, there is no need for managing a look-ahead window anymore. The probability of success of the adversary is only v/10^6 or roughly v in one million. A side benefit is obviously to be able to increase s &#34;infinitely&#34; and therefore improve the system usability without impacting the security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合、先読みウィンドウを管理する必要はもうありません。敵対者の成功の可能性は、100万百万円でのV / 10 ^ 6またはおおよそVにすぎません。サイドの利点は明らかにS「無限に」を増やすことができ、したがって、セキュリティに影響を与えることなくシステムの使いやすさを向上させることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This resynchronization protocol SHOULD be used whenever the related impact on the client and server applications is deemed acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この再同期プロトコルは、クライアントおよびサーバーアプリケーションへの関連する影響が許容できると見なされるたびに使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="E-5--Data-Field">
E.5. Data Field
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.5. データフィールド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another interesting option is the introduction of a Data field, which would be used for generating the One-Time Password values: HOTP (K, C, [Data]) where Data is an optional field that can be the concatenation of various pieces of identity-related information, e.g., Data = Address | PIN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もう1つの興味深いオプションは、データフィールドの紹介であり、ワンタイムパスワード値を生成するために使用されるであろう。 - 関連情報、例えばdata = address.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We could also use a Timer, either as the only moving factor or in combination with the Counter -- in this case, e.g., Data = Timer, where Timer could be the UNIX-time (GMT seconds since 1/1/1970) divided by some factor (8, 16, 32, etc.) in order to give a specific time step. The time window for the One-Time Password is then equal to the time step multiplied by the resynchronization parameter as defined before. For example, if we take 64 seconds as the time step and 7 for the resynchronization parameter, we obtain an acceptance window of +/- 3 minutes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合、この場合、Data = Timer、例えばData = Timer（1/1/1970からGMT秒から1/1/1970以降のGMT秒）になる可能性がある場合は、タイマーを使用することもできます。特定の時間段階を与えるために、ある要因（8,16,32など）によって。1回限りのパスワードのタイムウィンドウは、以前に定義されているように、再同期パラメータを乗算したときの時間ステップと同じです。たとえば、再同期パラメータの時間ステップと7として64秒かかると、/  -  3分の受付ウィンドウが得られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using a Data field opens for more flexibility in the algorithm implementation, provided that the Data field is clearly specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データフィールドが明確に指定されている場合、データフィールドを使用すると、アルゴリズムの実装ではより柔軟性が向上します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者の住所
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David M&#39;Raihi (primary contact for sending comments and questions) VeriSign, Inc. 685 E. Middlefield Road Mountain View, CA 94043 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David M&#39;Raihi（コメントや質問の送信のための主な連絡先）Verisign、Inc。685 E.ミドルフィールドロードマウンテンビュー、CA 94043 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: 1-650-426-3832 EMail: dmraihi@verisign.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：1-650-426-3832 Eメール：Dmraihi@verisign.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mihir Bellare Dept of Computer Science and Engineering, Mail Code 0114 University of California at San Diego 9500 Gilman Drive La Jolla, CA 92093, USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mihir Bellare Dept of Computer Science and Engineeration、メールコード0114カリフォルニア大学San Diego 9500 Gilman Drive La Jolla、CA 92093、アメリカ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: mihir@cs.ucsd.edu
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Frank Hoornaert VASCO Data Security, Inc. Koningin Astridlaan 164 1780 Wemmel, Belgium
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Frank Hoornaert Vasco Data Security、Inc。Koningin Astridlaan 164 1780 Wemmel、ベルギー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: frh@vasco.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Naccache Gemplus Innovation 34 rue Guynemer, 92447, Issy les Moulineaux, France and Information Security Group, Royal Holloway, University of London, Egham, Surrey TW20 0EX, UK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Naccache Gemplus Innovation 34 Rue Guynemer、92447、Issy Les Moulineaux、フランス、情報セキュリティグループ、ロンドン大学、Egham、Surrey Tw20 0ex、UK
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: david.naccache@gemplus.com, david.naccache@rhul.ac.uk
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ohad Ranen Aladdin Knowledge Systems Ltd. 15 Beit Oved Street Tel Aviv, Israel 61110
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ohad Ranen Aladdin Knowledge Systems Ltd. 15 Beit Oves Streetテルアビブ、イスラエル61110
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: Ohad.Ranen@ealaddin.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完全著作権宣言
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2005).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット社会（2005）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78に含まれている権利、ライセンス、制限の対象となり、その中に述べた場合を除き、著者らはすべての権利を保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書と本明細書に含まれる情報は、「現状のまま」基準で提供されており、投稿者、または（いずれかの場合）、インターネット社会とインターネットエンジニアリングのタスクフォースがすべての保証を損なう、または本明細書における情報の使用が、特定の目的のためのあらゆる権利または黙示の保証を侵害しないことを含むがこれらに限定されないが、これに限定されない。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知的財産
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書に記載されているテクノロジの実装または使用に関連すると主張される可能性がある、またはそのような権利の下でのライセンスの使用に関連すると主張される可能性がある、またはその他の権利の下にある範囲内である可能性がある、またはその他の権利の使用に関連すると主張する可能性がある、IETFは、IETFを取りません。利用可能です。そのような権利を特定するためにそれが独立した努力をしたことを表していません。RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF事務局へのIETF事務局と利用可能なライセンスの保証のコピー、またはこの仕様書の実装者や利用者による一般的なライセンスまたは許可を得るための試みの結果を得ることができます。IETFオンラインIPRリポジトリからhttp://www.ietf.org/ipr。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、著作権、特許または特許出願、またはこの規格を実装することが要求される可能性がある技術をカバーする可能性のある他の独自の権利を注意を及ぼすように興味のある当事者を勧めます。ietf-ipr@ietf.orgのIETFに情報を宛先に宛ててください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFCエディタ機能のための資金は、現在インターネット社会によって提供されています。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
