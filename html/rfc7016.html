<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 7016 - Adobe&#39;s Secure Real-Time Media Flow Protocol 日本語訳</title>
  <meta name="description" content="RFC 7016は、AdobeのSecure Real-Time Media Flow Protocol（SRMF）に関する規格です。SRMFは、リアルタイムのメディアストリーミングを安全に転送するためのプロトコルであり、セキュリティとプライバシーの保護を目的としています。">
  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">7016</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc7016">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 7016 - Adobe's Secure Real-Time Media Flow Protocol 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc7016">
            https://datatracker.ietf.org/doc/html/rfc7016
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 7016 - アドビのセキュアリアルタイムメディアフロープロトコル</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] RFC 7016は、AdobeのSecure Real-Time Media Flow Protocol（SRMF）に関する規格です。SRMFは、リアルタイムのメディアストリーミングを安全に転送するためのプロトコルであり、セキュリティとプライバシーの保護を目的としています。</p>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                     M. Thornburgh
Request for Comments: 7016                                         Adobe
Category: Informational                                    November 2013
ISSN: 2070-1721
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Adobe&#39;s Secure Real-Time Media Flow Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
アドビのセキュアリアルタイムメディアフロープロトコル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo describes Adobe&#39;s Secure Real-Time Media Flow Protocol (RTMFP), an endpoint-to-endpoint communication protocol designed to securely transport parallel flows of real-time video, audio, and data messages, as well as bulk data, over IP networks. RTMFP has features that make it effective for peer-to-peer (P2P) as well as client-server communications, even when Network Address Translators (NATs) are used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、アドビのセキュアリアルタイムメディアフロープロトコル（RTMFP）について説明しています。これは、IPビデオを介して、リアルタイムのビデオ、オーディオ、データメッセージのパラレルフローとバルクデータを安全に転送するように設計されたエンドポイント間通信プロトコルです。 。 RTMFPには、ネットワークアドレストランスレータ（NAT）が使用されている場合でも、ピアツーピア（P2P）だけでなくクライアント/サーバー通信にも効果的な機能があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for informational purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはInternet Standards Trackの仕様ではありません。情報提供を目的として公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IETF（Internet Engineering Task Force）の製品です。 Internet Engineering Steering Group（IESG）による公開が承認されています。 IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補になるわけではありません。 RFC 5741のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7016.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7016で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
IESG Note
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
IESG Note
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document represents technology developed outside the processes of the IETF and the IETF community has determined that it is useful to publish it as an RFC in its current form. It is a product of the IETF only in that it has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG), but the content of the document does not represent a consensus of the IETF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IETFのプロセス外で開発されたテクノロジーを表しており、IETFコミュニティは、現在の形式でRFCとして公開することが有用であると判断しています。これは、IETFの製品であり、パブリックレビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されていますが、このドキュメントの内容はIETFの合意を表すものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2013 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document may not be modified, and derivative works of it may not be created, except to format it for publication as an RFC or to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、RFCとして公開するためにフォーマットしたり、英語以外の言語に翻訳したりする場合を除き、変更したり、その派生物を作成したりすることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................5
      1.1. Design Highlights of RTMFP .................................6
      1.2. Terminology ................................................7
   2. Syntax ..........................................................8
      2.1. Common Elements ............................................8
           2.1.1. Elementary Types and Constructs .....................8
           2.1.2. Variable Length Unsigned Integer (VLU) .............10
           2.1.3. Option .............................................10
           2.1.4. Option List ........................................11
           2.1.5. Internet Socket Address (Address) ..................12
      2.2. Network Layer .............................................13
           2.2.1. Encapsulation ......................................13
           2.2.2. Multiplex ..........................................13
           2.2.3. Encryption .........................................14
           2.2.4. Packet .............................................15
      2.3. Chunks ....................................................18
           2.3.1. Packet Fragment Chunk ..............................20
           2.3.2. Initiator Hello Chunk (IHello) .....................21
           2.3.3. Forwarded Initiator Hello Chunk (FIHello) ..........22
           2.3.4. Responder Hello Chunk (RHello) .....................23
           2.3.5. Responder Redirect Chunk (Redirect) ................24
           2.3.6. RHello Cookie Change Chunk .........................26
           2.3.7. Initiator Initial Keying Chunk (IIKeying) ..........27
           2.3.8. Responder Initial Keying Chunk (RIKeying) ..........29
           2.3.9. Ping Chunk .........................................31
           2.3.10. Ping Reply Chunk ..................................32
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
           2.3.11. User Data Chunk ...................................33
                  2.3.11.1. Options for User Data ....................35
                           2.3.11.1.1. User&#39;s Per-Flow Metadata ......35
                           2.3.11.1.2. Return Flow Association .......36
           2.3.12. Next User Data Chunk ..............................37
           2.3.13. Data Acknowledgement Bitmap Chunk (Bitmap Ack) ....39
           2.3.14. Data Acknowledgement Ranges Chunk (Range Ack) .....41
           2.3.15. Buffer Probe Chunk ................................43
           2.3.16. Flow Exception Report Chunk .......................43
           2.3.17. Session Close Request Chunk (Close) ...............44
           2.3.18. Session Close Acknowledgement Chunk (Close Ack) ...44
   3. Operation ......................................................45
      3.1. Overview ..................................................45
      3.2. Endpoint Identity .........................................46
      3.3. Packet Multiplex ..........................................48
      3.4. Packet Fragmentation ......................................48
      3.5. Sessions ..................................................50
           3.5.1. Startup ............................................53
                  3.5.1.1. Normal Handshake ..........................53
                           3.5.1.1.1. Initiator ......................54
                           3.5.1.1.2. Responder ......................55
                  3.5.1.2. Cookie Change .............................57
                  3.5.1.3. Glare .....................................59
                  3.5.1.4. Redirector ................................60
                  3.5.1.5. Forwarder .................................61
                  3.5.1.6. Redirector and Forwarder with NAT .........63
                  3.5.1.7. Load Distribution and Fault Tolerance .....66
           3.5.2. Congestion Control .................................67
                  3.5.2.1. Time Critical Reverse Notification ........68
                  3.5.2.2. Retransmission Timeout ....................68
                  3.5.2.3. Burst Avoidance ...........................71
           3.5.3. Address Mobility ...................................71
           3.5.4. Ping ...............................................72
                  3.5.4.1. Keepalive .................................72
                  3.5.4.2. Address Mobility ..........................73
                  3.5.4.3. Path MTU Discovery ........................74
           3.5.5. Close ..............................................74
      3.6. Flows .....................................................75
           3.6.1. Overview ...........................................75
                  3.6.1.1. Identity ..................................75
                  3.6.1.2. Messages and Sequencing ...................76
                  3.6.1.3. Lifetime ..................................77
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
           3.6.2. Sender .............................................78
                  3.6.2.1. Startup ...................................80
                  3.6.2.2. Queuing Data ..............................80
                  3.6.2.3. Sending Data ..............................81
                           3.6.2.3.1. Startup Options ................83
                           3.6.2.3.2. Send Next Data .................83
                  3.6.2.4. Processing Acknowledgements ...............83
                  3.6.2.5. Negative Acknowledgement and Loss .........84
                  3.6.2.6. Timeout ...................................85
                  3.6.2.7. Abandoning Data ...........................86
                           3.6.2.7.1. Forward Sequence Number
                                      Update .........................86
                  3.6.2.8. Examples ..................................87
                  3.6.2.9. Flow Control ..............................89
                           3.6.2.9.1. Buffer Probe ...................89
                  3.6.2.10. Exception ................................89
                  3.6.2.11. Close ....................................90
           3.6.3. Receiver ...........................................90
                  3.6.3.1. Startup ...................................93
                  3.6.3.2. Receiving Data ............................94
                  3.6.3.3. Buffering and Delivering Data .............95
                  3.6.3.4. Acknowledging Data ........................97
                           3.6.3.4.1. Timing .........................98
                           3.6.3.4.2. Size and Truncation ............99
                           3.6.3.4.3. Constructing ...................99
                           3.6.3.4.4. Delayed Acknowledgement .......100
                           3.6.3.4.5. Obligatory Acknowledgement ....100
                           3.6.3.4.6. Opportunistic
                                      Acknowledgement ...............100
                           3.6.3.4.7. Example .......................101
                  3.6.3.5. Flow Control .............................102
                  3.6.3.6. Receiving a Buffer Probe .................103
                  3.6.3.7. Rejecting a Flow .........................103
                  3.6.3.8. Close ....................................104
   4. IANA Considerations ...........................................104
   5. Security Considerations .......................................105
   6. Acknowledgements ..............................................106
   7. References ....................................................107
      7.1. Normative References .....................................107
      7.2. Informative References ...................................107
   Appendix A. Example Congestion Control Algorithm .................108
     A.1. Discussion ................................................108
     A.2. Algorithm .................................................110
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Adobe&#39;s Secure Real-Time Media Flow Protocol (RTMFP) is intended for use as a general purpose endpoint-to-endpoint data transport service in IP networks. It has features that make it well suited to the transport of real-time media (such as low-delay video, audio, and data) as well as bulk data, and for client-server as well as peer-to-peer (P2P) communication. These features include independent parallel message flows that may have different delivery priorities, variable message reliability (from TCP-like full reliability to UDP-like best effort), multi-point congestion control, and built-in security. Session multiplexing and facilities to support UDP hole-punching simplify Network Address Translator (NAT) traversal in peer-to-peer systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アドビのセキュアリアルタイムメディアフロープロトコル（RTMFP）は、IPネットワークでのエンドポイントからエンドポイントへの汎用データ転送サービスとして使用することを目的としています。リアルタイムメディア（低遅延のビデオ、オーディオ、データなど）やバルクデータの転送、およびクライアントサーバーやピアツーピア（P2P）に最適な機能を備えています。 ） コミュニケーション。これらの機能には、さまざまな配信優先順位、さまざまなメッセージ信頼性（TCPのような完全な信頼性からUDPのようなベストエフォートまで）、マルチポイントの輻輳制御、および組み込みのセキュリティがある独立した並列メッセージフローが含まれます。 UDPホールパンチングをサポートするセッションの多重化と機能により、ピアツーピアシステムでのネットワークアドレス変換（NAT）トラバーサルが簡素化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP is implemented in Flash Player, Adobe Integrated Runtime (AIR), and Adobe Media Server (AMS, formerly Flash Media Server or FMS), all from Adobe Systems Incorporated, and is used as the foundation transport protocol for real-time video, audio, and data communication, both client-server and P2P, in those products. At the time of writing, the Adobe Flash Player runtime is installed on more than one billion end-user desktop computers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPは、Flash Player、Adobe Integrated Runtime（AIR）、およびAdobe Media Server（AMS、以前のFlash Media ServerまたはFMS）に実装されており、すべてAdobe Systems Incorporatedから提供されており、リアルタイムビデオ、オーディオの基盤トランスポートプロトコルとして使用されています。 、およびこれらの製品におけるクライアントサーバーとP2Pの両方のデータ通信。執筆時点では、Adobe Flash Playerランタイムは10億台を超えるエンドユーザーのデスクトップコンピューターにインストールされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP was developed by Adobe Systems Incorporated and is not the product of an IETF activity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPはAdobe Systems Incorporatedによって開発され、IETFアクティビティの製品ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo describes the syntax and operation of the Secure Real-Time Media Flow Protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、Secure Real-Time Media Flow Protocolの構文と操作について説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo describes a general security framework that, when combined with an application-specific Cryptography Profile, can be used to establish a confidential and authenticated session between endpoints. The application-specific Cryptography Profile, not defined herein, would detail the specific cryptographic algorithms, data formats, and semantics to be used within this framework. Interoperation between applications of RTMFP requires common or compatible Cryptography Profiles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、アプリケーション固有の暗号化プロファイルと組み合わせると、エンドポイント間に機密で認証されたセッションを確立するために使用できる一般的なセキュリティフレームワークについて説明します。ここで定義されていないアプリケーション固有の暗号化プロファイルは、このフレームワーク内で使用される特定の暗号化アルゴリズム、データ形式、およびセマンティクスを詳述します。 RTMFPのアプリケーション間の相互運用には、共通または互換性のある暗号化プロファイルが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note to implementers: at the time of writing, the Cryptography Profile used by the above-mentioned Adobe products is not publicly described by Adobe. Implementers should investigate the availability of documentation of that Cryptography Profile prior to implementing RTMFP for the purpose of interoperation with the above-mentioned Adobe products.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装者への注意：執筆の時点では、上記のアドビ製品で使用される暗号化プロファイルは、アドビによって公に説明されていません。実装者は、上記のアドビ製品との相互運用を目的としてRTMFPを実装する前に、その暗号化プロファイルのドキュメントの可用性を調査する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-1--Design-Highlights-of-RTMFP">
1.1. Design Highlights of RTMFP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. RTMFPの設計のハイライト
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Between any pair of communicating endpoints is a single, bidirectional, secured, congestion controlled session. Unidirectional flows convey messages from one end to the other within the session. An endpoint can have concurrent sessions with multiple other far endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通信するエンドポイントのペアの間には、単一の双方向の安全な輻輳制御セッションがあります。単方向フローは、セッション内でメッセージを一方の端から他方の端に伝達します。エンドポイントは、他の複数の遠端エンドポイントとの同時セッションを持つことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Design highlights of RTMFP include the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPの設計の要点は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The security framework is an inherent part of the basic protocol. The application designer chooses the cryptographic formats and algorithms to suit the needs of the application, and may update them as the state of the security arts progresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セキュリティフレームワークは、基本プロトコルの固有の部分です。アプリケーション設計者は、アプリケーションのニーズに合うように暗号化形式とアルゴリズムを選択し、セキュリティ技術の進歩に応じてそれらを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Cryptographic Endpoint Discriminators can resist port scanning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 暗号化エンドポイント識別子は、ポートスキャンに抵抗できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All header, control, and framing information, except for network addressing information and a session identifier, is encrypted according to the Cryptography Profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ネットワークアドレッシング情報とセッション識別子を除くすべてのヘッダー、制御、およびフレーミング情報は、暗号化プロファイルに従って暗号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There is a single session and associated congestion control state between a pair of endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o エンドポイントのペア間には、単一のセッションと関連する輻輳制御状態があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Each session may have zero or more unidirectional message-oriented flows in each direction. All of a session&#39;s sending flows share the session&#39;s congestion control state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 各セッションには、各方向に1つ以上の単方向メッセージ指向フローがあります。セッションのすべての送信フローは、セッションの輻輳制御状態を共有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Return Flow Association (Section 2.3.11.1.2) generalizes bidirectional communication to arbitrarily complex trees of flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o リターンフローアソシエーション（セクション2.3.11.1.2）は、双方向通信を一般化して、フローの複雑なツリーを任意に作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Messages in flows can be arbitrarily large and are fragmented for transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フロー内のメッセージは任意に大きくすることができ、送信用にフラグメント化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Messages of any size may be sent with full, partial, or no reliability (sender&#39;s choice). Messages may be delivered to the receiving user in original queuing order or network arrival order (receiver&#39;s choice).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 任意のサイズのメッセージは、完全、部分的、または信頼性なしで送信できます（送信者の選択）。メッセージは、元のキューイング順またはネットワーク到着順（受信者の選択）で受信ユーザーに配信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Flows are named with arbitrary, user-defined metadata (Section 2.3.11.1.1) rather than port or stream numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フローには、ポート番号やストリーム番号ではなく、任意のユーザー定義のメタデータ（セクション2.3.11.1.1）が付けられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The sequence numbers of each flow are independent of all other flows and are not permanently bound to a session-wide transmission ordering. This allows real-time priority decisions to be made at transmission or retransmission time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 各フローのシーケンス番号は他のすべてのフローから独立しており、セッション全体の送信順序に永続的にバインドされていません。これにより、送信時または再送信時にリアルタイムの優先度決定を行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Each flow has its own receive window and, therefore, independent flow control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 各フローには独自の受信ウィンドウがあるため、独立したフロー制御があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Round trips are expensive and are minimized or eliminated when possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 往復は高価であり、可能であれば最小限に抑えられるか、排除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o After a session is established, flows begin by sending the flow&#39;s messages with no additional handshake (and associated round trips).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セッションが確立されると、フローは、追加のハンドシェイク（および関連する往復）なしでフローのメッセージを送信することから始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Transmitting bytes on the network is much more expensive than moving bytes in a CPU or memory. Wasted bytes are minimized or eliminated when possible and practical, and variable length encodings are used, even at the expense of breaking 32-bit alignment and making the text diagrams in this specification look awkward.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ネットワークでバイトを送信することは、CPUやメモリでバイトを移動するよりもはるかにコストがかかります。無駄なバイトは可能な限り実用的に最小化または排除され、可変長エンコーディングが使用されます。ただし、32ビットアライメントを壊し、この仕様のテキスト図を不自然に見せることになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o P2P lookup and peer introduction (including UDP hole-punching for NAT and firewall traversal) are supported directly by the session startup handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o P2Pルックアップとピアの導入（NATのUDPホールパンチとファイアウォールトラバーサルを含む）は、セッションスタートアップハンドシェイクによって直接サポートされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Session identifiers allow an endpoint to multiplex many sessions over a single local transport address while allowing sessions to survive changes in transport address (as may happen in mobile or wireless deployments).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セッション識別子を使用すると、エンドポイントは単一のローカルトランスポートアドレスを介して多くのセッションを多重化でき、セッションはトランスポートアドレスの変更に耐えることができます（モバイルまたはワイヤレスの展開で発生する可能性があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The syntax of the protocol is detailed in Section 2. The operation of the protocol is detailed in Section 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルの構文はセクション2で詳しく説明されています。プロトコルの操作はセクション3で詳しく説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-2--Terminology">
1.2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. 用語
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこの文書の &#34;は、[RFC2119]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Syntax">
2. Syntax
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 構文
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Definitions of types and structures in this specification use traditional text diagrams paired with procedural descriptions using a C-like syntax. The C-like procedural descriptions SHALL be construed as definitive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様のタイプと構造の定義では、Cのような構文を使用した手続き型の説明と対になっている従来のテキスト図を使用します。 Cのような手続き型の記述は、決定的なものとして解釈されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structures are packed to take only as many bytes as explicitly indicated. There is no 32-bit alignment constraint, and fields are not padded for alignment unless explicitly indicated or described. Text diagrams may include a bit ruler across the top; this is a convenience for counting bits in individual fields and does not necessarily imply field alignment on a multiple of the ruler width.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造体は、明示的に示されているバイト数だけを使用するようにパックされます。 32ビットのアライメント制約はなく、明示的に指定または説明されていない限り、フィールドはアライメントのためにパディングされません。テキスト図には上部にビット定規が含まれている場合があります。これは、個々のフィールドのビットをカウントするのに便利であり、ルーラー幅の倍数でのフィールドの整列を必ずしも意味しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless specified otherwise, reserved fields SHOULD be set to 0 by a sender and MUST be ignored by a receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に明記しない限り、予約済みフィールドは送信者によって0に設定されるべきで（SHOULD）、受信者によって無視されなければならない（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedural syntax of this specification defines correct and error-free encoded inputs to a parser. The procedural syntax does not describe a fully featured parser, including error detection and handling. Implementations MUST include means to identify error circumstances, including truncations causing elementary or composed types to not fit inside containing structures, fields, or elements. Unless specified otherwise, an error circumstance SHALL abort the parsing and processing of an element and its enclosing elements, up to the containing packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様の手続き型構文は、パーサーへの正しくエラーのないエンコードされた入力を定義します。手続き型構文は、エラーの検出と処理を含む、完全に機能するパーサーを記述していません。実装には、エラーの状況を特定する手段が含まれていなければなりません。これには、基本型または構成型が構造、フィールド、または要素の中に収まらない原因となる切り捨てが含まれます。特に明記されていない限り、エラー状況は、要素とその包含要素の解析と処理を、含まれるパケットまで中止するものとします（SHALL）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1--Common-Elements">
2.1. Common Elements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. 共通要素
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section lists types and structures that are used throughout this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、この仕様全体で使用されるタイプと構造をリストします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1-1--Elementary-Types-and-Constructs">
2.1.1. Elementary Types and Constructs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.1. 基本的なタイプと構成
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section lists the elementary types and constructs out of which all of the following sections&#39; definitions are built.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、以下のセクションの定義がすべて構築される基本タイプと構成をリストします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint8_t var;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint8_t var;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An unsigned integer 8 bits (one byte) in length and byte aligned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
長さ8バイト（1バイト）の符号なし整数。バイト境界で整列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint16_t var;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint16_t var;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An unsigned integer 16 bits in length, in network byte order (&#34;big endian&#34;) and byte aligned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ネットワークバイトオーダー（「ビッグエンディアン」）でバイトアラインされた、長さが16ビットの符号なし整数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint32_t var;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint32_t var;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An unsigned integer 32 bits in length, in network byte order and byte aligned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
32バイト長の符号なし整数。ネットワークバイトオーダーで、バイト境界で整列されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint128_t var;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint128_t var;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An unsigned integer 128 bits in length, in network byte order and byte aligned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
128バイト長の符号なし整数。ネットワークバイトオーダーで、バイト境界で整列されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uintn_t var :bitsize;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint_t var：bitesize;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An unsigned integer of any other size, potentially not byte aligned. Its size in bits is specified explicitly by bitsize.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
その他のサイズの符号なし整数で、バイト境界整列されていない可能性があります。ビット単位のサイズは、ビットサイズによって明示的に指定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bool_t var :1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bool_t var：1;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A boolean flag having the value true (1 or set) or false (0 or clear) and being one bit in length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
true（1またはセット）またはfalse（0またはクリア）の値を持ち、長さが1ビットのブール値フラグ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type var[num];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプvar [num];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A packed array of type with length num*sizeof(type)*8 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
長さがnum * sizeof（type）* 8ビットのタイプのパックされた配列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct name_t { ... } name :bitsize;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A packed structure. Its size in bits is specified by bitsize.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パック構造。ビット単位のサイズは、bitesizeで指定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
remainder();
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残り();
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The number of bytes from the current offset to the end of the enclosing structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
現在のオフセットからそれを囲む構造の最後までのバイト数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type var[remainder()];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプvar [remainder()];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A packed array of type, its size extending to the end of the enclosing structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
タイプのパックされた配列で、そのサイズは囲んでいる構造体の最後まで拡張されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that a bitsize of &#34;variable&#34; indicates that the size of the structure is determined by the sizes of its interior components. A bitsize of &#34;n*8&#34; indicates that the size of the structure is a whole number of bytes and is byte aligned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「変数」のビットサイズは、構造のサイズが内部コンポーネントのサイズによって決定されることを示していることに注意してください。 「n * 8」のビットサイズは、構造体のサイズがバイトの整数であり、バイト境界で整列されていることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1-2--Variable-Length-Unsigned-Integer-VLU">
2.1.2. Variable Length Unsigned Integer (VLU)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.2. 可変長符号なし整数（VLU）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A VLU encodes any finite non-negative integer into one or more bytes. For each encoded byte, if the high bit is set, the next byte is also part of the VLU. If the high bit is clear, this is the final byte of the VLU. The remaining bits encode the number, seven bits at a time, from most significant to least significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VLUは、非負の有限整数を1バイト以上にエンコードします。エンコードされたバイトごとに、上位ビットが設定されている場合、次のバイトもVLUの一部です。上位ビットがクリアされている場合、これはVLUの最後のバイトです。残りのビットは、一度に7ビットずつ、最上位から最下位までの数をエンコードします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
    0 1 2 3 4 5 6 7                 0 1 2 3 4 5 6 7
   +~+~+~+~+~+~+~+~+               +-+-+-+-+-+-+-+-+
   |1|    digit    |...............|0|    digit    |
   +~+~+~+~+~+~+~+~+               +-+-+-+-+-+-+-+-+
   ^                               ^
   +--------- zero or more --------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct vlu_t
   {
       value = 0;
       do {
           bool_t  more  :1;
           uintn_t digit :7;
           value = (value * 128) + digit;
       } while(more);
   } :variable*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                              +-------------/-+
                              |             \ |
                              +-------------/-+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Figure 1: VLU Depiction in Following Diagrams
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
図1：次の図のVLUの説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless stated otherwise in this specification, implementations SHOULD handle VLUs encoding unsigned integers at least 64 bits in length (that is, encoding a maximum value of at least 2^64 - 1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様で特に明記されていない限り、実装は、少なくとも64ビット長の符号なし整数をエンコードする（つまり、最大値を2 ^ 64-1にエンコードする）VLUを処理する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1-3--Option">
2.1.3. Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.3. オプション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Option is a Length-Type-Value triplet. Length and Type are encoded in VLU format. Length is the number of bytes of payload following the Length field. The payload comprises the Type and Value fields. Type identifies the kind of option this is. The syntax of the Value field is determined by the type of option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションは、Length-Type-Valueトリプレットです。長さとタイプはVLU形式でエンコードされます。長さは、長さフィールドに続くペイロードのバイト数です。ペイロードは、タイプフィールドと値フィールドで構成されます。 Typeは、このオプションの種類を識別します。 「値」フィールドの構文は、オプションのタイプによって決まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Option can have a length of zero, in which case it has no type and no value and is empty. An empty Option is called a &#34;Marker&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Optionの長さは0にすることができます。その場合、タイプも値もなく、空です。空のオプションは「マーカー」と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------/-+~~~~~~~~~~~~~/~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |   length    \ |    type     \ |            value              |
   +-------------/-+~~~~~~~~~~~~~/~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
                   ^                                               ^
                   +-------- length bytes long (may be 0) ---------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct option_t
   {
       vlu_t length :variable*8; // &#34;L&#34;
       if(length &gt; 0)
       {
           struct {
               vlu_t   type :variable*8;   // &#34;T&#34;
               uint8_t value[remainder()]; // &#34;V&#34;
           } payload :length*8;
       }
   } :variable*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             +---/---/-------+
                             | L \ T \   V   |
                             +---/---/-------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Figure 2: Option Depiction in Following Diagrams
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
図2：次の図のオプションの説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1-4--Option-List">
2.1.4. Option List
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.4. オプション一覧
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Option List is a sequence of zero or more non-empty Options terminated by a Marker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションリストは、マーカーで終了する0個以上の空でないオプションのシーケンスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+-------------/-+
   | L \ T \   V   |...............| L \ T \   V   |       0     \ |
   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+-------------/-+
   ^                                               ^     Marker
   +------- zero or more non-empty Options --------+ (empty Option)
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct optionList_t
   {
       do
       {
           option_t option :variable*8;
       } while(option.length &gt; 0);
   } :variable*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1-5--Internet-Socket-Address-Address">
2.1.5. Internet Socket Address (Address)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.5. インターネットソケットアドレス（アドレス）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When communicating an Internet socket address (a combination of a 32-bit IPv4 [RFC0791] or 128-bit IPv6 [RFC2460] address and a 16-bit port number) to another RTMFP, this encoding is used. This encoding additionally allows an address to be tagged with an origin type, which an RTMFP MAY use to modify the use or disposition of the address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インターネットソケットアドレス（32ビットIPv4 [RFC0791]または128ビットIPv6 [RFC2460]アドレスと16ビットポート番号の組み合わせ）を別のRTMFPに通信する場合、このエンコーディングが使用されます。このエンコーディングはさらに、RTMFPがアドレスの使用または処理を変更するために使用できる発信元タイプでタグを付けることができるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                                        1
    0 1 2 3 4 5 6 7                 0 1 2 3 4 5 6 7|8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-----/.../-----+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |I|         | O |    Internet   |                               |
   |P|0 0 0 0 0| R |    address    |              port             |
   |6|   rsv   | I |32 or 128 bits |                               |
   +-+-+-+-+-+-+-+-+-----/.../-----+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct address_t
   {
       bool_t  inet6    :1;     // &#34;IP6&#34;
       uintn_t reserved :5 = 0; // &#34;rsv&#34;
       uintn_t origin   :2;     // &#34;ORI&#34;
       if(inet6)
           uint128_t ipAddress;
       else
           uint32_t ipAddress;
       uint16_t port;
   } :variable*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6: If set, the Internet address is a 128-bit IPv6 address. If clear, the Internet address is a 32-bit IPv4 address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6：設定されている場合、インターネットアドレスは128ビットのIPv6アドレスです。クリアされている場合、インターネットアドレスは32ビットのIPv4アドレスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
origin: The origin tag of this address. Possible values are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
origin：この住所の起点タグ。可能な値は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0: Unknown, unspecified, or &#34;other&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0：不明、不特定、または「その他」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1: Address was reported by the origin as a local, directly attached interface address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1：アドレスは、発信元によってローカルの直接接続されたインターフェイスアドレスとして報告されました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2: Address was observed to be the source address from which a packet was received (a &#34;reflexive transport address&#34; in the terminology of [RFC5389])
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2：アドレスは、パケットの受信元のソースアドレスであることが確認されました（[RFC5389]の用語では「再帰トランスポートアドレス」）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3: Address is a relay, proxy, or introducer (a Redirector and/or Forwarder)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3：アドレスはリレー、プロキシ、またはイントロデューサ（リダイレクタおよび/またはフォワーダ）です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ipAddress: The Internet address, in network byte order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ipAddress：ネットワークバイト順のインターネットアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
port: The 16-bit port number, in network byte order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
port：16ビットのポート番号（ネットワークバイト順）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2--Network-Layer">
2.2. Network Layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. ネットワーク層
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2-1--Encapsulation">
2.2.1. Encapsulation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1. カプセル化
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP Multiplex packets are usually carried in UDP [RFC0768] datagrams so that they may transit commonly deployed NATs and firewalls, and so that RTMFP may be implemented on commonly deployed operating systems without special privileges or permissions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPマルチプレックスパケットは通常、UDP [RFC0768]データグラムで運ばれるため、一般に展開されているNATとファイアウォールを通過でき、RTMFPは、特別な特権や権限なしで一般に展開されているオペレーティングシステムに実装できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP Multiplex packets MAY be carried by any suitable datagram transport or encapsulation where endpoints are addressed by an Internet socket address (that is, an IPv4 or IPv6 address and a 16-bit port number).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPマルチプレックスパケットは、エンドポイントがインターネットソケットアドレス（つまり、IPv4またはIPv6アドレスと16ビットのポート番号）でアドレス指定される、適切なデータグラムトランスポートまたはカプセル化によって伝送される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The choice of port numbers is not mandated by this specification. Higher protocol layers or the application define the port numbers used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポート番号の選択は、この仕様では必須ではありません。上位のプロトコル層またはアプリケーションが、使用されるポート番号を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2-2--Multiplex">
2.2.2. Multiplex
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.2. マルチプレックス
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Scrambled Session ID (SSID)                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             e             first32[0]                          |
   |- - - - - -  n  - - - - - - - - - - - - - - - - - - - - - - - -|
   |             c             first32[1]                          |
   +- - - - - -  r  - - - - - - - - - - - - - - - - - - - - - - - -+
   |             y                                                 |
   |             pted packet                                       |
   +---------------------------------------------------------------/
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct multiplex_t
   {
       uint32_t scrambledSessionID; // &#34;SSID&#34;
       union {
           uint32_t first32[2]; // see note
           uint8_t  encryptedPacket[remainder()];
       } :(encapsulation.length - 4)*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       // if encryptedPacket is less than 8 bytes long, treat it
       // as if it were end-padded with 0s for the following:
       sessionID = scrambledSessionID XOR first32[0] XOR first32[1];
   } :encapsulation.length*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The 32-bit Scrambled Session ID is the 32-bit session ID modified by performing a bitwise exclusive-or with the bitwise exclusive-or of the first two 32-bit words of the encrypted packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32ビットのスクランブルセッションIDは、暗号化されたパケットの最初の2つの32ビットワードのビット単位の排他的論理和またはビット単位の排他的論理和を実行することによって変更された32ビットセッションIDです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The session ID is a 32-bit value that the receiver has requested to be used by the sender when sending packets to this receiver (Sections 2.3.7 and 2.3.8). The session ID identifies the session to which this packet belongs and the decryption key to be used to decrypt the encrypted packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションIDは、この受信者にパケットを送信するときに送信者が使用するように受信者が要求した32ビット値です（セクション2.3.7および2.3.8）。セッションIDは、このパケットが属するセッションと、暗号化されたパケットを復号化するために使用される復号化キーを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: Session ID 0 (prior to scrambling) denotes the startup pseudo-session and implies the Default Session Key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：セッションID 0（スクランブリング前）は、スタートアップ疑似セッションを示し、デフォルトセッションキーを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: If the encrypted packet is less than 8 bytes long, then for the scrambling operation, perform the exclusive-or as though the encrypted packet were end-padded with enough 0-bytes to bring its length to 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：暗号化されたパケットの長さが8バイト未満の場合は、スクランブル操作のために、exclusive-orを実行します。暗号化されたパケットが、その長さを8にするために十分な0バイトでパディングされているかのように。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2-3--Encryption">
2.2.3. Encryption
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.3. 暗号化
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP packets are encrypted according to a Cryptography Profile. This specification doesn&#39;t define a Cryptography Profile or mandate a particular choice of cryptography. The application defines the cryptographic syntax and algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPパケットは、暗号化プロファイルに従って暗号化されます。この仕様は、暗号化プロファイルを定義しておらず、暗号化の特定の選択を義務付けていません。アプリケーションは、暗号の構文とアルゴリズムを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packet encryption is RECOMMENDED to be a block cipher operating in Cipher Block Chaining [CBC] or similar mode. Encrypted packets MUST be decipherable without inter-packet dependency, since packets may be lost, duplicated, or reordered in the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット暗号化は、Cipher Block Chaining [CBC]または同様のモードで動作するブロック暗号であることが推奨されます。暗号化されたパケットは、パケットがネットワーク内で失われたり、複製されたり、並べ替えられたりする可能性があるため、パケット間の依存関係なしに解読可能である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The packet encryption layer is responsible for data integrity and authenticity of packets, for example by means of a checksum or cryptographic message authentication code. To mitigate replay attacks, data integrity SHOULD comprise duplicate packet detection, for example by means of a session-wide packet sequence number. The packet encryption layer SHALL discard a received packet that does not pass integrity or authenticity tests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット暗号化層は、たとえばチェックサムまたは暗号メッセージ認証コードを使用して、データの整合性とパケットの信頼性を担います。リプレイ攻撃を軽減するために、データ整合性は、たとえばセッション全体のパケットシーケンス番号による重複パケット検出を含む必要があります。パケット暗号化層は、完全性または信頼性テストに合格しない受信パケットを破棄するものとします（SHALL）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the structures described below are of plain, unencrypted packets. Encrypted packets MUST be decrypted according to the Session Key associated with the Multiplex Session ID before being interpreted according to this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下で説明する構造は、暗号化されていない単純なパケットであることに注意してください。暗号化されたパケットは、この仕様に従って解釈される前に、マルチプレックスセッションIDに関連付けられたセッションキーに従って復号化する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The Cryptography Profile defines a well-known Default Session Key that is used at session startup, during which per-session key(s) are negotiated by the two endpoints. A session ID of zero denotes use of the Default Session Key. The Default Session Key is also used with non-zero session IDs during the latter phases of session startup (Sections 2.3.6 and 2.3.8). See Security Considerations (Section 5) for more about the Default Session Key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
暗号化プロファイルは、セッション開始時に使用される既知のデフォルトセッションキーを定義します。このセッション中に、セッションごとのキーが2つのエンドポイントによってネゴシエートされます。ゼロのセッションIDは、デフォルトセッションキーの使用を示します。デフォルトセッションキーは、セッション起動の後のフェーズ（セクション2.3.6および2.3.8）でゼロ以外のセッションIDとともに使用されます。デフォルトセッションキーの詳細については、セキュリティに関する考慮事項（セクション5）を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2-4--Packet">
2.2.4. Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.4. パケット
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An (unencrypted, plain) RTMFP packet consists of a variable sized common header, zero or more chunks, and padding. Padding can be inserted by the encryption layer of the sender to meet cipher block size constraints and is ignored by the receiver. A sender&#39;s encryption layer MAY pad the end of a packet with bytes with value 0xff such that the resulting packet is a natural and appropriate size for the cipher. Alternatively, the Cryptography Profile MAY define its own framing and padding scheme, if needed, such that decrypted packets are compatible with the syntax defined in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（暗号化されていない、プレーンな）RTMFPパケットは、可変サイズの共通ヘッダー、0個以上のチャンク、およびパディングで構成されます。パディングは、暗号化ブロックサイズの制約を満たすために送信者の暗号化層によって挿入でき、受信者は無視します。送信者の暗号化層は、結果のパケットが暗号にとって自然で適切なサイズになるように、値0xffのバイトでパケットの終わりを埋めてもよい（MAY）。あるいは、暗号化プロファイルは、必要に応じて、独自のフレーミングおよびパディング方式を定義してもよい（MAY）。これにより、復号されたパケットは、このセクションで定義された構文と互換性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |T|T| r |T|T| M |
   |C|C| s |S|S| O |
   | |R| v | |E| D |
   +-+-+-+-+-+-+-+-+
   +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+
   |        if(TS) timestamp       |     if(TSE) timestampEcho     |
   +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                             Chunk                             |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
                                   :
                                   :
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                             Chunk                             |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                            padding                            |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct packet_t
   {
       bool_t  timeCritical         :1; // &#34;TC&#34;
       bool_t  timeCriticalReverse  :1; // &#34;TCR&#34;
       uintn_t reserved             :2; // &#34;rsv&#34;
       bool_t  timestampPresent     :1; // &#34;TS&#34;
       bool_t  timestampEchoPresent :1; // &#34;TSE&#34;
       uintn_t mode                 :2; // &#34;MOD&#34;
       if(0 != mode)
       {
           if(timestampPresent)
               uint16_t timestamp;
           if(timestampEchoPresent)
               uint16_t timestampEcho;
           while(remainder() &gt; 2)
           {
               uint8_t  chunkType;
               uint16_t chunkLength;
               if(remainder() &lt; chunkLength)
                   break;
               uint8_t  chunkPayload[chunkLength];
           } // chunks
           uint8_t padding[remainder()];
       }
   } :plainPacket.length*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timeCritical: Time Critical Forward Notification. If set, indicates that this packet contains real-time user data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timeCritical：時間クリティカル転送通知。設定されている場合、このパケットにリアルタイムのユーザーデータが含まれていることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timeCriticalReverse: Time Critical Reverse Notification. If set, indicates that the sender is currently receiving packets on other sessions that have the timeCritical flag set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timeCriticalReverse：タイムクリティカルなリバース通知。設定されている場合、送信者が現在timeCriticalフラグが設定されている他のセッションでパケットを受信して​​いることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestampPresent: If set, indicates that the timestamp field is present. If clear, there is no timestamp field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestampPresent：設定されている場合、タイムスタンプフィールドが存在することを示します。クリアされている場合、タイムスタンプフィールドはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestampEchoPresent: If set, indicates that the timestamp echo field is present. If clear, there is no timestamp echo field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestampEchoPresent：設定されている場合、タイムスタンプエコーフィールドが存在することを示します。クリアされている場合、タイムスタンプエコーフィールドはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mode: The mode of this packet. See below for additional discussion of packet modes. Possible values are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mode：このパケットのモード。パケットモードの詳細については、以下を参照してください。可能な値は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0: Forbidden value
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0：禁止値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1: Initiator Mark
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1：イニシエーターマーク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2: Responder Mark
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2：応答者マーク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3: Startup
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3：スタートアップ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestamp: If the timestampPresent flag is set, this field is present and contains the low 16 bits of the sender&#39;s 250 Hz clock (4 milliseconds per tick) at transmit time. The sender&#39;s clock MAY have its origin at any time in the past.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestamp：timestampPresentフラグが設定されている場合、このフィールドが存在し、送信時の送信者の250 Hzクロック（ティックあたり4ミリ秒）の下位16ビットが含まれます。送信者の時計は、過去のいつでもその起源を持っているかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestampEcho: If the timestampEchoPresent flag is set, this field is present and contains the sender&#39;s estimate of what the timestamp field of a packet received from the other end would be at the time this packet was transmitted, using the method described in Section 3.5.2.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestampEcho：timestampEchoPresentフラグが設定されている場合、このフィールドが存在し、セクション3.5.2.2で説明されている方法を使用して、このパケットが送信されたときに相手側から受信したパケットのタイムスタンプフィールドがどうなるかについての送信者の推定が含まれます。 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunks: Zero or more chunks follow the header. It is RECOMMENDED that a packet contain at least one chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンク：0個以上のチャンクがヘッダーの後に続きます。パケットには少なくとも1つのチャンクが含まれていることが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
padding: Zero or more bytes of padding follow the chunks. The following conditions indicate padding:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディング：チャンクの後に0バイト以上のパディングが続きます。次の条件はパディングを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Fewer than three bytes (the size of a chunk header) remain in the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 3バイト未満（チャンクヘッダーのサイズ）がパケットに残ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The chunkLength field of what would be the current chunk header indicates that the hypothetical chunk payload wouldn&#39;t fit in the remaining bytes of the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 現在のチャンクヘッダーのchunkLengthフィールドは、仮想チャンクペイロードがパケットの残りのバイトに収まらないことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packet mode 0 is not allowed. Packets marked with this mode are invalid and MUST be discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットモード0は許可されていません。このモードでマークされたパケットは無効であり、破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The original initiator of a session MUST mark all non-startup packets it sends in that session with packet mode 1 (&#34;Initiator Mark&#34;). It SHOULD ignore any packet received in that session with packet mode 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションの元のイニシエーターは、そのセッションで送信するすべての非スタートアップパケットをパケットモード1（「イニシエーターマーク」）でマークする必要があります。パケットモード1のセッションで受信したパケットはすべて無視する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The original responder of a session MUST mark all non-startup packets it sends in that session with packet mode 2 (&#34;Responder Mark&#34;). It SHOULD ignore any packet received in that session with packet mode 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションの元のレスポンダは、そのセッションで送信するすべての非スタートアップパケットをパケットモード2（「レスポンダマーク」）でマークする必要があります。パケットモード2のセッションで受信したパケットはすべて無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packet mode 3 is for session startup. Session startup chunks are only allowed in packets with this mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットモード3はセッションの起動用です。セッション開始チャンクは、このモードのパケットでのみ許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Chunks that are not for session startup are only allowed in packets with modes 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションの起動用ではないチャンクは、モード1または2のパケットでのみ許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3--Chunks">
2.3. Chunks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. チャンク
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   chunkType   |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |        chunkPayload (chunkLength bytes, may be zero)          |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct chunk_t
   {
       uint8_t  chunkType;
       uint16_t chunkLength;
       uint8_t  chunkPayload[chunkLength];
   } :variable*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunkType: The chunk type code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunkType：チャンクタイプコード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunkLength: The size, in bytes, of the chunk payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunkLength：チャンクペイロードのサイズ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunkPayload: The type-specific payload of this chunk, chunkLength bytes in length (may be empty).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunkPayload：このチャンクのタイプ固有のペイロード、chunkLengthバイトの長さ（空の場合があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Defined chunk types are enumerated here in the order they might be encountered in the course of a typical session. The following chunk type codes are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定義されたチャンクタイプは、一般的なセッション中に遭遇する可能性がある順序でここに列挙されています。次のチャンクタイプコードが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x7f: Packet Fragment (Section 2.3.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x7f：パケットフラグメント（セクション2.3.1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x30: Initiator Hello (Section 2.3.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x30：イニシエーターこんにちは（セクション2.3.2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x0f: Forwarded Initiator Hello (Section 2.3.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x0f：Forwarded Initiator Hello（セクション2.3.3）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x70: Responder Hello (Section 2.3.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x70：応答側Hello（セクション2.3.4）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x71: Responder Redirect (Section 2.3.5)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x71：レスポンダリダイレクト（セクション2.3.5）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x79: RHello Cookie Change (Section 2.3.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x79：RHello Cookieの変更（セクション2.3.6）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x38: Initiator Initial Keying (Section 2.3.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x38：イニシエーターの初期キーイング（セクション2.3.7）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x78: Responder Initial Keying (Section 2.3.8)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x78：Responder Initial Keying（セクション2.3.8）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x01: Ping (Section 2.3.9)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x01：Ping（セクション2.3.9）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x41: Ping Reply (Section 2.3.10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x41：Ping応答（セクション2.3.10）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x10: User Data (Section 2.3.11)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x10：ユーザーデータ（セクション2.3.11）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x11: Next User Data (Section 2.3.12)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x11：次のユーザーデータ（セクション2.3.12）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x50: Data Acknowledgement Bitmap (Section 2.3.13)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x50：データ確認ビットマップ（セクション2.3.13）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x51: Data Acknowledgement Ranges (Section 2.3.14)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x51：データ確認応答範囲（セクション2.3.14）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x18: Buffer Probe (Section 2.3.15)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x18：バッファプローブ（セクション2.3.15）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x5e: Flow Exception Report (Section 2.3.16)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x5e：フロー例外レポート（セクション2.3.16）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x0c: Session Close Request (Section 2.3.17)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x0c：セッション終了リクエスト（セクション2.3.17）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x4c: Session Close Acknowledgement (Section 2.3.18)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x4c：セッション終了の確認（セクション2.3.18）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x00: Ignore/Padding
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x00：無視/パディング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0xff: Ignore/Padding
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0xff：無視/パディング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiver MUST ignore a chunk having an unrecognized chunk type code. A receiver MUST ignore a chunk appearing in a packet having a mode inappropriate to that chunk type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信者は、認識されていないチャンクタイプコードを持つチャンクを無視する必要があります。受信者は、そのチャンクタイプに不適切なモードを持つパケットに現れるチャンクを無視しなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless specified otherwise, if a chunk has a syntax or processing error (for example, the chunk&#39;s payload field is not long enough to contain the specified syntax elements), the chunk SHALL be ignored as though it was not present in the packet, and parsing and processing SHALL commence with the next chunk in the packet, if any.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に明記されていない限り、チャンクに構文エラーまたは処理エラーがある場合（たとえば、チャンクのペイロードフィールドが指定された構文要素を含めるのに十分な長さでない場合）、チャンクはパケットに存在しないかのように無視され、解析されます（SHALL）。そして、もしあれば、パケット内の次のチャンクから処理を開始する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-1--Packet-Fragment-Chunk">
2.3.1. Packet Fragment Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.1. パケットフラグメントチャンク
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is used to divide a plain RTMFP packet (Section 2.2.4) that is unavoidably larger than the path MTU (such as session startup packets containing Responder Hello (Section 2.3.4) or Initiator Initial Keying (Section 2.3.7) chunks with large certificates) into segments that do not exceed the path MTU, and to allow the segments to be sent through the network at a moderated rate to avoid jamming interfaces, links, or paths.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、パスMTU（Responder Hello（セクション2.3.4）またはInitiator Initial Keying（セクション2.3.7）チャンクを含むセッション起動パケットなど）を避けられないサイズのプレーンなRTMFPパケット（セクション2.2.4）を分割するために使用されますパスのMTUを超えないセグメントに分割し、セグメントが適度な速度でネットワークを介して送信されるようにして、インターフェース、リンク、またはパスの妨害を回避します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x7f     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-------------/-+-------------/-+
   |M|  reserved   |   packetID  \ | fragmentNum \ |
   +-+-+-+-+-+-+-+-+-------------/-+-------------/-+
   +---------------------------------------------------------------+
   |                         packetFragment                        |
   +---------------------------------------------------------------/
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fragmentChunkPayload_t
   {
       bool_t  moreFragments :1; // M
       uintn_t reserved      :7;
       vlu_t   packetID      :variable*8;
       vlu_t   fragmentNum   :variable*8;
       uint8_t packetFragment[remainder()];
   } :chunkLength*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
moreFragments: If set, the indicated packet comprises additional fragments. If clear, this fragment is the final fragment of the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
moreFragments：設定されている場合、示されたパケットは追加のフラグメントを含みます。クリアの場合、このフラグメントはパケットの最後のフラグメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
reserved: Reserved for future use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
reserved：将来使用するために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
packetID: VLU, the identifier of this segmented packet. All fragments of the same packet have the same packetID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
packetID：VLU、このセグメント化されたパケットの識別子。同じパケットのすべてのフラグメントは同じpacketIDを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragmentNum: VLU, the index of this fragment of the indicated packet. The first fragment of the packet MUST be index 0. Fragments are numbered consecutively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragmentNum：VLU、指定されたパケットのこのフラグメントのインデックス。パケットの最初のフラグメントはインデックス0である必要があります。フラグメントは連続して番号が付けられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
packetFragment: The bytes of the indicated segment of the indicated original plain RTMFP packet. A packetFragment MUST NOT be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
packetFragment：指定された元のプレーンRTMFPパケットの指定されたセグメントのバイト。 packetFragmentを空にすることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of this mechanism is detailed in Section 3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメカニズムの使用については、セクション3.4で詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-2--Initiator-Hello-Chunk-IHello">
2.3.2. Initiator Hello Chunk (IHello)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.2. イニシエーターHello Chunk（IHello）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent by the initiator of a new session to begin the startup handshake. This chunk is only allowed in a packet with Session ID 0, encrypted with the Default Session Key, and having packet mode 3 (Startup).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、スタートアップハンドシェイクを開始するために、新しいセッションの開始者によって送信されます。このチャンクは、セッションID 0、デフォルトセッションキーで暗号化され、パケットモード3（スタートアップ）のパケットでのみ許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x30     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-----------------------------------------------+
   |  epdLength  \ |    endpointDiscriminator (epdLength bytes)    |
   +-------------/-+-----------------------------------------------/
   +---------------------------------------------------------------+
   |                              tag                              |
   +---------------------------------------------------------------/
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ihelloChunkPayload_t
   {
       vlu_t   epdLength :variable*8;
       uint8_t endpointDiscriminator[epdLength];
       uint8_t tag[remainder()];
   } :chunkLength*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
epdLength: VLU, the length of the following endpointDiscriminator field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
epdLength：VLU、次のendpointDiscriminatorフィールドの長さ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
endpointDiscriminator: The Endpoint Discriminator for the identity with which the initiator wants to communicate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
endpointDiscriminator：イニシエーターが通信するIDのエンドポイントディスクリミネーター。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tag: Initiator-provided data to be returned in a Responder Hello&#39;s tagEcho field. The tag/tagEcho is used to match Responder Hellos to the initiator&#39;s session startup state independent of the responder&#39;s address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tag：イニシエーターが提供するデータで、レスポンダのHelloのtagEchoフィールドに返されます。 tag / tagEchoは、レスポンダーのアドレスに関係なく、レスポンダーのHelloをイニシエーターのセッション起動状態に一致させるために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of IHello is detailed in Section 3.5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IHelloの使用については、セクション3.5.1で詳しく説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-3--Forwarded-Initiator-Hello-Chunk-FIHello">
2.3.3. Forwarded Initiator Hello Chunk (FIHello)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.3. 転送イニシエーターHelloチャンク（FIHello）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent on behalf of an initiator by a Forwarder. It is only allowed in packets of an established session having packet mode 1 or 2. A receiver MAY treat this chunk as though it was an Initiator Hello received directly from replyAddress. Alternatively, if the receiver is selected by the Endpoint Discriminator, it MAY respond to replyAddress with an Implied Redirect (Section 2.3.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、フォワーダーによってイニシエーターに代わって送信されます。これは、パケットモード1または2の確立されたセッションのパケットでのみ許可されます。受信者は、このチャンクを、ReplyAddressから直接受信されたInitiator Helloであるかのように処理できます。あるいは、受信者がEndpoint Discriminatorによって選択された場合、暗黙のリダイレクト（セクション2.3.5）でreplyAddressに応答する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x0f     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-----------------------------------------------+
   |  epdLength  \ |    endpointDiscriminator (epdLength bytes)    |
   +-------------/-+-----------------------------------------------/
   +---------------------------------------------------------------+
   |                          replyAddress                         |
   +---------------------------------------------------------------/
   +---------------------------------------------------------------+
   |                              tag                              |
   +---------------------------------------------------------------/
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fihelloChunkPayload_t
   {
       vlu_t     epdLength :variable*8;
       uint8_t   endpointDiscriminator[epdLength];
       address_t replyAddress :variable*8;
       uint8_t   tag[remainder()];
   } :chunkLength*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
epdLength: VLU, the length of the following endpointDiscriminator field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
epdLength：VLU、次のendpointDiscriminatorフィールドの長さ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
endpointDiscriminator: The Endpoint Discriminator for the identity with which the original initiator wants to communicate, copied from the original Initiator Hello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
endpointDiscriminator：元のイニシエーターHelloからコピーされた、元のイニシエーターが通信するIDのエンドポイントディスクリミネーター。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
replyAddress: Address format (Section 2.1.5), the address that the forwarding node derived from the received Initiator Hello, to which the receiver should respond.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
replyAddress：アドレス形式（セクション2.1.5）。受信側が応答する必要がある、受信したInitiator Helloから転送ノードが取得したアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tag: Copied from the original Initiator Hello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タグ：元のイニシエーターこんにちはからコピー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of FIHello is detailed in Section 3.5.1.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FIHelloの使用については、セクション3.5.1.5で詳しく説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-4--Responder-Hello-Chunk-RHello">
2.3.4. Responder Hello Chunk (RHello)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.4. レスポンダーHello Chunk（RHello）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent by a responder in response to an Initiator Hello or Forwarded Initiator Hello if the Endpoint Discriminator indicates the responder&#39;s identity. This chunk is only allowed in a packet with Session ID 0, encrypted with the Default Session Key, and having packet mode 3 (Startup).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、Endpoint DiscriminatorがレスポンダのIDを示している場合、Initiator HelloまたはForwarded Initiator Helloに応答してレスポンダによって送信されます。このチャンクは、セッションID 0、デフォルトセッションキーで暗号化され、パケットモード3（スタートアップ）のパケットでのみ許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x70     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-----------------------------------------------+
   |  tagLength  \ |            tagEcho (tagLength bytes)          |
   +-------------/-+-----------------------------------------------/
   +-------------/-+-----------------------------------------------+
   | cookieLength\ |           cookie (cookieLength bytes)         |
   +-------------/-+-----------------------------------------------/
   +---------------------------------------------------------------+
   |                     responderCertificate                      |
   +---------------------------------------------------------------/
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct rhelloChunkPayload_t
   {
       vlu_t   tagLength :variable*8;
       uint8_t tagEcho[tagLength];
       vlu_t   cookieLength :variable*8;
       uint8_t cookie[cookieLength];
       uint8_t responderCertificate[remainder()];
   } :chunkLength*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tagLength: VLU, the length of the following tagEcho field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tagLength：VLU、次のtagEchoフィールドの長さ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tagEcho: The tag from the Initiator Hello, unaltered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tagEcho：イニシエーターこんにちは、変更されていないタグ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieLength: VLU, the length of the following cookie field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieLength：VLU、次のcookieフィールドの長さ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookie: Responder-created state data to authenticate a future Initiator Initial Keying message (in order to prevent denial-of-service attacks).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookie：将来のイニシエーター初期キーメッセージを認証するためにレスポンダーが作成した状態データ（サービス拒否攻撃を防ぐため）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responderCertificate: The responder&#39;s cryptographic credentials.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responderCertificate：レスポンダーの暗号化資格。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: This specification doesn&#39;t mandate a specific choice of certificate format. The Cryptography Profile determines the syntax, algorithms, and interpretation of the responderCertificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：この仕様では、証明書形式の特定の選択を義務付けていません。暗号化プロファイルは、responderCertificateの構文、アルゴリズム、および解釈を決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of RHello is detailed in Section 3.5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RHelloの使用については、セクション3.5.1で詳しく説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-5--Responder-Redirect-Chunk-Redirect">
2.3.5. Responder Redirect Chunk (Redirect)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.5. レスポンダリダイレクトチャンク（リダイレクト）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent in response to an Initiator Hello or Forwarded Initiator Hello to indicate that the requested endpoint can be reached at one or more of the indicated addresses. A receiver can add none, some, or all of the indicated addresses to the set of addresses to which it is sending Initiator Hello messages for the opening session associated with tagEcho. This chunk is only allowed in a packet with Session ID 0, encrypted with the Default Session Key, and having packet mode 3 (Startup).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、Initiator HelloまたはForwarded Initiator Helloに応答して送信され、指定されたアドレスの1つ以上で要求されたエンドポイントに到達できることを示します。レシーバーは、tagEchoに関連付けられた開始セッションのイニシエーターHelloメッセージを送信するアドレスのセットに、示されたアドレスの一部またはすべてを追加することができます。このチャンクは、セッションID 0、デフォルトセッションキーで暗号化され、パケットモード3（スタートアップ）のパケットでのみ許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x71     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-----------------------------------------------+
   |  tagLength  \ |            tagEcho (tagLength bytes)          |
   +-------------/-+-----------------------------------------------/
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                     redirectDestination 1                     |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
                                   :
                                   :
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                     redirectDestination N                     |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct responderRedirectChunkPayload_t
   {
       vlu_t   tagLength :variable*8;
       uint8_t tagEcho[tagLength];
       addressCount = 0;
       while(remainder() &gt; 0)
       {
           address_t redirectDestination :variable*8;
           addressCount++;
       }
       if(0 == addressCount)
           redirectDestination = packetSourceAddress();
   } :chunkLength*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tagLength: VLU, the length of the following tagEcho field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tagLength：VLU、次のtagEchoフィールドの長さ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tagEcho: The tag from the Initiator Hello, unaltered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tagEcho：イニシエーターこんにちは、変更されていないタグ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
redirectDestination: (Zero or more) Address format (Section 2.1.5) addresses to add to the opening set for the indicated session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
redirectDestination：（ゼロ以上）指定されたセッションの開始セットに追加するアドレス形式（セクション2.1.5）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If this chunk lists zero redirectDestination addresses, then this is an Implied Redirect, and the indicated address is the address from which the packet containing this chunk was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクがゼロのredirectDestinationアドレスをリストしている場合、これは暗黙のリダイレクトであり、示されたアドレスは、このチャンクを含むパケットの受信元のアドレスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of Redirect is detailed in Sections 3.5.1.1.1, 3.5.1.1.2, and 3.5.1.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リダイレクトの使用については、セクション3.5.1.1.1、3.5.1.1.2、および3.5.1.4で詳しく説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-6--RHello-Cookie-Change-Chunk">
2.3.6. RHello Cookie Change Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.6. RHello Cookie変更チャンク
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk SHOULD be sent by a responder to an initiator in response to an Initiator Initial Keying if that chunk&#39;s cookie appears to have been created by the responder but the cookie is incorrect (for example, it includes a hash of the initiator&#39;s address, but the initiator&#39;s address is different than the one that elicited the Responder Hello containing the original cookie).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、そのチャンクのCookieがレスポンダによって作成されたように見えても、Cookieが正しくない場合（たとえば、イニシエータのアドレスのハッシュが含まれているが、イニシエーターのアドレスは、元のCookieを含むレスポンダーHelloを引き出したアドレスとは異なります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is only allowed in a packet encrypted with the Default Session Key and having packet mode 3, and with the session ID indicated in the initiatorSessionID field of the Initiator Initial Keying to which this is a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、デフォルトセッションキーで暗号化され、パケットモード3で暗号化されたパケット、およびこれが応答であるイニシエーター初期キーのInitiatorSessionIDフィールドに示されたセッションIDでのみ許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x79     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-----------------------------------------------+
   | oldCookieLen\ |        oldCookie (oldCookieLen bytes)         |
   +-------------/-+-----------------------------------------------/
   +---------------------------------------------------------------+
   |                           newCookie                           |
   +---------------------------------------------------------------/
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct rhelloCookieChangeChunkPayload_t
   {
       vlu_t   oldCookieLen :variable*8;
       uint8_t oldCookie[oldCookieLen];
       uint8_t newCookie[remainder()];
   } :chunkLength*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldCookieLen: VLU, the length of the following oldCookie field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldCookieLen：VLU、次のoldCookieフィールドの長さ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldCookie: The cookie that was sent in a previous Responder Hello and Initiator Initial Keying.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldCookie：以前のレスポンダーのHelloおよびイニシエーターの初期キーで送信されたCookie。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
newCookie: The new cookie that the responder would like sent (and signed) in a replacement Initiator Initial Keying. The old and new cookies need not have the same lengths.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
newCookie：レスポンダが代わりのイニシエーター初期キーで送信（および署名）したい新しいCookie。新旧のクッキーは同じ長さである必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of this chunk, the initiator SHOULD compute, sign, and send a new Initiator Initial Keying having newCookie in place of oldCookie. The use of this chunk is detailed in Section 3.5.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクを受け取ると、イニシエーターはoldCookieの代わりにnewCookieを持つ新しいイニシエーター初期キーを計算、署名、および送信する必要があります（SHOULD）。このチャンクの使用については、セクション3.5.1.2で詳しく説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-7--Initiator-Initial-Keying-Chunk-IIKeying">
2.3.7. Initiator Initial Keying Chunk (IIKeying)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.7. イニシエーター初期鍵チャンク（IIKeying）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent by an initiator to establish a session with a responder. The initiator MUST have obtained a valid cookie to use with the responder, typically by receiving a Responder Hello from it. This chunk is only allowed in a packet with Session ID 0, encrypted with the Default Session Key, and having packet mode 3 (Startup).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、レスポンダとのセッションを確立するためにイニシエータによって送信されます。イニシエータは、通常、レスポンダHelloを受信して​​、レスポンダで使用する有効なCookieを取得している必要があります。このチャンクは、セッションID 0、デフォルトセッションキーで暗号化され、パケットモード3（スタートアップ）のパケットでのみ許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x38     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       initiatorSessionID                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-----------------------------------------------+
   | cookieLength\ |                  cookieEcho                   |
   +-------------/-+-----------------------------------------------/
   +-------------/-+-----------------------------------------------+
   |  certLength \ |             initiatorCertificate              |
   +-------------/-+-----------------------------------------------/
   +-------------/-+-----------------------------------------------+
   |  skicLength \ |          sessionKeyInitiatorComponent         |
   +-------------/-+-----------------------------------------------/
   +---------------------------------------------------------------+
   |                           signature                           |
   +---------------------------------------------------------------/
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct iikeyingChunkPayload_t
   {
       struct
       {
           uint32_t initiatorSessionID;
           vlu_t    cookieLength :variable*8;
           uint8_t  cookieEcho[cookieLength];
           vlu_t    certLength :variable*8;
           uint8_t  initiatorCertificate[certLength];
           vlu_t    skicLength :variable*8;
           uint8_t  sessionKeyInitiatorComponent[skicLength];
       } initiatorSignedParameters :variable*8;
       uint8_t signature[remainder()];
   } :chunkLength*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initiatorSessionID: The session ID to be used by the responder when sending packets to the initiator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initiatorSessionID：パケットをイニシエーターに送信するときにレスポンダーが使用するセッションID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieLength: VLU, the length of the following cookieEcho field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieLength：VLU、次のcookieEchoフィールドの長さ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieEcho: The cookie from the Responder Hello, unaltered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieEcho：レスポンダHelloからのcookieで、変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certLength: VLU, the length of the following initiatorCertificate field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certLength：VLU、次の発信者Certificateフィールドの長さ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initiatorCertificate: The initiator&#39;s identity credentials.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initiatorCertificate：イニシエーターのID資格情報。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
skicLength: VLU, the length of the following sessionKeyInitiatorComponent field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
skicLength：VLU、次のsessionKeyInitiatorComponentフィールドの長さ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sessionKeyInitiatorComponent: The initiator&#39;s portion of the session key negotiation according to the Cryptography Profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sessionKeyInitiatorComponent：暗号化プロファイルによるセッションキーネゴシエーションの開始者の部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initiatorSignedParameters: The payload portion of this chunk up to the signature field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initiatorSignedParameters：このチャンクのペイロード部分から署名フィールドまで。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
signature: The initiator&#39;s digital signature of the initiatorSignedParameters according to the Cryptography Profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
signature：暗号化プロファイルに従った、initiatorSignedParametersのイニシエーターのデジタル署名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: This specification doesn&#39;t mandate a specific choice of cryptography. The Cryptography Profile determines the syntax, algorithms, and interpretation of the initiatorCertificate, responderCertificate, sessionKeyInitiatorComponent, sessionKeyResponderComponent, and signature, and how the sessionKeyInitiatorComponent and sessionKeyResponderComponent are combined to derive the session keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：この仕様は、暗号化の特定の選択を義務付けるものではありません。暗号化プロファイルは、initiatorCertificate、responderCertificate、sessionKeyInitiatorComponent、sessionKeyResponderComponent、および署名の構文、アルゴリズム、解釈、およびsessionKeyInitiatorComponentとsessionKeyResponderComponentを組み合わせてセッションキーを取得する方法を決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of IIKeying is detailed in Section 3.5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IIKeyingの使用については、セクション3.5.1で詳しく説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-8--Responder-Initial-Keying-Chunk-RIKeying">
2.3.8. Responder Initial Keying Chunk (RIKeying)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.8. レスポンダーの初期キーチャンク（RIKeying）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent by a responder in response to an Initiator Initial Keying as the final phase of session startup. This chunk is only allowed in a packet encrypted with the Default Session Key, having packet mode 3 (Startup), and sent to the initiator with the session ID specified by the initiatorSessionID field from the Initiator Initial Keying.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、セッション開始の最終フェーズとして、イニシエーター初期キーに応答してレスポンダによって送信されます。このチャンクは、デフォルトのセッションキーで暗号化され、パケットモード3（スタートアップ）のパケットでのみ許可され、イニシエーター初期キーからの発信者セッションIDフィールドで指定されたセッションIDで発信者に送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x78     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       responderSessionID                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-----------------------------------------------+
   |  skrcLength \ |         sessionKeyResponderComponent          |
   +-------------/-+-----------------------------------------------/
   +---------------------------------------------------------------+
   |                           signature                           |
   +---------------------------------------------------------------/
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct rikeyingChunkPayload_t
   {
       struct
       {
           uint32_t responderSessionID;
           vlu_t    skrcLength :variable*8;
           uint8_t  sessionKeyResponderComponent[skrcLength];
       } responderSignedParametersPortion :variable*8;
       uint8_t  signature[remainder()];
   } :chunkLength*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct
   {
       responderSignedParametersPortion;
       sessionKeyInitiatorComponent;
   } responderSignedParameters;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responderSessionID: The session ID to be used by the initiator when sending packets to the responder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responderSessionID：応答側にパケットを送信するときに開始側が使用するセッションID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
skrcLength: VLU, the length of the following sessionKeyResponderComponent field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
skrcLength：VLU、後続のsessionKeyResponderComponentフィールドの長さ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sessionKeyResponderComponent: The responder&#39;s portion of the session key negotiation according to the Cryptography Profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sessionKeyResponderComponent：暗号化プロファイルによるセッションキーネゴシエーションのレスポンダの部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responderSignedParametersPortion: The payload portion of this chunk up to the signature field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responderSignedParametersPortion：このチャンクのペイロード部分から署名フィールドまで。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
signature: The responder&#39;s digital signature of the responderSignedParameters (see below) according to the Cryptography Profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
署名：暗号化プロファイルに基づくレスポンダーのレスポンダーのデジタル署名（以下を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responderSignedParameters: The concatenation of the responderSignedParametersPortion (the payload portion of this chunk up to the signature field) and the sessionKeyInitiatorComponent from the Initiator Initial Keying to which this chunk is a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responderSignedParameters：responderSignedParametersPortion（このチャンクのペイロード部分から署名フィールドまで）と、このチャンクが応答するInitiator Initial KeyingからのsessionKeyInitiatorComponentの連結。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: This specification doesn&#39;t mandate a specific choice of cryptography. The Cryptography Profile determines the syntax, algorithms, and interpretation of the initiatorCertificate, responderCertificate, sessionKeyInitiatorComponent, sessionKeyResponderComponent, and signature, and how the sessionKeyInitiatorComponent and sessionKeyResponderComponent are combined to derive the session keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：この仕様は、暗号化の特定の選択を義務付けるものではありません。暗号化プロファイルは、initiatorCertificate、responderCertificate、sessionKeyInitiatorComponent、sessionKeyResponderComponent、および署名の構文、アルゴリズム、解釈、およびsessionKeyInitiatorComponentとsessionKeyResponderComponentを組み合わせてセッションキーを取得する方法を決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the responder has computed the sessionKeyResponderComponent, it has all of the information and state necessary for an established session with the initiator. Once the responder has sent this chunk to the initiator, the session is established and ready to carry flows of user data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レスポンダがsessionKeyResponderComponentを計算すると、イニシエータとの確立されたセッションに必要なすべての情報と状態が得られます。レスポンダがこのチャンクをイニシエータに送信すると、セッションが確立され、ユーザーデータのフローを伝送する準備が整います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the initiator receives, verifies, and processes this chunk, it has all of the information and state necessary for an established session with the responder. The session is established and ready to carry flows of user data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエーターは、このチャンクを受信、検証、および処理すると、レスポンダーとの確立されたセッションに必要なすべての情報と状態を取得します。セッションが確立され、ユーザーデータのフローを伝送する準備が整います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of RIKeying is detailed in Section 3.5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RIKeyingの使用については、セクション3.5.1で詳しく説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-9--Ping-Chunk">
2.3.9. Ping Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.9. ピンチャンク
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent in order to elicit a Ping Reply from the receiver. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、受信側からPing応答を引き出すために送信されます。確立されたセッションに属し、パケットモードが1または2のパケットでのみ許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x01     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                             message                           |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct pingChunkPayload_t
   {
       uint8_t message[chunkLength];
   } :chunkLength*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
message: The (potentially empty) message that is expected to be returned by the other end of the session in a Ping Reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージ：セッションのもう一方の端からPing応答で返されると予想される（潜在的に空の）メッセージ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receiver of this chunk SHOULD reply as immediately as is practical with a Ping Reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクの受信者は、Ping応答を使用してできるだけ早く応答する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ping and the expected Ping Reply are typically used for session keepalive, endpoint address change verification, and path MTU discovery. See Section 3.5.4 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pingと予想されるPing応答は、通常、セッションキープアライブ、エンドポイントアドレス変更の検証、およびパスMTUディスカバリに使用されます。詳細については、セクション3.5.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-10--Ping-Reply-Chunk">
2.3.10. Ping Reply Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.10. Ping返信チャンク
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent in response to a Ping chunk. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、Pingチャンクへの応答として送信されます。確立されたセッションに属し、パケットモードが1または2のパケットでのみ許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x41     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                           messageEcho                         |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct pingReplyChunkPayload_t
   {
       uint8_t messageEcho[chunkLength];
   } :chunkLength*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
messageEcho: The message from the Ping to which this is a response, unaltered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
messageEcho：これが応答であるPingからのメッセージ。変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-11--User-Data-Chunk">
2.3.11. User Data Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.11. ユーザーデータチャンク
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is the basic unit of transmission for the user messages of a flow. A user message comprises one or more fragments. Each fragment is carried in its own chunk and has a unique sequence number in its flow. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、フローのユーザーメッセージの送信の基本単位です。ユーザーメッセージは、1つ以上のフラグメントで構成されます。各フラグメントは独自のチャンクで運ばれ、フロー内で一意のシーケンス番号を持ちます。確立されたセッションに属し、パケットモードが1または2のパケットでのみ許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x10     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+
   |O|r| F | r |A|F|
   |P|s| R | s |B|I|
   |T|v| A | v |N|N|
   +-+-+-+-+-+-+-+-+
   +-------------/-+-------------/-+-------------/-+
   |   flowID    \ |     seq#    \ |  fsnOffset  \ |
   +-------------/-+-------------/-+-------------/-+
   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+-------------/-+
   | L \ T \   V   |... options ...| L \ T \   V   |       0     \ |
   \~~~/~~~/~~~~~~~+   [if(OPT)]   +~~~/~~~/~~~~~~~+-------------/-/
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                            userData                           |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct userDataChunkPayload_t
   {
       bool_t  optionsPresent :1;  // &#34;OPT&#34;
       uintn_t reserved1 :1;       // &#34;rsv&#34;
       uintn_t fragmentControl :2; // &#34;FRA&#34;
           // 0=whole, 1=begin, 2=end, 3=middle
       uintn_t reserved2 :2;       // &#34;rsv&#34;
       bool_t  abandon :1;         // &#34;ABN&#34;
       bool_t  final :1;           // &#34;FIN&#34;
       vlu_t   flowID :variable*8;
       vlu_t   sequenceNumber :variable*8; // &#34;seq#&#34;
       vlu_t   fsnOffset :variable*8;
       forwardSequenceNumber = sequenceNumber - fsnOffset;
       if(optionsPresent)
           optionList_t options :variable*8;
       uint8_t userData[remainder()];
   } :chunkLength*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
optionsPresent: If set, indicates the presence of an option list before the user data. If clear, there is no option list in this chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
optionsPresent：設定されている場合、ユーザーデータの前にオプションリストが存在することを示します。クリアされている場合、このチャンクにはオプションリストはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragmentControl: Indicates how this fragment is assembled, potentially with others, into a complete user message. Possible values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragmentControl：このフラグメントが、他のユーザーと一緒に、完全なユーザーメッセージにアセンブルされる方法を示します。可能な値：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0: This fragment is a complete message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0：このフラグメントは完全なメッセージです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1: This fragment is the first of a multi-fragment message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1：このフラグメントは、マルチフラグメントメッセージの最初のものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2: This fragment is the last of a multi-fragment message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2：このフラグメントは、マルチフラグメントメッセージの最後です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3: This fragment is in the middle of a multi-fragment message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3：このフラグメントは、マルチフラグメントメッセージの途中にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A single-fragment user message has a fragment control of &#34;0-whole&#34;. When a message has more than one fragment, the first fragment has a fragment control of &#34;1-begin&#34;, then zero or more &#34;3-middle&#34; fragments, and finally a &#34;2-end&#34; fragment. The sequence numbers of a multi-fragment message MUST be contiguous.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
単一フラグメントのユーザーメッセージには、「0全体」のフラグメントコントロールがあります。メッセージに複数のフラグメントがある場合、最初のフラグメントには「1-begin」、次に0個以上の「3-middle」フラグメント、最後に「2-end」フラグメントのフラグメントコントロールがあります。マルチフラグメントメッセージのシーケンス番号は連続している必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
abandon: If set, this sequence number has been abandoned by the sender. The userData, if any, MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
abandon：設定されている場合、このシーケンス番号は送信者によって破棄されています。 userData（ある場合）は無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
final: If set, this is the last sequence number of the flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
final：設定されている場合、これはフローの最後のシーケンス番号です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flowID: VLU, the flow identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flowID：VLU、フロー識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sequenceNumber: VLU, the sequence number of this fragment. Fragments are assigned contiguous increasing sequence numbers in a flow. The first sequence number of a flow SHOULD be 1. The first sequence number of a flow MUST be greater than zero. Sequence numbers are unbounded and do not wrap.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sequenceNumber：VLU、このフラグメントのシーケンス番号。フラグメントには、フロー内で連続する増加するシーケンス番号が割り当てられます。フローの最初のシーケンス番号は1である必要があります（SHOULD）。フローの最初のシーケンス番号はゼロより大きい必要があります。シーケンス番号には制限がなく、折り返されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fsnOffset: VLU, the difference between the sequence number and the Forward Sequence Number. This field MUST NOT be zero if the abandon flag is not set. This field MUST NOT be greater than sequenceNumber.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fsnOffset：VLU、シーケンス番号と転送シーケンス番号の違い。放棄フラグが設定されていない場合、このフィールドはゼロであってはなりません。このフィールドは、sequenceNumberより大きくてはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
forwardSequenceNumber: The flow sender will not send (or resend) any fragment with a sequence number less than or equal to the Forward Sequence Number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
forwardSequenceNumber：フロー送信側は、転送シーケンス番号以下のシーケンス番号を持つフラグメントを送信（または再送信）しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
options: If the optionsPresent flag is set, a list of zero or more Options terminated by a Marker is present. See Section 2.3.11.1 for defined options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
options：optionsPresentフラグが設定されている場合、マーカーで終了する0個以上のオプションのリストが存在します。定義されているオプションについては、セクション2.3.11.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
userData: The actual user data for this fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
userData：このフラグメントの実際のユーザーデータ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of User Data is detailed in Section 3.6.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーデータの使用については、セクション3.6.2で詳しく説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-11-1--Options-for-User-Data">
2.3.11.1. Options for User Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.11.1. ユーザーデータのオプション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section lists options that may appear in User Data option lists. A conforming implementation MUST support the options in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、ユーザーデータオプションリストに表示されるオプションを示します。準拠する実装は、このセクションのオプションをサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A flow receiver MUST reject a flow containing a flow option that is not understood if the option type is less than 8192 (0x2000). A flow receiver MUST ignore any flow option that is not understood if the option type is 8192 or greater.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローレシーバーは、オプションタイプが8192（0x2000）未満の場合に理解されないフローオプションを含むフローを拒否する必要があります。フローレシーバーは、オプションタイプが8192以上の場合、理解できないフローオプションを無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following option type codes are defined for User Data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のオプションタイプコードは、ユーザーデータに対して定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x00: User&#39;s Per-Flow Metadata (Section 2.3.11.1.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x00：ユーザーのフローごとのメタデータ（セクション2.3.11.1.1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x0a: Return Flow Association (Section 2.3.11.1.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x0a：Return Flow Association（セクション2.3.11.1.2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-11-1-1--Users-Per-Flow-Metadata">
2.3.11.1.1. User&#39;s Per-Flow Metadata
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.11.1.1. ユーザーのフローごとのメタデータ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This option conveys the user&#39;s per-flow metadata for the flow to which it&#39;s attached.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオプションは、アタッチされているフローのフローごとのユーザーのメタデータを伝えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |   length    \ |     0x00    \ |         userMetadata          |
   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct userMetadataOptionValue_t
   {
       uint8_t userMetadata[remainder()];
   } :remainder()*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The user associates application-defined metadata with each flow. The metadata does not change over the life of the flow. Every flow MUST have metadata. A flow sender MUST send this option with the first User Data chunk for this flow in each packet until an acknowledgement for this flow is received. A flow sender SHOULD NOT send this option more than once for each flow in any one packet. A flow sender SHOULD NOT send this option for a flow once the flow has been acknowledged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーは、アプリケーション定義のメタデータを各フローに関連付けます。メタデータはフローの存続期間を通じて変更されません。すべてのフローにはメタデータが必要です。フローの送信者は、このフローの確認応答が受信されるまで、各パケットでこのフローの最初のユーザーデータチャンクとともにこのオプションを送信する必要があります。フローセンダーは、1つのパケットの各フローに対してこのオプションを複数回送信してはなりません（SHOULD NOT）。フローが確認されると、フロー送信者はフローに対してこのオプションを送信してはなりません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification doesn&#39;t mandate the encoding, syntax, or interpretation of the user&#39;s per-flow metadata; this is determined by the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、ユーザーのフローごとのメタデータのエンコード、構文、または解釈を義務付けていません。これはアプリケーションによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The userMetadata SHOULD NOT exceed 512 bytes. The userMetadata MAY be 0 bytes in length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
userMetadataは512バイトを超えてはなりません（SHOULD NOT）。 userMetadataの長さは0バイトである場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-11-1-2--Return-Flow-Association">
2.3.11.1.2. Return Flow Association
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.11.1.2. 戻りフローの関連付け
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A new flow can be considered to be in return (or response) to a flow sent by the other endpoint. This option encodes the receive flow identifier to which this new sending flow is a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいフローは、他のエンドポイントによって送信されたフローの見返り（または応答）であると見なすことができます。このオプションは、この新しい送信フローが応答である受信フロー識別子をエンコードします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------/-+-------------/-+-------------/-+
   |   length    \ |     0x0a    \ |    flowID   \ |
   +-------------/-+-------------/-+-------------/-+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct returnFlowAssociationOptionValue_t
   {
       vlu_t flowID :variable*8;
   } :variable*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider endpoints A and B. Endpoint A begins a flow with identifier 5 to endpoint B. A is the flow sender for A&#39;s flowID=5, and B is the flow receiver for A&#39;s flowID=5. B begins a return flow with identifier 7 to A in response to A&#39;s flowID=5. B is the flow sender for B&#39;s flowID=7, and A is the flow receiver for B&#39;s flowID=7. B sends this option with flowID set to 5 to indicate that B&#39;s flowID=7 is in response to and associated with A&#39;s flowID=5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントAとBを考えます。エンドポイントAは、エンドポイントBへの識別子5でフローを開始します。AはAのflowID = 5のフローセンダーであり、BはAのflowID = 5のフローレシーバーです。 Bは、AのflowID = 5に応答して、識別子7からAへの戻りフローを開始します。 BはBのflowID = 7のフローセンダーであり、AはBのflowID = 7のフローレシーバーです。 Bは、flowIDを5に設定してこのオプションを送信し、BのflowID = 7がAのflowID = 5に応答して関連付けられていることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there is a return association, the flow sender MUST send this option with the first User Data chunk for this flow in each packet until an acknowledgement for this flow is received. A flow sender SHOULD NOT send this option more than once for each flow in any one packet. A flow sender SHOULD NOT send this option for a flow once the flow has been acknowledged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リターンアソシエーションがある場合、フロー送信者は、このフローの確認応答が受信されるまで、各パケットでこのフローの最初のユーザーデータチャンクとともにこのオプションを送信する必要があります。フローセンダーは、1つのパケットの各フローに対してこのオプションを複数回送信してはなりません（SHOULD NOT）。フローが確認されると、フロー送信者はフローに対してこのオプションを送信してはなりません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A flow MUST NOT indicate more than one return association.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローは、複数のリターンアソシエーションを示してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A flow MUST indicate its return association, if any, upon its first transmission of a User Data chunk. A return association can&#39;t be added to a sending flow after it begins.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローは、ユーザーデータチャンクの最初の送信時に、もしあれば、その関連付けを示す必要があります。リターンアソシエーションは、開始後に送信フローに追加することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A flow receiver MUST reject a new receiving flow having a return flow association that does not indicate an F_OPEN sending flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローレシーバーは、F_OPEN送信フローを示さないリターンフローアソシエーションを持つ新しい受信フローを拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-12--Next-User-Data-Chunk">
2.3.12. Next User Data Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.12. 次のユーザーデータチャンク
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is equivalent to the User Data chunk for purposes of sending the user messages of a flow. When used, it MUST follow a User Data chunk or another Next User Data chunk in the same packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、フローのユーザーメッセージを送信するためのユーザーデータチャンクに相当します。使用する場合、同じパケット内のユーザーデータチャンクまたは別の次のユーザーデータチャンクを追跡する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x11     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+
   |O|r| F | r |A|F|
   |P|s| R | s |B|I|
   |T|v| A | v |N|N|
   +-+-+-+-+-+-+-+-+
   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+-------------/-+
   | L \ T \   V   |... options ...| L \ T \   V   |       0     \ |
   \~~~/~~~/~~~~~~~+   [if(OPT)]   +~~~/~~~/~~~~~~~+-------------/-/
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                            userData                           |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nextUserDataChunkPayload_t
   {
       bool_t  optionsPresent :1;  // &#34;OPT&#34;
       uintn_t reserved1 :1;       // &#34;rsv&#34;
       uintn_t fragmentControl :2; // &#34;FRA&#34;
           // 0=whole, 1=begin, 2=end, 3=middle
       uintn_t reserved2 :2;       // &#34;rsv&#34;
       bool_t  abandon :1;         // &#34;ABN&#34;
       bool_t  final :1;           // &#34;FIN&#34;
       if(optionsPresent)
           optionList_t options :variable*8;
       uint8_t userData[remainder()];
   } :chunkLength*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is considered to be for the same flowID as the most recently preceding User Data or Next User Data chunk in the same packet, having the same Forward Sequence Number, and having the next sequence number. The optionsPresent, fragmentControl, abandon, and final flags, and the options (if present), have the same interpretation as for the User Data chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、同じパケット内の直前のユーザーデータチャンクまたは次のユーザーデータチャンクと同じflowIDで、同じ順方向シーケンス番号を持ち、次のシーケンス番号を持つものと見なされます。 optionsPresent、fragmentControl、abandon、finalフラグ、およびオプション（存在する場合）の解釈は、ユーザーデータチャンクの場合と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               ...
               ----------+------------------------------------
               10 00 07  | User Data chunk, length=7
               00        | OPT=0, FRA=0 &#34;whole&#34;, ABN=0, FIN=0
               02 05 03  | flowID=2, seq#=5, fsn=(5-3)=2
               00 01 02  | data 3 bytes: 00, 01, 02
               ----------+------------------------------------
               11 00 04  | Next User Data chunk,length=4
               00        | OPT=0, FRA=0 &#34;whole&#34;, ABN=0, FIN=0
                         | flowID=2, seq#=6, fsn=2
               03 04 05  | data 3 bytes: 03, 04, 05
               ----------+------------------------------------
               11 00 04  | Next User Data chunk, length=4
               00        | OPT=0, FRA=0 &#34;whole&#34;, ABN=0, FIN=0
                         | flowID=2, seq#=7, fsn=2
               06 07 08  | data 3 bytes: 06, 07, 08
               ----------+------------------------------------
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Figure 3: Sequential Messages in One Packet Using Next User Data
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
図3：次のユーザーデータを使用した1つのパケット内の順次メッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of Next User Data is detailed in Section 3.6.2.3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のユーザーデータの使用については、セクション3.6.2.3.2で詳しく説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-13--Data-Acknowledgement-Bitmap-Chunk-Bitmap-Ack">
2.3.13. Data Acknowledgement Bitmap Chunk (Bitmap Ack)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.13. データ確認ビットマップチャンク（ビットマップ確認）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent by the flow receiver to indicate to the flow sender the User Data fragment sequence numbers that have been received for one flow. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、フローレシーバーによって送信され、1つのフローで受信されたユーザーデータフラグメントシーケンス番号をフローセンダーに示します。確立されたセッションに属し、パケットモードが1または2のパケットでのみ許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow receiver can choose to acknowledge User Data with this chunk or with a Range Ack. It SHOULD choose whichever format has the most compact encoding of the sequence numbers received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローレシーバーは、このチャンクまたはRange Ackでユーザーデータを確認することを選択できます。受信したシーケンス番号の最もコンパクトなエンコーディングを持つフォーマットを選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x50     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-------------/-+-------------/-+
   |   flowID    \ |   bufAvail  \ |    cumAck   \ |
   +-------------/-+-------------/-+-------------/-+
   +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+
   |C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|
   |+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|
   |9|8|7|6|5|4|3|2|1|1|1|1|1|1|1|1|2|2|2|2|2|2|1|1| ....
   | | | | | | | | |7|6|5|4|3|2|1|0|5|4|3|2|1|0|9|8|
   +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct dataAckBitmapChunkPayload_t
   {
       vlu_t flowID :variable*8;
       vlu_t bufferBlocksAvailable :variable*8; // &#34;bufAvail&#34;
       vlu_t cumulativeAck :variable*8; // &#34;cumAck&#34;
       bufferBytesAvailable = bufferBlocksAvailable * 1024;
       acknowledge(0 through cumulativeAck);
       ackCursor = cumulativeAck + 1;
       while(remainder() &gt; 0)
       {
           for(bitPosition = 8; bitPosition &gt; 0; bitPosition--)
           {
               bool_t bit :1;
               if(bit)
                   acknowledge(ackCursor + bitPosition);
           }
           ackCursor += 8;
       }
   } :chunkLength*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flowID: VLU, the flow identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flowID：VLU、フロー識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bufferBlocksAvailable: VLU, the number of 1024-byte blocks of User Data that the receiver is currently able to accept. Section 3.6.3.5 describes how to calculate this value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bufferBlocksAvailable：VLU、受信者が現在受け入れることができるユーザーデータの1024バイトブロックの数。セクション3.6.3.5では、この値の計算方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cumulativeAck: VLU, the acknowledgement of every fragment sequence number in this flow that is less than or equal to this value. This MUST NOT be less than the highest Forward Sequence Number received in this flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
incrementalAck：VLU、この値以下のこのフロー内のすべてのフラグメントシーケンス番号の確認。これは、このフローで受信した最高の転送シーケンス番号よりも小さくてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bit field: A sequence of zero or more bytes representing a bit field of received fragment sequence numbers after the cumulative acknowledgement, least significant bit first. A set bit indicates receipt of a sequence number. A clear bit indicates that sequence number was not received. The least significant bit of the first byte is the second sequence number following the cumulative acknowledgement, the next bit is the third sequence number following, and so on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビットフィールド：累積確認応答後の受信フラグメントシーケンス番号のビットフィールドを表す0バイト以上のシーケンス。最下位ビットが最初。セットビットはシーケンス番号の受信を示します。クリアビットは、シーケンス番号が受信されなかったことを示します。最初のバイトの最下位ビットは、累積確認応答に続く2番目のシーケンス番号、次のビットは、それに続く3番目のシーケンス番号です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 4 shows an example Bitmap Ack indicating acknowledgement of fragment sequence numbers 0 through 16, 18, 21 through 24, 27, and 28.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
図4は、フラグメントシーケンス番号0〜16、18、21〜24、27、28の確認応答を示すビットマップAckの例を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         50 00 05  | Bitmap Ack, length=5 bytes
         05 7f 10  | flowID=5, bufAvail=127*1024 bytes, cumAck=0..16
         79 06     | 01111001 00000110 = 18, 21, 22, 23, 24, 27, 28
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
Figure 4: Example Bitmap Ack
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
図4：ビットマップ確認の例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-14--Data-Acknowledgement-Ranges-Chunk-Range-Ack">
2.3.14. Data Acknowledgement Ranges Chunk (Range Ack)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.14. データ確認範囲チャンク（範囲確認）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent by the flow receiver to indicate to the flow sender the User Data fragment sequence numbers that have been received for one flow. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、フローレシーバーによって送信され、1つのフローで受信されたユーザーデータフラグメントシーケンス番号をフローセンダーに示します。確立されたセッションに属し、パケットモードが1または2のパケットでのみ許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow receiver can choose to acknowledge User Data with this chunk or with a Bitmap Ack. It SHOULD choose whichever format has the most compact encoding of the sequence numbers received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローレシーバーは、このチャンクまたはビットマップACKでユーザーデータを確認することを選択できます。受信したシーケンス番号の最もコンパクトなエンコーディングを持つフォーマットを選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x51     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-------------/-+-------------/-+
   |   flowID    \ |   bufAvail  \ |    cumAck   \ |
   +-------------/-+-------------/-+-------------/-+
   +~~~~~~~~~~~~~/~+~~~~~~~~~~~~~/~+
   |   #holes-1  \ |   #recv-1   \ |
   +~~~~~~~~~~~~~/~+~~~~~~~~~~~~~/~+
                   :
                   :
   +~~~~~~~~~~~~~/~+~~~~~~~~~~~~~/~+
   |   #holes-1  \ |   #recv-1   \ |
   +~~~~~~~~~~~~~/~+~~~~~~~~~~~~~/~+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct dataAckRangesChunkPayload_t
   {
       vlu_t flowID :variable*8;
       vlu_t bufferBlocksAvailable :variable*8; // &#34;bufAvail&#34;
       vlu_t cumulativeAck :variable*8; // &#34;cumAck&#34;
       bufferBytesAvailable = bufferBlocksAvailable * 1024;
       acknowledge(0 through cumulativeAck);
       ackCursor = cumulativeAck;
       while(remainder() &gt; 0)
       {
           vlu_t holesMinusOne :variable*8; // &#34;#holes-1&#34;
           vlu_t receivedMinusOne :variable*8; // &#34;#recv-1&#34;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           ackCursor++;
           rangeFrom = ackCursor + holesMinusOne + 1;
           rangeTo = rangeFrom + receivedMinusOne;
           acknowledge(rangeFrom through rangeTo);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           ackCursor = rangeTo;
       }
   } :chunkLength*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flowID: VLU, the flow identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flowID：VLU、フロー識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bufferBlocksAvailable: VLU, the number of 1024-byte blocks of User Data that the receiver is currently able to accept. Section 3.6.3.5 describes how to calculate this value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bufferBlocksAvailable：VLU、受信者が現在受け入れることができるユーザーデータの1024バイトブロックの数。セクション3.6.3.5では、この値の計算方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cumulativeAck: VLU, the acknowledgement of every fragment sequence number in this flow that is less than or equal to this value. This MUST NOT be less than the highest Forward Sequence Number received in this flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
incrementalAck：VLU、この値以下のこのフロー内のすべてのフラグメントシーケンス番号の確認。これは、このフローで受信した最高の転送シーケンス番号よりも小さくてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
holesMinusOne / receivedMinusOne: Zero or more acknowledgement ranges, run-length encoded. Runs are encoded as zero or more pairs of VLUs indicating the number (minus one) of missing sequence numbers followed by the number (minus one) of received sequence numbers, starting at the cumulative acknowledgement. NOTE: If a parser syntax error is encountered here (that is, if the chunk is truncated such that not enough bytes remain to completely encode both VLUs of the acknowledgement range), then treat and process this chunk as though it was properly formed up to the last completely encoded range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
holesMinusOne / receivedMinusOne：ゼロ以上の確認応答範囲、ランレングスエンコード。実行は、欠落したシーケンス番号の数（マイナス1）に続いて、受信したシーケンス番号の数（マイナス1）を示すVLUのゼロ以上のペアとしてエンコードされ、累積確認から始まります。注：パーサー構文エラーがここで発生した場合（つまり、確認応答範囲の両方のVLUを完全にエンコードするのに十分なバイトが残っていないようにチャンクが切り捨てられた場合）、このチャンクが正しく形成されたかのように扱い、処理最後の完全にエンコードされた範囲。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 5 shows an example Range Ack indicating acknowledgement of fragment sequence numbers 0 through 16, 18, 21, 22, 23, and 24.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
図5は、フラグメントシーケンス番号0〜16、18、21、22、23、および24の確認応答を示すRange Ackの例を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      51 00 07  | Range Ack, length=7
      05 7f 10  | flowID=5, bufAvail=127*1024 bytes, cumAck=0..16
      00 00     | holes=1, received=1 -- missing 17, received 18
      01 03     | holes=2, received=4 -- missing 19..20, received 21..24
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
Figure 5: Example Range Ack
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
図5：範囲確認の例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 6 shows an example Range Ack indicating acknowledgement of fragment sequence numbers 0 through 16 and 18, with a truncated last range. Note that the truncation and parse error does not abort the entire chunk in this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
図6は、最後の範囲が切り捨てられたフラグメントシーケンス番号0〜16および18の確認応答を示す範囲ACKの例を示しています。この場合、切り捨てと解析のエラーはチャンク全体を中止しないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       51 00 07  | Range Ack, length=9
       05 7f 10  | flowID=5, bufAvail=127*1024 bytes, cumAck=0..16
       00 00     | holes=1, received=1 -- missing 17, received 18
       01 83     | holes=2, received=VLU parse error, ignore this range
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
Figure 6: Example Truncated Range Ack
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
図6：切り捨てられた範囲の確認の例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-15--Buffer-Probe-Chunk">
2.3.15. Buffer Probe Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.15. バッファプローブチャンク
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent by the flow sender in order to request the current available receive buffer (in the form of a Data Acknowledgement) for a flow. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、フローの現在利用可能な受信バッファー（データ確認応答の形式）を要求するために、フローセンダーによって送信されます。確立されたセッションに属し、パケットモードが1または2のパケットでのみ許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x18     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+
   |   flowID    \ |
   +-------------/-+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct bufferProbeChunkPayload_t
   {
       vlu_t flowID :variable*8;
   } :chunkLength*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flowID: VLU, the flow identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flowID：VLU、フロー識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receiver of this chunk SHOULD reply as immediately as is practical with a Data Acknowledgement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクの受信者は、データ確認応答を使用して、できるだけ早く応答する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-16--Flow-Exception-Report-Chunk">
2.3.16. Flow Exception Report Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.16. フロー例外レポートチャンク
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent by the flow receiver to indicate that it is not (or is no longer) interested in the flow and would like the flow sender to close the flow. This chunk SHOULD precede every Data Acknowledgement chunk for the same flow in this condition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、フローレシーバーによって送信されます。これは、フローに関心がなく（またはもはや関心がない）、フローセンダーにフローを閉じてもらいたいことを示します。このチャンクは、この状態の同じフローのすべてのデータ確認チャンクに先行する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is only allowed in a packet belonging to an established session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、確立されたセッションに属し、パケットモード1または2を持つパケットでのみ許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x5e     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-------------/-+
   |   flowID    \ |  exception  \ |
   +-------------/-+-------------/-+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct flowExceptionReportChunkPayload_t
   {
       vlu_t flowID :variable*8;
       vlu_t exception :variable*8;
   } :chunkLength*8;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flowID: VLU, the flow identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flowID：VLU、フロー識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
exception: VLU, the application-defined exception code being reported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例外：VLU、報告されているアプリケーション定義の例外コード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiving RTMFP might reject a flow automatically, for example if it is missing metadata, or if an invalid return association is specified. In circumstances where an RTMFP rejects a flow automatically, the exception code MUST be 0. The application can specify any exception code, including 0, when rejecting a flow. All non-zero exception codes are reserved for the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータが欠落している場合や、無効な戻り関連付けが指定されている場合など、受信RTMFPはフローを自動的に拒否する場合があります。 RTMFPがフローを自動的に拒否する状況では、例外コードは0である必要があります。アプリケーションは、フローを拒否するときに、0を含む任意の例外コードを指定できます。ゼロ以外のすべての例外コードは、アプリケーション用に予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-17--Session-Close-Request-Chunk-Close">
2.3.17. Session Close Request Chunk (Close)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.17. セッションクローズリクエストチャンク（クローズ）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent to cleanly terminate a session. It is only allowed in a packet belonging to an established or closing session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、セッションを完全に終了するために送信されます。これは、確立済みまたはクローズセッションに属し、パケットモード1または2を持つパケットでのみ許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x0c     |               0               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk has no payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクにはペイロードがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of Close is detailed in Section 3.5.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of Close is detailed in Section 3.5.5.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-18--Session-Close-Acknowledgement-Chunk-Close-Ack">
2.3.18. Session Close Acknowledgement Chunk (Close Ack)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.18. セッション終了確認チャンク（終了確認）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent in response to a Session Close Request to indicate that the sender has terminated the session. It is only allowed in a packet belonging to an established or closing session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、送信者がセッションを終了したことを示すために、Session Close Requestへの応答として送信されます。これは、確立済みまたはクローズセッションに属し、パケットモード1または2を持つパケットでのみ許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x4c     |               0               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk has no payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクにはペイロードがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of Close Ack is detailed in Section 3.5.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Close Ackの使用については、セクション3.5.5で詳しく説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Operation">
3. Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 操作
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Overview">
3.1. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 概観
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              +--------+                             +--------+
              | Peer A |        S E S S I O N        | Peer B |
              |        /=============================\        |
              |       ||            Flows            ||       |
              |       ||----------------------------&gt;||       |
              |       ||----------------------------&gt;||       |
              |       ||&lt;----------------------------||       |
              |       ||&lt;----------------------------||       |
              |       ||&lt;----------------------------||       |
              |        \=============================/        |
              |        |                             |        |
              |        |                             +--------+
              |        |
              |        |                             +--------+
              |        |        S E S S I O N        | Peer C |
              |        /=============================\        |
              |       ||            Flows            ||       |
              |       ||----------------------------&gt;||       |
              |       ||&lt;----------------------------||       |
              |       ||&lt;----------------------------||       |
              |        \=============================/        |
              |        |                             |        |
              +--------+                             +--------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Figure 7: Sessions between Pairs of Communicating Endpoints
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
図7：通信するエンドポイントのペア間のセッション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Between any pair of communicating endpoints is a single, bidirectional, secured, congestion controlled session. Unidirectional flows convey messages from one end to the other within the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通信するエンドポイントのペアの間には、単一の双方向の安全な輻輳制御セッションがあります。単方向フローは、セッション内でメッセージを一方の端から他方の端に伝達します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint initiates a session to a far end when communication is desired. An initiator begins with one or more candidate destination socket addresses, and it may learn and try more candidate addresses during startup handshaking. Eventually, a first suitable response is received, and that endpoint is selected. Startup proceeds to the selected endpoint. In the case of session startup glare, one endpoint is the prevailing initiator and the other assumes the role of responder. Encryption keys and session identifiers are negotiated between the endpoints, and the session is established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通信が必要な場合、エンドポイントは遠端へのセッションを開始します。イニシエーターは、1つまたは複数の候補宛先ソケットアドレスで始まり、スタートアップハンドシェイク中に、より多くの候補アドレスを学習して試行する場合があります。最終的に、最初の適切な応答が受信され、そのエンドポイントが選択されます。起動は選択したエンドポイントに進みます。セッションの開始グレアの場合、1つのエンドポイントが優勢なイニシエーターであり、もう1つのエンドポイントはレスポンダーの役割を担います。暗号化キーとセッション識別子がエンドポイント間でネゴシエートされ、セッションが確立されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Each endpoint may begin sending message flows to the other end. For each flow, the far end may accept it and deliver its messages to the user, or it may reject the flow and transmit an exception to the sender. The flow receiver may close and reject a flow at a later time, after first accepting it. The flow receiver acknowledges all data sent to it, regardless of whether the flow was accepted. Acknowledgements drive a congestion control mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Each endpoint may begin sending message flows to the other end. For each flow, the far end may accept it and deliver its messages to the user, or it may reject the flow and transmit an exception to the sender. The flow receiver may close and reject a flow at a later time, after first accepting it. The flow receiver acknowledges all data sent to it, regardless of whether the flow was accepted. Acknowledgements drive a congestion control mechanism.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint may have concurrent sessions with other far endpoints. The multiple sessions are distinguished by a session identifier rather than by socket address. This allows an endpoint&#39;s address to change mid-session without having to tear down and re-establish a session. The existing cryptographic state for a session can be used to verify a change of address while protecting against session hijacking or denial of service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントには、他の遠いエンドポイントとの同時セッションがある場合があります。複数のセッションは、ソケットアドレスではなくセッション識別子によって区別されます。これにより、セッションを破棄して再確立する必要なしに、エンドポイントのアドレスをセッションの途中で変更できます。セッションの既存の暗号化状態を使用して、セッションのハイジャックまたはサービス拒否から保護しながら、アドレスの変更を確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender may indicate to a receiver that some user messages are of a time critical or real-time nature. A receiver may indicate to senders on concurrent sessions that it is receiving time critical messages from another endpoint. The other senders SHOULD modify their congestion control parameters to yield capacity to the session carrying time critical messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は、一部のユーザーメッセージがタイムクリティカルまたはリアルタイムの性質であることを受信者に示す場合があります。受信者は、別のエンドポイントからタイムクリティカルなメッセージを受信して​​いることを同時セッションの送信者に示す場合があります。他の送信者は、輻輳制御パラメータを変更して、タイムクリティカルなメッセージを運ぶセッションに容量を与える必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender may close a flow. The flow is completed when the receiver has no outstanding gaps before the final fragment of the flow. The sender and receiver reserve a completed flow&#39;s identifier for a time to allow in-flight messages to drain from the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者はフローを閉じます。フローの最後のフラグメントの前にレシーバーに未処理のギャップがない場合、フローは完了します。送信者と受信者は、完了したフローの識別子を一定時間予約して、処理中のメッセージをネットワークから排出できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Eventually, neither end will have any flows open to the other. The session will be idle and quiescent. Either end may reliably close the session to recover its resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最終的に、どちらの端も、もう一方に開かれたフローを持ちません。セッションはアイドル状態で静止します。どちらの側も、確実にセッションを閉じてリソースを回復します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In certain circumstances, an endpoint may be ceasing operation and not have time to wait for acknowledgement of a reliable session close. In this case, the halting endpoint may send an abrupt session close to advise the far end that it is halting immediately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定の状況では、エンドポイントが操作を停止していて、信頼できるセッションの終了の確認を待つ時間がない場合があります。この場合、停止しているエンドポイントは突然セッションを送信して、遠端にすぐに停止していることを通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--Endpoint-Identity">
3.2. Endpoint Identity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. エンドポイントID
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each RTMFP endpoint has an identity. The identity is encoded in a certificate. This specification doesn&#39;t mandate any particular certificate format, cryptographic algorithms, or cryptographic properties for certificates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each RTMFP endpoint has an identity. The identity is encoded in a certificate. This specification doesn&#39;t mandate any particular certificate format, cryptographic algorithms, or cryptographic properties for certificates.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint is named by an Endpoint Discriminator. This specification doesn&#39;t mandate any particular format for Endpoint Discriminators.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、Endpoint Discriminatorによって命名されます。この仕様では、Endpoint Discriminatorsの特定の形式を義務付けていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Endpoint Discriminator MAY select more than one identity and MAY match more than one distinct certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoint Discriminatorは、複数のIDを選択する場合があり、複数の異なる証明書と一致する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiple distinct Endpoint Discriminators MAY match one certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数の異なるエンドポイント識別子が1つの証明書と一致する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is RECOMMENDED that multiple endpoints not have the same identity. Entities with the same identity are indistinguishable during session startup; this situation could be undesirable in some applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のエンドポイントが同じIDを持たないことをお勧めします。同じIDを持つエンティティは、セッションの起動時に区別できません。この状況は、一部のアプリケーションでは望ましくない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint MAY have more than one address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint MAY have more than one address.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Cryptography Profile implements the following functions for identities, certificates, and Endpoint Discriminators, whose operation MUST be deterministic:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化プロファイルは、操作が確定的でなければならないID、証明書、およびエンドポイントディスクリミネーター用の次の関数を実装します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Test whether a given certificate is authentic. Authenticity can comprise verifying an issuer signature chain in a public key infrastructure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Test whether a given certificate is authentic. Authenticity can comprise verifying an issuer signature chain in a public key infrastructure.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Test whether a given Endpoint Discriminator selects a given certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 特定のEndpoint Discriminatorが特定の証明書を選択するかどうかをテストします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Test whether a given Endpoint Discriminator selects the local endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 指定されたEndpoint Discriminatorがローカルエンドポイントを選択するかどうかをテストします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Generate a Canonical Endpoint Discriminator for a given certificate. Canonical Endpoint Discriminators for distinct identities SHOULD be distinct. If two distinct identities have the same Canonical Endpoint Discriminator, an initiator might abort a new opening session to the second identity (Section 3.5.1.1.1); this behavior might not be desirable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 指定された証明書のCanonical Endpoint Discriminatorを生成します。個別のアイデンティティの正規のエンドポイント弁別子は個別である必要があります。 2つの異なるIDが同じCanonical Endpoint Discriminatorを持つ場合、イニシエーターは2番目のIDへの新しいオープニングセッションを中止する場合があります（セクション3.5.1.1.1）。この動作は望ましくない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Given a certificate, a message, and a digital signature over the message, test whether the signature is valid and generated by the owner of the certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 証明書、メッセージ、およびメッセージに対するデジタル署名を指定して、署名が有効であり、証明書の所有者によって生成されたかどうかをテストします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Generate a digital signature for a given message corresponding to the near identity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 近いアイデンティティに対応する特定のメッセージのデジタル署名を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Given the near identity and a far certificate, determine which one shall prevail as Initiator and which shall assume the Responder role in the case of startup glare. The far end MUST arrive at the same conclusion. A comparison function can comprise performing a lexicographic ordering of the binary certificates, declaring the far identity the prevailing endpoint if the far certificate is ordered before the near certificate, and otherwise declaring the near identity to be the prevailing endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 近い身元と遠い証明書を考慮して、どれがイニシエーターとして勝ち、どれが起動時のまぶしさの場合にレスポンダーの役割を担うかを決定します。遠端も同じ結論に達しなければなりません。比較機能は、バイナリ証明書の辞書式順序の実行、遠い証明書が近い証明書の前に並べられている場合は、遠いIDを優勢なエンドポイントとして宣言し、そうでない場合は、近しいアイデンティティを優勢なエンドポイントとして宣言することを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Given a first certificate and a second certificate, test whether a new incoming session from the second shall override an existing session with the first. It is RECOMMENDED that the test comprise testing whether the certificates are bitwise identical.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 最初の証明書と2番目の証明書が与えられたら、2番目からの新しい着信セッションが1番目の既存のセッションをオーバーライドするかどうかをテストします。テストは、証明書がビットごとに同一であるかどうかをテストすることからなることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All other semantics for certificates and Endpoint Discriminators are determined by the Cryptography Profile and the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書およびエンドポイント識別子のその他すべてのセマンティクスは、暗号化プロファイルとアプリケーションによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--Packet-Multiplex">
3.3. Packet Multiplex
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. パケット多重
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An RTMFP typically has one or more interfaces through which it communicates with other RTMFP endpoints. RTMFP can communicate with multiple distinct other RTMFP endpoints through each local interface. Session multiplexing over a shared interface can facilitate peer-to-peer communications through a NAT, by enabling third-party endpoints such as Forwarders (Section 3.5.1.5) and Redirectors (Section 3.5.1.4) to observe the translated public address and inform peers of the translation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPには通常、他のRTMFPエンドポイントと通信するための1つ以上のインターフェースがあります。 RTMFPは、各ローカルインターフェイスを介して、他の複数のRTMFPエンドポイントと通信できます。共有インターフェースを介したセッションの多重化により、フォワーダー（セクション3.5.1.5）やリダイレクター（セクション3.5.1.4）などのサードパーティエンドポイントが変換されたパブリックアドレスを監視し、ピアに通知することで、NATを介したピアツーピア通信が容易になります。翻訳の。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An interface is typically a UDP socket (Section 2.2.1) but MAY be any suitable datagram transport service where endpoints can be addressed by IPv4 or IPv6 socket addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インターフェースは通常UDPソケット（セクション2.2.1）ですが、エンドポイントがIPv4またはIPv6ソケットアドレスでアドレス指定できる任意の適切なデータグラムトランスポートサービスである場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP uses a session ID to multiplex and demultiplex communications with distinct endpoints (Section 2.2.2), in addition to the endpoint socket address. This allows an RTMFP to detect a far-end address change (as might happen, for example, in mobile and wireless scenarios) and allows communication sessions to survive address changes. This also allows an RTMFP to act as a Forwarder or Redirector for an endpoint with which it has an active session, by distinguishing startup packets from those of the active session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP uses a session ID to multiplex and demultiplex communications with distinct endpoints (Section 2.2.2), in addition to the endpoint socket address. This allows an RTMFP to detect a far-end address change (as might happen, for example, in mobile and wireless scenarios) and allows communication sessions to survive address changes. This also allows an RTMFP to act as a Forwarder or Redirector for an endpoint with which it has an active session, by distinguishing startup packets from those of the active session.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receiving a packet, an RTMFP decodes the session ID to look up the corresponding session information context and decryption key. Session ID 0 is reserved for session startup and MUST NOT be used for an active session. A packet for Session ID 0 uses the Default Session Key as defined by the Cryptography Profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットを受信すると、RTMFPはセッションIDをデコードして、対応するセッション情報コンテキストと復号化キーを検索します。セッションID 0はセッションの起動用に予約されており、アクティブなセッションで使用してはなりません。セッションID 0のパケットは、暗号化プロファイルで定義されているデフォルトセッションキーを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-4--Packet-Fragmentation">
3.4. Packet Fragmentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. パケットの断片化
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an RTMFP packet (Section 2.2.4) is unavoidably larger than the path MTU (such as a startup packet containing an RHello (Section 2.3.4) or IIKeying (Section 2.3.7) chunk with a large certificate), it can be fragmented into segments that do not exceed the path MTU by using the Packet Fragment chunk (Section 2.3.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPパケット（セクション2.2.4）がパスMTU（RHello（セクション2.3.4）またはIIKeying（セクション2.3.7）チャンクと大きな証明書を含むスタートアップパケット）よりも不可避的に大きい場合、パケットフラグメントチャンクを使用して、パスMTUを超えないセグメントにフラグメント化されます（セクション2.3.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The packet fragmentation mechanism SHOULD be used only to segment unavoidably large packets. Accordingly, this mechanism SHOULD be employed only during session startup with Session ID 0. This mechanism MUST NOT be used instead of the natural fragmentation mechanism of the User Data (Section 2.3.11) and Next User Data (Section 2.3.12) chunks for dividing the messages of the user&#39;s data flows into segments that do not exceed the path MTU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット断片化メカニズムは、避けられないほど大きなパケットをセグメント化するためにのみ使用されるべきです（SHOULD）。したがって、このメカニズムは、セッションID 0のセッション起動時にのみ使用する必要があります。このメカニズムは、ユーザーデータ（セクション2.3.11）および次のユーザーデータ（セクション2.3.12）チャンクの自然な断片化メカニズムの代わりに使用してはなりません（MUST NOT）。ユーザーのデータフローのメッセージを、パスMTUを超えないセグメントに分割します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A fragmented plain RTMFP packet is reassembled by concatenating the packetFragment fields of the fragments for the packet in contiguous ascending order, starting from index 0 through and including the final fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメント化されたプレーンなRTMFPパケットは、パケットのフラグメントのpacketFragmentフィールドを、インデックス0から始まり、最後のフラグメントを含む連続した昇順で連結することによって再構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When reassembling packets for Session ID 0, a receiver SHOULD identify the packets by the socket address from which the packet containing the fragment was received, as well as the indicated packetID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When reassembling packets for Session ID 0, a receiver SHOULD identify the packets by the socket address from which the packet containing the fragment was received, as well as the indicated packetID.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiver SHOULD allow up to 60 seconds to completely receive a fragmented packet for which progress is being made. A packet is progressing if at least one new fragment for it was received in the last second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiver SHOULD allow up to 60 seconds to completely receive a fragmented packet for which progress is being made. A packet is progressing if at least one new fragment for it was received in the last second.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiver MUST discard a Packet Fragment chunk having an empty packetFragment field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レシーバーは、packetFragmentフィールドが空のパケットフラグメントチャンクを破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mode of each packet containing Packet Fragments for the same fragmented packet MUST match the mode of the fragmented packet. A receiver MUST discard any new Packet Fragment chunk received in a packet with a mode different from the mode of the packet containing the first received fragment. A receiver MUST discard any reassembled packet with a mode different than the packets containing its fragments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じフラグメント化されたパケットのパケットフラグメントを含む各パケットのモードは、フラグメント化されたパケットのモードと一致する必要があります。レシーバーは、最初に受信したフラグメントを含むパケットのモードとは異なるモードのパケットで受信した新しいパケットフラグメントチャンクを破棄しなければなりません（MUST）。受信者は、フラグメントを含むパケットとは異なるモードで再構成されたパケットを破棄しなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to avoid jamming the network, the sender MUST rate limit packet transmission. In the absence of specific path capacity information (for instance, during session startup), a sender SHOULD NOT send more than 4380 bytes nor more than four packets per distinct endpoint every 200 ms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークの妨害を回避するために、送信者はパケット送信をレート制限しなければなりません（MUST）。特定のパスキャパシティ情報がない場合（たとえば、セッションの起動時）、送信者は、200ミリ秒ごとに異なるエンドポイントごとに4380バイトを超えるパケットも4つを超えるパケットも送信してはなりません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 To avoid resource exhaustion, a receiver SHOULD limit the number of concurrent packet reassembly buffers and the size of each buffer. Limits can depend, for example, on the expected size of reassembled packets, on the rate at which fragmented packets are expected to be received, on the expected degree of interleaving, and on the expected function of the receiver. Limits can depend on the available resources of the receiver. There can be different limits for packets with Session ID 0 and packets for established sessions. For example, a busy server might need to allow for several hundred concurrent packet reassembly buffers to accommodate hundreds of connection requests per second with potentially interleaved fragments, but a client device with constrained resources could allow just a few reassembly buffers. In the absence of specific information regarding the expected size of reassembled packets, a receiver should set the limit for each packet reassembly buffer to 65536 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
リソースの枯渇を回避するために、受信者は、同時パケット再構成バッファーの数と各バッファーのサイズを制限する必要があります（SHOULD）。制限は、たとえば、再構成されたパケットの予想されるサイズ、断片化されたパケットが受信されると予想されるレート、予想されるインターリーブの程度、および受信機の予想される機能に依存します。制限は、レシーバーの使用可能なリソースによって異なります。セッションID 0のパケットと確立されたセッションのパケットには、異なる制限がある場合があります。たとえば、ビジー状態のサーバーでは、インターリーブされる可能性のあるフラグメントで1秒あたり数百の接続要求に対応するために、数百の同時パケット再構成バッファーを許可する必要があるかもしれませんが、リソースが制限されているクライアントデバイスでは、再構成バッファーが少数しか許可されない場合があります。再構成されたパケットの予想サイズに関する特定の情報がない場合、受信者は各パケット再構成バッファの制限を65536バイトに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5--Sessions">
3.5. Sessions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. セッション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A session is the protocol relationship between a pair of communicating endpoints, comprising the shared and endpoint-specific information context necessary to carry out the communication. The session context at each end includes at least:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションは、通信するエンドポイントのペア間のプロトコル関係であり、通信を実行するために必要な共有されたエンドポイント固有の情報コンテキストを含みます。両端のセッションコンテキストには、少なくとも次のものが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TS_RX: the last timestamp received from the far end;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TS_RX：遠端から受信した最後のタイムスタンプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TS_RX_TIME: the time at which TS_RX was first observed to be different than its previous value;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TS_RX_TIME：TS_RXが最初に以前の値と異なることが観測された時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TS_ECHO_TX: the last timestamp echo sent to the far end;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TS_ECHO_TX：遠端に送信された最後のタイムスタンプエコー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MRTO: the measured retransmission timeout;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MRTO：測定された再送信タイムアウト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ERTO: the effective retransmission timeout;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ERTO：有効な再送信タイムアウト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Cryptographic keys for encrypting and decrypting packets, and for verifying the validity of packets, according to the Cryptography Profile;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 暗号化プロファイルに従って、パケットの暗号化と復号化、およびパケットの有効性を検証するための暗号化キー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Cryptographic near and far nonces according to the Cryptography Profile, where the near nonce is the far end&#39;s far nonce, and vice versa;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Cryptography Profileに準拠した暗号の近距離および遠距離ノンス。ここで近距離ノンスは遠端の遠距離ノンスであり、逆も同様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The certificate of the far end;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 遠端の証明書。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The receive session identifier, used by the far end when sending packets to this end;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o パケットをこの端に送信するときに遠端で使用される受信セッション識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The send session identifier to use when sending packets to the far end;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 遠端にパケットを送信するときに使用する送信セッション識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DESTADDR: the destination socket address to use when sending packets to the far end;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DESTADDR：パケットを遠端に送信するときに使用する宛先ソケットアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The set of all sending flow contexts (Section 3.6.2);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o すべての送信フローコンテキストのセット（セクション3.6.2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The set of all receiving flow contexts (Section 3.6.3);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o すべての受信フローコンテキストのセット（セクション3.6.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The transmission budget, which controls the rate at which data is sent into the network (for example, a congestion window);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o データがネットワークに送信される速度を制御する送信バジェット（たとえば、輻輳ウィンドウ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o S_OUTSTANDING_BYTES: the total amount of user message data outstanding, or in flight, in the network -- that is, the sum of the F_OUTSTANDING_BYTES of each sending flow in the session;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o S_OUTSTANDING_BYTES：ネットワークで未処理の、または処理中のユーザーメッセージデータの合計量。つまり、セッションの各送信フローのF_OUTSTANDING_BYTESの合計。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RX_DATA_PACKETS: a count of the number of received packets containing at least one User Data chunk since the last acknowledgement was sent, initially 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RX_DATA_PACKETS：最後の確認応答が送信されてから少なくとも1つのユーザーデータチャンクを含む受信パケット数のカウント、最初は0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ACK_NOW: a boolean flag indicating whether an acknowledgement should be sent immediately, initially false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ACK_NOW：肯定応答をすぐに送信するかどうかを示すブールフラグ。最初はfalse。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DELACK_ALARM: an alarm to trigger an acknowledgement after a delay, initially unset;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DELACK_ALARM：遅延後に確認応答をトリガーするアラーム。最初は設定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The state, at any time being one of the following values: the opening states S_IHELLO_SENT and S_KEYING_SENT, the open state S_OPEN, the closing states S_NEARCLOSE and S_FARCLOSE_LINGER, and the closed states S_CLOSED and S_OPEN_FAILED; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o いつでも次のいずれかの値である状態：開始状態S_IHELLO_SENTおよびS_KEYING_SENT、オープン状態S_OPEN、終了状態S_NEARCLOSEおよびS_FARCLOSE_LINGER、およびクローズ状態S_CLOSEDおよびS_OPEN_FAILED。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The role -- either Initiator or Responder -- of this end of the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セッションのこの終わりの役割（開始者または応答者）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: The following diagram is only a summary of state transitions and their causing events, and is not a complete operational specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：以下の図は、状態遷移とその原因となるイベントの要約にすぎず、完全な運用仕様ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          rcv IIKeying Glare
          far prevails +-------------+   ultimate open timeout
        +--------------|S_IHELLO_SENT|-------------+
        |              +-------------+             |
        |                     |rcv RHello          |
        |                     |                    v
        |                     v             +-------------+
        |&lt;-----------(duplicate session?)   |S_OPEN_FAILED|
        |         yes         |no           +-------------+
        |                     |                    ^
        | rcv IIKeying Glare  v                    |
        | far prevails +-------------+             |
        |&lt;-------------|S_KEYING_SENT|-------------+
        |              +-------------+   ultimate open timeout
        |                     |rcv RIKeying
        |                     |
        |       rcv           v
        |   +-+ IIKeying  +--------+ rcv Close Request
        |   |X|----------&gt;| S_OPEN |--------------------+
        |   +-+           +--------+                    |
        |                   |    |ABRUPT CLOSE          |
        |      ORDERLY CLOSE|    |or rcv Close Ack      |
        |                   |    |or rcv IIKeying       |
        |                   |    |   session override   |
        |                   |    +-------+              |
        |                   v            |              v
        |             +-----------+      |     +-----------------+
        |             |S_NEARCLOSE|      |     |S_FARCLOSE_LINGER|
        |             +-----------+      |     +-----------------+
        |      rcv Close Ack|            |              |rcv Close Ack
        |      or 90 seconds|            v              |or 19 seconds
        |                   |       +--------+          |
        |                   +------&gt;|S_CLOSED|&lt;---------+
        +--------------------------&gt;|        |
                                    +--------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
Figure 8: Session State Diagram
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
図8：セッション状態図
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-1--Startup">
3.5.1. Startup
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1. 起動
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-1-1--Normal-Handshake">
3.5.1.1. Normal Handshake
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.1. 通常のハンドシェイク
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP sessions are established with a 4-way handshake in two round trips. The initiator begins by sending an IHello to one or more candidate addresses for the desired destination endpoint. A responder statelessly sends an RHello in response. The first correct RHello received at the initiator is selected; all others are ignored. The initiator computes its half of the session keying and sends an IIKeying. The responder receives the IIKeying and, if it is acceptable, computes its half of the session keying, at which point it can also compute the shared session keying and session nonces. The responder creates a new S_OPEN session with the initiator and sends an RIKeying. The initiator receives the RIKeying and, if it is acceptable, computes the shared session keying and session nonces. The initiator&#39;s session is now S_OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPセッションは、2往復の4ウェイハンドシェイクで確立されます。イニシエーターは、目的の宛先エンドポイントの1つ以上の候補アドレスにIHelloを送信することから始めます。レスポンダは、応答としてRHelloをステートレスに送信します。イニシエーターで受信された最初の正しいRHelloが選択されます。他のすべては無視されます。イニシエーターはセッションキーイングの半分を計算し、IIKeyingを送信します。レスポンダはIIKeyingを受信し、許容できる場合はセッションキーイングの半分を計算します。その時点で、共有セッションキーイングとセッションナンスも計算できます。レスポンダは、イニシエータとの新しいS_OPENセッションを作成し、RIKeyingを送信します。イニシエーターはRIKeyingを受信し、受け入れ可能な場合は、共有セッションキーイングとセッションナンスを計算します。イニシエーターのセッションはS_OPENです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        .     Initiator                                Responder     .
                      | IHello                         |
                      |(EPD,Tag)                       |
        S_IHELLO_SENT |(SID=0)                         |
                      |-------------------------------&gt;|
                      |                                |
                      |                         RHello |
                      |              (Tag,Cookie,RCert)|
                      |                         (SID=0)|
                      |&lt;-------------------------------|
        S_KEYING_SENT |                                |
                      | IIKeying                       |
                      |(ISID,Cookie,ICert,SKIC,ISig)   |
                      |(SID=0)                         |
                      |-------------------------------&gt;|
                      |                                |
                      |                       RIKeying |
                      |                (RSID,SKRC,RSig)|
                      |          (SID=ISID,Key=Default)| S_OPEN
                      |&lt;-------------------------------|
               S_OPEN |                                |
                      |          S E S S I O N         |
                      |&lt;-------------------(SID=ISID)--|
                      |--(SID=RSID)-------------------&gt;|
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
Figure 9: Normal Handshake
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
図9：通常のハンドシェイク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following sections, the handshake is detailed from the perspectives of the initiator and responder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクションでは、イニシエーターとレスポンダーの観点から、ハンドシェイクについて詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-1-1-1--Initiator">
3.5.1.1.1. Initiator
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.1.1. イニシエータ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initiator determines that a session is needed for an Endpoint Discriminator. The initiator creates state for a new opening session and begins with a candidate endpoint address set containing at least one address. The new session is placed in the S_IHELLO_SENT state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエーターは、エンドポイント識別子にセッションが必要であると判断します。イニシエーターは、新しいオープニングセッションの状態を作成し、少なくとも1つのアドレスを含む候補エンドポイントアドレスセットで開始します。新しいセッションはS_IHELLO_SENT状態になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the session does not move to the S_OPEN state before an ultimate open timeout, the session has failed and moves to the S_OPEN_FAILED state. The RECOMMENDED ultimate open timeout is 95 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最終的なオープンタイムアウトの前にセッションがS_OPEN状態に移行しない場合、セッションは失敗してS_OPEN_FAILED状態に移行します。推奨される最終的なオープンタイムアウトは95秒です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initiator chooses a new, unique tag not used by any currently opening session. It is RECOMMENDED that the tag be cryptographically pseudorandom and be at least 8 bytes in length, so that it is hard to guess. The initiator constructs an IHello chunk (Section 2.3.2) with the Endpoint Discriminator and the tag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
開始者は、現在開いているセッションで使用されていない新しい一意のタグを選択します。タグは暗号的に疑似ランダムであり、長さが少なくとも8バイトであることをお勧めします。そのため、推測するのは困難です。イニシエーターは、Endpoint Discriminatorとタグを使用してIHelloチャンク（セクション2.3.2）を構築します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the initiator is in the S_IHELLO_SENT state, it sends the IHello to each candidate endpoint address in the set, on a backoff schedule. The backoff SHOULD NOT be less than multiplicative, with not less than 1.5 seconds added to the interval between each attempt. The backoff SHOULD be scheduled separately for each candidate address, since new candidates can be added over time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエーターがS_IHELLO_SENT状態にある間、イニシエーターはバックオフスケジュールに従って、セット内の各候補エンドポイントアドレスにIHelloを送信します。バックオフは、各試行間の間隔に1.5秒以上の時間を追加して、乗法より小さくすべきではありません（SHOULD NOT）。時間の経過とともに新しい候補者を追加できるため、バックオフは候補者のアドレスごとに個別にスケジュールする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the initiator receives a Redirect chunk (Section 2.3.5) with a tag echo matching this session, AND this session is in the S_IHELLO_SENT state, then for each redirect destination indicated in the Redirect: if the candidate endpoint address set contains fewer than REDIRECT_THRESHOLD addresses, add the indicated redirect destination to the candidate endpoint address set. REDIRECT_THRESHOLD SHOULD NOT be more than 24.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエーターがこのセッションに一致するタグエコーを含むリダイレクトチャンク（セクション2.3.5）を受信し、このセッションがS_IHELLO_SENT状態にある場合、リダイレクトに示されている各リダイレクト先について：候補エンドポイントアドレスセットに含まれるREDIRECT_THRESHOLD未満の場合アドレス、候補のエンドポイントアドレスセットに示されたリダイレクト宛先を追加します。 REDIRECT_THRESHOLDは24以下にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the initiator receives an RHello chunk (Section 2.3.4) with a tag echo matching this session, AND this session is in the S_IHELLO_SENT state, AND the responder certificate matches the desired Endpoint Discriminator, AND the certificate is authentic according to the Cryptography Profile, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエーターがこのセッションと一致するタグエコーを含むRHelloチャンク（セクション2.3.4）を受信し、かつこのセッションがS_IHELLO_SENT状態であり、レスポンダ証明書が目的のエンドポイントディスクリミネーターと一致し、かつ証明書が暗号プロファイルに従って認証されている場合、次に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the Canonical Endpoint Discriminator for the responder certificate matches the Canonical Endpoint Discriminator of another existing session in the S_KEYING_SENT or S_OPEN states, AND the certificate of the other opening session matches the desired Endpoint Discriminator, then this session is a duplicate and SHOULD be aborted in favor of the other existing session; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. レスポンダ証明書のCanonical Endpoint DiscriminatorがS_KEYING_SENTまたはS_OPEN状態の別の既存セッションのCanonical Endpoint Discriminatorと一致し、他の開始セッションの証明書が目的のEndpoint Discriminatorと一致する場合、このセッションは重複しているため、他の既存のセッションを支持する;さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Move to the S_KEYING_SENT state. Set DESTADDR, the far-end address for the session, to the address from which this RHello was received. The initiator chooses a new, unique receive session ID, not used by any other session, for the responder to use when sending packets to the initiator. It computes a Session Key Initiator Component appropriate to the responder&#39;s certificate according to the Cryptography Profile. Using this data and the cookie from the RHello, the initiator constructs and signs an IIKeying chunk (Section 2.3.7).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. S_KEYING_SENT状態に移行します。セッションの遠端アドレスであるDESTADDRを、このRHelloの受信元のアドレスに設定します。イニシエーターは、パケットをイニシエーターに送信するときにレスポンダーが使用する、他のセッションでは使用されていない新しい一意の受信セッションIDを選択します。暗号化プロファイルに従って、レスポンダの証明書に適切なセッションキーイニシエータコンポーネントを計算します。このデータとRHelloからのCookieを使用して、イニシエーターはIIKeyingチャンクを構築して署名します（セクション2.3.7）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the initiator is in the S_KEYING_SENT state, it sends the IIKeying to DESTADDR on a backoff schedule. The backoff SHOULD NOT be less than multiplicative, with not less than 1.5 seconds added to the interval between each attempt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエーターがS_KEYING_SENT状態にある間、イニシエーターはIIKeyingをバックオフスケジュールでDESTADDRに送信します。バックオフは、各試行間の間隔に1.5秒以上の時間を追加して、乗法より小さくすべきではありません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the initiator receives an RIKeying chunk (Section 2.3.8) in a packet with this session&#39;s receive session identifier, AND this session is in the S_KEYING_SENT state, AND the signature in the chunk is authentic according to the far end&#39;s certificate (from the RHello), AND the Session Key Responder Component successfully combines with the Session Key Initiator Component and the near and far certificates to form the shared session keys and nonces according to the Cryptography Profile, then the session has opened successfully. The session moves to the S_OPEN state. The send session identifier is set from the RIKeying. Packet encryption, decryption, and verification now use the newly computed shared session keys, and the session nonces are available for application-layer cryptographic challenges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエーターがこのセッションの受信セッション識別子を持つパケットでRIKeyingチャンク（セクション2.3.8）を受信し、かつこのセッションがS_KEYING_SENT状態であり、かつチャンク内の署名が遠端の証明書（RHelloから）に従って認証されている場合）、およびセッションキーレスポンダーコンポーネントがセッションキーイニシエーターコンポーネントおよびニア証明書とファー証明書と正常に結合し、暗号化プロファイルに従って共有セッションキーとナンスを形成すると、セッションが正常に開きます。セッションはS_OPEN状態に移行します。送信セッション識別子はRIKeyingから設定されます。パケットの暗号化、復号化、および検証で、新しく計算された共有セッションキーが使用されるようになり、セッションナンスをアプリケーション層の暗号化の課題に使用できるようになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-1-1-2--Responder">
3.5.1.1.2. Responder
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.1.2. 回答
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an IHello chunk (Section 2.3.2) with an Endpoint Discriminator that selects its identity, an endpoint SHOULD construct an RHello chunk (Section 2.3.4) and send it to the address from which the IHello was received. To avoid a potential resource exhaustion denial of service, the endpoint SHOULD NOT create any persistent state associated with the IHello. The endpoint MUST generate the cookie for the RHello in such a way that it can be recognized as authentic and valid when echoed in an IIKeying. The endpoint SHOULD use the address from which the IHello was received as part of the cookie generation formula. Cookies SHOULD be valid only for a limited time; that lifetime SHOULD NOT be less than 95 seconds (the recommended ultimate session open timeout).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、IDを選択するエンドポイントディスクリミネーターでIHelloチャンク（セクション2.3.2）を受信すると、RHelloチャンク（セクション2.3.4）を構築し、IHelloの受信元アドレスに送信する必要があります（SHOULD）。潜在的なリソース枯渇サービス拒否を回避するために、エンドポイントはIHelloに関連付けられた永続的な状態を作成してはなりません（SHOULD NOT）。エンドポイントは、IIKeyingでエコーされたときに本物であり、有効であると認識できるような方法で、RHelloのCookieを生成する必要があります。エンドポイントは、IHelloが受信されたアドレスをCookie生成式の一部として使用する必要があります（SHOULD）。クッキーは一定期間のみ有効である必要があります。その存続期間は95秒未満にする必要があります（推奨される最終的なセッションオープンタイムアウト）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an FIHello chunk (Section 2.3.3) from a Forwarder (Section 3.5.1.5) where the Endpoint Discriminator selects its identity, an endpoint SHOULD do one of the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイント弁別子がアイデンティティを選択するフォワーダー（セクション3.5.1.5）からFIHelloチャンク（セクション2.3.3）を受信すると、エンドポイントは次のいずれかを実行する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Compute, construct, and send an RHello as though the FIHello was an IHello received from the indicated reply address; or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. FIHelloが指定された応答アドレスから受信したIHelloであるかのように、RHelloを計算、構築、送信します。または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Construct and send an Implied Redirect (Section 2.3.5) to the FIHello&#39;s reply address; or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 暗黙のリダイレクト（セクション2.3.5）を作成し、FIHelloの返信アドレスに送信します。または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Ignore this FIHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. このFIHelloは無視してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an IIKeying chunk (Section 2.3.7), if the cookie is not authentic or if it has expired, ignore this IIKeying; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IIKeyingチャンクを受信すると（セクション2.3.7）、Cookieが本物ではない場合、または有効期限が切れている場合は、このIIKeyingを無視します。さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an IIKeying chunk, if the cookie appears authentic but does not match the address from which the IIKeying&#39;s packet was received, perform the special processing at Cookie Change (Section 3.5.1.2); otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IIKeyingチャンクの受信時に、Cookieが本物であるように見えても、IIKeyingのパケットの受信元のアドレスと一致しない場合は、Cookieの変更（セクション3.5.1.2）で特別な処理を実行します。さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an IIKeying with an authentic and valid cookie, if the certificate is authentic according to the Cryptography Profile, AND the signature in the chunk is authentic according to the far end&#39;s certificate and the Cryptography Profile, AND the Session Key Initiator Component is acceptable, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
真正で有効なCookieを含むIIKeyingを受信したとき、証明書が暗号化プロファイルに従って真正であり、チャンク内の署名が遠端の証明書および暗号化プロファイルに従って真正であり、セッションキーイニシエーターコンポーネントが受け入れ可能である場合、次に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the address from which this IIKeying was received corresponds to an opening session in the S_IHELLO_SENT or S_KEYING_SENT state, perform the special processing at Glare (Section 3.5.1.3); otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. このIIKeyingの受信元のアドレスがS_IHELLO_SENTまたはS_KEYING_SENT状態のオープニングセッションに対応している場合は、Glareで特別な処理を実行します（セクション3.5.1.3）。さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If the address from which this IIKeying was received corresponds to a session in the S_OPEN state, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. このIIKeyingの受信元のアドレスがS_OPEN状態のセッションに対応する場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
1. If the receiver was the Responder for the S_OPEN session and the session identifier, certificate, and Session Key Initiator Component are identical to those of the S_OPEN session, this IIKeying is a retransmission, so resend the S_OPEN session&#39;s RIKeying using the Default Session Key as specified below; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
1. レシーバーがS_OPENセッションのレスポンダーであり、セッションID、証明書、およびセッションキーイニシエーターコンポーネントがS_OPENセッションのものと同一である場合、このIIKeyingは再送信であるため、指定されたデフォルトのセッションキーを使用してS_OPENセッションのRIKeyingを再送信します。未満;さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2. If the certificate from this IIKeying does not override the certificate of the S_OPEN session, ignore this IIKeying; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2. このIIKeyingからの証明書がS_OPENセッションの証明書を上書きしない場合は、このIIKeyingを無視してください。さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3. The certificate from this IIKeying overrides the certificate of the S_OPEN session; this is a new opening session from the same identity, and the existing S_OPEN session is stale. Move the existing S_OPEN session to S_CLOSED and abort all of its flows (signaling exceptions to the user), then continue processing this IIKeying.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3. このIIKeyingからの証明書は、S_OPENセッションの証明書をオーバーライドします。これは同じIDからの新しいオープニングセッションであり、既存のS_OPENセッションは古くなっています。既存のS_OPENセッションをS_CLOSEDに移動し、そのフローをすべて中止し（ユーザーに例外を通知）、このIIKeyingの処理を続行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Compute a Session Key Responder Component and choose a new, unique receive session ID not used by any other session for the initiator to use when sending packets to the responder. Using this data, construct and, with the Session Key Initiator Component, sign an RIKeying chunk (Section 2.3.8). Using the Session Key Initiator and Responder Components and the near and far certificates, the responder combines and computes the shared session keys and nonces according to the Cryptography Profile. The responder creates a new session in the S_OPEN state, with the far-endpoint address DESTADDR taken from the source address of the packet containing the IIKeying and the send session identifier taken from the IIKeying. The responder sends the RIKeying to the initiator using the Default Session Key and the requested send session identifier. Packet encryption, decryption, and verification of all future packets for this session use the newly computed keys, and the session nonces are available for application-layer cryptographic challenges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. セッションキーレスポンダコンポーネントを計算し、イニシエータがパケットをレスポンダに送信するときに使用する、他のセッションで使用されていない新しい一意の受信セッションIDを選択します。このデータを使用して、セッションキーイニシエーターコンポーネントを作成し、RIKeyingチャンクに署名します（セクション2.3.8）。セッションキーイニシエーターとレスポンダーコンポーネント、およびニア証明書とファー証明書を使用して、レスポンダーは暗号化プロファイルに従って共有セッションキーとナンスを組み合わせて計算します。レスポンダは、IIKeyingを含むパケットのソースアドレスから取得された遠端点アドレスDESTADDRと、IIKeyingから取得された送信セッション識別子を使用して、S_OPEN状態で新しいセッションを作成します。レスポンダは、デフォルトセッションキーと要求された送信セッション識別子を使用して、RIKeyingをイニシエータに送信します。パケットの暗号化、復号化、およびこのセッションの今後のすべてのパケットの検証では、新しく計算された鍵が使用され、セッションナンスはアプリケーション層の暗号化の課題に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-1-2--Cookie-Change">
3.5.1.2. Cookie Change
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.2. Cookieの変更
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some circumstances, the responder may generate an RHello cookie for an initiator&#39;s address that isn&#39;t the address the initiator would use when sending packets directly to the responder. This can happen, for example, when the initiator has multiple local addresses and uses one address to reach a Forwarder (Section 3.5.1.5) but another to reach the responder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状況によっては、レスポンダがイニシエータがパケットを直接レスポンダに送信するときに使用するアドレスではないアドレスのイニシエータのRHello Cookieを生成する場合があります。これは、たとえば、イニシエーターに複数のローカルアドレスがあり、1つのアドレスを使用してフォワーダー（セクション3.5.1.5）に到達し、別のアドレスを使用してレスポンダーに到達する場合に発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider the following example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例について考えてみます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Initiator                    Forwarder                     Responder
   | IHello                         |                                 |
   |(Src=Ix)                        |                                 |
   |-------------------------------&gt;|                                 |
   |                                | FIHello                         |
   |                                |(RA=Ix)                          |
   |                                |--------------------------------&gt;|
   |                                                                  |
   |                                                           RHello |
   |                                                       (Cookie:Ix)|
   |&lt;-----------------------------------------------------------------|
   |                                                                  |
   | IIKeying                                                         |
   |(Cookie:Ix,Src=Iy)                                                |
   |-----------------------------------------------------------------&gt;|
   |                                                                  |
   |                                             RHello Cookie Change |
   |                                             (Cookie:Ix,Cookie:Iy)|
   |&lt;-----------------------------------------------------------------|
   |                                                                  |
   | IIKeying                                                         |
   |(Cookie:Iy)                                                       |
   |-----------------------------------------------------------------&gt;|
   |                                                                  |
   |                                                         RIKeying |
   |&lt;-----------------------------------------------------------------|
   |                                                                  |
   |&lt;======================== S E S S I O N =========================&gt;|
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Figure 10: Handshake with Cookie Change
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
図10：Cookieの変更を伴うハンドシェイク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The initiator has two network interfaces: a first preferred interface with address Ix = 192.0.2.100:50000, and a second with address Iy = 198.51.100.101:50001. The responder has one interface with address Ry = 198.51.100.200:51000, on the same network as the initiator&#39;s second interface. The initiator uses its first interface to reach a Forwarder. The Forwarder observes the initiator&#39;s address of Ix and sends a Forwarded IHello (Section 2.3.3) to the responder. The responder treats this as if it were an IHello from Ix, calculates a corresponding cookie, and sends an RHello to Ix. The initiator receives this RHello from Ry and selects that address as the destination for the session. It then sends an IIKeying, copying the cookie from the RHello. However, since the source of the RHello is Ry, on a network to which the initiator is directly connected, the initiator uses its second interface Iy to send the IIKeying. The responder, on receiving the IIKeying, will compare the cookie to the expected value based on the source address of the packet, and since the IIKeying source doesn&#39;t match the IHello source used to generate the cookie, the responder will reject the IIKeying.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
イニシエーターには2つのネットワークインターフェイスがあります。アドレスがIx = 192.0.2.100:50000の最初の優先インターフェイスと、アドレスがIy = 198.51.100.101:50001の2番目のインターフェイスです。レスポンダには、イニシエータの2番目のインターフェースと同じネットワーク上に、アドレスRy = 198.51.100.200:51000のインターフェースが1つあります。イニシエーターは、最初のインターフェースを使用してフォワーダーに到達します。 Forwarderは、Ixのイニシエーターのアドレスを監視し、Forwarded IHello（セクション2.3.3）をレスポンダに送信します。レスポンダは、これをIxからのIHelloであるかのように扱い、対応するCookieを計算して、RHelloをIxに送信します。イニシエーターはRyからこのRHelloを受信し、そのアドレスをセッションの宛先として選択します。次にIIKeyingを送信し、RHelloからCookieをコピーします。ただし、RHelloのソースはRyであるため、イニシエーターが直接接続されているネットワークでは、イニシエーターは2番目のインターフェースIyを使用してIIKeyingを送信します。 IIKeyingを受信すると、レスポンダはパケットのソースアドレスに基づいてCookieを期待値と比較します。IIKeyingソースがCookieの生成に使用されたIHelloソースと一致しないため、レスポンダはIIKeyingを拒否します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the responder determines that it generated the cookie in the IIKeying but the cookie doesn&#39;t match the sender&#39;s address (for example, if the cookie is in two parts, with a first part generated independently of the initiator&#39;s address and a second part dependent on the address), the responder SHOULD generate a new cookie based on the address from which the IIKeying was received and send an RHello Cookie Change chunk (Section 2.3.6) to the source of the IIKeying, using the session ID from the IIKeying and the Default Session Key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IIKeyingでCookieを生成したと応答側が判断したが、Cookieが送信者のアドレスと一致しない場合（たとえば、Cookieが2つの部分にあり、最初の部分は開始者のアドレスとは無関係に生成され、2番目の部分は依存している場合）アドレス）、レスポンダーは、IIKeyingを受信したアドレスに基づいて新しいCookieを生成し、IIKeyingのセッションIDを使用して、RHello Cookie Changeチャンク（セクション2.3.6）をIIKeyingのソースに送信する必要があります（SHOULD）。デフォルトのセッションキー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the initiator receives an RHello Cookie Change chunk for a session in the S_KEYING_SENT state, AND the old cookie matches the one originally sent to the responder, then the initiator adopts the new cookie, constructs and signs a new IIKeying chunk, and sends the new IIKeying to the responder. The initiator SHOULD NOT change the cookie for a session more than once.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエーターがS_KEYING_SENT状態のセッションのRHello Cookie Changeチャンクを受信し、古いCookieが最初にレスポンダーに送信されたものと一致する場合、イニシエーターは新しいCookieを採用し、新しいIIKeyingチャンクを作成して署名し、新しいIIレスポンダへのキーイング。イニシエーターは、セッションのCookieを複数回変更してはなりません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-1-3--Glare">
3.5.1.3. Glare
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.3. グレア
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Glare occurs when two endpoints attempt to initiate sessions to each other concurrently. Glare is detected by receipt of a valid and authentic IIKeying from an endpoint address that is a destination for an opening session. Only one session is allowed between a pair of endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グレアは、2つのエンドポイントが相互に同時にセッションを開始しようとしたときに発生します。グレアは、オープニングセッションの宛先であるエンドポイントアドレスからの有効で信頼できるIIKeyingの受信によって検出されます。エンドポイントのペア間で許可されるセッションは1つだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Glare is resolved by comparing the certificate in the received IIKeying with the near end&#39;s certificate. The Cryptography Profile defines a certificate comparison function to determine the prevailing endpoint when there is glare.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グレアは、受信したIIKeyingの証明書を近端の証明書と比較することで解決されます。暗号化プロファイルは、グレアが存在する場合の一般的なエンドポイントを決定するための証明書比較関数を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the near end prevails, discard and ignore the received IIKeying. The far end will abort its opening session on receipt of IIKeying from the near end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
近端が優勢な場合は、受け取ったIIKeyingを破棄して無視します。遠端は、近端からIIKeyingを受信すると、オープニングセッションを中止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise, the far end prevails:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それ以外の場合、遠端が優先されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the certificate in the IIKeying overrides the certificate associated with the near opening session according to the Cryptography Profile, then abort and destroy the near opening session. Then,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. IIKeyingの証明書が、暗号化プロファイルに従って、ほぼ開始しているセッションに関連付けられている証明書をオーバーライドする場合は、中断し、ほぼ開始しているセッションを破棄します。そして、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Continue with normal Responder IIKeying processing (Section 3.5.1.1.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 通常のResponder IIKeying処理を続行します（セクション3.5.1.1.2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-1-4--Redirector">
3.5.1.4. Redirector
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.4. リダイレクター
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        +-----------+           +------------+          +-----------+
        | Initiator |----------&gt;| Redirector |          | Responder |
        |           |&lt;----------|            |          |           |
        |           |           +------------+          |           |
        |           |&lt;=================================&gt;|           |
        +-----------+                                   +-----------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
Figure 11: Redirector
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
図11：リダイレクター
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Redirector acts like a name server for Endpoint Discriminators. An initiator MAY use a Redirector to discover additional candidate endpoint addresses for a desired endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リダイレクタは、Endpoint Discriminatorsのネームサーバーのように機能します。イニシエーターは、リダイレクターを使用して、目的のエンドポイントの追加候補エンドポイントアドレスを検出できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an IHello chunk with an Endpoint Discriminator that does not select the Redirector&#39;s identity, the Redirector constructs and sends back to the initiator a Responder Redirect chunk (Section 2.3.5) containing one or more additional candidate addresses for the indicated endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リダイレクターのIDを選択しないエンドポイント識別子を持つIHelloチャンクを受信すると、リダイレクターは指定されたエンドポイントの1つ以上の追加候補アドレスを含むレスポンダーリダイレクトチャンク（セクション2.3.5）を作成してイニシエーターに送り返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Initiator                   Redirector                     Responder
   | IHello                         |                                 |
   |-------------------------------&gt;|                                 |
   |                                |                                 |
   |                       Redirect |                                 |
   |&lt;-------------------------------|                                 |
   |                                                                  |
   | IHello                                                           |
   |-----------------------------------------------------------------&gt;|
   |                                                                  |
   |                                                           RHello |
   |&lt;-----------------------------------------------------------------|
   |                                                                  |
   | IIKeying                                                         |
   |-----------------------------------------------------------------&gt;|
   |                                                                  |
   |                                                         RIKeying |
   |&lt;-----------------------------------------------------------------|
   |                                                                  |
   |&lt;======================== S E S S I O N =========================&gt;|
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Figure 12: Handshake Using a Redirector
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
図12：リダイレクターを使用したハンドシェイク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Deployment Design Note: Redirectors SHOULD NOT initiate new sessions to endpoints that might use the Redirector&#39;s address as a candidate for another endpoint, since the far end might interpret the Redirector&#39;s IIKeying as glare for the far end&#39;s initiation to the other endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配備設計上の注意：リダイレクターは、リダイレクターのアドレスを別のエンドポイントの候補として使用する可能性のあるエンドポイントへの新しいセッションを開始しないでください。これは、遠端がリダイレクターのIIKeyingを、遠端が他のエンドポイントへの開始のまぶしさとして解釈する可能性があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-1-5--Forwarder">
3.5.1.5. Forwarder
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.5. フォワーダー
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         +-----------+     +-----------+     +---+     +-----------+
         | Initiator |----&gt;| Forwarder |&lt;===&gt;| N |&lt;===&gt;| Responder |
         |           |     +-----------+     | A |     |           |
         |           |&lt;=====================&gt;| T |&lt;===&gt;|           |
         +-----------+                       +---+     +-----------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
Figure 13: Forwarder
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
図13：フォワーダー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A responder might be behind a NAT or firewall that doesn&#39;t allow inbound packets to reach the endpoint until it first sends an outbound packet for a particular far-endpoint address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レスポンダは、NATまたはファイアウォールの背後にある可能性があり、特定の遠端点アドレスのアウトバウンドパケットを最初に送信するまで、インバウンドパケットがエンドポイントに到達することを許可しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Forwarder&#39;s endpoint address MAY be a candidate address for another endpoint. A responder MAY use a Forwarder to receive FIHello chunks sent on behalf of an initiator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フォワーダーのエンドポイントアドレスは、別のエンドポイントの候補アドレスになる場合があります。レスポンダは、イニシエータに代わって送信されたFIHelloチャンクを受信するためにフォワーダを使用できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an IHello chunk with an Endpoint Discriminator that does not select the Forwarder&#39;s identity, if the Forwarder has an S_OPEN session with an endpoint whose certificate matches the desired Endpoint Discriminator, the Forwarder constructs and sends an FIHello chunk (Section 2.3.3) to the selected endpoint over the S_OPEN session, using the tag and Endpoint Discriminator from the IHello chunk and the source address of the packet containing the IHello for the corresponding fields of the FIHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フォワーダーのIDを選択しないEndpoint Discriminatorを含むIHelloチャンクを受信すると、フォワーダーが、証明書が目的のEndpoint Discriminatorと一致するエンドポイントとのS_OPENセッションを持っている場合、FIHelloチャンクを構築して送信します（セクション2.3.3）。 IHelloチャンクのタグとEndpoint Discriminator、およびFIHelloの対応するフィールドのIHelloを含むパケットの送信元アドレスを使用して、S_OPENセッションを介して選択したエンドポイントに送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an FIHello chunk, a responder might send an RHello or Implied Redirect to the original source of the IHello (Section 3.5.1.1.2), potentially allowing future packets to flow directly between the initiator and responder through the NAT or firewall.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FIHelloチャンクを受信すると、レスポンダーはRHelloまたは暗黙のリダイレクトをIHelloの元のソース（セクション3.5.1.1.2）に送信し、将来のパケットがイニシエーターとレスポンダーの間でNATまたはファイアウォールを介して直接流れるようにする可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Initiator                    Forwarder           NAT       Responder
   | IHello                         |                |                |
   |-------------------------------&gt;|                |                |
   |                                | FIHello        |                |
   |                                |---------------&gt;|---------------&gt;|
   |                                                 |                |
   |                                                 |         RHello |
   |                                                 :&lt;---------------|
   |&lt;------------------------------------------------:                |
   |                                                 :                |
   | IIKeying                                        :                |
   |-------------------------------------------------:---------------&gt;|
   |                                                 :                |
   |                                                 :       RIKeying |
   |                                                 :&lt;---------------|
   |&lt;------------------------------------------------:                |
   |                                                 :                |
   |&lt;======================== S E S S I O N ========&gt;:&lt;==============&gt;|
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 14: Forwarder Handshake where Responder Sends an RHello
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
図14：レスポンダがRHelloを送信するフォワーダハンドシェイク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Initiator                    Forwarder           NAT       Responder
   | IHello                         |                |                |
   |-------------------------------&gt;|                |                |
   |                                | FIHello        |                |
   |                                |---------------&gt;|---------------&gt;|
   |                                                 |                |
   |                                                 |       Redirect |
   |                                                 | (Implied,RD={})|
   |                                                 :&lt;---------------|
   |&lt;------------------------------------------------:                |
   |                                                 :                |
   | IHello                                          :                |
   |------------------------------------------------&gt;:---------------&gt;|
   |                                                 :                |
   |                                                 :         RHello |
   |                                                 :&lt;---------------|
   |&lt;------------------------------------------------:                |
   |                                                 :                |
   | IIKeying                                        :                |
   |------------------------------------------------&gt;:---------------&gt;|
   |                                                 :                |
   |                                                 :       RIKeying |
   |                                                 :&lt;---------------|
   |&lt;------------------------------------------------:                |
   |                                                 :                |
   |&lt;======================== S E S S I O N ========&gt;:&lt;==============&gt;|
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Figure 15: Forwarder Handshake where Responder Sends an Implied Redirect
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
図15：レスポンダが暗黙のリダイレクトを送信するフォワーダハンドシェイク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-1-6--Redirector-and-Forwarder-with-NAT">
3.5.1.6. Redirector and Forwarder with NAT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.6. NATを使用するリダイレクターとフォワーダー
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             +---+       +---+       +---+      +---+      +---+
             | I |       | N |       | I |      | N |      | R |
             | n |------&gt;| A |------&gt;| n |      | A |      | e |
             | i |       | T |       | t |&lt;====&gt;| T |&lt;====&gt;| s |
             | t |&lt;------|   |&lt;------| r |      |   |      | p |
             | i |       |   |       | o |      |   |      | o |
             | a |       |   |       +---+      |   |      | n |
             | t |       |   |                  |   |      | d |
             | o |&lt;=====&gt;|   |&lt;================&gt;|   |&lt;====&gt;| e |
             | r |       |   |                  |   |      | r |
             +---+       +---+                  +---+      +---+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Figure 16: Introduction Service for Initiator and Responder behind NATs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
図16：NATの背後にあるイニシエーターとレスポンダーの紹介サービス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An initiator and responder might each be behind distinct NATs or firewalls that don&#39;t allow inbound packets to reach the respective endpoints until each first sends an outbound packet for a particular far-endpoint address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエーターとレスポンダーはそれぞれ、個別のNATまたはファイアウォールの背後にある可能性があり、それぞれが特定の遠端点アドレスのアウトバウンドパケットを最初に送信するまで、インバウンドパケットがそれぞれのエンドポイントに到達することを許可しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An introduction service comprising Redirector and Forwarder functions may facilitate direct communication between endpoints each behind a NAT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リダイレクターとフォワーダーの機能を備えた導入サービスは、NATの背後にあるエンドポイント間の直接通信を容易にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The responder is registered with the introduction service via an S_OPEN session to it. The service observes and records the responder&#39;s public NAT address as the DESTADDR of the S_OPEN session. The service MAY record other addresses for the responder, for example addresses that the responder self-reports as being directly attached.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レスポンダは、S_OPENセッションを介して紹介サービスに登録されます。サービスは、レスポンダーのパブリックNATアドレスを監視して、S_OPENセッションのDESTADDRとして記録します。サービスはレスポンダの他のアドレス、たとえばレスポンダが直接接続されていると自己報告するアドレスなどを記録してもよい（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initiator begins with an address of the introduction service as an initial candidate. The Redirector portion of the service sends to the initiator a Responder Redirect containing at least the responder&#39;s public NAT address as previously recorded. The Forwarder portion of the service sends to the responder a Forwarded IHello containing the initiator&#39;s public NAT address as observed to be the source of the IHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエーターは、最初の候補として紹介サービスのアドレスから始まります。サービスのリダイレクター部分は、少なくとも記録済みのレスポンダーのパブリックNATアドレスを含むレスポンダーリダイレクトをイニシエーターに送信します。サービスのForwarder部分は、IHelloのソースであることが確認されたイニシエーターのパブリックNATアドレスを含むForwarded IHelloをレスポンダーに送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The responder sends an RHello to the initiator&#39;s public NAT address in response to the FIHello. This will allow inbound packets to the responder through its NAT from the initiator&#39;s public NAT address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レスポンダは、FIHelloに応答してRHelloをイニシエータのパブリックNATアドレスに送信します。これにより、イニシエーターのパブリックNATアドレスからNATを介してレスポンダーへのインバウンドパケットが許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initiator sends an IHello to the responder&#39;s public NAT address in response to the Responder Redirect. This will allow inbound packets to the initiator through its NAT from the responder&#39;s public NAT address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエーターは、レスポンダーリダイレクトへの応答として、IHelloをレスポンダーのパブリックNATアドレスに送信します。これにより、レスポンダーのパブリックNATアドレスからNATを介してイニシエーターへのインバウンドパケットが許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With transit paths created in both NATs, normal session startup can proceed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
両方のNATで作成されたトランジットパスを使用すると、通常のセッションの起動を続行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Initiator     NAT-I    Redirector+Forwarder     NAT-R      Responder
   |               |                |                |                |
   | IHello        |                |                |                |
   |(Dst=Intro)    |                |                |                |
   |--------------&gt;|                |                |                |
   |               |---------------&gt;|                |                |
   |               |                | FIHello        |                |
   |               |                |(RA=NAT-I-Pub)  |                |
   |               |                |---------------&gt;|---------------&gt;|
   |               |       Redirect |                |                |
   |               | (RD={NAT-R-Pub,|                |                |
   |               |           ...})|                |                |
   |&lt;--------------|&lt;---------------|                |                |
   |               |                                 |         RHello |
   |               |                                 | (Dst=NAT-I-Pub)|
   |               |                                 :&lt;---------------|
   |               | (*)  &lt;--------------------------:                |
   | IHello        |                                 :                |
   |(Dst=NAT-R-Pub)|                                 :                |
   |--------------&gt;:                                 :                |
   |               :--------------------------------&gt;:---------------&gt;|
   |               :                                 :                |
   |               :                                 :         RHello |
   |               :                                 :&lt;---------------|
   |&lt;--------------:&lt;--------------------------------:                |
   |               :                                 :                |
   | IIKeying      :                                 :                |
   |--------------&gt;:                                 :                |
   |               :--------------------------------&gt;:---------------&gt;|
   |               :                                 :                |
   |               :                                 :       RIKeying |
   |               :                                 :&lt;---------------|
   |&lt;--------------:&lt;--------------------------------:                |
   |               :                                 :                |
   |&lt;=============&gt;:&lt;======== S E S S I O N ========&gt;:&lt;==============&gt;|
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Figure 17: Handshake with Redirector and Forwarder
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
図17：リダイレクターとフォワーダーを使用したハンドシェイク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the point in Figure 17 marked (*), the responder&#39;s RHello from the FIHello might arrive at the initiator&#39;s NAT before or after the initiator&#39;s IHello is sent outbound to the responder&#39;s public NAT address. If it arrives before, it may be dropped by the NAT. If it arrives after, it will transit the NAT and trigger keying without waiting for another round-trip time. The timing of this race depends, among other factors, on the relative distances of the initiator and responder from each other and from the introduction service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図17の（*）でマークされた時点で、FIHelloからのレスポンダーのRHelloは、イニシエーターのIHelloがレスポンダーのパブリックNATアドレスに送信される前または後に、イニシエーターのNATに到着する場合があります。以前に到着した場合、NATによってドロップされる可能性があります。それが後に到着した場合、NATを通過し、次の往復時間を待たずにキーイングをトリガーします。このレースのタイミングは、他の要因の中でも、イニシエーターとレスポンダーの互いからの、および紹介サービスからの相対的な距離に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-1-7--Load-Distribution-and-Fault-Tolerance">
3.5.1.7. Load Distribution and Fault Tolerance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.7. 負荷分散とフォールトトレランス
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             +---+    IHello/RHello    +-------------+
             | I |&lt;-------------------&gt;| Responder 1 |
             | n |                     +-------------+
             | i |  SESSION  +-------------+
             | t |&lt;=========&gt;| Responder 2 |
             | i |           +-------------+
             | a |   IHello...                 +----------------+
             | t |-------------------------&gt; X | Dead Responder |
             | o |                             +----------------+
             | r |  IHello/RHello   +-------------+
             |   |&lt;----------------&gt;| Responder N |
             +---+                  +-------------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Figure 18: Parallel Open to Multiple Endpoints
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
図18：複数のエンドポイントへの並列オープン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As specified in Section 3.2, more than one endpoint is allowed to be selected by one Endpoint Discriminator. This will typically be the case for a set of servers, any of which could accommodate a connecting client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.2で指定されているように、1つのエンドポイント識別子によって複数のエンドポイントを選択できます。これは通常、サーバーのセットに当てはまります。サーバーのいずれも接続するクライアントに対応できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As specified in Section 3.5.1.1.1, an initiator is allowed to use multiple candidate endpoint addresses when starting a session, and the sender of the first acceptable RHello chunk to be received is selected to complete the session, with later responses ignored. An initiator can start with the multiple candidate endpoint addresses, or it may learn them during startup from one or more Redirectors (Section 3.5.1.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.5.1.1.1で指定されているように、イニシエーターはセッションの開始時に複数の候補エンドポイントアドレスを使用でき、受信する最初の受け入れ可能なRHelloチャンクの送信者がセッションを完了するために選択され、その後の応答は無視されます。イニシエーターは複数の候補エンドポイントアドレスで開始できます。または、1つ以上のリダイレクターから起動時にそれらを学習する場合があります（セクション3.5.1.4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Parallel open to multiple endpoints for the same Endpoint Discriminator, combined with selection by earliest RHello, can be used for load distribution and fault tolerance. The cost at each endpoint that is not selected is limited to receiving and processing an IHello, and generating and sending an RHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じEndpoint Discriminatorの複数のエンドポイントに並行してオープンし、最初のRHelloによる選択と組み合わせて、負荷分散とフォールトトレランスに使用できます。選択されていない各エンドポイントのコストは、IHelloの受信と処理、およびRHelloの生成と送信に限定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In one circumstance, multiple servers of similar processing and networking capacity may be located in near proximity to each other, such as in a data center. In this circumstance, a less heavily loaded server can respond to an IHello more quickly than more heavily loaded servers and will tend to be selected by a client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ある状況では、同様の処理能力とネットワーキング能力を備えた複数のサーバーが、データセンター内など、互いに近接して配置されている場合があります。この状況では、負荷が少ないサーバーは、負荷が高いサーバーよりもIHelloに迅速に応答でき、クライアントによって選択される傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In another circumstance, multiple servers may be located in different physical locations, such as different data centers. In this circumstance, a server that is located nearer (in terms of network distance) to the client can respond earlier than more distant servers and will tend to be selected by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別の状況では、複数のサーバーが異なるデータセンターなどの異なる物理的な場所に配置されている場合があります。この状況では、クライアントに近い（ネットワーク距離の点で）サーバーは、遠いサーバーよりも早く応答でき、クライアントによって選択される傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiple servers, in proximity or distant from one another, can form a redundant pool of servers. A client can perform a parallel open to the multiple servers. In normal operation, the multiple servers will all respond, and the client will select one of them as described above. If one of the multiple servers fails, other servers in the pool can still respond to the client, allowing the client to succeed to an S_OPEN session with one of them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のサーバーが互いに近接または離れている場合は、サーバーの冗長プールを形成できます。クライアントは、複数のサーバーに対して並列オープンを実行できます。通常の操作では、複数のサーバーがすべて応答し、クライアントは上記のようにそれらの1つを選択します。複数のサーバーの1つに障害が発生した場合でも、プール内の他のサーバーはクライアントに応答できるため、クライアントはそのうちの1つとのS_OPENセッションに成功できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-2--Congestion-Control">
3.5.2. Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.2. 輻輳制御
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An RTMFP MUST implement congestion control and avoidance algorithms that are &#34;TCP compatible&#34;, in accordance with Internet best current practice [RFC2914]. The algorithms SHOULD NOT be more aggressive in sending data than those described in &#34;TCP Congestion Control&#34; [RFC5681] and MUST NOT be more aggressive in sending data than the &#34;slow start algorithm&#34; described in Section 3.1 of RFC 5681.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPは、インターネットのベストプラクティス[RFC2914]に従って、「TCP互換」である輻輳制御および回避アルゴリズムを実装する必要があります。アルゴリズムは、「TCP輻輳制御」[RFC5681]で説明されているものよりもデータを送信する際に積極的にすべきではなく、RFC 5681のセクション3.1で説明されている「スロースタートアルゴリズム」よりも積極的にデータを送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint maintains a transmission budget in the session information context of each S_OPEN session (Section 3.5), controlling the rate at which the endpoint sends data into the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、各S_OPENセッション（セクション3.5）のセッション情報コンテキストで伝送バジェットを維持し、エンドポイントがネットワークにデータを送信するレートを制御します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For window-based congestion control and avoidance algorithms, the transmission budget is the congestion window, which is the amount of user data that is allowed to be outstanding, or in flight, in the network. Transmission is allowed when S_OUTSTANDING_BYTES (Section 3.5) is less than the congestion window (Section 3.6.2.3). See Appendix A for an experimental window-based congestion control algorithm for real-time and bulk data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ウィンドウベースの輻輳制御および回避アルゴリズムの場合、送信バジェットは輻輳ウィンドウです。これは、ネットワーク内で未処理または処理中のユーザーデータの量です。 S_OUTSTANDING_BYTES（セクション3.5）が輻輳ウィンドウ（セクション3.6.2.3）より小さい場合、送信は許可されます。リアルタイムデータとバルクデータの実験的なウィンドウベースの輻輳制御アルゴリズムについては、付録Aを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint avoids sending large bursts of data or packets into the network (Section 3.5.2.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、データまたはパケットの大きなバーストをネットワークに送信することを回避します（セクション3.5.2.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sending endpoint increases and decreases its transmission budget in response to acknowledgements (Section 3.6.2.4) and loss according to the congestion control and avoidance algorithms. Loss is detected by negative acknowledgement (Section 3.6.2.5) and timeout (Section 3.6.2.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信側エンドポイントは、輻輳制御および回避アルゴリズムに従って、確認応答（セクション3.6.2.4）および損失に応じて、送信バジェットを増減します。損失は​​、否定応答（セクション3.6.2.5）およびタイムアウト（セクション3.6.2.6）によって検出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Timeout is determined by the Effective Retransmission Timeout (ERTO) (Section 3.5.2.2). The ERTO is measured using the Timestamp and Timestamp Echo packet header fields (Section 2.2.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイムアウトは、有効な再送信タイムアウト（ERTO）によって決定されます（セクション3.5.2.2）。 ERTOは、タイムスタンプおよびタイムスタンプエコーパケットヘッダーフィールドを使用して測定されます（セクション2.2.4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiving endpoint acknowledges all received data (Section 3.6.3.4) to enable the sender to measure receipt of data, or lack thereof.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信側エンドポイントは、受信したすべてのデータを確認し（3.6.3.4項）、送信側がデータの受信または欠落を測定できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiving endpoint may be receiving time critical (or real-time) data from a first sender while receiving data from other senders. The receiving endpoint can signal its other senders (Section 2.2.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信側エンドポイントは、他の送信側からデータを受信しながら、最初の送信側からタイムクリティカル（またはリアルタイム）のデータを受信して​​いる可能性があります。受信エンドポイントは他の送信者に信号を送ることができます（セクション2.2.4）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
to cause them to decrease the aggressiveness of their congestion control and avoidance algorithms, in order to yield network capacity to the time critical data (Section 3.5.2.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイムクリティカルなデータにネットワーク容量をもたらすために、輻輳制御および回避アルゴリズムの積極性を低下させる（セクション3.5.2.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-2-1--Time-Critical-Reverse-Notification">
3.5.2.1. Time Critical Reverse Notification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.2.1. タイムクリティカルな逆通知
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender can increase its transmission budget at a rate compatible with (but not exceeding) the &#34;slow start algorithm&#34; specified in RFC 5681 (with which the transmission rate is doubled every round trip when beginning or restarting transmission, until loss is detected). However, a sender MUST behave as though the slow start threshold SSTHRESH is clamped to 0 (disabling the slow start algorithm&#39;s exponential increase behavior) on a session where a Time Critical Reverse Notification (Section 2.2.4) indication has been received from the far end within the last 800 milliseconds, unless the sender is itself currently sending time critical data to the far end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は、RFC 5681で指定された「スロースタートアルゴリズム」と互換性のある（ただし超過しない）レートで送信バジェットを増やすことができます（これにより、損失が検出されるまで、送信を開始または再開すると、ラウンドトリップごとに送信レートが2倍になります）。ただし、送信者は、タイムクリティカルなリバース通知（セクション2.2.4）の指示が遠端から受信されたセッションで、スロースタートしきい値SSTHRESHが0にクランプされている（スロースタートアルゴリズムの指数増加動作を無効にする）ように動作する必要があります。送信者自身が現在タイムクリティカルなデータを遠端に送信していない限り、過去800ミリ秒以内。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During each round trip, a sender SHOULD NOT increase the transmission budget by more than 0.5% or by 384 bytes per round trip (whichever is greater) on a session where a Time Critical Reverse Notification indication has been received from the far end within the last 800 milliseconds, unless the sender is itself currently sending time critical data to the far end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ラウンドトリップの間、送信者は、最後の時間内に遠端からタイムクリティカルなリバース通知の指示が受信されたセッションで、0.5％以上、またはラウンドトリップごとに384バイト（どちらか大きい方）だけ、送信バジェットを増加してはなりません（SHOULD NOT）。 800ミリ秒。ただし、送信者自身が現在タイムクリティカルなデータを遠端に送信している場合を除きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-2-2--Retransmission-Timeout">
3.5.2.2. Retransmission Timeout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.2.2. 再送タイムアウト
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP uses the ERTO to detect when a user data fragment has been lost in the network. The ERTO is typically calculated in a manner similar to that specified in &#34;Requirements for Internet Hosts - Communication Layers&#34; [RFC1122] and is a function of round-trip time measurements and persistent timeout behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPはERTOを使用して、ユーザーデータフラグメントがネットワークで失われたことを検出します。 ERTOは通常、「インターネットホストの要件-通信層」[RFC1122]で指定された方法と同様の方法で計算され、往復時間測定と永続的なタイムアウト動作の関数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ERTO SHOULD be at least 250 milliseconds and SHOULD allow for the receiver to delay sending an acknowledgement for up to 200 milliseconds (Section 3.6.3.4.4). The ERTO MUST NOT be less than the round-trip time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERTOは少なくとも250ミリ秒である必要があり（SHOULD）、受信者が最大200ミリ秒（セクション3.6.3.4.4）の確認応答の送信を遅延できるようにする必要があります。 ERTOは往復時間より短くしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To facilitate round-trip time measurement, an endpoint MUST implement the Timestamp Echo facility:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ラウンドトリップ時間測定を容易にするために、エンドポイントはタイムスタンプエコー機能を実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On a session entering the S_OPEN state, initialize TS_RX_TIME to negative infinity, and initialize TS_RX and TS_ECHO_TX to have no value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o S_OPEN状態に入るセッションで、TS_RX_TIMEを負の無限大に初期化し、TS_RXおよびTS_ECHO_TXを初期化して値をなくします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a packet in an S_OPEN session with the timestampPresent (Section 2.2.4) flag set, if the timestamp field in the packet is different than TS_RX, set TS_RX to the value of the timestamp field in the packet, and set TS_RX_TIME to the current time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o timestampPresent（セクション2.2.4）フラグが設定されたS_OPENセッションでパケットを受信したときに、パケットのタイムスタンプフィールドがTS_RXと異なる場合は、TS_RXをパケットのタイムスタンプフィールドの値に設定し、TS_RX_TIMEを現在の時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When sending a packet to the far end in an S_OPEN session:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o S_OPENセッションで遠端にパケットを送信する場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. Calculate TS_RX_ELAPSED = current time - TS_RX_TIME. If TS_RX_ELAPSED is more than 128 seconds, then set TS_RX and TS_ECHO_TX to have no value, and do not include a timestamp echo; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. TS_RX_ELAPSED =現在の時刻-TS_RX_TIMEを計算します。 TS_RX_ELAPSEDが128秒を超える場合は、TS_RXおよびTS_ECHO_TXを値なしに設定し、タイムスタンプエコーを含めないでください。さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. Calculate TS_RX_ELAPSED_TICKS to be the number of whole 4-millisecond periods in TS_RX_ELAPSED; then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. TS_RX_ELAPSED_TICKSを計算して、TS_RX_ELAPSEDの4ミリ秒の期間全体の数になります。その後
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. Calculate TS_ECHO = (TS_RX + TS_RX_ELAPSED_TICKS) MODULO 65536; then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. TS_ECHO =（TS_RX + TS_RX_ELAPSED_TICKS）MODULO 65536を計算します。その後
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4. If TS_ECHO is not equal to TS_ECHO_TX, then set TS_ECHO_TX to TS_ECHO, set the timestampEchoPresent flag, and set the timestampEcho field to TS_ECHO_TX.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4. TS_ECHOがTS_ECHO_TXと等しくない場合は、TS_ECHO_TXをTS_ECHOに設定し、timestampEchoPresentフラグを設定し、timestampEchoフィールドをTS_ECHO_TXに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remainder of this section describes an OPTIONAL method for calculating the ERTO. Real-time applications and P2P mesh applications often require knowing the round-trip time and RTT variance. This section additionally describes a method for measuring the round-trip time and RTT variance, and calculating a smoothed round-trip time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションの残りの部分では、ERTOを計算するためのオプションの方法について説明します。リアルタイムアプリケーションとP2Pメッシュアプ​​リケーションでは、多くの場合、往復時間とRTT変動を知る必要があります。このセクションでは、往復時間とRTTの分散を測定し、平滑化された往復時間を計算する方法についても説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the session information context contain additional variables:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション情報コンテキストに追加の変数を含めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TS_TX: the last timestamp sent to the far end, initialized to have no value;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TS_TX：値を持たないように初期化された、遠端に送信された最後のタイムスタンプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TS_ECHO_RX: the last timestamp echo received from the far end, initialized to have no value;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TS_ECHO_RX：値を持たないように初期化された、遠端から受信した最後のタイムスタンプエコー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SRTT: the smoothed round-trip time, initialized to have no value;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SRTT：平滑化された往復時間。値を持たないように初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RTTVAR: the round-trip time variance, initialized to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RTTVAR：往復の時間変動。0に初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initialize MRTO to 250 milliseconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MRTOを250ミリ秒に初期化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initialize ERTO to 3 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERTOを3秒に初期化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On sending a packet to the far end of an S_OPEN session, if the current send timestamp is not equal to TS_TX, then set TS_TX to the current send timestamp, set the timestampPresent flag in the packet header, and set the timestamp field to TS_TX.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_OPENセッションの遠端にパケットを送信するときに、現在の送信タイムスタンプがTS_TXと等しくない場合、TS_TXを現在の送信タイムスタンプに設定し、パケットヘッダーのtimestampPresentフラグを設定し、タイムスタンプフィールドをTS_TXに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of a packet from the far end of an S_OPEN session, if the timestampEchoPresent flag is set in the packet header, AND the timestampEcho field is not equal to TS_ECHO_RX, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_OPENセッションの遠端からのパケットの受信時に、timestampEchoPresentフラグがパケットヘッダーに設定されていて、timestampEchoフィールドがTS_ECHO_RXと等しくない場合、次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Set TS_ECHO_RX to timestampEcho;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. TS_ECHO_RXをtimestampEchoに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Calculate RTT_TICKS = (current send timestamp - timestampEcho) MODULO 65536;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. RTT_TICKS =（現在の送信タイムスタンプ-timestampEcho）MODULO 65536を計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If RTT_TICKS is greater than 32767, the measurement is invalid, so discard this measurement; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. RTT_TICKSが32767より大きい場合、測定は無効であるため、この測定を破棄します。さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Calculate RTT = RTT_TICKS * 4 milliseconds;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. RTT = RTT_TICKS * 4ミリ秒を計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. If SRTT has a value, then calculate new values of RTTVAR and SRTT:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. SRTTに値がある場合、RTTVARとSRTTの新しい値を計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
1. RTT_DELTA = | SRTT - RTT |;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
1. RTT_DELTA = | SRTT-RTT |;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2. RTTVAR = ((3 * RTTVAR) + RTT_DELTA) / 4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2. RTTVAR =（（3 * RTTVAR）+ RTT_DELTA）/ 4;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3. SRTT = ((7 * SRTT) + RTT) / 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3. SRTT =（（7 * SRTT）+ RTT）/ 8。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. If SRTT has no value, then set SRTT = RTT and RTTVAR = RTT / 2;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. SRTTに値がない場合は、SRTT = RTTおよびRTTVAR = RTT / 2に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Set MRTO = SRTT + 4 * RTTVAR + 200 milliseconds;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. MRTO = SRTT + 4 * RTTVAR + 200ミリ秒に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Set ERTO to MRTO or 250 milliseconds, whichever is greater.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. ERTOをMRTOまたは250ミリ秒のいずれか大きい方に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A retransmission timeout occurs when the most recently transmitted user data fragment has remained outstanding in the network for ERTO. When this timeout occurs, increase ERTO on an exponential backoff with an ultimate backoff cap of 10 seconds:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再送信タイムアウトは、最後に送信されたユーザーデータフラグメントがERTOのネットワークで未処理のままである場合に発生します。このタイムアウトが発生した場合、最終的なバックオフキャップが10秒の指数バックオフでERTOを増やします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Calculate ERTO_BACKOFF = ERTO * 1.4142;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. ERTO_BACKOFF = ERTO * 1.4142を計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Calculate ERTO_CAPPED to be ERTO_BACKOFF or 10 seconds, whichever is less;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. ERTO_CAPPEDを計算して、ERTO_BACKOFFまたは10秒のいずれか短い方にしてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Set ERTO to ERTO_CAPPED or MRTO, whichever is greater.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. ERTOをERTO_CAPPEDまたはMRTOのいずれか大きい方に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-2-3--Burst-Avoidance">
3.5.2.3. Burst Avoidance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.2.3. バースト回避
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application&#39;s sending patterns may cause the transmission budget to grow to a large value, but at times its sending patterns will result in a comparatively small amount of data outstanding in the network. In this circumstance, especially with a window-based congestion avoidance algorithm, if the application then has a large amount of new data to send (for example, a new bulk data transfer), it could send data into the network all at once to fill the window. This kind of transmission burst is undesirable, however, because it can jam interfaces, links, and buffers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションの送信パターンにより、送信バジェットが大きな値になることがありますが、その送信パターンにより、ネットワークで未処理のデータ量が比較的少なくなる場合があります。この状況では、特にウィンドウベースの輻輳回避アルゴリズムでは、アプリケーションが大量の新しいデータを送信する場合（たとえば、新しいバルクデータ転送）、データを一度にネットワークに送信してデータをいっぱいにすることができます。窓。ただし、この種類の送信バーストは、インターフェイス、リンク、およびバッファを妨害する可能性があるため、望ましくありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Accordingly, in any session, an endpoint SHOULD NOT send more than six packets containing user data between receiving any acknowledgements or retransmission timeouts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、どのセッションでも、エンドポイントは、確認応答または再送信タイムアウトを受信する間に、ユーザーデータを含む6つ以上のパケットを送信してはなりません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following describes an OPTIONAL method to avoid bursting large numbers of packets into the network:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下に、ネットワークへの大量のパケットのバーストを回避するためのオプションの方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the session information context contain an additional variable DATA_PACKET_COUNT, initialized to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション情報コンテキストに、0に初期化された追加の変数DATA_PACKET_COUNTが含まれるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transmission of a user data fragment on this session is not allowed if DATA_PACKET_COUNT is greater than or equal to 6, regardless of any other allowance of the congestion control algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DATA_PACKET_COUNTが6以上の場合、輻輳制御アルゴリズムの他の許可に関係なく、このセッションでのユーザーデータフラグメントの送信は許可されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On transmission of a packet containing at least one User Data chunk (Section 2.3.11), set DATA_PACKET_COUNT = DATA_PACKET_COUNT + 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
少なくとも1つのユーザーデータチャンク（2.3.11節）を含むパケットの送信時に、DATA_PACKET_COUNT = DATA_PACKET_COUNT + 1を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an acknowledgement chunk (Sections 2.3.13 and 2.3.14), set DATA_PACKET_COUNT to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認応答チャンクを受信したら（セクション2.3.13および2.3.14）、DATA_PACKET_COUNTを0に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On a retransmission timeout, set DATA_PACKET_COUNT to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再送信タイムアウト時に、DATA_PACKET_COUNTを0に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-3--Address-Mobility">
3.5.3. Address Mobility
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.3. アドレスモビリティ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sessions are demultiplexed with a 32-bit session ID, rather than by endpoint address. This allows an endpoint&#39;s address to change during an S_OPEN session. This can happen, for example, when switching from a wireless to a wired network, or when moving from one wireless base station to another, or when a NAT restarts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションは、エンドポイントアドレスではなく、32ビットセッションIDで逆多重化されます。これにより、S_OPENセッション中にエンドポイントのアドレスを変更できます。これは、たとえば、ワイヤレスネットワークから有線ネットワークに切り替えるとき、1つのワイヤレスベースステーションから別のベースステーションに移動するとき、またはNATが再起動するときに発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the near end receives a valid packet for an S_OPEN session from a source address that doesn&#39;t match DESTADDR, the far end might have changed addresses. The near end SHOULD verify that the far end is definitively at the new address before changing DESTADDR. A suggested verification method is described in Section 3.5.4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
近端がDESTADDRと一致しない送信元アドレスからS_OPENセッションの有効なパケットを受信した場合、遠端がアドレスを変更している可能性があります。 DESTADDRを変更する前に、近端は遠端が確実に新しいアドレスにあることを確認する必要があります。推奨される検証方法は、セクション3.5.4.2で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-4--Ping">
3.5.4. Ping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.4. ping
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an endpoint receives a Ping chunk (Section 2.3.9) in a session in the S_OPEN state, it SHOULD construct and send a Ping Reply chunk (Section 2.3.10) in response if possible, copying the message unaltered. The Ping Reply SHOULD be sent as quickly as possible following receipt of a Ping. The semantics of a Ping&#39;s message is reserved for the sender; a receiver SHOULD NOT interpret the Ping&#39;s message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントがS_OPEN状態のセッションでPingチャンク（セクション2.3.9）を受信した場合、可能であれば応答としてPing応答チャンク（セクション2.3.10）を構築して送信し、メッセージを変更せずにコピーする必要があります。 Ping応答は、Pingの受信後、可能な限り迅速に送信する必要があります（SHOULD）。 Pingのメッセージのセマンティクスは送信者用に予約されています。受信者はPingのメッセージを解釈すべきではありません（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints can use the mechanism of the Ping chunk and the expected Ping Reply for any purpose. This specification doesn&#39;t mandate any specific constraints on the format or semantics of a Ping message. A Ping Reply MUST be sent only as a response to a Ping.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、任意の目的でPingチャンクのメカニズムと予想されるPing応答を使用できます。この仕様では、Pingメッセージの形式やセマンティクスに特定の制約を課していません。 Ping応答は、Pingへの応答としてのみ送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Receipt of a Ping Reply implies live bidirectional connectivity. This specification doesn&#39;t mandate any other semantics for a Ping Reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ping応答の受信は、ライブの双方向接続を意味します。この仕様では、Ping応答のその他のセマンティクスは必須ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-4-1--Keepalive">
3.5.4.1. Keepalive
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.4.1. 生き続ける
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint can use a Ping to test for live bidirectional connectivity, to test that the far end of a session is still in the S_OPEN state, to keep NAT translations alive, and to keep firewall holes open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントはPingを使用して、ライブの双方向接続をテストし、セッションの遠端がまだS_OPEN状態であることをテストし、NAT変換を維持し、ファイアウォールホールを開いたままにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint can use a Ping to hasten detection of a near-end address change by the far end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントはPingを使用して、遠端による近端アドレス変更の検出を速めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint may declare a session to be defunct and dead after a persistent failure by the far end to return Ping Replies in response to Pings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、Pingに応答してPing応答を返すために、遠端で永続的な障害が発生した後、セッションが非アクティブであると宣言する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If used for these purposes, a Keepalive Ping SHOULD have an empty message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの目的で使用する場合、キープアライブpingには空のメッセージが必要です（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Keepalive Ping SHOULD NOT be sent more often than once per ERTO. If a corresponding Ping Reply is not received within ERTO of sending the Ping, ERTO SHOULD be increased according to Section 3.5.2 (&#34;Congestion Control&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キープアライブpingは、ERTOごとに複数回送信するべきではありません。対応するPing応答がpingを送信したERTO内で受信されない場合、ERTOはセクション3.5.2（「輻輳制御」）に従って増加する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-4-2--Address-Mobility">
3.5.4.2. Address Mobility
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.4.2. アドレスモビリティ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes an OPTIONAL but suggested method for processing and verifying a far-end address change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、オプションですが、遠端アドレスの変更を処理および確認するための推奨方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the session context contain additional variables MOB_TX_TS, MOB_RX_TS, and MOB_SECRET. MOB_TX_TS and MOB_RX_TS have initial values of negative infinity. MOB_SECRET should be a cryptographically pseudorandom value not less than 128 bits in length and known only to this end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションコンテキストに追加の変数MOB_TX_TS、MOB_RX_TS、およびMOB_SECRETを含めます。 MOB_TX_TSおよびMOB_RX_TSの初期値は負の無限大です。 MOB_SECRETは、128ビット以上の長さの暗号化された疑似ランダム値であり、この目的でのみ知られている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of a packet for an S_OPEN session, after processing all chunks in the packet: if the session is still in the S_OPEN state, AND the source address of the packet does not match DESTADDR, AND MOB_TX_TS is at least one second in the past, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_OPENセッションのパケットを受信したとき、パケット内のすべてのチャンクを処理した後：セッションがまだS_OPEN状態であり、かつパケットの送信元アドレスがDESTADDRと一致せず、MOB_TX_TSが過去1秒以上である場合、次に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Set MOB_TX_TS to the current time;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. MOB_TX_TSを現在の時刻に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Construct a Ping message comprising the following: a marking to indicate (to this end when returned in a Ping Reply) that it is a mobility check (for example, the first byte being ASCII &#39;M&#39; for &#34;Mobility&#34;), a timestamp set to MOB_TX_TS, and a cryptographic hash over the following: the preceding items, the address from which the packet was received, and MOB_SECRET; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 次を含むPingメッセージを作成します：（Ping応答で返されたときにこの目的のために）モビリティチェックであることを示すマーキング（たとえば、最初のバイトは「モビリティ」のASCII &#39;M&#39;です）、タイムスタンプセットMOB_TX_TS、および次の暗号化ハッシュ：前の項目、パケットの受信元のアドレス、およびMOB_SECRET。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Send this Ping to the address from which the packet was received, instead of DESTADDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. このPingを、DESTADDRではなく、パケットの受信元のアドレスに送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of a Ping Reply in an S_OPEN session, if the Ping Reply&#39;s message satisfies all of these conditions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_OPENセッションでPing返信を受信したとき、Ping返信のメッセージが次のすべての条件を満たす場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o it has this end&#39;s expected marking to indicate that it is a mobility check, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o これは、モビリティチェックであることを示すために、この端の予想されるマーキングを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the timestamp in the message is not more than 120 seconds in the past, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o メッセージのタイムスタンプが過去120秒以下であり、かつ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the timestamp in the message is greater than MOB_RX_TS, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o メッセージのタイムスタンプがMOB_RX_TSより大きい、および
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the cryptographic hash matches the expected value according to the contents of the message plus the source address of the packet containing this Ping Reply and MOB_SECRET,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 暗号化ハッシュは、メッセージの内容と、このPing応答およびMOB_SECRETを含むパケットの送信元アドレスに従って、期待値と一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Set MOB_RX_TS to the timestamp in the message; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. MOB_RX_TSをメッセージのタイムスタンプに設定します。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Set DESTADDR to the source address of the packet containing this Ping Reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. DESTADDRを、このPing応答を含むパケットの送信元アドレスに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-4-3--Path-MTU-Discovery">
3.5.4.3. Path MTU Discovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.4.3. パスMTUディスカバリー
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;Packetization Layer Path MTU Discovery&#34; [RFC4821] describes a method for measuring the path MTU between communicating endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「Packetization Layer Path MTU Discovery」[RFC4821]では、通信するエンドポイント間のパスMTUを測定する方法について説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An RTMFP SHOULD perform path MTU discovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPは、パスMTU検出を実行する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The method described in RFC 4821 can be adapted for use in RTMFP by sending a probe packet comprising one of the Padding chunk types (type 0x00 or 0xff) and a Ping. The Ping chunk SHOULD come after the Padding chunk, to guard against a false positive response in case the probe packet is truncated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 4821で説明されている方法は、パッディングチャンクタイプ（タイプ0x00または0xff）の1つとPingを含むプローブパケットを送信することにより、RTMFPでの使用に適合させることができます。 Pingチャンクは、プローブパケットが切り捨てられた場合の誤検知から保護するために、Paddingチャンクの後に来る必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-5--Close">
3.5.5. Close
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.5. 閉じる
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint may close a session at any time. Typically, an endpoint will close a session when there have been no open flows in either direction for a time. In another circumstance, an endpoint may be ceasing operation and will close all of its sessions even if they have open flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントはいつでもセッションを閉じることができます。通常、エンドポイントは、どちらかの方向に開いているフローがしばらくなかった場合にセッションを閉じます。別の状況では、エンドポイントが操作を停止している可能性があり、フローが開いていても、すべてのセッションを閉じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To close an S_OPEN session in a reliable and orderly fashion, an endpoint moves the session to the S_NEARCLOSE state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_OPENセッションを信頼性の高い規則的な方法で閉じるために、エンドポイントはセッションをS_NEARCLOSE状態に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On a session transitioning from S_OPEN to S_NEARCLOSE and every 5 seconds thereafter while still in the S_NEARCLOSE state, send a Session Close Request chunk (Section 2.3.17).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_OPENからS_NEARCLOSEに移行するセッションで、その後S_NEARCLOSE状態のまま5秒ごとに、Session Close Requestチャンクを送信します（セクション2.3.17）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A session that has been in the S_NEARCLOSE state for at least 90 seconds (allowing time to retransmit the Session Close Request multiple times) SHOULD move to the S_CLOSED state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
少なくとも90秒間S_NEARCLOSE状態にあったセッション（セッションクローズリクエストを複数回再送信できる時間を許容）は、S_CLOSED状態に移行する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On a session transitioning from S_OPEN to the S_NEARCLOSE, S_FARCLOSE_LINGER or S_CLOSED state, immediately abort and terminate all open or closing flows. Flows only exist in S_OPEN sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_OPENからS_NEARCLOSE、S_FARCLOSE_LINGERまたはS_CLOSED状態に移行するセッションでは、すべてのオープンまたはクローズフローをただちに中止して終了します。フローはS_OPENセッションにのみ存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To close an S_OPEN session abruptly, send a Session Close Acknowledgement chunk (Section 2.3.18), then move to the S_CLOSED state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_OPENセッションを突然閉じるには、Session Close Acknowledgementチャンクを送信し（セクション2.3.18）、S_CLOSED状態に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of a Session Close Request chunk for a session in the S_OPEN, S_NEARCLOSE, or S_FARCLOSE_LINGER states, send a Session Close Acknowledgement chunk; then, if the session is in the S_OPEN state, move to the S_FARCLOSE_LINGER state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_OPEN、S_NEARCLOSE、またはS_FARCLOSE_LINGER状態のセッションのSession Close Requestチャンクを受信すると、Session Close Acknowledgementチャンクを送信します。次に、セッションがS_OPEN状態の場合は、S_FARCLOSE_LINGER状態に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A session that has been in the S_FARCLOSE_LINGER state for at least 19 seconds (allowing time to answer 3 retransmissions of a Session Close Request) SHOULD move to the S_CLOSED state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
少なくとも19秒間S_FARCLOSE_LINGER状態にあるセッション（セッションクローズリクエストの3回の再送信に応答する時間がある）は、S_CLOSED状態に移行する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of a Session Close Acknowledgement chunk for a session in the S_OPEN, S_NEARCLOSE, or S_FARCLOSE_LINGER states, move to the S_CLOSED state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_OPEN、S_NEARCLOSE、またはS_FARCLOSE_LINGER状態のセッションのSession Close Acknowledgementチャンクを受信すると、S_CLOSED状態に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6--Flows">
3.6. Flows
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. 流れ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A flow is a unidirectional communication channel in a session for transporting a correlated series of user messages from a sender to a receiver. Each end of a session may have zero or more sending flows to the other end. Each sending flow at one end has a corresponding receiving flow at the other end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローは、相関関係のある一連のユーザーメッセージを送信者から受信者に転送するためのセッション内の一方向通信チャネルです。セッションの両端には、もう一方の端への送信フローがゼロ以上ある場合があります。一端の各送信フローには、他端に対応する受信フローがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-1--Overview">
3.6.1. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.1. 概観
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-1-1--Identity">
3.6.1.1. Identity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.1.1. 身元
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flows are multiplexed in a session by a flow identifier. Each end of a session chooses its sending flow identifiers independently of the other end. The choice of similar flow identifiers by both ends does not imply an association. A sender MAY choose any identifier for any flow; therefore, a flow receiver MUST NOT ascribe any semantic meaning, role, or name to a flow based only on its identifier. There are no &#34;well known&#34; or reserved flow identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローは、セッション内でフロー識別子によって多重化されます。セッションの両端は、他端とは無関係に送信フロー識別子を選択します。両端で同様のフロー識別子を選択しても、関連付けを意味するわけではありません。送信者は、任意のフローの任意の識別子を選択できます。したがって、フローレシーバーは、識別子のみに基づいてフローに意味的な意味、役割、または名前を割り当ててはなりません（MUST NOT）。 「既知の」または予約済みのフロー識別子はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bidirectional flow association is indicated at flow startup with the Return Flow Association option (Section 2.3.11.1.2). An endpoint can indicate that a new sending flow is in return (or response) to a receiving flow from the other end. A sending flow MUST NOT indicate more than one return association. A receiving flow can be specified as the return association for any number of sending flows. The return flow association, if any, is fixed for the lifetime of the sending flow. Note: Closure of one flow in an association does not automatically close other flows in the association, except as specified in Section 3.6.3.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
双方向のフローの関連付けは、フローの開始時にReturn Flow Associationオプション（セクション2.3.11.1.2）で示されます。エンドポイントは、新しい送信フローが相手側からの受信フローの見返り（または応答）であることを示すことができます。送信フローは、複数のリターンアソシエーションを示してはなりません。受信フローは、任意の数の送信フローのリターンアソシエーションとして指定できます。リターンフローの関連付けがある場合は、送信フローのライフタイムの間固定されます。注：セクション3.6.3.1で指定されている場合を除き、アソシエーション内の1つのフローを閉じても、アソシエーション内の他のフローは自動的に閉じません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flows are named with arbitrary user metadata. This specification doesn&#39;t mandate any particular encoding, syntax, or semantics for the user metadata, except for the encoded size (Section 2.3.11.1.1); the user metadata is entirely reserved for the application. The user metadata is fixed for the lifetime of the flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローには、任意のユーザーメタデータを使用して名前が付けられます。この仕様では、エンコードされたサイズ（セクション2.3.11.1.1）を除いて、ユーザーメタデータの特定のエンコード、構文、またはセマンティクスを義務付けていません。ユーザーメタデータは完全にアプリケーション用に予約されています。ユーザーメタデータは、フローの存続期間中固定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-1-2--Messages-and-Sequencing">
3.6.1.2. Messages and Sequencing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.1.2. メッセージとシーケンス
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flows provide message-oriented framing. Large messages are fragmented for transport in the network. Receivers reassemble fragmented messages and only present complete messages to the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローはメッセージ指向のフレーミングを提供します。大きなメッセージは、ネットワークでの転送のために断片化されます。受信者は断片化されたメッセージを再構成し、完全なメッセージのみをユーザーに提示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender queues messages on a sending flow one after another. A receiver can recover the original queuing order of the messages, even when they are reordered in transit by the network or as a result of loss and retransmission, by means of the messages&#39; fragment sequence numbers. Flows are the basic units of message sequencing; each flow is sequenced independently of all other flows; inter-flow message arrival and delivery sequencing are not guaranteed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は、送信フローのメッセージを次々にキューに入れます。受信者は、メッセージのフラグメントシーケンス番号を使用して、ネットワークで転送中に再順序付けされた場合や、損失と再送信の結果として、メッセージの元のキューイング順序を回復できます。フローはメッセージシーケンスの基本単位です。各フローは、他のすべてのフローとは無関係に順序付けられます。フロー間メッセージの到着と配信の順序付けは保証されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Independent flow sequencing allows a sender to prioritize the transmission or retransmission of the messages of one flow over those of other flows in a session, allocating capacity from the transmission budget according to priority. RTMFP is designed for flows to be the basic unit of prioritization. In any flow, fragment sequence numbers are unique and monotonically increasing; that is, the fragment sequence numbers for any message MUST be greater than the fragment sequence numbers of all messages previously queued in that flow. Receipt of fragments out of sequence number order within a flow creates discontiguous gaps at the receiver, causing it to send an acknowledgement for every packet and also causing the size of the encoded acknowledgements to grow. Therefore, for any flow, the sender SHOULD send lower sequence numbers first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
独立したフローシーケンスにより、送信者はセッション内の他のフローのメッセージよりも1つのフローのメッセージの送信または再送信を優先し、優先度に従って送信バジェットから容量を割り当てることができます。 RTMFPは、フローが優先順位付けの基本単位になるように設計されています。どのフローでも、フラグメントのシーケンス番号は一意で単調に増加します。つまり、メッセージのフラグメントシーケンス番号は、そのフローで以前にキューに入れられたすべてのメッセージのフラグメントシーケンス番号よりも大きい必要があります。フロー内のシーケンス番号順以外のフラグメントを受信すると、レシーバーに不連続なギャップが生じ、パケットごとに確認応答が送信され、エンコードされた確認応答のサイズも大きくなります。したがって、どのフローでも、送信者は最初に小さいシーケンス番号を送信する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A sender can abandon a queued message at any time, even if some fragments of that message have been received by the other end. A receiver MUST be able to detect a gap in the flow when a message is abandoned; therefore, each message SHOULD take at least one sequence number from the sequence space even if no fragments for that message are ever sent. The sender will transmit the fragments of all messages not abandoned, and retransmit any lost fragments of all messages not abandoned, until all the fragments of all messages not abandoned are acknowledged by the receiver. A sender indicates a Forward Sequence Number (FSN) to instruct the receiver that sequence numbers less than or equal to the FSN will not be transmitted or retransmitted. This allows the receiver to move forward over gaps and continue sequenced delivery of completely received messages to the user. Any incomplete messages missing fragments with sequence numbers less than or equal to the FSN were abandoned by the sender and will never be completed. A gap indication MUST be communicated to the receiving user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
送信者は、キューに入れられたメッセージの一部が相手側で受信されていても、いつでもキューに入れられたメッセージを破棄できます。受信者は、メッセージが破棄されたときにフローのギャップを検出できなければなりません（MUST）。したがって、そのメッセージのフラグメントが送信されない場合でも、各メッセージはシーケンススペースから少なくとも1つのシーケンス番号を取得する必要があります（SHOULD）。放棄されていないすべてのメッセージのフラグメントが受信者によって確認されるまで、送信者は放棄されていないすべてのメッセージのフラグメントを送信し、放棄されていないすべてのメッセージの失われたフラグメントを再送信します。送信者は、FSN以下のシーケンス番号が送信または再送信されないことを受信者に指示するために、転送シーケンス番号（FSN）を示します。これにより、受信者はギャップを越えて前進し、完全に受信されたメッセージをユーザーに順次配信し続けることができます。 FSN以下のシーケンス番号を持つフラグメントが欠落している不完全なメッセージは、送信者によって破棄され、決して完了しません。ギャップ表示は、受信ユーザーに通知されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-1-3--Lifetime">
3.6.1.3. Lifetime
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.1.3. 一生
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender begins a flow by sending user message fragments to the other end, and including the user metadata and, if any, the return flow association. The sender continues to include the user metadata and return flow association until the flow is acknowledged by the far end, at which point the sender knows that the receiver has received the user metadata and, if any, the return flow association. After that point, the flow identifier alone is sufficient.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は、ユーザーメッセージフラグメントを相手側に送信し、ユーザーメタデータと、もしあればリターンフローの関連付けを含めて、フローを開始します。送信側は、フローが遠端で確認されるまで、ユーザーメタデータと戻りフローの関連付けを続けます。その時点で、送信側は、受信者がユーザーメタデータと、もしあれば戻りフローの関連付けを受信したことを認識します。その後は、フロー識別子だけで十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow receivers SHOULD acknowledge all sequence numbers received for any flow, whether the flow is accepted or rejected. Flow receivers MUST NOT acknowledge sequence numbers higher than the FSN that were not received. Acknowledgements drive the congestion control and avoidance algorithms and therefore must be accurate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローレシーバーは、フローが受け入れられるか拒否されるかにかかわらず、任意のフローに対して受信されたすべてのシーケンス番号を確認する必要があります。フローレシーバーは、受信されなかったFSNよりも大きいシーケンス番号を確認してはなりません（MUST NOT）。承認は、輻輳制御および回避アルゴリズムを推進するため、正確でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint can reject a receiving flow at any time in the flow&#39;s lifetime. To reject the flow, the receiving endpoint sends a Flow Exception Report chunk (Section 2.3.16) immediately preceding every acknowledgement chunk for the rejected receiving flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、フローの存続期間中いつでも受信フローを拒否できます。フローを拒否するために、受信エンドポイントは、拒否された受信フローのすべての確認応答チャンクの直前にフロー例外レポートチャンク（2.3.16節）を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint may eventually conclude and close a sending flow. The last sequence number of the flow is marked with the Final flag. The sending flow is complete when all sequence numbers of the flow, including the final sequence number, have been cumulatively acknowledged by the receiver. The receiving flow is complete when every sequence number from the FSN to the final sequence number has been received. The sending flow and corresponding receiving flow at the respective ends hold the flow identifier of a completed flow in reserve for a time to allow delayed or duplicated fragments and acknowledgements to drain from the network without erroneously initiating a new receiving flow or erroneously acknowledging a new sending flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは最終的に送信フローを完了して閉じる場合があります。フローの最後のシーケンス番号は、Finalフラグでマークされます。最終シーケンス番号を含むフローのすべてのシーケンス番号が受信者によって累積的に確認されると、送信フローは完了です。 FSNから最終シーケンス番号までのすべてのシーケンス番号が受信されると、受信フローが完了します。それぞれの端での送信フローと対応する受信フローは、新しい受信フローを誤って開始したり、新しい送信を誤って確認したりせずに、遅延または複製されたフラグメントと確認応答をネットワークから排出できるように、完了したフローのフロー識別子を一定時間確保します。フロー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a flow sender receives a Flow Exception indication from the other end, the flow sender SHOULD close the flow and abandon all of the undelivered queued messages. The flow sender SHOULD indicate an exception to the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローセンダーがもう一方の端からフロー例外の指示を受信した場合、フローセンダーはフローを閉じて、配信されなかったすべてのキューに入れられたメッセージを破棄する必要があります。フロー送信者は、ユーザーに例外を示す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2--Sender">
3.6.2. Sender
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2. 送信者
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each sending flow comprises the flow-specific information context necessary to transfer that flow&#39;s messages to the other end. Each sending flow context includes at least:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各送信フローは、そのフローのメッセージを相手側に転送するために必要なフロー固有の情報コンテキストで構成されます。各送信フローコンテキストには、少なくとも次のものが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o F_FLOW_ID: this flow&#39;s identifier;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o F_FLOW_ID：このフローの識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o STARTUP_OPTIONS: the set of options to send to the receiver until this flow is acknowledged, including the User&#39;s Per-Flow Metadata and, if set, the Return Flow Association;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o STARTUP_OPTIONS：このフローが確認されるまで受信者に送信するオプションのセット。ユーザーのフローごとのメタデータと、設定されている場合はリターンフローの関連付けを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SEND_QUEUE: the unacknowledged message fragments queued in this flow, initially empty; each message fragment entry comprising the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SEND_QUEUE：このフローでキューに入れられた未確認のメッセージフラグメント。最初は空です。以下を含む各メッセージフラグメントエントリ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* SEQUENCE_NUMBER: the sequence number of this fragment;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* SEQUENCE_NUMBER：このフラグメントのシーケンス番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* DATA: this fragment&#39;s user data;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* DATA：このフラグメントのユーザーデータ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* FRA: the fragment control value for this message fragment, having one of the values enumerated for that purpose in Section 2.3.11 (&#34;User Data Chunk&#34;);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* FRA：このメッセージフラグメントのフラグメント制御値。セクション2.3.11（「ユーザーデータチャンク」）でその目的のために列挙された値の1つを持ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ABANDONED: a boolean flag indicating whether this fragment has been abandoned;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ABANDONED：このフラグメントが破棄されたかどうかを示すブールフラグ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* SENT_ABANDONED: a boolean flag indicating whether this fragment was abandoned when sent;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* SENT_ABANDONED：このフラグメントが送信時に破棄されたかどうかを示すブールフラグ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* EVER_SENT: a boolean flag indicating whether this fragment has been sent at least once, initially false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* EVER_SENT：このフラグメントが少なくとも1回送信されたかどうかを示すブールフラグ。最初はfalse。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* NAK_COUNT: a count of the number of negative acknowledgements detected for this fragment, initially 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* NAK_COUNT：このフラグメントに対して検出された否定応答の数のカウント。最初は0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* IN_FLIGHT: a boolean flag indicating whether this fragment is currently outstanding, or in flight, in the network, initially false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* IN_FLIGHT：このフラグメントがネットワークで現在未解決であるか、処理中かを示すブールフラグ。最初はfalse。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* TRANSMIT_SIZE: the size, in bytes, of the encoded User Data chunk (including the chunk header) for this fragment when it was transmitted into the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* TRANSMIT_SIZE：このフラグメントがネットワークに送信されたときの、このフラグメントのエンコードされたユーザーデータチャンク（チャンクヘッダーを含む）のサイズ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o F_OUTSTANDING_BYTES: the sum of the TRANSMIT_SIZE of each entry in SEND_QUEUE where entry.IN_FLIGHT is true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o F_OUTSTANDING_BYTES：SEND_QUEUEの各エントリのTRANSMIT_SIZEの合計。ここで、entry.IN_FLIGHTはtrueです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RX_BUFFER_SIZE: the most recent available buffer advertisement from the other end (Sections 2.3.13 and 2.3.14), initially 65536 bytes;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RX_BUFFER_SIZE：もう一方の端からの利用可能な最新のバッファー通知（セクション2.3.13および2.3.14）、最初は65536バイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NEXT_SN: the next sequence number to assign to a message fragment, initially 1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NEXT_SN：メッセージフラグメントに割り当てる次のシーケンス番号。最初は1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o F_FINAL_SN: the sequence number assigned to the final message fragment of the flow, initially having no value;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o F_FINAL_SN：フローの最後のメッセージフラグメントに割り当てられたシーケンス番号。最初は値がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o EXCEPTION: a boolean flag indicating whether an exception has been reported by the receiver, initially false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o EXCEPTION：レシーバーによって例外が報告されたかどうかを示すブールフラグ。最初はfalse。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The state, at any time being one of the following values: the open state F_OPEN; the closing states F_CLOSING and F_COMPLETE_LINGER; and the closed state F_CLOSED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 常に次のいずれかの値の状態。オープン状態F_OPEN;終了状態F_CLOSINGおよびF_COMPLETE_LINGER;閉じた状態F_CLOSED。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: The following diagram is only a summary of state transitions and their causing events, and is not a complete operational specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：以下の図は、状態遷移とその原因となるイベントの要約にすぎず、完全な運用仕様ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                 +--------+
                                 | F_OPEN |
                                 +--------+
                                      |CLOSE or
                                      |rcv Flow Exception
                                      |
                                      v
                                 +---------+
                                 |F_CLOSING|
                                 +---------+
                                      |rcv Data Ack
                                      |  0..F_FINAL_SN
                                      v
                             +-----------------+
                             |F_COMPLETE_LINGER|
                             +-----------------+
                                      | 130 seconds
                                      v
                                  +--------+
                                  |F_CLOSED|
                                  +--------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
Figure 19: Sending Flow State Diagram
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
図19：フロー状態図の送信
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2-1--Startup">
3.6.2.1. Startup
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.1. 起動
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application opens a new sending flow to the other end in an S_OPEN session. The implementation chooses a new flow ID that is not assigned to any other sending flow in that session in the F_OPEN, F_CLOSING, or F_COMPLETE_LINGER states. The flow starts in the F_OPEN state. The STARTUP_OPTIONS for the new flow is set with the User&#39;s Per-Flow Metadata (Section 2.3.11.1.1). If this flow is in return (or response) to a receiving flow from the other end, that flow&#39;s ID is encoded in a Return Flow Association (Section 2.3.11.1.2) option and added to STARTUP_OPTIONS. A new sending flow SHOULD NOT be opened in response to a receiving flow from the other end that is not in the RF_OPEN state when the sending flow is opened.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、S_OPENセッションで、もう一方の端への新しい送信フローを開きます。実装は、F_OPEN、F_CLOSING、またはF_COMPLETE_LINGER状態で、そのセッションの他の送信フローに割り当てられていない新しいフローIDを選択します。フローはF_OPEN状態で開始されます。新しいフローのSTARTUP_OPTIONSは、ユーザーのフローごとのメタデータで設定されます（セクション2.3.11.1.1）。このフローが相手側からの受信フローへの返信（または応答）である場合、そのフローのIDはReturn Flow Association（セクション2.3.11.1.2）オプションでエンコードされ、STARTUP_OPTIONSに追加されます。送信フローが開かれるときにRF_OPEN状態にない他端からの受信フローに応答して、新しい送信フローを開く必要があります（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At this point, the flow exists in the sender but not in the receiver. The flow begins when user data fragments are transmitted to the receiver. A sender can begin a flow in the absence of immediate user data by sending a Forward Sequence Number Update (Section 3.6.2.7.1), by queuing and transmitting a user data fragment that is already abandoned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この時点で、フローは送信側に存在しますが、受信側には存在しません。フローは、ユーザーデータフラグメントが受信者に送信されたときに始まります。送信者は、すでに破棄されているユーザーデータフラグメントをキューに入れて送信することにより、転送シーケンス番号更新（3.6.2.7.1項）を送信することにより、即時のユーザーデータがない場合にフローを開始できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2-2--Queuing-Data">
3.6.2.2. Queuing Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.2. データのキューイング
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application queues messages in an F_OPEN sending flow for transmission to the far end. The implementation divides each message into one or more fragments for transmission in User Data chunks (Section 2.3.11). Each fragment MUST be small enough so that, if assembled into a packet (Section 2.2.4) with a maximum-size common header, User Data chunk header, and, if not empty, this flow&#39;s STARTUP_OPTIONS, the packet will not exceed the path MTU (Section 3.5.4.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、F_OPEN送信フローのメッセージをキューに入れ、遠端に送信します。実装では、ユーザーメッセージチャンクで送信するために、各メッセージを1つ以上のフラグメントに分割します（セクション2.3.11）。各フラグメントは、最大サイズの共通ヘッダー、ユーザーデータチャンクヘッダーを使用してパケット（セクション2.2.4）に組み立てられ、空でない場合、このフローのSTARTUP_OPTIONS、パケットがパスを超えないように、十分に小さい必要があります。 MTU（セクション3.5.4.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each fragment, create a fragment entry and set fragmentEntry.SEQUENCE_NUMBER to flow.NEXT_SN, and increment flow.NEXT_SN by one. Set fragmentEntry.FRA according to the encoding in User Data chunks:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメントごとに、フラグメントエントリを作成し、fragmentEntry.SEQUENCE_NUMBERをflow.NEXT_SNに設定し、flow.NEXT_SNを1増やします。ユーザーデータチャンクのエンコーディングに従って、fragmentEntry.FRAを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0: This fragment is a complete message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0：このフラグメントは完全なメッセージです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1: This fragment is the first of a multi-fragment message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1：このフラグメントは、マルチフラグメントメッセージの最初のものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2: This fragment is the last of a multi-fragment message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2：このフラグメントは、マルチフラグメントメッセージの最後です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3: This fragment is in the middle of a multi-fragment message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3：このフラグメントは、マルチフラグメントメッセージの途中にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Append fragmentEntry to flow.SEND_QUEUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragmentEntryをflow.SEND_QUEUEに追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2-3--Sending-Data">
3.6.2.3. Sending Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.3. データの送信
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sending flow is ready to transmit if the SEND_QUEUE contains at least one entry that is eligible to send, and if either RX_BUFFER_SIZE is greater than F_OUTSTANDING_BYTES or EXCEPTION is set to true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEND_QUEUEに送信に適格なエントリが少なくとも1つ含まれ、RX_BUFFER_SIZEがF_OUTSTANDING_BYTESより大きいか、EXCEPTIONがtrueに設定されている場合、送信フローは送信の準備ができています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A SEND_QUEUE entry is eligible to send if it is not IN_FLIGHT, AND at least one of the following conditions holds:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEND_QUEUEエントリは、IN_FLIGHTでなく、次の条件の少なくとも1つが満たされた場合に送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The entry is not ABANDONED; or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o エントリは放棄されていません。または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The entry is the first one in the SEND_QUEUE; or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o エントリはSEND_QUEUEの最初のエントリです。または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The entry&#39;s SEQUENCE_NUMBER is equal to flow.F_FINAL_SN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o エントリのSEQUENCE_NUMBERは、flow.F_FINAL_SNと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the session&#39;s transmission budget allows, a flow that is ready to transmit is selected for transmission according to the implementation&#39;s prioritization scheme. The manner of flow prioritization is not mandated by this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションの送信バジェットが許可する場合、実装の優先順位付けスキームに従って、送信準備ができているフローが送信用に選択されます。フローの優先順位付けの方法は、この仕様では必須ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Trim abandoned messages from the front of the queue, and find the Forward Sequence Number (FSN):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キューの前から破棄されたメッセージをトリミングし、転送シーケンス番号（FSN）を見つけます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. While the SEND_QUEUE contains at least two entries, AND the first entry is not IN_FLIGHT, AND the first entry is ABANDONED, remove and discard the first entry from the SEND_QUEUE;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. SEND_QUEUEに少なくとも2つのエントリが含まれ、かつ最初のエントリがIN_FLIGHTではなく、かつ最初のエントリがABANDONEDである場合、SEND_QUEUEから最初のエントリを削除して破棄します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If the first entry in the SEND_QUEUE is not abandoned, set FSN to entry.SEQUENCE_NUMBER - 1; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. SEND_QUEUEの最初のエントリが破棄されない場合は、FSNをentry.SEQUENCE_NUMBER-1に設定します。さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If the first entry in the SEND_QUEUE is IN_FLIGHT, AND entry.SENT_ABANDONED is false, set FSN to entry.SEQUENCE_NUMBER - 1; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. SEND_QUEUEの最初のエントリがIN_FLIGHTであり、かつentry.SENT_ABANDONEDがfalseの場合、FSNをentry.SEQUENCE_NUMBER-1に設定します。さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The first entry in the SEND_QUEUE is abandoned and either is not IN_FLIGHT or was already abandoned when sent; set FSN to entry.SEQUENCE_NUMBER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. SEND_QUEUEの最初のエントリは破棄され、IN_FLIGHTではないか、送信時に既に破棄されています。 FSNをentry.SEQUENCE_NUMBERに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The FSN MUST NOT be greater than any sequence number currently outstanding. The FSN MUST NOT be equal to any sequence number currently outstanding that was not abandoned when sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FSNは、現在未解決のシーケンス番号より大きくてはなりません（MUST NOT）。 FSNは、送信時に破棄されなかった、現在未解決のシーケンス番号と同じであってはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assemble user data chunks for this flow into a packet to send to the receiver. While enough space remains in the packet and the flow is ready to transmit:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このフローのユーザーデータチャンクをパケットにまとめて、レシーバーに送信します。パケットに十分なスペースが残っており、フローを送信する準備ができている間：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Starting at the head of the SEND_QUEUE, find the first eligible fragment entry;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. SEND_QUEUEの先頭から始めて、最初の適格なフラグメントエントリを見つけます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Encode the entry into a User Data chunk (Section 2.3.11) or, if possible (Section 3.6.2.3.2), a Next User Data chunk (Section 2.3.12);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. エントリをユーザーデータチャンク（セクション2.3.11）、または可能であれば（セクション3.6.2.3.2）、次のユーザーデータチャンク（セクション2.3.12）にエンコードします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If present, set chunk.flowID to flow.F_FLOW_ID;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 存在する場合は、chunk.flowIDをflow.F_FLOW_IDに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If present, set chunk.sequenceNumber to entry.SEQUENCE_NUMBER;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 存在する場合は、chunk.sequenceNumberをentry.SEQUENCE_NUMBERに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. If present, set chunk.fsnOffset to entry.SEQUENCE_NUMBER - FSN;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 存在する場合は、chunk.fsnOffsetをentry.SEQUENCE_NUMBER-FSNに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Set chunk.fragmentControl to entry.FRA;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. chunk.fragmentControlをentry.FRAに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Set chunk.abandon to entry.ABANDONED;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. chunk.abandonをentry.ABANDONEDに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. If entry.SEQUENCE_NUMBER equals flow.F_FINAL_SN, set chunk.final to true; else set chunk.final to false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. entry.SEQUENCE_NUMBERがflow.F_FINAL_SNと等しい場合、chunk.finalをtrueに設定します。それ以外の場合は、chunk.finalをfalseに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. If any options are being sent with this chunk, set chunk.optionsPresent to true, assemble the options into the chunk, and assemble a Marker to terminate the option list;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. このチャンクでオプションが送信されている場合は、chunk.optionsPresentをtrueに設定し、オプションをチャンクにアセンブルし、マーカーをアセンブルしてオプションリストを終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. If entry.ABANDONED is true, set chunk.userData to empty; otherwise, set chunk.userData to entry.DATA;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. entry.ABANDONEDがtrueの場合、chunk.userDataを空に設定します。それ以外の場合は、chunk.userDataをentry.DATAに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. If adding the assembled chunk to the packet would cause the packet to exceed the path MTU, do not assemble this chunk into the packet; enough space no longer remains in the packet; stop. Otherwise, continue:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. 組み立てられたチャンクをパケットに追加すると、パケットがパスMTUを超える場合は、このチャンクをパケットに組み立てないでください。パケットに十分なスペースが残っていない。やめる。それ以外の場合は続行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12. Set entry.IN_FLIGHT to true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12. entry.IN_FLIGHTをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
13. Set entry.EVER_SENT to true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
13. entry.EVER_SENTをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
14. Set entry.NAK_COUNT to 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
14. entry.NAK_COUNTを0に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
15. Set entry.SENT_ABANDONED to entry.ABANDONED;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
15. entry.SENT_ABANDONEDをentry.ABANDONEDに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
16. Set entry.TRANSMIT_SIZE to the size of the assembled chunk, including the chunk header;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
16. entry.TRANSMIT_SIZEを、組み立てられたチャンクのサイズ（チャンクヘッダーを含む）に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
17. Assemble this chunk into the packet; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
17. このチャンクをパケットに組み立てます。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
18. If this flow or entry is considered Time Critical (real-time), set the timeCritical flag in the packet header (Section 2.2.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
18. このフローまたはエントリがTime Critical（リアルタイム）と見なされる場合は、パケットヘッダーでtimeCriticalフラグを設定します（セクション2.2.4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Complete any other appropriate packet processing, and transmit the packet to the far end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他の適切なパケット処理を完了し、パケットを遠端に送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2-3-1--Startup-Options">
3.6.2.3.1. Startup Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.3.1. 起動オプション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If STARTUP_OPTIONS is not empty, then when assembling the FIRST User Data chunk for this flow into a packet, add the encoded STARTUP_OPTIONS to that chunk&#39;s option list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STARTUP_OPTIONSが空でない場合、このフローの最初のユーザーデータチャンクをパケットにアセンブルするときに、エンコードされたSTARTUP_OPTIONSをそのチャンクのオプションリストに追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2-3-2--Send-Next-Data">
3.6.2.3.2. Send Next Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.3.2. 次のデータを送信
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Next User Data chunk (Section 2.3.12) is a compact encoding for a user message fragment when multiple contiguous fragments are assembled into one packet. Using this chunk where possible can conserve space in a packet, potentially reducing transmission overhead or allowing additional information to be sent in a packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のユーザーデータチャンク（セクション2.3.12）は、複数の連続するフラグメントが1つのパケットにまとめられる場合のユーザーメッセージフラグメントのコンパクトなエンコーディングです。このチャンクを可能な限り使用すると、パケットのスペースを節約でき、送信オーバーヘッドを削減したり、パケットで追加情報を送信したりできるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If, after assembling a user message fragment of a flow into a packet (Section 3.6.2.3), the next eligible fragment to be selected for assembly into that packet belongs to the same flow, AND its sequence number is one greater than that of the fragment just assembled, it is RECOMMENDED that an implementation encode a Next User Data chunk instead of a User Data chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローのユーザーメッセージフラグメントをパケットにアセンブルした後（セクション3.6.2.3）、そのパケットにアセンブルするために選択される次の適格なフラグメントが同じフローに属し、そのシーケンス番号がフラグメントがアセンブルされたばかりの場合、実装はユーザーデータチャンクではなく次のユーザーデータチャンクをエンコードすることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The FIRST fragment of a flow assembled into a packet MUST be encoded as a User Data chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットに組み立てられたフローの最初のフラグメントは、ユーザーデータチャンクとしてエンコードする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2-4--Processing-Acknowledgements">
3.6.2.4. Processing Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.4. 謝辞の処理
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Data Acknowledgement Bitmap chunk (Section 2.3.13) or a Data Acknowledgement Ranges chunk (Section 2.3.14) encodes the acknowledgement of receipt of one or more sequence numbers of a flow, as well as the receiver&#39;s current receive window advertisement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ確認応答ビットマップチャンク（セクション2.3.13）またはデータ確認応答範囲チャンク（セクション2.3.14）は、フローの1つ以上のシーケンス番号の受信確認と受信者の現在の受信ウィンドウアドバタイズをエンコードします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an acknowledgement chunk for a sending flow:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信フローの確認応答チャンクを受信すると、次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Set PRE_ACK_OUTSTANDING_BYTES to flow.F_OUTSTANDING_BYTES;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. PRE_ACK_OUTSTANDING_BYTESをflow.F_OUTSTANDING_BYTES;に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Set flow.STARTUP_OPTIONS to empty;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. flow.STARTUP_OPTIONSを空に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Set flow.RX_BUFFER_SIZE to chunk.bufferBytesAvailable;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. flow.RX_BUFFER_SIZEをchunk.bufferBytesAvailableに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. For each sequence number encoded in the acknowledgement, if there is an entry in flow.SEND_QUEUE with that sequence number and its IN_FLIGHT is true, then remove the entry from flow.SEND_QUEUE; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 確認にエンコードされたシーケンス番号ごとに、flow.SEND_QUEUEにそのシーケンス番号のエントリがあり、そのIN_FLIGHTがtrueの場合、フローからエントリを削除します。SEND_QUEUE;そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Notify the congestion control and avoidance algorithms that PRE_ACK_OUTSTANDING_BYTES - flow.F_OUTSTANDING_BYTES were acknowledged. Note that negative acknowledgements (Section 3.6.2.5) affect &#34;TCP friendly&#34; congestion control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 輻輳制御および回避アルゴリズムにPRE_ACK_OUTSTANDING_BYTES-flow.F_OUTSTANDING_BYTESが確認されたことを通知します。否定応答（セクション3.6.2.5）は、「TCP対応」の輻輳制御に影響を与えることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2-5--Negative-Acknowledgement-and-Loss">
3.6.2.5. Negative Acknowledgement and Loss
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.5. 否定的な確認と損失
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A negative acknowledgement is inferred for an outstanding fragment if an acknowledgement is received for any other fragments sent after it in the same session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じセッションでその後に送信された他のフラグメントの確認応答を受信した場合、未解決のフラグメントに対して否定応答が推測されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation SHOULD consider a fragment to be lost once that fragment receives three negative acknowledgements. A lost fragment is no longer outstanding in the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、フラグメントが3つの否定応答を受信すると、フラグメントが失われたと見なす必要があります（SHOULD）。失われたフラグメントは、ネットワークで未処理ではなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following describes an OPTIONAL method for detecting negative acknowledgements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下では、否定応答を検出するためのオプションの方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the session track the order in which fragments are transmitted across all its sending flows by way of a monotonically increasing Transmission Sequence Number (TSN) recorded with each fragment queue entry each time that fragment is transmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのフラグメントが送信されるたびに各フラグメントキューエントリに記録された単調に増加する送信シーケンス番号（TSN）によって、すべての送信フローでフラグメントが送信される順序をセッションに追跡させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the session information context contain additional variables:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション情報コンテキストに追加の変数を含めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NEXT_TSN: the next TSN to record with a fragment&#39;s queue entry when it is transmitted, initially 1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NEXT_TSN：フラグメントの送信時にフラグメントのキューエントリで記録する次のTSN。最初は1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MAX_TSN_ACK: the highest acknowledged TSN, initially 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MAX_TSN_ACK：承認された最高のTSN、最初は0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let each fragment queue entry contain an additional variable TSN, initially 0, to track its transmission order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各フラグメントキューエントリに追加の変数TSN（最初は0）を含めて、その送信順序を追跡します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On transmission of a message fragment into the network, set its entry.TSN to session.NEXT_TSN, and increment session.NEXT_TSN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークへのメッセージフラグメントの送信時に、そのentry.TSNをsession.NEXT_TSNに設定し、session.NEXT_TSNを増分します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On acknowledgement of an outstanding fragment, if its entry.TSN is greater than session.MAX_TSN_ACK, set session.MAX_TSN_ACK to entry.TSN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未解決のフラグメントの確認時に、そのentry.TSNがsession.MAX_TSN_ACKより大きい場合は、session.MAX_TSN_ACKをentry.TSNに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 After processing all acknowledgements in a packet containing at least one acknowledgement, then for each sending flow in that session, for each entry in that flow&#39;s SEND_QUEUE, if entry.IN_FLIGHT is true and entry.TSN is less than session.MAX_TSN_ACK, increment entry.NAK_COUNT and notify the congestion control and avoidance algorithms that a negative acknowledgement was detected in this packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
少なくとも1つの確認応答を含むパケット内のすべての確認応答を処理した後、そのセッションの送信フローごとに、そのフローのSEND_QUEUEの各エントリについて、entry.IN_FLIGHTがtrueであり、entry.TSNがsession.MAX_TSN_ACKより小さい場合、エントリを増分します。 NAK_COUNTし、このパケットで否定応答が検出されたことを輻輳制御および回避アルゴリズムに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each sending flow in that session, for each entry in that flow&#39;s SEND_QUEUE, if entry.IN_FLIGHT is true and entry.NAK_COUNT is at least 3, that fragment was lost in the network and is no longer considered to be in flight. Set entry.IN_FLIGHT to false. Notify the congestion control and avoidance algorithms of the loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのセッションの各送信フローについて、そのフローのSEND_QUEUEの各エントリについて、entry.IN_FLIGHTがtrueであり、entry.NAK_COUNTが3以上の場合、そのフラグメントはネットワークで失われ、処理中ではないと見なされます。 entry.IN_FLIGHTをfalseに設定します。輻輳制御および回避アルゴリズムに損失を通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2-6--Timeout">
3.6.2.6. Timeout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.6. タイムアウト
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A fragment is considered lost and no longer in flight in the network if it has remained outstanding for at least ERTO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメントが少なくともERTOの間未解決のままである場合、フラグメントは失われたと見なされ、ネットワーク内で飛行中ではなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following describes an OPTIONAL method to manage transmission timeouts. This method REQUIRES that either burst avoidance (Section 3.5.2.3) is implemented or the implementation&#39;s congestion control and avoidance algorithms will eventually stop sending new fragments into the network if acknowledgements are persistently not received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、送信タイムアウトを管理するためのオプションの方法について説明します。この方法では、バースト回避（セクション3.5.2.3）が実装されているか、実装の輻輳制御および回避アルゴリズムが、確認応答が持続的に受信されない場合、最終的にネットワークへの新しいフラグメントの送信を停止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the session information context contain an alarm TIMEOUT_ALARM, initially unset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション情報コンテキストに、最初は設定されていないアラームTIMEOUT_ALARMを含めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On sending a packet containing at least one User Data chunk, set or reset TIMEOUT_ALARM to fire in ERTO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
少なくとも1つのユーザーデータチャンクを含むパケットを送信するときに、ERTOで起動するようにTIMEOUT_ALARMを設定またはリセットします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receiving a packet containing at least one acknowledgement, reset TIMEOUT_ALARM (if already set) to fire in ERTO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
少なくとも1つの確認応答を含むパケットを受信したら、TIMEOUT_ALARM（すでに設定されている場合）をリセットして、ERTOで起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When TIMEOUT_ALARM fires:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TIMEOUT_ALARMが発生したとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Set WAS_LOSS = false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. WAS_LOSS = falseを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. For each sending flow in the session, and for each entry in that flow&#39;s SEND_QUEUE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. セッションの各送信フロー、およびそのフローのSEND_QUEUEの各エントリについて：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
1. If entry.IN_FLIGHT is true, set WAS_LOSS = true; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
1. entry.IN_FLIGHTがtrueの場合、WAS_LOSS = trueを設定します。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2. Set entry.IN_FLIGHT to false.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2. entry.IN_FLIGHTをfalseに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If WAS_LOSS is true, perform ERTO backoff (Section 3.5.2.2); and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. WAS_LOSSがtrueの場合、ERTOバックオフ（セクション3.5.2.2）を実行します。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Notify the congestion control and avoidance algorithms of the timeout and, if WAS_LOSS is true, that there was loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. タイムアウトの輻輳制御および回避アルゴリズムに通知し、WAS_LOSSがtrueの場合は、損失があったことを通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2-7--Abandoning-Data">
3.6.2.7. Abandoning Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.7. データの破棄
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application can abandon queued messages at any time and for any reason. Example reasons include (but are not limited to) the following: one or more fragments of a message have remained in the SEND_QUEUE for longer than a specified message lifetime; a fragment has been retransmitted more than a specified retransmission limit; a prior message on which this message depends (such as a key frame in a prediction chain) was abandoned and not delivered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、キューに入れられたメッセージをいつでも理由を問わず破棄できます。理由の例には、以下が含まれます（これらに限定されません）。メッセージの1つ以上のフラグメントが、指定されたメッセージの存続期間よりも長くSEND_QUEUEに残っている。フラグメントが指定された再送信制限を超えて再送信されました。このメッセージが依存する以前のメッセージ（予測チェーンのキーフレームなど）は破棄され、配信されませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To abandon a message fragment, set its SEND_QUEUE entry&#39;s ABANDON flag to true. When abandoning a message fragment, abandon all fragments of the message to which it belongs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージフラグメントを破棄するには、SEND_QUEUEエントリのABANDONフラグをtrueに設定します。メッセージフラグメントを破棄する場合は、それが属するメッセージのすべてのフラグメントを破棄します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An abandoned fragment MUST NOT be un-abandoned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
破棄されたフラグメントは、放棄されてはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2-7-1--Forward-Sequence-Number-Update">
3.6.2.7.1. Forward Sequence Number Update
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.7.1. シーケンス番号更新の転送
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Abandoned data may leave gaps in the sequence number space of a flow. Gaps may cause the receiver to hold completely received messages for ordered delivery to allow for retransmission of the missing fragments. User Data chunks (Section 2.3.11) encode a Forward Sequence Number (FSN) to instruct the receiver that fragments with sequence numbers less than or equal to the FSN will not be transmitted or retransmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
破棄されたデータは、フローのシーケンス番号スペースにギャップを残す可能性があります。欠落があると、欠落しているフラグメントの再送信を可能にするために、受信者が完全に受信したメッセージを順序付けられた配信用に保持することがあります。ユーザーデータチャンク（セクション2.3.11）は、FSN以下のシーケンス番号を持つフラグメントが送信または再送信されないことを受信者に指示するために、転送シーケンス番号（FSN）をエンコードします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the receiver has gaps in the received sequence number space and no non-abandoned message fragments remain in the SEND_QUEUE, the sender SHOULD transmit a Forward Sequence Number Update (FSN Update) comprising a User Data chunk marked abandoned, whose sequence number is the FSN and whose fsnOffset is 0. An FSN Update allows the receiver to skip gaps that will not be repaired and deliver received messages to the user. An FSN Update may be thought of as a transmission or retransmission of abandoned sequence numbers without actually sending the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信者が受信したシーケンス番号スペースにギャップがあり、SEND_QUEUEに放棄されていないメッセージフラグメントが残っていない場合、送信者は、破棄されたとマークされたユーザーデータチャンクを含む転送シーケンス番号更新（FSN更新）を送信する必要があります（FSN更新） fsnOffsetが0のFSN更新を使用すると、受信者は修復されないギャップをスキップして、受信したメッセージをユーザーに配信できます。 FSN更新は、実際にデータを送信せずに、破棄されたシーケンス番号の送信または再送信と考えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The method described in Section 3.6.2.3 (&#34;Sending Data&#34;) generates FSN Updates when appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.6.2.3（「データの送信」）で説明されている方法は、必要に応じてFSN更新を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2-8--Examples">
3.6.2.8. Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.8. 例
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    Sender
      |                   :
    1 |&lt;---  Ack  ID=2, seq:0-16
    2 |---&gt;  Data ID=2, seq#=25, fsnOff=9 (fsn=16)
    3 |---&gt;  Data ID=2, seq#=26, fsnOff=10 (fsn=16)
    4 |&lt;---  Ack  ID=2, seq:0-18
    5 |---&gt;  Data ID=2, seq#=27, fsnOff=9 (fsn=18)
    6 |---&gt;  Data ID=2, seq#=28, fsnOff=10 (fsn=18)
      |                   :
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are 9 sequence numbers in flight with delayed acknowledgements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
進行中の9つのシーケンス番号があり、確認応答が遅れています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
Figure 20: Normal Flow with No Loss
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
図20：損失のない通常のフロー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    Sender
      |                   :
    1 |&lt;---  Ack  ID=3, seq:0-30
    2 |---&gt;  Data ID=3, seq#=45, fsnOff=15 (fsn=30)
    3 |&lt;---  Ack  ID=3, seq:0-30, 32 (nack 31:1)
    4 |---&gt;  Data ID=3, seq#=46, fsnOff=16 (fsn=30)
    5 |&lt;---  Ack  ID=3, seq:0-30, 32, 34 (nack 31:2, 33:1)
    6 |&lt;---  Ack  ID=3, seq:0-30, 32, 34-35 (nack 31:3=lost, 33:2)
    7 |---&gt;  Data ID=3, seq#=47, fsnOff=15 (fsn=32, abandon 31)
    8 |&lt;---  Ack  ID=3, seq:0-30, 32, 34-36 (nack 33:3=lost)
    9 |---&gt;  Data ID=3, seq#=33, fsnOff=1 (fsn=32, retransmit 33)
   10 |&lt;---  Ack  ID=3, seq:0-30, 32, 34-37
   11 |---&gt;  Data ID=3, seq#=48, fsnOff=16 (fsn=32)
      |                   :
      |      (continues through seq#=59)
      |                   :
   12 |---&gt;  Data ID=3, seq#=60, fsnOff=28(fsn=32)
   13 |&lt;---  Ack  ID=3, seq:0-30, 34-46
   14 |---&gt;  Data ID=3, seq#=61, fsnOff=29 (fsn=32)
   15 |&lt;---  Ack  ID=3, seq:0-32, 34-47
   16 |---&gt;  Data ID=3, seq#=62, fsnOff=30 (fsn=32)
   17 |&lt;---  Ack  ID=3, seq:0-47
   18 |---&gt;  Data ID=3, seq#=63, fsnOff=16 (fsn=47)
   19 |&lt;---  Ack  ID=3, seq:0-49
   20 |---&gt;  Data ID=3, seq#=64, fsnOff=15 (fsn=49)
      |                   :
   21 |&lt;---  Ack  ID=3, seq:0-59
   22 |&lt;---  Ack  ID=3, seq:0-59, 61 (nack 60:1)
   23 |&lt;---  Ack  ID=3, seq:0-59, 61-62 (nack 60:2)
   24 |&lt;---  Ack  ID=3, seq:0-59, 61-63 (nack 60:3=lost)
   25 |---&gt;  Data ID=3, ABN=1, seq#=60, fsnOff=0 (fsn=60, abandon 60)
   26 |&lt;---  Ack  ID=3, seq:0-59, 61-64
      |                   :
   27 |&lt;---  Ack  ID=3, seq:0-64
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow with sequence numbers 31, 33, and 60 lost in transit, and a pause at 64. 33 is retransmitted; 31 and 60 are abandoned. Note that line 25 is a Forward Sequence Number Update (Section 3.6.2.7.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス番号31、33、および60のフローは転送中に失われ、64で一時停止されます。33が再送信されます。 31と60は放棄されました。 25行目はForward Sequence Number Update（セクション3.6.2.7.1）であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-25">
Figure 21: Flow with Loss
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-25">
図21：損失のあるフロー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2-9--Flow-Control">
3.6.2.9. Flow Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.9. フロー制御
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow receiver advertises the amount of new data it&#39;s willing to accept from the flow sender with the bufferBytesAvailable derived field of an acknowledgement (Sections 2.3.13 and 2.3.14).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローレシーバーは、確認応答のbufferBytesAvailable派生フィールドを使用して、フローセンダーから受け入れることができる新しいデータの量を通知します（セクション2.3.13および2.3.14）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow sender MUST NOT send new data into the network if flow.F_OUTSTANDING_BYTES is greater than or equal to the most recently received buffer advertisement, unless flow.EXCEPTION is true (Section 3.6.2.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flow.EXCEPTIONがtrueでない限り、flow.F_OUTSTANDING_BYTESが最後に受信したバッファアドバタイズメント以上の場合、フロー送信者はネットワークに新しいデータを送信してはなりません（セクション3.6.2.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2-9-1--Buffer-Probe">
3.6.2.9.1. Buffer Probe
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.9.1. バッファープローブ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow sender is suspended if the most recently received buffer advertisement is zero and the flow hasn&#39;t been rejected by the receiver -- that is, while RX_BUFFER_SIZE is zero AND EXCEPTION is false. To guard against potentially lost acknowledgements that might reopen the receive window, a suspended flow sender SHOULD send a packet comprising a Buffer Probe chunk (Section 2.3.15) for this flow from time to time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に受信したバッファアドバタイズメントがゼロであり、フローがレシーバーによって拒否されていない場合、つまり、RX_BUFFER_SIZEがゼロであり、かつEXCEPTIONがfalseの場合、フローセンダーは中断されます。受信ウィンドウを再び開く可能性のある、失われた可能性のある確認応答を防ぐために、一時停止されたフロー送信者は、このフローのバッファプローブチャンク（セクション2.3.15）から構成されるパケットを時々送信する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the receive window advertisement transitions from non-zero to zero, the flow sender MAY send a Buffer Probe immediately and SHOULD send a probe within one second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信ウィンドウアドバタイズメントがゼロ以外からゼロに移行する場合、フロー送信側はすぐにバッファプローブを送信でき、1秒以内にプローブを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial period between Buffer Probes SHOULD be at least one second or ERTO, whichever is greater. The period between probes SHOULD increase over time, but the period between probes SHOULD NOT be more than one minute or ERTO, whichever is greater.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バッファープローブ間の初期期間は、少なくとも1秒またはERTOのいずれか大きい方である必要があります。プローブ間の期間は時間の経過とともに増加する必要がありますが、プローブ間の期間は1分またはERTOのいずれか長い方でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow sender SHOULD stop sending Buffer Probes if it is no longer suspended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローセンダーは、中断されなくなった場合、バッファープローブの送信を停止する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2-10--Exception">
3.6.2.10. Exception
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.10. 例外
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow receiver can reject the flow at any time and for any reason. The flow receiver sends a Flow Exception Report (Section 2.3.16) when it has rejected a flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローレシーバーは、いつでもどのような理由でもフローを拒否できます。フロー受信者は、フローを拒否すると、フロー例外レポート（2.3.16項）を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receiving a Flow Exception Report for a sending flow:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信フローのフロー例外レポートを受信すると：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the flow is F_OPEN, close the flow (Section 3.6.2.11) and notify the user that the far end reported an exception with the encoded exception code;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. フローがF_OPENの場合、フローを閉じ（3.6.2.11項）、遠端がエンコードされた例外コードで例外を報告したことをユーザーに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Set the EXCEPTION flag to true; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. EXCEPTIONフラグをtrueに設定します。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. For each entry in SEND_QUEUE, set entry.ABANDONED = true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. SEND_QUEUEの各エントリに対して、entry.ABANDONED = trueを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-2-11--Close">
3.6.2.11. Close
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.11. 閉じる
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sending flow is closed by the user or as a result of an exception. To close an F_OPEN flow:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信フローは、ユーザーによって、または例外の結果として閉じられました。 F_OPENフローを閉じるには：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Move to the F_CLOSING state;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. F_CLOSING状態に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If the SEND_QUEUE is not empty, AND the tail entry of the SEND_QUEUE has a sequence number of NEXT_SN - 1, AND the tail entry.EVER_SENT is false, set F_FINAL_SN to entry.SEQUENCE_NUMBER; else
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. SEND_QUEUEが空ではなく、かつSEND_QUEUEのテールエントリのシーケンス番号がNEXT_SN-1であり、テールエントリである場合。EVER_SENTがfalseの場合、F_FINAL_SNをentry.SEQUENCE_NUMBERに設定します。そうしないと
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The SEND_QUEUE is empty, OR the tail entry does not have a sequence number of NEXT_SN - 1, OR the tail entry.EVER_SENT is true: enqueue a new SEND_QUEUE entry with entry.SEQUENCE_NUMBER = flow.NEXT_SN, entry.FRA = 0, and entry.ABANDONED = true, and set flow.F_FINAL_SN to entry.SEQUENCE_NUMBER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. SEND_QUEUEが空であるか、末尾のエントリにNEXT_SN-1のシーケンス番号がないか、末尾のエントリがあります。EVER_SENTがtrueの場合：新しいSEND_QUEUEエントリをentry.SEQUENCE_NUMBER = flow.NEXT_SN、entry.FRA = 0、およびentry.ABANDONED = true、flow.F_FINAL_SNをentry.SEQUENCE_NUMBERに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An F_CLOSING sending flow is complete when its SEND_QUEUE transitions to empty, indicating that all sequence numbers, including the FINAL_SN, have been acknowledged by the other end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEND_QUEUEが空に遷移すると、F_CLOSING送信フローが完了します。これは、FINAL_SNを含むすべてのシーケンス番号が相手側によって確認されたことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an F_CLOSING sending flow becomes complete, move to the F_COMPLETE_LINGER state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
F_CLOSING送信フローが完了すると、F_COMPLETE_LINGER状態に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sending flow MUST remain in the F_COMPLETE_LINGER state for at least 130 seconds. After at least 130 seconds, move to the F_CLOSED state. The sending flow is now closed, its resources can be reclaimed, and its F_FLOW_ID MAY be used for a new sending flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信フローは、少なくとも130秒間F_COMPLETE_LINGER状態に留まる必要があります。 130秒以上経過したら、F_CLOSED状態に移行します。これで送信フローが閉じられ、そのリソースを再利用でき、そのF_FLOW_IDを新しい送信フローに使用できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3--Receiver">
3.6.3. Receiver
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3. 受信機
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each receiving flow comprises the flow-specific information context necessary to receive that flow&#39;s messages from the sending end and deliver completed messages to the user. Each receiving flow context includes at least:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各受信フローは、送信側からそのフローのメッセージを受信し、完了したメッセージをユーザーに配信するために必要なフロー固有の情報コンテキストを含みます。各受信フローコンテキストには、少なくとも次のものが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RF_FLOW_ID: this flow&#39;s identifier;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RF_FLOW_ID：このフローの識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SEQUENCE_SET: the set of all fragment sequence numbers seen in this receiving flow, whether received or abandoned, initially empty;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SEQUENCE_SET：この受信フローで見られるすべてのフラグメントシーケンス番号のセット。受信されたか破棄されたかに関係なく、最初は空です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RF_FINAL_SN: the final fragment sequence number of the flow, initially having no value;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RF_FINAL_SN：フローの最終フラグメントシーケンス番号。最初は値がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RECV_BUFFER: the message fragments waiting to be delivered to the user, sorted by sequence number in ascending order, initially empty; each message fragment entry comprising the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RECV_BUFFER：ユーザーに配信されるのを待っているメッセージフラグメント。昇順のシーケンス番号でソートされ、最初は空です。以下を含む各メッセージフラグメントエントリ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* SEQUENCE_NUMBER: the sequence number of this fragment;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* SEQUENCE_NUMBER：このフラグメントのシーケンス番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* DATA: this fragment&#39;s user data; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* DATA：このフラグメントのユーザーデータ。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* FRA: the fragment control value for this message fragment, having one of the values enumerated for that purpose in Section 2.3.11 (&#34;User Data Chunk&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* FRA：このメッセージフラグメントのフラグメントコントロール値。2.3.11節で目的のために列挙された値の1つ（「ユーザーデータチャンク」）を持ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o BUFFERED_SIZE: the sum of the lengths of each fragment in RECV_BUFFER plus any additional storage overhead for the fragments incurred by the implementation, in bytes;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o BUFFERED_SIZE：RECV_BUFFERの各フラグメントの長さの合計と、実装によって発生したフラグメントの追加のストレージオーバーヘッド（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o BUFFER_CAPACITY: the desired maximum size for the receive buffer, in bytes;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o BUFFER_CAPACITY：受信バッファーの望ましい最大サイズ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PREV_RWND: the most recent receive window advertisement sent in an acknowledgement, in 1024-byte blocks, initially having no value;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PREV_RWND：確認応答で送信された最新の受信ウィンドウアドバタイズメント（1024バイトブロック単位）。最初は値がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SHOULD_ACK: whether or not an acknowledgement should be sent for this flow, initially false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SHOULD_ACK：このフローに対して確認応答を送信するかどうか。最初はfalse。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o EXCEPTION_CODE: the exception code to report to the sender when the flow has been rejected, initially 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o EXCEPTION_CODE：フローが拒否されたときに送信者に報告する例外コード。最初は0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The state, at any time being one of the following values: the open state RF_OPEN; the closing states RF_REJECTED and RF_COMPLETE_LINGER; and the closed state RF_CLOSED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o いつでも次のいずれかの値の状態。オープン状態RF_OPEN;終了状態RF_REJECTEDおよびRF_COMPLETE_LINGER;閉じた状態RF_CLOSED。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: The following diagram is only a summary of state transitions and their causing events, and is not a complete operational specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：以下の図は、状態遷移とその原因となるイベントの要約にすぎず、完全な運用仕様ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                       +-+
                                       |X|
                                       +-+
                                        |rcv User Data for
                                        |  no existing flow
                                        v
                                   +---------+
                                   | RF_OPEN |
                                   +---------+
              rcv all sequence numbers|   |user reject,
                      0..RF_FINAL_SN  |   |rcv bad option,
                                      |   |no metadata at open,
                                      |   |association specified
                                      |   |  but not F_OPEN at open
                                  +---+   |
                                  |       v
                                  |  +-----------+
                                  |  |RF_REJECTED|
                                  |  +-----------+
                                  |       |rcv all sequence numbers
                                  |       |  0..RF_FINAL_SN
                                  v       v
                             +------------------+
                             |RF_COMPLETE_LINGER|
                             +------------------+
                                      | 120 seconds
                                      v
                                 +---------+
                                 |RF_CLOSED|
                                 +---------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Figure 22: Receiving Flow State Diagram
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
図22：受信フローの状態図
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-1--Startup">
3.6.3.1. Startup
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.1. 起動
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A new receiving flow starts on receipt of a User Data chunk (Section 2.3.11) encoding a flow ID not belonging to any other receiving flow in the same session in the RF_OPEN, RF_REJECTED, or RF_COMPLETE_LINGER states.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい受信フローは、RF_OPEN、RF_REJECTED、またはRF_COMPLETE_LINGER状態の同じセッションで他の受信フローに属さないフローIDをエンコードするユーザーデータチャンク（セクション2.3.11）を受信すると開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of such a User Data chunk:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このようなユーザーデータチャンクを受信すると：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Set temporary variables METADATA, ASSOCIATED_FLOWID, and ASSOCIATION to each have no value;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 一時変数METADATA、ASSOCIATED_FLOWID、およびASSOCIATIONをそれぞれに値がないように設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Create a new receiving flow context in this session, setting its RF_FLOW_ID to the flow ID encoded in the opening User Data chunk, and set to the RF_OPEN state;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. このセッションで新しい受信フローコンテキストを作成し、そのRF_FLOW_IDを、開始ユーザーデータチャンクでエンコードされたフローIDに設定し、RF_OPEN状態に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If the opening User Data chunk encodes a User&#39;s Per-Flow Metadata option (Section 2.3.11.1.1), set METADATA to option.userMetadata;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 最初のユーザーデータチャンクがユーザーのフローごとのメタデータオプションをエンコードする場合（セクション2.3.11.1.1）、METADATAをoption.userMetadataに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If the opening User Data chunk encodes a Return Flow Association option (Section 2.3.11.1.2), set ASSOCIATED_FLOWID to option.flowID;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 最初のユーザーデータチャンクがReturn Flow Associationオプションをエンコードする場合（セクション2.3.11.1.2）、ASSOCIATED_FLOWIDをoption.flowIDに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. If METADATA has no value, the receiver MUST reject the flow (Section 3.6.3.7), moving it to the RF_REJECTED state;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. METADATAに値がない場合、受信者はフローを拒否し（3.6.3.7節）、RF_REJECTED状態に移行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. If ASSOCIATED_FLOWID has a value, then if there is no sending flow in the same session with a flow ID of ASSOCIATED_FLOWID, the receiver MUST reject the flow, moving it to the RF_REJECTED state; otherwise, set ASSOCIATION to the indicated sending flow;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. ASSOCIATED_FLOWIDに値がある場合、同じセッションにフローIDがASSOCIATED_FLOWIDの送信フローがない場合、受信者はフローを拒否して、RF_REJECTED状態に移行する必要があります。それ以外の場合は、ASSOCIATIONを指定された送信フローに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. If ASSOCIATION indicates a sending flow, AND that sending flow&#39;s state is not F_OPEN, the receiver MUST reject this receiving flow, moving it to the RF_REJECTED state;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. ASSOCIATIONが送信フローを示し、その送信フローの状態がF_OPENではない場合、受信者はこの受信フローを拒否して、RF_REJECTED状態に移行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. If the opening User Data chunk encodes any unrecognized option with a type code less than 8192 (Section 2.3.11.1), the receiver MUST reject the flow, moving it to the RF_REJECTED state;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. オープニングのユーザーデータチャンクが8192（セクション2.3.11.1）未満のタイプコードで認識されないオプションをエンコードする場合、受信者はフローを拒否し、RF_REJECTED状態に移行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. If this new receiving flow is still RF_OPEN, then notify the user that a new receiving flow has opened, including the METADATA and, if present, the ASSOCIATION, and set flow.BUFFER_CAPACITY according to the user;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. この新しい受信フローがまだRF_OPENである場合は、METADATAおよび存在する場合はASSOCIATIONを含む新しい受信フローが開いたことをユーザーに通知し、ユーザーに応じてflow.BUFFER_CAPACITYを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. Perform the normal data processing (Section 3.6.3.2) for the opening User Data chunk; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. 最初のユーザーデータチャンクに対して通常のデータ処理（3.6.3.2項）を実行します。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. Set this session&#39;s ACK_NOW to true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. このセッションのACK_NOWをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-2--Receiving-Data">
3.6.3.2. Receiving Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.2. データ受信中
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A User Data chunk (Section 2.3.11) or a Next User Data chunk (Section 2.3.12) encodes one fragment of a user data message of a flow, as well as the flow&#39;s Forward Sequence Number and potentially optional parameters (Section 2.3.11.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーデータチャンク（セクション2.3.11）または次のユーザーデータチャンク（セクション2.3.12）は、フローのユーザーデータメッセージの1つのフラグメント、およびフローの転送シーケンス番号とオプションのパラメーター（セクション2.3。 11.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of a User Data or Next User Data chunk:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーデータまたは次のユーザーデータのチャンクの受信時：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If chunk.flowID doesn&#39;t indicate an existing receiving flow in the same session in the RF_OPEN, RF_REJECTED, or RF_COMPLETE_LINGER state, perform the steps of Section 3.6.3.1 (&#34;Startup&#34;) to start a new receiving flow;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. chunk.flowIDが、RF_OPEN、RF_REJECTED、またはRF_COMPLETE_LINGER状態の同じセッションの既存の受信フローを示していない場合は、セクション3.6.3.1（「起動」）の手順を実行して、新しい受信フローを開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Retrieve the receiving flow context for the flow indicated by chunk.flowID;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. chunk.flowIDで示されるフローの受信フローコンテキストを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Set flow.SHOULD_ACK to true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. flow.SHOULD_ACKをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If the flow is RF_OPEN, AND the chunk encodes any unrecognized option with a type code less than 8192 (Section 2.3.11.1), the flow MUST be rejected: notify the user of an exception, and reject the flow (Section 3.6.3.7), moving it to the RF_REJECTED state;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. フローがRF_OPENであり、チャンクが8192未満のタイプコードで認識されないオプションをエンコードしている場合（セクション2.3.11.1）、フローを拒否する必要があります。ユーザーに例外を通知し、フローを拒否します（セクション3.6.3.7）。 、それをRF_REJECTED状態に移動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. If the flow is not in the RF_OPEN state, set session.ACK_NOW to true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. フローがRF_OPEN状態でない場合は、session.ACK_NOWをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. If flow.PREV_RWND has a value and that value is less than 2 blocks, set session.ACK_NOW to true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. flow.PREV_RWNDに値があり、その値が2ブロック未満の場合は、session.ACK_NOWをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. If chunk.abandon is true, set session.ACK_NOW to true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. chunk.abandonがtrueの場合、session.ACK_NOWをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. If flow.SEQUENCE_SET has any gaps (that is, if it doesn&#39;t contain every sequence number from 0 through and including the highest sequence number in the set), set session.ACK_NOW to true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. flow.SEQUENCE_SETにギャップがある場合（つまり、0からセット内の最大のシーケンス番号を含むすべてのシーケンス番号が含まれていない場合）、session.ACK_NOWをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. If flow.SEQUENCE_SET contains chunk.sequenceNumber, then this chunk is a duplicate: set session.ACK_NOW to true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. flow.SEQUENCE_SETにchunk.sequenceNumberが含まれている場合、このチャンクは重複しています。session.ACK_NOWをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. If flow.SEQUENCE_SET doesn&#39;t contain chunk.sequenceNumber, AND chunk.final is true, AND flow.RF_FINAL_SN has no value, then set flow.RF_FINAL_SN to chunk.sequenceNumber, and set session.ACK_NOW to true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. flow.SEQUENCE_SETにchunk.sequenceNumberが含まれておらず、かつchunk.finalがtrueであり、かつ、flow.RF_FINAL_SNに値がない場合、flow.RF_FINAL_SNをchunk.sequenceNumberに設定し、session.ACK_NOWをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. If the flow is in the RF_OPEN state, AND flow.SEQUENCE_SET doesn&#39;t contain chunk.sequenceNumber, AND chunk.abandon is false, then create a new RECV_BUFFER entry for this chunk&#39;s data and set entry.SEQUENCE_NUMBER to chunk.sequenceNumber, entry.DATA to chunk.userData, and entry.FRA to chunk.fragmentControl, and insert this new entry into flow.RECV_BUFFER;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. フローがRF_OPEN状態であり、かつflow.SEQUENCE_SETにchunk.sequenceNumberが含まれておらず、かつchunk.abandonがfalseの場合、このチャンクのデータ用に新しいRECV_BUFFERエントリを作成し、entry.SEQUENCE_NUMBERをchunk.sequenceNumberエントリに設定します。 DATAをchunk.userDataに、entry.FRAをchunk.fragmentControlに、この新しいエントリをflow.RECV_BUFFERに挿入します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12. Add to flow.SEQUENCE_SET the range of sequence numbers from 0 through and including the chunk.forwardSequenceNumber derived field;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12. flow.SEQUENCE_SETにシーケンス番号の範囲を0からchunk.forwardSequenceNumber派生フィールドを含めて追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
13. Add chunk.sequenceNumber to flow.SEQUENCE_SET;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
13. chunk.sequenceNumberをflow.SEQUENCE_SETに追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
14. If flow.SEQUENCE_SET now has any gaps, set session.ACK_NOW to true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
14. flow.SEQUENCE_SETにギャップがある場合は、session.ACK_NOWをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
15. If session.ACK_NOW is false and session.DELACK_ALARM is not set, set session.DELACK_ALARM to fire in 200 milliseconds; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
15. session.ACK_NOWがfalseで、session.DELACK_ALARMが設定されていない場合は、session.DELACK_ALARMを200ミリ秒で起動するように設定します。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
16. Attempt delivery of completed messages in this flow&#39;s RECV_BUFFER to the user (Section 3.6.3.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
16. このフローのRECV_BUFFERで完了したメッセージのユーザーへの配信を試みます（セクション3.6.3.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After processing all chunks in a packet containing at least one User Data chunk, increment session.RX_DATA_PACKETS by one. If session.RX_DATA_PACKETS is at least two, set session.ACK_NOW to true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
少なくとも1つのユーザーデータチャンクを含むパケットのすべてのチャンクを処理した後、session.RX_DATA_PACKETSを1増やします。 session.RX_DATA_PACKETSが2つ以上の場合は、session.ACK_NOWをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiving flow that is not in the RF_CLOSED state is ready to send an acknowledgement if its SHOULD_ACK flag is set. Acknowledgements for receiving flows that are ready are sent either opportunistically by piggybacking on a packet that&#39;s already sending user data or an acknowledgement (Section 3.6.3.4.6), or when the session&#39;s ACK_NOW flag is set (Section 3.6.3.4.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RF_CLOSED状態でない受信フローは、SHOULD_ACKフラグが設定されている場合、確認応答を送信する準備ができています。準備ができているフローを受信するための確認応答は、すでにユーザーデータまたは確認応答を送信しているパケットに便乗的に送信するか（セクション3.6.3.4.6）、またはセッションのACK_NOWフラグが設定されている場合（セクション3.6.3.4.5）に送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-3--Buffering-and-Delivering-Data">
3.6.3.3. Buffering and Delivering Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.3. データのバッファリングと配信
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiving flow&#39;s information context contains a RECV_BUFFER for reordering, reassembling, and holding the user data messages of the flow. Only complete messages are delivered to the user; an implementation MUST NOT deliver partially received messages, except by special arrangement with the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信フローの情報コンテキストには、フローのユーザーデータメッセージを並べ替え、再構成、および保持するためのRECV_BUFFERが含まれています。完全なメッセージのみがユーザーに配信されます。実装は、ユーザーとの特別な取り決めによる場合を除いて、部分的に受信したメッセージを配信してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the Cumulative Acknowledgement Sequence Number (CSN) be the highest number in the contiguous range of numbers in SEQUENCE_SET starting with 0. For example, if SEQUENCE_SET contains {0, 1, 2, 3, 5, 6}, the contiguous range starting with 0 is 0..3, so the CSN is 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
累積確認応答シーケンス番号（CSN）を、0から始まるSEQUENCE_SETの連続する番号範囲の最大番号とします。たとえば、SEQUENCE_SETに{0、1、2、3、5、6}が含まれている場合、連続する範囲は0は0..3なので、CSNは3です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A message is complete if all of its fragments are present in the RECV_BUFFER. The fragments of one message have contiguous sequence numbers. A message can be either a single fragment, whose fragment control value is 0-whole, or two or more fragments where the first&#39;s fragment control value is 1-begin, followed by zero or more fragments with control value 3-middle, and terminated by a last fragment with control value 2-end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのフラグメントがRECV_BUFFERに存在する場合、メッセージは完了です。 1つのメッセージのフラグメントには、連続したシーケンス番号があります。メッセージは、フラグメント制御値が0全体である単一のフラグメント、または最初のフラグメント制御値が1で始まる2つ以上のフラグメントで、その後に制御値が3の中間にある0個以上のフラグメントが続き、制御値2の最後のフラグメント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An incomplete message segment is a contiguous sequence of one or more fragments that do not form a complete message -- that is, a 1-begin followed by zero or more 3-middle fragments but with no 2-end, or zero or more 3-middle fragments followed by a 2-end but with no 1-begin, or one or more 3-middle fragments with neither a 1-begin nor a 2-end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不完全なメッセージセグメントは、完全なメッセージを形成しない1つ以上のフラグメントの連続したシーケンスです。つまり、1始まりの後に0個以上の3つの中間フラグメントが続きますが、2終わりがないか、0個以上の3です。 -中間フラグメントの後に2端が続くが1開始がないか、1つ以上の3中間フラグメントが1開始でも2端でもない。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Incomplete message segments can either be in progress or abandoned. An incomplete segment is abandoned in the following cases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不完全なメッセージセグメントは、進行中または破棄されます。次の場合、不完全なセグメントは破棄されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The sequence number of the segment&#39;s first fragment is less than or equal to the CSN, AND that fragment&#39;s control value is not 1-begin; or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セグメントの最初のフラグメントのシーケンス番号がCSN以下であり、かつそのフラグメントの制御値が1から始まっていない。または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The sequence number of the segment&#39;s last fragment is less than the CSN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セグメントの最後のフラグメントのシーケンス番号がCSN未満です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Abandoned message segments will never be completed, so they SHOULD be removed from the RECV_BUFFER to make room in the advertised receive window and the receiver&#39;s memory for messages that can be completed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
破棄されたメッセージセグメントは決して完了しないため、それらをRECV_BUFFERから削除して、アドバタイズされた受信ウィンドウと受信者のメモリに、完了可能なメッセージ用のスペースを確保する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The user can suspend delivery of a flow&#39;s messages. A suspended receiving flow holds completed messages in its RECV_BUFFER until the user resumes delivery. A suspended flow can cause the receive window advertisement to go to zero even when the BUFFER_CAPACITY is non-zero; this is described in detail in Section 3.6.3.5 (&#34;Flow Control&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーはフローのメッセージの配信を一時停止できます。中断された受信フローは、ユーザーが配信を再開するまで、完了したメッセージをRECV_BUFFERに保持します。中断されたフローにより、BUFFER_CAPACITYがゼロ以外の場合でも、受信ウィンドウアドバタイズがゼロになる可能性があります。これについては、3.6.3.5（「フロー制御」）で詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the receiving flow is not suspended, the original queuing order of the messages is recovered by delivering, in ascending sequence number order, complete messages in the RECV_BUFFER whose sequence numbers are less than or equal to the CSN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信フローが中断されない場合、メッセージの元のキューイング順序は、シーケンス番号の昇順で、シーケンス番号がCSN以下の完全なメッセージをRECV_BUFFERに配信することによって回復されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following describes a method for discarding abandoned message segments and delivering complete messages in original queuing order when the receiving flow is not suspended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、受信フローが中断されていない場合に、破棄されたメッセージセグメントを破棄し、完全なメッセージを元のキューイング順に配信する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the first fragment entry in the RECV_BUFFER has a sequence number less than or equal to the CSN and delivery is still possible:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RECV_BUFFERの最初のフラグメントエントリのシーケンス番号はCSN以下であり、配信は引き続き可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If entry.FRA is 0-whole, deliver entry.DATA to the user, and remove this entry from RECV_BUFFER; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. entry.FRAが0全体の場合、entry.DATAをユーザーに配信し、このエントリーをRECV_BUFFERから削除します。さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If entry.FRA is 2-end or 3-middle, this entry belongs to an abandoned segment, so remove and discard this entry from RECV_BUFFER; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. entry.FRAが2エンドまたは3ミドルの場合、このエントリーは破棄されたセグメントに属しているため、このエントリーをRECV_BUFFERから削除して破棄します。さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Entry.FRA is 1-begin. Let LAST_ENTRY be the last RECV_BUFFER entry that is part of this message segment (LAST_ENTRY can be entry if the segment has only one fragment so far). Then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Entry.FRAは1から始まります。 LAST_ENTRYを、このメッセージセグメントの一部である最後のRECV_BUFFERエントリにします（これまでにセグメントにフラグメントが1つしかない場合は、LAST_ENTRYをエントリにすることができます）。次に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
1. If LAST_ENTRY.FRA is 2-end, this segment is a complete message, so concatenate the DATA fields of each fragment entry of this segment in ascending sequence number order and deliver the complete message to the user, then remove the entries for this complete message from RECV_BUFFER; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
1. LAST_ENTRY.FRAが2エンドの場合、このセグメントは完全なメッセージであるため、このセグメントの各フラグメントエントリのDATAフィールドを昇順のシーケンス番号で連結し、完全なメッセージをユーザーに配信してから、この完全なメッセージのエントリを削除します。 RECV_BUFFERから。さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2. If LAST_ENTRY.SEQUENCE_NUMBER is less than CSN, this segment is incomplete and abandoned, so remove and discard the entries for this segment from RECV_BUFFER; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2. LAST_ENTRY.SEQUENCE_NUMBERがCSNより小さい場合、このセグメントは不完全であり、破棄されるため、このセグメントのエントリをRECV_BUFFERから削除して破棄します。さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3. LAST_ENTRY.SEQUENCE_NUMBER is equal to CSN and LAST_ENTRY.FRA is not 2-end: this segment is incomplete but still in progress. Ordered delivery is no longer possible until at least one more fragment is received. Stop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3. LAST_ENTRY.SEQUENCE_NUMBERはCSNと等しく、LAST_ENTRY.FRAは2エンドではありません。このセグメントは不完全ですが、まだ進行中です。少なくとももう1つのフラグメントが受信されるまで、注文した配送はできなくなります。やめる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If flow.RF_FINAL_SN has a value and is equal to the CSN, AND RECV_BUFFER is empty, all complete messages have been delivered to the user, so notify the user that the flow is complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flow.RF_FINAL_SNに値があり、CSNと等しく、かつRECV_BUFFERが空の場合、すべての完全なメッセージがユーザーに配信されているため、フローが完了したことをユーザーに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-4--Acknowledging-Data">
3.6.3.4. Acknowledging Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4. データの確認
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A flow receiver SHOULD acknowledge all user data fragment sequence numbers seen in that flow. Acknowledgements drive the sender&#39;s congestion control and avoidance algorithms, clear data from the sender&#39;s buffers, and in some sender implementations clock new data into the network; therefore, the acknowledgements must be accurate and timely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー受信者は、そのフローで見られるすべてのユーザーデータフラグメントシーケンス番号を確認する必要があります。承認は、送信者の輻輳制御および回避アルゴリズムを駆動し、送信者のバッファからデータをクリアし、一部の送信者の実装では、新しいデータをネットワークに送り込みます。したがって、確認は正確かつタイムリーでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-4-1--Timing">
3.6.3.4.1. Timing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.1. タイミング
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For reasons similar to those discussed in Section 4.2.3.2 of RFC 1122 [RFC1122], it is advantageous to delay sending acknowledgements for a short time, so that multiple data fragments can be acknowledged in a single transmission. However, it is also advantageous for a sender to receive timely notification about the receiver&#39;s disposition of the flow, particularly in unusual or exceptional circumstances, so that the circumstances can be addressed if possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 1122 [RFC1122]のセクション4.2.3.2で説明されている理由と同様の理由により、複数のデータフラグメントを1回の送信で確認できるように、確認応答の送信を短時間遅らせると有利です。ただし、特に異常または例外的な状況で、フローの受信者の処理に関するタイムリーな通知を送信者が受信することも有利であり、可能であればその状況に対処できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, a flow receiver SHOULD send an acknowledgement for a flow as soon as is practical in any of the following circumstances:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、フローレシーバーは、以下の状況のいずれかで実用的であるとすぐにフローの確認応答を送信する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a User Data chunk that starts a new flow;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 新しいフローを開始するユーザーデータチャンクの受信時。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a User Data or Next User Data chunk if the flow is not in the RF_OPEN state;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フローがRF_OPEN状態でない場合、ユーザーデータまたは次のユーザーデータのチャンクを受信したとき。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a User Data chunk where, before processing the chunk, the SEQUENCE_SET of the indicated flow does not contain every sequence number between 0 and the highest sequence number in the set (that is, if there was a sequence number gap before processing the chunk);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ユーザーデータチャンクを受信すると、チャンクを処理する前に、示されたフローのSEQUENCE_SETに0からセット内の最大シーケンス番号までのすべてのシーケンス番号が含まれていない（つまり、シーケンスを処理する前にシーケンス番号のギャップがあった場合）チャンク）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a User Data chunk where, after processing the chunk, the flow&#39;s SEQUENCE_SET does not contain every sequence number between 0 and the highest sequence number in the set (that is, if this chunk causes a sequence number gap);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ユーザーデータチャンクを受信すると、チャンクの処理後、フローのSEQUENCE_SETに0とセット内の最大のシーケンス番号の間のシーケンス番号が含まれていません（つまり、このチャンクによってシーケンス番号にギャップが生じた場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a Buffer Probe for the flow;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フローのバッファープローブの受信時。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a User Data chunk if the last acknowledgement sent for the flow indicated fewer than two bufferBlocksAvailable;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フローに対して送信された最後の確認応答が2つ未満のbufferBlocksAvailableを示した場合のユーザーデータチャンクの受信時。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a User Data or Next User Data chunk for the flow if, after processing the chunk, the flow&#39;s BUFFER_CAPACITY is not at least 1024 bytes greater than BUFFERED_SIZE;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フローのユーザーデータまたは次のユーザーデータのチャンクを受信したときに、チャンクを処理した後、フローのBUFFER_CAPACITYが少なくとも1024バイトがBUFFERED_SIZEより大きくない場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a User Data or Next User Data chunk for any sequence number that was already seen (that is, on receipt of a duplicate);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o すでに表示されているシーケンス番号のユーザーデータまたは次のユーザーデータのチャンクを受信したとき（つまり、重複を受信したとき）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On the first receipt of the final sequence number of the flow;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フローの最終シーケンス番号の最初の受信時。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of two packets in the session that contain user data for any flows since an acknowledgement was last sent, the new acknowledgements being for the flows having any User Data chunks in the received packets (that is, for every second packet containing user data);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 確認応答が最後に送信されてからフローのユーザーデータを含む2つのパケットをセッションで受信すると、新しい確認応答は、受信したパケットにユーザーデータチャンクを含むフロー（つまり、ユーザーデータを含む2番目のパケットごと）に対するものです。 ;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o After receipt of a User Data chunk for the flow, if an acknowledgement for any other flow is being sent (that is, consolidate acknowledgements);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フローのユーザーデータチャンクを受信した後、他のフローの確認応答が送信されている（つまり、確認応答を統合する）場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o After receipt of a User Data chunk for the flow, if any user data for a sending flow is being sent in a packet and if there is space available in the same packet (that is, attempt to piggyback an acknowledgement with user data if possible);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フローのユーザーデータチャンクを受信した後、送信フローのユーザーデータがパケットで送信されており、同じパケットに使用可能なスペースがある場合（つまり、可能であればユーザーデータで確認応答をピギーバックしようとします） ;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o No longer than 200 milliseconds after receipt of a User Data chunk for the flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フローのユーザーデータチャンクを受信して​​から200ミリ秒以内。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-4-2--Size-and-Truncation">
3.6.3.4.2. Size and Truncation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.2. サイズと切り捨て
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Including an encoded acknowledgement in a packet might cause the packet to exceed the path MTU. In that case:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコードされた確認応答をパケットに含めると、パケットがパスMTUを超える可能性があります。その場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the packet is being sent primarily to send an acknowledgement, AND this is the first acknowledgement in the packet, truncate the acknowledgement so that the packet does not exceed the path MTU; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o パケットが主に確認応答を送信するために送信されており、これがパケット内の最初の確認応答である場合、パケットがパスMTUを超えないように確認応答を切り捨てます。さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The acknowledgement is being piggybacked in a packet with user data or with an acknowledgement for another flow: do not include this acknowledgement in the packet, and send it later.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 確認応答は、ユーザーデータまたは別のフローの確認応答を持つパケットで便乗されています。この確認応答をパケットに含めず、後で送信してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-4-3--Constructing">
3.6.3.4.3. Constructing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.3. 構築
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Data Acknowledgement Bitmap chunk (Section 2.3.13) and Data Acknowledgement Ranges chunk (Section 2.3.14) encode a receiving flow&#39;s SEQUENCE_SET and its receive window advertisement. The two chunks are semantically equivalent; implementations SHOULD send whichever provides the most compact encoding of the SEQUENCE_SET.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ受信確認ビットマップチャンク（セクション2.3.13）およびデータ受信確認範囲チャンク（セクション2.3.14）は、受信フローのSEQUENCE_SETとその受信ウィンドウアドバタイズをエンコードします。 2つのチャンクは、意味的に同等です。実装は、SEQUENCE_SETの最もコンパクトなエンコーディングを提供する方を送信する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When assembling an acknowledgement for a receiving flow:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信フローの確認を組み立てるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the flow&#39;s state is RF_REJECTED, first assemble a Flow Exception Report chunk (Section 2.3.16) for flow.flowID;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. フローの状態がRF_REJECTEDの場合、最初にflow.flowIDのフロー例外レポートチャンク（セクション2.3.16）をアセンブルします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Choose the acknowledgement chunk type that most compactly encodes flow.SEQUENCE_SET;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. flow.SEQUENCE_SET;を最もコンパクトにエンコードする確認応答チャンクタイプを選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Use the method described in Section 3.6.3.5 (&#34;Flow Control&#34;) to determine the value for the acknowledgement chunk&#39;s bufferBlocksAvailable field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. セクション3.6.3.5（「フロー制御」）で説明されている方法を使用して、確認応答チャンクのbufferBlocksAvailableフィールドの値を決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-4-4--Delayed-Acknowledgement">
3.6.3.4.4. Delayed Acknowledgement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.4. 承認の遅延
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed in Section 3.6.3.4.1 (&#34;Timing&#34;), a flow receiver can delay sending an acknowledgement for up to 200 milliseconds after receiving user data. The method described in Section 3.6.3.2 (&#34;Receiving Data&#34;) sets the session&#39;s DELACK_ALARM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.6.3.4.1（「タイミング」）で説明したように、フローレシーバーは、ユーザーデータの受信後、確認応答の送信を最大200ミリ秒遅らせることができます。セクション3.6.3.2（「データの受信」）で説明されているメソッドは、セッションのDELACK_ALARMを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When DELACK_ALARM fires, set ACK_NOW to true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DELACK_ALARMが発生したら、ACK_NOWをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-4-5--Obligatory-Acknowledgement">
3.6.3.4.5. Obligatory Acknowledgement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.5. 義務的な謝辞
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One or more acknowledgements should be sent as soon as is practical when the session&#39;s ACK_NOW flag is set. While the ACK_NOW flag is set:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションのACK_NOWフラグが設定されている場合は、できるだけ早く1つ以上の確認応答を送信する必要があります。 ACK_NOWフラグが設定されている間：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Choose a receiving flow that is ready to send an acknowledgement;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 確認応答を送信する準備ができている受信フローを選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If there is no such flow, there is no work to do, set ACK_NOW to false, set RX_DATA_PACKETS to 0, clear the DELACK_ALARM, and stop; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. そのようなフローがない場合、実行する作業はありません。ACK_NOWをfalseに設定し、RX_DATA_PACKETSを0に設定し、DELACK_ALARMをクリアして停止します。さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Start a new packet;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 新しいパケットを開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Assemble an acknowledgement for the flow and include it in the packet, truncating it if necessary so that the packet doesn&#39;t exceed the path MTU;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. フローの確認応答を組み立ててパケットに含め、パケットがパスMTUを超えないように、必要に応じてそれを切り捨てます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Set flow.SHOULD_ACK to false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. flow.SHOULD_ACKをfalseに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Set flow.PREV_RWND to the bufferBlocksAvailable field of the included acknowledgement chunk;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 含まれる確認応答チャンクのbufferBlocksAvailableフィールドにflow.PREV_RWNDを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Attempt to piggyback acknowledgements for any other flows that are ready to send an acknowledgement into the packet, as described below; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. 以下で説明するように、確認応答をパケットに送信する準備ができている他のフローの確認応答を便乗させようとします。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Send the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. パケットを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-4-6--Opportunistic-Acknowledgement">
3.6.3.4.6. Opportunistic Acknowledgement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.6. 日和見的謝辞
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When sending a packet with user data or an acknowledgement, any other receiving flows that are ready to send an acknowledgement should include their acknowledgements in the packet if possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーデータまたは確認応答を含むパケットを送信する場合、確認応答を送信する準備ができている他の受信フローは、可能であれば、それらの確認応答をパケットに含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To piggyback acknowledgements in a packet that is already being sent, where the packet contains user data or an acknowledgement, while there is at least one receiving flow that is ready to send an acknowledgement:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
既に送信されているパケットに確認応答を便乗させるには、確認応答を送信する準備ができている受信フローが少なくとも1つある間に、パケットにユーザーデータまたは確認応答が含まれている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Assemble an acknowledgement for the flow;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. フローの確認を組み立てます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If the acknowledgement cannot be included in the packet without exceeding the path MTU, the packet is full; stop. Otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. パスMTUを超えずに確認応答をパケットに含めることができない場合、パケットはいっぱいです。やめる。さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Include the acknowledgement in the packet;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 確認応答をパケットに含めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Set flow.SHOULD_ACK to false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. flow.SHOULD_ACKをfalseに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Set flow.PREV_RWND to the bufferBlocksAvailable field of the included acknowledgement chunk; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 含まれる確認応答チャンクのbufferBlocksAvailableフィールドにflow.PREV_RWNDを設定します。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. If there are no longer any receiving flows in the session that are ready to send an acknowledgement, set session.ACK_NOW to false, set session.RX_DATA_PACKETS to 0, and clear session.DELACK_ALARM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. セッション内に確認応答を送信する準備ができている受信フローがなくなった場合は、session.ACK_NOWをfalseに設定し、session.RX_DATA_PACKETSを0に設定し、session.DELACK_ALARMをクリアします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-4-7--Example">
3.6.3.4.7. Example
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.7. 例
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 23 shows an example flow with sequence numbers 31 and 33 lost in transit; 31 is abandoned, and 33 is retransmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図23は、シーケンス番号31および33が転送中に失われたフローの例を示しています。 31は破棄され、33は再送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Receiver
    1 |&lt;---  Data ID=3, seq#=29, fsnOff=11 (fsn=18)
    2 |&lt;---  Data ID=3, seq#=30, fsnOff=12 (fsn=18)
    3 |---&gt;  Ack  ID=3, seq:0-30
    4 |&lt;---  Data ID=3, seq#=32, fsnOff=12 (fsn=20)
    5 |---&gt;  Ack  ID=3, seq:0-30, 32
    6 |&lt;---  Data ID=3, seq#=34, fsnOff=12 (fsn=22)
    7 |---&gt;  Ack  ID=3, seq:0-30, 32, 34
      |                   :
    8 |&lt;---  Data ID=3, seq#=46, fsnOff=16 (fsn=30)
    9 |---&gt;  Ack  ID=3, seq:0-30, 32, 34-46
   10 |&lt;---  Data ID=3, seq#=47, fsnOff=15 (fsn=32)
   11 |---&gt;  Ack  ID=3, seq:0-32, 34-47
   12 |&lt;---  Data ID=3, seq#=33, fsnOff=1 (fsn=32)
   13 |---&gt;  Ack  ID=3, seq#=0-47
   14 |&lt;---  Data ID=3, seq#=48, fsnOff=16 (fsn=32)
   15 |&lt;---  Data ID=3, seq#=49, fsnOff=17 (fsn=32)
   16 |---&gt;  Ack  ID=3, seq#=0-49
      |                   :
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
Figure 23: Flow Example with Loss
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
図23：損失のあるフローの例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-5--Flow-Control">
3.6.3.5. Flow Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.5. フロー制御
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow receiver maintains a buffer for reassembling and reordering messages for delivery to the user (Section 3.6.3.3). The implementation and the user may wish to limit the amount of resources (including buffer memory) that a flow is allowed to use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローレシーバーは、ユーザーに配信するためにメッセージを再構成して並べ替えるためのバッファーを維持します（セクション3.6.3.3）。実装とユーザーは、フローが使用できるリソース（バッファメモリを含む）の量を制限したい場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP provides a means for each receiving flow to govern the amount of data sent by the sender, by way of the bufferBytesAvailable derived field of acknowledgement chunks (Sections 2.3.13 and 2.3.14). This derived field indicates the amount of data that the sender is allowed to have outstanding in the network, until instructed otherwise. This amount is also called the receive window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPは、受信フローごとに、確認応答チャンクのbufferBytesAvailable派生フィールドを介して、送信者が送信するデータの量を管理する手段を提供します（セクション2.3.13および2.3.14）。この派生フィールドは、特に指示がない限り、送信者がネットワーク内で未処理のままにできるデータの量を示します。この量は、受信ウィンドウとも呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow receiver can suspend the sender by advertising a closed (zero length) receive window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローレシーバーは、閉じた（長さがゼロの）受信ウィンドウをアドバタイズすることにより、送信者を一時停止できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The user can suspend delivery of messages from the receiving flow (Section 3.6.3.3). This can cause the receive buffer to fill.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーは、受信フローからのメッセージの配信を一時停止できます（セクション3.6.3.3）。これにより、受信バッファーがいっぱいになる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order for progress to be made on completing a fragmented message or repairing a gap for sequenced delivery in a flow, the flow receiver MUST advertise at least one buffer block in an acknowledgement if it is not suspended, even if the amount of data in the buffer exceeds the buffer capacity, unless the buffer capacity is 0. Otherwise, deadlock can occur, as the receive buffer will stay full and won&#39;t drain because of a gap or incomplete message, and the gap or incomplete message can&#39;t be repaired or completed because the sender is suspended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
断片化されたメッセージの完了、またはフロー内のシーケンス配信のギャップの修復で進行するために、フローのデータ量が中断されていても、フロー受信者は確認応答で少なくとも1つのバッファブロックを通知する必要があります。バッファー容量が0でない限り、バッファーはバッファー容量を超えます。そうしないと、ギャップまたは不完全なメッセージのために受信バッファーがいっぱいのままドレインされず、ギャップまたは不完全なメッセージを修復できないため、デッドロックが発生する可能性があります。または送信者が一時停止されているため完了しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receive window is advertised in units of 1024-byte blocks. For example, advertisements for 1 byte, 1023 bytes, and 1024 bytes each require one block. An advertisement for 1025 bytes requires two blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信ウィンドウは、1024バイトブロック単位でアドバタイズされます。たとえば、1バイト、1023バイト、および1024バイトのアドバタイズには、それぞれ1つのブロックが必要です。 1025バイトのアドバタイズには2つのブロックが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following describes the RECOMMENDED method of calculating the bufferBlocksAvailable field of an acknowledgement chunk for a receiving flow:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、受信フローの確認応答チャンクのbufferBlocksAvailableフィールドを計算するRECOMMENDEDメソッドについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If BUFFERED_SIZE is greater than or equal to BUFFER_CAPACITY, set ADVERTISE_BYTES to 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. BUFFERED_SIZEがBUFFER_CAPACITY以上の場合は、ADVERTISE_BYTESを0に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If BUFFERED_SIZE is less than BUFFER_CAPACITY, set ADVERTISE_BYTES to BUFFER_CAPACITY - BUFFERED_SIZE;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. BUFFERED_SIZEがBUFFER_CAPACITYより小さい場合は、ADVERTISE_BYTESをBUFFER_CAPACITY-BUFFERED_SIZEに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Set ADVERTISE_BLOCKS to CEIL(ADVERTISE_BYTES / 1024);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. ADVERTISE_BLOCKSをCEIL（ADVERTISE_BYTES / 1024）に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If ADVERTISE_BLOCKS is 0, AND BUFFER_CAPACITY is greater than 0, AND delivery to the user is not suspended, set ADVERTISE_BLOCKS to 1; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. ADVERTISE_BLOCKSが0で、かつBUFFER_CAPACITYが0より大きく、ユーザーへの配信が一時停止されていない場合は、ADVERTISE_BLOCKSを1に設定します。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Set the acknowledgement&#39;s bufferBlocksAvailable field to ADVERTISE_BLOCKS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 確認応答のbufferBlocksAvailableフィールドをADVERTISE_BLOCKSに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-6--Receiving-a-Buffer-Probe">
3.6.3.6. Receiving a Buffer Probe
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.6. バッファプローブの受信
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Buffer Probe chunk (Section 2.3.15) is sent by the flow sender (Section 3.6.2.9.1) to request the current receive window advertisement (in the form of an acknowledgement) from the flow receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バッファープローブチャンク（セクション2.3.15）がフローセンダー（セクション3.6.2.9.1）によって送信され、フローレシーバーに現在の受信ウィンドウアドバタイズメント（確認応答の形式）を要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of a Buffer Probe chunk:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バッファープローブチャンクの受信時：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If chunk.flowID doesn&#39;t belong to a receiving flow in the same session in the RF_OPEN, RF_REJECTED, or RF_COMPLETE_LINGER state, ignore this Buffer Probe; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. chunk.flowIDがRF_OPEN、RF_REJECTED、またはRF_COMPLETE_LINGER状態の同じセッションの受信フローに属していない場合は、このバッファープローブを無視してください。さもないと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Retrieve the receiving flow context for the flow indicated by chunk.flowID; then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. chunk.flowIDで示されるフローの受信フローコンテキストを取得します。その後
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Set flow.SHOULD_ACK to true; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. flow.SHOULD_ACKをtrueに設定します。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Set session.ACK_NOW to true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. session.ACK_NOWをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-7--Rejecting-a-Flow">
3.6.3.7. Rejecting a Flow
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.7. フローを拒否する
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiver can reject an RF_OPEN flow at any time and for any reason. To reject a receiving flow in the RF_OPEN state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レシーバーは、いつでも、どのような理由でも、RF_OPENフローを拒否できます。 RF_OPEN状態の受信フローを拒否するには：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Move to the RF_REJECTED state;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. RF_REJECTED状態に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Discard all entries in flow.RECV_BUFFER, as they are no longer relevant;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 関係がなくなったため、flow.RECV_BUFFERのすべてのエントリを破棄します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If the user rejected the flow, set flow.EXCEPTION_CODE to the exception code indicated by the user; otherwise, the flow was rejected automatically by the implementation, so the exception code is 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. ユーザーがフローを拒否した場合は、flow.EXCEPTION_CODEをユーザーが指定した例外コードに設定します。それ以外の場合、フローは実装によって自動的に拒否されたため、例外コードは0です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Set flow.SHOULD_ACK to true; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. flow.SHOULD_ACKをtrueに設定します。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Set session.ACK_NOW to true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. session.ACK_NOWをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receiver indicates that it has rejected a flow by sending a Flow Exception Report chunk (Section 2.3.16) with every acknowledgement (Section 3.6.3.4.3) for a flow in the RF_REJECTED state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レシーバーは、RF_REJECTED状態のフローのすべての確認応答（セクション3.6.3.4.3）とともにフロー例外レポートチャンク（セクション2.3.16）を送信することにより、フローを拒否したことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6-3-8--Close">
3.6.3.8. Close
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.8. 閉じる
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiving flow is complete when every sequence number from 0 through and including the final sequence number has been received -- that is, when flow.RF_FINAL_SN has a value and flow.SEQUENCE_SET contains every sequence number from 0 through flow.RF_FINAL_SN, inclusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信フローは、0から最終シーケンス番号までのすべてのシーケンス番号が受信されると完了します。つまり、flow.RF_FINAL_SNに値があり、flow.SEQUENCE_SETには、0からflow.RF_FINAL_SNまでのすべてのシーケンス番号が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an RF_OPEN or RF_REJECTED receiving flow becomes complete, move to the RF_COMPLETE_LINGER state, set flow.SHOULD_ACK to true, and set session.ACK_NOW to true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RF_OPENまたはRF_REJECTED受信フローが完了したら、RF_COMPLETE_LINGER状態に移行し、flow.SHOULD_ACKをtrueに設定し、session.ACK_NOWをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiving flow SHOULD remain in the RF_COMPLETE_LINGER state for 120 seconds. After 120 seconds, move to the RF_CLOSED state. The receiving flow is now closed, and its resources can be reclaimed once all complete messages in flow.RECV_BUFFER have been delivered to the user (Section 3.6.3.3). The same flow ID might be used for a new flow by the sender after this point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信フローは、120秒間RF_COMPLETE_LINGER状態を維持する必要があります（SHOULD）。 120秒後、RF_CLOSED状態に移行します。これで受信フローが閉じられ、flow.RECV_BUFFER内のすべての完全なメッセージがユーザーに配信されると、そのリソースを再利用できます（セクション3.6.3.3）。この後、送信者は新しいフローに同じフローIDを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Discussion: The flow sender detects that the flow is complete on receiving an acknowledgement of all fragment sequence numbers of the flow. This can&#39;t happen until after the receiver has detected that the flow is complete and acknowledged all of the sequence numbers. The receiver&#39;s RF_COMPLETE_LINGER period is two minutes (one Maximum Segment Lifetime (MSL)); this period allows any in-flight packets to drain from the network without being misidentified and gives the sender an opportunity to retransmit any sequence numbers if the completing acknowledgement is lost. The sender&#39;s F_COMPLETE_LINGER period is at least two minutes plus 10 seconds and doesn&#39;t begin until the completing acknowledgement is received; therefore, the same flow identifier won&#39;t be reused by the flow sender for a new sending flow for at least 10 seconds after the flow receiver has closed the receiving flow context. This ensures correct operation independent of network delay, even when the sender&#39;s clock runs up to 8 percent faster than the receiver&#39;s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ディスカッション：フロー送信者は、フローのすべてのフラグメントシーケンス番号の確認応答を受信すると、フローが完了したことを検出します。これは、受信者がフローが完了したことを検出し、すべてのシーケンス番号を確認するまで発生しません。レシーバーのRF_COMPLETE_LINGER期間は2分（1つの最大セグメントライフタイム（MSL））です。この期間により、送信中のパケットが誤認されることなくネットワークから排出され、完全な確認応答が失われた場合に送信者がシーケンス番号を再送信する機会が与えられます。送信者のF_COMPLETE_LINGER期間は少なくとも2分+ 10秒であり、完了確認が受信されるまで開始されません。したがって、フローレシーバーが受信フローコンテキストを閉じてから少なくとも10秒間は、同じフロー識別子が新しい送信フローのためにフローセンダーによって再利用されません。これにより、送信側のクロックが受信側のクロックよりも最大8％高速で実行されている場合でも、ネットワーク遅延に関係なく正しい動作が保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--IANA-Considerations">
4. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. IANAに関する考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo specifies chunk type code values (Section 2.3) and User Data option type code values (Section 2.3.11.1). These type code values are assigned and maintained by Adobe. Therefore, this memo has no IANA actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、チャンクタイプコード値（セクション2.3）およびユーザーデータオプションタイプコード値（セクション2.3.11.1）を指定します。これらのタイプコード値は、アドビによって割り当てられ、維持されます。したがって、このメモにはIANAアクションはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Security-Considerations">
5. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. セキュリティに関する考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo specifies a general framework that can be used to establish a confidential and authenticated session between endpoints. A Cryptography Profile, not specified herein, defines the cryptographic algorithms, data formats, and semantics as used within this framework. Designing a Cryptography Profile to ensure that communications are protected to the degree required by the application-specific threat model is outside the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、エンドポイント間で機密で認証されたセッションを確立するために使用できる一般的なフレームワークを指定します。ここで指定されていない暗号化プロファイルは、このフレームワーク内で使用される暗号アルゴリズム、データ形式、およびセマンティクスを定義します。暗号化プロファイルを設計して、アプリケーション固有の脅威モデルに必要な程度まで通信が保護されるようにすることは、この仕様の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A block cipher in CBC mode is RECOMMENDED for packet encryption (Section 2.2.3). An attacker can predict the values of some fields from one plain RTMFP packet to the next or predict that some fields may be the same from one packet to the next. This SHOULD be considered in choosing and implementing a packet encryption cipher and mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CBCモードのブロック暗号は、パケット暗号化に推奨されます（セクション2.2.3）。攻撃者は、あるRTMFPパケットから次のパケットまでの一部のフィールドの値を予測したり、一部のフィールドがパケット間で同じである可能性があることを予測したりできます。これは、パケット暗号化の暗号とモードを選択して実装する際に考慮すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The well-known Default Session Key of a Cryptography Profile serves multiple purposes, including the scrambling of session startup packets to protect interior fields from undesirable modification by middleboxes such as NATs, increasing the effort required for casual passive observation of startup packets, and allowing different applications of RTMFP using different Default Session Keys to (intentionally or not) share network transport addresses without interference. The Default Session Key, being well known, MUST NOT be construed to contribute to the security of session startup; session startup is essentially in the clear.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化プロファイルのよく知られたデフォルトセッションキーは、NATなどのミドルボックスによる望ましくない変更から内部フィールドを保護するためのセッションスタートアップパケットのスクランブル、スタートアップパケットのカジュアルなパッシブ監視に必要な労力の増加、さまざまなさまざまなデフォルトセッションキーを使用したRTMFPのアプリケーションは、干渉なしに（意図的に、または意図せずに）ネットワーク転送アドレスを共有します。よく知られているデフォルトセッションキーは、セッション起動のセキュリティに寄与すると解釈してはなりません。セッションの起動は、本質的には明確です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 3.5.4.2 describes an OPTIONAL method for processing a change of network address of a communicating peer. Securely processing address mobility using that method, or any substantially similar method, REQUIRES at least that the packet encryption function of the Cryptography Profile (Section 2.2.3) employs a cryptographic verification mechanism comprising secret information known only to the two endpoints. Without this constraint, that method, or any substantially similar method, becomes &#34;session hijacking support&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.5.4.2では、通信するピアのネットワークアドレスの変更を処理するためのOPTIONALメソッドについて説明します。その方法または実質的に同様の方法を使用してアドレスモビリティを安全に処理するには、少なくとも暗号化プロファイル（セクション2.2.3）のパケット暗号化機能が、2つのエンドポイントだけが知っている秘密情報を含む暗号化検証メカニズムを使用する必要があります。この制約がない場合、そのメソッドまたは実質的に同様のメソッドが「セッションハイジャックサポート」になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flows and packet fragmentation imply semantics that could cause unbounded resource utilization in receivers, causing a denial of service. Implementations SHOULD guard against unbounded or excessive resource use and abort sessions that appear abusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローとパケットの断片化は、受信側で無制限のリソース使用率を引き起こし、サービス拒否を引き起こす可能性があるセマンティクスを意味します。実装は、無制限または過剰なリソースの使用を防ぎ、乱用と思われるセッションを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A rogue but popular Redirector (Section 3.5.1.4) could direct session initiators to flood a victim address or network with Initiator Hello packets, potentially causing a denial of service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
悪意のある人気のあるリダイレクター（セクション3.5.1.4）は、セッション開始者に被害者のアドレスまたはネットワークにイニシエーターHelloパケットをフラッディングするように指示し、サービス拒否を引き起こす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attacker that can passively observe an IHello and that possesses a certificate matching the Endpoint Discriminator (without having to know the private key, if any, associated with it) can deny the initiator access to the desired responder by sending an RHello before the desired responder does, since only the first received RHello is selected by the initiator. The attacker needn&#39;t forge the desired responder&#39;s source address, since the RHello is selected based on the tag echo and not the packet&#39;s source address. This can simplify the attack in some network or host configurations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IHelloを受動的に監視でき、エンドポイントディスクリミネーターと一致する証明書を持っている攻撃者（それに関連付けられている秘密キーがあればそれを知らなくても）は、目的のレスポンダーの前にRHelloを送信することにより、目的のレスポンダーへのイニシエーターアクセスを拒否できます。最初に受信したRHelloのみがイニシエーターによって選択されるためです。 RHelloはパケットの送信元アドレスではなくタグエコーに基づいて選択されるため、攻撃者は目的のレスポンダの送信元アドレスを偽造する必要はありません。これにより、一部のネットワークまたはホスト構成での攻撃を簡略化できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attacker that can passively observe and record the packets of an established session can use traffic analysis techniques to infer the start and completion of flows without decrypting the packets. The User Data fragments of flows have unique sequence numbers, so flows are immune to replay while they are open. However, once a flow has completed and the linger period has concluded, the attacker could replay the recorded packets, opening a new flow in the receiver and duplicating the flow&#39;s data; this replay might have undesirable effects on the receiver&#39;s application. The attacker could also infer that a new flow has begun reusing the recorded flow&#39;s identifier and replay the final sequence number or any of the other fragments in the flow, potentially denying or interfering with legitimate traffic to the receiver. Therefore, the data integrity aspect of packet encryption SHOULD comprise anti-replay measures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確立されたセッションのパケットを受動的に監視および記録できる攻撃者は、トラフィック分析手法を使用して、パケットを復号化せずにフローの開始と完了を推測できます。フローのユーザーデータフラグメントには固有のシーケンス番号があるため、フローが開いている間、フローは再生の影響を受けません。ただし、フローが完了してリンガー期間が終了すると、攻撃者は記録されたパケットを再生し、レシーバーで新しいフローを開いてフローのデータを複製する可能性があります。このリプレイは、レシーバーのアプリケーションに望ましくない影響を与える可能性があります。攻撃者はまた、新しいフローが記録されたフローの識別子を再利用し始め、フロー内の最終シーケンス番号またはその他のフラグメントを再生し、受信者への正当なトラフィックを拒否または干渉する可能性があると推測することもできます。したがって、パケット暗号化のデータ整合性の側面は、アンチリプレイ対策を含む必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Acknowledgements">
6. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 謝辞
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Special thanks go to Matthew Kaufman for his contributions to the creation and design of RTMFP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPの作成と設計に貢献してくれたMatthew Kaufmanに特に感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to Jari Arkko, Ben Campbell, Wesley Eddy, Stephen Farrell, Philipp Hancke, Bela Lubkin, Hilarie Orman, Richard Scheffenegger, and Martin Stiemerling for their detailed reviews of this memo.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモの詳細なレビューを提供してくれたJari Arkko、Ben Campbell、Wesley Eddy、Stephen Farrell、Philipp Hancke、Bela Lubkin、Hilarie Orman、Richard Scheffenegger、Martin Stiemerlingに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--References">
7. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 参考文献
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1--Normative-References">
7.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 引用文献
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CBC] Dworkin, M., &#34;Recommendation for Block Cipher Modes of Operation&#34;, NIST Special Publication 800-38A, December 2001, &lt;http://csrc.nist.gov/publications/ nistpubs/800-38a/sp800-38a.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CBC] Dworkin、M。、「Block Cipher Modes of Operation」、NIST Special Publication 800-38A、December 2001、&lt;http://csrc.nist.gov/publications/ nistpubs / 800-38a / sp800-38a .pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0768] Postel, J., &#34;User Datagram Protocol&#34;, STD 6, RFC 768, August 1980.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0768] Postel、J。、「User Datagram Protocol」、STD 6、RFC 768、1980年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0791] Postel, J., &#34;Internet Protocol&#34;, STD 5, RFC 791, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0791] Postel、J。、「インターネットプロトコル」、STD 5、RFC 791、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122] Braden, R., &#34;Requirements for Internet Hosts - Communication Layers&#34;, STD 3, RFC 1122, October 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122] Braden、R。、「インターネットホストの要件-通信層」、STD 3、RFC 1122、1989年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460] Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6 (IPv6) Specification&#34;, RFC 2460, December 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460] Deering、S。およびR. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、RFC 2460、1998年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2914] Floyd, S., &#34;Congestion Control Principles&#34;, BCP 41, RFC 2914, September 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2914]フロイド、S。、「輻輳制御原則」、BCP 41、RFC 2914、2000年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4821] Mathis, M. and J. Heffner, &#34;Packetization Layer Path MTU Discovery&#34;, RFC 4821, March 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4821] Mathis、M。およびJ. Heffner、「Packetization Layer Path MTU Discovery」、RFC 4821、2007年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman, M., Paxson, V., and E. Blanton, &#34;TCP Congestion Control&#34;, RFC 5681, September 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman、M.、Paxson、V。、およびE. Blanton、「TCP Congestion Control」、RFC 5681、2009年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-2--Informative-References">
7.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 参考引用
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &#34;Session Traversal Utilities for NAT (STUN)&#34;, RFC 5389, October 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5389] Rosenberg、J.、Mahy、R.、Matthews、P。、およびD. Wing、「NAT用セッショントラバーサルユーティリティ（STUN）」、RFC 5389、2008年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ScalableTCP] Kelly, T., &#34;Scalable TCP: Improving Performance in Highspeed Wide Area Networks&#34;, December 2002, &lt;http://datatag.web.cern.ch/datatag/papers/ pfldnet2003-ctk.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ScalableTCP] Kelly、T。、「Scalable TCP：Improving Performance in Highspeed Wide Area Networks」、2002年12月、&lt;http://datatag.web.cern.ch/datatag/papers/pfldnet2003-ctk.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--Example-Congestion-Control-Algorithm">
Appendix A. Example Congestion Control Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A.輻輳制御アルゴリズムの例
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mandated in Section 3.5.2, an RTMFP is required to use TCP-compatible congestion control, but flexibility in exact implementation is allowed, within certain limits. This section describes an experimental window-based congestion control algorithm that is appropriate for real-time and bulk data transport in RTMFP. The algorithm includes slow start and congestion avoidance phases, including modified increase and decrease parameters. These parameters are further adjusted according to whether real-time data is being sent and whether Time Critical Reverse Notifications are received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.5.2で規定されているように、RTMFPはTCP互換の輻輳制御を使用する必要がありますが、特定の制限内で正確な実装の柔軟性が許可されます。このセクションでは、RTMFPのリアルタイムおよびバルクデータ転送に適した実験的なウィンドウベースの輻輳制御アルゴリズムについて説明します。アルゴリズムには、変更された増加および減少パラメーターを含む、スロースタートおよび輻輳回避フェーズが含まれます。これらのパラメータは、リアルタイムデータが送信されているかどうか、およびタイムクリティカルリバース通知が受信されているかどうかに応じてさらに調整されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-1--Discussion">
A.1. Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. 討論
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 5681 defines the standard window-based congestion control algorithms for TCP. These algorithms are appropriate for delay-insensitive bulk data transport but have undesirable behaviors for delay- and loss-sensitive applications. Among the undesirable behaviors are the cutting of the congestion window in half during a loss event, and the rapidity of the slow start algorithm&#39;s exponential growth. Cutting the congestion window in half requires a large channel headroom to support a real-time application and can cause a large amount of jitter from sender-side buffering. Doubling the congestion window during the slow start phase can lead to the congestion window temporarily growing to twice the size it should be, causing a period of excessive loss in the path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 5681は、TCPの標準的なウィンドウベースの輻輳制御アルゴリズムを定義しています。これらのアルゴリズムは、遅延の影響を受けにくいバルクデータ転送に適していますが、遅延や損失の影響を受けやすいアプリケーションでは望ましくない動作をします。望ましくない動作の中には、損失イベント中に輻輳ウィンドウを半分に切断することと、スロースタートアルゴリズムの急激な成長の速さがあります。輻輳ウィンドウを半分にカットするには、リアルタイムアプリケーションをサポートするために大きなチャネルヘッドルームが必要であり、送信側のバッファリングから大量のジッターを引き起こす可能性があります。スロースタートフェーズ中に輻輳ウィンドウを2倍にすると、輻輳ウィンドウが一時的に本来のサイズの2倍になり、パスで過度の損失が発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We found that a number of deployed TCP implementations use the method of equation (3) from Section 3.1 of RFC 5681; this method, when combined with the recommended behavior of acknowledging every other packet, causes the congestion window to grow at approximately half the rate that the recommended method specifies. In order to compete fairly with these deployed TCPs, we choose 768 bytes per round trip as the increment during the normal congestion avoidance phase; this is approximately half of the typical maximum segment size of 1500 bytes and is also easily subdivided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デプロイされたTCP実装の多くが、RFC 5681のセクション3.1の式（3）の方法を使用していることがわかりました。この方法を1つおきのパケットの確認応答の推奨される動作と組み合わせると、推奨される方法で指定されている速度の約半分で輻輳ウィンドウが拡大します。これらの展開されたTCPと公平に競争するために、通常の輻輳回避フェーズ中の増分として、ラウンドトリップあたり768バイトを選択します。これは、1500バイトの一般的な最大セグメントサイズの約半分であり、簡単に再分割することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The sender may be sending real-time data to the far end. When sending real-time data, a smoother response to congestion is desired while still competing with reasonable fairness to other flows in the Internet. In order to scale the sending rate quickly, the slow start algorithm is desired, but slow start&#39;s normal rate of increase can cause excessive loss in the last round trip. Accordingly, slow start&#39;s exponential increase rate is adjusted to double approximately every 3 round trips instead of every round trip. The multiplicative decrease cuts the congestion window by one eighth on loss to maintain a smoother sending rate. The additive increase is done at half the normal rate (incrementing at 384 bytes per round trip), to both compensate for the less aggressive loss response and probe the path capacity more gently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
送信者は、リアルタイムデータを遠端に送信している可能性があります。リアルタイムデータを送信するときは、インターネット内の他のフローとの妥当な公平性を保ちながら、輻輳に対するスムーズな応答が望まれます。送信レートをすばやくスケーリングするには、スロースタートアルゴリズムが望ましいですが、スロースタートの通常の増加率は、最後の往復で過度の損失を引き起こす可能性があります。したがって、スロースタートの指数関数的増加率は、往復ごとではなく、約3往復ごとに2倍になるように調整されます。乗法的減少により、損失時に輻輳ウィンドウが1/8に削減され、よりスムーズな送信速度が維持されます。加法的な増加は通常の半分の速度で行われ（往復あたり384バイトで増加）、あまり積極的ではない損失応答を補償し、パス容量をより穏やかに調べます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The far end may report that it is receiving real-time data from other peers, or the sender may be sending real-time data to other far ends. In these circumstances (if not sending real-time data to this far end), it is desirable to respond differently than the standard TCP algorithms specify, to both yield capacity to the real-time flows and avoid excessive losses while probing the path capacity. Slow start&#39;s exponential increase is disabled, and the additive increase is done at half the normal rate (incrementing at 384 bytes per round trip). Multiplicative decrease is left at the normal rate (cutting by half) to yield to other flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
遠端は、他のピアからリアルタイムデータを受信して​​いることを報告するか、送信者が他の遠端にリアルタイムデータを送信している可能性があります。これらの状況（リアルタイムデータをこの遠端に送信しない場合）では、標準TCPアルゴリズムが指定するのとは異なる方法で応答して、リアルタイムフローに容量を提供し、パス容量のプローブ中に過度の損失を回避することが望まれます。スロースタートの指数関数的な増加は無効になり、追加の増加は通常のレートの半分で行われます（ラウンドトリップあたり384バイトで増加します）。乗法的減少は、通常のレート（半分に削減）のままにして、他のフローに譲ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since real-time messages may be small, and sent regularly, it is advantageous to spread congestion window increases out across the round-trip time instead of doing them all at once. We divide the round trip into 16 segments with an additive increase of a useful size (48 bytes) per segment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リアルタイムメッセージは小さく、定期的に送信される可能性があるため、輻輳ウィンドウの増加をすべて一度に行うのではなく、往復時間全体に広げることが有利です。ラウンドトリップを16セグメントに分割し、セグメントごとに有効サイズ（48バイト）をさらに増やします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Scalable TCP [ScalableTCP] describes experimental methods of modifying the additive increase and multiplicative decrease of the congestion window in large delay-bandwidth scenarios. The congestion window is increased by 1% each round trip and decreased by one eighth on loss in the congestion avoidance phase in certain circumstances (specifically, when a 1% increase is larger than the normal additive-increase amount). Those methods are adapted here. The scalable increase amount is 48 bytes for every 4800 bytes acknowledged, to spread the increase out over the round trip. The congestion window is decreased by one eighth on loss when it is at least 67200 bytes per round trip, which is seven eighths of 76800 (the point at which 1% is greater than 768 bytes per round trip). When sending real-time data to the far end, the scalable increase is 1% or 384 bytes per round trip, whichever is greater. Otherwise, when notified that the far end is receiving real-time data from other peers, the scaled increase is adjusted to 0.5% or 384 bytes per round trip, whichever is greater.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スケーラブルTCP [ScalableTCP]は、大きな遅延帯域幅のシナリオでの輻輳ウィンドウの追加の増加と乗法の減少を変更する実験的な方法を説明しています。輻輳ウィンドウは、ラウンドトリップごとに1％ずつ増加し、特定の状況（特に、1％の増加が通常の加算増加量よりも大きい場合）での輻輳回避フェーズでの損失時に1/8ずつ減少します。これらのメソッドはここで適応されます。スケーラブルな増加量は、確認応答の4800バイトごとに48バイトであり、増加を往復に分散します。輻輳ウィンドウは、ラウンドトリップあたり少なくとも67200バイト、つまり76800の7分の8（1ポイントがラウンドトリップあたり768バイトを超えるポイント）である場合、損失時に1/8ずつ減少します。リアルタイムデータを遠端に送信する場合、スケーラブルな増加は1％または往復あたり384バイトのいずれか大きい方です。それ以外の場合、遠端が他のピアからリアルタイムデータを受信して​​いることが通知されると、スケーリングされた増加は、0.5％またはラウンドトリップあたり384バイトのいずれか大きい方に調整されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-2--Algorithm">
A.2. Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. アルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let SMSS denote the Sender Maximum Segment Size [RFC5681], for example 1460 bytes. Let CWND_INIT denote the Initial Congestion Window (IW) according to Section 3.1 of RFC 5681, for example 4380 bytes. Let CWND_TIMEDOUT denote the congestion window after a timeout indicating lost data, being 1*SMSS (for example, 1460 bytes).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SMSSが1460バイトなどの送信者最大セグメントサイズ[RFC5681]を示すようにします。 CWND_INITが、RFC 5681のセクション3.1に従って、初期輻輳ウィンドウ（IW）を示すとします（例：4380バイト）。 CWND_TIMEDOUTが、失われたデータを示すタイムアウト後の輻輳ウィンドウを1 * SMSS（たとえば、1460バイト）であると示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the session information context contain additional variables:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション情報コンテキストに追加の変数を含めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o CWND: the congestion window, initialized to CWND_INIT;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o CWND：CWND_INITに初期化された輻輳ウィンドウ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SSTHRESH: the slow start threshold, initialized to positive infinity;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SSTHRESH：スロースタートしきい値。正の無限大に初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ACKED_BYTES_ACCUMULATOR: a count of acknowledged bytes, initialized to 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ACKED_BYTES_ACCUMULATOR：0に初期化された確認済みバイトのカウント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ACKED_BYTES_THIS_PACKET: a count of acknowledged bytes observed in the current packet;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ACKED_BYTES_THIS_PACKET：現在のパケットで確認された確認済みバイトの数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PRE_ACK_OUTSTANDING: the number of bytes outstanding in the network before processing any acknowledgements in the current packet;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PRE_ACK_OUTSTANDING：現在のパケットの確認応答を処理する前の、ネットワークで未処理のバイト数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ANY_LOSS: an indication of whether any loss has been detected in the current packet;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ANY_LOSS：現在のパケットで損失が検出されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ANY_NAKS: an indication of whether any negative acknowledgements have been detected in the current packet;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ANY_NAKS：現在のパケットで否定応答が検出されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ANY_ACKS: an indication of whether any acknowledgement chunks have been received in the current packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ANY_ACKS：確認応答チャンクが現在のパケットで受信されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let FASTGROW_ALLOWED indicate whether the congestion window is allowed to grow at the normal rate versus a slower rate, being false if a Time Critical Reverse Notification has been received on this session within the last 800 milliseconds (Sections 2.2.4 and 3.5.2.1) or if a Time Critical Forward Notification has been sent on ANY session in the last 800 milliseconds, and otherwise being true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FASTGROW_ALLOWEDに、輻輳ウィンドウが通常の速度よりも遅い速度で拡大できるかどうかを示し、このセッションで過去800ミリ秒以内にタイムクリティカルリバース通知が受信された場合（セクション2.2.4および3.5.2.1）またはfalse Time Critical Forward Notificationが過去800ミリ秒の間に任意のセッションで送信された場合、それ以外の場合はtrue。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let TC_SENT indicate whether a Time Critical Forward Notification has been sent on this session within the last 800 milliseconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TC_SENTに、このセッションで過去800ミリ秒以内にタイムクリティカル転送通知が送信されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implement the method described in Section 3.6.2.6 to manage transmission timeouts, including setting the TIMEOUT_ALARM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TIMEOUT_ALARMの設定など、送信タイムアウトを管理するために、3.6.2.6で説明されているメソッドを実装します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On being notified that the TIMEOUT_ALARM has fired, perform the function shown in Figure 24:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TIMEOUT_ALARMが発生したことが通知されたら、図24に示す機能を実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
on TimeoutNotification(WAS_LOSS): set SSTHRESH to MAX(SSTHRESH, CWND * 3/4). set ACKED_BYTES_ACCUMULATOR to 0. if WAS_LOSS is true: set CWND to CWND_TIMEDOUT. else: set CWND to CWND_INIT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
on TimeoutNotification（WAS_LOSS）：SSTHRESHをMAX（SSTHRESH、CWND * 3/4）に設定します。 ACKED_BYTES_ACCUMULATORを0に設定します。WAS_LOSSがtrueの場合：CWNDをCWND_TIMEDOUTに設定します。それ以外の場合：CWNDをCWND_INITに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Figure 24: Pseudocode for Handling a Timeout Notification
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
図24：タイムアウト通知を処理するための疑似コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before processing each received packet in this session:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセッションで受信した各パケットを処理する前に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Set ANY_LOSS to false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. ANY_LOSSをfalseに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Set ANY_NAKS to false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. ANY_NAKSをfalseに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Set ACKED_BYTES_THIS_PACKET to 0; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. ACKED_BYTES_THIS_PACKETを0に設定します。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Set PRE_ACK_OUTSTANDING to S_OUTSTANDING_BYTES.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. PRE_ACK_OUTSTANDINGをS_OUTSTANDING_BYTESに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On notification of loss (Section 3.6.2.5), set ANY_LOSS to true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
損失の通知（セクション3.6.2.5）で、ANY_LOSSをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On notification of negative acknowledgement (Section 3.6.2.5), set ANY_NAKS to true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
否定応答の通知（セクション3.6.2.5）で、ANY_NAKSをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On notification of acknowledgement of data (Section 3.6.2.4), set ANY_ACKS to true, and add the count of acknowledged bytes to ACKED_BYTES_THIS_PACKET.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データの確認の通知（セクション3.6.2.4）で、ANY_ACKSをtrueに設定し、確認済みバイトの数をACKED_BYTES_THIS_PACKETに追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After processing all chunks in each received packet for this session, perform the function shown in Figure 25:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセッションで受信した各パケットのすべてのチャンクを処理した後、図25に示す機能を実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
if ANY_LOSS is true: if (TC_SENT is true) OR (PRE_ACK_OUTSTANDING &gt; 67200 AND \ FASTGROW_ALLOWED is true): set SSTHRESH to MAX(PRE_ACK_OUTSTANDING * 7/8, CWND_INIT). else: set SSTHRESH to MAX(PRE_ACK_OUTSTANDING * 1/2, CWND_INIT). set CWND to SSTHRESH. set ACKED_BYTES_ACCUMULATOR to 0. else if (ANY_ACKS is true) AND (ANY_NAKS is false) AND \ (PRE_ACK_OUTSTANDING &gt;= CWND): set var INCREASE to 0. var AITHRESH. if FASTGROW_ALLOWED is true: if CWND &lt; SSTHRESH: set INCREASE to ACKED_BYTES_THIS_PACKET. else: add ACKED_BYTES_THIS_PACKET to ACKED_BYTES_ACCUMULATOR. set AITHRESH to MIN(MAX(CWND / 16, 64), 4800). while ACKED_BYTES_ACCUMULATOR &gt;= AITHRESH: subtract AITHRESH from ACKED_BYTES_ACCUMULATOR. add 48 to INCREASE. else FASTGROW_ALLOWED is false: if CWND &lt; SSTHRESH AND TC_SENT is true: set INCREASE to CEIL(ACKED_BYTES_THIS_PACKET / 4). else: var AITHRESH_CAP. if TC_SENT is true: set AITHRESH_CAP to 2400. else: set AITHRESH_CAP to 4800. add ACKED_BYTES_THIS_PACKET to ACKED_BYTES_ACCUMULATOR. set AITHRESH to MIN(MAX(CWND / 16, 64), AITHRESH_CAP). while ACKED_BYTES_ACCUMULATOR &gt;= AITHRESH: subtract AITHRESH from ACKED_BYTES_ACCUMULATOR. add 24 to INCREASE. set CWND to MAX(CWND + MIN(INCREASE, SMSS), CWND_INIT).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ANY_LOSSがtrueの場合：（TC_SENTがtrue）または（PRE_ACK_OUTSTANDING&gt; 67200 AND \ FASTGROW_ALLOWEDがtrueの場合）：SSTHRESHをMAX（PRE_ACK_OUTSTANDING * 7/8、CWND_INIT）に設定します。それ以外の場合：SSTHRESHをMAX（PRE_ACK_OUTSTANDING * 1/2、CWND_INIT）に設定します。 CWNDをSSTHRESHに設定します。 ACKED_BYTES_ACCUMULATORを0に設定します。それ以外の場合（ANY_ACKSがtrue）AND（ANY_NAKSがfalse）AND \（PRE_ACK_OUTSTANDING&gt; = CWND）：var INCREASEを0に設定します。varAITHRESH。 FASTGROW_ALLOWEDがtrueの場合：CWND &lt;SSTHRESHの場合：INCREASEをACKED_BYTES_THIS_PACKETに設定します。それ以外の場合：ACKED_BYTES_THIS_PACKETをACKED_BYTES_ACCUMULATORに追加します。 AITHRESHをMIN（MAX（CWND / 16、64）、4800）に設定します。 ACKED_BYTES_ACCUMULATOR&gt; = AITHRESHの場合：ACKED_BYTES_ACCUMULATORからAITHRESHを減算します。 INCREASEに48を加算します。それ以外の場合、FASTGROW_ALLOWEDはfalseです。CWND&lt;SSTHRESH AND TC_SENTがtrueの場合：INCREASEをCEIL（ACKED_BYTES_THIS_PACKET / 4）に設定します。それ以外の場合：var AITHRESH_CAP。 TC_SENTが真の場合：AITHRESH_CAPを2400に設定します。それ以外の場合：AITHRESH_CAPを4800に設定します。ACKED_BYTES_THIS_PACKETをACKED_BYTES_ACCUMULATORに追加します。 AITHRESHをMIN（MAX（CWND / 16、64）、AITHRESH_CAP）に設定します。 ACKED_BYTES_ACCUMULATOR&gt; = AITHRESHの場合：ACKED_BYTES_ACCUMULATORからAITHRESHを減算します。 INCREASEに24を加算します。 CWNDをMAX（CWND + MIN（INCREASE、SMSS）、CWND_INIT）に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Figure 25: Pseudocode for Congestion Window Adjustment after Processing a Packet
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
図25：パケット処理後の輻輳ウィンドウ調整の疑似コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Michael C. Thornburgh Adobe Systems Incorporated 345 Park Avenue San Jose, CA 95110-2704 US
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Michael C. Thornburgh Adob​​e Systems Incorporated 345 Park Avenue San Jose、CA 95110-2704 US
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 408 536 6000
   EMail: mthornbu@adobe.com
   URI:   http://www.adobe.com/
        </pre>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
