<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 3089 - A SOCKS-based IPv6/IPv4 Gateway Mechanism 日本語訳</title>
  <meta name="description" content="要約：RFC 3089は、IPv6とIPv4のゲートウェイメカニズムであるSOCKSをベースにしたプロトコルについての規格です。
目的：このRFCの目的は、IPv6とIPv4のネットワーク間での通信を可能にするためのゲートウェイメカニズムを提供することです。">

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3089</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc3089">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 3089 - A SOCKS-based IPv6/IPv4 Gateway Mechanism 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc3089">
            https://datatracker.ietf.org/doc/html/rfc3089
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 3089 - ソックスベースのIPv6/IPv4ゲートウェイメカニズム</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] 要約：RFC 3089は、IPv6とIPv4のゲートウェイメカニズムであるSOCKSをベースにしたプロトコルについての規格です。
目的：このRFCの目的は、IPv6とIPv4のネットワーク間での通信を可能にするためのゲートウェイメカニズムを提供することです。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                        H. Kitamura
Request for Comments: 3089                               NEC Corporation
Category: Informational                                       April 2001
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
A SOCKS-based IPv6/IPv4 Gateway Mechanism
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
ソックスベースのIPv6/IPv4ゲートウェイメカニズム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2001). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）The Internet Society（2001）。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes a SOCKS-based IPv6/IPv4 gateway mechanism that enables smooth heterogeneous communications between the IPv6 nodes and IPv4 nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、IPv6ノードとIPv4ノード間のスムーズな不均一な通信を可能にするソックスベースのIPv6/IPv4ゲートウェイメカニズムについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is based on the SOCKS protocol [SOCKSv5]. By applying the SOCKS mechanism to the heterogeneous communications and relaying two &#34;terminated&#34; IPv4 and IPv6 connections at the &#34;application layer&#34; (the SOCKS server), the SOCKS-based IPv6/IPv4 gateway mechanism is accomplished.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Socksプロトコル[Socksv5]に基づいています。ソックスメカニズムを不均一な通信に適用し、「アプリケーションレイヤー」（ソックスサーバー）で2つの「終了した」IPv4およびIPv6接続を中継することにより、ソックスベースのIPv6/IPv4ゲートウェイメカニズムが達成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since it is accomplished without introducing new protocols, it provides the same communication environment that is provided by the SOCKS mechanism. The same appearance is provided to the heterogeneous communications. No conveniences or functionalities of current communications are sacrificed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいプロトコルを導入せずに達成されるため、ソックスメカニズムによって提供されるのと同じ通信環境を提供します。同じ外観が不均一な通信に提供されています。現在の通信の便利さや機能は犠牲にされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SOCKS-based IPv6/IPv4 gateway mechanism is based on a mechanism that relays two &#34;terminated&#34; IPv4 and IPv6 connections at the &#34;application layer&#34; (the SOCKS server); its characteristics are inherited from those of the connection relay mechanism at the application layer and those of the native SOCKS mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソックスベースのIPv6/IPv4ゲートウェイメカニズムは、「アプリケーションレイヤー」（ソックスサーバー）で2つの「終了した」IPv4およびIPv6接続を中継するメカニズムに基づいています。その特性は、アプリケーション層の接続リレーメカニズムとネイティブソックスメカニズムの特性から継承されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Basic-SOCKS-based-Gateway-Mechanism">
2. Basic SOCKS-based Gateway Mechanism
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 基本的な靴下ベースのゲートウェイメカニズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 1 shows the basic SOCKS-based gateway mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図1は、基本的なソックスベースのゲートウェイメカニズムを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  Client C       Gateway G     Destination D
               +-----------+     (Server)
               |Application|
           +--&gt;+===========+  +-------------+  +-----------+
      same-+   |*SOCKS Lib*|  |  *Gateway*  |  |Application|
       API +--&gt;+===========+  +=====---=====+  +-----------+
               | Socket DNS|  | Socket  DNS |  | Socket DNS|
               +-----------+  +-------------+  +-----------+
               | [ IPv X ] |  |[IPvX]|(IPvY)|  | ( IPv Y ) |
               +-----------+  +-------------+  +-----------+
               |Network I/F|  | Network I/F |  |Network I/F|
               +-----+-----+  +---+-----+---+  +-----+-----+
                     |            |     |            |
                     +============+     +------------+
                       socksified           normal
                       connection         connection
                      (ctrl)+data          data only
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
Fig. 1 Basic SOCKS-based Gateway Mechanism
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
図1基本的なソックスベースのゲートウェイメカニズム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this figure, the Client C initiates the communication to the Destination D. Two new functional blocks are introduced and they compose the mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この図では、クライアントCが宛先Dへの通信を開始します。2つの新しい機能ブロックが導入され、メカニズムを構成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One, *Socks Lib*, is introduced into the client side (Client C) (this procedure is called &#34;socksifying&#34;). The *Socks Lib* is located between the application layer and the socket layer, and can replace applications&#39; socket APIs and DNS name resolving APIs (e.g., gethostbyname(), getaddrinfo() etc.). There is a mapping table in it for a &#34;DNS name resolving delegation&#34; feature (described below). Each socksified application has its own *Socks Lib*.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つ、 *Socks lib *はクライアント側に導入されます（クライアントC）（この手順は「ソックシーケーション」と呼ばれます）。* Socks lib *は、アプリケーションレイヤーとソケット層の間にあり、アプリケーションのソケットAPIとDNS名を解決するAPI（gethostbyname（）、getaddrinfo（）などを置き換えることができます。「DNS名解決委任」機能（以下で説明）のマッピングテーブルがあります。各ソックシー型アプリケーションには、独自の *ソックスlib *があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The other, *Gateway*, is installed on the IPv6 and IPv4 dual stack node (Gateway G). It is an enhanced SOCKS server that enables any types of protocol combination relays between Client C (IPvX) and Destination D (IPvY). When the *Socks Lib* invokes a relay, one corresponding *Gateway* process (thread) is spawned from the parent *Gateway* to take charge of the relay connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もう1つの *Gateway *は、IPv6およびIPv4デュアルスタックノード（Gateway G）にインストールされています。これは、クライアントC（IPVX）と宛先D（IPVY）の間のあらゆる種類のプロトコルの組み合わせリレーを有効にする拡張ソックスサーバーです。* Socks lib *がリレーを呼び出すと、対応する *ゲートウェイ *プロセス（スレッド）が親 *ゲートウェイ *から生成され、リレー接続を担当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following four types of combinations of IPvX and IPvY are possible in the mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メカニズムでは、次の4種類のIPVXとIPVYの組み合わせが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    type C ------ G ------ D
           [IPvX]   (IPvY)
     A      IPv4     IPv4       homogeneous (normal SOCKS)
     B      IPv4     IPv6     * heterogeneous *
     C      IPv6     IPv4     * heterogeneous *
     D      IPv6     IPv6       homogeneous
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type A is supported by the normal SOCKS mechanism. Type B and C are the main targets for the SOCKS-based IPv6/IPv4 gateway mechanism. They provide heterogeneous communications. Type D can be supported by the natural extension of the SOCKS mechanism, because it is a homogeneous communication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプAは、通常の靴下メカニズムによってサポートされています。タイプBとCは、ソックスベースのIPv6/IPv4ゲートウェイメカニズムの主なターゲットです。彼らは異質なコミュニケーションを提供します。タイプDは、均一な通信であるため、Socksメカニズムの自然な拡張によってサポートできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the *Socks Lib* communicates with the *Gateway* by using SOCKS protocol [SOCKSv5], the connection between them (the Client C and the Gateway G) is a special connection and is called a &#34;socksified connection&#34;. It can transfer not only data but also control information (e.g., the location information of Destination D).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Socks lib *は、Socksプロトコル[Socksv5]を使用して *ゲートウェイ *と通信するため、それら（クライアントCとゲートウェイG）の間の接続は特別な接続であり、「ソック化された接続」と呼ばれます。データだけでなく、制御情報（宛先Dの位置情報など）も転送できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The connection between the Gateway G and the Destination D is a normal connection. It is not modified (socksified). A server application that runs on Destination D does not notice the existence of the Client C. It recognizes that the peer node of the connection is the Gateway G (not Client C).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ゲートウェイGと宛先Dの間の接続は、通常の接続です。修正されていません（ソックシーリング）。宛先Dで実行されるサーバーアプリケーションは、クライアントCの存在に気付かないC.接続のピアノードがゲートウェイG（クライアントCではない）であることを認識しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
No new protocols are introduced to the SOCKS protocol [SOCKSv5] to accomplish the mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メカニズムを達成するために、Socksプロトコル[Socksv5]に新しいプロトコルは導入されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Packet Size Adjustment
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* パケットサイズの調整
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Since the length of the IPv6 header is different from that of the IPv4 header, it is necessary to consider the packet size adjustment in heterogeneous communications. If this is not taken into consideration, the packet size may exceed the MTU of the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
IPv6ヘッダーの長さはIPv4ヘッダーの長さとは異なるため、不均一通信のパケットサイズの調整を考慮する必要があります。これが考慮されない場合、パケットサイズはネットワークのMTUを超える可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
In the SOCKS-based IPv6/IPv4 gateway mechanism, it never exceeds the MTU, because the mechanism is based on relaying two &#34;terminated&#34; connections at the &#34;application layer&#34;. The relayed data is a simple data stream for the application, and the packet size is naturally adjusted at each relayed connection side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
ソックスベースのIPv6/IPv4ゲートウェイメカニズムでは、メカニズムは「アプリケーションレイヤー」で2つの「終了」接続を中継することに基づいているため、MTUを超えることはありません。中継データは、アプリケーションの単純なデータストリームであり、パケットサイズは各リレー接続側で自然に調整されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Authenticated Relay
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 認証されたリレー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Since the SOCKS is originally designed for firewall systems and it has various authentication methods, the relayed connections can be authenticated by the native SOCKS authentication methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
ソックスはもともとファイアウォールシステム用に設計されており、さまざまな認証方法を備えているため、リレーされた接続はネイティブソックス認証方法によって認証できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--DNS-Name-Resolving-Procedure">
3. DNS Name Resolving Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. DNS名解決手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In all communication applications, it is a necessary to obtain destination IP address information to start a communication. It is, however, theoretically impossible for the heterogeneous communications to obtain correct information, because an existing IPv4 application can not deal with an IPv6 address. It prepares only a 4-byte address space to store an IP address information, and it can not store an IPv6 address information into there. This is a critical problem caused by differences in address length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての通信アプリケーションで、通信を開始するために宛先IPアドレス情報を取得する必要があります。ただし、既存のIPv4アプリケーションはIPv6アドレスを処理できないため、不均一な通信が正しい情報を取得することは理論的には不可能です。IPアドレス情報を保存するための4バイトのアドレススペースのみを準備し、IPv6アドレス情報をそこに保存することはできません。これは、アドレスの長さの違いによって引き起こされる重大な問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to solve the problem, a feature called &#34;DNS name resolving delegation&#34; is used in the SOCKS-based IPv6/IPv4 gateway mechanism. The feature involves the delegating of DNS name resolving actions at the source node (Client C) to the relay server (Gateway G). Since the relay server is an IPv4 and IPv6 dual stack node, DNS name resolving queries for any address family types of destinations can be made without causing any problems. Therefore, it is not necessary to modify the existing DNS mechanism at all.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
問題を解決するために、ソックスベースのIPv6/IPv4ゲートウェイメカニズムで「DNS名解決委任」と呼ばれる機能が使用されます。この機能には、ソースノード（クライアントc）でアクションを解決するDNS名の委任がリレーサーバー（ゲートウェイG）に委任されます。リレーサーバーはIPv4およびIPv6デュアルスタックノードであるため、任意のアドレスファミリタイプの宛先のDNS名解決クエリは、問題を引き起こすことなく作成できます。したがって、既存のDNSメカニズムをまったく変更する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The feature supports not only the case in which a destination logical host name (FQDN) information is given but also the case in which a destination literal (numerical) IP address is given. The latter case is supported in almost the same way as the former case. Since the literal IPv6 address expression includes colons (&#34;:&#34;), it is identified as an FQDN (not a literal IPv4 address) for the IPv4 application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この機能は、宛先の論理ホスト名（FQDN）情報が与えられる場合だけでなく、宛先リテラル（数値）IPアドレスが指定されている場合もサポートします。後者のケースは、前者のケースとほぼ同じ方法でサポートされています。リテラルIPv6アドレス式にはコロン（ &#34;：&#34;）が含まれているため、IPv4アプリケーションのFQDN（リテラルIPv4アドレスではない）として識別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SOCKS protocol specification [SOCKSv5] defines that IPv4 address, IPv6 address, and DOMAINNAME (FQDN) information can be used in the ATYP (address type) field of the SOCKS protocol format. In the &#34;DNS name resolving delegation&#34; feature, the DOMAINNAME (FQDN) information is used in the ATYP (address type) field. The FQDN information is transferred from the Client C to the Gateway G to indicate the Destination D.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Socks Protocol Specification [Socksv5]は、IPv4アドレス、IPv6アドレス、およびドメイン名（FQDN）情報がSocksプロトコル形式のATYP（アドレスタイプ）フィールドで使用できることを定義しています。「DNS名解決委任」機能では、domainname（fqdn）情報がATYP（アドレスタイプ）フィールドで使用されています。FQDN情報は、クライアントCからゲートウェイGに転送され、宛先Dを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to solve the formerly explained critical problem, an appropriate &#34;fake IP&#34; address is introduced in the feature, and it is used as a virtual destination IP address for a socksified application. A mapping table is also introduced in the *Socks Lib* (at the Client C) to manage mappings between &#34;fake IP&#34; and &#34;FQDN&#34;. A &#34;fake IP&#34; address is used as a key to look up the corresponding &#34;FQDN&#34; information. The mapping table is local and independent of other applications or their *Socks Lib*s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前に説明されていた重要な問題を解決するために、この機能には適切な「偽のIP」アドレスが導入されており、ソックシーリングアプリケーションの仮想宛先IPアドレスとして使用されます。「偽のIP」と「FQDN」の間のマッピングを管理するために、 * Socks Lib *（クライアントc）にマッピングテーブルも導入されています。「偽のIP」アドレスは、対応する「FQDN」情報を検索するためのキーとして使用されます。マッピングテーブルはローカルであり、他のアプリケーションまたはその *ソックスlib *に依存しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transparentness to applications is maintained in the feature. Nothing special is required to execute it except socksifying the applications. Since DNS name resolving APIs are replaced by the *Socks Lib*, the &#34;DNS name resolving delegation&#34; is executed internally merely by calling the DNS name resolving APIs in ordinal methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションへの透明度は、この機能に維持されます。 アプリケーションのソックシーシングを除いて、それを実行するために特別なものは必要ありません。 DNS名の解決APIは *Socks lib *に置き換えられるため、「DNS名解決委任」は、DNS名を呼び出して、APIを序数で解決するだけで内部的に実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;DNS name resolving delegation&#34; is accomplished only when FQDN information is used in the ATYP (address type) field of the SOCKS command. Therefore, it is mandatory to do so for heterogeneous communications. The method of using FQDN information in the ATYP field depends on the configuration setting and implementation of the SOCKS protocol. In order to simplify the discussion, only the case in which the FQDN information is used in the ATYP field is discussed here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「DNS名解決委任」は、SocksコマンドのATYP（アドレスタイプ）フィールドでFQDN情報が使用されている場合にのみ達成されます。したがって、不均一なコミュニケーションのためにそうすることは必須です。ATYPフィールドでFQDN情報を使用する方法は、ソックスプロトコルの構成設定と実装に依存します。議論を簡素化するために、ATYPフィールドでFQDN情報が使用される場合のみについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The detailed internal procedure of the &#34;DNS name resolving delegation&#34; and address mapping management related issues are described as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「DNS名解決委任」の詳細な内部手順とアドレスマッピング管理に関連する問題は、次のように説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. An application on the source node (Client C) tries to get the IP address information of the destination node (Destination D) by calling the DNS name resolving function (e.g., gethostbyname()). At this time, the logical host name (&#34;FQDN&#34;) information of the Destination D is passed to the application&#39;s *Socks Lib* as an argument of called APIs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. ソースノード（クライアントC）のアプリケーションは、DNS名解決関数（gethostbyname（））を呼び出すことにより、宛先ノード（宛先D）のIPアドレス情報を取得しようとします。この時点で、宛先Dの論理ホスト名（ &#34;fqdn&#34;）情報は、APIと呼ばれる引数として、アプリケーションの * Socks lib *に渡されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Since the *Socks Lib* has replaced such DNS name resolving APIs, the real DNS name resolving APIs is not called here. The argued &#34;FQDN&#34; information is merely registered into a mapping table in *Socks Lib*, and a &#34;fake IP&#34; address is selected as information that is replied to the application from a reserved special IP address space that is never used in real communications (e.g., 0.0.0.x). The address family type of the &#34;fake IP&#34; address must be suitable for requests called by the applications. Namely, it must belong to the same address family of the Client C, even if the address family of the Destination D is different from it. After the selected &#34;fake IP&#34; address is registered into the mapping table as a pair with the &#34;FQDN&#34;, it is replied to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. * Socks lib *はこのようなDNS名の解決APIを置き換えたため、APIを解決する実際のDNS名はここでは呼ばれません。議論された「FQDN」情報は、 *Socks lib *のマッピングテーブルに単に登録されており、「偽のIP」アドレスは、実際の通信では使用されない予約された特別なIPアドレススペースからアプリケーションに返信される情報として選択されます。（例：0.0.0.x）。「偽のIP」アドレスのアドレスファミリタイプは、アプリケーションが呼び出すリクエストに適している必要があります。つまり、宛先Dのアドレスファミリがそれとは異なる場合でも、クライアントCの同じアドレスファミリーに属する必要があります。選択した「偽のIP」アドレスが「FQDN」とのペアとしてマッピングテーブルに登録された後、アプリケーションに返信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The application receives the &#34;fake IP&#34; address, and prepares a &#34;socket&#34;. The &#34;fake IP&#34; address information is used as an element of the &#34;socket&#34;. The application calls socket APIs (e.g., connect()) to start a communication. The &#34;socket&#34; is used as an argument of the APIs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. アプリケーションは「偽のIP」アドレスを受信し、「ソケット」を準備します。「偽のIP」アドレス情報は、「ソケット」の要素として使用されます。アプリケーションは、ソケットAPI（例：Connect（））を呼び出して通信を開始します。「ソケット」は、APIの引数として使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Since the *Socks Lib* has replaced such socket APIs, the real socket function is not called. The IP address information of the argued socket is checked. If the address belongs to the special address space for the fake address, the matched registered &#34;FQDN&#34; information of the &#34;fake IP&#34; address is obtained from the mapping table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. * Socks lib *はこのようなソケットAPIを置き換えたため、実際のソケット機能は呼び出されません。引数ソケットのIPアドレス情報がチェックされます。アドレスが偽のアドレスの特別なアドレススペースに属している場合、「偽のIP」アドレスの登録された「FQDN」情報がマッピングテーブルから取得されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. The &#34;FQDN&#34; information is transferred to the *Gateway* on the relay server (Gateway G) by using the SOCKS command that is matched to the called socket APIs. (e.g., for connect(), the CONNECT command is used.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 「FQDN」情報は、呼び出されたソケットAPIに一致するソックスコマンドを使用して、リレーサーバー（ゲートウェイG）の *ゲートウェイ *に転送されます。（たとえば、connect（）の場合、connectコマンドが使用されます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Finally, the real DNS name resolving API (e.g., getaddrinfo()) is called at the *Gateway*. At this time, the received &#34;FQDN&#34; information via the SOCKS protocol is used as an argument of the called APIs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 最後に、APIを解決する実際のDNS名（getaddrinfo（））が *ゲートウェイ *で呼び出されます。この時点で、Socksプロトコルを介した受信した「FQDN」情報は、呼び出されたAPIの引数として使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. The *Gateway* obtains the &#34;real IP&#34; address from a DNS server, and creates a &#34;socket&#34;. The &#34;real IP&#34; address information is used as an element of the &#34;socket&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. *ゲートウェイ *は、DNSサーバーから「実際のIP」アドレスを取得し、「ソケット」を作成します。「実際のIP」アドレス情報は、「ソケット」の要素として使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. The *Gateway* calls socket APIs (e.g., connect()) to communicate with the Destination D. The &#34;socket&#34; is used as an argument of the APIs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. * Gateway *は、Socket API（例：Connect（））を呼び出して宛先Dと通信します。「ソケット」はAPIの引数として使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The problem with the feature is that failures of the DNS name resolving process are detected incorrectly at the source node (Client C). They are detected as connection-establishment failures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この機能の問題は、DNS名解決プロセスの障害がソースノード（クライアントC）で誤って検出されることです。それらは、接続確立の障害として検出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Restrictions on applicability of &#34;fake IP&#34; address, etc., are described in Section 5.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（「偽のIP」アドレスなどの適用性に関する制限は、セクション5で説明されています。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Operations for Address Management (reservation, mapping etc.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 住所管理のための操作（予約、マッピングなど）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SOCKS-based gateway mechanism does not require the reserving of a wide global address space for the address mapping, and complex address allocation and garbage-collection mechanisms are not necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソックスベースのゲートウェイメカニズムでは、アドレスマッピング用の広いグローバルアドレススペースを予約する必要はなく、複雑なアドレス割り当てとガベージ収集メカニズムは必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Such address management operations are done at the *Socks Lib* by using the fake IP address and the mapping table for the DNS name resolving delegation. Since the mapping table is prepared in each application, it is locally closed and independent of other applications. Therefore, it is easy to manage the table, and it is not necessary to reserve a wide global address space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このようなアドレス管理操作は、偽のIPアドレスとDNS名解決委任のマッピングテーブルを使用して、 * Socks lib *で行われます。マッピングテーブルは各アプリケーションで準備されているため、局所的に閉鎖され、他のアプリケーションから独立しています。したがって、テーブルを管理するのは簡単であり、広いグローバルアドレススペースを予約する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Multiple-Chained-Relay-Mechanism-Advanced-usage">
4. Multiple Chained Relay Mechanism (Advanced usage)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 複数のチェーンリレーメカニズム（高度な使用法）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SOCKS-based gateway mechanism has the flexibility to support multiple chained relay topologies. With the mechanism, IPv4 and IPv6 mixed various communication topologies are accomplished.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソックスベースのゲートウェイメカニズムには、複数のチェーンリレートポロジーをサポートする柔軟性があります。メカニズムにより、IPv4とIPv6はさまざまな通信トポロジを混合しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 2 shows the structure of the multiple chained relay mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図2は、複数の鎖リレーメカニズムの構造を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        Client C       Gateway G1       Gateway G2    Destination D
     +-----------+     (Server 1)       (Server 2)
     |Application|
     +===========+  +-------------+  +-------------+  +-----------+
     |*SOCKS Lib*|  |  *Gateway1* |  |  *Gateway2* |  |Application|
     +===========+  +=====---=====+  +=====---=====+  +-----------+
     | Socket DNS|  | Socket  DNS |  | Socket  DNS |  | Socket DNS|
     +-----------+  +-------------+  +-------------+  +-----------+
     | [ IPv X ] |  |[IPvX]|(IPvY)|  |(IPvY)|{IPvZ}|  | { IPv Z } |
     +-----------+  +-------------+  +-------------+  +-----------+
     |Network I/F|  | Network I/F |  | Network I/F |  |Network I/F|
     +-----+-----+  +---+-----+---+  +---+-----+---+  +-----+-----+
           |            |     |          |     |            |
           +============+     +==========+     +------------+
             socksified        socksified          normal
             connection        connection        connection
            (ctrl)+data       (ctrl)+data         data only
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Fig. 2 Multiple Chained Relay Mechanism
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
図2複数の鎖のリレーメカニズム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this figure, the source node (Client C) initiates the communication with the destination (Destination D). Underneath, the connection is replaced with three connections, and they are relayed at the two relay servers (Gateway G1 and G2). The *Gateway* includes the same type of functions of *Socks Lib*. By enabling the *Socks Lib* functions at the *Gateway1* on the first relay server (Gateway G1), the multiple chained relay topology is accomplished.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この図では、ソースノード（クライアントC）が宛先との通信（宛先D）を開始します。その下には、接続が3つの接続に置き換えられ、2つのリレーサーバー（Gateway G1およびG2）でリレーされます。*Gateway *には、 *Socks lib *の同じタイプの関数が含まれています。最初のリレーサーバー（Gateway G1）の * Gateway1 *で * Socks lib *機能を有効にすることにより、複数のチェーンリレートポロジが達成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is no limitation on the number of relay operations between the source node and the final destination node. It is possible to have more than two intermediate relay servers. To simplify the explanation, a twice-relayed topology is shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースノードと最終宛先ノードの間のリレー操作の数に制限はありません。2つ以上の中間リレーサーバーを持つことができます。説明を簡素化するために、ここに2回のリラックスされたトポロジーが示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the multiple chained relay is more complex than one-time relay and causes complexity, it is recommended that the multiple chained relay communication should be used only when it is necessary for some reason (e.g., usable protocols or topologies are limited by routers etc.).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のチェーンリレーは1回限りのリレーよりも複雑で複雑さを引き起こすため、何らかの理由で複数のチェーンリレー通信を使用することをお勧めします（たとえば、使用可能なプロトコルまたはトポロジーはルーターなどによって制限されます。）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Applicability-statement">
5. Applicability statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. アプリケーションステートメント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SOCKS-based gateway mechanism requests socksification of applications (install *Socks Lib*) to accomplish heterogeneous communications. It is not necessary to modify (change source codes and recompile them, etc.) the applications, because typical socksification is done by changing the linking order of dynamic link libraries (specifically, by linking the SOCKS dynamic link library before the dynamic link libraries for normal socket and DNS name resolving APIs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソックスベースのゲートウェイメカニズムは、異種通信を達成するために、アプリケーションのソックシクション（ *ソックスlib *）を要求します。典型的なソックサイズは、ダイナミックリンクライブラリのリンク順序を変更することによって行われるため、アプリケーションを変更（ソースコードを変更して再コンパイルするなど）する必要はありません（特に、ソックスダイナミックリンクライブラリをダイナミックリンクライブラリの前にリンクすることによって行われます。APIの解決の通常のソケットとDNS名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mechanism does not request modification of the DNS system, because the DNS name resolving procedure at the Client C is delegated to the dual stack node Gateway G.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メカニズムは、クライアントCでのDNS名解決手順がデュアルスタックノードゲートウェイGに委任されるため、DNSシステムの変更を要求しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other than the socksification, the SOCKS-based gateway mechanism has the following three types of constraints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソックスベースのゲートウェイメカニズムには、靴下の除去以外に、次の3つのタイプの制約があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Essential constraints:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 本質的な制約：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Constraints are caused by the address length difference between IPv4 and IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
制約は、IPv4とIPv6のアドレス長の違いによって引き起こされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Functions that request an IP address as one of the return values (e.g., getpeername() and getsockname() etc.) can not provide the correct IP address as a return value. However, a suitable port value can be provided, because IPv4 and IPv6 use the same size port space and an appropriate port information is transferred by the SOCKS protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPアドレスを返す値の1つとして要求する関数（例：getPeername（）およびgetSockName（）など）は、正しいIPアドレスを返品値として提供できません。ただし、IPv4とIPv6は同じサイズのポートスペースを使用し、Socksプロトコルによって適切なポート情報が転送されるため、適切なポート値を提供できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Constraints of the SOCKS mechanism:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. ソックスメカニズムの制約：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Since the current SOCKS system can not socksify all of the tricky applications in which extraordinary manners are used to create connections, the SOCKS-based gateway mechanism can not be applied to them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
現在のSocksシステムは、接続を作成するために並外れたマナーが使用されるすべてのトリッキーなアプリケーションをソックシー化できないため、ソックスベースのゲートウェイメカニズムを適用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Constraints to deal with the fake address:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 偽のアドレスに対処するための制約：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The fake address must be dealt with as a temporary value at the application. It is used as a key value in the mapping table for the &#34;DNS name resolving delegation&#34; feature. When the application is finished and the mapping table disappears, the fake address information must be also released.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
偽のアドレスは、アプリケーションの一時的な価値として扱わなければなりません。「DNS名解決委任」機能のマッピングテーブルのキー値として使用されます。アプリケーションが終了し、マッピングテーブルが消えると、偽のアドレス情報もリリースする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Even if it is recorded permanently (e.g., recorded as a bookmark), serious problems will not occur. The recorded fake address information will merely become useless, because fake address information is taken from a reserved special IP address space that is never used in real communications (e.g., 0.0.0.x) and such a information is useless for the normal communication applications. Furthermore, such cases will be rare because most applications usually record FQDN information (not fake IP address information) to the bookmark, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
たとえそれが永続的に記録されていても（たとえば、ブックマークとして記録されている）、深刻な問題は発生しません。偽のアドレス情報は、実際の通信では使用されない予約された特別なIPアドレススペース（0.0.0.xなど）から取得され、そのような情報は通常の通信アプリケーションでは役に立たないため、録音された偽のアドレス情報は単に役に立たなくなります。。さらに、ほとんどのアプリケーションは通常、FQDN情報（偽のIPアドレス情報ではない）をブックマークなどに記録するため、このようなケースはまれです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1-Native-SOCKS-mechanism-considerations">
5.1 Native SOCKS mechanism considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 ネイティブソックスメカニズムの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The characteristics of the SOCKS-based IPv6/IPv4 gateway mechanism are inherited from those of the native SOCKS mechanism. Therefore, consideration issues of the native SOCKS mechanism are discussed in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソックスベースのIPv6/IPv4ゲートウェイメカニズムの特性は、ネイティブソックスメカニズムの特性から継承されます。したがって、ネイティブソックスメカニズムの考慮事項については、このセクションで説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SOCKSv5 protocol is composed of three commands (CONNECT, BIND and UDP ASSOCIATE). All of three commands can be applied in the SOCKS-based IPv6/IPv4 gateway mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SOCKSV5プロトコルは、3つのコマンド（Connect、Bind、UDPアソシエイト）で構成されています。3つのコマンドはすべて、ソックスベースのIPv6/IPv4ゲートウェイメカニズムに適用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is described with assuming the usage of the CONNECT command mainly, because the CONNECT command is the main and most frequently used command in the SOCKS mechanism. Since the CONNECT command does not have clear week points, we can use it freely without considerations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、Connectコマンドがソックスメカニズムでメインおよび最も頻繁に使用されるコマンドであるため、Connectコマンドの使用を主に仮定することで説明されています。Connectコマンドには明確な1週間のポイントがないため、考慮せずに自由に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The other (BIND and UDP ASSOCIATE) commands have the following weak points. So, we have to consider these points when we use the BIND or UDP ASSOCIATE commands in the mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もう1つの（BindおよびUDPアソシエイト）コマンドには、次の弱点があります。したがって、メカニズムでバインドまたはUDPアソシエイトコマンドを使用するときは、これらのポイントを考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The BIND command is basically designed to support reverse-channel rendezvous of the FTP type applications. So, general usages of the BIND command may cause problems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bindコマンドは、基本的にFTPタイプアプリケーションのリバースチャネルランデブーをサポートするように設計されています。したがって、Bindコマンドの一般的な使用は問題を引き起こす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The UDP ASSOCIATE command is basically designed for simple UDP applications (e.g., archie). It is not general enough to support a large class of applications that use both TCP and UDP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPアソシエイトコマンドは、基本的に単純なUDPアプリケーション（Archieなど）用に設計されています。TCPとUDPの両方を使用する大規模なクラスのアプリケーションをサポートするほど一般的ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Security-Considerations">
6. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the SOCKS-based IPv6/IPv4 gateway mechanism is based on SOCKSv5 protocol, the security feature of the mechanism matches that of SOCKSv5. It is described in the Security Considerations section of the SOCKS Protocol Version 5 [SOCKSv5].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SocksベースのIPv6/IPv4ゲートウェイメカニズムはSocksv5プロトコルに基づいているため、メカニズムのセキュリティ機能はSocksv5のセキュリティと一致します。Socks Protocolバージョン5 [Socksv5]のセキュリティに関する考慮事項セクションで説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mechanism is based on relaying two &#34;terminated&#34; connections at the &#34;application layer&#34;. The end-to-end security is maintained at each of the relayed connections (i.e., between Client C and Gateway G, and between Gateway G and Destination D). The mechanism does not provide total end-to-end security relay between the original source (Client C) and the final destination (Destination D).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メカニズムは、「アプリケーションレイヤー」で2つの「終了」接続を中継することに基づいています。エンドツーエンドのセキュリティは、各リレー接続（つまり、クライアントCとゲートウェイGの間、ゲートウェイGと宛先Dの間）で維持されます。このメカニズムは、元のソース（クライアントC）と最終目的地（宛先D）の間に総エンドツーエンドのセキュリティリレーを提供しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--Implementations">
Appendix A. Implementations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Currently, there are two independent implementations of the SOCKS-based IPv6/IPv4 gateway mechanism. Both of them are open to the public.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在、SocksベースのIPv6/IPv4ゲートウェイメカニズムの2つの独立した実装があります。どちらも一般公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One is NEC&#39;s implementation. Its source codes are available at the following URL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つはNECの実装です。そのソースコードは、次のURLで利用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
http://www.socks.nec.com/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
http://www.socks.nec.com/
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The other is Fujitsu Lab.&#39;s implementation, which is called &#34;SOCKS64&#34;. Its source codes are available at the following URL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もう1つは、「socks64」と呼ばれる富士通ラボの実装です。そのソースコードは、次のURLで利用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
ftp://ftp.kame.net/pub/kame/misc/socks64-...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
ftp://ftp.kame.net/pub/kame/misc/socks64-...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
参考文献
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SOCKSv5] Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D. and L. Jones, &#34;SOCKS Protocol V5&#34;, RFC 1928, April 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Socksv5] Leech、M.、Ganis、M.、Lee、Y.、Kuris、R.、Koblas、D。and L. Jones、「Socks Protocol V5」、RFC 1928、1996年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TRANSMECH] Gilligan, R. and E. Nordmark, &#34;Transition Mechanisms for IPv6 Hosts and Routers&#34;, RFC 2893, August 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TransMech] Gilligan、R。およびE. Nordmark、「IPv6ホストとルーターの遷移メカニズム」、RFC 2893、2000年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IPv6] Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6 (IPv6) Specification&#34;, RFC 2460, December 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IPv6] Deering、S。and R. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、RFC 2460、1998年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[INET99] H. Kitamura, &#34;Entering the IPv6 communication world by the SOCKS-based IPv6/IPv4 Translator&#34;, in Proceedings of INET99, July 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[INET99] H. Kitamura、「SocksベースのIPv6/IPv4翻訳者によるIPv6通信の世界に入る」、1999年7月のINET99の議事録。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者の連絡先
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hiroshi Kitamura NEC Corporation Development Laboratories (Igarashi Building 4F) 11-5, Shibaura 2-Chome, Minato-Ku, Tokyo 108-8557, JAPAN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キタムラNEC Corporation Development Laboratories（Igarashi Building 4F）11-5、Shibaura 2-Chome、Minato-Ku、Tokyo 108-8557、日本
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +81 (3) 5476-1071
   Fax:   +81 (3) 5476-1005
   EMail: kitamura@da.jp.nec.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2001). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）The Internet Society（2001）。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFCエディター機能の資金は現在、インターネット協会によって提供されています。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
