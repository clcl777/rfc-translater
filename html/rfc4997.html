<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 4997 - Formal Notation for RObust Header Compression (ROHC-FN) 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">4997</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc4997">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 4997 - Formal Notation for RObust Header Compression (ROHC-FN) 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc4997">
            https://datatracker.ietf.org/doc/html/rfc4997
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 4997 - 堅牢なヘッダー圧縮の正式な表記（ROHC-FN）</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <h6 class="card-title">要約（自動生成）</h6>
            <p class="card-text">RFC 4997は、ROHC-FN（RObust Header Compressionの形式的表記）に関する規格であり、ROHCプロトコルのヘッダ圧縮を形式的に表現するためのものです。その目的は、ROHCの実装と相互運用性を向上させることです。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                         R. Finking
Request for Comments: 4997                   Siemens/Roke Manor Research
Category: Standards Track                                   G. Pelletier
                                                                Ericsson
                                                               July 2007
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Formal Notation for RObust Header Compression (ROHC-FN)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
堅牢なヘッダー圧縮の正式な表記（ROHC-FN）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The IETF Trust (2007).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（c）The IETF Trust（2007）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines Robust Header Compression - Formal Notation (ROHC-FN), a formal notation to specify field encodings for compressed formats when defining new profiles within the ROHC framework. ROHC-FN offers a library of encoding methods that are often used in ROHC profiles and can thereby help to simplify future profile development work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、ROHCフレームワーク内で新しいプロファイルを定義するときに圧縮形式のフィールドエンコーディングを指定する正式な表記である、堅牢なヘッダー圧縮 - 正式な表記（ROHC -FN）を定義します。ROHC-FNは、ROHCプロファイルでよく使用されるエンコードメソッドのライブラリを提供し、それにより将来のプロファイル開発作業を簡素化するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
   2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  4
   3.  Overview of ROHC-FN  . . . . . . . . . . . . . . . . . . . . .  5
     3.1.  Scope of the Formal Notation . . . . . . . . . . . . . . .  6
     3.2.  Fundamentals of the Formal Notation  . . . . . . . . . . .  7
       3.2.1.  Fields and Encodings . . . . . . . . . . . . . . . . .  7
       3.2.2.  Formats and Encoding Methods . . . . . . . . . . . . .  9
     3.3.  Example Using IPv4 . . . . . . . . . . . . . . . . . . . . 11
   4.  Normative Definition of ROHC-FN  . . . . . . . . . . . . . . . 13
     4.1.  Structure of a Specification . . . . . . . . . . . . . . . 13
     4.2.  Identifiers  . . . . . . . . . . . . . . . . . . . . . . . 14
     4.3.  Constant Definitions . . . . . . . . . . . . . . . . . . . 15
     4.4.  Fields . . . . . . . . . . . . . . . . . . . . . . . . . . 16
       4.4.1.  Attribute References . . . . . . . . . . . . . . . . . 17
       4.4.2.  Representation of Field Values . . . . . . . . . . . . 17
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
     4.5.  Grouping of Fields . . . . . . . . . . . . . . . . . . . . 17
     4.6.  &#34;THIS&#34; . . . . . . . . . . . . . . . . . . . . . . . . . . 18
     4.7.  Expressions  . . . . . . . . . . . . . . . . . . . . . . . 19
       4.7.1.  Integer Literals . . . . . . . . . . . . . . . . . . . 20
       4.7.2.  Integer Operators  . . . . . . . . . . . . . . . . . . 20
       4.7.3.  Boolean Literals . . . . . . . . . . . . . . . . . . . 20
       4.7.4.  Boolean Operators  . . . . . . . . . . . . . . . . . . 20
       4.7.5.  Comparison Operators . . . . . . . . . . . . . . . . . 21
     4.8.  Comments . . . . . . . . . . . . . . . . . . . . . . . . . 21
     4.9.  &#34;ENFORCE&#34; Statements . . . . . . . . . . . . . . . . . . . 22
     4.10. Formal Specification of Field Lengths  . . . . . . . . . . 23
     4.11. Library of Encoding Methods  . . . . . . . . . . . . . . . 24
       4.11.1. uncompressed_value . . . . . . . . . . . . . . . . . . 24
       4.11.2. compressed_value . . . . . . . . . . . . . . . . . . . 25
       4.11.3. irregular  . . . . . . . . . . . . . . . . . . . . . . 26
       4.11.4. static . . . . . . . . . . . . . . . . . . . . . . . . 27
       4.11.5. lsb  . . . . . . . . . . . . . . . . . . . . . . . . . 27
       4.11.6. crc  . . . . . . . . . . . . . . . . . . . . . . . . . 29
     4.12. Definition of Encoding Methods . . . . . . . . . . . . . . 29
       4.12.1. Structure  . . . . . . . . . . . . . . . . . . . . . . 30
       4.12.2. Arguments  . . . . . . . . . . . . . . . . . . . . . . 37
       4.12.3. Multiple Formats . . . . . . . . . . . . . . . . . . . 38
     4.13. Profile-Specific Encoding Methods  . . . . . . . . . . . . 40
   5.  Security Considerations  . . . . . . . . . . . . . . . . . . . 41
   6.  Contributors . . . . . . . . . . . . . . . . . . . . . . . . . 41
   7.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 41
   8.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 42
     8.1.  Normative References . . . . . . . . . . . . . . . . . . . 42
     8.2.  Informative References . . . . . . . . . . . . . . . . . . 42
   Appendix A.  Formal Syntax of ROHC-FN  . . . . . . . . . . . . . . 43
   Appendix B.  Bit-level Worked Example  . . . . . . . . . . . . . . 45
     B.1.  Example Packet Format  . . . . . . . . . . . . . . . . . . 45
     B.2.  Initial Encoding . . . . . . . . . . . . . . . . . . . . . 46
     B.3.  Basic Compression  . . . . . . . . . . . . . . . . . . . . 47
     B.4.  Inter-Packet Compression . . . . . . . . . . . . . . . . . 48
     B.5.  Specifying Initial Values  . . . . . . . . . . . . . . . . 50
     B.6.  Multiple Packet Formats  . . . . . . . . . . . . . . . . . 51
     B.7.  Variable Length Discriminators . . . . . . . . . . . . . . 53
     B.8.  Default Encoding . . . . . . . . . . . . . . . . . . . . . 55
     B.9.  Control Fields . . . . . . . . . . . . . . . . . . . . . . 56
     B.10. Use of &#34;ENFORCE&#34; Statements as Conditionals  . . . . . . . 59
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Robust Header Compression - Formal Notation (ROHC-FN) is a formal notation designed to help with the definition of ROHC [RFC4995] header compression profiles. Previous header compression profiles have been so far specified using a combination of English text together with ASCII Box notation. Unfortunately, this was sometimes unclear and ambiguous, revealing the limitations of defining complex structures and encodings for compressed formats this way. The primary objective of the Formal Notation is to provide a more rigorous means to define header formats -- compressed and uncompressed -- as well as the relationships between them. No other formal notation exists that meets these requirements, so ROHC-FN aims to meet them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
堅牢なヘッダー圧縮 - フォーマル表記（ROHC -FN）は、ROHC [RFC4995]ヘッダー圧縮プロファイルの定義を支援するために設計された正式な表記です。以前のヘッダー圧縮プロファイルは、ASCIIボックス表記と一緒に英語のテキストの組み合わせを使用して、これまでに指定されています。残念ながら、これは時には不明確で曖昧であり、この方法で圧縮形式の複雑な構造とエンコーディングを定義する制限を明らかにします。正式な表記法の主な目的は、ヘッダー形式（圧縮および圧縮されていない）とそれらの間の関係を定義するためのより厳格な手段を提供することです。これらの要件を満たす他の正式な表記は存在しないため、ROHC-FNはそれらを満たすことを目指しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, ROHC-FN offers a library of encoding methods that are often used in ROHC profiles, so that the specification of new profiles using the formal notation can be achieved without having to redefine this library from scratch. Informally, an encoding method defines a two-way mapping between uncompressed data and compressed data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、ROHC-FNは、ROHCプロファイルでよく使用されるエンコードメソッドのライブラリを提供しているため、このライブラリをゼロから再定義することなく、正式な表記法を使用した新しいプロファイルの仕様を実現できます。非公式には、エンコーディング方法は、非圧縮データと圧縮データの間の双方向マッピングを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Terminology">
2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Compressed format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 圧縮形式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A compressed format consists of a list of fields that provides bindings between encodings and the fields it compresses. One or more compressed formats can be combined to represent an entire compressed header format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
圧縮形式は、エンコーディングと圧縮するフィールドの間にバインディングを提供するフィールドのリストで構成されています。1つ以上の圧縮形式を組み合わせて、圧縮ヘッダー形式全体を表すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Context
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o コンテクスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Context is information about the current (de)compression state of the flow. Specifically, a context for a specific field can be either uninitialised, or it can include a set of one or more values for the field&#39;s attributes defined by the compression algorithm, where a value may come from the field&#39;s attributes corresponding to a previous packet. See also a more generalized definition in Section 2.2 of [RFC4995].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
コンテキストとは、流れの電流（de）圧縮状態に関する情報です。具体的には、特定のフィールドのコンテキストは、単位化されていない場合、または以前のパケットに対応するフィールドの属性から値が生じる可能性のある圧縮アルゴリズムによって定義されるフィールドの属性の1つ以上の値のセットを含めることができます。[RFC4995]のセクション2.2のより一般化された定義も参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Control field
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 制御フィールド
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Control fields are transmitted from a ROHC compressor to a ROHC decompressor, but are not part of the uncompressed header itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
コントロールフィールドは、ROHCコンプレッサーからROHC分解器に送信されますが、非圧縮ヘッダー自体の一部ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Encoding method, encodings
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o エンコーディング方法、エンコーディング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Encoding methods are two-way relations that can be applied to compress and decompress fields of a protocol header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
エンコーディング方法は、プロトコルヘッダーのフィールドを圧縮および減圧するために適用できる双方向の関係です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Field
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 分野
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol header is divided into a set of contiguous bit patterns known as fields. Each field is defined by a collection of attributes that indicate its value and length in bits for both the compressed and uncompressed headers. The way the header is divided into fields is specific to the definition of a profile, and it is not necessary for the field divisions to be identical to the ones given by the specification(s) for the protocol header being compressed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
プロトコルヘッダーは、フィールドと呼ばれる一連の連続したビットパターンに分割されます。各フィールドは、圧縮ヘッダーと非圧縮ヘッダーの両方のビットの値と長さを示す属性のコレクションによって定義されます。ヘッダーがフィールドに分割される方法は、プロファイルの定義に固有のものであり、圧縮されるプロトコルヘッダーの仕様によって与えられたものとフィールド分割を同一にする必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Library of encoding methods
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o エンコーディング方法のライブラリ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The library of encoding methods contains a number of commonly used encoding methods for compressing header fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
エンコーディングメソッドのライブラリには、ヘッダーフィールドを圧縮するための一般的に使用されるエンコード方法が多数含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Profile
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o プロフィール
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A ROHC [RFC4995] profile is a description of how to compress a certain protocol stack. Each profile consists of a set of formats (for example, uncompressed and compressed formats) along with a set of rules that control compressor and decompressor behaviour.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ROHC [RFC4995]プロファイルは、特定のプロトコルスタックを圧縮する方法の説明です。各プロファイルは、コンプレッサーと減圧装置の動作を制御する一連のルールとともに、一連のフォーマット（非圧縮形式と圧縮形式）で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ROHC-FN specification
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ROHC-FN仕様
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The specification of the set of formats of a ROHC profile using ROHC-FN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ROHC-FNを使用したROHCプロファイルのフォーマットのセットの仕様。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Uncompressed format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 非圧縮形式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An uncompressed format consists of a list of fields that provides the order of the fields to be compressed for a contiguous set of bits whose bit layout corresponds to the protocol header being compressed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
非圧縮形式は、ビットレイアウトが圧縮されているプロトコルヘッダーに対応する隣接するビットのセットのために圧縮されるフィールドの順序を提供するフィールドのリストで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Overview-of-ROHC-FN">
3. Overview of ROHC-FN
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. ROHC-FNの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section gives an overview of ROHC-FN. It also explains how ROHC-FN can be used to specify the compression of header fields as part of a ROHC profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、ROHC-FNの概要を示します。また、ROHC-FNを使用して、ROHCプロファイルの一部としてヘッダーフィールドの圧縮を指定する方法についても説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Scope-of-the-Formal-Notation">
3.1. Scope of the Formal Notation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 正式な表記の範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section explains how the formal notation relates to the ROHC framework and to specifications of ROHC profiles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、正式な表記法がROHCフレームワークとROHCプロファイルの仕様にどのように関連しているかについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ROHC framework [RFC4995] provides the general principles for performing robust header compression. It defines the concept of a profile, which makes ROHC a general platform for different compression schemes. It sets link layer requirements, and in particular negotiation requirements, for all ROHC profiles. It defines a set of common functions such as Context Identifiers (CIDs), padding, and segmentation. It also defines common formats (IR, IR-DYN, Feedback, Add-CID, etc.), and finally it defines a generic, profile independent, feedback mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHCフレームワーク[RFC4995]は、堅牢なヘッダー圧縮を実行するための一般原則を提供します。ROHCをさまざまな圧縮スキームの一般的なプラットフォームにするプロファイルの概念を定義します。すべてのROHCプロファイルに対して、リンクレイヤー要件、特に交渉要件を設定します。コンテキスト識別子（CID）、パディング、セグメンテーションなどの共通機能のセットを定義します。また、一般的な形式（IR、IR-DYN、フィードバック、追加CIDなど）を定義し、最後に、一般的なプロファイルに依存しないフィードバックメカニズムを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A ROHC profile is a description of how to compress a certain protocol stack. For example, ROHC profiles are available for RTP/UDP/IP and many other protocol stacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHCプロファイルは、特定のプロトコルスタックを圧縮する方法の説明です。たとえば、ROHCプロファイルは、RTP/UDP/IPおよびその他の多くのプロトコルスタックで使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At a high level, each ROHC profile consists of a set of formats (defining the bits to be transmitted) along with a set of rules that control compressor and decompressor behaviour. The purpose of the formats is to define how to compress and decompress headers. The formats define one or more compressed versions of each uncompressed header, and simultaneously define the inverse: how to relate a compressed header back to the original uncompressed header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高レベルでは、各ROHCプロファイルは、コンプレッサーと減圧剤の動作を制御する一連のルールとともに、一連のフォーマット（ビットを定義する）で構成されています。フォーマットの目的は、ヘッダーを圧縮および解凍する方法を定義することです。この形式は、各非圧縮ヘッダーの1つまたは複数の圧縮バージョンを定義し、同時に逆を定義します。圧縮ヘッダーを元の非圧縮ヘッダーに関連付ける方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set of formats will typically define compression of headers relative to a context of field values from previous headers in a flow, improving the overall compression by taking into account redundancies between headers of successive packets. Therefore, in addition to defining the formats, a profile has to:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フォーマットのセットは通常、フロー内の以前のヘッダーからのフィールド値のコンテキストに対するヘッダーの圧縮を定義し、連続したパケットのヘッダー間の冗長性を考慮して全体的な圧縮を改善します。したがって、形式の定義に加えて、プロファイルは以下を行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o specify how to manage the context for both the compressor and the decompressor,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o コンプレッサーと減圧器の両方のコンテキストを管理する方法を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o define when and what to send in feedback messages, if any, from decompressor to compressor,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フィードバックメッセージをいつ、どのように送信するかを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o outline compression principles to make the profile robust against bit errors and dropped packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o プロファイルをビットエラーとドロップしたパケットに対して堅牢にするための圧縮原則の概要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All this is needed to ensure that the compressor and decompressor contexts are kept consistent with each other, while still facilitating the best possible compression performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、可能な限り最高の圧縮性能を促進しながら、コンプレッサーと減圧器のコンテキストが互いに一貫性を保つことを保証するために必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ROHC-FN is designed to help in the specification of compressed formats that, when put together based on the profile definition, make up the formats used in a ROHC profile. It offers a library of encoding methods for compressing fields, and a mechanism for combining these encoding methods to create compressed formats tailored to a specific protocol stack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-FNは、プロファイル定義に基づいてまとめた場合、ROHCプロファイルで使用される形式を構成する圧縮形式の仕様を支援するように設計されています。フィールドを圧縮するためのエンコーディング方法のライブラリと、これらのエンコード方法を組み合わせて特定のプロトコルスタックに合わせた圧縮形式を作成するメカニズムを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The scope of ROHC-FN is limited to specifying the relationship between the compressed and uncompressed formats. To form a complete profile specification, the control logic for the profile behaviour needs to be defined by other means.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-FNの範囲は、圧縮形式と非圧縮形式の関係を指定することに限定されています。完全なプロファイル仕様を形成するには、プロファイルの動作の制御ロジックを他の手段で定義する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--Fundamentals-of-the-Formal-Notation">
3.2. Fundamentals of the Formal Notation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 正式な表記の基礎
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two fundamental elements to the formal notation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正式な表記には2つの基本的な要素があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Fields and their encodings, which define the mapping between a header&#39;s uncompressed and compressed forms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. フィールドとそのエンコーディングは、ヘッダーの非圧縮形式と圧縮フォームの間のマッピングを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Encoding methods, which define the way headers are broken down into fields. Encoding methods define lists of uncompressed fields and the lists of compressed fields they map onto.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. ヘッダーがフィールドに分解される方法を定義するエンコードメソッド。エンコーディングメソッドは、圧縮されていないフィールドのリストと、マップされる圧縮フィールドのリストを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These two fundamental elements are at the core of the notation and are outlined below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの2つの基本的な要素は、表記の中核にあり、以下に概説します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-1--Fields-and-Encodings">
3.2.1. Fields and Encodings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. フィールドとエンコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Headers are made up of fields. For example, version number, header length, and sequence number are all fields used in real protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーはフィールドで構成されています。たとえば、バージョン番号、ヘッダー長、およびシーケンス番号は、すべて実際のプロトコルで使用されるすべてのフィールドです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fields have attributes. Attributes describe various things about the field. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドには属性があります。属性は、フィールドに関するさまざまなことを説明しています。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
field.ULENGTH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">

        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above indicates the uncompressed length of the field. A field is said to have a value attribute, i.e., a compressed value or an uncompressed value, if the corresponding length attribute is greater than zero. See Section 4.4 for more details on field attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記は、フィールドの非圧縮長さを示しています。対応する長さ属性がゼロより大きい場合、フィールドには値属性、つまり圧縮値または非圧縮値があると言われています。フィールド属性の詳細については、セクション4.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The relationship between the compressed and uncompressed attributes of a field are specified with encoding methods, using the following notation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドの圧縮属性と非圧縮属性の関係は、次の表記法を使用して、エンコード方法で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     field   =:=   encoding_method;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the field definition above, the symbol &#34;=:=&#34; means &#34;is encoded by&#34;. This field definition does not represent an assignment operation from the right hand side to the left side. Instead, it is a two-way mapping between the compressed and uncompressed attributes of the field. It both represents the compression and the decompression operation in a single field definition, through a process of two-way matching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のフィールド定義では、シンボル &#34;=：=&#34;平均 &#34;によってエンコードされます。このフィールド定義は、右側から左側への割り当て操作を表しません。代わりに、フィールドの圧縮属性と非圧縮属性の間の双方向マッピングです。どちらも、双方向マッチングのプロセスを通じて、単一のフィールド定義での圧縮と減圧操作を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two-way matching is a binary operation that attempts to make the operands (i.e., the compressed and uncompressed attributes) match. This is similar to the unification process in logic. The operands represent one unspecified data object and one specified object. Values can be matched from either operand.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
双方向マッチングは、オペランド（つまり、圧縮および非圧縮属性）を一致させようとするバイナリ操作です。これは、論理の統一プロセスに似ています。オペランドは、1つの不特定のデータオブジェクトと1つの指定されたオブジェクトを表します。値は、いずれかのオペランドから一致させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During compression, the uncompressed attributes of the field are already defined. The given encoding matches the compressed attributes against them. During decompression, the compressed attributes of the field are already defined, so the uncompressed attributes are matched to the compressed attributes using the given encoding method. Thus, both compression and decompression are defined by a single field definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮中、フィールドの非圧縮属性はすでに定義されています。指定されたエンコードは、それらに対する圧縮属性と一致します。減圧中、フィールドの圧縮属性はすでに定義されているため、非圧縮属性は、指定されたエンコード法を使用して圧縮属性と一致します。したがって、圧縮と減圧の両方が、単一のフィールド定義によって定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, an encoding method (including any parameters specified) creates a reversible binding between the attributes of a field. At the compressor, a format can be used if a set of bindings that is successful for all the attributes in all its fields can be found. At the decompressor, the operation is reversed using the same bindings and the attributes in each field are filled according to the specified bindings; decoding fails if the binding for an attribute fails.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、エンコーディング方法（指定されたパラメーターを含む）は、フィールドの属性間に可逆的な結合を作成します。コンプレッサーでは、すべてのフィールドのすべての属性に対して成功するバインディングのセットが見つかる場合、形式を使用できます。減圧器では、同じバインディングを使用して操作が逆転し、各フィールドの属性は指定されたバインディングに従って埋められます。属性のバインディングが失敗した場合、デコードに失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, the &#34;static&#34; encoding method creates a binding between the attribute corresponding to the uncompressed value of the field and the corresponding value of the field in the context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、「静的」エンコードメソッドは、フィールドの非圧縮値とコンテキスト内のフィールドの対応する値に対応する属性との間に結合を作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For the compressor, the &#34;static&#34; binding is successful when both the context value and the uncompressed value are the same. If the two values differ then the binding fails.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o コンプレッサーの場合、コンテキスト値と非圧縮値の両方が同じ場合、「静的」バインディングが成功します。2つの値が異なる場合、バインディングは失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For the decompressor, the &#34;static&#34; binding succeeds only if a valid context entry containing the value of the uncompressed field exists. Otherwise, the binding will fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 減圧器の場合、「静的」バインディングは、非圧縮フィールドの値を含む有効なコンテキストエントリが存在する場合にのみ成功します。それ以外の場合、バインディングは失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both the compressed and uncompressed forms of each field are represented as a string of bits; the most significant bit first, of the length specified by the length attribute. The bit string is the binary representation of the value attribute of the field, modulo &#34;2^length&#34;, where &#34;length&#34; is the length attribute of the field. However, this is only the representation of the bits exchanged between the compressor and the decompressor, designed to allow maximum compression efficiency. The FN itself uses the full range of integers. See Section 4.4.2 for further details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各フィールドの圧縮形式と非圧縮フォームの両方が、一連のビットとして表されます。長さの属性で指定された長さの最も重要なビット。ビット文字列は、フィールドの値属性のバイナリ表現であり、モジュロ「2^長さ」で、「長さ」はフィールドの長さ属性です。ただし、これは、圧縮効率を可能にするように設計されたコンプレッサーと減圧器の間で交換されるBITの表現のみです。FN自体は、整数の全範囲を使用します。詳細については、セクション4.4.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-2--Formats-and-Encoding-Methods">
3.2.2. Formats and Encoding Methods
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2. フォーマットとエンコーディングメソッド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ROHC-FN provides a library of commonly used encoding methods. Encoding methods can be defined using plain English, or using a formal definition consisting of, for example, a collection of expressions (Section 4.7) and &#34;ENFORCE&#34; statements (Section 4.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-FNは、一般的に使用されるエンコーディング方法のライブラリを提供します。エンコーディング方法は、プレーン英語を使用して、または表現のコレクション（セクション4.7）および「施行」ステートメント（セクション4.9）で構成される正式な定義を使用して定義できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-FN also provides mechanisms for combining fields and their encoding methods into higher level encoding methods following a well-defined structure. This is similar to the definition of functions and procedures in an ordinary programming language. It allows complexity to be handled by being broken down into manageable parts. New encoding methods are defined at the top level of a profile. These can then be used in the definition of other higher level encoding methods, and so on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-FNは、明確に定義された構造に従って、フィールドとそのエンコード方法をより高いレベルのエンコード方法に組み合わせるためのメカニズムも提供します。これは、通常のプログラミング言語での機能と手順の定義に似ています。これにより、管理可能な部分に分解されることにより、複雑さを処理できます。新しいエンコード方法は、プロファイルの上位レベルで定義されています。これらは、他の高レベルのエンコード方法の定義などで使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   new_encoding_method         // This block is an encoding method
   {
     UNCOMPRESSED {            // This block is an uncompressed format
       field_1   [ 16 ];
       field_2   [ 32 ];
       field_3   [ 48 ];
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CONTROL { // This block defines control fields ctrl_field_1; ctrl_field_2; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
制御{//このブロックは、制御フィールドCtrl_field_1を定義します。ctrl_field_2;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     DEFAULT {                 // This block defines default encodings
                               // for specified fields
       ctrl_field_2 =:= encoding_method_2;
       field_1      =:= encoding_method_1;
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     COMPRESSED format_0 {     // This block is a compressed format
       field_1;
       field_2      =:= encoding_method_2;
       field_3      =:= encoding_method_3;
       ctrl_field_1 =:= encoding_method_4;
       ctrl_field_2;
     }
        COMPRESSED format_1 {     // This block is a compressed format
       field_1;
       field_2      =:= encoding_method_3;
       field_3      =:= encoding_method_4;
       ctrl_field_2 =:= encoding_method_5;
       ctrl_field_3 =:= encoding_method_6; // This is a control field
                                           // with no uncompressed value
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the example above, the encoding method being defined is called &#34;new_encoding_method&#34;. The section headed &#34;UNCOMPRESSED&#34; indicates the order of fields in the uncompressed header, i.e., the uncompressed header format. The number of bits in each of the fields is indicated in square brackets. After this is another section, &#34;CONTROL&#34;, which defines two control fields. Following this is the &#34;DEFAULT&#34; section which defines default encoding methods for two of the fields (see below). Finally, two alternative compressed formats follow, each defined in sections headed &#34;COMPRESSED&#34;. The fields that occur in the compressed formats are either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の例では、定義されているエンコードメソッドは「new_encoding_method」と呼ばれます。「圧縮されていない」というセクションは、非圧縮ヘッダーのフィールドの順序、つまり非圧縮ヘッダー形式を示します。各フィールドのビット数は、正方形の括弧で示されています。この後、別のセクション「コントロール」があり、2つの制御フィールドを定義します。これに続くのは、2つのフィールドのデフォルトエンコードメソッドを定義する「デフォルト」セクションです（以下を参照）。最後に、2つの代替圧縮形式が続き、それぞれが「圧縮」という見出しにあるセクションで定義されています。圧縮形式で発生するフィールドは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o fields that occur in the uncompressed format; or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 非圧縮形式で発生するフィールド。また
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o control fields that have an uncompressed value and that occur in the CONTROL section; or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 非圧縮値を持つ制御フィールドと、コントロールセクションで発生するフィールド。また
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o control fields that do not have an uncompressed value and thus are defined as part of the compressed format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 圧縮されていない値がないため、圧縮形式の一部として定義される制御フィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Central to each of these formats is a &#34;field list&#34;, which defines the fields contained in the format and also the order that those fields appear in that format. For the &#34;DEFAULT&#34; and &#34;CONTROL&#34; sections, the field order is not significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの各形式の中心は「フィールドリスト」です。これは、形式に含まれるフィールドと、それらのフィールドがその形式に表示される順序を定義します。「デフォルト」および「制御」セクションの場合、フィールド順序は重要ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to specifying field order, the field list may also specify bindings for any or all of the fields it contains. Fields that have no bindings defined for them are bound using the default bindings specified in the &#34;DEFAULT&#34; section (see Section 4.12.1.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドの順序の指定に加えて、フィールドリストには、含まれるフィールドのいずれかまたはすべてのバインディングを指定することもできます。それらのために定義されたバインディングのないフィールドは、「デフォルト」セクションで指定されたデフォルトのバインディングを使用してバインドされています（セクション4.12.1.5を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fields from the compressed format have the same name as they do in the uncompressed format. If there are any fields that are present exclusively in the compressed format, but that do have an uncompressed value, they must be declared in the &#34;CONTROL&#34; section of the definition of the encoding method (see Section 4.12.1.3 for more details on defining control fields).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮形式のフィールドは、非圧縮形式で行うのと同じ名前です。圧縮形式のみで存在するが、非圧縮値を持っているフィールドがある場合、エンコーディング方法の定義の「制御」セクションで宣言する必要があります（セクション4.12.1.3を参照してください。制御フィールド）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fields that have no uncompressed value do not appear in an &#34;UNCOMPRESSED&#34; field list and do not have to appear in the &#34;CONTROL&#34; field list either. Instead, they are only declared in the compressed field lists where they are used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非圧縮値のないフィールドは、「圧縮されていない」フィールドリストには表示されず、「コントロール」フィールドリストにも表示される必要はありません。代わりに、それらが使用されている場所に圧縮フィールドリストでのみ宣言されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the example above, all the fields that appear in the compressed format are also found in the uncompressed format, or the control field list, except for ctrl_field_3; this is possible because ctrl_field_3 has no &#34;uncompressed&#34; value at all. Fields such as a checksum on the compressed information fall into this category.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の例では、圧縮形式に表示されるすべてのフィールドは、CTRL_FIELD_3を除き、非圧縮形式または制御フィールドリストにもあります。これは、CTRL_FIELD_3に「圧縮されていない」値がまったくないため、可能です。圧縮情報のチェックサムなどのフィールドは、このカテゴリに分類されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--Example-Using-IPv4">
3.3. Example Using IPv4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. IPv4を使用した例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section gives an overview of how the notation is used by means of an example. The example will develop the formal notation for an encoding method capable of compressing a single, well-known header: the IPv4 header [RFC791].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、例によって表記がどのように使用されるかの概要を説明します。この例は、単一のよく知られているヘッダーであるIPv4ヘッダー[RFC791]を圧縮できるエンコード方法の正式な表記を開発します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first step is to specify the overall structure of the IPv4 header. To do this, we use an encoding method that we will call &#34;ipv4_header&#34;. More details on definitions of encoding methods can be found in Section 4.12. This is notated as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のステップは、IPv4ヘッダーの全体的な構造を指定することです。これを行うには、「ipv4_header」と呼ばれるエンコード方法を使用します。エンコーディング方法の定義の詳細については、セクション4.12をご覧ください。これは次のように記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
ipv4_header {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
ipv4_header {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fragment of notation above declares the encoding method &#34;ipv4_header&#34;, the definition follows the opening brace (see Section 4.12).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の表記の断片は、エンコードメソッド「IPv4_header」を宣言し、定義はオープニングブレースに従います（セクション4.12を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Definitions within the pair of braces are local to &#34;ipv4_header&#34;. This scoping mechanism helps to clarify which fields belong to which formats; it is also useful when compressing complex protocol stacks with several headers, often with the same field names occurring in multiple headers (see Section 4.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブレースのペア内の定義は、「IPv4_header」からローカルです。このスコーピングメカニズムは、どのフィールドがどの形式に属しているかを明確にするのに役立ちます。また、複数のヘッダーで複雑なプロトコルスタックを圧縮する場合にも役立ちます。多くの場合、同じフィールド名が複数のヘッダーで発生します（セクション4.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next step is to specify the fields contained in the uncompressed IPv4 header to represent the uncompressed format for which the encoding method will define one or more compressed formats. This is accomplished using ROHC-FN as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のステップは、非圧縮IPv4ヘッダーに含まれるフィールドを指定して、エンコードメソッドが1つ以上の圧縮形式を定義する非圧縮形式を表すことです。これは、次のようにROHC-FNを使用して達成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       UNCOMPRESSED {
         version         [  4 ];
         header_length   [  4 ];
         dscp            [  6 ];
         ecn             [  2 ];
         length          [ 16 ];
         id              [ 16 ];
         reserved        [  1 ];
         dont_frag       [  1 ];
         more_fragments  [  1 ];
         offset          [ 13 ];
         ttl             [  8 ];
         protocol        [  8 ];
         checksum        [ 16 ];
         src_addr        [ 32 ];
         dest_addr       [ 32 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The width of each field is indicated in square brackets. This part of the notation is used in the example for illustration to help the reader&#39;s understanding. However, indicating the field lengths in this way is optional since the width of each field can also normally be derived from the encoding that is used to compress/decompress it for a specific format. This part of the notation is formally defined in Section 4.10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各フィールドの幅は、正方形の括弧で示されています。表記のこの部分は、読者の理解を助けるためにイラストの例で使用されています。ただし、各フィールドの幅は通常、特定の形式でそれを圧縮/解凍するために使用されるエンコードから導出できるため、この方法でフィールドの長さを示すことはオプションです。表記のこの部分は、セクション4.10で正式に定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next step is to specify the compressed format. This includes the encodings for each field that map between the compressed and uncompressed forms of the field. In the example, these encoding methods are mainly taken from the ROHC-FN library (see Section 4.11). Since the intention here is to illustrate the use of the notation, rather than to describe the optimum method of compressing IPv4 headers, this example uses only three encoding methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のステップは、圧縮形式を指定することです。これには、フィールドの圧縮フォームと非圧縮フォームの間にマッピングされる各フィールドのエンコーディングが含まれます。この例では、これらのエンコード方法は主にROHC-FNライブラリから取得されます（セクション4.11を参照）。ここでの意図は、IPv4ヘッダーを圧縮する最適な方法を記述するのではなく、表記の使用を説明することであるため、この例では3つのエンコーディング方法のみを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;uncompressed_value&#34; encoding method (defined in Section 4.11.1) can compress any field whose uncompressed length and value are fixed, or can be calculated using an expression. No compressed bits need to be sent because the uncompressed field can be reconstructed using its known size and value. The &#34;uncompressed_value&#34; encoding method is used to compress five fields in the IPv4 header, as described below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「非圧縮_Value」エンコードメソッド（セクション4.11.1で定義）は、圧縮されていない長さと値が固定されているか、式を使用して計算できるフィールドを圧縮できます。非圧縮フィールドをその既知のサイズと値を使用して再構築できるため、圧縮ビットを送信する必要はありません。以下に説明するように、「圧縮されていない」エンコードメソッドを使用して、IPv4ヘッダーの5つのフィールドを圧縮します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED {
         header_length  =:= uncompressed_value(4, 5);
         version        =:= uncompressed_value(4, 4);
         reserved       =:= uncompressed_value(1, 0);
         offset         =:= uncompressed_value(13, 0);
         more_fragments =:= uncompressed_value(1, 0);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first parameter indicates the length of the uncompressed field in bits, and the second parameter gives its integer value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のパラメーターは、ビットの非圧縮フィールドの長さを示し、2番目のパラメーターは整数値を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the order of the fields in the compressed format is independent of the order of the fields in the uncompressed format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮形式のフィールドの順序は、非圧縮形式のフィールドの順序とは無関係であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;irregular&#34; encoding method (defined in Section 4.11.3) can be used to encode any field for which both uncompressed attributes (ULENGTH and UVALUE) are defined, and whose ULENGTH attribute is either fixed or can be calculated using an expression. It is a fail-safe encoding method that can be used for such fields in the case where no other encoding method applies. All of the bits in the uncompressed form of the field are present in the compressed form as well; hence this encoding does not achieve any compression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「不規則な」エンコーディング方法（セクション4.11.3で定義）を使用して、非圧縮属性（ulengthとuvalue）の両方が定義され、ulength属性が固定されているか、式を使用して計算できるフィールドをエンコードできます。これは、他のエンコードメソッドが適用されない場合にそのようなフィールドに使用できるフェイルセーフエンコード方法です。フィールドの非圧縮形式のすべてのビットは、圧縮形式にも存在します。したがって、このエンコードは圧縮を実現しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         src_addr       =:= irregular(32);
         dest_addr      =:= irregular(32);
         length         =:= irregular(16);
         id             =:= irregular(16);
         ttl            =:= irregular(8);
         protocol       =:= irregular(8);
         dscp           =:= irregular(6);
         ecn            =:= irregular(2);
         dont_frag      =:= irregular(1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, the third encoding method is specific only to the uncompressed format defined above for the IPv4 header, &#34;inferred_ip_v4_header_checksum&#34;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、3番目のエンコードメソッドは、IPv4ヘッダーの上記で定義された非圧縮形式にのみ固有です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         checksum       =:= inferred_ip_v4_header_checksum [ 0 ];
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;inferred_ip_v4_header_checksum&#34; encoding method is different from the other two encoding methods in that it is not defined in the ROHC-FN library of encoding methods. Its definition could be given either by using the formal notation as part of the profile definition itself (see Section 4.12) or by using plain English text (see Section 4.13).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「amed_ip_ip_v4_header_checum」エンコードメソッドは、エンコードメソッドのROHC-FNライブラリで定義されていないという点で、他の2つのエンコード方法とは異なります。その定義は、プロファイルの定義自体の一部として正式な表記を使用するか（セクション4.12を参照）、または平易な英語のテキスト（セクション4.13を参照）を使用することにより、与えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In our example, the &#34;inferred_ip_v4_header_checksum&#34; is a specific encoding method that calculates the IP checksum from the rest of the header values. Like the &#34;uncompressed_value&#34; encoding method, no compressed bits need to be sent, since the field value can be reconstructed at the decompressor. This is notated explicitly by specifying, in square brackets, a length of 0 for the checksum field in the compressed format. Again, this notation is optional since the encoding method itself would be defined as sending zero compressed bits, however it is useful to the reader to include such notation (see Section 4.10 for details on this part of the notation).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例では、「bedred_ip_4_header_checksum」は、ヘッダー値の残りの部分からIPチェックサムを計算する特定のエンコードメソッドです。「非圧縮_Value」エンコードメソッドのように、フィールド値を減圧器で再構築できるため、圧縮ビットを送信する必要はありません。これは、圧縮形式のチェックサムフィールドの長さ0を正方形の括弧で指定することにより明示的に記載されています。繰り返しますが、エンコードメソッド自体は圧縮ビットゼロを送信すると定義されるため、この表記法はオプションですが、読者にとってそのような表記を含めることは役立ちます（表記のこの部分の詳細についてはセクション4.10を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally the definition of the format is terminated with a closing brace. At this point, the above example has defined a compressed format that can be used to represent the entire compressed IPv4 header, and provides enough information to allow an implementation to construct the compressed format from an uncompressed format (compression) and vice versa (decompression).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、形式の定義は閉鎖ブレースで終了します。この時点で、上記の例では、圧縮IPv4ヘッダー全体を表すために使用できる圧縮形式を定義し、非圧縮形式（圧縮）と逆（減圧）から圧縮形式を構築するための実装を可能にするのに十分な情報を提供します。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Normative-Definition-of-ROHC-FN">
4. Normative Definition of ROHC-FN
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. ROHC-FNの規範的定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section gives the normative definition of ROHC-FN. ROHC-FN is a declarative language that is referentially transparent, with no side effects. This means that whenever an expression is evaluated, there are no other effects from obtaining the value of the expression; the same expression is thus guaranteed to have the same value wherever it appears in the notation, and it can always be interchanged with its value in any of the formats it appears in (subject to the scope rules of identifiers of Section 4.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、ROHC-FNの規範的な定義を示します。ROHC-FNは、参照的に透明性のある宣言的な言語であり、副作用はありません。これは、式が評価されるときはいつでも、式の値を取得することから他の効果がないことを意味します。したがって、同じ式は、表記に表示されている場所に同じ値を持つことが保証されており、表示される形式のいずれかでその値と常に交換できます（セクション4.2の識別子の範囲ルールの対象となります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The formal notation describes the structure of the formats and the relationships between their uncompressed and compressed forms, rather than describing how compression and decompression is performed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正式な表記は、圧縮と減圧がどのように実行されるかを説明するのではなく、形式の構造と非圧縮フォーム間の関係について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In various places within this section, text inside angle brackets has been used as a descriptive placeholder. The use of angle brackets in this way is solely for the benefit of the reader of this document. Neither the angle brackets, nor their contents form a part of the notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクション内のさまざまな場所で、テキストの内部角度ブラケットが記述的なプレースホルダーとして使用されています。この方法での角度ブラケットの使用は、このドキュメントの読者の利益のためだけです。角度ブラケットもその内容も、表記の一部を形成しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Structure-of-a-Specification">
4.1. Structure of a Specification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 仕様の構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The specification of the compressed formats of a ROHC profile using ROHC-FN is called a ROHC-FN specification. ROHC-FN specifications are case sensitive and are written in the 7-bit ASCII character set (as defined in [RFC2822]) and consist of a sequence of zero or more constant definitions (Section 4.3), an optional global control field list (Section 4.12.1.3) and one or more encoding method definitions (Section 4.12).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-FNを使用したROHCプロファイルの圧縮形式の仕様は、ROHC-FN仕様と呼ばれます。ROHC-FN仕様はケースに敏感であり、7ビットASCII文字セット（[RFC2822]で定義されている）で記述されており、オプションのグローバル制御フィールドリストであるゼロ以上の定義（セクション4.3）のシーケンス（セクション4.3）で構成されています。4.12.1.3）および1つ以上のエンコードメソッド定義（セクション4.12）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding methods can be defined using the formal notation or can be predefined encoding methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコーディングメソッドは、正式な表記法を使用して定義するか、事前定義されたエンコードメソッドであることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding methods are defined using the formal notation by giving one or more uncompressed formats to represent the uncompressed header and one or more compressed formats. These formats are related to each other by &#34;fields&#34;, each of which describes a certain part of an uncompressed and/or a compressed header. In addition to the formats, each encoding method may contain control fields, initial values, and default field encodings sections. The attributes of a field are bound by using an encoding method for it and/or by using &#34;ENFORCE&#34; statements (Section 4.9) within the formats. Each of these are terminated by a semi-colon.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコーディングメソッドは、非圧縮ヘッダーと1つ以上の圧縮形式を表すために1つ以上の非圧縮形式を提供することにより、正式な表記を使用して定義されます。これらの形式は、「フィールド」によって互いに関連しており、それぞれが非圧縮ヘッダーおよび/または圧縮ヘッダーの特定の部分を説明しています。形式に加えて、各エンコーディング方法には、制御フィールド、初期値、およびデフォルトのフィールドエンコーディングセクションが含まれる場合があります。フィールドの属性は、そのためのエンコード方法を使用して、および/または形式内の「施行」ステートメント（セクション4.9）を使用することにより拘束されます。これらのそれぞれは、セミコロンによって終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Predefined encoding methods are not defined in the formal notation. Instead they are defined by giving a short textual reference explaining where the encoding method is defined. It is not necessary to define the library of encoding methods contained in this document in this way, their definition is implicit to the usage of the formal notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
事前定義されたエンコードメソッドは、正式な表記では定義されていません。代わりに、エンコードメソッドが定義されている場所を説明する短いテキストリファレンスを提供することによって定義されます。この方法でこのドキュメントに含まれるエンコードメソッドのライブラリを定義する必要はありません。それらの定義は、正式な表記法の使用に暗黙的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Identifiers">
4.2. Identifiers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 識別子
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In ROHC-FN, identifiers are used for any of the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-FNでは、識別子が以下のいずれかに使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o encoding methods
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o エンコード方法
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o formats
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o フォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o fields
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 田畑野外野良
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o parameters
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o パラメーター
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o constants
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 定数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All identifiers may be of any length and may contain any combination of alphanumeric characters and underscores, within the restrictions defined in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての識別子は任意の長さである場合があり、このセクションで定義されている制限内に、英数字とアンダースコアの任意の組み合わせが含まれる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All identifiers must start with an alphabetic character.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての識別子は、アルファベット文字から開始する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is illegal to have two or more identifiers that differ from each other only in capitalisation, in the same scope.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じ範囲で、大文字のみが互いに異なる2つ以上の識別子を持つことは違法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All letters in identifiers for constants must be upper case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定数の識別子のすべての文字は大文字でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is illegal to use any of the following as identifiers (including alternative capitalisations):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のいずれかを識別子（代替資本を含む）として使用することは違法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;false&#34;, &#34;true&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;真偽&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;ENFORCE&#34;, &#34;THIS&#34;, &#34;VARIABLE&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「施行」、「これ」、「変数」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;ULENGTH&#34;, &#34;UVALUE&#34; o &#34;CLENGTH&#34;, &#34;CVALUE&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「ulength」、 &#34;uvalue&#34; o &#34;clength&#34;、 &#34;cvalue&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;UNCOMPRESSED&#34;, &#34;COMPRESSED&#34;, &#34;CONTROL&#34;, &#34;INITIAL&#34;, or &#34;DEFAULT&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「圧縮されていない」、「圧縮」、「コントロール」、「初期」、または「デフォルト」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Format names cannot be referred to in the notation, although they are considered to be identifiers. (See Section 4.12.3.1 for more details on format names.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
形式名は表記で参照することはできませんが、識別子と見なされます。（フォーマット名の詳細については、セクション4.12.3.1を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All identifiers used in ROHC-FN have a &#34;scope&#34;. The scope of an identifier defines the parts of the specification where that identifier applies and from which it can be referred to. If an identifier has a &#34;global&#34; scope, then it applies throughout the specification that contains it and can be referred to from anywhere within it. If an identifier has a &#34;local&#34; scope, then it only applies to the encoding method in which it is defined, it cannot be referenced from outside the local scope of that encoding method. If an identifier has a local scope, that identifier can therefore be used in multiple different local scopes to refer to different items.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-FNで使用されるすべての識別子には「スコープ」があります。識別子の範囲は、その識別子が適用され、そこから参照できる仕様の部分を定義します。識別子に「グローバル」範囲がある場合、それを含む仕様全体に適用され、その中のどこからも参照できます。識別子に「ローカル」スコープがある場合、それが定義されているエンコード方法にのみ適用される場合、そのエンコード方法のローカル範囲外から参照することはできません。識別子にローカルスコープがある場合、その識別子を複数の異なるローカルスコープで使用して、異なるアイテムを参照できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All instances of an identifier within its scope refer to the same item. It is not possible to have different items referred to by a single identifier within any given scope. For this reason, if there is an identifier that has global scope it cannot be used separately in a local scope, since a globally-scoped identifier is already applicable in all local scopes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのスコープ内の識別子のすべてのインスタンスは、同じアイテムを参照しています。特定の範囲内で単一の識別子によって参照されるさまざまなアイテムを持つことはできません。このため、グローバルな範囲でグローバルな範囲で使用することはできない識別子がある場合、グローバルにスコープした識別子はすでにすべてのローカルスコープに適用可能であるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The identifiers for each encoding method and each constant all have a global scope. Each format and field also has an identifier. The scope of format and field identifiers is local, with the exception of global control fields, which have a global scope. Therefore it is illegal for a format or field to have the same identifier as another format or field within the same scope, or as an encoding method or a constant (since they have global scope).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各エンコード方法と各定数の識別子にはすべて、グローバルな範囲があります。各形式とフィールドには識別子もあります。フォーマットおよびフィールド識別子の範囲はローカルであり、グローバルな範囲を持つグローバル制御フィールドを除きます。したがって、形式またはフィールドが同じ範囲内の別の形式またはフィールドと同じ識別子を持つこと、またはエンコード方法または定数（グローバルスコープがあるため）として違法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that although format names (see Section 4.12.3.1) are considered to be identifiers, they are not referred to in the notation, but are primarily for the benefit of the reader.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フォーマット名（セクション4.12.3.1を参照）は識別子と見なされますが、表記では参照されませんが、主に読者の利益のためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--Constant-Definitions">
4.3. Constant Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 一定の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Constant values can be defined using the &#34;=&#34; operator. Identifiers for constants must be all upper case. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「=」演算子を使用して一定の値を定義できます。定数の識別子はすべて大文字でなければなりません。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SOME_CONSTANT = 3;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
some_constant = 3;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Constants are defined by an expression (see Section 4.7) on the right-hand side of the &#34;=&#34; operator. The expression must yield a constant value. That is, the expression must be one whose terms are all either constants or literals and must not vary depending on the header being compressed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定数は、「=」演算子の右側にある式（セクション4.7を参照）によって定義されます。式は一定の値を生成する必要があります。つまり、式は、すべての定数またはリテラルのいずれかであり、ヘッダーが圧縮されていることによって異なるものであってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Constants have a global scope. Constants must be defined at the top level, outside any encoding method definition. Constants are entirely equivalent to the value they refer to, and are completely interchangeable with that value. Unlike field attributes, which may change from packet to packet, constants have the same value for all packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定数にはグローバルな範囲があります。定数は、エンコードメソッド定義の外側の上部レベルで定義する必要があります。定数は、参照する値と完全に同等であり、その値と完全に交換可能です。パケットからパケットに変更される可能性のあるフィールド属性とは異なり、定数はすべてのパケットに対して同じ値を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4--Fields">
4.4. Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 田畑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fields are the basic building blocks of a ROHC-FN specification. Fields are the units into which headers are divided. Each field may have two forms: a compressed form and an uncompressed form. Both forms are represented as bits exchanged between the compressor and the decompressor in the same way, as an unsigned string of bits; the most significant bit first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドは、ROHC-FN仕様の基本的な構成要素です。フィールドは、ヘッダーが分割されるユニットです。各フィールドには、圧縮フォームと非圧縮フォームの2つのフォームがあります。どちらの形式も、コンプレッサーと減圧器の間で署名されていないビットの文字列として交換されるビットとして表されます。最初に最も重要なビット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The properties of the compressed form of a field are defined by an encoding method and/or &#34;ENFORCE&#34; statements. This entirely characterises the relationship between the uncompressed and compressed forms of that field. This is achieved by specifying the relationships between the field&#39;s attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドの圧縮形式のプロパティは、エンコード方法および/または「施行」ステートメントによって定義されます。これは、そのフィールドの非圧縮形式と圧縮形式の関係を完全に特徴付けます。これは、フィールドの属性間の関係を指定することによって達成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation defines four field attributes, two for the uncompressed form and a corresponding two for the compressed form. The attributes available for each field are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">

        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uncompressed attributes of a field:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドの非圧縮属性：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;UVALUE&#34; and &#34;ULENGTH&#34;,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「uvalue」と「ulength」、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compressed attributes of a field:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドの圧縮属性：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;CVALUE&#34; and &#34;CLENGTH&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「値」と「長さ」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two value attributes contain the respective numerical values of the field, i.e., &#34;UVALUE&#34; gives the numerical value of the uncompressed form of the field, and the attribute &#34;CVALUE&#34; gives the numerical value of the compressed form of the field. The numerical values are derived by interpreting the bit-string representations of the field as bit strings; the most significant bit first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つの値属性には、フィールドのそれぞれの数値値が含まれています。つまり、「uValue」はフィールドの非圧縮形式の数値を与え、属性「cValue」はフィールドの圧縮形式の数値を与えます。数値は、フィールドのビットストリング表現をビット文字列として解釈することにより導き出されます。最初に最も重要なビット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two length attributes indicate the length in bits of the associated bit string; &#34;ULENGTH&#34; for the uncompressed form, and &#34;CLENGTH&#34; for the compressed form.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つの長さの属性は、関連するビット文字列のビットの長さを示します。非圧縮フォームの「ulength」、圧縮形式の「clength」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Attributes are undefined unless they are bound to a value, in which case they become defined. If two conflicting bindings are given for a field attribute then the bindings fail along with the (combination of) formats in which those bindings were defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性は、値に拘束されない限り未定義です。その場合、定義されます。フィールド属性に対して2つの競合するバインディングが与えられた場合、それらのバインディングが定義された（組み合わせの）形式とともにバインディングが失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Uncompressed attributes do not always reflect an aspect of the uncompressed header. Some fields do not originate from the uncompressed header, but are control fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非圧縮属性は、非圧縮ヘッダーの側面を常に反映するとは限りません。一部のフィールドは、圧縮されていないヘッダーに由来するものではなく、制御フィールドです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4-1--Attribute-References">
4.4.1. Attribute References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1. 属性参照
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Attributes of a particular field are formally referred to by using the field&#39;s name followed by a &#34;.&#34; and the attribute&#39;s identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のフィールドの属性は、フィールドの名前を使用して「。」を使用して正式に言及されます。属性の識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
rtp_seq_number.UVALUE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
rtp_seq_number.u値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above gives the uncompressed value of the rtp_seq_number field. The primary reason for referencing attributes is for use in expressions, which are explained in Section 4.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記は、RTP_SEQ_NUMBERフィールドの非圧縮値を示します。属性を参照する主な理由は、セクション4.7で説明されている式で使用するためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4-2--Representation-of-Field-Values">
4.4.2. Representation of Field Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2. フィールド値の表現
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fields are represented as bit strings. The bit string is calculated using the value attribute (&#34;val&#34;) and the length attribute (&#34;len&#34;). The bit string is the binary representation of &#34;val % (2 ^ len)&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドはビット文字列として表されます。ビット文字列は、値属性（ &#34;val&#34;）と長さ属性（ &#34;len&#34;）を使用して計算されます。ビット文字列は、「val％（2 ^ len）」のバイナリ表現です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, if a field&#39;s &#34;CLENGTH&#34; attribute was 8, and its &#34;CVALUE&#34; attribute was -1, the compressed representation of the field would be &#34;-1 % (2 ^ 8)&#34;, which equals &#34;-1 % 256&#34;, which equals 255, 11111111 in binary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、フィールドの「clength」属性が8であり、その「cvalue」属性が-1である場合、フィールドの圧縮表現は「-1％（2 ^ 8）」になり、「-1％256」に等しくなります。、バイナリで255、11111111に相当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-FN supports the full range of integers for use in expressions (see Section 4.7), but the representation of the formats (i.e., the bits exchanged between the compressor and the decompressor) is in the above form.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-FNは、式で使用するための整数の全範囲（セクション4.7を参照）をサポートしますが、形式の表現（つまり、コンプレッサーと分解器の間で交換されるビット）は上記の形式です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-5--Grouping-of-Fields">
4.5. Grouping of Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. フィールドのグループ化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the order of fields in a &#34;COMPRESSED&#34; field list (Section 4.12.1.2) do not have to be the same as the order of fields in an &#34;UNCOMPRESSED&#34; field list (Section 4.12.1.1), it is possible to group together any number of fields that are contiguous in a &#34;COMPRESSED&#34; format, to allow them all to be encoded using a single encoding method. The group of fields is specified immediately to the left of &#34;=:=&#34; in place of a single field name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「圧縮された」フィールドリスト（セクション4.12.1.2）のフィールドの順序は、「圧縮されていない」フィールドリスト（セクション4.12.1.1）のフィールドの順序と同じである必要はないため、一緒にグループ化することは可能です。「圧縮」形式で隣接するフィールドの任意の数は、単一のエンコード方法を使用してすべてエンコードできるようにします。フィールドのグループは、単一のフィールド名の代わりに「=：=」の左側にすぐに指定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The group is notated by giving a colon-separated list of the fields to be grouped together. For example there may be two non-contiguous fields in an uncompressed header that are two halves of what is effectively a single sequence number:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このグループは、グループ化されるフィールドのコロン分離リストを提供することによって記載されています。たとえば、非圧縮ヘッダーには、効果的に単一のシーケンス番号の2つの半分である2つの非連続フィールドがある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     grouping_example
     {
       UNCOMPRESSED {
         minor_seq_num;  // 12 bits
         other_field;    //  8 bits
         major_seq_num;  //  4 bits
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED {
         other_field     =:= irregular(8);
         major_seq_num
         : minor_seq_num =:= lsb(3, 0);
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The group of fields is presented to the encoding method as a contiguous group of bits, assembled by the concatenation of the fields in the order they are given in the group. The most significant bit of the combined field is the most significant bit of the first field in the list, and the least significant bit of the combined field is the least significant bit of the last field in the list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドのグループは、グループで与えられた順序でフィールドの連結によって組み立てられた、隣接するビットのグループとしてエンコード法に提示されます。組み合わせたフィールドの最も重要なビットは、リスト内の最初のフィールドの中で最も重要なビットであり、複合フィールドの最も重要なビットは、リスト内の最後のフィールドの最も重要なビットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, the length attributes of the combined field are equal to the sum of the corresponding length attributes for all the fields in the group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、結合したフィールドの長さ属性は、グループ内のすべてのフィールドの対応する長さ属性の合計に等しくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6--THIS">
4.6. &#34;THIS&#34;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. &#34;これ&#34;
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Within the definition of an encoding method, it is possible to refer to the field (i.e., the group of contiguous bits) the method is encoding, using the keyword &#34;THIS&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコーディング方法の定義内では、キーワード「this」を使用して、フィールド（つまり、隣接するビットのグループ）を参照することができます（つまり、隣接するビットのグループ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is useful for gaining access to the attributes of the field being encoded. For example it is often useful to know the total uncompressed length of the uncompressed format that is being encoded:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、エンコードされているフィールドの属性へのアクセスを獲得するのに役立ちます。たとえば、エンコードされている非圧縮形式の非圧縮されていない長さを知ることがしばしば役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
THIS.ULENGTH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
this.ulength
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-7--Expressions">
4.7. Expressions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. 式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-FN includes the usual infix style of expressions, with parentheses &#34;(&#34; and &#34;)&#34; used for grouping. Expressions can be made up of any of the components described in the following subsections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC-FNには、グループ化に使用される括弧 &#34;（&#34; and &#34;）&#34;を備えた通常のInfixスタイルの表現スタイルが含まれています。式は、以下のサブセクションで説明されているコンポーネントのいずれかで構成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The semantics of expressions are generally similar to the expressions in the ANSI-C programming language [C90]. The definitive list of expressions in ROHC-FN follows in the next subsections; the list below provides some examples of the difference between expressions in ANSI-C and expressions in ROHC-FN:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表現のセマンティクスは、一般に、ANSI-Cプログラミング言語の式に似ています[C90]。ROHC-FNの式の決定的なリストは、次のサブセクションで続きます。以下のリストは、ANSI-Cの式とROHC-FNの式の式の違いの例をいくつか示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There is no limit on the range of integers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 整数の範囲に制限はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;x ^ y&#34; evaluates to x raised to the power of y. This has a precedence higher than *, / and %, but lower than unary - and is right to left associative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「x ^ y」は、yの力に上げられたxを評価します。これには、 *、 /、および％よりも高い優先順位がありますが、unaryよりも低く、左から左の連想です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There is no comma operator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o コンマオペレーターはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There are no &#34;modify&#34; operators (no assignment operators and no increment or decrement).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「変更」オペレーターはありません（割り当てオペレーターも増分も減少もありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There are no bitwise operators.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ビットワイズオペレーターはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Expressions may refer to any of the attributes of a field (as described in Section 4.4), to any defined constant (see Section 4.3) and also to encoding method parameters, if any are in scope (see Section 4.12).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
式は、フィールドの属性（セクション4.4で説明されているように）、定義された定数（セクション4.3を参照）、および範囲内の場合（セクション4.12を参照）、メソッドパラメーターをエンコードすることも指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If any of the attributes, constants, or parameters used in the expression are undefined, the value of the expression is undefined. Undefined expressions cause the environment (for example, the compressed format) in which they are used to fail if a defined value is required. Defined values are required for all compressed attributes of fields that appear in the compressed format. Defined values are not required for all uncompressed attributes of fields which appear in the uncompressed format. It is up to the profile creator to define what happens to the unbound field attributes in this case. It should be noted that in such a case, transparency of the compression process will be lost; i.e., it will not be possible for the decompressor to reproduce the original header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
式で使用される属性、定数、またはパラメーターのいずれかが定義されていない場合、式の値は未定義です。未定義の式は、定義された値が必要な場合に故障するために使用される環境（たとえば、圧縮形式）を引き起こします。定義された値は、圧縮形式に表示されるフィールドのすべての圧縮属性に対して必要です。非圧縮形式に表示されるフィールドのすべての非圧縮属性には、定義された値は必要ありません。この場合、Unboundフィールド属性に何が起こるかを定義するのは、プロファイル作成者次第です。そのような場合、圧縮プロセスの透明性が失われることに注意する必要があります。つまり、減圧装置が元のヘッダーを再現することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Expressions cannot be used as encoding methods directly because they do not completely characterise a field. Expressions only specify a single value whereas a field is made up of several values: its attributes. For example, the following is illegal:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
式は、フィールドを完全に特徴付けるものではないため、メソッドを直接エンコードすることはできません。式は単一の値のみを指定しますが、フィールドはいくつかの値、その属性で構成されています。たとえば、以下は違法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      tcp_list_length =:= (data_offset + 20) / 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is only enough information here to define a single attribute of &#34;tcp_list_length&#34;. Although this makes no sense formally, this could intuitively be read as defining the &#34;UVALUE&#34; attribute. However, that would still leave the length of the uncompressed field undefined at the decompressor. Such usage is therefore prohibited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここには、「tcp_list_length」の単一の属性を定義するのに十分な情報のみがあります。これは正式には意味がありませんが、これは「UValue」属性を定義するものとして直感的に読むことができます。しかし、それはまだ減圧器で未定義の未定義のフィールドの長さを残します。したがって、そのような使用法は禁止されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-7-1--Integer-Literals">
4.7.1. Integer Literals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.1. 整数リテラル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Integers can be expressed as decimal values, binary values (prefixed by &#34;0b&#34;), or hexadecimal values (prefixed by &#34;0x&#34;). Negative integers are prefixed by a &#34;-&#34; sign. For example &#34;10&#34;, &#34;0b1010&#34;, and &#34;-0x0a&#34; are all valid integer literals, having the values 10, 10, and -10 respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
整数は、小数値、バイナリ値（「0B」でプレフィックス）、または16進値（「0x」で接頭辞）として表現できます。負の整数には、「 - 」記号が付いています。たとえば、「10」、「0B1010」、および「-0x0A」はすべて有効な整数リテラルであり、それぞれ値10、10、および-10を備えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-7-2--Integer-Operators">
4.7.2. Integer Operators
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.2. 整数演算子
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following &#34;integer&#34; operators are available, which take integer arguments and return an integer result:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の「整数」演算子が利用可能です。これは、整数引数を取り、整数の結果を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ^, for exponentiation. &#34;x ^ y&#34; returns the value of &#34;x&#34; to the power of &#34;y&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ^、指数の場合。「x ^ y」は「x」の値を「y」の力に返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o *, / for multiplication and division. &#34;x * y&#34; returns the product of &#34;x&#34; and &#34;y&#34;. &#34;x / y&#34; returns the quotient, rounded down to the next integer (the next one towards negative infinity).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o *、 /乗算および分割用。「x * y」は「x」と「y」の積を返します。「x / y」は商を返し、次の整数（次の整数は負の無限に向かって）に丸められます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o +, - for addition and subtraction. &#34;x + y&#34; returns the sum of &#34;x&#34; and &#34;y&#34;. &#34;x - y&#34; returns the difference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 、 - 加算と減算用。「x y」は「x」と「y」の合計を返します。「x -y」は違いを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o % for modulo. &#34;x % y&#34; returns &#34;x&#34; modulo &#34;y&#34;; x - y * (x / y).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Moduloの％。「x％y」は「x &#34;modulo&#34; y &#34;を返します。x -y *（x / y）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-7-3--Boolean-Literals">
4.7.3. Boolean Literals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.3. ブールリテラル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The boolean literals are &#34;false&#34;, and &#34;true&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブールのリテラルは「false」と「true」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-7-4--Boolean-Operators">
4.7.4. Boolean Operators
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.4. ブールオペレーター
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following &#34;boolean&#34; operators are available, which take boolean arguments and return a boolean result:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の「ブール」演算子が利用可能です。これは、ブールの引数を取り、ブールの結果を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &amp;&amp;, for logical &#34;and&#34;. Returns true if both arguments are true. Returns false otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &amp;&amp;、論理 &#34;および&#34; and &#34;。両方の引数がtrueである場合、trueを返します。それ以外の場合はfalseを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ||, for logical &#34;or&#34;. Returns true if at least one argument is true. Returns false otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ||、論理的な &#34;または&#34;の場合。少なくとも1つの引数が真である場合、trueを返します。それ以外の場合はfalseを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o !, for logical &#34;not&#34;. Returns true if its argument is false. Returns false otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ！、論理的な「NOT」の場合。その議論がfalseの場合、trueを返します。それ以外の場合はfalseを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-7-5--Comparison-Operators">
4.7.5. Comparison Operators
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.5. 比較演算子
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following &#34;comparison&#34; operators are available, which take integer arguments and return a boolean result:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の「比較」演算子が利用可能です。これは、整数引数を取り、ブール結果を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ==, !=, for equality and its negative. &#34;x == y&#34; returns true if x is equal to y. Returns false otherwise. &#34;x != y&#34; returns true if x is not equal to y. Returns false otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ==、！=、平等とそのネガティブの場合。「x == y」がxがyに等しい場合、trueを返します。それ以外の場合はfalseを返します。「x！= y」がxがyに等しくない場合、trueを返します。それ以外の場合はfalseを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &lt;, &gt;, for less than and greater than. &#34;x &lt; y&#34; returns true if x is less than y. Returns false otherwise. &#34;x &gt; y&#34; returns true if x is greater than y. Returns false otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &lt;、&gt;、より少ない、より大きい。xがy未満の場合、「x &lt;y」がtrueを返します。それ以外の場合はfalseを返します。xがyより大きい場合、「x&gt; y」がtrueを返します。それ以外の場合はfalseを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &gt;=, &lt;=, for greater than or equal and less than or equal, the inverse functions of &lt;, &gt;. &#34;x &gt;= y&#34; returns false if x is less than y. Returns true otherwise. &#34;x &lt;= y&#34; returns false if x is greater than y. Returns true otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &gt; =、&lt;=、&lt;、&gt;の逆関数。「x&gt; = y」はxがy未満の場合にfalseを返します。それ以外の場合はtrueを返します。「x &lt;= y」がxがyより大きい場合、falseを返します。それ以外の場合はtrueを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-8--Comments">
4.8. Comments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. コメント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Free English text can be inserted into a ROHC-FN specification to explain why something has been done a particular way, to clarify the intended meaning of the notation, or to elaborate on some point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
無料の英語のテキストをROHC-FN仕様に挿入して、何かが特定の方法で行われた理由を説明したり、表記の意図した意味を明確にしたり、ある時点で詳しく説明したりできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The FN uses an end of line comment style, which makes use of the &#34;//&#34; comment marker. Any text between the &#34;//&#34; marker and the end of the line has no formal meaning. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FNは、「//」コメントマーカーを使用する行のコメントスタイルを使用します。「//」マーカーと行の終わりの間のテキストには、正式な意味はありません。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     //-----------------------------------------------------------------
     //    IR-REPLICATE header formats
     //-----------------------------------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     // The following fields are included in all of the IR-REPLICATE
     // header formats:
     //
     UNCOMPRESSED {
       discriminator;    //  8 bits
       tcp_seq_number;   // 32 bits
       tcp_flags_ecn;    //  2 bits
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Comments do not affect the formal meaning of what is notated, but can be used to improve readability. Their use is optional.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コメントは、記載されているものの正式な意味に影響を与えませんが、読みやすさを改善するために使用できます。それらの使用はオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Comments may help to provide clarifications to the reader, and serve different purposes to implementers. Comments should thus not be considered of lesser importance when inserting them into a ROHC-FN specification; they should be consistent with the normative part of the specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コメントは、読者に説明を提供し、実装者にさまざまな目的を果たすのに役立つ場合があります。したがって、コメントは、ROHC-FN仕様に挿入する際に、それほど重要ではないと見なされるべきではありません。それらは、仕様の規範的部分と一致する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9--ENFORCE-Statements">
4.9. &#34;ENFORCE&#34; Statements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9. 「強制」声明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;ENFORCE&#34; statement provides a way to add predicates to a format, all of which must be fulfilled for the format to succeed. An &#34;ENFORCE&#34; statement shares some similarities with an encoding method. Specifically, whereas an encoding method binds several field attributes at once, an &#34;ENFORCE&#34; statement typically binds just one of them. In fact, all the bindings that encoding methods create can be expressed in terms of a collection of &#34;ENFORCE&#34; statements. Here is an example &#34;ENFORCE&#34; statement which binds the &#34;UVALUE&#34; attribute of a field to 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「Enforce」ステートメントは、形式に述語を追加する方法を提供します。これらはすべて、フォーマットを成功させるために満たされなければなりません。「Enforce」ステートメントは、エンコード方法といくつかの類似点を共有しています。具体的には、エンコーディング方法はいくつかのフィールド属性に一度に結合しますが、「施行」ステートメントは通常、その1つだけにバインドされます。実際、メソッドをエンコードするすべてのバインディングは、「施行」ステートメントのコレクションで表現できます。以下は、フィールドの「uvalue」属性を5に拘束する「執行」ステートメントの例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     ENFORCE(field.UVALUE == 5);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An &#34;ENFORCE&#34; statement must only be used inside a field list (see Section 4.12). It attempts to force the expression given to be true for the format that it belongs to.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「施行」ステートメントは、フィールドリスト内でのみ使用する必要があります（セクション4.12を参照）。それは、与えられた表現を、それが属する形式に真であるように強制しようとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An abbreviated form of an &#34;ENFORCE&#34; statement is available for binding length attributes using &#34;[&#34; and &#34;]&#34;, see Section 4.10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「[&#34;&#34; &#34;&#34; &#34;&#34; &#34;および&#34; &#34;を使用して、「施行」ステートメントの略語形式は、セクション4.10を参照して、拘束力のある長さの属性に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Like an encoding method, an &#34;ENFORCE&#34; statement can only be successfully used in a format if the binding it describes is achievable. A format containing the example &#34;ENFORCE&#34; statement above would not be usable if the field had also been bound within that same format with &#34;uncompressed_value&#34; encoding, which gave it a &#34;UVALUE&#34; other than 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコーディング方法と同様に、「強制」ステートメントは、説明するバインディングが達成可能である場合にのみ、形式で正常に使用できます。上記の「執行」ステートメントの例を含む形式は、フィールドが「非圧縮_Value」エンコードで同じ形式内にバインドされていた場合、5以外の「UValue」を与えた場合、使用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An &#34;ENFORCE&#34; statement takes a boolean expression as a parameter. It can be used to assert that the expression is true, in order to choose a particular format from a list of possible formats specified in an encoding method (see Section 4.12), or just to bind an expression as in the example above. The general form of an &#34;ENFORCE&#34; statement is therefore:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「Enforce」ステートメントは、パラメーターとしてブール式を使用します。エンコード方法で指定された可能な形式のリストから特定の形式を選択するために、または上記の例のように式を結合するためだけに、式が真であると主張することができます。したがって、「執行」ステートメントの一般的な形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     ENFORCE(&lt;boolean expression&gt;);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are three possible conditions that the expression may be in:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
式がある可能性のある3つの条件があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The boolean expression evaluates to false, in which case the local scope of the format that contains the &#34;ENFORCE&#34; statement cannot be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. ブール式はfalseに評価されます。その場合、「施行」ステートメントを含む形式のローカル範囲は使用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The boolean expression evaluates to true, in which case the binding is created and successful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. ブールの発現は真のものに評価されます。その場合、結合が作成され成功します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The value of the boolean expression is undefined. In this case, the binding is also created and successful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. ブール式の値は未定義です。この場合、バインディングも作成され、成功します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In all three cases, any undefined term becomes bound by the expression. Generally speaking, an &#34;ENFORCE&#34; statement is either being used as an assignment (condition 3 above) or being used to test if a particular format is usable, as is the case with conditions 1 and 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3つのケースすべてで、未定義の用語は式に拘束されます。一般的に言えば、「施行」ステートメントは、条件1と2の場合のように、割り当てとして使用されるか（上記の条件3）、特定の形式が使用可能かどうかをテストするために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-10--Formal-Specification-of-Field-Lengths">
4.10. Formal Specification of Field Lengths
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.10. フィールド長の正式な仕様
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In many of the examples each field has been followed by a comment indicating the length of the field. Indicating the length of a field like this is optional, but can be very helpful for the reader. However, whilst useful to the reader, comments have no formal meaning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの例では、各フィールドの後に、フィールドの長さを示すコメントが続きます。このようなフィールドの長さを示すことはオプションですが、読者にとって非常に役立ちます。ただし、読者にとっては便利ですが、コメントには正式な意味はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One of the most common uses for &#34;ENFORCE&#34; statements (see Section 4.9) is to explicitly define the length of a field within a header. Using &#34;ENFORCE&#34; statements for this purpose has formal meaning but is not so easy to read. Therefore, an abbreviated form is provided for this use of &#34;ENFORCE&#34;, which is both easy to read and has formal meaning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「強制」ステートメント（セクション4.9を参照）の最も一般的な用途の1つは、ヘッダー内のフィールドの長さを明示的に定義することです。この目的のために「施行」ステートメントを使用するには、正式な意味がありますが、読みやすいものではありません。したがって、この「施行」の使用のために、略語されたフォームが提供されます。これは、読みやすく、正式な意味を持つ両方です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An expression defining the length of a field can be specified in square brackets after the appearance of that field in a format. If the field can take several alternative lengths, then the expressions defining those lengths can be enumerated as a comma separated list within the square brackets. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドの長さを定義する式は、そのフィールドが形式で表示された後、四角い括弧で指定できます。フィールドがいくつかの代替長さを取ることができる場合、それらの長さを定義する式を正方形のブラケット内のコンマ分離リストとして列挙できます。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     field_1                  [ 4 ];
     field_2                  [ a+b, 2 ];
     field_3 =:= lsb(16, 16)  [ 26 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The actual length attribute, which is bound by this notation, depends on whether it appears in a &#34;COMPRESSED&#34;, &#34;UNCOMPRESSED&#34;, or &#34;CONTROL&#34; field list (see Section 4.12.1 and its subsections). In a &#34;COMPRESSED&#34; field list, the field&#39;s &#34;CLENGTH&#34; attribute is bound. In &#34;UNCOMPRESSED&#34; and &#34;CONTROL&#34; field lists, the field&#39;s &#34;ULENGTH&#34; attribute is bound. Abbreviated &#34;ENFORCE&#34; statements are not allowed in &#34;DEFAULT&#34; sections (see Section 4.12.1.5). Therefore, the above notation would not be allowed to appear in a &#34;DEFAULT&#34; section. However, if the above appeared in an &#34;UNCOMPRESSED&#34; or &#34;CONTROL&#34; section, it would be equivalent to:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この表記に拘束される実際の長さの属性は、「圧縮」、「圧縮されていない」、または「制御」フィールドリストに表示されるかどうかに依存します（セクション4.12.1およびそのサブセクションを参照）。「圧縮」フィールドリストでは、フィールドの「clength」属性がバインドされています。「圧縮されていない」および「制御」フィールドリストでは、フィールドの「ulength」属性がバインドされています。「デフォルト」セクションでは、「執行」ステートメントが省略されていることは許可されていません（セクション4.12.1.5を参照）。したがって、上記の表記は「デフォルト」セクションに表示されません。ただし、上記が「圧縮されていない」または「制御」セクションに表示された場合、次のものと同等です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     field_1;                 ENFORCE(field_1.ULENGTH == 4);
     field_2;                 ENFORCE((field_2.ULENGTH == 2)
                                   || (field_2.ULENGTH == a+b));
     field_3 =:= lsb(16, 16); ENFORCE(field_3.ULENGTH == 26);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A special case exists for fields that have a variable length that the notator does not wish, or is not able to, define using an expression. The keyword &#34;VARIABLE&#34; can be used in the following case:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知者が式を使用して定義することを望んでいない、またはできないさまざまな長さを持つフィールドに特別なケースが存在します。キーワード「変数」は、次の場合に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
variable_length_field [ VARIABLE ];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
variable_length_field [variable];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Formally, this provides no restrictions on the field length, but maps onto any positive integer or to a value of zero. It will therefore be necessary to define the length of the field elsewhere (see the final paragraphs of Section 4.12.1.1 and Section 4.12.1.2). This may either be in the notation or in the English text of the profile within which the FN is contained. Within the square brackets, the keyword &#34;VARIABLE&#34; may be used as a term in an expression, just like any other term that normally appears in an expression. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正式には、これはフィールドの長さに制限を提供しませんが、正の整数またはゼロの値にマップします。したがって、他の場所でフィールドの長さを定義する必要があります（セクション4.12.1.1およびセクション4.12.1.2の最終段落を参照）。これは、fnが含まれているプロファイルの表記または英語のテキストのいずれかにあります。正方形の括弧内で、キーワード「変数」は、式に通常表示される他の用語と同様に、式の用語として使用できます。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         field  [ 8 * (5 + VARIABLE) ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This defines a field whose length is a whole number of octets and at least 40 bits (5 octets).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、長さがオクテットの全数と少なくとも40ビット（5オクテット）であるフィールドを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-11--Library-of-Encoding-Methods">
4.11. Library of Encoding Methods
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.11. エンコーディング方法のライブラリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number of common techniques for compressing header fields are defined as part of the ROHC-FN library so that they can be reused when creating new ROHC-FN specifications. Their notation is described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフィールドを圧縮するための多くの一般的な手法は、ROHC-FNライブラリの一部として定義されているため、新しいROHC-FN仕様を作成するときに再利用できます。それらの表記については、以下に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an alternative, or a complement, to this library of encoding methods, a ROHC-FN specification can define its own set of encoding methods, using the formal notation (see Section 4.12) or using a textual definition (see Section 4.13).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエンコード方法のこのライブラリの代替または補完として、ROHC-FN仕様は、正式な表記（セクション4.12を参照）を使用するか、テキスト定義（セクション4.13を参照）を使用して、独自のエンコードメソッドセットを定義できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-11-1--uncompressedvalue">
4.11.1. uncompressed_value
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.11.1. 非圧縮_value
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;uncompressed_value&#34; encoding method is used to encode header fields for which the uncompressed value can be defined using a mathematical expression (including constant values). This encoding method is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「非圧縮_Value」エンコードメソッドは、数学的式（定数値を含む）を使用して非圧縮値を定義できるヘッダーフィールドをエンコードするために使用されます。このエンコード方法は、次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     uncompressed_value(len, val) {
       UNCOMPRESSED {
         field;
         ENFORCE(field.ULENGTH == len);
         ENFORCE(field.UVALUE == val);
       }
       COMPRESSED {
         field;
         ENFORCE(field.CLENGTH == 0);
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To exemplify the usage of &#34;uncompressed_value&#34; encoding, the IPv6 header version number is a 4-bit field that always has the value 6:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「非圧縮_Value」エンコーディングの使用法を例示するために、IPv6ヘッダーバージョン番号は、常に値6を持つ4ビットフィールドです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     version   =:=   uncompressed_value(4, 6);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here is another example of value encoding, using an expression to calculate the length:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
式を使用して長さを計算する値エンコーディングの別の例を次に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     padding =:= uncompressed_value(nbits - 8, 0);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The expression above uses an encoding method parameter, &#34;nbits&#34;, that in this example specifies how many significant bits there are in the data to calculate how many pad bits to use. See Section 4.12.2 for more information on encoding method parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の式では、エンコードメソッドパラメーター「nbits」を使用します。この例では、使用するパッドビットの数を計算するデータに重要なビットの数を指定します。エンコードメソッドパラメーターの詳細については、セクション4.12.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-11-2--compressedvalue">
4.11.2. compressed_value
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.11.2. compressed_value
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;compressed_value&#34; encoding method is used to define fields in compressed formats for which there is no counterpart in the uncompressed format (i.e., control fields). It can be used to specify compressed fields whose value can be defined using a mathematical expression (including constant values). This encoding method is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「Compressed_Value」エンコードメソッドは、非圧縮形式（コントロールフィールド）に対応するものがない圧縮形式のフィールドを定義するために使用されます。数学的式（定数値を含む）を使用して値を定義できる圧縮フィールドを指定するために使用できます。このエンコード方法は、次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     compressed_value(len, val) {
       UNCOMPRESSED {
         field;
         ENFORCE(field.ULENGTH == 0);
       }
       COMPRESSED {
         field;
         ENFORCE(field.CLENGTH == len);
         ENFORCE(field.CVALUE == val);
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible use of this encoding method is to define padding in a compressed format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエンコーディング方法の使用可能な1つの使用は、圧縮形式でパディングを定義することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     pad_to_octet_boundary      =:=   compressed_value(3, 0);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A more common use is to define a discriminator field to make it possible to differentiate between different compressed formats within an encoding method (see Section 4.12). For convenience, the notation provides syntax for specifying &#34;compressed_value&#34; encoding in the form of a binary string. The binary string to be encoded is simply given in single quotes; the &#34;CLENGTH&#34; attribute of the field binds with the number of bits in the string, while its &#34;CVALUE&#34; attribute binds with the value given by the string. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
より一般的な用途は、エンコーディング方法内の異なる圧縮形式を区別できるようにするために、判別器フィールドを定義することです（セクション4.12を参照）。便宜上、表記はバイナリ文字列の形で「Compressed_Value」エンコードを指定するための構文を提供します。エンコードされるバイナリ文字列は、単一の引用符で簡単に示されます。フィールドの「clength」属性は、文字列内のビット数に結合し、その「cValue」属性は文字列によって与えられた値に結合します。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     discriminator     =:=   &#39;01101&#39;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This has exactly the same meaning as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、次の意味とまったく同じ意味です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     discriminator     =:=   compressed_value(5, 13);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-11-3--irregular">
4.11.3. irregular
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.11.3. 不規則不定期不整
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;irregular&#34; encoding method is used to encode a field in the compressed format with a bit pattern identical to the uncompressed field. This encoding method is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「不規則な」エンコーディング方法は、圧縮フォーマットでフィールドをエンコードするために使用され、非圧縮フィールドと同じパターンがあります。このエンコード方法は、次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     irregular(len) {
       UNCOMPRESSED {
         field;
         ENFORCE(field.ULENGTH == len);
       }
       COMPRESSED {
         field;
         ENFORCE(field.CLENGTH == len);
         ENFORCE(field.CVALUE == field.UVALUE);
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, the checksum field of the TCP header is a 16-bit field that does not follow any predictable pattern from one header to another (and so it cannot be compressed):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、TCPヘッダーのチェックサムフィールドは、あるヘッダーから別のヘッダーまでの予測可能なパターンに従わない16ビットフィールドです（したがって、圧縮できません）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     tcp_checksum  =:=   irregular(16);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the length does not have to be constant, for example, an expression can be used to derive the length of the field from the value of another field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さは一定である必要はないことに注意してください。たとえば、式を使用して、別のフィールドの値からフィールドの長さを導出することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-11-4--static">
4.11.4. static
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.11.4. 静的スタティック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;static&#34; encoding method compresses a field whose length and value are the same as for a previous header in the flow, i.e., where the field completely matches an existing entry in the context:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「静的」エンコーディングメソッドは、フロー内の以前のヘッダーと同じ長さと値が同じであるフィールドを圧縮します。つまり、フィールドはコンテキストの既存のエントリと完全に一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     field            =:=   static;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The field&#39;s &#34;UVALUE&#34; and &#34;ULENGTH&#34; attributes bind with their respective values in the context and the &#34;CLENGTH&#34; attribute is bound to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドの「uvalue」および「ulength」属性は、コンテキスト内のそれぞれの値にバインドし、「clength」属性はゼロに結合します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the field value is the same as a previous field value, the entire field can be reconstructed from the context, so it is compressed to zero bits and does not appear in the compressed format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールド値は以前のフィールド値と同じであるため、フィールド全体をコンテキストから再構築できるため、圧縮ビットに圧縮され、圧縮形式に表示されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, the source port of the TCP header is a field whose value does not change from one packet to the next for a given flow:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、TCPヘッダーのソースポートは、特定のフローについて、1つのパケットから次のパケットに変化しないフィールドです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     src_port  =:=   static;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-11-5--lsb">
4.11.5. lsb
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.11.5. LSB
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The least significant bits encoding method, &#34;lsb&#34;, compresses a field whose value differs by a small amount from the value stored in the context. The least significant bits of the field value are transmitted instead of the original field value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最も有意なBITSエンコーディング方法「LSB」は、コンテキストに保存されている値と少量によって値が異なるフィールドを圧縮します。フィールド値の最も重要なビットは、元のフィールド値の代わりに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     field  =:=   lsb(&lt;num_lsbs_param&gt;, &lt;offset_param&gt;);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here, &#34;num_lsbs_param&#34; is the number of least significant bits to use, and &#34;offset_param&#34; is the interpretation interval offset as defined below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでは、「num_lsbs_param」は使用する最も重要なビットの数であり、「offset_param」は、以下に定義されているように解釈間隔オフセットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The parameter &#34;num_lsbs_param&#34; binds with the &#34;CLENGTH&#34; attribute, the &#34;UVALUE&#34; attribute binds to the value within the interval whose least significant bits match the &#34;CVALUE&#34; attribute. The value of the &#34;ULENGTH&#34; can be derived from the information stored in the context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パラメーター「num_lsbs_param」は「clength」属性と結合し、「uvalue」属性は、「cvalue」属性と一致する間隔内の値にバインドします。「ulength」の値は、コンテキストに保存されている情報から導き出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, the TCP sequence number:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、TCPシーケンス番号：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     tcp_sequence_number   =:=   lsb(14, 8192);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This takes up 14 bits, and can communicate any value that is between 8192 lower than the value of the field stored in context and 8191 above it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより14ビットがかかり、コンテキストに保存されているフィールドの値とその上の8191の値よりも8192低い値を通知できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The interpretation interval can be described as a function of a value stored in the context, ref_value, and of num_lsbs_param:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解釈間隔は、コンテキスト、ref_value、およびnum_lsbs_paramのコンテキストに保存されている値の関数として説明できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     f(context_value, num_lsbs_param) = [ref_value - offset_param,
                ref_value + (2^num_lsbs_param - 1) - offset_param]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where offset_param is an integer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Offset_Paramは整数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          &lt;-- interpretation interval (size is 2^num_lsbs_param) --&gt;
          |---------------------------+----------------------------|
        lower                     ref_value                      upper
        bound                                                    bound
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        lower bound = ref_value - offset_param
        upper bound = ref_value + (2^num_lsbs_param-1) - offset_param
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;lsb&#34; encoding method can therefore compress a field whose value lies between the lower and the upper bounds, inclusively, of the interpretation interval. In particular, if offset_param = 0, then the field value can only stay the same or increase relative to the reference value ref_value. If offset_param = -1, then it can only increase, whereas if offset_param = 2^num_lsbs_param, then it can only decrease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、「LSB」エンコーディング方法は、解釈間隔の下限と上限の間に値が包括的にあるフィールドを圧縮できます。特に、offset_param = 0の場合、フィールド値は同じままであるか、参照値ref_valueに比べて増加することができます。offset_param = -1の場合、それは増加するだけですが、offset_param = 2^num_lsbs_paramの場合、減少するだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The compressed field takes up the specified number of bits in the compressed format (i.e., num_lsbs_param).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮フィールドは、圧縮形式（つまり、num_lsbs_param）で指定されたビット数を占有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The compressor may not be able to determine the exact reference value stored in the decompressor context and that will be used by the decompressor, since some packets that would have updated the context may have been lost or damaged. However, from feedback received or by making assumptions, the compressor can limit the candidate set of values. The compressor can then select a format that uses &#34;lsb&#34; encoding, defined with suitable values for its parameters num_lsbs_param and offset_param, such that no matter which context value in the candidate set the decompressor uses, the resulting decompression is correct. If that is not possible, the &#34;lsb&#34; encoding method fails (which typically results in a less efficient compressed format being chosen by the compressor). How the compressor determines what reference values it stores and maintains in its set of candidate references is outside the scope of the notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンプレッサーは、コンプレッサーのコンテキストに保存されている正確な基準値を決定できない場合があり、コンプレッサーによって使用されます。ただし、受け取ったフィードバックから、または仮定を作成することにより、コンプレッサーは候補の値セットを制限できます。コンプレッサーは、パラメーターnum_lsbs_paramとoffset_paramに適切な値で定義された「LSB」エンコーディングを使用する形式を選択できます。そのため、候補者のどのコンテキスト値が減圧装置を設定しても、結果として生じる減圧が正しくなります。それが不可能な場合、「LSB」エンコードメソッドは失敗します（通常、コンプレッサーによって選択される効率の低い圧縮形式になります）。コンプレッサーが、候補参照のセットで保存および維持する参照値を決定する方法は、表記の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-11-6--crc">
4.11.6. crc
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.11.6. CRC
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;crc&#34; encoding method provides a CRC calculated over a block of data. The algorithm used to calculate the CRC is the one specified in [RFC4995]. The &#34;crc&#34; method takes a number of parameters:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「CRC」エンコーディング方法は、データのブロックで計算されたCRCを提供します。CRCの計算に使用されるアルゴリズムは、[RFC4995]で指定されているアルゴリズムです。「CRC」メソッドは、多くのパラメーターを取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the number of bits for the CRC (crc_bits),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o CRC（CRC_BITS）のビット数、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the bit-pattern for the polynomial (bit_pattern),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 多項式のビットパターン（bit_pattern）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the initial value for the CRC register (initial_value),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o CRCレジスタ（initial_value）の初期値、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the value of the block of data, represented using either the &#34;UVALUE&#34; or &#34;CVALUE&#34; attribute of a field (block_data_value); and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o データのブロックの値は、フィールド（block_data_value）の「uvalue」または「cvalue」属性のいずれかを使用して表されます。と
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the size in octets of the block of data (block_data_length).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o データブロックのオクテットのサイズ（block_data_length）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
That is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あれは：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     field   =:=   crc(&lt;num_bits&gt;, &lt;bit_pattern&gt;, &lt;initial_value&gt;,
                       &lt;block_data_value&gt;, &lt;block_data_length&gt;);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When specifying the bit pattern for the polynomial, each bit represents the coefficient for the corresponding term in the polynomial. Note that the highest order term is always present (by definition) and therefore does not need specifying in the bit pattern. Therefore, a CRC polynomial with n terms in it is represented by a bit pattern with n-1 bits set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多項式のビットパターンを指定する場合、各ビットは、多項式の対応する項の係数を表します。最高の項が常に（定義上）存在するため、ビットパターンで指定する必要はないことに注意してください。したがって、n項を持つCRC多項式は、n-1ビットセットを備えたビットパターンで表されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CRC is calculated in least significant bit (LSB) order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CRCは、少なくとも有意なビット（LSB）順序で計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     // 3 bit CRC, C(x) = x^0 + x^1 + x^3
     crc_field =:= crc(3, 0x6, 0xF, THIS.CVALUE, THIS.CLENGTH);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Usage of the &#34;THIS&#34; keyword (see Section 4.6) as shown above, is typical when using &#34;crc&#34; encoding. For example, when used in the encoding method for an entire header, it causes the CRC to be calculated over all fields in the header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の「この」キーワード（セクション4.6を参照）の使用は、「CRC」エンコーディングを使用する場合に典型的です。たとえば、ヘッダー全体にエンコーディング方法で使用すると、ヘッダー内のすべてのフィールドでCRCが計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-12--Definition-of-Encoding-Methods">
4.12. Definition of Encoding Methods
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.12. エンコーディング方法の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
New encoding methods can be defined in a formal specification. These compose groups of individual fields into a contiguous block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいエンコード方法は、正式な仕様で定義できます。これらは、個々のフィールドのグループを連続的なブロックに構成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding methods have names and may have parameters; they can also be used in the same way as any other encoding method from the library of encoding methods. Since they can contain references to other encoding methods, complicated formats can be broken down into manageable pieces in a hierarchical fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコーディングメソッドには名前があり、パラメーターがある場合があります。また、エンコードメソッドライブラリの他のエンコード方法と同じ方法で使用することもできます。他のエンコード方法への参照を含めることができるため、複雑な形式は階層的な方法で管理可能なピースに分解できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the various features used to define new encoding methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、新しいエンコーディング方法を定義するために使用されるさまざまな機能について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-12-1--Structure">
4.12.1. Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.12.1. 構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This simplest form of defining an encoding method is to specify a single encoding. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコーディング方法を定義するこの最も単純な形式は、単一のエンコードを指定することです。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     compound_encoding_method
     {
       UNCOMPRESSED {
         field_1;  //  4 bits
         field_2;  // 12 bits
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED {
         field_2 =:= uncompressed_value(12, 9); //  0 bits
         field_1 =:= irregular(4);              //  4 bits
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above begins with the new method&#39;s identifier, &#34;compound_encoding_method&#34;. The definition of the method then follows inside curly brackets, &#34;{&#34; and &#34;}&#34;. The first item in the definition is the &#34;UNCOMPRESSED&#34; field list, which gives the order of the fields in the uncompressed format. This is followed by the compressed format field list (&#34;COMPRESSED&#34;). This list gives the order of fields in the compressed format and also gives the encoding method for each field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記は、新しいメソッドの識別子である「Compleam_Encoding_Method」から始まります。メソッドの定義は、巻き毛の括弧内の「{&#34;および&#34;}」内に続きます。定義の最初の項目は「圧縮されていない」フィールドリストで、非圧縮形式でフィールドの順序を示します。これに続いて、圧縮形式のフィールドリスト（「圧縮」）が続きます。このリストは、圧縮形式のフィールドの順序を提供し、各フィールドのエンコード方法も提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the example, both the formats list each field exactly once. However, sometimes it is necessary to specify more than one binding for a given field, which means it appears more than once in the field list. In this case, it is the first occurrence of the field in the list that indicates its position in the field order. The subsequent occurrences of the field only specify binding information, not field order information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例では、両方の形式が各フィールドを1回正確にリストします。ただし、特定のフィールドに複数のバインディングを指定する必要がある場合があります。つまり、フィールドリストに複数回表示されます。この場合、フィールド順序での位置を示すのは、リスト内のフィールドの最初の発生です。その後のフィールドの発生は、フィールド順序情報ではなく、バインディング情報のみを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The different components of this example are described in more detail below. Other components that can be used in the definition of encoding methods are also defined thereafter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例のさまざまなコンポーネントについては、以下で詳しく説明します。エンコーディング方法の定義で使用できる他のコンポーネントも、その後定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-12-1-1--Uncompressed-Format---UNCOMPRESSED">
4.12.1.1. Uncompressed Format - &#34;UNCOMPRESSED&#34;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.12.1.1. 非圧縮形式 - 「非圧縮」
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The uncompressed field list is defined by &#34;UNCOMPRESSED&#34;, which specifies the fields of the uncompressed format in the order that they appear in the uncompressed header. The sum of the lengths of each individual uncompressed field in the list must be equal to the length of the field being encoded. Finally, the representation of the uncompressed format described using the list of fields in the &#34;UNCOMPRESSED&#34; section, for which compressed formats are being defined, always consists of one single contiguous block of bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非圧縮フィールドリストは、非圧縮形式のフィールドを非圧縮ヘッダーに表示する順に指定する「非圧縮」で定義されます。リスト内の個々の個々の非圧縮フィールドの長さの合計は、エンコードされているフィールドの長さに等しくなければなりません。最後に、圧縮形式が定義されている「圧縮されていない」セクションのフィールドのリストを使用して説明されている非圧縮形式の表現は、常に1つの隣接するビットブロックで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the example above in Section 4.12.1, the uncompressed field list is &#34;field_1&#34;, followed by &#34;field_2&#34;. This means that a field being encoded by this method is divided into two subfields, &#34;field_1&#34; and &#34;field_2&#34;. The total uncompressed length of these two fields therefore equals the length of the field being encoded:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション4.12.1の上記の例では、圧縮されていないフィールドリストは「Field_1」で、「Field_2」が続きます。これは、この方法でエンコードされているフィールドが、「Field_1」と「Field_2」という2つのサブフィールドに分割されることを意味します。したがって、これら2つのフィールドの総非圧縮長さは、エンコードされているフィールドの長さに等しくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     field_1.ULENGTH + field_2.ULENGTH == THIS.ULENGTH
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the example, there are only two fields, but any number of fields may be used. This relationship applies to however many fields are actually used. Any arrangement of fields that efficiently describes the content of the uncompressed header may be chosen -- this need not be the same as the one described in the specifications for the protocol header being compressed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例では、フィールドは2つしかありませんが、任意の数のフィールドを使用できます。この関係は、多くのフィールドが実際に使用されていることに適用されます。非圧縮ヘッダーのコンテンツを効率的に説明するフィールドの配置が選択される場合があります。これは、圧縮されるプロトコルヘッダーの仕様に記載されているものと同じである必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, there may be a protocol whose header contains a 16-bit sequence number, but whose sessions tend to be short-lived. This would mean that the high bits of the sequence number are almost always constant. The &#34;UNCOMPRESSED&#34; format could reflect this by splitting the original uncompressed field into two fields, one field to represent the almost-always-zero part of the sequence number, and a second field to represent the salient part.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、ヘッダーに16ビットシーケンス番号が含まれているが、セッションが短命になる傾向があるプロトコルがある場合があります。これは、シーケンス数の高いビットがほとんど常に一定であることを意味します。「圧縮されていない」形式は、元の非圧縮フィールドを2つのフィールドに分割することでこれを反映できます。1つのフィールドは、シーケンス番号のほぼゼロの部分を表し、顕著な部分を表す2番目のフィールドです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An &#34;UNCOMPRESSED&#34; field list may specify encoding methods in the same way as the &#34;COMPRESSED&#34; field list in the example. Encoding methods specified therein are used whenever a packet with that uncompressed format is being encoded. The encoding of a packet with a given uncompressed format can only succeed if all of its encoding methods and &#34;ENFORCE&#34; statements succeed (see Section 4.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「圧縮されていない」フィールドリストは、例の「圧縮」フィールドリストと同じ方法でエンコードメソッドを指定する場合があります。その中で指定されたエンコードメソッドは、その非圧縮形式のパケットがエンコードされているときはいつでも使用されます。特定の非圧縮形式を使用したパケットのエンコードは、すべてのエンコードメソッドと「施行」ステートメントが成功した場合にのみ成功できます（セクション4.9を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The total length of each uncompressed format must always be defined. The length of each of the fields in an uncompressed format must also be defined. This means that the bindings in the &#34;UNCOMPRESSED&#34;, &#34;COMPRESSED&#34; (see Section 4.12.1.2 below), &#34;CONTROL&#34; (see Section 4.12.1.3 below), &#34;INITIAL&#34; (see Section 4.12.1.4 below), and &#34;DEFAULT&#34; (see Section 4.12.1.5 below) field lists must, between them, define the &#34;ULENGTH&#34; attribute of every field in an uncompressed format so that there is an unambiguous mapping from the bits in the uncompressed format to the fields listed in the &#34;UNCOMPRESSED&#34; field list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非圧縮形式の合計長さは常に定義する必要があります。非圧縮形式の各フィールドの長さも定義する必要があります。これは、「圧縮されていない」、「圧縮」（以下のセクション4.12.1.2を参照）、「コントロール」（以下のセクション4.12.1.3を参照）、「初期」（以下のセクション4.12.1.4を参照）、および「デフォルトを参照）のバインディングを意味します。「（以下のセクション4.12.1.5を参照）フィールドリストは、それらの間で、非圧縮形式のすべてのフィールドの「ULength」属性を定義する必要があります。そうすることで、非圧縮形式のビットからのビットからのマッピングが明確にマッピングされます。」非圧縮 &#34;フィールドリスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-12-1-2--Compressed-Format---COMPRESSED">
4.12.1.2. Compressed Format - &#34;COMPRESSED&#34;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.12.1.2. 圧縮形式 - 「圧縮」
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similar to the uncompressed field list, the fields in the compressed header will appear in the order specified by the compressed field list given for a compressed format. Each individual field is encoded in the manner given for that field. The total length of the compressed data will be the sum of the compressed lengths of all the individual fields. In the example from Section 4.12.1, the encoding methods used for these fields indicate that they are zero and 4 bits long, making a total of 4 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非圧縮フィールドリストと同様に、圧縮ヘッダーのフィールドは、圧縮形式で指定された圧縮フィールドリストで指定された順序で表示されます。個々のフィールドは、そのフィールドに与えられた方法でエンコードされます。圧縮データの総長さは、すべての個々のフィールドの圧縮長の合計です。セクション4.12.1の例では、これらのフィールドに使用されるエンコーディング方法は、それらがゼロと4ビットの長さであり、合計4ビットを作ることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The order of the fields specified in a &#34;COMPRESSED&#34; field list does not have to match the order they appear in the &#34;UNCOMPRESSED&#34; field list. It may be desirable to reorder the fields in the compressed format to align the compressed header to the octet boundary, or for other reasons. In the above example, the order is in fact the opposite of that in the uncompressed format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「圧縮された」フィールドリストで指定されたフィールドの順序は、「圧縮されていない」フィールドリストに表示される順序を一致させる必要はありません。圧縮された形式でフィールドを再注文して、圧縮されたヘッダーをOctet境界に整列させることが望ましい場合があります。上記の例では、順序は実際には、非圧縮形式でそれの反対です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The compressed field list specifies that the encoding for &#34;field_1&#34; is &#34;irregular&#34;, and takes up 4 bits in both the compressed format and uncompressed format. The encoding for &#34;field_2&#34; is &#34;uncompressed_value&#34;, which means that the field has a fixed value, so it can be compressed to zero bits. The value it takes is 9, and it is 12 bits wide in the uncompressed format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮フィールドリストは、「Field_1」のエンコードが「不規則」であることを指定し、圧縮形式と非圧縮形式の両方で4ビットを占有します。「field_2」のエンコードは「非圧縮_value」です。つまり、フィールドに固定値があるため、ビットゼロに圧縮できます。取る値は9で、非圧縮形式では12ビット幅です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fields like &#34;field_2&#34;, which compress to zero bits in length, may appear anywhere in the field list without changing the compressed format because their position in the list is not significant. In fact, if the encoding method for this field were defined elsewhere (for example, in the &#34;UNCOMPRESSED&#34; section), this field could be omitted from the &#34;COMPRESSED&#34; section altogether:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さがゼロビットに圧縮される「Field_2」のようなフィールドは、リスト内の位置が重要ではないため、圧縮形式を変更せずにフィールドリストのどこにでも表示される場合があります。実際、このフィールドのエンコーディング方法が他の場所（たとえば、「圧縮されていない」セクション）で定義されている場合、このフィールドは「圧縮」セクションから完全に省略できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     compound_encoding_method
     {
       UNCOMPRESSED {
         field_1;                                //  4 bits
         field_2 =:= uncompressed_value(12, 9);  // 12 bits
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED {
         field_1 =:= irregular(4);               //  4 bits
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The total length of each compressed format must always be defined. The length of each of the fields in a compressed format must also be defined. This means that the bindings in the &#34;UNCOMPRESSED&#34;, &#34;COMPRESSED&#34;, &#34;CONTROL&#34; (see Section 4.12.1.3 below), &#34;INITIAL&#34; (see Section 4.12.1.4 below), and &#34;DEFAULT&#34; (see Section 4.12.1.5 below) field lists must between them define the &#34;CLENGTH&#34; attribute of every field in a compressed format so that there is an unambiguous mapping from the bits in the compressed format to the fields listed in the &#34;COMPRESSED&#34; field list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各圧縮形式の合計長さは常に定義する必要があります。圧縮形式の各フィールドの長さも定義する必要があります。これは、「圧縮されていない」、「圧縮」、「コントロール」（以下のセクション4.12.1.3を参照）、「初期」（以下のセクション4.12.1.4を参照）、および「デフォルト」（以下のセクション4.12.1.5を参照）のバインディングを意味します。）フィールドリストは、圧縮形式のすべてのフィールドの「clength」属性を定義する必要があるため、圧縮形式のビットから「圧縮」フィールドリストにリストされているフィールドに明確なマッピングがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-12-1-3--Control-Fields---CONTROL">
4.12.1.3. Control Fields - &#34;CONTROL&#34;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.12.1.3. 制御フィールド - 「コントロール」
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Control fields are defined using the &#34;CONTROL&#34; field list. The control field list specifies all fields that do not appear in the uncompressed format, but that have an uncompressed value (specifically those with an &#34;ULENGTH&#34; greater than zero). Such fields may be used to help compress fields from the uncompressed format more efficiently. A control field could be used to improve efficiency by representing some commonality between a number of the uncompressed fields, or by representing some information about the flow that is not explicitly contained in the protocol headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御フィールドは、「コントロール」フィールドリストを使用して定義されます。制御フィールドリストは、非圧縮形式に表示されないが、圧縮されていない値（具体的にはゼロを超える「ulength」を持つもの）を持つすべてのフィールドを指定します。このようなフィールドは、非圧縮形式からフィールドをより効率的に圧縮するのに役立つために使用できます。制御フィールドを使用して、多くの非圧縮フィールド間の共通性を表すか、プロトコルヘッダーに明示的に含まれていないフローに関する情報を表すことにより、効率を改善できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example in IPv4, the behaviour of the IP-ID field in a flow varies depending on how the endpoints handle IP-IDs. Sometimes the behaviour is effectively random and sometimes the IP-ID follows a predictable sequence. The type of IP-ID behaviour is information that is never communicated explicitly in the uncompressed header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、IPv4では、フローにおけるIP-IDフィールドの動作は、エンドポイントがIP-IDを処理する方法によって異なります。動作が事実上ランダムである場合があり、場合によってはIP-IDが予測可能なシーケンスに従うことがあります。IP-IDの動作のタイプは、非圧縮ヘッダーで明示的に伝えられない情報です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, a profile can still be designed to identify the behaviour and adjust the compression strategy according to the identified behaviour, thereby improving the compression performance. To do so, the ROHC-FN specification can introduce an explicit field to communicate the IP-ID behaviour in compressed format -- this is done by introducing a control field:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、プロファイルは、動作を識別し、特定された動作に応じて圧縮戦略を調整するように設計することができ、それにより圧縮性能が向上します。そのために、ROHC-FN仕様は、圧縮形式でIP-IDの動作を通信するための明示的なフィールドを導入できます。これは、制御フィールドを導入することによって行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     ipv4
     {
       UNCOMPRESSED {
         version;       // 4 bits
         hdr_length;    // 4 bits
         protocol;      // 8 bits
         dscp;          // 6 bits
         ip_ecn_flags;  // 2 bits
         ttl_hopl;      // 8 bits
         df;            // 1 bit
         mf;            // 1 bit
         rf;            // 1 bit
         frag_offset;   // 13 bits
              ip_id;         // 16 bits
         src_addr;      // 32 bits
         dst_addr;      // 32 bits
         checksum;      // 16 bits
         length;        // 16 bits
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
CONTROL { ip_id_behavior; // 1 bit : :
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
control {ip_id_behavior;// 1ビット：：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;CONTROL&#34; field list is equivalent to the &#34;UNCOMPRESSED&#34; field list for fields that do not appear in the uncompressed format. It defines a field that has the same properties (the same defined attributes, etc.) as fields appearing in the uncompressed format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「コントロール」フィールドリストは、非圧縮形式に表示されないフィールドの「圧縮されていない」フィールドリストに相当します。非圧縮形式に表示されるフィールドと同じプロパティ（同じ定義属性など）を持つフィールドを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Control fields are initialised by using the appropriate encoding methods and/or by using &#34;ENFORCE&#34; statements. This may be done inside the &#34;CONTROL&#34; field list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御フィールドは、適切なエンコーディング方法を使用して、および/または「施行」ステートメントを使用して初期化されます。これは、「コントロール」フィールドリスト内で実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     example_encoding_method_definition
     {
       UNCOMPRESSED {
         field_1 =:= some_encoding;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       CONTROL {
         scaled_field;
         ENFORCE(scaled_field.UVALUE == field_1.UVALUE / 8);
         ENFORCE(scaled_field.ULENGTH == field_1.ULENGTH - 3);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED {
         scaled_field =:= lsb(4, 0);
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This control field is used to scale down a field in the uncompressed format by a factor of 8 before encoding it with the &#34;lsb&#34; encoding method. Scaling it down makes the &#34;lsb&#34; encoding more efficient.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この制御フィールドは、「LSB」エンコードメソッドでエンコードする前に、非圧縮形式のフィールドを8倍にスケーリングするために使用されます。それをスケーリングすると、「LSB」をエンコードする「LSB」がより効率的になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Control fields may also be used with a global scope. In this case, their declaration must be outside of any encoding method definition. They are then visible within any encoding method, thus allowing information to be shared between encoding methods directly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コントロールフィールドは、グローバルな範囲で使用することもできます。この場合、それらの宣言は、エンコードメソッド定義の外側でなければなりません。その後、任意のエンコーディング方法内に表示されるため、エンコードメソッド間で直接情報を共有できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-12-1-4--Initial-Values---INITIAL">
4.12.1.4. Initial Values - &#34;INITIAL&#34;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.12.1.4. 初期値 - 「初期」
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to allow fields in the very first usage of a specific format to be compressed with &#34;static&#34;, &#34;lsb&#34;, or other encoding methods that depend on the context, it is possible to specify initial bindings for such fields. This is done using &#34;INITIAL&#34;, for example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定の形式の最初の使用法でフィールドを「静的」、「LSB」、またはコンテキストに依存するその他のエンコードメソッドで圧縮できるようにするために、そのようなフィールドの初期バインディングを指定することができます。これは、「初期」を使用して行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     INITIAL {
        field =:= uncompressed_value(4, 6);
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This initialises the &#34;UVALUE&#34; of &#34;field&#34; to 6 and initialises its &#34;ULENGTH&#34; to 4. Unlike all other bindings specified in the formal notation, these bindings are applied to the context of the field, if the field&#39;s context is undefined. This is particularly useful when using encoding methods that rely on context being present, such as &#34;static&#34; or &#34;lsb&#34;, with the first packet in a flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、「フィールド」の「uvalue」を6に初期化し、「ulength」に「ulength」を初期化します。正式な表記で指定された他のすべてのバインディングとは異なり、これらのバインディングは、フィールドのコンテキストが定義されていない場合、フィールドのコンテキストに適用されます。これは、フローに最初のパケットを使用して、「静的」や「LSB」などのコンテキストに依存するエンコーディング方法を使用する場合に特に役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the &#34;INITIAL&#34; field list is used to bind the context alone, it makes no sense to specify initial bindings that themselves rely on the context, for example, &#34;lsb&#34;. Such usage is not allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「初期」フィールドリストはコンテキストのみをバインドするために使用されるため、たとえば「LSB」など、コンテキストに依存する初期バインディングを指定することは意味がありません。このような使用は許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-12-1-5--Default-Field-Bindings---DEFAULT">
4.12.1.5. Default Field Bindings - &#34;DEFAULT&#34;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.12.1.5. デフォルトのフィールドバインディング - 「デフォルト」
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Default bindings may be specified for each field or attribute. The default encoding methods specify the encoding method to use for a field if no binding is given elsewhere for the value of that field. This is helpful to keep the definition of the formats concise, as the same encoding method need not be repeated for every format, when defining multiple formats (see Section 4.12.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デフォルトのバインディングは、各フィールドまたは属性に対して指定できます。デフォルトのエンコーディングメソッドは、そのフィールドの値について他の場所にバインディングが与えられていない場合、フィールドに使用するエンコードメソッドを指定します。これは、複数の形式を定義する場合、すべての形式で同じエンコードメソッドを繰り返す必要はないため、形式の定義を簡潔に保つのに役立ちます（セクション4.12.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Default bindings are optional and may be given for any combination of fields and attributes which are in scope.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デフォルトのバインディングはオプションであり、範囲内のフィールドと属性の任意の組み合わせに与えられる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The syntax for specifying default bindings is similar to that used to specify a compressed or uncompressed format. However, the order of the fields in the field list does not affect the order of the fields in either the compressed or uncompressed format. This is because the field order is specified individually for each &#34;COMPRESSED&#34; format and &#34;UNCOMPRESSED&#34; format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デフォルトのバインディングを指定するための構文は、圧縮または非圧縮形式を指定するために使用される構文と類似しています。ただし、フィールドリストのフィールドの順序は、圧縮形式または非圧縮形式のいずれのフィールドの順序に影響しません。これは、フィールド順序が各「圧縮」形式および「圧縮されていない」形式ごとに個別に指定されているためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here is an example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これが例です：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       DEFAULT {
         field_1 =:= uncompressed_value(4, 1);
         field_2 =:= uncompressed_value(4, 2);
         field_3 =:= lsb(3, -1);
         ENFORCE(field_4.ULENGTH == 4);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here default bindings are specified for fields 1 to 3. A default binding for the &#34;ULENGTH&#34; attribute of field_4 is also specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでは、フィールド1〜3にデフォルトのバインディングが指定されています。Field_4の「ULength」属性のデフォルトのバインディングも指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fields for which there is a default encoding method do not need their bindings to be specified in the field list of any format that uses the default encoding method for that field. Any format that does not use the default encoding method must explicitly specify a binding for the value of that field&#39;s attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デフォルトのエンコーディング方法があるフィールドでは、そのフィールドにデフォルトのエンコードメソッドを使用する任意のフォーマットのフィールドリストで、バインディングを指定する必要はありません。デフォルトのエンコードメソッドを使用しない形式は、そのフィールドの属性の値に対するバインディングを明示的に指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If elsewhere a binding is not specified for the attributes of a field, the default encoding method is used. If the default encoding method always compresses the field down to zero bits, the field can be omitted from the compressed format&#39;s field list. Like any other zero-bit field, its position in the field list is not significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他の場所で、フィールドの属性にバインディングが指定されていない場合、デフォルトのエンコーディング方法が使用されます。デフォルトのエンコードメソッドが常にフィールドをゼロビットに圧縮する場合、フィールドは圧縮形式のフィールドリストから省略できます。他のゼロビットフィールドと同様に、フィールドリストにおけるその位置は重要ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;DEFAULT&#34; field list may contain default bindings for individual attributes by using &#34;ENFORCE&#34; statements. A default binding for an individual attribute will only be used if elsewhere there is no binding given for that attribute or the field to which it belongs. If elsewhere there is an &#34;ENFORCE&#34; statement binding that attribute, or an encoding method binding the field to which it belongs, the default binding for the attribute will not be used. This applies even if the specified encoding method does not bind the particular attribute given in the &#34;DEFAULT&#34; section. However, an &#34;ENFORCE&#34; statement elsewhere that only binds the length of the field still allows the default bindings to be used, except for default &#34;ENFORCE&#34; statements which bind nothing but the field&#39;s length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「デフォルト」フィールドリストには、「施行」ステートメントを使用して、個々の属性のデフォルトバインディングを含めることができます。個々の属性のデフォルトのバインディングは、その属性またはそれが属するフィールドに対して与えられたバインディングが与えられていない場合にのみ使用されます。他の場所に、その属性のバインディングバインディングの「施行」ステートメントがある場合、またはそれが属するフィールドをバインドするエンコードメソッドがある場合、属性のデフォルトのバインディングは使用されません。これは、指定されたエンコードメソッドが「デフォルト」セクションに与えられた特定の属性にバインドされていない場合でも適用されます。ただし、フィールドの長さのみにバインドする「施行」ステートメントは、フィールドの長さ以外の何もバインドしていないデフォルトの「施行」ステートメントを除き、デフォルトのバインディングを使用することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To clarify, assuming the default bindings given in the example above, the first three of the following four compressed formats would not use the default binding for &#34;field_4.ULENGTH&#34;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の例で示されているデフォルトのバインディングを仮定すると、次の4つの圧縮形式の最初の3つは、「field_4.ulength」にデフォルトのバインディングを使用しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED format1 {
         ENFORCE(field_4.ULENGTH == 3); // set ULENGTH to 3
         ENFORCE(field_4.UVALUE == 7);  // set UVALUE to 7
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED format2 {
         field_4 =:= irregular(3);      // set ULENGTH to 3
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED format3 {
         field_4 =:= &#39;1010&#39;;            // set ULENGTH to zero
       }
              COMPRESSED format4 {
         ENFORCE(field_4.UVALUE == 12); // use default ULENGTH
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fourth format is the only one that uses the default binding for &#34;field_4.ULENGTH&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4番目の形式は、「field_4.ulength」にデフォルトのバインディングを使用する唯一の形式です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In summary, the default bindings of an encoding method are only used for formats that do not already specify a binding for the value of all of their fields. For the formats that do use default bindings, only those fields and attributes whose bindings are not specified are looked up in the &#34;DEFAULT&#34; field list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要約すると、エンコードメソッドのデフォルトのバインディングは、すべてのフィールドの値のバインディングをまだ指定していないフォーマットにのみ使用されます。デフォルトのバインディングを使用する形式の場合、バインディングが指定されていないフィールドと属性のみが「デフォルト」フィールドリストで調べられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-12-2--Arguments">
4.12.2. Arguments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.12.2. 議論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding methods may take arguments that control the mapping between compressed and uncompressed fields. These are specified immediately after the method&#39;s name, in parentheses, as a comma-separated list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコーディングメソッドは、圧縮フィールドと非圧縮フィールドの間のマッピングを制御する引数を取る場合があります。これらは、メソッドの名前の直後に、カンマーを分離されたリストとして指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     poor_mans_lsb(variable_length)
     {
       UNCOMPRESSED {
         constant_bits;
         variable_bits;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED {
         variable_bits =:= irregular(variable_length);
         constant_bits =:= static;
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with any encoding method, all arguments take individual values, such as an integer literal or a field attribute, rather than entire fields. Although entire fields cannot be passed as arguments, it is possible to pass each of their attributes instead, which is equivalent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のエンコーディング方法と同様に、すべての引数は、フィールド全体ではなく、整数リテラルまたはフィールド属性などの個々の値を取得します。フィールド全体を引数として渡すことはできませんが、代わりに各属性を渡すことができますが、これは同等です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recall that all bindings are two-way, so that rather than the arguments acting as &#34;inputs&#34; to the encoding method, the result of an encoding method may be to bind the parameters passed to it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのバインディングは双方向であるため、エンコード方法への「入力」として機能する引数ではなく、エンコード方法の結果は、渡されたパラメーターにバインドすることである可能性があることを思い出してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     set_to_double(arg1, arg2)
     {
       CONTROL {
         ENFORCE(arg1 == 2 * arg2);
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This encoding method will attempt to bind the first argument to twice the value of the second. In fact this &#34;encoding&#34; method is pathological. Since it defines no fields, it does not do any actual encoding at all. &#34;CONTROL&#34; sections are more appropriate to use for this purpose than &#34;UNCOMPRESSED&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このエンコードメソッドは、最初の引数を2番目の値の2倍に結合しようとします。実際、この「エンコーディング」方法は病的です。フィールドは定義されていないため、実際のエンコードはまったく行われません。「制御」セクションは、「非圧縮」よりもこの目的のために使用する方が適切です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-12-3--Multiple-Formats">
4.12.3. Multiple Formats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.12.3. 複数の形式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding methods can also define multiple formats for a given header. This allows different compression methods to be used depending on what is the most efficient way of compressing a particular header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコードメソッドは、特定のヘッダーの複数の形式を定義することもできます。これにより、特定のヘッダーを圧縮する最も効率的な方法に応じて、さまざまな圧縮方法を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, a field may have a fixed value most of the time, but the value may occasionally change. Using a single format for the encoding, this field would have to be encoded using &#34;irregular&#34; (see Section 4.11.3), even though the value only changes rarely. However, by defining multiple formats, we can provide two alternative encodings: one for when the value remains fixed and another for when the value changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、フィールドはほとんどの場合固定値を持つ場合がありますが、値が変更される場合があります。エンコードに単一の形式を使用して、このフィールドは「不規則」を使用してエンコードする必要があります（セクション4.11.3を参照）。ただし、複数の形式を定義することにより、2つの代替エンコーディングを提供できます。1つは固定されたままで、もう1つは値が変更されるときです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is the topic of the following sub-sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、次のサブセクションのトピックです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-12-3-1--Naming-Convention">
4.12.3.1. Naming Convention
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.12.3.1. 命名規則
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When compressed formats are defined, they must be defined using the reserved word &#34;COMPRESSED&#34;. Similarly, uncompressed formats must be defined using the reserved word &#34;UNCOMPRESSED&#34;. After each of these keywords, a name may be given for the format. If no name is given to the format, the name of the format is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮形式が定義されている場合、予約された単語「圧縮」を使用して定義する必要があります。同様に、非圧縮形式は、予約された単語「非圧縮」を使用して定義する必要があります。これらの各キーワードの後、フォーマットに名前が付けられる場合があります。形式に名前が付けられていない場合、形式の名前は空です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Format names, except for the case where the name is empty, follow the syntactic rules of identifiers as described in Section 4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前が空の場合を除き、フォーマット名は、セクション4.2で説明されている識別子の構文規則に従ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Format names must be unique within the scope of the encoding method to which they belong, except for the empty name, which may be used for one &#34;COMPRESSED&#34; and one &#34;UNCOMPRESSED&#34; format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フォーマット名は、1つの「圧縮」と1つの「圧縮されていない」形式に使用できる空の名前を除き、属するエンコード方法の範囲内で一意でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-12-3-2--Format-Discrimination">
4.12.3.2. Format Discrimination
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.12.3.2. 差別の形式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the compressed formats has its own field list. A compressor may pick any of these alternative formats to compress a header, as long as the field bindings it employs can be used with the uncompressed format. For example, the compressor could not choose to use a compressed format that had a &#34;static&#34; encoding for a field whose &#34;UVALUE&#34; attribute differs from its corresponding value in the context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それぞれの圧縮形式には、独自のフィールドリストがあります。コンプレッサーは、これらの代替形式のいずれかを選択して、使用しているフィールドバインディングを非圧縮形式で使用できる限り、ヘッダーを圧縮することができます。たとえば、コンプレッサーは、「uvalue」属性がコンテキスト内の対応する値と異なるフィールドに「静的」エンコードを持つ圧縮形式を使用することを選択できませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
More formally, the compressor can choose any combination of an uncompressed format and a compressed format for which no binding for any of the field&#39;s attributes &#34;fail&#34;, i.e., the encoding methods and &#34;ENFORCE&#34; statements (see Section 4.9) that bind their compressed attributes succeed. If there are multiple successful combinations, the compressor can choose any one. Otherwise if there are no successful combinations, the encoding method &#34;fails&#34;. A format will never fail due to it not defining the &#34;UVALUE&#34; attribute of a field. A format only fails if it fails to define one of the compressed attributes of one of the fields in the compressed format, or leaves the length of the uncompressed format undefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
より正式には、コンプレッサーは、圧縮されていない形式と圧縮形式の任意の組み合わせを選択できます。これにより、フィールドの属性が「失敗」、つまりエンコードメソッドと「実施」ステートメント（セクション4.9を参照」（セクション4.9を参照）を選択できます。属性は成功します。複数の成功した組み合わせがある場合、コンプレッサーは任意の組み合わせを選択できます。それ以外の場合、組み合わせが成功していない場合、エンコードメソッドは「失敗」します。フィールドの「UValue」属性を定義していないため、フォーマットは決して失敗しません。形式は、圧縮形式のフィールドの1つの圧縮属性の1つを定義できない場合、または非圧縮形式の長さを未定義のままにしない場合にのみ失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the compressor has a choice, it must be possible for the decompressor to discriminate between the different compressed formats that the compressor could have chosen. A simple approach to this problem is for each compressed format to include a &#34;discriminator&#34; that uniquely identifies that particular &#34;COMPRESSED&#34; format. A discriminator is a control field; it is not derived from any of the uncompressed field values (see Section 4.11.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンプレッサーには選択肢があるため、減圧器がコンプレッサーが選択できたさまざまな圧縮形式を区別できる必要があります。この問題に対する簡単なアプローチは、各圧縮形式がその特定の「圧縮」形式を一意に識別する「識別子」を含めることです。判別器は制御フィールドです。これは、圧縮されていないフィールド値のいずれからも導き出されていません（セクション4.11.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-12-3-3--Example-of-Multiple-Formats">
4.12.3.3. Example of Multiple Formats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.12.3.3. 複数の形式の例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Putting this all together, here is a complete example of the definition of an encoding method with multiple compressed formats:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これをすべてまとめると、複数の圧縮形式を使用したエンコードメソッドの定義の完全な例を次に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     example_multiple_formats
     {
       UNCOMPRESSED {
         field_1;  //  4 bits
         field_2;  //  4 bits
         field_3;  // 24 bits
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       DEFAULT {
         field_1 =:= static;
         field_2 =:= uncompressed_value(4, 2);
         field_3 =:= lsb(4, 0);
       }
              COMPRESSED format0 {
         discriminator =:= &#39;0&#39;; // 1 bit
         field_3;               // 4 bits
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED format1 {
         discriminator =:= &#39;1&#39;;           //  1 bit
         field_1       =:= irregular(4);  //  4 bits
         field_3       =:= irregular(24); // 24 bits
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のことに注意してください：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;field_1&#34; and &#34;field_3&#34; both have default encoding methods specified for them, which are used in &#34;format0&#34;, but are overridden in &#34;format1&#34;; the default encoding method of &#34;field_2&#34; however, is not overridden.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「Field_1」と「Field_3」はどちらも、「Format0」で使用されているが、「Format1」でオーバーライドされているデフォルトのエンコードメソッドが指定されています。ただし、「field_2」のデフォルトのエンコーディング方法は無効にされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;field_1&#34; and &#34;field_2&#34; have default encoding methods that compress to zero bits. When these are used in &#34;format0&#34;, the field names do not appear in the field list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 「Field_1」と「Field_2」には、ビットがゼロに圧縮されるデフォルトのエンコードメソッドがあります。これらを「format0」で使用する場合、フィールド名はフィールドリストに表示されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;field_3&#34; has an encoding method that does not compress to zero bits, so whilst &#34;field_3&#34; has no encoding specified for it in the field list of &#34;format0&#34;, it still needs to appear in the field list to specify where it goes in the compressed format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;field_3&#34;にはゼロビットに圧縮されないエンコードメソッドがあるため、「format0」のフィールドリストに「field_3」が指定されているエンコードはありませんが、フィールドリストに表示するには、入力する場所を指定する必要があります。圧縮形式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the example, all the fields in the uncompressed format have default encoding methods specified for them, but this is not a requirement. Default encodings can be specified for only some or even none of the fields of the uncompressed format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o この例では、非圧縮形式のすべてのフィールドには、それらに指定されたデフォルトのエンコードメソッドがありますが、これは要件ではありません。デフォルトのエンコーディングは、非圧縮形式のフィールドの一部またはまずない場合に指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the example, all the default encoding methods are on fields from the uncompressed format, but this is not a requirement. Default encoding methods can be specified for control fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o この例では、すべてのデフォルトのエンコードメソッドは、非圧縮形式のフィールド上にありますが、これは要件ではありません。コントロールフィールドにデフォルトのエンコードメソッドを指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-13--Profile-Specific-Encoding-Methods">
4.13. Profile-Specific Encoding Methods
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.13. プロファイル固有のエンコーディング方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The library of encoding methods defined by ROHC-FN in Section 4.11 provides a basic and generic set of field encoding methods. When using a ROHC-FN specification in a ROHC profile, some additional encodings specific to the particular protocol header being compressed may, however, be needed, such as methods that infer the value of a field from other values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション4.11のROHC-FNによって定義されたエンコーディングメソッドのライブラリは、フィールドエンコーディング方法の基本的および一般的なセットを提供します。ただし、ROHCプロファイルでROHC-FN仕様を使用する場合、圧縮される特定のプロトコルヘッダーに固有のいくつかの追加のエンコーディングが必要になる場合があります。たとえば、他の値からフィールドの値を推測する方法などです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These methods are specific to the properties of the protocol being compressed and will thus have to be defined within the profile specification itself. Such profile-specific encoding methods, defined either in ROHC-FN syntax or rigorously in plain text, can be referred to in the ROHC-FN specification of the profile&#39;s formats in the same way as any method in the ROHC-FN library.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの方法は、圧縮されているプロトコルのプロパティに固有であるため、プロファイル仕様自体内で定義する必要があります。ROHC-FN構文のいずれかまたはプレーンテキストで厳密に定義されているこのようなプロファイル固有のエンコードメソッドは、ROHC-FNライブラリの任意の方法と同じ方法で、プロファイルの形式のROHC-FN仕様で参照できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding methods that are not defined in the formal notation are specified by giving their name, followed by a short description of where they are defined, in double quotes, and a semi-colon.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正式な表記で定義されていないエンコードメソッドは、名前を付けることで指定され、その後、それらが定義されている場所、二重引用符、およびセミコロンの簡単な説明が続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
inferred_ip_v4_header_checksum &#34;defined in RFCxxxx Section 6.4.1&#34;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
vedred_ip_v4_header_checksum &#34;rfcxxxxセクション6.4.1&#34;で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Security-Considerations">
5. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes a formal notation similar to ABNF [RFC4234], and hence is not believed to raise any security issues (note that ABNF has a completely separate purpose to the ROHC formal notation).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、ABNF [RFC4234]に類似した正式な表記法について説明するため、セキュリティの問題を提起するとは考えられていません（ABNFにはROHCの正式な表記法と完全に別々の目的があることに注意してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Contributors">
6. Contributors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 貢献者
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Richard Price did much of the foundational work on the formal notation. He authored the initial document describing a formal notation on which this document is based.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リチャード・プライスは、正式な表記法で基本的な仕事の多くをしました。彼は、このドキュメントの基礎となる正式な表記を説明する最初の文書を執筆しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kristofer Sandlund contributed to this work by applying new ideas to the ROHC-TCP profile, by providing feedback, and by helping resolve different issues during the entire development of the notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kristofer Sandlundは、ROHC-TCPプロファイルに新しいアイデアを適用し、フィードバックを提供し、表記の全体の開発中にさまざまな問題の解決を支援することにより、この作業に貢献しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Carsten Bormann provided the translation of the formal notation syntax using ABNF in Appendix A, and also contributed with feedback and reviews to validate the completeness and correctness of the notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Carsten Bormannは、付録AのABNFを使用して正式な表記構文の翻訳を提供し、表記の完全性と正しさを検証するためのフィードバックとレビューにも貢献しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Acknowledgements">
7. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number of important concepts and ideas have been borrowed from ROHC [RFC3095].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ROHC [RFC3095]から多くの重要な概念とアイデアが借用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to Mark West, Eilert Brinkmann, Alan Ford, and Lars-Erik Jonsson for their contributions, reviews, and feedback that led to significant improvements to the readability, completeness, and overall quality of the notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mark West、Eilert Brinkmann、Alan Ford、およびLars-Erik Jonssonの貢献、レビュー、フィードバックに感謝し、表記の読みやすさ、完全性、全体的な品質の大幅な改善につながったことに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to Stewart Sadler, Caroline Daniels, Alan Finney, and David Findlay for their reviews and comments. Thanks to Rob Hancock and Stephen McCann for their early work on the formal notation. The authors would also like to thank Christian Schmidt, Qian Zhang, Hongbin Liao, and Max Riegel for their comments and valuable input.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スチュワート・サドラー、キャロライン・ダニエルズ、アラン・フィニー、デビッド・フィンドレーのレビューとコメントに感謝します。ロブ・ハンコックとスティーブン・マッキャンが正式な表記法の初期の作業に感謝します。著者はまた、Christian Schmidt、Qian Zhang、Hongbin Liao、Max Riegelのコメントと貴重な意見に感謝したいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional thanks: this document was reviewed during working group last-call by committed reviewers Mark West, Carsten Bormann, and Joe Touch, as well as by Sally Floyd who provided a review at the request of the Transport Area Directors. Thanks also to Magnus Westerlund for his feedback in preparation for the IESG review.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加の感謝：このドキュメントは、ワーキンググループの最終コールで、コミットされたレビュアー、マークウェスト、カルステンボルマン、ジョータッチ、および交通エリアディレクターの要請でレビューを提供したサリーフロイドによってレビューされました。IESGレビューに備えてフィードバックをしてくれたMagnus Westerlundにも感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--References">
8. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1--Normative-References">
8.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[C90] ISO/IEC, &#34;ISO/IEC 9899:1990 Information technology -- Programming Language C&#34;, ISO 9899:1990, April 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">

        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2822] Resnick, P., Ed., &#34;STANDARD FOR THE FORMAT OF ARPA INTERNET TEXT MESSAGES&#34;, RFC 2822, April 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2822] Resnick、P.、ed。、「ARPAインターネットテキストメッセージの形式の標準」、RFC 2822、2001年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4234] Crocker, D., Ed. and P. Overell, &#34;Augmented BNF for Syntax Specifications: ABNF&#34;, RFC 4234, October 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4234] Crocker、D.、ed。およびP. Overell、「構文仕様のためのBNFの増強：ABNF」、RFC 4234、2005年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4995] Jonsson, L-E., Pelletier, G., and K. Sandlund, &#34;The RObust Header Compression (ROHC) Framework&#34;, RFC 4995, July 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4995] Jonsson、L-E。、Pelletier、G。、およびK. Sandlund、「The Robust Header Compression（ROHC）フレームワーク」、RFC 4995、2007年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2--Informative-References">
8.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3095] Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, &#34;RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed&#34;, RFC 3095, July 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3095] Bormann、C.、Burmeister、C.、Degermark、M.、Fukushima、H.、Hannu、H.、Jonsson、L-e。、Hakenberg、R.、Koren、T.、Le、K.、Liu、Liu、Z.、Martensson、A.、Miyazaki、A.、Svanbro、K.、Wiebke、T.、Yoshimura、T.、およびH. Zheng、 &#34;堅牢なヘッダー圧縮（ROHC）：フレームワークと4つのプロファイル：RTP、UDP、ESP、および非圧縮」、RFC 3095、2001年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC791] University of Southern California, &#34;DARPA INTERNET PROGRAM PROTOCOL SPECIFICATION&#34;, RFC 791, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC791]南カリフォルニア大学、「DARPAインターネットプログラムプロトコル仕様」、RFC 791、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--Formal-Syntax-of-ROHC-FN">
Appendix A. Formal Syntax of ROHC-FN
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A. ROHC-FNの正式な構文
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section gives a definition of the syntax of ROHC-FN in ABNF [RFC4234], using &#34;fnspec&#34; as the start rule.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、「FNSPEC」を開始ルールとして使用して、ABNF [RFC4234]のROHC-FNの構文の定義を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ; overall structure
   fnspec     = S *(constdef S) [globctl S] 1*(methdef S)
   constdef   = constname S &#34;=&#34; S expn S &#34;;&#34;
   globctl    = CONTROL S formbody
   methdef    = id S [parmlist S] &#34;{&#34; S 1*(formatdef S) &#34;}&#34;
              / id S [parmlist S] STRQ *STRCHAR STRQ S &#34;;&#34;
   parmlist   = &#34;(&#34; S id S *( &#34;,&#34; S id S ) &#34;)&#34;
   formatdef  = formhead S formbody
   formhead   = UNCOMPRESSED [ 1*WS id ]
              / COMPRESSED [ 1*WS id ]
              / CONTROL / INITIAL / DEFAULT
   formbody   = &#34;{&#34; S *((fielddef/enforcer) S) &#34;}&#34;
   fielddef   = fieldgroup S [&#34;=:=&#34; S encspec S] [lenspec S] &#34;;&#34;
   fieldgroup = fieldname *( S &#34;:&#34; S fieldname )
   fieldname  = id
   encspec    = &#34;&#39;&#34; *(&#34;0&#34;/&#34;1&#34;) &#34;&#39;&#34;
              / id [ S &#34;(&#34; S expn S *( &#34;,&#34; S expn S ) &#34;)&#34;]
   lenspec    = &#34;[&#34; S expn S *(&#34;,&#34; S expn S) &#34;]&#34;
   enforcer   = ENFORCE S &#34;(&#34; S expn S &#34;)&#34; S &#34;;&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ; expressions
   expn  = *(expnb S &#34;||&#34; S) expnb
   expnb = *(expna S &#34;&amp;&amp;&#34; S) expna
   expna = *(expn7 S (&#34;==&#34;/&#34;!=&#34;) S) expn7
   expn7 = *(expn6 S (&#34;&lt;&#34;/&#34;&lt;=&#34;/&#34;&gt;&#34;/&#34;&gt;=&#34;) S) expn6
   expn6 = *(expn4 S (&#34;+&#34;/&#34;-&#34;) S) expn4
   expn4 = *(expn3 S (&#34;*&#34;/&#34;/&#34;/&#34;%&#34;) S) expn3
   expn3 = expn2 [S &#34;^&#34; S expn3]
   expn2 = [&#34;!&#34; S] expn1
   expn1 = expn0 / attref / constname / litval / id
   expn0 = &#34;(&#34; S expn S &#34;)&#34; / VARIABLE
   attref       = fieldnameref &#34;.&#34; attname
   fieldnameref = fieldname / THIS
   attname      = ( U / C ) ( LENGTH / VALUE )
   litval       = [&#34;-&#34;] &#34;0b&#34; 1*(&#34;0&#34;/&#34;1&#34;)
                / [&#34;-&#34;] &#34;0x&#34; 1*(DIGIT/&#34;a&#34;/&#34;b&#34;/&#34;c&#34;/&#34;d&#34;/&#34;e&#34;/&#34;f&#34;)
                / [&#34;-&#34;] 1*DIGIT
                / false / true
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ; lexical categories
   constname = UPCASE *(UPCASE / DIGIT / &#34;_&#34;)
   id        = ALPHA *(ALPHA / DIGIT / &#34;_&#34;)
   ALPHA     = %x41-5A / %x61-7A
   UPCASE    = %x41-5A
   DIGIT     = %x30-39
   COMMENT   = &#34;//&#34; *(SP / HTAB / VCHAR) CRLF
   SP        = %x20
   HTAB      = %x09
   VCHAR     = %x21-7E
   CRLF      = %x0A / %x0D.0A
   NL        = COMMENT / CRLF
   WS        = SP / HTAB / NL
   S         = *WS
   STRCHAR   = SP / HTAB / %x21 / %x23-7E
   STRQ      = %x22
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ; case-sensitive literals
   C            = %d67
   COMPRESSED   = %d67.79.77.80.82.69.83.83.69.68
   CONTROL      = %d67.79.78.84.82.79.76
   DEFAULT      = %d68.69.70.65.85.76.84
   ENFORCE      = %d69.78.70.79.82.67.69
   INITIAL      = %d73.78.73.84.73.65.76
   LENGTH       = %d76.69.78.71.84.72
   THIS         = %d84.72.73.83
   U            = %d85
   UNCOMPRESSED = %d85.78.67.79.77.80.82.69.83.83.69.68
   VALUE        = %d86.65.76.85.69
   VARIABLE     = %d86.65.82.73.65.66.76.69
   false        = %d102.97.108.115.101
   true         = %d116.114.117.101
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-B--Bit-level-Worked-Example">
Appendix B. Bit-level Worked Example
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録B. ビットレベルの作業例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section gives a worked example at the bit level, showing how a simple ROHC-FN specification describes the compression of real data from an imaginary protocol header. The example used has been kept fairly simple, whilst still aiming to illustrate some of the intricacies that arise in use of the notation. In particular, fields have been kept short to make it possible to read the binary representation of the headers without too much difficulty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、ビットレベルでの実用的な例を示し、単純なROHC-FN仕様が、虚数プロトコルヘッダーからの実際のデータの圧縮をどのように記述しているかを示しています。使用された例はかなり単純に保たれていますが、表記法の使用で生じる複雑さのいくつかを説明することを目指しています。特に、フィールドは、あまり困難なく、ヘッダーのバイナリ表現を読むことができるようにするために不足しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-1--Example-Packet-Format">
B.1. Example Packet Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.1. パケット形式の例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Our imaginary header is just 16 bits long, and consists of the following fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちの想像上のヘッダーは長さがわずか16ビットで、次のフィールドで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. version number -- 2 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. バージョン番号-2ビット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. type -- 2 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. タイプ-2ビット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. flow id -- 4 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. フローID -4ビット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. sequence number -- 4 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. シーケンス番号-4ビット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. flag bits -- 4 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. フラグビット-4ビット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So for example 0101000100010000 indicates a header with a version number of one, a type of one, a flow id of one, a sequence number of one, and all flag bits set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、たとえば、0101000100010000は、バージョン番号のヘッダー、1つのタイプ、1つのフローID、1つのシーケンス番号、およびすべてのフラグビットがゼロに設定されたヘッダーを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here is an ASCII box notation diagram of the imaginary header:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、想像上のヘッダーのASCIIボックス表記図です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |version| type  |    flow_id    |
   +---+---+---+---+---+---+---+---+
   |  sequence_no  |   flag_bits   |
   +---+---+---+---+---+---+---+---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-2--Initial-Encoding">
B.2. Initial Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.2. 初期エンコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An initial definition based solely on the above information is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の情報のみに基づいた初期定義は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     eg_header
     {
       UNCOMPRESSED {
         version_no   [ 2 ];
         type         [ 2 ];
         flow_id      [ 4 ];
         sequence_no  [ 4 ];
         flag_bits    [ 4 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED initial_definition {
         version_no  =:= irregular(2);
         type        =:= irregular(2);
         flow_id     =:= irregular(4);
         sequence_no =:= irregular(4);
         flag_bits   =:= irregular(4);
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This defines the format nicely, but doesn&#39;t actually offer any compression. If we use it to encode the above header, we get:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは形式をうまく定義しますが、実際には圧縮は提供されません。上記のヘッダーをエンコードするためにそれを使用すると、次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Uncompressed header: 0101000100010000 Compressed header: 0101000100010000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
非圧縮ヘッダー：0101000100010000圧縮ヘッダー：0101000100010000
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is because we have stated that all fields are &#34;irregular&#34; -- i.e., we haven&#39;t specified anything about their behaviour.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、すべてのフィールドが「不規則」であると述べたためです。つまり、それらの行動について何も指定していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that since we have only one compressed format and one uncompressed format, it makes no difference whether the encoding methods for each field are specified in the compressed or uncompressed format. It would make no difference at all if we wrote the following instead:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮形式は1つだけで、1つの非圧縮形式のみであるため、各フィールドのエンコードメソッドが圧縮形式または非圧縮形式で指定されているかどうかは違いはありません。代わりに以下を書いた場合、それはまったく違いを生みません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     eg_header
     {
       UNCOMPRESSED {
         version_no  =:= irregular(2);
         type        =:= irregular(2);
         flow_id     =:= irregular(4);
         sequence_no =:= irregular(4);
         flag_bits   =:= irregular(4);
       }
            COMPRESSED initial_definition {
         version_no   [ 2 ];
         type         [ 2 ];
         flow_id      [ 4 ];
         sequence_no  [ 4 ];
         flag_bits    [ 4 ];
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-3--Basic-Compression">
B.3. Basic Compression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.3. 基本的な圧縮
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to achieve any compression we need to notate more knowledge about the header and its behaviour in a flow. For example, we may know the following facts about the header:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮を達成するには、ヘッダーとその流れにおけるその動作に関するより多くの知識を表明する必要があります。たとえば、ヘッダーに関する次の事実を知っているかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. version number -- indicates which version of the protocol this is: always one for this version of the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. バージョン番号 - これが次のプロトコルのバージョンを示します。このバージョンのプロトコル用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. type -- may take any value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. タイプ - 任意の価値を取ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. flow id -- may take any value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. フローID-任意の価値を取ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. sequence number -- make take any value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. シーケンス番号 - 任意の値を取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. flag bits -- contains three flags, a, b, and c, each of which may be set or clear, and a reserved flag bit, which is always clear (i.e., zero).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. フラグビット -  3つのフラグ、a、b、およびcが含まれています。それぞれが設定または明確になる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We could notate this knowledge as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この知識は次のように記録できました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     eg_header
     {
       UNCOMPRESSED {
         version_no     [ 2 ];
         type           [ 2 ];
         flow_id        [ 4 ];
         sequence_no    [ 4 ];
         abc_flag_bits  [ 3 ];
         reserved_flag  [ 1 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED basic {
         version_no    =:= uncompressed_value(2, 1)  [ 0 ];
         type          =:= irregular(2)              [ 2 ];
         flow_id       =:= irregular(4)              [ 4 ];
         sequence_no   =:= irregular(4)              [ 4 ];
         abc_flag_bits =:= irregular(3)              [ 3 ];
         reserved_flag =:= uncompressed_value(1, 0)  [ 0 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using this simple scheme, we have successfully encoded the fact that one of the fields has a permanently fixed value of one, and therefore contains no useful information. We have also encoded the fact that the final flag bit is always zero, which again contains no useful information. Both of these facts have been notated using the &#34;uncompressed_value&#34; encoding method (see Section 4.11.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この単純なスキームを使用して、フィールドの1つが永続的に固定された値を持っているため、有用な情報が含まれていないという事実を正常にエンコードしました。また、最終フラグビットが常にゼロであるという事実もエンコードしました。これには、有用な情報が含まれていません。これらの両方の事実は、「非圧縮_Value」エンコード方法を使用して記載されています（セクション4.11.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using this new encoding on the above header, we get:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のヘッダーでこの新しいエンコーディングを使用して、次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Uncompressed header: 0101000100010000 Compressed header: 0100010001000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
非圧縮ヘッダー：0101000100010000圧縮ヘッダー：0100010001000
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This reduces the amount of data we need to transmit by roughly 20%. However, this encoding fails to take advantage of relationships between values of a field in one packet and its value in subsequent packets. For example, every header in the following sequence is compressed by the same amount despite the similarities between them:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、送信する必要があるデータの量が約20％減少します。ただし、このエンコーディングは、1つのパケットのフィールドの値とその後のパケットでの値の間の関係を活用できません。たとえば、次のシーケンスのすべてのヘッダーは、それらの間の類似性にもかかわらず、同じ量で圧縮されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Uncompressed header: 0101000100010000 Compressed header: 0100010001000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
非圧縮ヘッダー：0101000100010000圧縮ヘッダー：0100010001000
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Uncompressed header: 0101000101000000 Compressed header: 0100010100000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
非圧縮ヘッダー：0101000101000000圧縮ヘッダー：0100010100000
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Uncompressed header: 0110000101110000 Compressed header: 1000010111000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
非圧縮ヘッダー：01100001011110000圧縮ヘッダー：1000010111000
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-4--Inter-Packet-Compression">
B.4. Inter-Packet Compression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.4. インターパケット圧縮
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The profile we have defined so far has not compressed the sequence number or flow ID fields at all, since they can take any value. However the value of each of these fields in one header has a very simple relationship to their values in previous headers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまでに定義したプロファイルは、あらゆる価値を取ることができるため、シーケンス番号またはフローIDフィールドをまったく圧縮していません。ただし、1つのヘッダーにあるこれらの各フィールドの値は、以前のヘッダーの値と非常に単純な関係を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the sequence number is unusual -- it increases by three each time,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o シーケンス番号は珍しいです - それは毎回3回増加します、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the flow_id stays the same -- it always has the same value that it did in the previous header in the flow,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Flow_idは同じままです - それは常にフローの前のヘッダーで行ったのと同じ値を持っています、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the abc_flag_bits stay the same most of the time -- they usually have the same value that they did in the previous header in the flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ABC_FLAG_BITSはほとんどの場合と同じままです。通常、フローの前のヘッダーで行った値と同じ値を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An obvious way of notating this is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これを注目する明白な方法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     // This obvious encoding will not work (correct encoding below)
     eg_header
     {
       UNCOMPRESSED {
         version_no     [ 2 ];
         type           [ 2 ];
         flow_id        [ 4 ];
         sequence_no    [ 4 ];
         abc_flag_bits  [ 3 ];
         reserved_flag  [ 1 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED obvious {
         version_no    =:= uncompressed_value(2, 1);
         type          =:= irregular(2);
         flow_id       =:= static;
         sequence_no   =:= lsb(0, -3);
         abc_flag_bits =:= irregular(3);
         reserved_flag =:= uncompressed_value(1, 0);
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The dependency on previous packets is notated using the &#34;static&#34; and &#34;lsb&#34; encoding methods (see Section 4.11.4 and Section 4.11.5 respectively). However there are a few problems with the above notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のパケットへの依存性は、「静的」および「LSB」エンコーディング方法を使用して記載されています（それぞれセクション4.11.4とセクション4.11.5を参照）。ただし、上記の表記にはいくつかの問題があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Firstly, and most importantly, the &#34;flow_id&#34; field is notated as &#34;static&#34;, which means that it doesn&#39;t change from packet to packet. However, the notation does not indicate how to communicate the value of the field initially. There is no point saying &#34;it&#39;s the same value as last time&#34; if there has not been a first time where we define what that value is, so that it can be referred back to. The above notation provides no way of communicating that. Similarly with the sequence number -- there needs to be a way of communicating its initial value. In fact, except for the explicit notation indicating their lengths, even the lengths of these two fields would be left undefined. This problem will be solved below, in Appendix B.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まず、そして最も重要なことに、「Flow_Id」フィールドは「静的」として記録されます。つまり、パケットからパケットに変更されません。ただし、表記は、最初にフィールドの価値を伝える方法を示していません。その値を参照できるように、その価値を定義する初めてのことがなかった場合、「前回と同じ値だ」と言う意味はありません。上記の表記は、それを伝える方法を提供しません。同様に、シーケンス番号と同様に、初期値を伝える方法が必要です。実際、長さを示す明示的な表記を除いて、これら2つのフィールドの長さでさえ未定義のままになります。この問題は、付録B.5で以下に解決されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Secondly, the sequence number field is communicated very efficiently in zero bits, but it is not at all robust against packet loss. If a packet is lost then there is no way to handle the missing sequence number. When communicating sequence numbers, or any other field encoded with &#34;lsb&#34; encoding, a very important consideration for the notator is how robust against packet loss the compressed protocol should be. This will vary a lot from protocol stack to protocol stack. For the example protocol we&#39;ll assume short, low overhead flows and say we need to be robust to the loss of just one packet, which we can achieve with two bits of &#34;lsb&#34; encoding (one bit isn&#39;t enough since the sequence number increases by three each time -- see Section 4.11.5). This will be addressed below in Appendix B.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二に、シーケンス番号フィールドはゼロビットで非常に効率的に通信されますが、パケット損失に対してまったく堅牢ではありません。パケットが失われた場合、欠落しているシーケンス番号を処理する方法はありません。シーケンス番号、または「LSB」エンコーディングでエンコードされたその他のフィールドを通信する場合、ノーテーターにとって非常に重要な考慮事項は、圧縮プロトコルがパケット損失に対してどれほど堅牢であるかです。これは、プロトコルスタックからプロトコルスタックまで大きく異なります。例のプロトコルでは、短くて低いオーバーヘッドフローを想定し、1つのパケットの損失に堅牢である必要があると言います。数は毎回3回増加します - セクション4.11.5を参照）。これは、付録B.5で以下に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, although the flag bits are usually the same as in the previous header in the flow, the profile doesn&#39;t make any use of this fact; since they are sometimes not the same as those in the previous header, it is not safe to say that they are always the same, so &#34;static&#34; encoding can&#39;t be used exclusively. This problem will be solved later through the use of multiple formats in Appendix B.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、フラグビットは通常、フローの前のヘッダーと同じですが、プロファイルはこの事実を使用しません。彼らは前のヘッダーのものと同じではないことがあるため、それらが常に同じであると言うのは安全ではないので、「静的」エンコーディングは排他的に使用することはできません。この問題は、付録B.6の複数の形式を使用することにより、後で解決されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-5--Specifying-Initial-Values">
B.5. Specifying Initial Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.5. 初期値の指定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To communicate initial values for fields compressed with a context dependent encoding such as &#34;static&#34; or &#34;lsb&#34; we use an &#34;INITIAL&#34; field list. This can help with fields whose start value is fixed and known. For example, if we knew that at the start of the flow that &#34;flow_id&#34; would always be 1 and &#34;sequence_no&#34; would always be 0, we could notate that like this:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「静的」や「LSB」などのコンテキスト依存エンコードで圧縮されたフィールドの初期値を通信するには、「初期」フィールドリストを使用します。これは、開始値が固定され、既知のフィールドに役立ちます。たとえば、フローの開始時に「flow_id」が常に1であり、「Sequence_no」が常に0になることを知っていた場合、次のように記録できました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     // This encoding will not work either (correct encoding below)
     eg_header
     {
       UNCOMPRESSED {
         version_no     [ 2 ];
         type           [ 2 ];
         flow_id        [ 4 ];
         sequence_no    [ 4 ];
         abc_flag_bits  [ 3 ];
         reserved_flag  [ 1 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       INITIAL {
         // set initial values of fields before flow starts
         flow_id     =:= uncompressed_value(4, 1);
         sequence_no =:= uncompressed_value(4, 0);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED obvious {
         version_no    =:= uncompressed_value(2, 1);
         type          =:= irregular(2);
         flow_id       =:= static;
         sequence_no   =:= lsb(2, -3);
         abc_flag_bits =:= irregular(3);
         reserved_flag =:= uncompressed_value(1, 0);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, this use of &#34;INITIAL&#34; is no good since the initial values of both &#34;flow_id&#34; and &#34;sequence_no&#34; vary from flow to flow. &#34;INITIAL&#34; is only applicable where the initial value of a field is fixed, as is often the case with control fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、この「初期」の使用は、「Flow_ID」と「Sequence_No」の両方の初期値がフローによって異なるため、良くありません。「初期」は、フィールドの初期値が固定されている場合にのみ適用されます。これは、制御フィールドの場合の場合と同様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-6--Multiple-Packet-Formats">
B.6. Multiple Packet Formats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.6. 複数のパケット形式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To communicate initial values for the sequence number and flow ID fields correctly, and to take advantage of the fact that the flag bits are usually the same as in the previous header, we need to depart from the single format encoding we are currently using and instead use multiple formats. Here, we have expressed the encodings for two of the fields in the uncompressed format, since they will always be true for uncompressed headers of that format. The remaining fields, whose encoding method may depend on exactly how the header is being compressed, have their encodings specified in the compressed formats.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス番号とフローIDフィールドの初期値を正しく通信し、フラグビットが通常前のヘッダーと同じであるという事実を利用するには、現在使用している単一形式のエンコードから出発する必要があります。複数の形式を使用します。ここでは、その形式の非圧縮ヘッダーに常に当てはまるため、2つのフィールドのエンコーディングを非圧縮形式で表現しました。エンコード方法がヘッダーの圧縮方法に正確に依存する可能性のある残りのフィールドは、エンコードを圧縮形式で指定していることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     eg_header
     {
       UNCOMPRESSED {
         version_no    =:= uncompressed_value(2, 1) [ 2 ];
         type                                       [ 2 ];
         flow_id                                    [ 4 ];
         sequence_no                                [ 4 ];
         abc_flag_bits                              [ 3 ];
         reserved_flag =:= uncompressed_value(1, 0) [ 1 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED irregular_format {
         discriminator =:= &#39;0&#39;          [ 1 ];
         version_no                     [ 0 ];
         type          =:= irregular(2) [ 2 ];
         flow_id       =:= irregular(4) [ 4 ];
         sequence_no   =:= irregular(4) [ 4 ];
         abc_flag_bits =:= irregular(3) [ 3 ];
         reserved_flag                  [ 0 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED compressed_format {
         discriminator =:= &#39;1&#39;          [ 1 ];
         version_no                     [ 0 ];
         type          =:= irregular(2) [ 2 ];
         flow_id       =:= static       [ 0 ];
         sequence_no   =:= lsb(2, -3)   [ 2 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         abc_flag_bits =:= static       [ 0 ];
         reserved_flag                  [ 0 ];
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that we have added a discriminator field, so that the decompressor can tell which format has been used by the compressor. The format with a &#34;static&#34; flow ID and &#34;lsb&#34; encoded sequence number is now 5 bits long. Note that despite having to add the discriminator field, this format is still the same size as the original incorrect &#34;obvious&#34; format because it takes advantage of the fact that the abc flag bits rarely change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
差別装置がコンプレッサーで使用されている形式を分解器に知ることができるように、識別子フィールドを追加したことに注意してください。「静的」フローIDと「LSB」エンコードされたシーケンス番号を備えた形式は、長さ5ビットになりました。識別子フィールドを追加する必要があるにもかかわらず、この形式は、ABCフラグビットがめったに変化しないという事実を利用するため、元の誤った「明白な」形式と同じサイズであることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, the original &#34;basic&#34; format has also grown by one bit due to the addition of the discriminator (&#34;irregular_format&#34;). An important consideration when creating multiple formats is whether each format occurs frequently enough that the average compressed header length is shorter as a result of its usage. For example, if in fact the flag bits always changed between packets, the &#34;compressed_format&#34; encoding could never be used; all we would have achieved is lengthening the &#34;basic&#34; format by one bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、元の「基本的な」形式も、識別子（「不規則な_FORMAT」）の追加により、少し増加しています。複数の形式を作成する際の重要な考慮事項は、各形式が使用された結果として平均圧縮ヘッダー長が短くなるほど頻繁に発生するかどうかです。たとえば、実際にフラグビットが常にパケット間で変更された場合、「Compressed_Format」エンコードを使用することはできません。私たちが達成したのは、「基本」形式を1ビット延長することだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using the above notation, we now get:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の表記法を使用して、次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Uncompressed header: 0101000100010000 Compressed header: 00100010001000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
非圧縮ヘッダー：0101000100010000圧縮ヘッダー：00100010001000
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Uncompressed header: 0101000101000000 Compressed header: 10100 ; 00100010100000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
非圧縮ヘッダー：0101000101000000圧縮ヘッダー：10100;00100010100000
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Uncompressed header: 0110000101110000 Compressed header: 11011 ; 01000010111000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
非圧縮ヘッダー：01100001011110000圧縮ヘッダー：11011;01000010111000
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first header in the stream is compressed the same way as before, except that it now has the extra 1-bit discriminator at the start (0). When a second header arrives with the same flow ID as the first and its sequence number three higher, it can be compressed in two possible ways: either by using &#34;compressed_format&#34; or, in the same way as previously, by using &#34;irregular_format&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリーム内の最初のヘッダーは、以前と同じように圧縮されますが、開始時に追加の1ビットの識別子があることを除いて、現在と同じように圧縮されます。2番目のヘッダーが最初のフローIDと同じフローIDで到着すると、2つの可能な方法で圧縮できます。「Compressed_Format」を使用するか、以前と同じ方法で「不規則な_FORMAT」を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that we show all theoretically possible encodings of a header as defined by the ROHC-FN specification, separated by semi-colons. Either of the above encodings for each header could be produced by a valid implementation, although a good implementation would always aim to pick the encoding that leads to the best compression. A good implementation would also take robustness into account and therefore probably wouldn&#39;t assume on the second packet that the decompressor had available the context necessary to decompress the shorter &#34;compressed_format&#34; form.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Semi-Colonsで区切られたROHC-FN仕様で定義されているヘッダーの理論的に可能なすべてのエンコーディングを示していることに注意してください。各ヘッダーの上記のエンコーディングのいずれかは、有効な実装によって生成される可能性がありますが、適切な実装は常に最高の圧縮につながるエンコードを選択することを目的としています。また、優れた実装では堅牢性を考慮しているため、2番目のパケットでは、短い「Compressed_format」フォームを解凍するために必要なコンテキストが利用可能であることを2番目のパケットで想定しないでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, note that the fields whose encoding methods are specified in the uncompressed format have zero length when compressed. This means their position in the compressed format is not significant. In this case, there is no need to notate them when defining the compressed formats. In the next part of the example we will see that they have been removed from the compressed formats altogether.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、非圧縮形式でエンコードメソッドが指定されているフィールドは、圧縮時にゼロの長さであることに注意してください。これは、圧縮形式での位置が重要ではないことを意味します。この場合、圧縮形式を定義するときにそれらを表記する必要はありません。この例の次の部分では、圧縮形式から完全に削除されたことがわかります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-7--Variable-Length-Discriminators">
B.7. Variable Length Discriminators
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.7. 可変長さの識別器
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suppose we do some analysis on flows of our example protocol and discover that whilst it is usual for successive packets to have the same flags, on the occasions when they don&#39;t, the packet is almost always a &#34;flags set&#34; packet in which all three of the abc flags are set. To encode the flow more efficiently a format needs to be written to reflect this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例のプロトコルのフローについていくつかの分析を行い、連続したパケットが同じフラグを持つのが普通である一方で、そうでない場合に、パケットはほとんど常に「フラグセット」パケットであることを発見します。ABCフラグの3つが設定されています。フローをより効率的にエンコードするには、これを反映するためにフォーマットを書き込む必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This now gives a total of three formats, which means we need three discriminators to differentiate between them. The obvious solution here is to increase the number of bits in the discriminator from one to two and use discriminators 00, 01, and 10 for example. However we can do slightly better than this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、合計3つの形式が提供されます。つまり、それらを区別するために3つの判別器が必要です。ここでの明らかな解決策は、判別器のビット数を1から2に増やし、たとえば判別器00、01、および10を使用することです。ただし、これよりも少しうまくできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any uniquely identifiable discriminator will suffice, so we can use 00, 01, and 1. If the discriminator starts with 1, that&#39;s the whole thing. If it starts with 0, the decompressor knows it has to check one more bit to determine the kind of format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一意に識別可能な識別器は十分であるため、00、01、および1を使用できます。差別器が1から始まる場合、それは全体です。0から始まる場合、減圧器は、形式の種類を決定するためにもう1つビットをチェックする必要があることを知っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that care must be taken when using variable length discriminators. For example, it would be erroneous to use 0, 01, and 10 as discriminators since after reading an initial 0, the decompressor would have no way of knowing if the next bit was a second bit of discriminator, or the first bit of the next field in the format. However, 0, 10, and 11 would be correct, as the first bit again indicates whether or not there are further discriminator bits to follow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可変長さの判別器を使用する場合は、注意を払う必要があることに注意してください。たとえば、最初の0を読んだ後、分解器は次のビットが2番目の識別因子であるか、次のビットの最初のビットであるかを知る方法がないため、0、01、および10を判別器として使用することは誤りです。フォーマットのフィールド。ただし、最初のビットは、さらに識別子ビットがあるかどうかを再び示しているため、0、10、および11が正しいでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This gives us the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、次のことがわかります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     eg_header
     {
       UNCOMPRESSED {
         version_no    =:= uncompressed_value(2, 1) [ 2 ];
         type                                       [ 2 ];
         flow_id                                    [ 4 ];
         sequence_no                                [ 4 ];
         abc_flag_bits                              [ 3 ];
         reserved_flag =:= uncompressed_value(1, 0) [ 1 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED irregular_format {
         discriminator =:= &#39;00&#39;         [ 2 ];
         type          =:= irregular(2) [ 2 ];
         flow_id       =:= irregular(4) [ 4 ];
         sequence_no   =:= irregular(4) [ 4 ];
         abc_flag_bits =:= irregular(3) [ 3 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED flags_set {
         discriminator =:= &#39;01&#39;                     [ 2 ];
         type          =:= irregular(2)             [ 2 ];
         flow_id       =:= static                   [ 0 ];
         sequence_no   =:= lsb(2, -3)               [ 2 ];
         abc_flag_bits =:= uncompressed_value(3, 7) [ 0 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED flags_static {
         discriminator =:= &#39;1&#39;          [ 1 ];
         type          =:= irregular(2) [ 2 ];
         flow_id       =:= static       [ 0 ];
         sequence_no   =:= lsb(2, -3)   [ 2 ];
         abc_flag_bits =:= static       [ 0 ];
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here is some example output:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これが出力の例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Uncompressed header: 0101000100010000 Compressed header: 000100010001000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
非圧縮ヘッダー：0101000100010000圧縮ヘッダー：000100010001000
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Uncompressed header: 0101000101000000
     Compressed header:   10100 ; 000100010100000
          Uncompressed header: 0110000101110000
     Compressed header:   11011 ; 001000010111000
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Uncompressed header: 0111000110101110 Compressed header: 011110 ; 001100011010111
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
非圧縮ヘッダー：0111000110101110圧縮ヘッダー：011110;001100011010111
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here we have a very similar sequence to last time, except that there is now an extra message on the end that has the flag bits set. The encoding for the first message in the stream is now one bit larger, the encoding for the next two messages is the same as before, since that format has not grown; thanks to the use of variable length discriminators. Finally, the packet that comes through with all the flag bits set can be encoded in just six bits, only one bit more than the most common format. Without the extra format, this last packet would have to be encoded using the longest format and would have taken up 14 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでは、前回と非常によく似たシーケンスがありますが、フラグビットが設定されている追加のメッセージが最後に表示されるようになりました。ストリーム内の最初のメッセージのエンコードは1つ少し大きくなり、次の2つのメッセージのエンコードは、その形式が成長していないため、以前と同じです。可変長さの判別器の使用のおかげです。最後に、すべてのフラグビットセットで届くパケットは、わずか6ビットでエンコードできます。これは、最も一般的な形式よりも1つだけです。追加の形式がなければ、この最後のパケットは最長の形式を使用してエンコードする必要があり、14ビットを取り上げていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-8--Default-Encoding">
B.8. Default Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.8. デフォルトのエンコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some of the common encoding methods used so far have been &#34;factored out&#34; into the definition of the uncompressed format, meaning that they don&#39;t need to be defined for every compressed format. However, there is still some redundancy in the notation. For a number of fields, the same encoding method is used several times in different formats (though not necessarily in all of them), but the field encoding is redefined explicitly each time. If the encoding for any of these fields changed in the future, then every format that uses that encoding would have to be modified to reflect this change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまでに使用されていた一般的なエンコードメソッドのいくつかは、非圧縮形式の定義に「因数分解」されています。つまり、圧縮形式ごとに定義する必要はありません。ただし、表記にはまだいくつかの冗長性があります。多くのフィールドでは、同じエンコード方法が異なる形式で数回使用されます（必ずしもすべてではありませんが）が、フィールドエンコーディングは毎回明示的に再定義されます。これらのフィールドのいずれかのエンコードが将来変更された場合、そのエンコードを使用するすべての形式を変更するために変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This problem can be avoided by specifying default encoding methods for these fields. Doing so can also lead to a more concisely notated profile:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この問題は、これらのフィールドのデフォルトのエンコードメソッドを指定することで回避できます。そうすることは、より簡潔に記載されたプロファイルにもつながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     eg_header
     {
       UNCOMPRESSED {
         version_no    =:= uncompressed_value(2, 1) [ 2 ];
         type                                       [ 2 ];
         flow_id                                    [ 4 ];
         sequence_no                                [ 4 ];
         abc_flag_bits                              [ 3 ];
         reserved_flag =:= uncompressed_value(1, 0) [ 1 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       DEFAULT {
         type          =:= irregular(2);
         flow_id       =:= static;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         sequence_no   =:= lsb(2, -3);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED irregular_format {
         discriminator =:= &#39;00&#39;         [ 2 ];
         type                           [ 2 ]; // Uses default
         flow_id       =:= irregular(4) [ 4 ]; // Overrides default
         sequence_no   =:= irregular(4) [ 4 ]; // Overrides default
         abc_flag_bits =:= irregular(3) [ 3 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED flags_set {
         discriminator =:= &#39;01&#39; [ 2 ];
         type                   [ 2 ]; // Uses default
         sequence_no            [ 2 ]; // Uses default
         abc_flag_bits =:= uncompressed_value(3, 7);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED flags_static {
         discriminator =:= &#39;1&#39; [ 1 ];
         type                  [ 2 ]; // Uses default
         sequence_no           [ 2 ]; // Uses default
         abc_flag_bits =:= static;
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above profile behaves in exactly the same way as the one notated previously, since it has the same meaning. Note that the purpose behind the different formats becomes clearer with the default encoding methods factored out: all that remains are the encodings that are specific to each format. Note also that default encoding methods that compress down to zero bits have become completely implicit. For example the compressed formats using the default encoding for &#34;flow_id&#34; don&#39;t mention it (the default is &#34;static&#34; encoding that compresses to zero bits).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のプロファイルは、同じ意味を持っているため、前述したものとまったく同じように動作します。異なる形式の背後にある目的は、デフォルトのエンコードメソッドが考慮されていることでより明確になることに注意してください。残っているのは、各形式に固有のエンコーディングだけです。また、ゼロビットに圧縮するデフォルトのエンコードメソッドが完全に暗黙的になっていることに注意してください。たとえば、「flow_id」のデフォルトエンコードを使用した圧縮形式は、それを言及していません（デフォルトはゼロビットに圧縮する「静的」エンコードです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-9--Control-Fields">
B.9. Control Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.9. 制御フィールド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One inefficiency in the compression scheme we have produced thus far is that it uses two bits to provide the &#34;lsb&#34; encoded sequence number with robustness for the loss of just one packet. In theory, only one bit should be needed. The root of the problem is the unusual sequence number that the protocol uses -- it counts up in increments of three. In order to encode it at maximum efficiency we need to translate this into a field that increments by one each time. We do this using a control field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまでに生成された圧縮スキームの1つの非効率性は、2つのビットを使用して「LSB」エンコードされたシーケンス番号を1つのパケットを失うために堅牢性を提供することです。理論的には、1ビットだけが必要です。問題のルートは、プロトコルが使用する珍しいシーケンス番号です。3つの増分でカウントされます。最大効率でエンコードするには、これを毎回1つずつ増分するフィールドに変換する必要があります。これを制御フィールドを使用して行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A control field is extra data that is communicated in the compressed format, but which is not a direct encoding of part of the uncompressed header. Control fields can be used to communicate extra information in the compressed format, that allows other fields to be compressed more efficiently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御フィールドは、圧縮形式で伝達される追加のデータですが、非圧縮ヘッダーの一部の直接エンコードではありません。制御フィールドを使用して、圧縮形式で追加の情報を通知することができ、他のフィールドをより効率的に圧縮できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The control field that we introduce scales the sequence number down by a factor of three. Instead of encoding the original sequence number in the compressed packet, we encode the scaled sequence number, allowing us to have robustness to the loss of one packet by using just one bit of &#34;lsb&#34; encoding:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
導入するコントロールフィールドは、シーケンス数を3倍に縮小します。圧縮パケットで元のシーケンス番号をエンコードする代わりに、スケーリングされたシーケンス番号をエンコードして、1つの「LSB」エンコードを使用して1つのパケットの損失に堅牢性を持つことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     eg_header
     {
       UNCOMPRESSED {
         version_no    =:= uncompressed_value(2, 1) [ 2 ];
         type                                       [ 2 ];
         flow_id                                    [ 4 ];
         sequence_no                                [ 4 ];
         abc_flag_bits                              [ 3 ];
         reserved_flag =:= uncompressed_value(1, 0) [ 1 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       CONTROL {
         // need modulo maths to calculate scaling correctly,
         // due to 4 bit wrap around
         scaled_seq_no   [ 4 ];
         ENFORCE(sequence_no.UVALUE
                   == (scaled_seq_no.UVALUE * 3) % 16);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       DEFAULT {
         type          =:= irregular(2);
         flow_id       =:= static;
         scaled_seq_no =:= lsb(1, -1);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED irregular_format {
         discriminator =:= &#39;00&#39;         [ 2 ];
         type                           [ 2 ];
         flow_id       =:= irregular(4) [ 4 ];
         scaled_seq_no =:= irregular(4) [ 4 ]; // Overrides default
         abc_flag_bits =:= irregular(3) [ 3 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED flags_set {
         discriminator =:= &#39;01&#39; [ 2 ];
         type                   [ 2 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         scaled_seq_no          [ 1 ]; // Uses default
         abc_flag_bits =:= uncompressed_value(3, 7);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED flags_static {
         discriminator =:= &#39;1&#39; [ 1 ];
         type                  [ 2 ];
         scaled_seq_no         [ 1 ]; // Uses default
         abc_flag_bits =:= static;
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Normally, the encoding method(s) used to encode a field specifies the length of the field. In the above notation, since there is no encoding method using &#34;sequence_no&#34; directly, its length needs to be defined explicitly using an &#34;ENFORCE&#34; statement. This is done using the abbreviated syntax, both for consistency and also for ease of readability. Note that this is unusual: whereas the majority of field length indications are redundant (and thus optional), this one isn&#39;t. If it was removed from the above notation, the length of the &#34;sequence_no&#34; field would be undefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、フィールドのエンコードに使用されるエンコーディング方法は、フィールドの長さを指定します。上記の表記では、「sequence_no」を直接使用するエンコードメソッドがないため、その長さは「施行」ステートメントを使用して明示的に定義する必要があります。これは、一貫性と読みやすさを容易にするために、短縮構文を使用して行われます。これは珍しいことであることに注意してください。フィールドの長さの適応症の大部分は冗長（したがってオプション）であるのに対し、これはそうではありません。上記の表記から削除された場合、「sequence_no」フィールドの長さは未定義になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here is some example output:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これが出力の例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Uncompressed header: 0101000100010000 Compressed header: 000100011011000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">

        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Uncompressed header: 0101000101000000 Compressed header: 1010 ; 000100011100000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
非圧縮ヘッダー：0101000101000000圧縮ヘッダー：1010;000100011100000
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Uncompressed header: 0110000101110000 Compressed header: 1101 ; 001000011101000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
非圧縮ヘッダー：01100001011110000圧縮ヘッダー：1101;001000011101000
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Uncompressed header: 0111000110101110 Compressed header: 01110 ; 001100011110111
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
非圧縮ヘッダー：0111000110101110圧縮ヘッダー：01110;001100011110111
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this form, we see that this gives us a saving of a further bit in most packets. Assuming the bulk of a flow is made up of &#34;flags_static&#34; headers, the mean size of the headers in a compressed flow is now just over a quarter of their size in an uncompressed flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この形式では、これにより、ほとんどのパケットでさらに節約できることがわかります。フローの大部分が「flags_static」ヘッダーで構成されていると仮定すると、圧縮フローのヘッダーの平均サイズは、圧縮されていないフローのサイズの4分の1をわずかに超えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-10--Use-of-ENFORCE-Statements-as-Conditionals">
B.10. Use of &#34;ENFORCE&#34; Statements as Conditionals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.10. 条件としての「施行」ステートメントの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Earlier, we created a new format &#34;flags_set&#34; to handle packets with all three of the flag bits set. As it happens, these three flags are always all set for &#34;type 3&#34; packets, and are never all set for other packet types (a &#34;type 3&#34; packet is one where the type field is set to three).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前には、3つのフラグビットセットすべてでパケットを処理するための新しいフォーマット「flags_set」を作成しました。たまたま、これらの3つのフラグはすべて「タイプ3」パケットに設定されており、他のパケットタイプにすべて設定されることはありません（「タイプ3」パケットは、タイプフィールドが3に設定されているものです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This allows extra efficiency in encoding such packets. We know the type is three, so we don&#39;t need to encode the type field in the compressed header. The type field was previously encoded as &#34;irregular(2)&#34;, which is two bits long. Removing this reduces the size of the &#34;flags_set&#34; format from five bits to three, making it the smallest format in the encoding method definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、このようなパケットをエンコードするのが効率が高くなります。このタイプが3であることがわかっているため、圧縮ヘッダーのタイプフィールドをエンコードする必要はありません。タイプフィールドは、以前は「不規則（2）」としてエンコードされていました。これは2ビットの長さです。これを削除すると、「flags_set」形式のサイズが5ビットから3つに縮小され、エンコードメソッド定義の最小形式になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to notate that the &#34;flags_set&#34; format should only be used for &#34;type 3&#34; headers, and the &#34;flags_static&#34; format only when the type isn&#39;t three, it is necessary to state these conditions inside each format. This can be done with an &#34;ENFORCE&#34; statement:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「flags_set」形式は「タイプ3」ヘッダーにのみ使用する必要があること、および「flags_static」形式はタイプが3でない場合にのみ使用する必要があることを記録するには、各形式内にこれらの条件を述べる必要があります。これは、「強制」ステートメントで実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     eg_header
     {
       UNCOMPRESSED {
         version_no    =:= uncompressed_value(2, 1) [ 2 ];
         type                                       [ 2 ];
         flow_id                                    [ 4 ];
         sequence_no                                [ 4 ];
         abc_flag_bits                              [ 3 ];
         reserved_flag =:= uncompressed_value(1, 0) [ 1 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       CONTROL {
         // need modulo maths to calculate scaling correctly,
         // due to 4 bit wrap around
         scaled_seq_no   [ 4 ];
         ENFORCE(sequence_no.UVALUE
                   == (scaled_seq_no.UVALUE * 3) % 16);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       DEFAULT {
         type          =:= irregular(2);
         scaled_seq_no =:= lsb(1, -1);
         flow_id       =:= static;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED irregular_format {
         discriminator =:= &#39;00&#39;         [ 2 ];
         type                           [ 2 ];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         flow_id       =:= irregular(4) [ 4 ];
         scaled_seq_no =:= irregular(4) [ 4 ];
         abc_flag_bits =:= irregular(3) [ 3 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED flags_set {
         ENFORCE(type.UVALUE == 3); // redundant condition
         discriminator =:= &#39;01&#39;                      [ 2 ];
         type          =:= uncompressed_value(2, 3)  [ 0 ];
         scaled_seq_no                               [ 1 ];
         abc_flag_bits =:= uncompressed_value(3, 7)  [ 0 ];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       COMPRESSED flags_static {
         ENFORCE(type.UVALUE != 3);
         discriminator =:= &#39;1&#39;    [ 1 ];
         type                     [ 2 ];
         scaled_seq_no            [ 1 ];
         abc_flag_bits =:= static [ 0 ];
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two &#34;ENFORCE&#34; statements in the last two formats act as &#34;guards&#34;. Guards prevent formats from being used under the wrong circumstances. In fact, the &#34;ENFORCE&#34; statement in &#34;flags_set&#34; is redundant. The condition it guards for is already enforced by the new encoding method used for the &#34;type&#34; field. The encoding method &#34;uncompressed_value(2,3)&#34; binds the &#34;UVALUE&#34; attribute to three. This is exactly what the &#34;ENFORCE&#34; statement does, so it can be removed without any change in meaning. The &#34;uncompressed_value&#34; encoding method on the other hand is not redundant. It specifies other bindings on the type field in addition to the one that the &#34;ENFORCE&#34; statement specifies. Therefore it would not be possible to remove the encoding method and leave just the &#34;ENFORCE&#34; statement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の2つの形式の2つの「施行」ステートメントは、「ガード」として機能します。警備員は、間違った状況下でフォーマットが使用されないようにします。実際、「flags_set」の「執行」ステートメントは冗長です。それが訴える条件は、「タイプ」フィールドに使用される新しいエンコード方法によってすでに施行されています。エンコードメソッド「非圧縮_Value（2,3）」は、「uvalue」属性を3に結合します。これはまさに「執行」ステートメントが行うことであるため、意味を変えることなく削除できます。一方、「非圧縮_Value」エンコードメソッドは冗長ではありません。「執行」ステートメントが指定しているものに加えて、タイプフィールドの他のバインディングを指定します。したがって、エンコードメソッドを削除して、「施行」ステートメントのみを残すことはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that a guard is solely preventative. A guard can never force a format to be chosen by the compressor. A format can only be guaranteed to be chosen in a given situation if there are no other formats that can be used instead. This is demonstrated in the example output below. The compressor can still choose the &#34;irregular&#34; format if it wishes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
警備員は単なる予防的であることに注意してください。警備員は、コンプレッサーによってフォーマットを強制することはできません。代わりに使用できる他の形式がない場合、形式は特定の状況で選択されることが保証されます。これは、以下の出力の例で示されています。コンプレッサーは、必要に応じて「不規則な」形式を選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Uncompressed header: 0101000100010000 Compressed header: 000100011011000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
非圧縮ヘッダー：0101000100010000圧縮ヘッダー：000100011011000
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Uncompressed header: 0101000101000000
     Compressed header:   1010 ; 000100011100000
          Uncompressed header: 0110000101110000
     Compressed header:   1101 ; 001000011101000
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Uncompressed header: 0111000110101110 Compressed header: 010 ; 001100011110111
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
非圧縮ヘッダー：0111000110101110圧縮ヘッダー：010;001100011110111
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This saves just two extra bits (a 7% saving) in the example flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、フローの例で2つの追加ビット（7％の節約）だけを節約できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Robert Finking Siemens/Roke Manor Research Old Salisbury Lane Romsey, Hampshire SO51 0ZN UK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロバートフィンキングシーメンス/ロークマナーリサーチオールドソールズベリーレーンロムシー、ハンプシャーSO51 0ZN UK
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +44 (0)1794 833189
   EMail: robert.finking@roke.co.uk
   URI:   http://www.roke.co.uk
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ghyslain Pelletier Ericsson Box 920 Lulea SE-971 28 Sweden
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ghyslain Pelletier Ericsson Box 920 Lulea SE-971 28スウェーデン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +46 (0) 8 404 29 43
   EMail: ghyslain.pelletier@ericsson.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The IETF Trust (2007).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（c）The IETF Trust（2007）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供され、貢献者、彼/彼女が代表する組織（もしあれば）、インターネット協会、IETFトラスト、インターネットエンジニアリングタスクフォースがすべてを否認します。明示的または黙示的な保証。ここでの情報の使用は、特定の目的に対する商品性または適合性の権利または暗黙の保証を侵害しないという保証を含むがこれらに限定されない。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知的財産
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、知的財産権またはその他の権利の有効性または範囲に関して、本書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスに基づくライセンスの範囲に関連すると主張される可能性のある他の権利に関しては、立場を取得しません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得するための試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要な技術をカバーする可能性のあるその他の独自の権利を注意深く招待するよう招待しています。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFCエディター機能の資金は現在、インターネット協会によって提供されています。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
