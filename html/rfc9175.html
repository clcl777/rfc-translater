<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 9175 - Constrained Application Protocol (CoAP): Echo, Request-Tag, and Token Processing 日本語訳</title>
  <meta name="description" content="RFC 9175 は、CoAP のセキュリティ問題を軽減するための拡張を定義しており、Echo オプションや Request-Tag オプションを導入している。この文書は、クライアントの Token 処理要件、非安全な Token の再利用禁止、および増幅緩和を更新し、セキュリティプロトコルと共に CoAP を使用する際の応答とリクエストのバインディングを確保している。">

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">9175</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc9175">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 9175 - Constrained Application Protocol (CoAP): Echo, Request-Tag, and Token Processing 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc9175">
            https://datatracker.ietf.org/doc/html/rfc9175
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 9175 - 制約付きアプリケーションプロトコル（COAP）：エコー、request-tag、およびトークン処理</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] RFC 9175 は、CoAP のセキュリティ問題を軽減するための拡張を定義しており、Echo オプションや Request-Tag オプションを導入している。この文書は、クライアントの Token 処理要件、非安全な Token の再利用禁止、および増幅緩和を更新し、セキュリティプロトコルと共に CoAP を使用する際の応答とリクエストのバインディングを確保している。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         C. Amsüss
Request for Comments: 9175
Updates: 7252                                          J. Preuß Mattsson
Category: Standards Track                                    G. Selander
ISSN: 2070-1721                                              Ericsson AB
                                                           February 2022
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Constrained Application Protocol (CoAP): Echo, Request-Tag, and Token Processing
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
制約付きアプリケーションプロトコル（COAP）：エコー、request-tag、およびトークン処理
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies enhancements to the Constrained Application Protocol (CoAP) that mitigate security issues in particular use cases. The Echo option enables a CoAP server to verify the freshness of a request or to force a client to demonstrate reachability at its claimed network address. The Request-Tag option allows the CoAP server to match block-wise message fragments belonging to the same request. This document updates RFC 7252 with respect to the following: processing requirements for client Tokens, forbidding non-secure reuse of Tokens to ensure response-to-request binding when CoAP is used with a security protocol, and amplification mitigation (where the use of the Echo option is now recommended).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、特に使用例のセキュリティの問題を軽減する制約付きアプリケーションプロトコル（CoAP）の機能強化を指定します。エコーオプションを使用すると、CoAPサーバーが要求の鮮度を検証したり、クライアントにクレームされたネットワークアドレスでの到達可能性を発揮させることができます。request-tagオプションを使用すると、CoAPサーバーは同じ要求に属するブロック単位のメッセージフラグメントを一致させることができます。このドキュメントは、次のことに関してRFC 7252を更新します。クライアントトークンの処理要件、クアップがセキュリティプロトコルと一緒に使用されているときの応答間のバインディング、および増幅緩和（の使用方法）エコーオプションが推奨されています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはインターネット規格のトラック文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書はインターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表します。それはパブリックレビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による出版の承認を受けました。インターネット規格に関する詳細情報は、RFC 7841のセクション2で利用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9175.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書の現在のステータス、任意のエラータ、およびフィードバックを提供する方法は、https://www.rfc-editor.org/info/rfc9175で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（c）2022 IETF信頼と文書の著者として識別された人。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、この文書の公開日に有効なIETF文書（https://trustee.ietf.org/License-Info）に関するBCP 78およびIETF信頼の法的規定の対象となります。この文書に関してあなたの権利と制限を説明するので、これらの文書をよくレビューしてください。この文書から抽出されたコードコンポーネントには、信託法定規定のセクション4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction
     1.1.  Terminology
   2.  Request Freshness and the Echo Option
     2.1.  Request Freshness
     2.2.  The Echo Option
       2.2.1.  Echo Option Format
     2.3.  Echo Processing
     2.4.  Applications of the Echo Option
     2.5.  Characterization of Echo Applications
       2.5.1.  Time-Based versus Event-Based Freshness
       2.5.2.  Authority over Used Information
       2.5.3.  Protection by a Security Protocol
     2.6.  Updated Amplification Mitigation Requirements for Servers
   3.  Protecting Message Bodies Using Request Tags
     3.1.  Fragmented Message Body Integrity
     3.2.  The Request-Tag Option
       3.2.1.  Request-Tag Option Format
     3.3.  Request-Tag Processing by Servers
     3.4.  Setting the Request-Tag
     3.5.  Applications of the Request-Tag Option
       3.5.1.  Body Integrity Based on Payload Integrity
       3.5.2.  Multiple Concurrent Block-Wise Operations
       3.5.3.  Simplified Block-Wise Handling for Constrained Proxies
     3.6.  Rationale for the Option Properties
     3.7.  Rationale for Introducing the Option
     3.8.  Block2 and ETag Processing
   4.  Token Processing for Secure Request-Response Binding
     4.1.  Request-Response Binding
     4.2.  Updated Token Processing Requirements for Clients
   5.  Security Considerations
     5.1.  Token Reuse
   6.  Privacy Considerations
   7.  IANA Considerations
   8.  References
     8.1.  Normative References
     8.2.  Informative References
   Appendix A.  Methods for Generating Echo Option Values
   Appendix B.  Request-Tag Message Size Impact
   Acknowledgements
   Authors&#39; Addresses
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial suite of specifications for the Constrained Application Protocol (CoAP) ([RFC7252], [RFC7641], and [RFC7959]) was designed with the assumption that security could be provided on a separate layer, in particular, by using DTLS [RFC6347]. However, for some use cases, additional functionality or extra processing is needed to support secure CoAP operations. This document specifies security enhancements to CoAP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制約付きアプリケーションプロトコル（COAAP）（[RFC7252]、[RFC7641]、[RFC7959]）の初期の仕様は、特にDTLSを使用することによってセキュリティを別の層に提供できると仮定して設計されました[RFC6347]]。ただし、ユースケースでは、安全なCOAP操作をサポートするために追加の機能または追加の処理が必要です。このドキュメントは、COAPのセキュリティ機能強化を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies two CoAP options, the Echo option and the Request-Tag option. The Echo option enables a CoAP server to verify the freshness of a request, which can be used to synchronize state, or to force a client to demonstrate reachability at its claimed network address. The Request-Tag option allows the CoAP server to match message fragments belonging to the same request, fragmented using the CoAP block-wise transfer mechanism, which mitigates attacks and enables concurrent block-wise operations. These options in themselves do not replace the need for a security protocol; they specify the format and processing of data that, when integrity protected using, e.g., DTLS [RFC6347], TLS [RFC8446], or Object Security for Constrained RESTful Environments (OSCORE) [RFC8613], provide the additional security features.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、ECHOオプションとrequest-tagオプションの2つのCOAPオプションを指定します。エコーオプションを使用すると、CoAPサーバーが要求の鮮度を検証できます。これは、状態を同期させるために使用することができ、またはクライアントにクレアされたネットワークアドレスで到達可能性を実証するように強制することができます。request-tagオプションを使用すると、COAASサーバーは、同じ要求に属するメッセージフラグメントを、攻撃を軽減し、並行ブロック単位の操作を可能にするCoAPブロックワイズ転送メカニズムを使用して断片化できます。これらのオプションは、セキュリティプロトコルの必要性を置き換えません。それらは、例えばDTLS [RFC6347]、TLS [RFC8446]、または[RESTFul環境のためのオブジェクトセキュリティ（OSCCORE）[RFC8613]を使用して保護されている場合、データのフォーマットと処理を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document updates [RFC7252] with a recommendation that servers use the Echo option to mitigate amplification attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、サーバーがECHOオプションを使用して増幅攻撃を軽減するという推奨事項で[RFC7252]を更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The document also updates the Token processing requirements for clients specified in [RFC7252]. The updated processing forbids non-secure reuse of Tokens to ensure binding of responses to requests when CoAP is used with security, thus mitigating error cases and attacks where the client may erroneously associate the wrong response to a request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、[RFC7252]で指定されたクライアントのトークン処理要件も更新されます。更新された処理は、COAPがセキュリティと共に使用されているときの要求に対する応答のバインディングを確実にするために、トークンの非安全な再利用、したがってエラーケースと攻撃を誤って要求に誤って関連付ける可能性がある攻撃を軽減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the following sections provides a more-detailed introduction to the topic at hand in its first subsection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の各セクションでは、最初のサブセクションで手元のトピックの詳細な紹介を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-1--Terminology">
1.1. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, および &#34;OPTIONAL&#34; はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Like [RFC7252], this document relies on the Representational State Transfer [REST] architecture of the Web.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7252]と同様に、この文書はWebの表現状態転送[REST]アーキテクチャに依存しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless otherwise specified, the terms &#34;client&#34; and &#34;server&#34; refer to &#34;CoAP client&#34; and &#34;CoAP server&#34;, respectively, as defined in [RFC7252].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に指定のない限り、「クライアント」および「サーバ」という用語は、[RFC7252]で定義されているように、それぞれ「CoAp Client」と「Coap Server」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A message&#39;s &#34;freshness&#34; is a measure of when a message was sent on a timescale of the recipient. A server that receives a request can either verify that the request is fresh or determine that it cannot be verified that the request is fresh. What is considered a fresh message is application dependent; exemplary uses are &#34;no more than 42 seconds ago&#34; or &#34;after this server&#39;s last reboot&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージの「鮮度」は、メッセージが受信者のタイムスケールで送信されたときの尺度です。要求を受け取るサーバーは、要求が新鮮であることを確認したり、要求が新鮮であることを確認できないことを確認できます。新たなメッセージと見なされるものはアプリケーションに依存しています。例示的な用途は、「42秒以上前」または「このサーバーの最後の再起動後」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The terms &#34;payload&#34; and &#34;body&#34; of a message are used as in [RFC7959]. The complete interchange of a request and a response body is called a (REST) &#34;operation&#34;. An operation fragmented using [RFC7959] is called a &#34;block-wise operation&#34;. A block-wise operation that is fragmenting the request body is called a &#34;block-wise request operation&#34;. A block-wise operation that is fragmenting the response body is called a &#34;block-wise response operation&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージの「ペイロード」と「ボディ」という用語は[RFC7959]のように使用されます。要求の完全な交換と応答本体は、（REST）「操作」と呼ばれます。[RFC7959]を使用して断片化された操作を「ブロック単位操作」と呼びます。要求本体を断片化しているブロック単位の操作を「ブロック単位の要求操作」と呼ぶ。応答本体を断片化しているブロック単位の動作を「ブロック単位の応答動作」と呼ぶ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two request messages are said to be &#34;matchable&#34; if they occur between the same endpoint pair, have the same code, and have the same set of options, with the exception that elective NoCacheKey options and options involved in block-wise transfer (Block1, Block2, and Request-Tag) need not be the same. Two blockwise request operations are said to be matchable if their request messages are matchable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つの要求メッセージは、同じエンドポイントペアの間に発生し、同じコードを持ち、同じオプションのセットを持ち、選択的なNoCacheKeyオプションとオプションがブロックワイズ転送に関与する例外を除いて、同じオプションのセットを持ちます（BLOCK1、block2、およびrequest-tag）は同じである必要はありません。2つのブロック単位の要求操作は、要求メッセージが互いに互いに整合的である場合に互いに一致すると言われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two matchable block-wise request operations are said to be &#34;concurrent&#34; if a block of the second request is exchanged even though the client still intends to exchange further blocks in the first operation. (Concurrent block-wise request operations from a single endpoint are impossible with the options of [RFC7959] -- see the last paragraphs of Sections 2.4 and 2.5 -- because the second operation&#39;s block overwrites any state of the first exchange.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1回目の要求のブロックが最初の操作でさらにブロックを交換することを依然として交換しても、2つ目の要求のブロックが交換されている場合、2つの整合可能なブロック単位の要求操作が「同時」であると言われます。（RFC7959のオプションでは、2.4および2.5の最後の段落を参照して、単一のエンドポイントからの並行ブロック単位の要求の要求は不可能です.Section 2.4と2.5の最後の段落は、最初の交換の様子を上書きします。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Echo and Request-Tag options are defined in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、echoとrequest-tagのオプションが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Request-Freshness-and-the-Echo-Option">
2. Request Freshness and the Echo Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 新鮮さとエコーオプションを要求します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1--Request-Freshness">
2.1. Request Freshness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. 鮮度をリクエストする
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A CoAP server receiving a request is, in general, not able to verify when the request was sent by the CoAP client. This remains true even if the request was protected with a security protocol, such as DTLS. This makes CoAP requests vulnerable to certain delay attacks that are particularly perilous in the case of actuators [COAP-ATTACKS]. Some attacks can be mitigated by establishing fresh session keys, e.g., performing a DTLS handshake for each request, but, in general, this is not a solution suitable for constrained environments, for example, due to increased message overhead and latency. Additionally, if there are proxies, fresh DTLS session keys between the server and the proxy do not say anything about when the client made the request. In a general hop-by-hop setting, freshness may need to be verified in each hop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求を受け取るCoAPサーバーは、一般に、要求がCOAPクライアントによって送信されたときに確認できません。DTLSなどのセキュリティプロトコルで要求が保護されていても、これは当てはまります。これにより、アクチュエータの場合に特に危険な遅延攻撃に対してCOAA依頼が脆弱になります[COAP-攻撃]。いくつかの攻撃は、新たなセッションキーを確立することによって軽減され、例えば、各要求のためにDTLSハンドシェイクを実行することによって軽減することができるが、一般に、これは、例えばメッセージオーバーヘッドおよび待ち時間の増加のために、制約付き環境に適した解決策ではない。さらに、プロキシがある場合は、サーバーとプロキシの間の新鮮なDTLSセッションキーが、クライアントが要求を実行したときには何も言わないでください。一般的なホップごとの設定では、各ホップで鮮度を検証する必要があるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A straightforward mitigation of potential delayed requests is that the CoAP server rejects a request the first time it appears and asks the CoAP client to prove that it intended to make the request at this point in time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
潜在的な遅延要求の直接的な緩和は、COAASサーバーが最初に現れたときに要求を拒否し、CoAPクライアントに要求をこの時点で要求をすることを意図したことを証明するように依頼することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2--The-Echo-Option">
2.2. The Echo Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. エコーオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines the Echo option, a lightweight challenge-response mechanism for CoAP that enables a CoAP server to verify the freshness of a request. A fresh request is one whose age has not yet exceeded the freshness requirements set by the server. The freshness requirements are application specific and may vary based on resource, method, and parameters outside of CoAP, such as policies. The Echo option value is a challenge from the server to the client included in a CoAP response and echoed back to the server in one or more CoAP requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、COAASサーバーが要求の鮮度を検証できるようにするCOAPの軽量のチャレンジ応答メカニズムであるエコーオプションを定義します。新鮮な要求は、年齢がまだサーバーによって設定された鮮度要件を超えていないものです。鮮度要件はアプリケーション固有のものであり、ポリシーなどのCOAP以外のリソース、メソッド、およびパラメータに基づいて変わります。エコーオプション値は、CoAP応答に含まれているサーバーからクライアントへのチャレンジであり、1つ以上のCOAP要求でサーバーにエコーされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This mechanism is not only important in the case of actuators, or other use cases where the CoAP operations require freshness of requests, but also in general for synchronizing state between a CoAP client and server, cryptographically verifying the aliveness of the client or forcing a client to demonstrate reachability at its claimed network address. The same functionality can be provided by echoing freshness indicators in CoAP payloads, but this only works for methods and response codes defined to have a payload. The Echo option provides a convention to transfer freshness indicators that works for all methods and response codes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメカニズムは、アクチュエータの場合には重要であるだけでなく、COAAS操作が要求の鮮度を必要とする場合だけでなく、クライアントの競合を暗号的に検証するかクライアントを強制的に検証するために一般的には一般的に重要です。その主張されたネットワークアドレスでの到達可能性を証明する。同じ機能は、COAPペイロード内の鮮度インジケータをエコーすることによって提供され得るが、これはペイロードを持つように定義されたメソッドおよび応答コードに対してのみ機能します。エコーオプションは、すべてのメソッドコードと応答コードに対して機能する鮮度インジケータを転送するための規約を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2-1--Echo-Option-Format">
2.2.1. Echo Option Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1. エコーオプションフォーマット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Echo option is elective, safe to forward, not part of the cache-key, and not repeatable (see Table 1, which extends Table 4 of [RFC7252]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エコーオプションは選択的で、キャッシュキーの一部ではなく、再現できず、再現できません（[RFC7252]の表4を拡張する）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +=====+===+===+===+===+======+========+========+=========+
   | No. | C | U | N | R | Name | Format | Length | Default |
   +=====+===+===+===+===+======+========+========+=========+
   | 252 |   |   | x |   | Echo | opaque | 1-40   | (none)  |
   +-----+---+---+---+---+------+--------+--------+---------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Table 1: Echo Option Summary
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
表1：エコーオプションの概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   C=Critical, U=Unsafe, N=NoCacheKey, R=Repeatable
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Echo option value is generated by a server, and its content and structure are implementation specific. Different methods for generating Echo option values are outlined in Appendix A. Clients and intermediaries MUST treat an Echo option value as opaque and make no assumptions about its content or structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エコーオプションの値はサーバーによって生成され、そのコンテンツと構造は実装固有です。ECHOオプション値を生成するためのさまざまな方法は、付録Aで概説されています。クライアントと仲介者は、エコーオプション値を不透明として扱い、その内容や構造についての仮定をしないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When receiving an Echo option in a request, the server MUST be able to verify that the Echo option value (a) was generated by the server or some other party that the server trusts and (b) fulfills the freshness requirements of the application. Depending on the freshness requirements, the server may verify exactly when the Echo option value was generated (time-based freshness) or verify that the Echo option was generated after a specific event (event-based freshness). As the request is bound to the Echo option value, the server can determine that the request is not older than the Echo option value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求にエコーオプションを受信すると、サーバーはサーバーによってエコーオプション値（A）がサーバーによって生成されたこと、または（B）アプリケーションの鮮度要件を満たすことを確認できなければなりません。鮮度要件に応じて、サーバーは、エコーオプションの値が生成されたとき（時間ベースの鮮度）、または特定のイベント（イベントベースの鮮度）の後にエコーオプションが生成されたことを確認することができます。要求がエコーオプション値にバインドされると、サーバーは要求がECHOオプション値より古くないと判断できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the Echo option is used with OSCORE [RFC8613], it MAY be an Inner or Outer option, and the Inner and Outer values are independent. OSCORE servers MUST only produce Inner Echo options unless they are merely testing for reachability of the client (the same as proxies may do). The Inner option is encrypted and integrity protected between the endpoints, whereas the Outer option is not protected by OSCORE. As always with OSCORE, Outer options are visible to (and may be acted on by) all proxies and are visible on all links where no additional encryption (like TLS between client and proxy) is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エコーオプションがOSCORE [RFC8613]で使用されている場合は、内側または外側のオプションである可能性があり、内側と外側値は独立しています。OSCOREサーバーは、クライアントの到達可能性について単にテストされていない限り、内部のエコーオプションのみを生成する必要があります（プロキシと同じ）。内部オプションは、エンドポイント間で暗号化され、整合性が保護されていますが、外部オプションはOSCOREによって保護されていません。OSCOREを常にOSCOREで表示すると、外部オプションはすべてのプロキシに表示され、追加の暗号化（クライアントとプロキシの間のTLSなど）が使用されていないすべてのリンクに表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3--Echo-Processing">
2.3. Echo Processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. エコー処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Echo option MAY be included in any request or response (see Section 2.4 for different applications).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エコーオプションは、任意の要求または応答に含まれている可能性があります（さまざまなアプリケーションについてはセクション2.4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application decides under what conditions a CoAP request to a resource is required to be fresh. These conditions can, for example, include what resource is requested, the request method and other data in the request, and conditions in the environment, such as the state of the server or the time of the day.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアプリケーションは、どの条件下でリソースへのCOAP要求が新鮮である必要があるかを決定します。これらの条件は、例えば、要求されたリソース、要求方法およびその他のデータ、およびサーバの状態などの環境内の条件、またはその日の時刻などの条件を含むことができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a certain request is required to be fresh, the request does not contain a fresh Echo option value, and the server cannot verify the freshness of the request in some other way, the server MUST NOT process the request further and SHOULD send a 4.01 (Unauthorized) response with an Echo option. The server MAY include the same Echo option value in several different response messages and to different clients. Examples of this could be time-based freshness (when several responses are sent closely after each other) or event-based freshness (with no event taking place between the responses).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定の要求が新鮮である必要がある場合、要求にはフレッシュエコーオプション値が含まれておらず、サーバーは他の方法で要求の鮮度を検証できません。サーバーはさらに要求をさらに処理してはならず（4.01）。不正な）エコーオプションによる応答。サーバは、いくつかの異なる応答メッセージおよび異なるクライアントに同じエコーオプション値を含むことができる。この例は、時間ベースの鮮度（複数の応答が互いに密接に送信されたとき）またはイベントベースの鮮度（応答間のイベントなしに）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server may use request freshness provided by the Echo option to verify the aliveness of a client or to synchronize state. The server may also include the Echo option in a response to force a client to demonstrate reachability at its claimed network address. Note that the Echo option does not bind a request to any particular previous response but provides an indication that the client had access to the previous response at the time when it created the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、エコーオプションによって提供された要求鮮度を使用して、クライアントの競合を検証するか、状態を同期させることができる。サーバはまた、クライアントにクレームされたネットワークアドレスでの到達可能性を示すようにクライアントに強制するための応答のエコーオプションを含み得る。ECHOオプションは、任意の特定の以前の応答に要求をバインドしないが、要求を作成した時点でクライアントが前の応答にアクセスしたことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receiving a 4.01 (Unauthorized) response with the Echo option, the client SHOULD resend the original request with the addition of an Echo option with the received Echo option value. The client MAY send a different request compared to the original request. Upon receiving any other response with the Echo option, the client SHOULD echo the Echo option value in the next request to the server. The client MAY include the same Echo option value in several different requests to the server or discard it at any time (especially to avoid tracking; see Section 6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エコーオプションで4.01（不正な）応答を受信すると、クライアントは受信したエコーオプション値を使用してECHOオプションを追加して元の要求を再送信する必要があります。クライアントは、元の要求と比較して別の要求を送信することができます。ECHOオプションを使用して他の応答を受信すると、クライアントはサーバーへの次の要求でエコーオプション値をエコーします。クライアントは、サーバーへのいくつかの異なる要求で同じエコーオプション値を含めることも、いつでも廃棄することもできます（特に追跡を回避するために; 6を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client MUST only send Echo option values to endpoints it received them from (where, as defined in Section 1.2 of [RFC7252], the security association is part of the endpoint). In OSCORE processing, that means sending Echo option values from Outer options (or from non-OSCORE responses) back in Outer options and sending those from Inner options in Inner options in the same security context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、エンドポイントにエコーオプションの値のみを送信する必要があります（ここで、[RFC7252]のセクション1.2で定義されているように、セキュリティアソシエーションはエンドポイントの一部）。OSCORE処理では、それは外部オプション（またはノンオスア応答）からのエコーオプション値を外部オプションで送信し、同じセキュリティコンテキスト内の内部オプションからそれらを送信することを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receiving a request with the Echo option, the server determines if the request is required to be fresh. If not, the Echo option MAY be ignored. If the request is required to be fresh and the server cannot verify the freshness of the request in some other way, the server MUST use the Echo option to verify that the request is fresh. If the server cannot verify that the request is fresh, the request is not processed further, and an error message MAY be sent. The error message SHOULD include a new Echo option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エコーオプションを使用して要求を受信すると、サーバは要求が新鮮であることが必要かどうかを判断する。そうでない場合、エコーオプションは無視されます。要求が新鮮で、サーバーが要求の鮮度を検証できない場合は、要求の鮮度を検証できない場合、サーバーは要求が新鮮であることを確認するためにECHOオプションを使用する必要があります。サーバが要求が新たに検証されていることを確認できない場合、要求はさらに処理されず、エラーメッセージが送信されてもよい。エラーメッセージには、新しいエコーオプションを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One way for the server to verify freshness is to bind the Echo option value to a specific point in time and verify that the request is not older than a certain threshold T. The server can verify this by checking that (t1 - t0) &lt; T, where t1 is the request receive time and t0 is the time when the Echo option value was generated. An example message flow over DTLS is shown Figure 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが新鮮さを検証する1つの方法は、エコーオプション値を特定の時点にバインドし、要求が特定のしきい値Tより古くないことを確認することです。サーバーは（T1-T0）&lt;tをチェックすることでこれを検証できます。ここで、t1は要求受信時間であり、T0はエコーオプション値が生成された時刻です。DTLを介したメッセージフローの例を図1に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    Client   Server
       |       |
       +------&gt;|        Code: 0.03 (PUT)
       |  PUT  |       Token: 0x41
       |       |    Uri-Path: lock
       |       |     Payload: 0 (Unlock)
       |       |
       |&lt;------+        Code: 4.01 (Unauthorized)
       |  4.01 |       Token: 0x41
       |       |        Echo: 0x00000009437468756c687521 (t0 = 9, +MAC)
       |       |
       | ...   | The round trips take 1 second, time is now t1 = 10.
       |       |
       +------&gt;|        Code: 0.03 (PUT)
       |  PUT  |       Token: 0x42
       |       |    Uri-Path: lock
       |       |        Echo: 0x00000009437468756c687521 (t0 = 9, +MAC)
       |       |     Payload: 0 (Unlock)
       |       |
       |       | Verify MAC, compare t1 - t0 = 1 &lt; T =&gt; permitted.
       |       |
       |&lt;------+        Code: 2.04 (Changed)
       |  2.04 |       Token: 0x42
       |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Figure 1: Example Message Flow for Time-Based Freshness Using the &#39;Integrity-Protected Timestamp&#39; Construction of Appendix A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
図1：付録Aの「整合性保護タイムスタンプ」構築を用いた時間ベースの鮮度のメッセージフローの例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another way for the server to verify freshness is to maintain a cache of values associated to events. The size of the cache is defined by the application. In the following, we assume the cache size is 1, in which case, freshness is defined as &#34;no new event has taken place&#34;. At each event, a new value is written into the cache. The cache values MUST be different or chosen in a way so the probability for collisions is negligible. The server verifies freshness by checking that e0 equals e1, where e0 is the cached value when the Echo option value was generated, and e1 is the cached value at the reception of the request. An example message flow over DTLS is shown in Figure 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが鮮度を検証するもう1つの方法は、イベントに関連付けられている値のキャッシュを維持することです。キャッシュのサイズはアプリケーションによって定義されます。以下では、キャッシュサイズが1で、その場合、鮮度は「新しいイベントが発生していない」と定義されます。各イベントでは、新しい値がキャッシュに書き込まれます。キャッシュ値は違う、または衝突の可能性が無視できるようにさまざまである必要があります。サーバは、E0がE1に等しいことを確認することによって鮮度を検証し、E0はエコーオプション値が生成されたときのキャッシュ値、E1は要求の受信時のキャッシュ値である。DTLSを介したメッセージフローの例を図2に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Client   Server
        |       |
        +------&gt;|        Code: 0.03 (PUT)
        |  PUT  |       Token: 0x41
        |       |    Uri-Path: lock
        |       |     Payload: 0 (Unlock)
        |       |
        |&lt;------+        Code: 4.01 (Unauthorized)
        |  4.01 |       Token: 0x41
        |       |        Echo: 0x05 (e0 = 5, number of total lock
        |       |                            operations performed)
        |       |
        | ...   | No alterations happen to the lock state, e1 has the
        |       | same value e1 = 5.
        |       |
        +------&gt;|        Code: 0.03 (PUT)
        |  PUT  |       Token: 0x42
        |       |    Uri-Path: lock
        |       |        Echo: 0x05
        |       |     Payload: 0 (Unlock)
        |       |
        |       | Compare e1 = e0 =&gt; permitted.
        |       |
        |&lt;------+        Code: 2.04 (Changed)
        |  2.04 |       Token: 0x42
        |       |        Echo: 0x06 (e2 = 6, to allow later locking
        |       |                            without more round trips)
        |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Figure 2: Example Message Flow for Event-Based Freshness Using the &#39;Persistent Counter&#39; Construction of Appendix A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
図2：付録Aの「持続的カウンタ」構築を用いたイベントベースの鮮度のためのメッセージフローの例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When used to serve freshness requirements (including client aliveness and state synchronizing), the Echo option value MUST be integrity protected between the intended endpoints, e.g., using DTLS, TLS, or an OSCORE Inner option [RFC8613]. When used to demonstrate reachability at a claimed network address, the Echo option SHOULD be a Message Authentication Code (MAC) of the claimed address but MAY be unprotected. Combining different Echo applications can necessitate different choices; see Appendix A, item 2 for an example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
鮮度要件（クライアントアリティ性と状態同期を含む）を提供するために使用される場合、エコーオプション値は、意図されたエンドポイント、例えばDTLS、TLS、またはOSCORE INNERオプション[RFC8613]を使用して、整合性が保護されている必要があります。クレームされたネットワークアドレスでの到達可能性を示すために使用される場合、エコーオプションはクレームされたアドレスのメッセージ認証コード（MAC）でなければなりませんが、保護されていない可能性があります。異なるエコーアプリケーションを組み合わせると、異なる選択肢が必要です。例については、付録A、項目2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Echo option MAY be sent with a successful response, i.e., even though the request satisfied any freshness requirements on the operation. This is called a &#34;preemptive&#34; Echo option value and is useful when the server anticipates that the client will need to demonstrate freshness relative to the current response in the near future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エコーオプションは、要求が操作上の鮮度要件を満たしていても、応答が成功した場合でも送信することができます。これは「PreEmptive」エコーオプション値と呼ばれ、サーバーがクライアントが近い将来現在の回答に対して鮮度を実証する必要があると予測している場合に役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A CoAP-to-CoAP proxy MAY set an Echo option on responses, both on forwarded ones that had no Echo option or ones generated by the proxy (from cache or as an error). If it does so, it MUST remove the Echo option it recognizes as one generated by itself on follow-up requests. When it receives an Echo option in a response, it MAY forward it to the client (and, not recognizing it as its own in future requests, relay it in the other direction as well) or process it on its own. If it does so, it MUST ensure that the client&#39;s request was generated (or is regenerated) after the Echo option value used to send to the server was first seen. (In most cases, this means that the proxy needs to ask the client to repeat the request with a new Echo option value.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CoAp to-Coapプロキシは、エコーオプションまたはプロキシによって生成されたもの（キャッシュまたはエラーとして）の両方で、応答にエコーオプションを設定できます。そうすると、それはフォローアップ要求でそれ自体によって生成されたものとして認識されるエコーオプションを削除する必要があります。応答にエコーオプションを受信すると、それをクライアントに転送することができます（そしてそれを将来の要求ではそれを認識していない、他の方向にそれを他の方向に中継する）、またはそれ自身のプロセスをプロセスするかもしれません。そうすると、サーバーに送信するために使用されたエコーオプション値が最初に見られた後に、クライアントの要求が生成された（または再生成されます）ことを確認する必要があります。（ほとんどの場合、これはプロキシがクライアントに新しいエコーオプション値で要求を繰り返すように依頼する必要があることを意味します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CoAP server side of CoAP-to-HTTP proxies MAY request freshness, especially if they have reason to assume that access may require it (e.g., because it is a PUT or POST); how this is determined is out of scope for this document. The CoAP client side of HTTP-to-CoAP proxies MUST respond to Echo challenges itself if the proxy knows from the recent establishing of the connection that the HTTP request is fresh. Otherwise, it MUST NOT repeat an unsafe request and SHOULD respond with a 503 (Service Unavailable) with a Retry-After value of 0 seconds and terminate any underlying Keep-Alive connection. If the HTTP request arrived in early data, the proxy SHOULD use a 425 (Too Early) response instead (see [RFC8470]). The proxy MAY also use other mechanisms to establish freshness of the HTTP request that are not specified here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CoAp-to-httpプロキシのCoAPサーバー側は、特にアクセスがそれを必要とすると仮定する理由がある場合（たとえば、PUTまたはPOSTであるため）と仮定する理由がある場合は、鮮度を要求できます。これがどのように決定されるかはこの文書の範囲外です。HTTPからCOAPプロキシのCoAPクライアント側は、プロキシがHTTP要求が新鮮な接続の最近の接続を確立した場合、エコーに応答する必要があります。それ以外の場合は、安全でない要求を繰り返してはならず、403（サービスでは使用できない）で、0秒の再試行後の値が0秒で応答し、その基礎となるキープアライブ接続を終了します。HTTPリクエストが初期のデータに到着した場合、プロキシは代わりに425（早すぎる）応答を使用する必要があります（[RFC8470]を参照）。プロキシはまた、ここで指定されていないHTTP要求の鮮度を確立するために他のメカニズムを使用することができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-4--Applications-of-the-Echo-Option">
2.4. Applications of the Echo Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. エコーオプションのアプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless otherwise noted, all these applications require a security protocol to be used and the Echo option to be protected by it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に明記しない限り、これらすべてのアプリケーションは、使用されるセキュリティプロトコルとそれによって保護されるエコーオプションを必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Actuation requests often require freshness guarantees to avoid accidental or malicious delayed actuator actions. In general, all unsafe methods (e.g., POST, PUT, and DELETE) may require freshness guarantees for secure operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 作動要求はしばしば誤った遅れたアクチュエータの行動を避けるために鮮度保証を必要とします。一般に、すべての危険な方法（例えば、POST、PUT、およびDELETE）は、安全な操作のために鮮度保証を必要とする可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* The same Echo option value may be used for multiple actuation requests to the same server, as long as the total time since the Echo option value was generated is below the freshness threshold.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* 同じサーバへの同じサーバへの複数の作動要求に同じエコーオプション値を使用することができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* For actuator applications with low delay tolerance, to avoid additional round trips for multiple requests in rapid sequence, the server may send preemptive Echo option values in successful requests, irrespectively of whether or not the request contained an Echo option. The client then uses the Echo option with the new value in the next actuation request, and the server compares the receive time accordingly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* 低遅延許容誤差を有するアクチュエータアプリケーションの場合、迅速なシーケンスにおける複数の要求に対する追加の往復を回避するために、サーバは、要求がエコーオプションを含むかどうかにかかわらず、サーバは正常に要求された要求においてプリエンプティブなエコーオプション値を送信することができる。次に、クライアントは次の作動要求の新しい値でECHOオプションを使用し、サーバーはそれに応じて受信時刻を比較します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. A server may use the Echo option to synchronize properties (such as state or time) with a requesting client. A server MUST NOT synchronize a property with a client that is not the authority of the property being synchronized. For example, if access to a server resource is dependent on time, then the server MUST NOT synchronize time with a client requesting access unless the client is a time authority for the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. サーバーは、エコーオプションを使用して、プロパティ（状態や時刻など）を要求しているクライアントと同期させることができます。サーバーは、同期されているプロパティの権限ではないクライアントとプロパティを同期してはいけません。たとえば、サーバーリソースへのアクセスが時間に依存している場合、クライアントがサーバーの時刻権限でない限り、サーバーはクライアントを要求するクライアントと同期してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Note that the state to be synchronized is not carried inside the Echo option. Any explicit state information needs to be carried along in the messages the Echo option value is sent in; the Echo mechanism only provides a partial order on the messages&#39; processing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
同期する状態は、エコーオプション内では使用されません。ECHOオプション値が送信されたメッセージ内に任意の明示的な状態情報を持ち運ぶ必要があります。エコーメカニズムは、メッセージの処理に部分的な順序のみを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* If a server reboots during operation, it may need to synchronize state or time before continuing the interaction. For example, with OSCORE, it is possible to reuse a partly persistently stored security context by synchronizing the Partial IV (sequence number) using the Echo option, as specified in Section 7.5 of [RFC8613].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* 操作中にサーバーが再起動すると、相互作用を継続する前に状態や時間を同期させる必要があります。たとえば、OSCOREを使用すると、[RFC8613]のセクション7.5で指定されているように、エコーオプションを使用して部分IV（シーケンス番号）を同期させることで、部分的に保存されているセキュリティコンテキストを再利用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* A device joining a CoAP group communication [GROUP-COAP] protected with OSCORE [GROUP-OSCORE] may be required to initially synchronize its replay window state with a client by using the Echo option in a unicast response to a multicast request. The client receiving the response with the Echo option includes the Echo option value in a subsequent unicast request to the responding server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* COAPグループ通信[グループCOAP]をOSCORE [グループ -  OSCORE]で保護されているデバイスは、マルチキャスト要求に対するユニキャスト応答のエコーオプションを使用して、再生ウィンドウの状態をクライアントと最初に同期させるために必要とされます。エコーオプションを使用して応答を受信したクライアントには、応答サーバーへの後続のユニキャストリクエストのエコーオプション値が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. An attacker can perform a denial-of-service attack by putting a victim&#39;s address in the source address of a CoAP request and sending the request to a resource with a large amplification factor. The amplification factor is the ratio between the size of the request and the total size of the response(s) to that request. A server that provides a large amplification factor to an unauthenticated peer SHOULD mitigate amplification attacks, as described in Section 11.3 of [RFC7252]. One way to mitigate such attacks is for the server to respond to the alleged source address of the request with an Echo option in a short response message (e.g., 4.01 (Unauthorized)), thereby requesting the client to verify its source address. This needs to be done only once per endpoint and limits the range of potential victims from the general Internet to endpoints that have been previously in contact with the server. For this application, the Echo option can be used in messages that are not integrity protected, for example, during discovery. (This is formally recommended in Section 2.6.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 攻撃者は、被害者のアドレスをCOAP要求の送信元アドレスに入れることによってサービス拒否攻撃を実行し、大きな増幅率を持つリソースに要求を送信することができます。増幅率は、要求のサイズとその要求に対する応答の合計サイズとの間の比率である。 [RFC7252]のセクション11.3で説明されているように、認証されていないピアに大きな増幅率を提供するサーバーは、増幅攻撃を軽減する必要があります。そのような攻撃を軽減する1つの方法は、サーバが短い応答メッセージ（例えば、4.01（不正））内のエコーオプションを用いて要求の要求元アドレスに応答することであり、それによってクライアントにその送信元アドレスを検証することを要求することである。これは、エンドポイントごとに1回だけ実行され、一般的なインターネットからの潜在的な犠牲者の範囲を以前にサーバーに連絡していたエンドポイントに制限されます。このアプリケーションでは、エコーオプションは、ディスカバリー中に保護されていないメッセージで使用できます。 （これはセクション2.6で正式に推奨されています。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* In the presence of a proxy, a server will not be able to distinguish different origin client endpoints, i.e., the client from which a request originates. Following from the recommendation above, a proxy that provides a large amplification factor to unauthenticated peers SHOULD mitigate amplification attacks. The proxy SHOULD use the Echo option to verify origin reachability, as described in Section 2.3. The proxy MAY forward safe requests immediately to have a cached result available when the client&#39;s repeated request arrives.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* プロキシの存在下では、サーバは、さまざまな原点クライアントエンドポイント、すなわち要求が発生するクライアントを区別することはできません。上記の勧告の後、認証されていないピアに大きな増幅率を提供するプロキシは、増幅攻撃を軽減する必要があります。プロキシは、セクション2.3に記載されているように、Origin到達可能性を検証するためにECHOオプションを使用する必要があります。プロキシは、クライアントの繰り返し要求が到着したときにキャッシュされた結果を利用できるようにすぐに安全な要求を順守することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Amplification mitigation is a trade-off between giving leverage to an attacker and causing overhead. An amplification factor of 3 (i.e., don&#39;t send more than three times the number of bytes received until the peer&#39;s address is confirmed) is considered acceptable for unconstrained applications in [RFC9000], Section 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* 増幅緩和は、攻撃者に活用され、オーバーヘッドを引き起こすことの間のトレードオフです。3の増幅率（ピアアドレスが確認されるまで受信したバイト数を3倍以上送信しない）は、[RFC9000]、セクション8の制約されていないアプリケーションに受け入れられると見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
When that limit is applied and no further context is available, a safe default is sending initial responses no larger than 136 bytes in CoAP serialization. (The number is assuming Ethernet, IP, and UDP headers of 14, 40, and 8 bytes, respectively, with 4 bytes added for the CoAP header. Triple that minus the non-CoAP headers gives the 136 bytes.) Given the token also takes up space in the request, responding with 132 bytes after the token is safe as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
その制限が適用され、それ以上のコンテキストが利用できない場合、安全なデフォルトは136バイト以下の初期応答をCOAAシリアライゼーションに送信しています。（その数は、それぞれイーサネット、IP、およびUDPヘッダーをそれぞれ14,40、および8バイトと仮定しています。これは、CoAPヘッダーに追加された4バイトが追加されています。マイナス非COAPヘッダーをマイナスにする3倍は136バイトを与えます。トークンを考えるとトークンが安全な後に132バイトで応答して、要求にスペースを取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* When an Echo response is sent to mitigate amplification, it MUST be sent as a piggybacked or Non-confirmable response, never as a separate one (which would cause amplification due to retransmission).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* エコー応答が軽減されるように送信されるとき、それはPiggybackedまたは不承認の対応として送信されなければならない（再送信のために増幅を引き起こすであろう）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. A server may want to use the request freshness provided by the Echo option to verify the aliveness of a client. Note that, in a deployment with hop-by-hop security and proxies, the server can only verify aliveness of the closest proxy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. サーバーは、エコーオプションによって提供された要求の鮮度を使用して、クライアントの競合を検証することをお勧めします。ホップバイホップセキュリティとプロキシを使用した展開では、サーバーは最も近いプロキシの競合を検証できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-5--Characterization-of-Echo-Applications">
2.5. Characterization of Echo Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5. エコーアプリケーションのキャラクタリゼーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use cases for the Echo option can be characterized by several criteria that help determine the required properties of the Echo option value. These criteria apply both to those listed in Section 2.4 and any novel applications. They provide rationale for the statements in the former and guidance for the latter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECHOオプションのユースケースは、エコーオプション値の必要なプロパティを決定するのに役立ついくつかの基準によって特徴付けられます。これらの基準は、セクション2.4および任意の新規なアプリケーションに記載されているものに適用されます。彼らは前者の声明と後者の手引きの根拠を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-5-1--Time-Based-versus-Event-Based-Freshness">
2.5.1. Time-Based versus Event-Based Freshness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5.1. 時間ベース対イベントベースの鮮度
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The property a client demonstrates by sending an Echo option value is that the request was sent after a certain point in time or after some event happened on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがエコーオプション値を送信することによって説明されているプロパティは、要求がある時点の後に、またはサーバー上で発生した後に要求が送信されたことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When events are counted, they form something that can be used as a monotonic but very non-uniform time line. With highly regular events and low-resolution time, the distinction between time-based and event-based freshness can be blurred: &#34;no longer than a month ago&#34; is similar to &#34;since the last full moon&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イベントが数えられると、それらは単調ではなく非常に不均一なタイムラインとして使用できるものを形成します。非常に定期的なイベントと低解像度の時間で、時間ベースとイベントベースの鮮度の区別はぼやけている可能性があります。「1ヶ月以上前」と似ています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In an extreme form of event-based freshness, the server can place an event whenever an Echo option value is used. This makes the Echo option value effectively single use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イベントベースの鮮度の極端な形式では、サーバーはエコーオプション値を使用するたびにイベントを配置できます。これにより、エコーオプション値が効果的に単一の使用になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Event-based and time-based freshness can be combined in a single Echo option value, e.g., by encrypting a timestamp with a key that changes with every event to obtain semantics in the style of &#34;usable once but only for 5 minutes&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イベントベースおよび時間ベースの鮮度を単一のエコーオプション値で組み合わせることで、「5分間だけ使用可能」のスタイルのセマンティクスを取得するためのすべてのイベントで変更を取得するためのタイムスタンプを暗号化することによって、単一のエコーオプション値で組み合わせることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-5-2--Authority-over-Used-Information">
2.5.2. Authority over Used Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5.2. 中古情報の権限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information conveyed to the server in the request Echo option value has different authority depending on the application. Understanding who or what is the authoritative source of that information helps the server implementor decide the necessary protection of the Echo option value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求エコーオプション値でサーバーに伝達された情報は、アプリケーションに応じて異なる権限を持ちます。その情報の権限のある権限を理解するのは、サーバー実装者がECHOオプション値の必要な保護を決定するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If all that is conveyed to the server is information that the client is authorized to provide arbitrarily (which is another way of saying that the server has to trust the client on whatever the Echo option is being used for), then the server can issue Echo option values that do not need to be protected on their own. They still need to be covered by the security protocol that covers the rest of the message, but the Echo option value can be just short enough to be unique between this server and client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーに伝えられるすべてのものが、クライアントが任意に提供することを許可されている情報である場合（これは、サーバーがエコーオプションが使用されているものとしてクライアントを信頼するための別の方法である）、サーバーはエコーを発行できます。自分で保護する必要がないオプション値。それらはまだメッセージの残りの部分をカバーするセキュリティプロトコルによってカバーされる必要がありますが、エコーオプションの値はこのサーバーとクライアントの間で一意になるのに十分な短いことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, the client&#39;s OSCORE Sender Sequence Number (as used in [RFC8613], Appendix B.1.2) is such information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、クライアントのOSCORE送信側シーケンス番号（[RFC8613]で使用されているように、付録B.1.2）はそのような情報です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In most other cases, there is information conveyed for which the server is the authority (&#34;the request must not be older than five minutes&#34; is counted on the server&#39;s clock, not the client&#39;s) or which even involve the network (as when performing amplification mitigation). In these cases, the Echo option value itself needs to be protected against forgery by the client, e.g., by using a sufficiently large, random value or a MAC, as described in Appendix A, items 1 and 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のほとんどの場合、サーバーが権限である情報が伝えられている情報があります（「要求は5分以内にしてはいけません」とクライアントの時計ではカウントされている場合は、）、またはネットワークを含みます（増幅を実行するときのように）。緩和）。これらの場合、エコーオプション値自体は、付録A、項目1および2に記載されているように、十分に大きい、ランダムな値またはMACを使用することによって、クライアントによって偽造から保護される必要がある。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For some applications, the server may be able to trust the client to also act as the authority (e.g., when using time-based freshness purely to mitigate request delay attacks); these need careful case-by-case evaluation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のアプリケーションでは、サーバーは、クライアントが権限としても機能するように信頼できるかもしれません（例えば、純粋に純粋に推奨攻撃を軽減するために時間ベースの鮮度を使用する場合）。これらは慎重なケースバイケースの評価を必要とする。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To issue Echo option values without integrity protection of its own, the server needs to trust the client to never produce requests with attacker-controlled Echo option values. The provisions of Section 2.3 (saying that an Echo option value may only be sent as received from the same server) allow that. The requirement stated there for the client to treat the Echo option value as opaque holds for these applications like for all others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
独自の保護なしにECHOオプション値を発行するには、サーバーは攻撃者制御エコーオプション値を使用して要求を作成することは決してないようにクライアントに信頼する必要があります。セクション2.3の規定（エコーオプションの値が同じサーバーから受信したときにのみ送信されるかもしれないと言っている）はそれを許可します。要件は、他のすべてのアプリケーションのように、エコーオプションの値を不透明として扱うためにクライアントに述べられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client is the sole authority over the synchronized property, the server can still use time or events to issue new Echo option values. Then, the request&#39;s Echo option value not so much proves the indicated freshness to the server but reflects the client&#39;s intention to indicate reception of responses containing that value when sending the later ones.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが同期プロパティを介した唯一の権限である場合、サーバーはまだ時間またはイベントを使用して新しいエコーオプション値を発行できます。その後、要求のエコーオプション値はそれほど多くのことを証明していませんが、サーバーへの示された鮮度を証明しますが、後のものを送信するときにその値を含む応答の受信を示すクライアントの意図を反映しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that a single Echo option value can be used for multiple purposes (e.g., to both get the sequence number information and perform amplification mitigation). In this case, the stricter protection requirements apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一のエコーオプション値を複数の目的に使用することができます（たとえば、シーケンス番号情報を取得し、増幅緩和を実行する）。この場合、厳密な保護要件が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-5-3--Protection-by-a-Security-Protocol">
2.5.3. Protection by a Security Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5.3. セキュリティプロトコルによる保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For meaningful results, the Echo option needs to be used in combination with a security protocol in almost all applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
意味のある結果の場合、エコーオプションは、ほとんどすべてのアプリケーションでセキュリティプロトコルと組み合わせて使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the information extracted by the server is only about a part of the system outside of any security protocol, then the Echo option can also be used without a security protocol (in case of OSCORE, as an Outer option).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーによって抽出された情報がすべてのセキュリティプロトコルの外でシステムの一部だけである場合、ECHOオプションはセキュリティプロトコルなしで（外部オプションとして）セキュリティプロトコルなしで使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The only known application satisfying this requirement is network address reachability, where unprotected Echo option values are used both by servers (e.g., during setup of a security context) and proxies (which do not necessarily have a security association with their clients) for amplification mitigation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この要件を満たす唯一の既知のアプリケーションはネットワークアドレス到達可能性であり、予約されていないエコーオプション値は（例えば、セキュリティコンテキストのセキュリティ中のセットアップ中に）使用され、プロキシ（必ずしもクライアントとのセキュリティアソシエーションが必要とされない）の両方で使用されます。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-6--Updated-Amplification-Mitigation-Requirements-for-Servers">
2.6. Updated Amplification Mitigation Requirements for Servers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6. サーバーの増幅緩和要件を更新しました
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section updates the amplification mitigation requirements for servers in [RFC7252] to recommend the use of the Echo option to mitigate amplification attacks. The requirements for clients are not updated. Section 11.3 of [RFC7252] is updated by adding the following text:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、[RFC7252]のサーバーの増幅緩和要件を更新し、増幅攻撃を軽減するためのECHOオプションを使用することをお勧めします。クライアントの要件は更新されません。[RFC7252]のセクション11.3は、次のテキストを追加して更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |  A CoAP server SHOULD mitigate potential amplification attacks by
   |  responding to unauthenticated clients with 4.01 (Unauthorized)
   |  including an Echo option, as described in item 3 in Section 2.4 of
   |  RFC 9175.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Protecting-Message-Bodies-Using-Request-Tags">
3. Protecting Message Bodies Using Request Tags
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 要求タグを使用してメッセージ本文を保護する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Fragmented-Message-Body-Integrity">
3.1. Fragmented Message Body Integrity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 断片化されたメッセージ本体の整合性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CoAP was designed to work over unreliable transports, such as UDP, and includes a lightweight reliability feature to handle messages that are lost or arrive out of order. In order for a security protocol to support CoAP operations over unreliable transports, it must allow out-of-order delivery of messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COAPは、UDPなどの信頼性の低い輸送を継続するように設計されており、紛失または順番に到着したメッセージを処理するための軽量の信頼性機能を含みます。セキュリティプロトコルが信頼性の低いトランスポートでのCOAP操作をサポートするためには、メッセージの順序配信を許可する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The block-wise transfer mechanism [RFC7959] extends CoAP by defining the transfer of a large resource representation (CoAP message body) as a sequence of blocks (CoAP message payloads). The mechanism uses a pair of CoAP options, Block1 and Block2, pertaining to the request and response payload, respectively. The block-wise functionality does not support the detection of interchanged blocks between different message bodies to the same resource having the same block number. This remains true even when CoAP is used together with a security protocol (such as DTLS or OSCORE) within the replay window [COAP-ATTACKS], which is a vulnerability of the block-wise functionality of CoAP [RFC7959].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック通信機構[RFC7959]は、大きなリソース表現（CoAPメッセージ本体）の転送を一連のブロックとして定義することによってCOAPを拡張する（CoAPメッセージペイロード）。このメカニズムは、それぞれ要求および応答ペイロードに関する一対のCOAPオプション、Block1およびBlock2を使用する。ブロック単位の機能は、同じブロック番号を有する同じリソースへの異なるメッセージ本体間の交換されたブロックの検出をサポートしていない。COAAP→COAP  - 攻撃の中でセキュリティプロトコル（DTLSやOSCOREなど）と一緒に使用されている場合でも、これは本当のままです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A straightforward mitigation of mixing up blocks from different messages is to use unique identifiers for different message bodies, which would provide equivalent protection to the case where the complete body fits into a single payload. The ETag option [RFC7252], set by the CoAP server, identifies a response body fragmented using the Block2 option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異なるメッセージからブロックを混在させることの直接的な緩和は、異なるメッセージ本体に対して固有の識別子を使用することであり、これは完全な本体が単一のペイロードに収まる場合に同等の保護を提供するであろう。CoAPサーバーによって設定されたETAGオプション[RFC7252]は、block2オプションを使用して断片化された応答本文を識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--The-Request-Tag-Option">
3.2. The Request-Tag Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. request-tagオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines the Request-Tag option for identifying request bodies, similar to ETag, but ephemeral and set by the CoAP client. The Request-Tag is intended for use as a short-lived identifier for keeping apart distinct block-wise request operations on one resource from one client, addressing the issue described in Section 3.1. It enables the receiving server to reliably assemble request payloads (blocks) to their message bodies and, if it chooses to support it, to reliably process simultaneous block-wise request operations on a single resource. The requests must be integrity protected if they should protect against interchange of blocks between different message bodies. The Request-Tag option is mainly used in requests that carry the Block1 option and in Block2 requests following these.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、ETAGと同様に、要求ボディを識別するためのrequest-tagオプションを定義します。要求タグは、セクション3.1で説明されている問題に対処して、あるクライアントからの1つのリソースに対して別個のブロック単位の要求操作を維持するための短命の識別子としての使用を目的としています。これにより、受信側サーバは、リクエストペイロード（ブロック）を自分のメッセージ本体に確実に組み立て、それをサポートすることを選択した場合は、単一のリソースに対して同時ブロック単位の要求操作を確実に処理することができます。異なるメッセージ本体間のブロックの交換から保護する必要がある場合、要求は整合性で保護されている必要があります。request-tagオプションは、主にブロック1オプションを持ち、ブロック2の要求に続く要求に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In essence, it is an implementation of the &#34;proxy-safe elective option&#34; used just to &#34;vary the cache key&#34;, as suggested in [RFC7959], Section 2.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本質的には、[RFC7959]で示唆されているように、「キャッシュキーを変える」ために使用される「プロキシセーフ選択オプション」の実装です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-1--Request-Tag-Option-Format">
3.2.1. Request-Tag Option Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. request-tagオプションフォーマット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Request-Tag option is elective, safe to forward, repeatable, and part of the cache key (see Table 2, which extends Table 4 of [RFC7252]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQUEST-TAGオプションは、選択可能で、転送、再現可能、およびキャッシュキーの一部（表2を参照）の[RFC7252]の表4を参照）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +=====+===+===+===+===+=============+========+========+=========+
   | No. | C | U | N | R | Name        | Format | Length | Default |
   +=====+===+===+===+===+=============+========+========+=========+
   | 292 |   |   |   | x | Request-Tag | opaque | 0-8    | (none)  |
   +-----+---+---+---+---+-------------+--------+--------+---------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Table 2: Request-Tag Option Summary
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
表2：request-tagオプションの概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   C=Critical, U=Unsafe, N=NoCacheKey, R=Repeatable
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Request-Tag, like the Block options, is both a class E and a class U option in terms of OSCORE processing (see Section 4.1 of [RFC8613]). The Request-Tag MAY be an Inner or Outer option. It influences the Inner or Outer block operations, respectively. The Inner and Outer values are therefore independent of each other. The Inner option is encrypted and integrity protected between the client and server, and it provides message body identification in case of end-to-end fragmentation of requests. The Outer option is visible to proxies and labels message bodies in case of hop-by-hop fragmentation of requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求タグは、ブロックオプションと同様に、OSCORE処理の観点からクラスEとクラスUオプションの両方です（[RFC8613]のセクション4.1を参照）。request-tagは内側または外側のオプションです。それはそれぞれ内部または外側のブロック操作に影響を与えます。したがって、内側値と外側値は互いに独立しています。内部オプションは、暗号化され、クライアントとサーバー間で保護されている整合性があり、エンドツーエンドの要求の断片化の場合にはメッセージ本文識別を提供します。アウターオプションは、要求のホップバイホップフラグメンテーションの場合、プロキシとラベルメッセージボディに表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Request-Tag option is only used in the request messages of block-wise operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
request-tagオプションは、ブロック単位の操作の要求メッセージでのみ使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Request-Tag mechanism can be applied independently on the server and client sides of CoAP-to-CoAP proxies, as are the Block options. However, given it is safe to forward, a proxy is free to just forward it when processing an operation. CoAP-to-HTTP proxies and HTTP-to-CoAP proxies can use Request-Tag on their CoAP sides; it is not applicable to HTTP requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロックオプションと同様に、coap-to-coapプロキシのサーバおよびクライアント側では、要求タグメカニズムを独立して適用できます。ただし、それが前方に安全であることを考えると、操作を処理するときにプロキシがそれを自由に転送することができます。CoAp-To-HTTPプロキシとHTTPからCOAPプロキシを使用すると、COAP側でREQUEST-TAGを使用できます。HTTPリクエストには適用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--Request-Tag-Processing-by-Servers">
3.3. Request-Tag Processing by Servers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. サーバーによる要求タグ処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Request-Tag option does not require any particular processing on the server side outside of the processing already necessary for any unknown elective proxy-safe cache-key option. The option varies the properties that distinguish block-wise operations (which includes all options except Block1, Block2, and all operations that are elective NoCacheKey). Thus, the server cannot treat messages with a different list of Request-Tag options as belonging to the same operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
request-tagオプションは、未知の選択プロキシセーフ・キャッシュ・キー・オプションにすでに必要な処理の外部でサーバー側で特定の処理を必要としません。このオプションは、ブロック単位の操作を区別するプロパティを異なります（これは、Block1、Block2、および選択されたNoCacheKeyであるすべての操作を除くすべてのオプションを含む）。したがって、サーバーは、同じ操作に属するものとして異なる要求タグオプションのリストを持つメッセージを扱うことはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To keep utilizing the cache, a server (including proxies) MAY discard the Request-Tag option from an assembled block-wise request when consulting its cache, as the option relates to the operation on the wire and not its semantics. For example, a FETCH request with the same body as an older one can be served from the cache if the older&#39;s Max-Age has not expired yet, even if the second operation uses a Request-Tag and the first did not. (This is similar to the situation about ETag in that it is formally part of the cache key, but implementations that are aware of its meaning can cache more efficiently (see [RFC7252], Section 5.4.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キャッシュを利用し続けるために、サーバ（プロキシを含む）は、そのオプションがワイヤ上の操作に関連してその意味ではなく、そのキャッシュを相談するときに、リクエスト - タグオプションをアセンブルブロック単位の要求から破棄することができる。たとえば、1つの操作が要求タグを使用していなくても、古いMAX-AGEが満了していない場合は、古いものと同じ本体を持つフェッチ要求をキャッシュから提供できます。（これは、それが正式にキャッシュキーの一部であるという状況と似ていますが、その意味を認識している実装はより効率的にキャッシュできます（セクション5.4.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server receiving a Request-Tag MUST treat it as opaque and make no assumptions about its content or structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求タグを受信したサーバーはそれを不透明として扱わなければならず、その内容または構造についての仮定をしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two messages carrying the same Request-Tag is a necessary but not sufficient condition for being part of the same operation. For one, a server may still treat them as independent messages when it sends 2.01 (Created) and 2.04 (Changed) responses for every block. Also, a client that lost interest in an old operation but wants to start over can overwrite the server&#39;s old state with a new initial (num=0) Block1 request and the same Request-Tag under some circumstances. Likewise, that results in the new message not being part of the old operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じ要求タグを搭載した2つのメッセージは、同じ操作の一部であるために必要であるが十分な条件ではない。1つの場合、サーバーはそれが2.01（作成された）および2.04（変更された）応答をブロックごとに送信するときにそれらを独立したメッセージとして扱うことがあります。また、古い操作に興味を失いたが、開始したいクライアントは、サーバの古い状態を新しい初期状態（num = 0）Block1要求といくつかの状況下で同じ要求タグで上書きすることができます。同様に、その結果、新しいメッセージが古い操作の一部ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As it has always been, a server that can only serve a limited number of block-wise operations at the same time can delay the start of the operation by replying with 5.03 (Service Unavailable) and a Max-Age indicating how long it expects the existing operation to go on, or it can forget about the state established with the older operation and respond with 4.08 (Request Entity Incomplete) to later blocks on the first operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それが常にあるので、限られた数のブロック単位の操作を達成することができるサーバーは、5.03（サービス利用不可）で返信することによって操作の開始を遅らせることができ、最大年齢がそれがどのくらい期待しているかを示す最大年齢を遅らせることができます。既存の操作をオンにするか、または古い操作で確立された状態を忘れることができ、4.08（要求エンティティが不完全な要求は不完全）を最初の操作でブロックすることを忘れることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-4--Setting-the-Request-Tag">
3.4. Setting the Request-Tag
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. request-tagを設定します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each separate block-wise request operation, the client can choose a Request-Tag value or choose not to set a Request-Tag. It needs to be set to the same value (or unset) in all messages belonging to the same operation; otherwise, they are treated as separate operations by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別々のブロック単位の要求操作ごとに、クライアントは要求タグ値を選択するか、要求タグを設定しないように選択できます。同じ操作に属するすべてのメッセージで同じ値（または未設定）に設定する必要があります。それ以外の場合は、サーバーによる別々の操作として扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Starting a request operation matchable to a previous operation and even using the same Request-Tag value is called &#34;request tag recycling&#34;. The absence of a Request-Tag option is viewed as a value distinct from all values with a single Request-Tag option set; starting a request operation matchable to a previous operation where neither has a Request-Tag option therefore constitutes request tag recycling just as well (also called &#34;recycling the absent option&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前回の操作に対応した要求操作を開始し、同じ要求タグ値を使用しても、「リクエストタグリサイクル」と呼ばれます。request-tagオプションの欠如は、単一の要求タグオプションセットを使用して、すべての値とは異なる値として表示されます。リクエストタグオプションを持たない前の操作に照合可能な要求動作を開始することで、要求タグのリサイクルを構成していない（不在オプションのリサイクル」とも呼ばれます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients that use Request-Tag for a particular purpose (like in Section 3.5) MUST NOT recycle a request tag unless the first operation has concluded. What constitutes a concluded operation depends on the purpose and is defined accordingly; see examples in Section 3.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定の目的のために要求タグを使用するクライアント（セクション3.5のように）最初の操作が終了しない限り、要求タグをリサイクルしてはなりません。締結された操作を構成するものは目的に依存し、それに応じて定義されています。セクション3.5の例を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When Block1 and Block2 are combined in an operation, the Request-Tag of the Block1 phase is set in the Block2 phase as well; otherwise, the request would have a different set of options and would not be recognized any more.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック1とブロック2が操作で組み合わされると、Block1フェーズの要求タグもブロック2フェーズに設定されます。それ以外の場合、要求は異なるオプションのセットを持ち、これ以上認識されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients are encouraged to generate compact messages. This means sending messages without Request-Tag options whenever possible and using short values when the absent option cannot be recycled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはコンパクトなメッセージを生成することをお勧めします。これは、不在オプションをリサイクルできない場合はいつでも要求タグオプションなしでメッセージを送信することを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that Request-Tag options can be present in request messages that carry no Block options (for example, because a proxy unaware of Request-Tag reassembled them).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求タグのオプションは、ブロックオプションを持たないリクエストメッセージに存在します（例えば、要求タグのプロキシを認識しないようにするため）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Request-Tag option MUST NOT be present in response messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求タグオプションは、応答メッセージに存在してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5--Applications-of-the-Request-Tag-Option">
3.5. Applications of the Request-Tag Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. 要求タグオプションのアプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-1--Body-Integrity-Based-on-Payload-Integrity">
3.5.1. Body Integrity Based on Payload Integrity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1. ペイロードの整合性に基づく体の整合性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client fragments a request body into multiple message payloads, even if the individual messages are integrity protected, it is still possible for an attacker to maliciously replace a later operation&#39;s blocks with an earlier operation&#39;s blocks (see Section 2.5 of [COAP-ATTACKS]). Therefore, the integrity protection of each block does not extend to the operation&#39;s request body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが複数のメッセージペイロードへのクライアントをフラグメント化すると、個々のメッセージが保護されていても、攻撃者が以前の操作のブロックを以前の操作のブロックと故意に置き換えることは依然として可能です（[CoAp-攻撃]のセクション2.5を参照）。）。したがって、各ブロックの完全性保護は操作の要求体には延長されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to gain that protection, use the Request-Tag mechanism as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その保護を得るために、次のようにrequest-tagメカニズムを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The individual exchanges MUST be integrity protected end to end between the client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 個々の交換品は、クライアントとサーバーの間の末尾に整合性保護されたエンドでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The client MUST NOT recycle a request tag in a new operation unless the previous operation matchable to the new one has concluded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 新しい操作が終了したことがない限り、クライアントは新しい操作で要求タグをリサイクルしてはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If any future security mechanisms allow a block-wise transfer to continue after an endpoint&#39;s details (like the IP address) have changed, then the client MUST consider messages matchable if they were sent to any endpoint address using the new operation&#39;s security context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
将来のセキュリティメカニズムでは、エンドポイントの詳細（IPアドレスのように）が変更された後にブロックごとの転送が続行された場合、クライアントは新しい操作のセキュリティコンテキストを使用して任意のエンドポイントアドレスに送信された場合にメッセージを一致させる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The client MUST NOT regard a block-wise request operation as concluded unless all of the messages the client has sent in the operation would be regarded as invalid by the server if they were replayed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* クライアントが操作でクライアントが送信されたすべてのメッセージが再生された場合にサーバーによって無効と見なされない限り、クライアントはブロックごとの要求操作を考慮してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
When security services are provided by OSCORE, these confirmations typically result either from the client receiving an OSCORE response message matching the request (an empty Acknowledgement (ACK) is insufficient) or because the message&#39;s sequence number is old enough to be outside the server&#39;s receive window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
セキュリティサービスがOSCOREによって提供されている場合、これらの確認は通常、要求に一致するOSCORE応答メッセージを受信したクライアントからの結果（空の確認応答（ACK）が不十分）、またはメッセージのシーケンス番号がサーバーの受信ウィンドウの外側になるのに十分な古いものである。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
When security services are provided by DTLS, this can only be confirmed if there was no CoAP retransmission of the request, the request was responded to, and the server uses replay protection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
セキュリティサービスがDTLSによって提供されている場合、これは要求のCOAP再送がなかった場合にのみ確認でき、要求は応答し、サーバーは再生保護を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Authors of other documents (e.g., applications of [RFC8613]) are invited to mandate this subsection&#39;s behavior for clients that execute block-wise interactions over secured transports. In this way, the server can rely on a conforming client to set the Request-Tag option when required and thereby have confidence in the integrity of the assembled body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他の文書の著者（例えば、[RFC8613]のアプリケーション）は、保護されたトランスポートを介したブロックごとの対話を実行するクライアントに対するこのサブセクションの動作を義務付けるように依頼されます。このようにして、サーバは、要求されたときに要求タグオプションを設定し、それによって組み立てられた本体の整合性に自信を有することができるように、準拠するクライアントに頼ることができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this mechanism is implicitly implemented when the security layer guarantees ordered delivery (e.g., CoAP over TLS [RFC8323]). This is because, with each message, any earlier message cannot be replayed any more, so the client never needs to set the Request-Tag option unless it wants to perform concurrent operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメカニズムは、セキュリティ層が順序付けられた配信を保証したとき（例えば、TLS [RFC8323]を介して）暗黙的に実装されています。これは、各メッセージで、以前のメッセージをもう少し再生できないため、クライアントは並行操作を実行しない限り、要求タグオプションを設定する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Body integrity only makes sense in applications that have stateful block-wise transfers. On applications where all the state is in the application (e.g., because rather than POSTing a large representation to a collection in a stateful block-wise transfer, a collection item is created first, then written to once and available when written completely), clients need not concern themselves with body integrity and thus the Request-Tag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ボディの整合性は、ステートフルなブロックごとの転送を持つアプリケーションでのみ意味があります。すべての状態がアプリケーション内にあるアプリケーションで（たとえば、ステートフルのブロック単位の転送でコレクションに転記するのではなく、コレクションアイテムが最初に作成され、次に完全に書き込まれたときに使用可能にし、クライアントに書き込まれて使用可能になるためです。体の整合性、したがって要求タグを扱う必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Body integrity is largely independent from replay protection. When no replay protection is available (it is optional in DTLS), a full block-wise operation may be replayed, but, by adhering to the above, no operations will be mixed up. The only link between body integrity and replay protection is that, without replay protection, recycling is not possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
体の整合性は、リプレイ保護と主に独立しています。再生保護がない場合（DTLSではオプション）、フルブロック単位の操作を再生することができますが、上記に従うことで、操作は混在しません。体の整合性と再生保護の間の唯一のリンクは、再生保護なしで、リサイクルは不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-2--Multiple-Concurrent-Block-Wise-Operations">
3.5.2. Multiple Concurrent Block-Wise Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.2. 複数の同時ブロック単位の操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CoAP clients, especially CoAP proxies, may initiate a block-wise request operation to a resource, to which a previous one is already in progress, which the new request should not cancel. A CoAP proxy would be in such a situation when it forwards operations with the same cache-key options but possibly different payloads.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CoAPクライアント、特にCOAPプロキシは、前のリクエストがすでに進行中であるリソースに対してブロック単位の要求操作を開始します。これは、新しい要求はキャンセルしないでください。COAPプロキシは、同じキャッシュキーオプションで操作を転送する場合は、場合によっては異なるペイロードを転送する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For those cases, Request-Tag is the proxy-safe elective option suggested in the last paragraph of Section 2.4 of [RFC7959].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのような場合、request-tagは[RFC7959]のセクション2.4の最後の段落で提案されたプロキシ安全選択オプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When initializing a new block-wise operation, a client has to look at other active operations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいブロック単位の操作を初期化するとき、クライアントは他のアクティブな操作を調べる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If any of them is matchable to the new one, and the client neither wants to cancel the old one nor postpone the new one, it can pick a Request-Tag value (including the absent option) that is not in use by the other matchable operations for the new operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* それらのいずれかが新しいものと一致していて、クライアントは古いものをキャンセルしたり、新しいものを延期したりしたりしませんでした。新しい操作の操作
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Otherwise, it can start the new operation without setting the Request-Tag option on it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* それ以外の場合は、request-tagオプションを設定せずに新しい操作を開始できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5-3--Simplified-Block-Wise-Handling-for-Constrained-Proxies">
3.5.3. Simplified Block-Wise Handling for Constrained Proxies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.3. 制約されたプロキシのための簡単なブロック単位の処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Block options were defined to be unsafe to forward because a proxy that would forward blocks as plain messages would risk mixing up clients&#39; requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロックを普通メッセージとして転送するプロキシは、クライアントの要求を混在させるリスクを解消するため、ブロックオプションは解析対象と定義されていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some cases, for example, when forwarding block-wise request operations, appending a Request-Tag value unique to the client can satisfy the requirements on the proxy that come from the presence of a Block option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
場合によっては、例えば、ブロック単位の要求操作を転送するときに、クライアントに固有の要求タグ値を追加することは、ブロックオプションの存在から来るプロキシ上の要件を満たすことができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is particularly useful to proxies that strive for stateless operations, as described in [RFC8974], Section 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、[RFC8974]、セクション4で説明されているように、ステートレス操作に努めるプロキシに特に役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The precise classification of cases in which such a Request-Tag option is sufficient is not trivial, especially when both request and response body are fragmented, and is out of scope for this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に要求および応答体の両方が断片化されている場合、そのような要求タグオプションが十分でない場合の正確な分類は些細な分類されており、この文書の範囲外である。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6--Rationale-for-the-Option-Properties">
3.6. Rationale for the Option Properties
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. オプションのプロパティの理論的根拠
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Request-Tag option can be elective, because to servers unaware of the Request-Tag option, operations with differing request tags will not be matchable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQUEST-TAGオプションは、要求タグオプションを認識しないようにするために、要求タグオプションを使用しているため、要求タグを持つ操作は一致しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Request-Tag option can be safe to forward but part of the cache key, because proxies unaware of the Request-Tag option will consider operations with differing request tags unmatchable but can still forward them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQUEST-TAGオプションは、REQUEST-TAGオプションの認識されていないプロキシが異なるリクエストタグを使用していない操作が不可能であるが、それらを転送することができるため、cache-tagオプションの一部を転送することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Request-Tag option is repeatable because this easily allows several cascaded stateless proxies to each put in an origin address. They can perform the steps of Section 3.5.3 without the need to create an option value that is the concatenation of the received option and their own value and can simply add a new Request-Tag option unconditionally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
request-tagオプションは繰り返し可能です。受信したオプションとそれぞれの値を連結したオプション値を作成する必要なしにセクション3.5.3の手順を実行でき、単に新しいrequest-tagオプションを無条件に追加することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In draft versions of this document, the Request-Tag option used to be critical and unsafe to forward. That design was based on an erroneous understanding of which blocks could be composed according to [RFC7959].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのドラフトバージョンでは、要求タグオプションが重要であり、前向きに危険がありません。その設計は、どのブロックを[RFC7959]に従って構成され得るかについての誤った理解に基づいていた。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-7--Rationale-for-Introducing-the-Option">
3.7. Rationale for Introducing the Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7. オプションを導入するための根拠
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An alternative that was considered to the Request-Tag option for coping with the problem of fragmented message body integrity (Section 3.5.1) was to update [RFC7959] to say that blocks could only be assembled if their fragments&#39; order corresponded to the sequence numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
断片化されたメッセージBody Integrityの問題に対処するためのrequest-tagオプション（セクション3.5.1）に検討された代替案は、[RFC7959]を更新して、ブロックがシーケンスに対応している場合にのみブロックを組み立てることができました。数字
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
That approach would have been difficult to roll out reliably on DTLS, where many implementations do not expose sequence numbers, and would still not prevent attacks like in Section 2.5.2 of [COAP-ATTACKS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのアプローチはDTLS上で確実に展開するのが困難であったが、多くの実装はシーケンス番号を公開しないことであり、依然として[CoAp-攻撃]のセクション2.5.2のような攻撃を防止しないであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-8--Block2-and-ETag-Processing">
3.8. Block2 and ETag Processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8. Block2とEtagの処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same security properties as in Section 3.5.1 can be obtained for block-wise response operations. The threat model here does not depend on an attacker; a client can construct a wrong representation by assembling it from blocks from different resource states. That can happen when a resource is modified during a transfer or when some blocks are still valid in the client&#39;s cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック方式の応答動作については、セクション3.5.1と同じセキュリティプロパティを取得できます。ここでの脅威モデルは攻撃者には依存しません。クライアントは、さまざまなリソース状態からブロックから組み立てることで、間違った表現を作成できます。これは、転送中にリソースが変更されたとき、または一部のブロックがクライアントのキャッシュでまだ有効な場合に発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rules stating that response body reassembly is conditional on matching ETag values are already in place from Section 2.4 of [RFC7959].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一致するETAG値に関する応答ボディの再構成が条件付きであることを示す規則は、[RFC7959]のセクション2.4から既に適しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To gain protection equivalent to that described in Section 3.5.1, a server MUST use the Block2 option in conjunction with the ETag option ([RFC7252], Section 5.10.6) and MUST NOT use the same ETag value for different representations of a resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.5.1で説明されているものと同等の保護を得るために、サーバーはETAGオプション（[RFC7252]、5.10.6セクション5.10.6）と組み合わせてBLOCK2オプションを使用する必要があり、リソースの異なる表現に同じETAG値を使用してはいけません。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Token-Processing-for-Secure-Request-Response-Binding">
4. Token Processing for Secure Request-Response Binding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 安全な要求 - 応答バインディングのためのトークン処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Request-Response-Binding">
4.1. Request-Response Binding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 要求 - 応答バインディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A fundamental requirement of secure REST operations is that the client can bind a response to a particular request. If this is not ensured, a client may erroneously associate the wrong response to a request. The wrong response may be an old response for the same resource or a response for a completely different resource (e.g., see Section 2.3 of [COAP-ATTACKS]). For example, a request for the alarm status &#34;GET /status&#34; may be associated to a prior response &#34;on&#34;, instead of the correct response &#34;off&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安全なREST操作の基本的な要件は、クライアントが特定の要求に応答を結び付けることができることです。これが保証されていない場合、クライアントは誤って間違った応答を要求に関連付けることができます。間違った応答は、同じリソースまたは完全に異なるリソースに対する応答に対する古い応答であり得る（例えば、[CoAp-攻撃]のセクション2.3を参照）。例えば、警報状態「get / status」の要求は、正しい応答「OFF」ではなく、前の応答「ON」に関連付けることができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In HTTP/1.1, this type of binding is always assured by the ordered and reliable delivery, as well as mandating that the server sends responses in the same order that the requests were received. The same is not true for CoAP, where the server (or an attacker) can return responses in any order and where there can be any number of responses to a request (e.g., see [RFC7641]). In CoAP, concurrent requests are differentiated by their Token. Note that the CoAP Message ID cannot be used for this purpose since those are typically different for the REST request and corresponding response in case of &#34;separate response&#34; (see Section 2.2 of [RFC7252]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP / 1.1では、このタイプのバインディングは常に順序付けられ、信頼できる配信によって保証され、サーバーが要求が受信されたのと同じ順序で応答を送信することを義務付けます。サーバ（または攻撃者）が任意の順序で応答を返すことができるCOAPについても同様であり、（例えば、[RFC7641]を参照）。COAPでは、同時要求はトークンによって区別されます。COAASメッセージIDは、REST要求と「別々の応答」の場合に対応する応答が通常異なるため、この目的に使用できません（[RFC7252]のセクション2.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CoAP [RFC7252] does not treat the Token as a cryptographically important value and does not give stricter guidelines than that the Tokens currently &#34;in use&#34; SHOULD (not SHALL) be unique. If used with a security protocol not providing bindings between requests and responses (e.g., DTLS and TLS), Token reuse may result in situations where a client matches a response to the wrong request. Note that mismatches can also happen for other reasons than a malicious attacker, e.g., delayed delivery or a server sending notifications to an uninterested client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CoAP [RFC7252]トークンを暗号的に重要な値として扱わず、現在「使用中の」トークンが一意であるべきであることよりも厳しいガイドラインを与えません。リクエストと応答（例えば、DTLS、TLS）の間にバインディングを提供しないセキュリティプロトコルで使用されている場合、トークンの再利用は、クライアントが間違った要求に対する応答と一致する状況をもたらす可能性があります。悪意のある攻撃者よりも、悪意のある攻撃者、例えば遅延配信またはサーバーの通知を未解決のクライアントに送信するサーバーが悪意のある攻撃者よりも発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A straightforward mitigation is to mandate clients to not reuse Tokens until the traffic keys have been replaced. The following section formalizes that.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
簡単な緩和は、トラフィックキーが交換されるまで、クライアントはトークンを再利用しないように義務付けることです。次のセクションでは、それを定式化してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Updated-Token-Processing-Requirements-for-Clients">
4.2. Updated Token Processing Requirements for Clients
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. クライアントのトークン処理要件を更新しました
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 4.1, the client must be able to verify that a response corresponds to a particular request. This section updates the Token processing requirements for clients in [RFC7252] to always assure a cryptographically secure binding of responses to requests for secure REST operations like &#34;coaps&#34;. The Token processing for servers is not updated. Token processing in Section 5.3.1 of [RFC7252] is updated by adding the following text:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション4.1で説明されているように、クライアントは応答が特定の要求に対応することを確認できなければなりません。このセクションでは、[RFC7252]のクライアントのトークン処理要件を更新して、「COAPS」のような安全なREST操作の要求に対する応答の暗号的に安全なバインディングを確保します。サーバーのトークン処理は更新されません。[RFC7252]のセクション5.3.1のトークン処理は、次のテキストを追加して更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |  When CoAP is used with a security protocol not providing bindings
   |  between requests and responses, the Tokens have cryptographic
   |  importance.  The client MUST make sure that Tokens are not used in
   |  a way so that responses risk being associated with the wrong
   |  request.
   |
   |  One easy way to accomplish this is to implement the Token (or part
   |  of the Token) as a sequence number, starting at zero for each new
   |  or rekeyed secure connection.  This approach SHOULD be followed.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Security-Considerations">
5. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The freshness assertion of the Echo option comes from the client reproducing the same value of the Echo option in a request as it received in a previous response. If the Echo option value is a large random number, then there is a high probability that the request is generated after having seen the response. If the Echo option value of the response can be guessed, e.g., if based on a small random number or a counter (see Appendix A), then it is possible to compose a request with the right Echo option value ahead of time. Using guessable Echo option values is only permissible in a narrow set of cases described in Section 2.5.2. Echo option values MUST be set by the CoAP server such that the risk associated with unintended reuse can be managed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECHOオプションの鮮度を主張すると、クライアントからのエコーオプションの同じ値を前の応答で受信したときに同じ値が再現されます。エコーオプション値が大きな乱数である場合、応答を見た後に要求が生成される可能性が高い。応答のエコーオプション値が推測され得る場合、例えば、小さな乱数またはカウンタに基づいている場合（付録Aを参照）、前もって右のエコーオプション値を有する要求を構成することが可能である。推測可能なエコーオプション値を使用することは、セクション2.5.2で説明されている狭いセットの場合にのみ許可されています。意図しない再利用に関連するリスクを管理できるように、エコーオプションの値をCoAPサーバーで設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If uniqueness of the Echo option value is based on randomness, then the availability of a secure pseudorandom number generator and truly random seeds are essential for the security of the Echo option. If no true random number generator is available, a truly random seed must be provided from an external source. As each pseudorandom number must only be used once, an implementation needs to get a new truly random seed after reboot or continuously store the state in nonvolatile memory. See [RFC8613], Appendix B.1.1 for issues and approaches for writing to nonvolatile memory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エコーオプションの値の一意性がランダム性に基づいている場合、安全な疑似乱数ジェネレータと本当にランダムなシードの可用性は、エコーオプションのセキュリティに不可欠です。真の乱数発生器が利用可能でない場合、真にランダムなシードを外部ソースから提供する必要があります。各疑似乱数番号は一度だけ使用されなければならず、実装は再起動後に新しい真のランダムなシードを取得する必要があり、または不揮発性メモリに継続的に保存する必要があります。不揮発性メモリへの書き込みのための問題やアプローチについては、[RFC8613]、付録B.1.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A single active Echo option value with 64 (pseudo)random bits gives the same theoretical security level as a 64-bit MAC (as used in, e.g., AES_128_CCM_8). If a random unique Echo option value is intended, the Echo option value SHOULD contain 64 (pseudo)random bits that are not predictable for any other party than the server. A server MAY use different security levels for different use cases (client aliveness, request freshness, state synchronization, network address reachability, etc.).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
64（疑似）ランダムビットを備えた単一のアクティブエコーオプション値は、64ビットMACと同じ理論セキュリティレベルを与えます（例えば、AES_128_CCM_8で使用されています）。ランダムな固有のエコーオプションの値が意図されている場合、エコーオプション値には、サーバーよりも他のどちらの当事者には予測できない64（疑似）ランダムビットが含まれています。サーバーは、ユースケースの異なる異なるセキュリティレベル（クライアントアリティシティ、鮮度、鮮度同期、ネットワークアドレス到達可能性など）を使用することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security provided by the Echo and Request-Tag options depends on the security protocol used. CoAP and HTTP proxies require (D)TLS to be terminated at the proxies. The proxies are therefore able to manipulate, inject, delete, or reorder options or packets. The security claims in such architectures only hold under the assumption that all intermediaries are fully trusted and have not been compromised.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECHOとREQUEST-TAGオプションによって提供されるセキュリティは、使用されるセキュリティプロトコルによって異なります。COAPおよびHTTPプロキシでは、（D）TLSがプロキシで終了する必要があります。したがって、プロキシはオプションまたはパケットを操作、注入、削除、または並べ替えることができます。そのようなアーキテクチャにおけるセキュリティは、すべての仲介者が完全に信頼されており、損なわれていないという仮定の下でのみ保持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Echo option values without the protection of randomness or a MAC are limited to cases when the client is the trusted source of all derived properties (as per Section 2.5.2). Using them needs per-application consideration of both the impact of a malicious client and of implementation errors in clients. These Echo option values are the only legitimate case for Echo option values shorter than four bytes, which are not necessarily secret. They MUST NOT be used unless the Echo option values in the request are integrity protected, as per Section 2.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ランダム性を保護することなくエコーオプション値またはMacは、クライアントがすべての派生プロパティの信頼できるソースである場合に制限されます（セクション2.5.2に従って）。クライアントの悪意のあるクライアントの影響と実装エラーの両方をアプリケーションごとに使用することができます。これらのエコーオプション値は、4バイトより短いエコーオプション値の唯一の正当な場合であり、これは必ずしも秘密ではありません。要求内のエコーオプションの値がセクション2.3に従って保護されていない限り、それらを使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers SHOULD use a monotonic clock to generate timestamps and compute round-trip times. Use of non-monotonic clocks is not secure, as the server will accept expired Echo option values if the clock is moved backward. The server will also reject fresh Echo option values if the clock is moved forward. Non-monotonic clocks MAY be used as long as they have deviations that are acceptable given the freshness requirements. If the deviations from a monotonic clock are known, it may be possible to adjust the threshold accordingly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは単調クロックを使用してタイムスタンプを生成し、往復時間を計算する必要があります。サーバーが後方に移動した場合、サーバーが期限切れのエコーオプションの値を受け入れると、非単調クロックの使用は安全ではありません。クロックが前方に移動された場合、サーバーはフレッシュエコーオプション値を拒否します。非単調クロックは、それらが鮮度要件を考慮して許容される偏差を有する限り使用され得る。単調クロックからの偏差が分かっている場合、それに応じて閾値を調整することが可能であり得る。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attacker may be able to affect the server&#39;s system time in various ways, such as setting up a fake NTP server or broadcasting false time signals to radio-controlled clocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者は、偽のNTPサーバの設定や無線制御クロックへの誤った時間信号を放送するなど、さまざまな方法でサーバーのシステム時間に影響を与える可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the purpose of generating timestamps for the Echo option, a server MAY set a timer at reboot and use the time since reboot, choosing the granularity such that different requests arrive at different times. Servers MAY intermittently reset the timer and MAY generate a random offset applied to all timestamps. When resetting the timer, the server MUST reject all Echo option values that were created before the reset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECHOオプションのタイムスタンプを生成する目的で、サーバーは再起動時にタイマーを設定し、再起動から時間を使用して、さまざまな要求が異なる時間に到着するような粒度を選択できます。サーバは、タイマを間欠的にリセットし、すべてのタイムスタンプに適用されるランダムオフセットを生成する可能性があります。タイマーをリセットするとき、サーバーはリセット前に作成されたすべてのエコーオプション値を拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers that use the &#34;List of Cached Random Values and Timestamps&#34; method described in Appendix A may be vulnerable to resource exhaustion attacks. One way to minimize the state is to use the &#34;Integrity-Protected Timestamp&#34; method described in Appendix A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付録Aに記載されている「キャッシュされたランダム値とタイムスタンプのリスト」を使用するサーバーは、リソースの枯渇攻撃に対して脆弱です。状態を最小限に抑える1つの方法は、付録Aに記載されている「完全性保護されたタイムスタンプ」方法を使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--Token-Reuse">
5.1. Token Reuse
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. トークンの再利用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reusing Tokens in a way so that responses are guaranteed to not be associated with the wrong request is not trivial. The server may process requests in any order and send multiple responses to the same request. An attacker may block, delay, and reorder messages. The use of a sequence number is therefore recommended when CoAP is used with a security protocol that does not provide bindings between requests and responses, such as DTLS or TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答が間違った要求に関連しないようにするようにトークンを再利用することは簡単ではありません。サーバーは要求を任意の順序で処理し、同じ要求に複数の応答を送信することができます。攻撃者はメッセージをブロック、遅延、および並べ替えることができます。したがって、COAPは、DTLSやTLSなどの要求と応答間のバインディングを提供しないセキュリティプロトコルと同じ場合、シーケンス番号の使用が推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a generic response to a Confirmable request over DTLS, binding can only be claimed without out-of-band knowledge if:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DTLSよりも確認可能な要求に対する一般的な応答のために、バインディングは、次の場合には帯域外の知識なしにのみ主張することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* the original request was never retransmitted and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 元の要求は再送信されたことは決してありませんでした
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* the response was piggybacked in an Acknowledgement message (as a Confirmable or Non-confirmable response may have been transmitted multiple times).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 応答は肯定応答メッセージでピギーバックされた（確認可能または不承認の応答が複数回送信された可能性があるとして）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If observation was used, the same holds for the registration, all reregistrations, and the cancellation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
観察が使用された場合、登録、すべての再登録、およびキャンセルを保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(In addition, for observations, any responses using that Token and a DTLS sequence number earlier than the cancellation Acknowledgement message need to be discarded. This is typically not supported in DTLS implementations.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（さらに、観測の場合、キャンセル確認メッセージより早くそのトークンを使用した応答は廃棄される必要があります。これは通常DTLS実装ではサポートされていません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some setups, Tokens can be reused without the above constraints, as a different component in the setup provides the associations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セットアップによっては、セットアップ内の異なるコンポーネントが関連付けを提供するため、上記の制約なしでトークンを再利用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* In CoAP over TLS, retransmissions are not handled by the CoAP layer and behave like a replay window size of 1. When a client is sending TLS-protected requests without Observe to a single server, the client can reuse a Token as soon as the previous response with that Token has been received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* TLSを介したCOAASでは、再送信はCOAAPレイヤーによって処理されず、リプレイウィンドウサイズのように動作します。クライアントが単一のサーバーに監視されずにTLS保護された要求を送信しているとき、クライアントは前のようにすぐにトークンを再利用できます。そのトークンによる応答が受け取られました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Requests whose responses are cryptographically bound to the requests (like in OSCORE) can reuse Tokens indefinitely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 応答が要求に暗号的にバインドされている要求（オスアのように）は、トークンを無期限に再利用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In all other cases, a sequence number approach is RECOMMENDED, as per Section 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のすべての場合において、セクション4に従って、シーケンス番号のアプローチが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tokens that cannot be reused need to be handled appropriately. This could be solved by increasing the Token as soon as the currently used Token cannot be reused or by keeping a list of all Tokens unsuitable for reuse.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再利用できないトークンは適切に処理される必要があります。これは、現在使用されているトークンが再利用できない、またはすべてのトークンのリストを再利用に適していないとすぐにトークンを増やすことによって解決できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the Token (or part of the Token) contains a sequence number, the encoding of the sequence number has to be chosen in a way to avoid any collisions. This is especially true when the Token contains more information than just the sequence number, e.g., the serialized state, as in [RFC8974].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークン（またはトークンの一部）にシーケンス番号が含まれている場合、シーケンス番号のエンコーディングは衝突を回避する方法で選択されなければなりません。これは、[RFC8974]のように、トークンにシーケンス番号、例えばシリアル化された状態よりも多くの情報が含まれている場合に特に当てはまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Privacy-Considerations">
6. Privacy Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. プライバシーに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations SHOULD NOT put any privacy-sensitive information in the Echo or Request-Tag option values. Unencrypted timestamps could reveal information about the server, such as location, time since reboot, or that the server will accept expired certificates. Timestamps MAY be used if the Echo option is encrypted between the client and the server, e.g., in the case of DTLS without proxies or when using OSCORE with an Inner Echo option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、プライバシーに敏感な情報をECHOまたはREQUEST-TAGオプションの値に配置しないでください。暗号化されていないタイムスタンプは、ロケーション、再起動からの時間などのサーバーに関する情報を明らかにしているか、サーバーが期限切れの証明書を受け入れることができます。エコーオプションがクライアントとサーバの間で暗号化されている場合、プロキシなしのDTLSの場合、またはインナーエコーオプションを使用してOSCOREを使用する場合は、エコーオプションが使用されている場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Like HTTP cookies, the Echo option could potentially be abused as a tracking mechanism that identifies a client across requests. This is especially true for preemptive Echo option values. Servers MUST NOT use the Echo option to correlate requests for other purposes than freshness and reachability. Clients only send Echo option values to the same server from which the values were received. Compared to HTTP, CoAP clients are often authenticated and non-mobile, and servers can therefore often correlate requests based on the security context, the client credentials, or the network address. Especially when the Echo option increases a server&#39;s ability to correlate requests, clients MAY discard all preemptive Echo option values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP Cookieのように、エコーオプションは、要求間でクライアントを識別する追跡メカニズムとして潜在的に廃棄される可能性があります。これは、プリエンプティブエコーオプション値に特に当てはまります。サーバーは、鮮度と到達可能性よりその他の目的の要求を相関させるためにECHOオプションを使用してはいけません。クライアントは、値が受信されたのと同じサーバーにエコーオプションの値を送信します。HTTPと比較して、COAAクライアントはしばしば認証されていて非モバイルであり、サーバーはセキュリティコンテキスト、クライアント認証情報、またはネットワークアドレスに基づいて要求を相関させることがよくあります。特にECHOオプションがリクエストを相関させるサーバーの能力を向上させるとき、クライアントはすべてのプリエンプティブエコーオプション値を破棄する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Publicly visible generated identifiers, even when opaque (as all defined in this document are), can leak information as described in [NUMERIC-IDS]. To avoid the effects described there, the absent Request-Tag option should be recycled as much as possible. (That is generally possible as long as a security mechanism is in place -- even in the case of OSCORE outer block-wise transfers, as the OSCORE option&#39;s variation ensures that no matchable requests are created by different clients.) When an unprotected Echo option is used to demonstrate reachability, the recommended mechanism of Section 2.3 keeps the effects to a minimum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
公に表示された生成された識別子は、（この文書で定義されているように）不透明な場合でも、[数値ID]で説明されているように情報をリークすることができます。そこに記載されている効果を回避するために、存在しない要求タグオプションはできるだけリサイクルされるべきです。（オスアオプションのバリエーションの場合でも、セキュリティメカニズムが配置されている限り、一般的に可能です。オスアオプションのバリエーションが異なる場合でも、保護されていないエコーオプションの場合）到達可能性を示すために使用されます。セクション2.3の推奨されているメカニズムは、効果を最小限に抑えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--IANA-Considerations">
7. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has added the following option numbers to the &#34;CoAP Option Numbers&#34; registry defined by [RFC7252]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、[RFC7252]によって定義された「CoAPオプション番号」レジストリに次のオプション番号を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +========+=============+===========+
   | Number | Name        | Reference |
   +========+=============+===========+
   | 252    | Echo        | RFC 9175  |
   +--------+-------------+-----------+
   | 292    | Request-Tag | RFC 9175  |
   +--------+-------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Table 3: Additions to CoAP Option Numbers Registry
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
表3：オプション番号をCOAPオプション番号レジストリに追加します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--References">
8. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1--Normative-References">
8.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] BRADNER、S、「RFCで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;https：//www.rfc-editor.org/info/RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6347] Rescorla, E. and N. Modadugu, &#34;Datagram Transport Layer Security Version 1.2&#34;, RFC 6347, DOI 10.17487/RFC6347, January 2012, &lt;https://www.rfc-editor.org/info/rfc6347&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6347] Rescorla、E.およびN. ModAdugu、「データグラムトランスポート層セキュリティバージョン1.2」、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、&lt;https：//www.rfc-editor.org/info/rfc6347&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7252] Shelby, Z., Hartke, K., and C. Bormann, &#34;The Constrained Application Protocol (CoAP)&#34;, RFC 7252, DOI 10.17487/RFC7252, June 2014, &lt;https://www.rfc-editor.org/info/rfc7252&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7252] Shelby、Z.、Hartke、K.、およびC. Bormann、「制約付きアプリケーションプロトコル（CoAP）」、RFC 7252、DOI 10.17487 / RFC7252、2014年6月、&lt;https：//www.rfc-編集者。ORG / INFO / RFC7252&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7959] Bormann, C. and Z. Shelby, Ed., &#34;Block-Wise Transfers in the Constrained Application Protocol (CoAP)&#34;, RFC 7959, DOI 10.17487/RFC7959, August 2016, &lt;https://www.rfc-editor.org/info/rfc7959&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7959] Bormann、C.およびZ. Shelby、ED。、「制約付きアプリケーションプロトコル（COAP）」、RFC 7959、DOI 10.17487 / RFC7959、&lt;https：///www.rfc-editor.org/info/rfc7959&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba、B.、RFC 2119キーワードの「大文字の曖昧さ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、&lt;https：//www.rfc-editor.org/info/RFC8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8470] Thomson, M., Nottingham, M., and W. Tarreau, &#34;Using Early Data in HTTP&#34;, RFC 8470, DOI 10.17487/RFC8470, September 2018, &lt;https://www.rfc-editor.org/info/rfc8470&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8470] Thomson、M.、Nottingham、M.、およびW. Tarreau、2018年9月、2018年9月、&lt;https://www.rfc-editor.org/情報/ RFC8470&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8613] Selander, G., Mattsson, J., Palombini, F., and L. Seitz, &#34;Object Security for Constrained RESTful Environments (OSCORE)&#34;, RFC 8613, DOI 10.17487/RFC8613, July 2019, &lt;https://www.rfc-editor.org/info/rfc8613&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8613] Selander、G.、Mattsson、J.、Palombini、F.、およびL. Seitz、「制約のある安らかな環境のためのオブジェクトセキュリティ（OSCORE）」、RFC 8613、DOI 10.17487 / RFC8613、2019年7月、&lt;https：//www.rfc-editor.org/info/rfc8613&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2--Informative-References">
8.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[COAP-ATTACKS] Preuß Mattsson, J., Fornehed, J., Selander, G., Palombini, F., and C. Amsüss, &#34;Attacks on the Constrained Application Protocol (CoAP)&#34;, Work in Progress, Internet-Draft, draft-mattsson-core-coap-attacks-01, 27 July 2021, &lt;https://datatracker.ietf.org/doc/html/draft-mattsson-core-coap-attacks-01&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[COAP-攻撃]プリプ・マッツソン、J.、Fornehed、J.、Selander、G.、Palombini、F.、およびC.Amsüss、「制約付きアプリケーションプロトコル（COAP）」、進行中の攻撃、インターネットドラフト、ドラフトマッツソン - コア -  COAP-Attacks-01,20 7月27日、&lt;https：//datatracker.ietf.org/doc/html/draft-mattsson-core-coap-attacks-01&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GROUP-COAP] Dijk, E., Wang, C., and M. Tiloca, &#34;Group Communication for the Constrained Application Protocol (CoAP)&#34;, Work in Progress, Internet-Draft, draft-ietf-core-groupcomm-bis-05, 25 October 2021, &lt;https://datatracker.ietf.org/doc/html/draft-ietf-core-groupcomm-bis-05&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Group Coap] DIJK、E.、Wang、C.、およびM. Tiloca、「制約付きアプリケーションプロトコル（COAP）のグループコミュニケーションズ」、進行中の作業、インターネットドラフト、ドラフトIETF-CORE-GROUPCOMM-BIS-05,2021、&lt;https://datatracker.ietf.org/doc/html/draft-ietf-core-groupComm-bis-05&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GROUP-OSCORE] Tiloca, M., Selander, G., Palombini, F., Preuß Mattsson, J., and J. Park, &#34;Group OSCORE - Secure Group Communication for CoAP&#34;, Work in Progress, Internet-Draft, draft-ietf-core-oscore-groupcomm-13, 25 October 2021, &lt;https://datatracker.ietf.org/doc/html/draft-ietf-core-oscore-groupcomm-13&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Group-OSCORE] Tiloca、M.、Selander、G.、Palombini、F.、PreußMattsson、J.、J.Park、「グループ・オスア・セキュア・グループコミュニティー・コミュニケーション・コミュニケーション・コミュニケーション」、インターネットドラフト、draft-ietf-core-oscore-groupcomm-13,2021、&lt;https：//datatracker.ietf.org/doc/html/draft-ietf-core-oscore-groupComm-13&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NUMERIC-IDS] Gont, F. and I. Arce, &#34;On the Generation of Transient Numeric Identifiers&#34;, Work in Progress, Internet-Draft, draft-irtf-pearg-numeric-ids-generation-08, 31 January 2022, &lt;https://datatracker.ietf.org/doc/html/draft-irtf-pearg-numeric-ids-generation-08&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[数値ID] gont、f。およびI.ARCE、「一時的な数値識別子の生成」、進行中の作業、インターネットドラフト、ドラフトIRTF-Pearg-Numeric-IDS-Generation-08,28,2022&lt;https://datatracker.ietf.org/doc/html/draft-irtf-pearg-numeric -ids-generation-08&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[REST] Fielding, R., &#34;Architectural Styles and the Design of Network-based Software Architectures&#34;, 2000, &lt;https://www.ics.uci.edu/~fielding/pubs/dissertation/ fielding_dissertation.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[REST]フィールド化、R.、「ネットワークベースのソフトウェアアーキテクチャの設計」、2000、&lt;https：//www.ics.uci.edu/~fielding/pubs/dissertation/ fielding_dissertation.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7641] Hartke, K., &#34;Observing Resources in the Constrained Application Protocol (CoAP)&#34;, RFC 7641, DOI 10.17487/RFC7641, September 2015, &lt;https://www.rfc-editor.org/info/rfc7641&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7641] Hartke、K。、「制約付きアプリケーションプロトコル（CoAP）」、RFC 7641、DOI 10.17487 / RFC7641、2015年9月、&lt;https：//www.rfc-editor.org/info/rfc7641&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8323] Bormann, C., Lemay, S., Tschofenig, H., Hartke, K., Silverajan, B., and B. Raymor, Ed., &#34;CoAP (Constrained Application Protocol) over TCP, TLS, and WebSockets&#34;, RFC 8323, DOI 10.17487/RFC8323, February 2018, &lt;https://www.rfc-editor.org/info/rfc8323&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8323] Bormann、C、LeMay、S.、Tschofenig、H.、Hartke、K.、Silverajan、B.、およびB.Raymor、Ed。、TCP、TLS、およびWebocketsの上のCOAP（制約付きアプリケーションプロトコル）&#34;、RFC 8323、DOI 10.17487 / RFC8323、2018年2月、&lt;https：//www.rfc-editor.org/info/rfc8323&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8446] Rescorla, E., &#34;The Transport Layer Security (TLS) Protocol Version 1.3&#34;, RFC 8446, DOI 10.17487/RFC8446, August 2018, &lt;https://www.rfc-editor.org/info/rfc8446&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8446] RESCORLA、E。、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487 / RFC8446、&lt;https：//www.rfc-editor.org/info/rfc8446&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8974] Hartke, K. and M. Richardson, &#34;Extended Tokens and Stateless Clients in the Constrained Application Protocol (CoAP)&#34;, RFC 8974, DOI 10.17487/RFC8974, January 2021, &lt;https://www.rfc-editor.org/info/rfc8974&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8974] Hartke、K.およびM. Richardson、「制約付きアプリケーションプロトコル（COAAP）」、RFC 8974、DOI 10.17487 / RFC8974、&lt;https：///www.rfc-編集者の拡張トークンおよびステートレスクライアント。ORG / INFO / RFC8974&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9000] Iyengar, J., Ed. and M. Thomson, Ed., &#34;QUIC: A UDP-Based Multiplexed and Secure Transport&#34;, RFC 9000, DOI 10.17487/RFC9000, May 2021, &lt;https://www.rfc-editor.org/info/rfc9000&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9000] Iyengar、J.、ED。M. Thomson、ED。、「QUIC：UDPベースの多重化および安全な輸送」、RFC 9000、DOI 10.17487 / RFC9000、2021年5月、&lt;https：//www.rfc-editor.org/info/rfc9000&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--Methods-for-Generating-Echo-Option-Values">
Appendix A. Methods for Generating Echo Option Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A.エコーオプション値を生成する方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The content and structure of the Echo option value are implementation specific and determined by the server. Two simple mechanisms for time-based freshness and one for event-based freshness are outlined in this appendix. The &#34;List of Cached Random Values and Timestamps&#34; mechanism is RECOMMENDED in general. The &#34;Integrity-Protected Timestamp&#34; mechanism is RECOMMENDED in case the Echo option is encrypted between the client and the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エコーオプション値の内容と構造は、サーバーによって特定され決定された実装です。この付録には、時間ベースの鮮度とイベントベースの鮮度のためのもののための2つの簡単なメカニズムが概説されています。一般に「キャッシュされたランダム値とタイムスタンプのリスト」メカニズムをお勧めします。エコーオプションがクライアントとサーバーの間で暗号化されている場合、 &#34;Integrity-Protected Timestamp&#34;メカニズムが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Different mechanisms have different trade-offs between the size of the Echo option value, the amount of server state, the amount of computation, and the security properties offered. A server MAY use different methods and security levels for different use cases (client aliveness, request freshness, state synchronization, network address reachability, etc.).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エコーオプション値のサイズ、サーバーの状態、計算量、および提供されたセキュリティプロパティの間には、さまざまなメカニズムが異なります。サーバーは、さまざまなユースケース（クライアントアリティズ、リクエストの鮮度、状態同期、ネットワークアドレスの到達可能性など）に対して異なる方法とセキュリティレベルを使用することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. List of Cached Random Values and Timestamps. The Echo option value is a (pseudo)random byte string called r. The server caches a list containing the random byte strings and their initial transmission times. Assuming 72-bit random values and 32-bit timestamps, the size of the Echo option value is 9 bytes and the amount of server state is 13n bytes, where n is the number of active Echo option values. The security against an attacker guessing Echo option values is given by s = bit length of r - log2(n). The length of r and the maximum allowed n should be set so that the security level is harmonized with other parts of the deployment, e.g., s &gt;= 64. If the server loses time continuity, e.g., due to reboot, the entries in the old list MUST be deleted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. キャッシュされたランダム値とタイムスタンプのリスト。エコーオプション値は、Rと呼ばれる（疑似）ランダムバイト文字列です。サーバーは、ランダムバイト文字列とそれらの最初の送信時間を含むリストをキャッシュします。72ビットのランダム値と32ビットのタイムスタンプを仮定すると、エコーオプション値のサイズは9バイトで、サーバーの状態量は13nバイトです。ここで、nはアクティブなエコーオプション値の数です。エコーオプション値を推測する攻撃者に対するセキュリティは、r  -  log2（n）のs =ビット長によって与えられます。Rの長さと許容される最大値Nは、セキュリティレベルが展開の他の部分と調和されるように設定されるべきである。サーバが時間の継続性を失った場合、例えば再起動のために、古いリストは削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Echo option value: random value r
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
エコーオプション値：ランダム値R.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Server State: random value r, timestamp t0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
サーバーの状態：ランダム値R、タイムスタンプT0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
This method is suitable for both time-based and event-based freshness (e.g., by clearing the cache when an event occurs) and is independent of the client authority.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
この方法は、時間ベースとイベントベースの鮮度の両方に適しています（たとえば、イベントが発生したときにキャッシュをクリアすることによって）、クライアント権限とは無関係です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Integrity-Protected Timestamp. The Echo option value is an integrity-protected timestamp. The timestamp can have a different resolution and range. A 32-bit timestamp can, e.g., give a resolution of 1 second with a range of 136 years. The (pseudo)random secret key is generated by the server and not shared with any other party. The use of truncated HMAC-SHA-256 is RECOMMENDED. With a 32-bit timestamp and a 64-bit MAC, the size of the Echo option value is 12 bytes, and the server state is small and constant. The security against an attacker guessing Echo option values is given by the MAC length. If the server loses time continuity, e.g., due to reboot, the old key MUST be deleted and replaced by a new random secret key. Note that the privacy considerations in Section 6 may apply to the timestamp. Therefore, it might be important to encrypt it. Depending on the choice of encryption algorithms, this may require an initialization vector to be included in the Echo option value (see below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 完全性保護されたタイムスタンプエコーオプション値は、整合性保護されたタイムスタンプです。タイムスタンプは異なる解像度と範囲を持つことができます。32ビットタイムスタンプは、例えば136年の範囲で1秒の解像度を与えることができる。（疑似）ランダム秘密鍵はサーバーによって生成され、他のパーティーと共有されません。切り捨てられたHMAC-SHA-256の使用をお勧めします。32ビットのタイムスタンプと64ビットMACを使用すると、エコーオプションの値のサイズは12バイトで、サーバーの状態は小さくて一定です。エコーオプション値を推測する攻撃者に対するセキュリティは、MACの長さによって与えられます。サーバーが時間の継続性を失った場合、例えば再起動のため、古いキーを削除して新しいランダムな秘密鍵に置き換えなければなりません。セクション6のプライバシーに関する考慮事項はタイムスタンプに適用される場合があります。したがって、それを暗号化することが重要かもしれません。暗号化アルゴリズムの選択に応じて、これはエコーオプション値に初期化ベクトルを含める必要があるかもしれません（下記参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Echo option value: timestamp t0, MAC(k, t0)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
エコーオプション値：TIMESTAMP T0、MAC（K、T0）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Server State: secret key k
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
サーバーの状態：秘密鍵K
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
This method is suitable for both time-based and event-based freshness (by the server remembering the time at which the event took place) and independent of the client authority.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
この方法は、（イベントが発生した時刻を覚えているサーバーによって）、クライアント権限とは無関係に、時間ベースとイベントベースの鮮度の両方に適しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
If this method is used to additionally obtain network reachability of the client, the server MUST use the client&#39;s network address too, e.g., as in MAC(k, t0, claimed network address).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
この方法がクライアントのネットワーク到達可能性を追加的に取得するために使用される場合、サーバは、例えばMAC（k、t0、クレームされたネットワークアドレス）のように、クライアントのネットワークアドレスも使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Persistent Counter. This can be used in OSCORE for sequence number recovery, per Appendix B.1.2 of [RFC8613]. The Echo option value is a simple counter without integrity protection of its own, serialized in uint format. The counter is incremented in a persistent way every time the state that needs to be synchronized is changed (in the case described in Appendix B.1.2 of [RFC8613], when a reboot indicates that volatile state may have been lost). An example of how such a persistent counter can be implemented efficiently is the OSCORE server Sender Sequence Number mechanism described in Appendix B.1.1 of [RFC8613].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 永続的なカウンターこれは[RFC8613]の付録B.1.2ごとに、シーケンス番号の回復のためにオスアートで使用できます。エコーオプション値は、UINTフォーマットでシリアル化された、独自の保護なしに単純なカウンタです。同期させる必要がある状態が変更されるたびにカウンタが永続的な方法でインクリメントされます（[RFC8613]の[RFC8613]の付録B.1.2に記載されている場合は、揮発性の状態が失われた可能性があることを示します）。そのような永続カウンタを効率的に実装できる方法の例は、[RFC8613]の付録B.1.1に記載されているOSCOREサーバ送信者シーケンス番号メカニズムである。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Echo option value: counter
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
エコーオプション値：カウンタ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Server State: counter
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
サーバーの状態：カウンター
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
This method is suitable only if the client is the authority over the synchronized property. Consequently, it cannot be used to show client aliveness. It provides statements from the client similar to event-based freshness (but without a proof of freshness).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
この方法は、クライアントが同期プロパティに対する権限である場合にのみ適しています。その結果、クライアントの競争力を示すために使用することはできません。イベントベースの鮮度と同様のクライアントからのステートメントを提供します（ただし鮮度の証明なし）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other mechanisms complying with the security and privacy considerations may be used. The use of encrypted timestamps in the Echo option provides additional protection but typically requires an initialization vector (a.k.a. nonce) as input to the encryption algorithm, which adds a slight complication to the procedure as well as overhead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティとプライバシーの考慮事項に準拠した他のメカニズムを使用することができます。エコーオプション内の暗号化タイムスタンプの使用は追加の保護を提供しますが、通常、暗号化アルゴリズムへの入力として初期化ベクトル（A.K.A.NONCE）を必要とします。これにより、オーバーヘッドとわずかな複雑化を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-B--Request-Tag-Message-Size-Impact">
Appendix B. Request-Tag Message Size Impact
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録B. request-tagメッセージサイズのImpact
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In absence of concurrent operations, the Request-Tag mechanism for body integrity (Section 3.5.1) incurs no overhead if no messages are lost (more precisely, in OSCORE, if no operations are aborted due to repeated transmission failure and, in DTLS, if no packets are lost and replay protection is active) or when block-wise request operations happen rarely (in OSCORE, if there is always only one request block-wise operation in the replay window).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同時操作がない場合、メッセージが失われなかった場合、Body Integrityの要求タグメカニズム（3.5.1項）は、メッセージが失われなかった場合はオーバーヘッドはありません（より正確には、送信失敗の繰り返しのために中止されず、DTLSでは、パケットが失われず、再生保護がアクティブになっていない場合、またはブロックごとの要求操作がめったに発生した場合（オスアの場合は、再生ウィンドウで常に1つの要求ブロック単位の操作である場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In those situations, no message has any Request-Tag option set, and the Request-Tag value can be recycled indefinitely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのような状況では、メッセージなしの要求タグオプションセットがあり、要求タグの値は無期限にリサイクルできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the absence of a Request-Tag option cannot be recycled any more within a security context, the messages with a present but empty Request-Tag option can be used (1 byte overhead), and when that is used up, 256 values from 1-byte options (2 bytes overhead) are available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
request-tagオプションの欠如をセキュリティコンテキスト内でリサイクルできない場合は、現在のが空のREQUEST-TAGオプションを持つメッセージを使用できます（1バイトのオーバーヘッド）、およびそれが使用されているときは、1から256の値を使用できます。-byteオプション（2バイトのオーバーヘッド）が利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In situations where that overhead is unacceptable (e.g., because the payloads are known to be at a fragmentation threshold), the absent Request-Tag value can be made usable again:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのオーバーヘッドが許容できない場合（例えば、ペイロードが断片化しきい値にあることが知られているので）、存在しない要求タグ値を再び使用可能にすることができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* In DTLS, a new session can be established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* DTLSでは、新しいセッションを確立できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* In OSCORE, the sequence number can be artificially increased so that all lost messages are outside of the replay window by the time the first request of the new operation gets processed, and all earlier operations can therefore be regarded as concluded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* OSCOREでは、新しい操作の最初の要求の最初の要求が処理されるまでに、すべての失われたメッセージが再生ウィンドウの外側にあるようにシーケンス番号を人為的に増やすことができ、それ故、すべての以前の操作は終了したと見なすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors want to thank Carsten Bormann, Roman Danyliw, Benjamin Kaduk, Murray Kucherawy, Francesca Palombini, and Jim Schaad for providing valuable input to the document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者らは、Carsten Bormann、Roman Danyliw、Benjamin Kaduk、Murray Kucherawy、Francesca Palombini、Jim Schaadに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者の住所
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Christian Amsüss Email: christian@amsuess.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ChristianAmsüsssメール：Christian@amsuess.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
John Preuß Mattsson Ericsson AB Email: john.mattsson@ericsson.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JohnPreußMattssonEricsson AB Eメール：john.mattsson@ericsson.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Göran Selander Ericsson AB Email: goran.selander@ericsson.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GöranSelander Ericsson AB Eメール：Goran.Selander@ericsson.com
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
