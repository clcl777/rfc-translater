<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 9001 - Using TLS to Secure QUIC 日本語訳</title>
  <meta name="description" content="RFC 9001は、QUICプロトコルのセキュリティをTLS 1.3を用いて強化する方法について記述しています。この文書では、QUICの信頼性と効率を保ちつつ、通信の機密性、完全性、認証を確保するためのTLSの利用方法を定義しています。QUICは主にウェブブラウジング、ライブストリーミング、クラウドサービスなどのインターネットアプリケーションでの使用を目的としており、関連するRFCにはRFC 9000（QUICプロトコルの概要）、RFC 9002（QUICの輻輳制御）、RFC 8999（QUICのバージョニング）などがあります。">

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">9001</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc9001">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 9001 - Using TLS to Secure QUIC 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc9001">
            https://datatracker.ietf.org/doc/html/rfc9001
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 9001 - TLSによるQUICの保護</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成 + 一部修正</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] RFC 9001は、QUICプロトコルのセキュリティをTLS 1.3を用いて強化する方法について記述しています。この文書では、QUICの信頼性と効率を保ちつつ、通信の機密性、完全性、認証を確保するためのTLSの利用方法を定義しています。QUICは主にウェブブラウジング、ライブストリーミング、クラウドサービスなどのインターネットアプリケーションでの使用を目的としており、関連するRFCにはRFC 9000（QUICプロトコルの概要）、RFC 9002（QUICの輻輳制御）、RFC 8999（QUICのバージョニング）などがあります。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                   M. Thomson, Ed.
Request for Comments: 9001                                       Mozilla
Category: Standards Track                                 S. Turner, Ed.
ISSN: 2070-1721                                                    sn3rd
                                                                May 2021
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
Using TLS to Secure QUIC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
TLSによるQUICの保護
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes how Transport Layer Security (TLS) is used to secure QUIC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、トランスポートレイヤのセキュリティ（TLS）を使用してQUICを保護する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはインターネット規格のトラック文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表します。それは公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による出版の承認を受けました。インターネット規格に関する詳細情報は、RFC 7841のセクション2で利用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書の現在のステータス、任意のエラータ、およびフィードバックを提供する方法は、https://www.rfc-editor.org/info/rfc9001で取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2021 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2021 IETF信頼と文書著者として識別された人。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、このドキュメントの発行日に有効なBCP 78およびIETFドキュメントに関連するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するお客様の権利と制限について説明しているため、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust LegalProvisionsのセクション4.eで説明されているSimplifiedBSD Licenseテキストが含まれている必要があり、Simplified BSDLicenseで説明されているように保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction
   2.  Notational Conventions
     2.1.  TLS Overview
   3.  Protocol Overview
   4.  Carrying TLS Messages
     4.1.  Interface to TLS
       4.1.1.  Handshake Complete
       4.1.2.  Handshake Confirmed
       4.1.3.  Sending and Receiving Handshake Messages
       4.1.4.  Encryption Level Changes
       4.1.5.  TLS Interface Summary
     4.2.  TLS Version
     4.3.  ClientHello Size
     4.4.  Peer Authentication
     4.5.  Session Resumption
     4.6.  0-RTT
       4.6.1.  Enabling 0-RTT
       4.6.2.  Accepting and Rejecting 0-RTT
       4.6.3.  Validating 0-RTT Configuration
     4.7.  HelloRetryRequest
     4.8.  TLS Errors
     4.9.  Discarding Unused Keys
       4.9.1.  Discarding Initial Keys
       4.9.2.  Discarding Handshake Keys
       4.9.3.  Discarding 0-RTT Keys
   5.  Packet Protection
     5.1.  Packet Protection Keys
     5.2.  Initial Secrets
     5.3.  AEAD Usage
     5.4.  Header Protection
       5.4.1.  Header Protection Application
       5.4.2.  Header Protection Sample
       5.4.3.  AES-Based Header Protection
       5.4.4.  ChaCha20-Based Header Protection
     5.5.  Receiving Protected Packets
     5.6.  Use of 0-RTT Keys
     5.7.  Receiving Out-of-Order Protected Packets
     5.8.  Retry Packet Integrity
   6.  Key Update
     6.1.  Initiating a Key Update
     6.2.  Responding to a Key Update
     6.3.  Timing of Receive Key Generation
     6.4.  Sending with Updated Keys
     6.5.  Receiving with Different Keys
     6.6.  Limits on AEAD Usage
     6.7.  Key Update Error Code
   7.  Security of Initial Messages
   8.  QUIC-Specific Adjustments to the TLS Handshake
     8.1.  Protocol Negotiation
     8.2.  QUIC Transport Parameters Extension
     8.3.  Removing the EndOfEarlyData Message
     8.4.  Prohibit TLS Middlebox Compatibility Mode
   9.  Security Considerations
     9.1.  Session Linkability
     9.2.  Replay Attacks with 0-RTT
     9.3.  Packet Reflection Attack Mitigation
     9.4.  Header Protection Analysis
     9.5.  Header Protection Timing Side Channels
     9.6.  Key Diversity
     9.7.  Randomness
   10. IANA Considerations
   11. References
     11.1.  Normative References
     11.2.  Informative References
   Appendix A.  Sample Packet Protection
     A.1.  Keys
     A.2.  Client Initial
     A.3.  Server Initial
     A.4.  Retry
     A.5.  ChaCha20-Poly1305 Short Header Packet
   Appendix B.  AEAD Algorithm Analysis
     B.1.  Analysis of AEAD_AES_128_GCM and AEAD_AES_256_GCM Usage
           Limits
       B.1.1.  Confidentiality Limit
       B.1.2.  Integrity Limit
     B.2.  Analysis of AEAD_AES_128_CCM Usage Limits
   Contributors
   Authors&#39; Addresses
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes how QUIC [QUIC-TRANSPORT] is secured using TLS [TLS13].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、TLS [TLS13]を使用してQUIC [QUIC-TRANSPORT]が保護される方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS 1.3 provides critical latency improvements for connection establishment over previous versions. Absent packet loss, most new connections can be established and secured within a single round trip; on subsequent connections between the same client and server, the client can often send application data immediately, that is, using a zero round-trip setup.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS 1.3は、以前のバージョンに対する接続確立のための重要な待ち時間の改善を提供します。不在のパケット損失、ほとんどの新しい接続は、1回のラウンドトリップ内で確立され保護されます。同じクライアントとサーバー間の後続の接続で、クライアントはすぐにアプリケーションデータを送信することができます。つまり、ゼロの往復設定を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes how TLS acts as a security component of QUIC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、TLSがQUICのセキュリティコンポーネントとして機能する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Notational-Conventions">
2. Notational Conventions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 表記規則
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, および &#34;OPTIONAL&#34; はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document uses the terminology established in [QUIC-TRANSPORT].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は[QUIC-TRANSPORT]で確立された用語を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For brevity, the acronym TLS is used to refer to TLS 1.3, though a newer version could be used; see Section 4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
簡潔にするために、Acronym TLSはTLS 1.3を参照するために使用されますが、新しいバージョンは使用できます。セクション4.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1--TLS-Overview">
2.1. TLS Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. TLSの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS provides two endpoints with a way to establish a means of communication over an untrusted medium (for example, the Internet). TLS enables authentication of peers and provides confidentiality and integrity protection for messages that endpoints exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSは、信頼されていない媒体（例えば、インターネット）を介して通信手段を確立する方法で2つのエンドポイントを提供します。TLSはピアの認証を可能にし、エンドポイントをエンドポイントするメッセージの機密性と整合性保護を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Internally, TLS is a layered protocol, with the structure shown in Figure 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
内部的には、TLSは積層プロトコルであり、図1に示す構造を有する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             +-------------+------------+--------------+---------+
   Content   |             |            |  Application |         |
   Layer     |  Handshake  |   Alerts   |     Data     |   ...   |
             |             |            |              |         |
             +-------------+------------+--------------+---------+
   Record    |                                                   |
   Layer     |                      Records                      |
             |                                                   |
             +---------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-28">
Figure 1: TLS Layers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-28">
図1：TLSレイヤー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each content-layer message (e.g., handshake, alerts, and application data) is carried as a series of typed TLS records by the record layer. Records are individually cryptographically protected and then transmitted over a reliable transport (typically TCP), which provides sequencing and guaranteed delivery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各コンテンツレイヤメッセージ（例えば、ハンドシェイク、アラート、およびアプリケーションデータ）は、レコードレイヤによって一連の型付きTLSレコードとして実行される。レコードは個別に暗号的に保護されてから、シーケンスと保証された配信を提供する信頼できるトランスポート（通常はTCP）を介して送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS authenticated key exchange occurs between two endpoints: client and server. The client initiates the exchange and the server responds. If the key exchange completes successfully, both client and server will agree on a secret. TLS supports both pre-shared key (PSK) and Diffie-Hellman over either finite fields or elliptic curves ((EC)DHE) key exchanges. PSK is the basis for Early Data (0-RTT); the latter provides forward secrecy (FS) when the (EC)DHE keys are destroyed. The two modes can also be combined to provide forward secrecy while using the PSK for authentication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS認証済みキー交換は、クライアントとサーバーの2つのエンドポイント間で発生します。クライアントはExchangeを開始し、サーバーが応答します。キー交換が正常に完了した場合、クライアントとサーバーの両方が秘密に同意されます。TLSは、有限フィールドまたは楕円曲線（（EC）DHE）キー交換のいずれかを介して、事前共有キー（PSK）とDiffie-Hellmanの両方をサポートします。PSKは早期データ（0-RTT）の基礎です。後者は、（EC）DHEキーが破壊されたときに前方秘密（FS）を提供します。認証用のPSKを使用しながら、2つのモードを組み合わせて順序を付けることもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After completing the TLS handshake, the client will have learned and authenticated an identity for the server, and the server is optionally able to learn and authenticate an identity for the client. TLS supports X.509 [RFC5280] certificate-based authentication for both server and client. When PSK key exchange is used (as in resumption), knowledge of the PSK serves to authenticate the peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSハンドシェイクを完了した後、クライアントはサーバーのIDを学習および認証し、サーバーはオプションでクライアントのIDを学習し認証できます。TLSは、サーバーとクライアントの両方のX.509 [RFC5280]証明書ベース認証をサポートしています。PSKキー交換が使用されている場合（再開のように）、PSKの知識はピアを認証するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS key exchange is resistant to tampering by attackers, and it produces shared secrets that cannot be controlled by either participating peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS鍵交換は攻撃者による改ざんに耐性があり、参加しているピアのどちらかによって制御できない共有秘密を生み出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS provides two basic handshake modes of interest to QUIC:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSは、QUICに興味のある2つの基本的なハンドシェイクモードを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* A full 1-RTT handshake, in which the client is able to send application data after one round trip and the server immediately responds after receiving the first handshake message from the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* クライアントが1回のラウンドトリップ後にアプリケーションデータを送信できるフル1-RTTハンドシェイクと、サーバーはすぐに応答し、クライアントから最初のハンドシェイクメッセージを受信した後に応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* A 0-RTT handshake, in which the client uses information it has previously learned about the server to send application data immediately. This application data can be replayed by an attacker, so 0-RTT is not suitable for carrying instructions that might initiate any action that could cause unwanted effects if replayed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* クライアントがアプリケーションデータをすぐに送信するためにサーバーについて以前に学習した情報を使用している0-RTTハンドシェイク。このアプリケーションデータは攻撃者によって再生することができ、0-RTTは、再生された場合に不要な効果を引き起こす可能性がある行動を起こす可能性がある命令を搬送するのには適していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A simplified TLS handshake with 0-RTT application data is shown in Figure 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0-RTTアプリケーションデータを備えた簡易TLSハンドシェイクを図2に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Client                                             Server
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       ClientHello
      (0-RTT Application Data)  --------&gt;
                                                     ServerHello
                                            {EncryptedExtensions}
                                                       {Finished}
                                &lt;--------      [Application Data]
      {Finished}                --------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      [Application Data]        &lt;-------&gt;      [Application Data]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       () Indicates messages protected by Early Data (0-RTT) Keys
       {} Indicates messages protected using Handshake Keys
       [] Indicates messages protected using Application Data
          (1-RTT) Keys
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
Figure 2: TLS Handshake with 0-RTT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
図2：0-RTTのTLSハンドシェイク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 2 omits the EndOfEarlyData message, which is not used in QUIC; see Section 8.3.  Likewise, neither ChangeCipherSpec nor KeyUpdate messages are used by QUIC.  ChangeCipherSpec is redundant in TLS 1.3; see Section 8.4.  QUIC has its own key update mechanism; see Section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図2は、QUICでは使用されないEndOfEarlyDataメッセージを省略しています。 セクション8.3を参照してください。 同様に、ChangeCipherSpecメッセージもKeyUpdateメッセージもQUICでは使用されません。 ChangeCipherSpecはTLS1.3では冗長です。 セクション8.4を参照してください。 QUICには独自のキー更新メカニズムがあります。 セクション6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data is protected using a number of encryption levels:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データは多数の暗号化レベルを使用して保護されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Initial keys
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 初期キー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Early data (0-RTT) keys
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 初期データ（0-RTT）キー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Handshake keys
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ハンドシェイクキー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Application data (1-RTT) keys
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* アプリケーションデータ（1 RTT）キー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Application data can only appear in the early data and application data levels. Handshake and alert messages may appear in any level.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションデータは、初期のデータレベルとアプリケーションのデータレベルにのみ表示できます。ハンドシェイクと警告メッセージは任意のレベルで表示されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The 0-RTT handshake can be used if the client and server have previously communicated. In the 1-RTT handshake, the client is unable to send protected application data until it has received all of the handshake messages sent by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーが以前に伝達された場合、0-RTTハンドシェイクを使用できます。1-RTTハンドシェイクで、クライアントはサーバーによって送信されたすべてのハンドシェイクメッセージを受信するまで保護されたアプリケーションデータを送信できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Protocol-Overview">
3. Protocol Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. プロトコルの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC [QUIC-TRANSPORT] assumes responsibility for the confidentiality and integrity protection of packets. For this it uses keys derived from a TLS handshake [TLS13], but instead of carrying TLS records over QUIC (as with TCP), TLS handshake and alert messages are carried directly over the QUIC transport, which takes over the responsibilities of the TLS record layer, as shown in Figure 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC [QUIC-TRANSPORT]パケットの機密性と整合性保護について責任を負います。これはTLSハンドシェイク[TLS13]から派生したキーを使用していますが、（TCPと同様に）TLSレコードを介してTLSレコードを運ぶのではなく、TLSハンドシェイクとアラートメッセージはTLSレコードの責任を引き継ぐQUICのトランスポートで直接伝送されます。図3に示すように、レイヤー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------------+--------------+ +-------------+
   |     TLS      |     TLS      | |    QUIC     |
   |  Handshake   |    Alerts    | | Applications|
   |              |              | |  (h3, etc.) |
   +--------------+--------------+-+-------------+
   |                                             |
   |                QUIC Transport               |
   |   (streams, reliability, congestion, etc.)  |
   |                                             |
   +---------------------------------------------+
   |                                             |
   |            QUIC Packet Protection           |
   |                                             |
   +---------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
Figure 3: QUIC Layers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
図3：QUICレイヤー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC also relies on TLS for authentication and negotiation of parameters that are critical to security and performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICはまた、セキュリティとパフォーマンスにとって重要なパラメータの認証とネゴシエーションのためのTLSに依存しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rather than a strict layering, these two protocols cooperate: QUIC uses the TLS handshake; TLS uses the reliability, ordered delivery, and record layer provided by QUIC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
厳密な階層化ではなく、これら2つのプロトコルは協力します。QUICはTLSハンドシェイクを使用します。TLSは、QUICによって提供される信頼性、注文配信、および記録層を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At a high level, there are two main interactions between the TLS and QUIC components:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高レベルでは、TLSとQUICコンポーネントの間には2つの主な対話があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The TLS component sends and receives messages via the QUIC component, with QUIC providing a reliable stream abstraction to TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* TLSコンポーネントは、QUICコンポーネントを介してメッセージを送受信し、信頼性の高いストリーム抽象化をTLSに提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The TLS component provides a series of updates to the QUIC component, including (a) new packet protection keys to install and (b) state changes such as handshake completion, the server certificate, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* TLSコンポーネントは、（a）インストールする新しいパケット保護キーを含む、QUICコンポーネントに一連の更新を提供し、ハンドシェイクの完了、サーバー証明書などの状態の変化
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 4 shows these interactions in more detail, with the QUIC packet protection being called out specially.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図4は、これらの相互作用をより詳細に示しており、QUICのパケット保護が特別に呼び出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------+                               +------------+
   |            |&lt;---- Handshake Messages -----&gt;|            |
   |            |&lt;- Validate 0-RTT Parameters -&gt;|            |
   |            |&lt;--------- 0-RTT Keys ---------|            |
   |    QUIC    |&lt;------- Handshake Keys -------|    TLS     |
   |            |&lt;--------- 1-RTT Keys ---------|            |
   |            |&lt;------- Handshake Done -------|            |
   +------------+                               +------------+
    |         ^
    | Protect | Protected
    v         | Packet
   +------------+
   |   QUIC     |
   |  Packet    |
   | Protection |
   +------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
Figure 4: QUIC and TLS Interactions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
図4：QUICとTLSのインタラクション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike TLS over TCP, QUIC applications that want to send data do not send it using TLS Application Data records. Rather, they send it as QUIC STREAM frames or other frame types, which are then carried in QUIC packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPを介したTLSとは異なり、データを送信したいQUICアプリケーションはTLSアプリケーションデータレコードを使用して送信しません。むしろ、それらはそれをQUICのストリームフレームまたは他のフレームタイプとして送信し、それはその後QUICのパケットで運ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Carrying-TLS-Messages">
4. Carrying TLS Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. TLSメッセージを運ぶ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC carries TLS handshake data in CRYPTO frames, each of which consists of a contiguous block of handshake data identified by an offset and length. Those frames are packaged into QUIC packets and encrypted under the current encryption level. As with TLS over TCP, once TLS handshake data has been delivered to QUIC, it is QUIC&#39;s responsibility to deliver it reliably. Each chunk of data that is produced by TLS is associated with the set of keys that TLS is currently using. If QUIC needs to retransmit that data, it MUST use the same keys even if TLS has already updated to newer keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICは、CryptoフレームでTLSハンドシェイクデータを搬送します。各々は、オフセットと長さによって識別されるハンドシェイクデータの連続ブロックからなる。これらのフレームはQUICパケットにパッケージ化され、現在の暗号化レベルで暗号化されています。TLSを介したTLSと同様に、TLSハンドシェイクデータがQUICに配信されたら、それを確実に配信することはQUICの責任です。TLSによって生成されるデータの各チャンクは、TLSが現在使用されているキーのセットに関連付けられています。QUICがそのデータを再送信する必要がある場合は、TLSがすでに新しいキーに更新されている場合でも同じキーを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each encryption level corresponds to a packet number space. The packet number space that is used determines the semantics of frames. Some frames are prohibited in different packet number spaces; see Section 12.5 of [QUIC-TRANSPORT].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各暗号化レベルはパケット番号スペースに対応する。使用されるパケット番号スペースは、フレームのセマンティクスを決定します。いくつかのフレームは異なるパケット番号スペースで禁止されています。[QUIC-TRANSPORT]の12.5項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because packets could be reordered on the wire, QUIC uses the packet type to indicate which keys were used to protect a given packet, as shown in Table 1. When packets of different types need to be sent, endpoints SHOULD use coalesced packets to send them in the same UDP datagram.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットはワイヤ上で並べ替えることができるので、QUICはパケットタイプを使用して、表1に示すように、指定されたパケットを保護するために使用されたキーを使用しているかを示します。さまざまなタイプのパケットを送信する必要がある場合、エンドポイントはそれらを送信するために合体パケットを使用する必要があります。同じUDPデータグラムに。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       +=====================+=================+==================+
       | Packet Type         | Encryption Keys | PN Space         |
       +=====================+=================+==================+
       | Initial             | Initial secrets | Initial          |
       +=====================+-----------------+------------------+
       | 0-RTT Protected     | 0-RTT           | Application data |
       +=====================+-----------------+------------------+
       | Handshake           | Handshake       | Handshake        |
       +=====================+-----------------+------------------+
       | Retry               | Retry           | N/A              |
       +=====================+-----------------+------------------+
       | Version Negotiation | N/A             | N/A              |
       +=====================+-----------------+------------------+
       | Short Header        | 1-RTT           | Application data |
       +=====================+-----------------+------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
Table 1: Encryption Keys by Packet Type
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
表1：パケットタイプによる暗号化キー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 17 of [QUIC-TRANSPORT] shows how packets at the various encryption levels fit into the handshake process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[QUIC-TRANSPORT]のセクション17は、さまざまな暗号化レベルのパケットがハンドシェイクプロセスにどのように収まるかを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Interface-to-TLS">
4.1. Interface to TLS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. TLSへのインタフェース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As shown in Figure 4, the interface from QUIC to TLS consists of four primary functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図4に示すように、QUICからTLSへのインターフェイスは4つの主な機能で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Sending and receiving handshake messages
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ハンドシェイクメッセージの送受信
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Processing stored transport and application state from a resumed session and determining if it is valid to generate or accept 0-RTT data
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 再開セッションからストアドトランスポートとアプリケーションの状態を処理し、0-RTTデータを生成または受け入れることが有効であるかどうかを判断します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Rekeying (both transmit and receive)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* REKEING（送信と受信）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Updating handshake state
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ハンドシェイク状態の更新
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional functions might be needed to configure TLS. In particular, QUIC and TLS need to agree on which is responsible for validation of peer credentials, such as certificate validation [RFC5280].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSを構成するには追加の機能が必要になる場合があります。特に、QUICとTLSは、証明書検証[RFC5280]などのピア資格情報の検証を担当することに同意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1-1--Handshake-Complete">
4.1.1. Handshake Complete
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. ハンドシェイクを完了します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this document, the TLS handshake is considered complete when the TLS stack has reported that the handshake is complete. This happens when the TLS stack has both sent a Finished message and verified the peer&#39;s Finished message. Verifying the peer&#39;s Finished message provides the endpoints with an assurance that previous handshake messages have not been modified. Note that the handshake does not complete at both endpoints simultaneously. Consequently, any requirement that is based on the completion of the handshake depends on the perspective of the endpoint in question.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、TLSスタックがハンドシェイクが完了したことを報告したときに、TLSハンドシェイクが完了したと見なされます。これは、TLSスタックが完成したメッセージを送信してピアの完成メッセージを検証したときに発生します。ピアの完成メッセージの検証は、以前のハンドシェイクメッセージが変更されていない保証を持つエンドポイントを提供します。ハンドシェイクは両方のエンドポイントで同時に完了しないことに注意してください。したがって、ハンドシェイクの完了に基づく要件は、問題のエンドポイントの観点によって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1-2--Handshake-Confirmed">
4.1.2. Handshake Confirmed
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. 握手が確認されました
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this document, the TLS handshake is considered confirmed at the server when the handshake completes. The server MUST send a HANDSHAKE_DONE frame as soon as the handshake is complete. At the client, the handshake is considered confirmed when a HANDSHAKE_DONE frame is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、ハンドシェイクが完了したときにTLSハンドシェイクがサーバーで確認されたと見なされます。ハンドシェイクが完了したら、サーバーはhandshake_doneフレームを送信する必要があります。クライアントでは、handshake_doneフレームが受信されたときにハンドシェイクが確認されたと見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, a client MAY consider the handshake to be confirmed when it receives an acknowledgment for a 1-RTT packet. This can be implemented by recording the lowest packet number sent with 1-RTT keys and comparing it to the Largest Acknowledged field in any received 1-RTT ACK frame: once the latter is greater than or equal to the former, the handshake is confirmed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、クライアントは、1-RTTパケットの確認応答を受け取ったときにハンドシェイクを確認することを検討することができます。これは、1-RTTキーで送信され、それを受信した1 RTT ACKフレームの最大の確認フィールドと比較してそれを比較することによって実装できます。後者が前者以上であると、ハンドシェイクが確認されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1-3--Sending-and-Receiving-Handshake-Messages">
4.1.3. Sending and Receiving Handshake Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3. ハンドシェイクメッセージの送受信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to drive the handshake, TLS depends on being able to send and receive handshake messages. There are two basic functions on this interface: one where QUIC requests handshake messages and one where QUIC provides bytes that comprise handshake messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハンドシェイクを駆動するために、TLSはハンドシェイクメッセージを送受信できることに依存します。このインターフェイスには2つの基本機能があります。QUICがハンドシェイクメッセージとQUICがハンドシェイクメッセージを含むバイトを提供する1つです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before starting the handshake, QUIC provides TLS with the transport parameters (see Section 8.2) that it wishes to carry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハンドシェイクを始める前に、QUICはキャリーを希望するトランスポートパラメータ（セクション8.2参照）を持つTLSを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A QUIC client starts TLS by requesting TLS handshake bytes from TLS. The client acquires handshake bytes before sending its first packet. A QUIC server starts the process by providing TLS with the client&#39;s handshake bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSからTLSハンドシェイクバイトを要求することで、QUICクライアントがTLSを開始します。クライアントは最初のパケットを送信する前にハンドシェイクバイトを取得します。クライアントのハンドシェイクバイトを使用してTLSを提供することで、QUICサーバーがプロセスを開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At any time, the TLS stack at an endpoint will have a current sending encryption level and a receiving encryption level. TLS encryption levels determine the QUIC packet type and keys that are used for protecting data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いつでも、エンドポイントのTLSスタックは、現在の送信暗号化レベルと受信暗号化レベルを持ちます。TLS暗号化レベルは、データを保護するために使用されるQUICパケットタイプとキーを決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each encryption level is associated with a different sequence of bytes, which is reliably transmitted to the peer in CRYPTO frames. When TLS provides handshake bytes to be sent, they are appended to the handshake bytes for the current encryption level. The encryption level then determines the type of packet that the resulting CRYPTO frame is carried in; see Table 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各暗号化レベルは、暗号フレーム内のピアに確実に伝送される異なる一連のバイトに関連付けられています。TLSが送信されるハンドシェイクバイトを提供するとき、それらは現在の暗号化レベルのハンドシェイクバイトに追加されます。暗号化レベルは次に、結果の暗号フレームが搬送されるパケットの種類を決定する。表1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Four encryption levels are used, producing keys for Initial, 0-RTT, Handshake, and 1-RTT packets. CRYPTO frames are carried in just three of these levels, omitting the 0-RTT level. These four levels correspond to three packet number spaces: Initial and Handshake encrypted packets use their own separate spaces; 0-RTT and 1-RTT packets use the application data packet number space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4つの暗号化レベルが使用され、初期、0-RTT、ハンドシェイク、および1-RTTパケットのキーを生成します。Cryptoフレームは、0-RTTレベルを省略して、これらのレベルの3つだけで搭載されています。これら4つのレベルは3つのパケット番号のスペースに対応します。初期およびハンドシェイクの暗号化パケットは、独自の個別のスペースを使用します。0-RTTパケットと1-RTTパケットはアプリケーションデータパケット番号スペースを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC takes the unprotected content of TLS handshake records as the content of CRYPTO frames. TLS record protection is not used by QUIC. QUIC assembles CRYPTO frames into QUIC packets, which are protected using QUIC packet protection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICは、Cryptoフレームの内容として、保護されていないTLSハンドシェイクレコードの内容を取ります。TLSレコード保護はQUICでは使用されません。QUICはCryptoフレームをQUICパケットに組み立てます。これは、QUICのパケット保護を使用して保護されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC CRYPTO frames only carry TLS handshake messages. TLS alerts are turned into QUIC CONNECTION_CLOSE error codes; see Section 4.8. TLS application data and other content types cannot be carried by QUIC at any encryption level; it is an error if they are received from the TLS stack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC CryptoフレームはTLSハンドシェイクメッセージのみを伝送します。TLSアラートはQUIC接続_closeエラーコードに変わります。セクション4.8を参照してください。TLSアプリケーションデータおよび他のコンテンツタイプは、任意の暗号化レベルでQUICによって実行できません。TLSスタックから受信した場合はエラーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an endpoint receives a QUIC packet containing a CRYPTO frame from the network, it proceeds as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントがネットワークから暗号フレームを含むQUICパケットを受信すると、次のように進行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If the packet uses the current TLS receiving encryption level, sequence the data into the input flow as usual. As with STREAM frames, the offset is used to find the proper location in the data sequence. If the result of this process is that new data is available, then it is delivered to TLS in order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* パケットが暗号化レベルを受信した現在のTLSを使用している場合は、通常のようにデータを入力フローにシーケンスします。ストリームフレームと同様に、オフセットはデータシーケンス内の適切な場所を見つけるために使用されます。このプロセスの結果が新しいデータが利用可能であることである場合、それは順番にTLSに配信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If the packet is from a previously installed encryption level, it MUST NOT contain data that extends past the end of previously received data in that flow. Implementations MUST treat any violations of this requirement as a connection error of type PROTOCOL_VIOLATION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* パケットが以前にインストールされた暗号化レベルからのものである場合、そのフロー内の以前に受信したデータの終わりを経て拡張されたデータを含める必要はありません。実装は、この要求の違反をType Protocol_Violationの接続エラーとして扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If the packet is from a new encryption level, it is saved for later processing by TLS. Once TLS moves to receiving from this encryption level, saved data can be provided to TLS. When TLS provides keys for a higher encryption level, if there is data from a previous encryption level that TLS has not consumed, this MUST be treated as a connection error of type PROTOCOL_VIOLATION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* パケットが新しい暗号化レベルからのものである場合は、後でTLSによる処理のために保存されます。TLSがこの暗号化レベルから受信に移動すると、保存されたデータをTLSに提供することができます。TLSがより高い暗号化レベルのキーを提供するとき、TLSが消費されていない以前の暗号化レベルからのデータがある場合、これはPROTOCOL_VIOLATION型の接続エラーとして扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each time that TLS is provided with new data, new handshake bytes are requested from TLS. TLS might not provide any bytes if the handshake messages it has received are incomplete or it has no data to send.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSに新しいデータが付属しているたびに、新しいハンドシェイクバイトがTLSから要求されます。受信したハンドシェイクメッセージが不完全である場合、または送信するデータがない場合、TLSはバイトを提供しない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The content of CRYPTO frames might either be processed incrementally by TLS or buffered until complete messages or flights are available. TLS is responsible for buffering handshake bytes that have arrived in order. QUIC is responsible for buffering handshake bytes that arrive out of order or for encryption levels that are not yet ready. QUIC does not provide any means of flow control for CRYPTO frames; see Section 7.5 of [QUIC-TRANSPORT].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号フレームの内容は、完全なメッセージやフライトが利用可能になるまで、TLSによって徐々に処理されるか、またはバッファされている可能性があります。TLSは、順番に到着したハンドシェイクバイトをバッファリングする責任があります。QUICは、順不同またはまだ準備ができていない暗号化レベルのために到着したハンドシェイクバイトをバッファリングする責任があります。QUICは暗号フレームのフロー制御手段を提供しません。[QUIC-TRANSPORT]のセクション7.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the TLS handshake is complete, this is indicated to QUIC along with any final handshake bytes that TLS needs to send. At this stage, the transport parameters that the peer advertised during the handshake are authenticated; see Section 8.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSハンドシェイクが完了すると、これはTLSが送信する必要がある最終的なハンドシェイクバイトとともにQUICに示されます。この段階では、ハンドシェイク中に宣伝されているピアが認証されているトランスポートパラメータが認証されています。セクション8.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the handshake is complete, TLS becomes passive. TLS can still receive data from its peer and respond in kind, but it will not need to send more data unless specifically requested -- either by an application or QUIC. One reason to send data is that the server might wish to provide additional or updated session tickets to a client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハンドシェイクが完了すると、TLSは受動的になります。TLSは依然としてそのピアからデータを受け取ることができ、種類で応答することはできますが、特に要求されない限り、より多くのデータを送信する必要はありません - アプリケーションまたはQUICによって。データを送信する理由の1つは、サーバーが追加または更新されたセッションチケットをクライアントに提供したいと思うことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the handshake is complete, QUIC only needs to provide TLS with any data that arrives in CRYPTO streams. In the same manner that is used during the handshake, new data is requested from TLS after providing received data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハンドシェイクが完了すると、QUICは暗号ストリームに到着するデータでTLSを提供するだけです。ハンドシェイク中に使用されるのと同じ方法で、受信データを提供した後に新しいデータがTLSから要求されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1-4--Encryption-Level-Changes">
4.1.4. Encryption Level Changes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.4. 暗号化レベルの変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As keys at a given encryption level become available to TLS, TLS indicates to QUIC that reading or writing keys at that encryption level are available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定の暗号化レベルのキーがTLSに利用可能になると、TLSはその暗号化レベルでのキーを読み書きすることをQUICに示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The availability of new keys is always a result of providing inputs to TLS. TLS only provides new keys after being initialized (by a client) or when provided with new handshake data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいキーの可用性は常にTLSへの入力を提供した結果です。TLSは、初期化された後（クライアントによって）または新しいハンドシェイクデータを指定した場合にのみ新しいキーを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, a TLS implementation could perform some of its processing asynchronously. In particular, the process of validating a certificate can take some time. While waiting for TLS processing to complete, an endpoint SHOULD buffer received packets if they might be processed using keys that are not yet available. These packets can be processed once keys are provided by TLS. An endpoint SHOULD continue to respond to packets that can be processed during this time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、TLS実装では、その処理の一部を非同期的に実行できます。特に、証明書を検証するプロセスはしばらく時間がかかることがあります。TLS処理を完了するのを待っている間、エンドポイントは、まだ使用できないキーを使用して処理される場合は、受信したパケットをバッファしてください。これらのパケットは、キーがTLSによって提供されると処理することができます。この間に処理できるパケットにエンドポイントが応答し続けるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After processing inputs, TLS might produce handshake bytes, keys for new encryption levels, or both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入力を処理した後、TLSはハンドシェイクバイト、新しい暗号化レベルのキー、またはその両方を生成する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS provides QUIC with three items as a new encryption level becomes available:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSは新しい暗号化レベルが利用可能になるにつれて3つの項目でQUICを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* A secret
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 秘密
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* An Authenticated Encryption with Associated Data (AEAD) function
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 関連データ（AEAD）関数を持つ認証された暗号化
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* A Key Derivation Function (KDF)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 重要な派生機能（KDF）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These values are based on the values that TLS negotiates and are used by QUIC to generate packet and header protection keys; see Section 5 and Section 5.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの値は、TLSがネゴシエートする値に基づいており、パケットおよびヘッダー保護キーを生成するためにQUICによって使用されます。セクション5とセクション5.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If 0-RTT is possible, it is ready after the client sends a TLS ClientHello message or the server receives that message. After providing a QUIC client with the first handshake bytes, the TLS stack might signal the change to 0-RTT keys. On the server, after receiving handshake bytes that contain a ClientHello message, a TLS server might signal that 0-RTT keys are available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0-RTTが可能な場合は、クライアントがTLS ClientHelloメッセージを送信した後、またはサーバーがそのメッセージを受信した後に準備ができます。最初のハンドシェイクバイトを使用してQUICクライアントを提供した後、TLSスタックは0-RTTキーへの変更をシグナリングできます。サーバー上で、ClientHelloメッセージを含むハンドシェイクバイトを受信した後、TLSサーバーが0-RTTキーを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although TLS only uses one encryption level at a time, QUIC may use more than one level. For instance, after sending its Finished message (using a CRYPTO frame at the Handshake encryption level) an endpoint can send STREAM data (in 1-RTT encryption). If the Finished message is lost, the endpoint uses the Handshake encryption level to retransmit the lost message. Reordering or loss of packets can mean that QUIC will need to handle packets at multiple encryption levels. During the handshake, this means potentially handling packets at higher and lower encryption levels than the current encryption level used by TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSは一度に1つの暗号化レベルのみを使用しますが、QUICは複数のレベルを使用できます。たとえば、完成したメッセージを送信した後（ハンドシェイク暗号化レベルで暗号フレームを使用して）エンドポイントはストリームデータを送信することができます（1-RTT暗号化で）。完成したメッセージが失われた場合、エンドポイントはハンドシェイクの暗号化レベルを使用して失われたメッセージを再送信します。パケットの並べ替えまたは損失は、QUICが複数の暗号化レベルでパケットを処理する必要があることを意味します。ハンドシェイクの間、これは、TLSによって使用される現在の暗号化レベルよりも高い暗号化レベルでパケットを潜在的に処理することを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In particular, server implementations need to be able to read packets at the Handshake encryption level at the same time as the 0-RTT encryption level. A client could interleave ACK frames that are protected with Handshake keys with 0-RTT data, and the server needs to process those acknowledgments in order to detect lost Handshake packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に、サーバ実装は、0  -  RTT暗号化レベルと同時にハンドシェイク暗号化レベルでパケットを読み取ることができる必要がある。クライアントは、ハンドシェイクキーで0-RTTデータで保護されているACKフレームをインターリーブでき、サーバーは失われたハンドシェイクパケットを検出するためにそれらの確認応答を処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC also needs access to keys that might not ordinarily be available to a TLS implementation. For instance, a client might need to acknowledge Handshake packets before it is ready to send CRYPTO frames at that encryption level. TLS therefore needs to provide keys to QUIC before it might produce them for its own use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICには、通常TLS実装で利用できる可能性があるキーにアクセスする必要があります。たとえば、クライアントは、その暗号化レベルで暗号フレームを送信する準備ができる前にハンドシェイクパケットを確認する必要があるかもしれません。したがって、TLSは、独自の使用のためにそれらを生成することができる前にQUYをQUICに提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1-5--TLS-Interface-Summary">
4.1.5. TLS Interface Summary
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.5. TLSインタフェースの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 5 summarizes the exchange between QUIC and TLS for both client and server. Solid arrows indicate packets that carry handshake data; dashed arrows show where application data can be sent. Each arrow is tagged with the encryption level used for that transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図5は、クライアントとサーバーの両方のQUICとTLS間の交換を要約しています。実線の矢印は、ハンドシェイクデータを運ぶパケットを示します。破線の矢印は、アプリケーションデータを送信できる場所を示しています。各矢印はその送信に使用される暗号化レベルでタグ付けされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Client                                                    Server
   ======                                                    ======
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Get Handshake
                        Initial -------------&gt;
   Install tx 0-RTT keys
                        0-RTT - - - - - - - -&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                                 Handshake Received
                                                      Get Handshake
                        &lt;------------- Initial
                                              Install rx 0-RTT keys
                                             Install Handshake keys
                                                      Get Handshake
                        &lt;----------- Handshake
                                              Install tx 1-RTT keys
                        &lt;- - - - - - - - 1-RTT
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Handshake Received (Initial)
   Install Handshake keys
   Handshake Received (Handshake)
   Get Handshake
                        Handshake -----------&gt;
   Handshake Complete
   Install 1-RTT keys
                        1-RTT - - - - - - - -&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                                 Handshake Received
                                                 Handshake Complete
                                                Handshake Confirmed
                                              Install rx 1-RTT keys
                        &lt;--------------- 1-RTT
                              (HANDSHAKE_DONE)
   Handshake Confirmed
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Figure 5: Interaction Summary between QUIC and TLS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
図5：QUICとTLSの間の相互作用の概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 5 shows the multiple packets that form a single &#34;flight&#34; of messages being processed individually, to show what incoming messages trigger different actions. This shows multiple &#34;Get Handshake&#34; invocations to retrieve handshake messages at different encryption levels. New handshake messages are requested after incoming packets have been processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図5は、個別に処理されているメッセージの単一の「フライト」を形成する複数のパケットを示しています。これは、さまざまな暗号化レベルでハンドシェイクメッセージを取得するための複数の「ハンドシェイク」の呼び出しを示しています。着信パケットが処理された後に新しいハンドシェイクメッセージが要求されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 5 shows one possible structure for a simple handshake exchange. The exact process varies based on the structure of endpoint implementations and the order in which packets arrive. Implementations could use a different number of operations or execute them in other orders.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
簡単なハンドシェイク交換のための1つの可能な構造を示す図である。正確なプロセスは、エンドポイント実装の構造とパケットが到着する順序によって異なります。実装は異なる数の操作を使用することも、他の注文でそれらを実行することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--TLS-Version">
4.2. TLS Version
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. TLSバージョン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes how TLS 1.3 [TLS13] is used with QUIC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、TLS 1.3 [TLS13]がQUICで使用される方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In practice, the TLS handshake will negotiate a version of TLS to use. This could result in a version of TLS newer than 1.3 being negotiated if both endpoints support that version. This is acceptable provided that the features of TLS 1.3 that are used by QUIC are supported by the newer version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際には、TLSハンドシェイクは使用するTLSのバージョンを交渉します。これにより、両方のエンドポイントがそのバージョンをサポートしている場合、これはNegotiated 1.3よりも新しいバージョンのTLSがネゴシエートされる可能性があります。これは、QUICによって使用されるTLS 1.3の機能が新しいバージョンによってサポートされていることが提供される。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients MUST NOT offer TLS versions older than 1.3. A badly configured TLS implementation could negotiate TLS 1.2 or another older version of TLS. An endpoint MUST terminate the connection if a version of TLS older than 1.3 is negotiated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは1.3より古いTLSバージョンを提供してはいけません。ひどく設定されているTLS実装は、TLS 1.2または別の古いバージョンのTLSを交渉する可能性があります。1.3より古いTLSのバージョンがネゴシエートされている場合、エンドポイントは接続を終了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--ClientHello-Size">
4.3. ClientHello Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Clienthelloサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first Initial packet from a client contains the start or all of its first cryptographic handshake message, which for TLS is the ClientHello. Servers might need to parse the entire ClientHello (e.g., to access extensions such as Server Name Identification (SNI) or Application-Layer Protocol Negotiation (ALPN)) in order to decide whether to accept the new incoming QUIC connection. If the ClientHello spans multiple Initial packets, such servers would need to buffer the first received fragments, which could consume excessive resources if the client&#39;s address has not yet been validated. To avoid this, servers MAY use the Retry feature (see Section 8.1 of [QUIC-TRANSPORT]) to only buffer partial ClientHello messages from clients with a validated address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントからの最初の初期パケットには、TLSがClientHelloであるその最初の暗号化ハンドシェイクメッセージの開始またはすべてが含まれています。サーバは、新しい着信QUIC接続を受け入れるかどうかを決定するために、ClientHello全体を解析する必要があるかもしれません。ClientHelloが複数の初期パケットにスパンする場合、そのようなサーバーは最初の受信したフラグメントをバッファリングする必要があります。これは、クライアントのアドレスがまだ検証されていない場合に過度のリソースを消費する可能性があります。これを回避するために、サーバーは再試行機能を使用することができます（[QUIC-TRANSPORT]のセクション8.1参照）を参照して、クライアントからの部分ClientHelloメッセージを検証済みアドレスでのみバッファーします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC packet and framing add at least 36 bytes of overhead to the ClientHello message. That overhead increases if the client chooses a Source Connection ID field longer than zero bytes. Overheads also do not include the token or a Destination Connection ID longer than 8 bytes, both of which might be required if a server sends a Retry packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICのパケットとフレーミングは、ClientHelloメッセージに少なくとも36バイトのオーバーヘッドを追加します。クライアントがゼロバイトよりも長いソース接続IDフィールドを選択した場合、そのオーバーヘッドが増加します。オーバーヘッドには、サーバーがリトライパケットを送信した場合も、どちらも必要な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A typical TLS ClientHello can easily fit into a 1200-byte packet. However, in addition to the overheads added by QUIC, there are several variables that could cause this limit to be exceeded. Large session tickets, multiple or large key shares, and long lists of supported ciphers, signature algorithms, versions, QUIC transport parameters, and other negotiable parameters and extensions could cause this message to grow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
典型的なTLS ClientHelloは、1200バイトのパケットに簡単に収まることができます。ただし、QUICによって追加されたオーバーヘッドに加えて、この制限を超える可能性がある変数がいくつかあります。大きなセッションチケット、複数または大鍵共有、およびサポートされている暗号化、署名アルゴリズム、バージョン、QUICトランスポートパラメータ、およびその他の交渉パラメータ、および拡張の長いリストは、このメッセージを拡大させる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For servers, in addition to connection IDs and tokens, the size of TLS session tickets can have an effect on a client&#39;s ability to connect efficiently. Minimizing the size of these values increases the probability that clients can use them and still fit their entire ClientHello message in their first Initial packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの場合、接続IDとトークンに加えて、TLSセッションチケットのサイズは、クライアントの接続機能に効率的に接続することができます。これらの値のサイズを最小限に抑えると、クライアントがそれらを使用し、それでも最初の初期パケットでClientHelloメッセージ全体を設定できる可能性が高まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS implementation does not need to ensure that the ClientHello is large enough to meet QUIC&#39;s requirements for datagrams that carry Initial packets; see Section 14.1 of [QUIC-TRANSPORT]. QUIC implementations use PADDING frames or packet coalescing to ensure that datagrams are large enough.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS実装は、クライアントヘッ得が初期パケットを運ぶデータグラムのQUICの要件を満たすのに十分な大きさであることを確認する必要はありません。[QUIC-TRANSPORT]の14.1項を参照してください。QUICの実装は、データグラムが十分に大きいことを確認するためにパディングフレームまたはパケットの合体を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4--Peer-Authentication">
4.4. Peer Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. ピア認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The requirements for authentication depend on the application protocol that is in use. TLS provides server authentication and permits the server to request client authentication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認証の要件は、使用中のアプリケーションプロトコルによって異なります。TLSはサーバー認証を提供し、サーバーがクライアント認証を要求することを許可します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client MUST authenticate the identity of the server. This typically involves verification that the identity of the server is included in a certificate and that the certificate is issued by a trusted entity (see for example [RFC2818]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはサーバーのIDを認証する必要があります。これは通常、サーバーの身元が証明書に含まれており、証明書が信頼できるエンティティによって発行されていることを確認します（たとえば[RFC2818]を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: Where servers provide certificates for authentication, the size of the certificate chain can consume a large number of bytes.  Controlling the size of certificate chains is critical to performance in QUIC as servers are limited to sending 3 bytes for every byte received prior to validating the client address; see Section 8.1 of [QUIC-TRANSPORT].  The size of a certificate chain can be managed by limiting the number of names or extensions; using keys with small public key representations, like ECDSA; or by using certificate compression [COMPRESS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：サーバーが認証用の証明書を提供する場合、証明書チェーンのサイズが多数のバイトを消費する可能性があります。 サーバーはクライアントアドレスを検証する前に受信したバイトごとに3バイトを送信するように制限されているため、証明書チェーンのサイズを制御することはQUICのパフォーマンスにとって重要です。 [QUIC-TRANSPORT]のセクション8.1を参照してください。 証明書チェーンのサイズは、名前または拡張子の数を制限することで管理できます。 ECDSAのような小さな公開鍵表現の鍵を使用する。 または、証明書圧縮[COMPRESS]を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MAY request that the client authenticate during the handshake. A server MAY refuse a connection if the client is unable to authenticate when requested. The requirements for client authentication vary based on application protocol and deployment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、クライアントがハンドシェイク中に認証されることを要求できます。クライアントが要求されたときに認証できない場合、サーバーは接続を拒否することがあります。クライアント認証の要件は、アプリケーションプロトコルと展開によって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MUST NOT use post-handshake client authentication (as defined in Section 4.6.2 of [TLS13]) because the multiplexing offered by QUIC prevents clients from correlating the certificate request with the application-level event that triggered it (see [HTTP2-TLS13]). More specifically, servers MUST NOT send post-handshake TLS CertificateRequest messages, and clients MUST treat receipt of such messages as a connection error of type PROTOCOL_VIOLATION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICによって提供される多重化はクライアントが証明書要求をトリガーされたアプリケーションレベルのイベントとの関連付けを防止するため、サーバーは（TLS13]のセクション4.6.2で定義されているように）handshakeクライアント認証を使用してはいけません（[TLS13]）。TLS13]）。具体的には、サーバーはハンドシェイクTLS CertificateQuestメッセージを送信してはならず、クライアントはPROTOCOL_VIOLATION型の接続エラーとしてそのようなメッセージの受信を扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-5--Session-Resumption">
4.5. Session Resumption
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. セッションの再開
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC can use the session resumption feature of TLS 1.3. It does this by carrying NewSessionTicket messages in CRYPTO frames after the handshake is complete. Session resumption can be used to provide 0-RTT and can also be used when 0-RTT is disabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICはTLS 1.3のセッション再開機能を使用できます。ハンドシェイクが完了したら、NewSessionTicketメッセージをCryptoフレームに運ぶことによってこれを行います。セッション再開は0-RTTを提供するために使用でき、0-RTTが無効になっているときにも使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints that use session resumption might need to remember some information about the current connection when creating a resumed connection. TLS requires that some information be retained; see Section 4.6.1 of [TLS13]. QUIC itself does not depend on any state being retained when resuming a connection unless 0-RTT is also used; see Section 7.4.1 of [QUIC-TRANSPORT] and Section 4.6.1. Application protocols could depend on state that is retained between resumed connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションの再開を使用するエンドポイントは、再開された接続を作成するときに現在の接続に関する情報を記憶する必要があるかもしれません。TLSはいくつかの情報が保持されることを必要とする。[TLS13]のセクション4.6.1を参照してください。QUIC自体は、0-RTTも使用されていない限り、接続を再開するときに保持されている状態には依存しません。[QUIC-TRANSPORT]のセクション7.4.1とセクション4.6.1を参照してください。アプリケーションプロトコルは、再開された接続間に保持されている状態に依存する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients can store any state required for resumption along with the session ticket. Servers can use the session ticket to help carry state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、セッションチケットとともに再開に必要な状態を保存できます。サーバーはセッションチケットを使用して継続状態を支援できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Session resumption allows servers to link activity on the original connection with the resumed connection, which might be a privacy issue for clients. Clients can choose not to enable resumption to avoid creating this correlation. Clients SHOULD NOT reuse tickets as that allows entities other than the server to correlate connections; see Appendix C.4 of [TLS13].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションの再開により、サーバーは再開された接続との元の接続でアクティビティをリンクすることができます。これは、クライアントのプライバシーの問題である可能性があります。クライアントはこの相関関係を作成しないように再開を可能にしないことを選択できます。クライアントは、サーバー以外のエンティティが接続を関連付けることを可能にするようにチケットを再利用しないでください。[TLS13]の付録C.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6--0-RTT">
4.6. 0-RTT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. 0-RTT
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The 0-RTT feature in QUIC allows a client to send application data before the handshake is complete. This is made possible by reusing negotiated parameters from a previous connection. To enable this, 0-RTT depends on the client remembering critical parameters and providing the server with a TLS session ticket that allows the server to recover the same information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICの0-RTT機能により、ハンドシェイクが完了する前にクライアントがアプリケーションデータを送信できます。これは、以前の接続からネゴシエートされたパラメータを再利用することによって可能になります。これを有効にするには、0-RTTはクライアントに重要なパラメータを記憶し、サーバーが同じ情報を回復できるようにするTLSセッションチケットをサーバーに提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This information includes parameters that determine TLS state, as governed by [TLS13], QUIC transport parameters, the chosen application protocol, and any information the application protocol might need; see Section 4.6.3. This information determines how 0-RTT packets and their contents are formed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この情報には、[TLS13]によって管理されるTLS状態を決定するパラメーター、QUICトランスポートパラメーター、選択されたアプリケーションプロトコル、およびアプリケーションプロトコルが必要とする可能性のある情報が含まれます。セクション4.6.3を参照してください。この情報は、0-RTTパケットとその内容がどのように形成されるかを決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To ensure that the same information is available to both endpoints, all information used to establish 0-RTT comes from the same connection. Endpoints cannot selectively disregard information that might alter the sending or processing of 0-RTT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じ情報が両方のエンドポイントで利用可能であることを確認するために、0-RTTを確立するために使用されるすべての情報は同じ接続から来ています。エンドポイントは、0-RTTの送信または処理を変更する可能性がある情報を選択的に無視できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS13] sets a limit of seven days on the time between the original connection and any attempt to use 0-RTT. There are other constraints on 0-RTT usage, notably those caused by the potential exposure to replay attack; see Section 9.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS13]は、元の接続から0-RTTの使用を試みるまでの時間に7日間の制限を設定します。0-RTTの使用には他にも制約があり、特にリプレイ攻撃にさらされる可能性によって引き起こされる制約があります。セクション9.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6-1--Enabling-0-RTT">
4.6.1. Enabling 0-RTT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. 0-RTTの有効化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS early_data extension in the NewSessionTicket message is defined to convey (in the max_early_data_size parameter) the amount of TLS 0-RTT data the server is willing to accept. QUIC does not use TLS early data. QUIC uses 0-RTT packets to carry early data. Accordingly, the max_early_data_size parameter is repurposed to hold a sentinel value 0xffffffff to indicate that the server is willing to accept QUIC 0-RTT data. To indicate that the server does not accept 0-RTT data, the early_data extension is omitted from the NewSessionTicket. The amount of data that the client can send in QUIC 0-RTT is controlled by the initial_max_data transport parameter supplied by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NewSessionTicketメッセージのTLS early_data拡張機能は、サーバーが受け入れるTLS0-RTTデータの量を（max_early_data_sizeパラメーターで）伝達するように定義されています。 QUICはTLS初期データを使用しません。 QUICは0-RTTパケットを使用して初期データを伝送します。 したがって、max_early_data_sizeパラメーターは、サーバーがQUIC 0-RTTデータを受け入れる意思があることを示すために、番兵値0xffffffffを保持するために再利用されます。 サーバーが0-RTTデータを受け入れないことを示すために、early_data拡張機能はNewSessionTicketから省略されています。 クライアントがQUIC0-RTTで送信できるデータの量は、サーバーによって提供されるinitial_max_dataトランスポートパラメーターによって制御されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers MUST NOT send the early_data extension with a max_early_data_size field set to any value other than 0xffffffff. A client MUST treat receipt of a NewSessionTicket that contains an early_data extension with any other value as a connection error of type PROTOCOL_VIOLATION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、0xFFFFFFFF以外の任意の値に設定されているMAX_EARLY_DATA_SIZEフィールドを使用してELIER_DATA拡張機能を送信してはなりません。クライアントは、PROTOCOL_VIOLATION型の接続エラーとして、任意の値を持つELEAS_DATA拡張機能を含むNewSessionTicketの受信を扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client that wishes to send 0-RTT packets uses the early_data extension in the ClientHello message of a subsequent handshake; see Section 4.2.10 of [TLS13]. It then sends application data in 0-RTT packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0-RTTパケットを送信したいクライアントは、後続のハンドシェイクのClientHelloメッセージでearly_data拡張機能を使用します。[TLS13]の4.2.10項を参照してください。その後、アプリケーションデータを0-RTTパケットに送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client that attempts 0-RTT might also provide an address validation token if the server has sent a NEW_TOKEN frame; see Section 8.1 of [QUIC-TRANSPORT].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがnew_tokenフレームを送信した場合、0-RTTを試行するクライアントもアドレス検証トークンを提供する可能性があります。[QUIC-TRANSPORT]のセクション8.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6-2--Accepting-and-Rejecting-0-RTT">
4.6.2. Accepting and Rejecting 0-RTT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2. 0-RTTを受け入れて拒否します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server accepts 0-RTT by sending an early_data extension in the EncryptedExtensions; see Section 4.2.10 of [TLS13]. The server then processes and acknowledges the 0-RTT packets that it receives.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、EncryptedExtensionsでelegre_data拡張機能を送信することによって0-RTTを受け入れます。[TLS13]の4.2.10項を参照してください。サーバーは、受信した0-RTTパケットを処理して確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server rejects 0-RTT by sending the EncryptedExtensions without an early_data extension. A server will always reject 0-RTT if it sends a TLS HelloRetryRequest. When rejecting 0-RTT, a server MUST NOT process any 0-RTT packets, even if it could. When 0-RTT was rejected, a client SHOULD treat receipt of an acknowledgment for a 0-RTT packet as a connection error of type PROTOCOL_VIOLATION, if it is able to detect the condition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Eargy_Data拡張機能なしで暗号化されたextensionsを送信することによって、サーバーが0-RTTを拒否します。TLS HellORetryRequestを送信した場合、サーバーは常に0-RTTを拒否します。0-RTTを拒否すると、サーバーはそれができていても0-RTTパケットを処理してはいけません。0-RTTが拒否された場合、クライアントは、条件を検出することができる場合、PROTOCOL_VIOLATION型の接続エラーとして、0-RTTパケットの確認応答の受信を扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When 0-RTT is rejected, all connection characteristics that the client assumed might be incorrect. This includes the choice of application protocol, transport parameters, and any application configuration. The client therefore MUST reset the state of all streams, including application state bound to those streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0-RTTが拒否されると、クライアントが想定しているすべての接続特性が正しくない可能性があります。これには、アプリケーションプロトコル、トランスポートパラメータ、およびアプリケーション構成の選択が含まれます。したがって、クライアントは、それらのストリームにバインドされているアプリケーション状態を含む、すべてのストリームの状態をリセットする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client MAY reattempt 0-RTT if it receives a Retry or Version Negotiation packet. These packets do not signify rejection of 0-RTT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再試行またはバージョンネゴシエーションパケットを受信した場合、クライアントは0-RTTを再試行することができます。これらのパケットは0-RTTの拒否を意味しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6-3--Validating-0-RTT-Configuration">
4.6.3. Validating 0-RTT Configuration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3. 0-RTT構成の検証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a server receives a ClientHello with the early_data extension, it has to decide whether to accept or reject 0-RTT data from the client. Some of this decision is made by the TLS stack (e.g., checking that the cipher suite being resumed was included in the ClientHello; see Section 4.2.10 of [TLS13]). Even when the TLS stack has no reason to reject 0-RTT data, the QUIC stack or the application protocol using QUIC might reject 0-RTT data because the configuration of the transport or application associated with the resumed session is not compatible with the server&#39;s current configuration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがelege_data拡張機能を持つClientHelloを受信すると、クライアントから0-RTTデータを承認または拒否するかどうかを決定する必要があります。この決定のいくつかはTLSスタックによって行われます（例えば、再開されている暗号スイートがClientHelloに含まれていることを確認します。[TLS13]のセクション4.2.10を参照）。TLSスタックが0-RTTデータを拒否する理由がない場合でも、QUICを使用したQUICスタックまたはアプリケーションプロトコルは、再開セッションに関連付けられているトランスポートまたはアプリケーションの構成がサーバーの現在と互換性がないため、0-RTTデータを拒否する可能性があります。設定
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC requires additional transport state to be associated with a 0-RTT session ticket. One common way to implement this is using stateless session tickets and storing this state in the session ticket. Application protocols that use QUIC might have similar requirements regarding associating or storing state. This associated state is used for deciding whether 0-RTT data must be rejected. For example, HTTP/3 settings [QUIC-HTTP] determine how 0-RTT data from the client is interpreted. Other applications using QUIC could have different requirements for determining whether to accept or reject 0-RTT data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICは、追加のトランスポート状態を0-RTTセッションチケットに関連付ける必要があります。これを実装する一般的な方法は、ステートレスセッションチケットを使用し、セッションチケットにこの状態を格納します。QUICを使用するアプリケーションプロトコルは、状態を関連付けまたは保存することに関して同様の要件を持つ可能性があります。この関連状態は、0-RTTデータを拒否する必要があるかどうかを決定するために使用されます。たとえば、HTTP/3の設定[QUIC-HTTP]クライアントからの0-RTTデータがどのように解釈されるかを決定します。QUICを使用した他のアプリケーションは、0-RTTデータを受け入れるか拒否するかを判断するためのさまざまな要件を持つことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-7--HelloRetryRequest">
4.7. HelloRetryRequest
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. HelloRetryRequest
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HelloRetryRequest message (see Section 4.1.4 of [TLS13]) can be used to request that a client provide new information, such as a key share, or to validate some characteristic of the client. From the perspective of QUIC, HelloRetryRequest is not differentiated from other cryptographic handshake messages that are carried in Initial packets. Although it is in principle possible to use this feature for address verification, QUIC implementations SHOULD instead use the Retry feature; see Section 8.1 of [QUIC-TRANSPORT].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HelloretryRequestメッセージ（[TLS13]のセクション4.1.4を参照）を使用して、クライアントがキーシェアなどの新しい情報を提供するか、クライアントのいくつかの特性を検証するように要求することができます。QUICの観点から、HelloretryRequestは最初のパケットで運ばれる他の暗号化ハンドシェイクメッセージと区別されません。原則として、この機能をアドレス検証に使用することは可能ですが、代わりにQUIC実装は再試行機能を使用する必要があります。[QUIC-TRANSPORT]のセクション8.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-8--TLS-Errors">
4.8. TLS Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. TLSエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If TLS experiences an error, it generates an appropriate alert as defined in Section 6 of [TLS13].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSがエラーを経験した場合は、[TLS13]のセクション6で定義されている適切なアラートを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A TLS alert is converted into a QUIC connection error. The AlertDescription value is added to 0x0100 to produce a QUIC error code from the range reserved for CRYPTO_ERROR; see Section 20.1 of [QUIC-TRANSPORT]. The resulting value is sent in a QUIC CONNECTION_CLOSE frame of type 0x1c.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSアラートはQUIC接続エラーに変換されます。AlertDescriptionの値が0x0100に追加され、crypto_errorの範囲からQUICのエラーコードが生成されます。[QUIC-TRANSPORT]の20.1節を参照してください。結果の値は、0x1c型のquic connection_closeフレームで送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC is only able to convey an alert level of &#34;fatal&#34;. In TLS 1.3, the only existing uses for the &#34;warning&#34; level are to signal connection close; see Section 6.1 of [TLS13]. As QUIC provides alternative mechanisms for connection termination and the TLS connection is only closed if an error is encountered, a QUIC endpoint MUST treat any alert from TLS as if it were at the &#34;fatal&#34; level.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICは、「致命的」の警告レベルを伝えることしかできません。TLS 1.3では、「警告」レベルの唯一の既存の用途は接続を閉じることです。[TLS13]のセクション6.1を参照してください。QUICが接続終了のための代替メカニズムを提供し、TLS接続はエラーが発生した場合にのみ閉じているだけで、QUICのエンドポイントは、それが「致命的な」レベルにあるかのようにTLSからの警告を扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC permits the use of a generic code in place of a specific error code; see Section 11 of [QUIC-TRANSPORT]. For TLS alerts, this includes replacing any alert with a generic alert, such as handshake_failure (0x0128 in QUIC). Endpoints MAY use a generic error code to avoid possibly exposing confidential information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICは、特定のエラーコードの代わりに一般コードの使用を許可します。[QUIC-TRANSPORT]のセクション11を参照してください。TLSアラートの場合、これには、handshake_failure（QUICの0x0128）などの警告を汎用アラートに置き換えることが含まれます。エンドポイントは、機密情報を公開することがないように一般的なエラーコードを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9--Discarding-Unused-Keys">
4.9. Discarding Unused Keys
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9. 未使用のキーの破棄
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After QUIC has completed a move to a new encryption level, packet protection keys for previous encryption levels can be discarded. This occurs several times during the handshake, as well as when keys are updated; see Section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICが新しい暗号化レベルへの移行を完了した後、以前の暗号化レベルのパケット保護キーを破棄することができます。これは、handshakeの間に数回発生し、キーが更新されたときに発生します。セクション6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packet protection keys are not discarded immediately when new keys are available. If packets from a lower encryption level contain CRYPTO frames, frames that retransmit that data MUST be sent at the same encryption level. Similarly, an endpoint generates acknowledgments for packets at the same encryption level as the packet being acknowledged. Thus, it is possible that keys for a lower encryption level are needed for a short time after keys for a newer encryption level are available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット保護キーは、新しいキーが利用可能なときにすぐに破棄されません。低暗号化レベルからのパケットに暗号フレームが含まれている場合、データを再送信するフレームは同じ暗号化レベルで送信されなければならないフレーム。同様に、エンドポイントは、承認されているパケットと同じ暗号化レベルでパケットの確認応答を生成します。したがって、新しい暗号化レベルのキーが入手可能である後に、より低い暗号化レベルのキーが短時間必要になる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint cannot discard keys for a given encryption level unless it has received all the cryptographic handshake messages from its peer at that encryption level and its peer has done the same. Different methods for determining this are provided for Initial keys (Section 4.9.1) and Handshake keys (Section 4.9.2). These methods do not prevent packets from being received or sent at that encryption level because a peer might not have received all the acknowledgments necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、その暗号化レベルでピアからすべての暗号ハンドシェイクメッセージを受信していない限り、特定の暗号化レベルのキーを廃棄できません。これを決定する方法は、初期キー（セクション4.9.1）およびハンドシェイクキー（セクション4.9.2）に提供されています。これらの方法は、ピアが必要なすべての確認応答を受信していない可能性があるため、パケットがその暗号化レベルで受信または送信されないようにしないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Though an endpoint might retain older keys, new data MUST be sent at the highest currently available encryption level. Only ACK frames and retransmissions of data in CRYPTO frames are sent at a previous encryption level. These packets MAY also include PADDING frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは古いキーを保持する可能性があるが、現在利用可能な最も利用可能な暗号化レベルで新しいデータを送信する必要があります。Cryptoフレーム内のACKフレームおよびデータの再送信は、前の暗号化レベルで送信されます。これらのパケットはまた、パディングフレームを含み得る。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9-1--Discarding-Initial-Keys">
4.9.1. Discarding Initial Keys
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1. 初期キーの破棄
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packets protected with Initial secrets (Section 5.2) are not authenticated, meaning that an attacker could spoof packets with the intent to disrupt a connection. To limit these attacks, Initial packet protection keys are discarded more aggressively than other keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期秘密で保護されたパケット（セクション5.2）は認証されません。つまり、攻撃者は接続を混乱させる意図を持つパケットを偽装することができます。これらの攻撃を制限するために、最初のパケット保護キーは他のキーよりも積極的に破棄されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The successful use of Handshake packets indicates that no more Initial packets need to be exchanged, as these keys can only be produced after receiving all CRYPTO frames from Initial packets. Thus, a client MUST discard Initial keys when it first sends a Handshake packet and a server MUST discard Initial keys when it first successfully processes a Handshake packet. Endpoints MUST NOT send Initial packets after this point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハンドシェイクパケットの使用が成功したことは、最初のパケットからすべての暗号フレームを受信した後にのみ生成されることができるので、もう初期パケットを交換する必要がないことを示しています。したがって、クライアントは最初にハンドシェイクパケットを送信し、サーバーが最初にハンドシェイクパケットを正常に処理したときにサーバーを破棄する必要がある場合、最初のキーを破棄する必要があります。エンドポイントはこの点の後に初期パケットを送信してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This results in abandoning loss recovery state for the Initial encryption level and ignoring any outstanding Initial packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、初期暗号化レベルの損失回復状態を放棄し、未処理の初期パケットを無視します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9-2--Discarding-Handshake-Keys">
4.9.2. Discarding Handshake Keys
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.2. ハンドシェイクキーの破棄
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint MUST discard its Handshake keys when the TLS handshake is confirmed (Section 4.1.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSハンドシェイクが確認されたときにエンドポイントがハンドシェイクキーを破棄する必要があります（セクション4.1.2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9-3--Discarding-0-RTT-Keys">
4.9.3. Discarding 0-RTT Keys
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.3. 0-RTTキーを破棄します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0-RTT and 1-RTT packets share the same packet number space, and clients do not send 0-RTT packets after sending a 1-RTT packet (Section 5.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0-RTTパケットと1-RTTパケットは同じパケット番号スペースを共有し、クライアントは1-RTTパケットを送信した後に0-RTTパケットを送信しません（セクション5.6）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, a client SHOULD discard 0-RTT keys as soon as it installs 1-RTT keys as they have no use after that moment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、クライアントは、その瞬間に使用しないように1 RTTキーをインストールするとすぐに0-RTTキーを破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, a server MAY discard 0-RTT keys as soon as it receives a 1-RTT packet. However, due to packet reordering, a 0-RTT packet could arrive after a 1-RTT packet. Servers MAY temporarily retain 0-RTT keys to allow decrypting reordered packets without requiring their contents to be retransmitted with 1-RTT keys. After receiving a 1-RTT packet, servers MUST discard 0-RTT keys within a short time; the RECOMMENDED time period is three times the Probe Timeout (PTO, see [QUIC-RECOVERY]). A server MAY discard 0-RTT keys earlier if it determines that it has received all 0-RTT packets, which can be done by keeping track of missing packet numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、サーバーは、1-RTTパケットを受信するとすぐに0-RTTキーを破棄することがあります。ただし、パケットの並べ替えのため、1 RTTパケットの後に0-RTTパケットが到着する可能性があります。サーバーは、1-RTTキーで内容を再送信することなく並べ替えされたパケットを復号化することを可能にするために一時的に0-RTTキーを保持することがあります。1-RTTパケットを受信した後、サーバーは短時間で0-RTTキーを破棄しなければなりません。推奨時間はプローブタイムアウトの3倍です（PTO、[QUIC回復]を参照）。Serverは、それがすべての0-RTTパケットを受信したと判断した場合に0-RTTキーを破棄します。これは、欠落しているパケット番号を追跡することによって実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Packet-Protection">
5. Packet Protection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. パケット保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with TLS over TCP, QUIC protects packets with keys derived from the TLS handshake, using the AEAD algorithm [AEAD] negotiated by TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPを介したTLSと同様に、QUICはTLSのアルゴリズム[AEAD]をTLSによってネゴシエートして、TLSハンドシェイクから派生したキーを持つパケットを保護します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC packets have varying protections depending on their type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICパケットには、その種類によってはさまざまな保護があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Version Negotiation packets have no cryptographic protection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* バージョンネゴシエーションパケットには暗号保護はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Retry packets use AEAD_AES_128_GCM to provide protection against accidental modification and to limit the entities that can produce a valid Retry; see Section 5.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 再試行パケットは、AEAD_AES_128_GCMを使用して、偶発的な修正に対する保護を提供し、有効な再試行を生み出すことができるエンティティを制限することです。セクション5.8を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Initial packets use AEAD_AES_128_GCM with keys derived from the Destination Connection ID field of the first Initial packet sent by the client; see Section 5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 初期パケットは、クライアントによって送信された最初の初期パケットの宛先接続IDフィールドから派生したキーを持つAEAD_AES_128_GCMを使用します。セクション5.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* All other packets have strong cryptographic protections for confidentiality and integrity, using keys and algorithms negotiated by TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 他のすべてのパケットは、TLSと交渉されたキーとアルゴリズムを使用して、機密性と整合性に対する強い暗号保護を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes how packet protection is applied to Handshake packets, 0-RTT packets, and 1-RTT packets. The same packet protection process is applied to Initial packets. However, as it is trivial to determine the keys used for Initial packets, these packets are not considered to have confidentiality or integrity protection. Retry packets use a fixed key and so similarly lack confidentiality and integrity protection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、パケット保護をハンドシェイクパケット、0-RTTパケット、および1-RTTパケットに適用する方法について説明します。最初のパケットに同じパケット保護プロセスが適用されます。ただし、初期パケットに使用されるキーを決定するのは簡単なので、これらのパケットは機密保持または完全性保護を持つとは考えられていません。再試行パケットは固定鍵を使用しているため、同様に機密性と整合性の保護が欠けています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--Packet-Protection-Keys">
5.1. Packet Protection Keys
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. パケット保護キー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC derives packet protection keys in the same way that TLS derives record protection keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICは、TLSがレコード保護キーを派生させるのと同じ方法でパケット保護キーを導きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each encryption level has separate secret values for protection of packets sent in each direction. These traffic secrets are derived by TLS (see Section 7.1 of [TLS13]) and are used by QUIC for all encryption levels except the Initial encryption level. The secrets for the Initial encryption level are computed based on the client&#39;s initial Destination Connection ID, as described in Section 5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各暗号化レベルには、各方向に送信されたパケットを保護するための別々の秘密値があります。これらのトラフィック秘密はTLSによって導出されます（[TLS13]のセクション7.1参照）、初期暗号化レベルを除くすべての暗号化レベルに対してQUICが使用されます。初期暗号化レベルの秘密は、セクション5.2で説明されているように、クライアントの初期宛先接続IDに基づいて計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The keys used for packet protection are computed from the TLS secrets using the KDF provided by TLS. In TLS 1.3, the HKDF-Expand-Label function described in Section 7.1 of [TLS13] is used with the hash function from the negotiated cipher suite. All uses of HKDF-Expand-Label in QUIC use a zero-length Context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット保護に使用されるキーは、TLSによって提供されるKDFを使用してTLSシークレットから計算されます。 TLS 1.3では、[TLS13]のセクション7.1で説明されているHKDF-Expand-Label関数が、ネゴシエートされた暗号スイートのハッシュ関数とともに使用されます。 QUICでのHKDF-Expand-Labelのすべての使用は、長さがゼロのコンテキストを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that labels, which are described using strings, are encoded as bytes using ASCII [ASCII] without quotes or any trailing NUL byte.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
文字列を使用して記述されているラベルは、引用符または末尾のNULバイトなしでASCII [ASCII]を使用してバイトとしてエンコードされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other versions of TLS MUST provide a similar function in order to be used with QUIC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSの他のバージョンは、QUICで使用するために同様の機能を提供しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current encryption level secret and the label &#34;quic key&#34; are input to the KDF to produce the AEAD key; the label &#34;quic iv&#34; is used to derive the Initialization Vector (IV); see Section 5.3. The header protection key uses the &#34;quic hp&#34; label; see Section 5.4. Using these labels provides key separation between QUIC and TLS; see Section 9.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の暗号化レベルの秘密とラベル「quic key」がKDFに入力され、AEADキーが生成されます。ラベル「quic iv」は、初期化ベクトル（IV）を導出するために使用される。セクション5.3を参照してください。ヘッダ保護キーは「quic hp」ラベルを使用します。セクション5.4を参照してください。これらのラベルを使用すると、QUICとTLSの間のキー間隔があります。セクション9.6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both &#34;quic key&#34; and &#34;quic hp&#34; are used to produce keys, so the Length provided to HKDF-Expand-Label along with these labels is determined by the size of keys in the AEAD or header protection algorithm. The Length provided with &#34;quic iv&#34; is the minimum length of the AEAD nonce or 8 bytes if that is larger; see [AEAD].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「quic key」と「quic hp」の両方がキーを生成するために使用されるので、これらのラベルと共にHKDF展開ラベルに供給される長さは、AEADまたはヘッダ保護アルゴリズム内のキーのサイズによって決定される。「quic iv」で提供される長さは、それが大きい場合、AEAD nonceまたは8バイトの最小長です。[AEAD]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The KDF used for initial secrets is always the HKDF-Expand-Label function from TLS 1.3; see Section 5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の秘密に使用されるKDFは常にTLS 1.3からのHKDF展開ラベル関数です。セクション5.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--Initial-Secrets">
5.2. Initial Secrets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. 初期の秘密
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initial packets apply the packet protection process, but use a secret derived from the Destination Connection ID field from the client&#39;s first Initial packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期パケットはパケット保護プロセスを適用しますが、クライアントの最初の初期パケットから[宛先接続ID]フィールドから派生した秘密を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This secret is determined by using HKDF-Extract (see Section 2.2 of [HKDF]) with a salt of 0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a and the input keying material (IKM) of the Destination Connection ID field. This produces an intermediate pseudorandom key (PRK) that is used to derive two separate secrets for sending and receiving.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この秘密は、0x38762cf7f55934b34d179ae6a4c80cadccbb7f0aのソルトと宛先接続IDフィールドの入力キーワード（IKM）を備えたHKDF抽出物（[HKDF]のセクション2.2を参照）によって決定されます。これにより、送受信のために2つの別々の秘密を導き出すために使用される中間擬似乱数キー（PRK）が生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The secret used by clients to construct Initial packets uses the PRK and the label &#34;client in&#34; as input to the HKDF-Expand-Label function from TLS [TLS13] to produce a 32-byte secret. Packets constructed by the server use the same process with the label &#34;server in&#34;. The hash function for HKDF when deriving initial secrets and keys is SHA-256 [SHA].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期パケットを構築するためにクライアントが使用する秘密は、TLS [TLS13]からのHKDF-Expand-Label関数への入力としてPRKとラベル「client in」を使用して32バイトの秘密を生成します。サーバーによって構築されたパケットは、ラベル「server in」と同じプロセスを使用します。初期秘密と鍵を導出するときのHKDFのハッシュ関数はSHA-256 [SHA]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This process in pseudocode is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
疑似コードのこのプロセスは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   initial_salt = 0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a
   initial_secret = HKDF-Extract(initial_salt,
                                 client_dst_connection_id)

   client_initial_secret = HKDF-Expand-Label(initial_secret,
                                             &#34;client in&#34;, &#34;&#34;,
                                             Hash.length)
   server_initial_secret = HKDF-Expand-Label(initial_secret,
                                             &#34;server in&#34;, &#34;&#34;,
                                             Hash.length)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The connection ID used with HKDF-Expand-Label is the Destination Connection ID in the Initial packet sent by the client. This will be a randomly selected value unless the client creates the Initial packet after receiving a Retry packet, where the Destination Connection ID is selected by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HKDF-Expand-Labelで使用される接続IDは、クライアントによって送信された初期パケット内の宛先接続IDです。クライアントが再試行パケットを受信した後に初期パケットを作成しない限り、これはランダムに選択された値になり、そこで宛先接続IDがサーバによって選択される。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Future versions of QUIC SHOULD generate a new salt value, thus ensuring that the keys are different for each version of QUIC. This prevents a middlebox that recognizes only one version of QUIC from seeing or modifying the contents of packets from future versions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICの将来のバージョンは新しい塩分値を生成する必要があり、キーがQUICのバージョンごとに異なることを確認します。これにより、将来のバージョンからのパケットの内容を見たり変更したりするのを認識したMiddleBoxが1つのQUICのみを認識します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HKDF-Expand-Label function defined in TLS 1.3 MUST be used for Initial packets even where the TLS versions offered do not include TLS 1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS 1.3で定義されているHKDF-Expand-Label関数は、提供されているTLSバージョンにTLS 1.3を含まない場合でも、初期パケットに使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The secrets used for constructing subsequent Initial packets change when a server sends a Retry packet to use the connection ID value selected by the server. The secrets do not change when a client changes the Destination Connection ID it uses in response to an Initial packet from the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがサーバーによって選択された接続ID値を使用するために、サーバーが再試行パケットを送信すると、後続の初期パケットを構築するために使用される秘密が変更されます。クライアントがサーバーからの最初のパケットに応答して使用する宛先接続IDをクライアントに変更すると、秘密は変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: The Destination Connection ID field could be any length up to 20 bytes, including zero length if the server sends a Retry packet with a zero-length Source Connection ID field. After a Retry, the Initial keys provide the client no assurance that the server received its packet, so the client has to rely on the exchange that included the Retry packet to validate the server address; see Section 8.1 of [QUIC-TRANSPORT].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：宛先接続IDフィールドは、サーバーが長さゼロの送信元接続IDフィールドで再試行パケットを送信する場合の長さゼロを含め、最大20バイトの任意の長さにすることができます。 再試行後、初期キーはサーバーがパケットを受信したことをクライアントに保証しないため、クライアントはサーバーアドレスを検証するために再試行パケットを含む交換に依存する必要があります。 [QUIC-TRANSPORT]のセクション8.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Appendix A contains sample Initial packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付録Aにサンプルの初期パケットが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3--AEAD-Usage">
5.3. AEAD Usage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. AEADの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Authenticated Encryption with Associated Data (AEAD) function (see [AEAD]) used for QUIC packet protection is the AEAD that is negotiated for use with the TLS connection. For example, if TLS is using the TLS_AES_128_GCM_SHA256 cipher suite, the AEAD_AES_128_GCM function is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICのパケット保護に使用される関連データ（AEAD）機能（[AEAD]を参照）を使用した認証された暗号化は、TLS接続で使用するためにネゴシエートされたAEADです。たとえば、TLSがTLS_AES_128_GCM_SHA256暗号スイートを使用している場合、AEAD_AES_128_GCM関数が使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC can use any of the cipher suites defined in [TLS13] with the exception of TLS_AES_128_CCM_8_SHA256. A cipher suite MUST NOT be negotiated unless a header protection scheme is defined for the cipher suite. This document defines a header protection scheme for all cipher suites defined in [TLS13] aside from TLS_AES_128_CCM_8_SHA256. These cipher suites have a 16-byte authentication tag and produce an output 16 bytes larger than their input.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICは、TLS_AES_128_CCM_8_SHA256を除いて、[TLS13]で定義されている暗号スイートを使用できます。暗号スイートに対してヘッダ保護方式が定義されていない限り、暗号スイートをネゴシエートしてはいけません。このドキュメントは、TLS_AES_128_CCM_8_SHA256とは別に[TLS13]で定義されているすべての暗号スイートのヘッダー保護方式を定義します。これらの暗号スイートは16バイトの認証タグを持ち、それらの入力より16バイトの出力を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint MUST NOT reject a ClientHello that offers a cipher suite that it does not support, or it would be impossible to deploy a new cipher suite. This also applies to TLS_AES_128_CCM_8_SHA256.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、サポートしていない暗号スイートを提供するClientHelloを拒否しないでください。また、新しい暗号スイートを展開することは不可能になります。これはTLS_AES_128_CCM_8_SHA256にも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When constructing packets, the AEAD function is applied prior to applying header protection; see Section 5.4. The unprotected packet header is part of the associated data (A). When processing packets, an endpoint first removes the header protection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットを構築するとき、AEAD関数はヘッダ保護を適用する前に適用されます。セクション5.4を参照してください。保護されていないパケットヘッダーは、関連データ（A）の一部です。パケットを処理するとき、エンドポイントは最初にヘッダー保護を削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key and IV for the packet are computed as described in Section 5.1. The nonce, N, is formed by combining the packet protection IV with the packet number. The 62 bits of the reconstructed QUIC packet number in network byte order are left-padded with zeros to the size of the IV. The exclusive OR of the padded packet number and the IV forms the AEAD nonce.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットのキーとIVは、セクション5.1で説明されているように計算されます。ナンスNは、パケット保護IVとパケット番号を組み合わせて形成されます。ネットワークバイトオーダーで再構築されたQUICパケット番号の62ビットには、IVのサイズまでゼロが左に埋め込まれます。パディングされたパケット番号とIVの排他的論理和がAEADナンスを形成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated data, A, for the AEAD is the contents of the QUIC header, starting from the first byte of either the short or long header, up to and including the unprotected packet number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AEADのための関連データAは、短いヘッダーまたはロングヘッダーの最初のバイトから保護されていないパケット番号までの、QUICヘッダーの内容です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The input plaintext, P, for the AEAD is the payload of the QUIC packet, as described in [QUIC-TRANSPORT].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AEAD用の入力平文Pは、[QUIC-TRANSPORT]で説明されているように、QUICパケットのペイロードです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The output ciphertext, C, of the AEAD is transmitted in place of P.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AEADの出力する暗号文CはPの代わりに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some AEAD functions have limits for how many packets can be encrypted under the same key and IV; see Section 6.6. This might be lower than the packet number limit. An endpoint MUST initiate a key update (Section 6) prior to exceeding any limit set for the AEAD that is in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのAEAD関数は、同じキーとIVの下で暗号化できるパケット数の制限を持っています。6.6項を参照してください。これはパケット番号の制限より低くなる可能性があります。エンドポイントは、使用中のAEADの制限セットを超える前に、キーアップデート（セクション6）を開始する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4--Header-Protection">
5.4. Header Protection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. ヘッダー保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Parts of QUIC packet headers, in particular the Packet Number field, are protected using a key that is derived separately from the packet protection key and IV. The key derived using the &#34;quic hp&#34; label is used to provide confidentiality protection for those fields that are not exposed to on-path elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICのパケットヘッダー、特にパケット番号フィールドの一部は、パケット保護キーとIVとは別に導出されたキーを使用して保護されています。「quic hp」ラベルを使用して導出されたキーは、オンパス要素にさらされていないフィールドの機密保護を提供するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This protection applies to the least significant bits of the first byte, plus the Packet Number field. The four least significant bits of the first byte are protected for packets with long headers; the five least significant bits of the first byte are protected for packets with short headers. For both header forms, this covers the reserved bits and the Packet Number Length field; the Key Phase bit is also protected for packets with a short header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この保護は、最初のバイトの最下位ビットに加えてパケット番号フィールドに適用されます。最初のバイトの4つの最下位ビットは長いヘッダーを持つパケットのために保護されています。最初のバイトの5つの最下位ビットは、短いヘッダーを持つパケットのために保護されています。両方のヘッダフォームの場合、これは予約ビットとパケット番号の長さフィールドをカバーします。キーフェーズビットは、短いヘッダを備えたパケットの場合も保護されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same header protection key is used for the duration of the connection, with the value not changing after a key update (see Section 6). This allows header protection to be used to protect the key phase.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じヘッダー保護キーが接続期間中に使用され、値はキーアップデート後に変更されません（セクション6を参照）。これにより、ヘッダー保護を使用してキーフェーズを保護できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This process does not apply to Retry or Version Negotiation packets, which do not contain a protected payload or any of the fields that are protected by this process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロセスは、再試行またはバージョンネゴシエーションパケットには適用されません。これは、保護されたペイロードまたはこのプロセスによって保護されているフィールドのいずれかを含みません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4-1--Header-Protection-Application">
5.4.1. Header Protection Application
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.1. ヘッダー保護アプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Header protection is applied after packet protection is applied (see Section 5.3). The ciphertext of the packet is sampled and used as input to an encryption algorithm. The algorithm used depends on the negotiated AEAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット保護が適用された後にヘッダ保護が適用されます（5.3項を参照）。パケットの暗号文はサンプリングされ、暗号化アルゴリズムへの入力として使用されます。使用されるアルゴリズムは、ネゴシエートされたAEADによって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The output of this algorithm is a 5-byte mask that is applied to the protected header fields using exclusive OR. The least significant bits of the first byte of the packet are masked by the least significant bits of the first mask byte, and the packet number is masked with the remaining bytes. Any unused bytes of mask that might result from a shorter packet number encoding are unused.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムの出力は、排他的論理和を使用して保護されたヘッダーフィールドに適用される5バイトのマスクです。パケットの最初のバイトの最下位ビットは、最初のマスクバイトの最下位ビットによってマスクされ、パケット番号は残りのバイトでマスクされます。より短いパケット番号エンコーディングから生じる可能性があるマスクの未使用のバイト数は未使用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 6 shows a sample algorithm for applying header protection. Removing header protection only differs in the order in which the packet number length (pn_length) is determined (here &#34;^&#34; is used to represent exclusive OR).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダ保護を適用するためのサンプルアルゴリズムを示す図である。ヘッダ保護の削除は、パケット番号長（PN_LENGTH）が決定される順序でのみ異なります（ここでは「^」は排他的論理和を表すために使用されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   mask = header_protection(hp_key, sample)

   pn_length = (packet[0] &amp; 0x03) + 1
   if (packet[0] &amp; 0x80) == 0x80:
      # Long header: 4 bits masked
      packet[0] ^= mask[0] &amp; 0x0f
   else:
      # Short header: 5 bits masked
      packet[0] ^= mask[0] &amp; 0x1f

   # pn_offset is the start of the Packet Number field.
   packet[pn_offset:pn_offset+pn_length] ^= mask[1:1+pn_length]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
Figure 6: Header Protection Pseudocode
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
図6：ヘッダー保護疑似コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specific header protection functions are defined based on the selected cipher suite; see Section 5.4.3 and Section 5.4.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のヘッダー保護機能は、選択した暗号スイートに基づいて定義されます。5.4.3節および5.4.4項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 7 shows an example long header packet (Initial) and a short header packet (1-RTT). Figure 7 shows the fields in each header that are covered by header protection and the portion of the protected packet payload that is sampled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図7は、ロングヘッダパケットの例（初期）と短いヘッダパケット（1  -  RTT）を示しています。図7は、ヘッダ保護によってカバーされている各ヘッダのフィールドとサンプリングされた保護されたパケットペイロードの部分を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Initial Packet {
     Header Form (1) = 1,
     Fixed Bit (1) = 1,
     Long Packet Type (2) = 0,
     Reserved Bits (2),         # Protected
     Packet Number Length (2),  # Protected
     Version (32),
     DCID Len (8),
     Destination Connection ID (0..160),
     SCID Len (8),
     Source Connection ID (0..160),
     Token Length (i),
     Token (..),
     Length (i),
     Packet Number (8..32),     # Protected
     Protected Payload (0..24), # Skipped Part
     Protected Payload (128),   # Sampled Part
     Protected Payload (..)     # Remainder
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1-RTT Packet {
     Header Form (1) = 0,
     Fixed Bit (1) = 1,
     Spin Bit (1),
     Reserved Bits (2),         # Protected
     Key Phase (1),             # Protected
     Packet Number Length (2),  # Protected
     Destination Connection ID (0..160),
     Packet Number (8..32),     # Protected
     Protected Payload (0..24), # Skipped Part
     Protected Payload (128),   # Sampled Part
     Protected Payload (..),    # Remainder
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Figure 7: Header Protection and Ciphertext Sample
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
図7：ヘッダー保護と暗号文のサンプル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before a TLS cipher suite can be used with QUIC, a header protection algorithm MUST be specified for the AEAD used with that cipher suite. This document defines algorithms for AEAD_AES_128_GCM, AEAD_AES_128_CCM, AEAD_AES_256_GCM (all these AES AEADs are defined in [AEAD]), and AEAD_CHACHA20_POLY1305 (defined in [CHACHA]). Prior to TLS selecting a cipher suite, AES header protection is used (Section 5.4.3), matching the AEAD_AES_128_GCM packet protection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS暗号スイートをQUICで使用する前に、その暗号スイートで使用されるAEADにヘッダー保護アルゴリズムを指定する必要があります。このドキュメントでは、AEAD_AES_128_GCM、AEAD_AES_128_CCM、AEAD_AES_256_GCMのアルゴリズムを定義します（これらすべてのAES AEADsは[AEAD]で定義されています）、AEAD_CHACHA20_POLY1305（[Chacha]で定義されています）。TLSの前に暗号スイートを選択する前に、AESヘッダー保護（セクション5.4.3）、AEAD_AES_128_GCMパケット保護と一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4-2--Header-Protection-Sample">
5.4.2. Header Protection Sample
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.2. ヘッダー保護のサンプル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The header protection algorithm uses both the header protection key and a sample of the ciphertext from the packet Payload field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダ保護アルゴリズムは、ヘッダ保護キーとパケットのPayloadフィールドから抽出した暗号文を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same number of bytes are always sampled, but an allowance needs to be made for the removal of protection by a receiving endpoint, which will not know the length of the Packet Number field. The sample of ciphertext is taken starting from an offset of 4 bytes after the start of the Packet Number field. That is, in sampling packet ciphertext for header protection, the Packet Number field is assumed to be 4 bytes long (its maximum possible encoded length).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じバイト数が常にサンプリングされますが、受信エンドポイントによって保護を削除するために手当を作成する必要があります。これにより、パケット番号フィールドの長さがわかりません。暗号文のサンプルは、パケット番号フィールドの開始後4バイトのオフセットから撮影されます。すなわち、ヘッダ保護用のサンプリングパケット暗号文において、パケット番号フィールドは4バイト長（その最大符号化長さ）と見なされる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint MUST discard packets that are not long enough to contain a complete sample.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、完全なサンプルを含めるのに十分な長さではないパケットを破棄しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To ensure that sufficient data is available for sampling, packets are padded so that the combined lengths of the encoded packet number and protected payload is at least 4 bytes longer than the sample required for header protection. The cipher suites defined in [TLS13] -- other than TLS_AES_128_CCM_8_SHA256, for which a header protection scheme is not defined in this document -- have 16-byte expansions and 16-byte header protection samples. This results in needing at least 3 bytes of frames in the unprotected payload if the packet number is encoded on a single byte, or 2 bytes of frames for a 2-byte packet number encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サンプリングに十分なデータが利用可能であることを確認するために、符号化されたパケット番号と保護されたペイロードの合成された長さが、ヘッダ保護に必要なサンプルより4バイト以上になるようにパケットが埋め込まれます。[TLS13]で定義された暗号スイート -  TLS_AES_128_CCM_8_SHA256以外に、ヘッダー保護方式はこのドキュメントに定義されていない -  16バイトの拡張と16バイトのヘッダー保護サンプルがあります。これにより、パケット番号が1バイト、または2バイトのパケット番号エンコードに対して2バイトのフレームでエンコードされている場合、保護されていないペイロード内の少なくとも3バイトのフレームが必要となる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sampled ciphertext can be determined by the following pseudocode:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サンプリングされた暗号文は、次の疑似コードによって決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   # pn_offset is the start of the Packet Number field.
   sample_offset = pn_offset + 4

   sample = packet[sample_offset..sample_offset+sample_length]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the packet number offset of a short header packet can be calculated as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
短いヘッダパケットのパケット番号オフセットを次のように計算できる場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   pn_offset = 1 + len(connection_id)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
And the packet number offset of a long header packet can be calculated as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長いヘッダーパケットのパケット番号オフセットは、次のように計算できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   pn_offset = 7 + len(destination_connection_id) +
                   len(source_connection_id) +
                   len(payload_length)
   if packet_type == Initial:
       pn_offset += len(token_length) +
                    len(token)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, for a packet with a short header, an 8-byte connection ID, and protected with AEAD_AES_128_GCM, the sample takes bytes 13 to 28 inclusive (using zero-based indexing).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、短いヘッダー、8バイトの接続ID、およびAEAD_AES_128_GCMで保護されているパケットの場合、サンプルは13から28を含む（ゼロベースの索引付けを使用）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiple QUIC packets might be included in the same UDP datagram. Each packet is handled separately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のQUICパケットが同じUDPデータグラムに含まれている可能性があります。各パケットは別々に処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4-3--AES-Based-Header-Protection">
5.4.3. AES-Based Header Protection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.3. AESベースのヘッダー保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section defines the packet protection algorithm for AEAD_AES_128_GCM, AEAD_AES_128_CCM, and AEAD_AES_256_GCM. AEAD_AES_128_GCM and AEAD_AES_128_CCM use 128-bit AES in Electronic Codebook (ECB) mode. AEAD_AES_256_GCM uses 256-bit AES in ECB mode. AES is defined in [AES].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、AEAD_AES_128_GCM、AEAD_AES_128_CCM、およびAEAD_AES_256_GCMのパケット保護アルゴリズムを定義します。AEAD_AES_128_GCMとAEAD_AES_128_CCMをECBモードで128ビットAESを使用します。AEAD_AES_256_GCMは、ECBモードで256ビットAESを使用します。AESは[AES]で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This algorithm samples 16 bytes from the packet ciphertext. This value is used as the input to AES-ECB. In pseudocode, the header protection function is defined as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムは、パケット暗号文から16バイトをサンプリングします。この値はAES-ECBへの入力として使用されます。疑似コードでは、ヘッダー保護機能は次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   header_protection(hp_key, sample):
     mask = AES-ECB(hp_key, sample)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4-4--ChaCha20-Based-Header-Protection">
5.4.4. ChaCha20-Based Header Protection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.4. Chacha20ベースのヘッダー保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When AEAD_CHACHA20_POLY1305 is in use, header protection uses the raw ChaCha20 function as defined in Section 2.4 of [CHACHA]. This uses a 256-bit key and 16 bytes sampled from the packet protection output.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AEAD_CHACHA20_POLY1305が使用されている場合、ヘッダー保護は[Chacha]のセクション2.4で定義されている生のCHACHA20関数を使用します。これにより、パケット保護出力からサンプリングされた256ビットキーと16バイトが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first 4 bytes of the sampled ciphertext are the block counter. A ChaCha20 implementation could take a 32-bit integer in place of a byte sequence, in which case, the byte sequence is interpreted as a little-endian value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サンプリングされた暗号文の最初の4バイトはブロックカウンタです。Chacha20実装では、バイトシーケンスの代わりに32ビット整数を取ることができ、その場合、バイトシーケンスはリトルエンディアン値として解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remaining 12 bytes are used as the nonce. A ChaCha20 implementation might take an array of three 32-bit integers in place of a byte sequence, in which case, the nonce bytes are interpreted as a sequence of 32-bit little-endian integers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残りの12バイトがナンスとして使用されます。Chacha20実装はバイトシーケンスの代わりに3つの32ビット整数の配列を取ります。その場合、ナンスのバイトは32ビットのリトルエンディアン整数のシーケンスとして解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The encryption mask is produced by invoking ChaCha20 to protect 5 zero bytes. In pseudocode, the header protection function is defined as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化マスクは、5バイトを保護するためにChacha20を呼び出すことによって生成されます。疑似コードでは、ヘッダー保護機能は次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   header_protection(hp_key, sample):
     counter = sample[0..3]
     nonce = sample[4..15]
     mask = ChaCha20(hp_key, counter, nonce, {0,0,0,0,0})
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-5--Receiving-Protected-Packets">
5.5. Receiving Protected Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. 保護されたパケットの受信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once an endpoint successfully receives a packet with a given packet number, it MUST discard all packets in the same packet number space with higher packet numbers if they cannot be successfully unprotected with either the same key, or -- if there is a key update -- a subsequent packet protection key; see Section 6. Similarly, a packet that appears to trigger a key update but cannot be unprotected successfully MUST be discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントが特定のパケット番号のパケットを正常に受信すると、同じキーで保護を解除できない場合、またはキーの更新がある場合は後続のパケット保護キーで保護を解除できない場合、パケット番号の大きい同じパケット番号スペース内のすべてのパケットを破棄する必要があります。セクション6を参照してください
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Failure to unprotect a packet does not necessarily indicate the existence of a protocol error in a peer or an attack. The truncated packet number encoding used in QUIC can cause packet numbers to be decoded incorrectly if they are delayed significantly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットを保護しないと、ピアまたは攻撃でプロトコルエラーが発生したことを必ずしも表示するわけではありません。QUICで使用される切り捨てられたパケット番号エンコーディングは、それらが大幅に遅れている場合にパケット番号を誤って復号化させる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-6--Use-of-0-RTT-Keys">
5.6. Use of 0-RTT Keys
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. 0-RTTキーの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If 0-RTT keys are available (see Section 4.6.1), the lack of replay protection means that restrictions on their use are necessary to avoid replay attacks on the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0-RTTキーが入手可能な場合（セクション4.6.1を参照）、再生保護の欠如は、プロトコルに対する再生攻撃を回避するために使用することに対する制限が必要であることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Of the frames defined in [QUIC-TRANSPORT], the STREAM, RESET_STREAM, STOP_SENDING, and CONNECTION_CLOSE frames are potentially unsafe for use with 0-RTT as they carry application data. Application data that is received in 0-RTT could cause an application at the server to process the data multiple times rather than just once. Additional actions taken by a server as a result of processing replayed application data could have unwanted consequences. A client therefore MUST NOT use 0-RTT for application data unless specifically requested by the application that is in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[QUIC-TRANSPORT]で定義されているフレームのうち、STREAM、RESET_STREAM、STOP_SENDING、およびCONNECTION_CLOSEフレームは、アプリケーションデータを搬送すると0-RTTで使用するための安全ではない。0-RTTで受信されたアプリケーションデータは、サーバーでアプリケーションが一度ではなく複数回データを処理する可能性があります。再生されたアプリケーションデータの処理の結果としてサーバーによって取られた追加の行動は、不要な結果を持つ可能性があります。したがって、使用中のアプリケーションによって明確に要求されない限り、クライアントはアプリケーションデータに0-RTTを使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application protocol that uses QUIC MUST include a profile that defines acceptable use of 0-RTT; otherwise, 0-RTT can only be used to carry QUIC frames that do not carry application data. For example, a profile for HTTP is described in [HTTP-REPLAY] and used for HTTP/3; see Section 10.9 of [QUIC-HTTP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICを使用するアプリケーションプロトコルは、0-RTTの許容可能な使用を定義するプロファイルを含める必要があります。それ以外の場合、0-RTTはアプリケーションデータを搬送しないQUICフレームを運ぶためにのみ使用できます。たとえば、HTTPのプロファイルは[HTTP-REPLAY]で説明され、HTTP/3に使用されます。[QUIC-HTTP]の10.9項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Though replaying packets might result in additional connection attempts, the effect of processing replayed frames that do not carry application data is limited to changing the state of the affected connection. A TLS handshake cannot be successfully completed using replayed packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットを再生すると、追加の接続試行が発生する可能性がありますが、アプリケーションデータを搬送しない再生フレームの処理の効果は、影響を受ける接続の状態を変更することです。TLSハンドシェイクは、再生されたパケットを使用して正常に完了できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client MAY wish to apply additional restrictions on what data it sends prior to the completion of the TLS handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、TLSハンドシェイクが完了する前に送信するデータに追加の制限を適用したい場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client otherwise treats 0-RTT keys as equivalent to 1-RTT keys, except that it cannot send certain frames with 0-RTT keys; see Section 12.5 of [QUIC-TRANSPORT].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その他の点では、0-RTTキーを0-RTTキーに送信できないことを除いて、1-RTTキーと同等の0-RTTキーを扱います。[QUIC-TRANSPORT]の12.5節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client that receives an indication that its 0-RTT data has been accepted by a server can send 0-RTT data until it receives all of the server&#39;s handshake messages. A client SHOULD stop sending 0-RTT data if it receives an indication that 0-RTT data has been rejected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その0-RTTデータがサーバーによって受け入れられたという指示を受け取るクライアントは、すべてのサーバーのハンドシェイクメッセージを受信するまで0-RTTのデータを送信できます。クライアントが0-RTTデータが拒否されたという表示を受信した場合、0-RTTデータの送信を停止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MUST NOT use 0-RTT keys to protect packets; it uses 1-RTT keys to protect acknowledgments of 0-RTT packets. A client MUST NOT attempt to decrypt 0-RTT packets it receives and instead MUST discard them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットを保護するためにサーバーが0-RTTキーを使用してはいけません。0-RTTパケットの確認応答を保護するために1-RTTキーを使用します。クライアントが受信した0-RTTパケットの復号化を試みてはならず、代わりにそれらを破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a client has installed 1-RTT keys, it MUST NOT send any more 0-RTT packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが1-RTTキーをインストールしたら、0-RTTパケットを送信してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: 0-RTT data can be acknowledged by the server as it receives it, but any packets containing acknowledgments of 0-RTT data cannot have packet protection removed by the client until the TLS handshake is complete.  The 1-RTT keys necessary to remove packet protection cannot be derived until the client receives all server handshake messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：0-RTTデータは、サーバーが受信したときに確認応答できますが、0-RTTデータの確認応答を含むパケットは、TLSハンドシェイクが完了するまで、クライアントがパケット保護を削除することはできません。 パケット保護を削除するために必要な1-RTTキーは、クライアントがすべてのサーバーハンドシェイクメッセージを受信するまで取得できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-7--Receiving-Out-of-Order-Protected-Packets">
5.7. Receiving Out-of-Order Protected Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7. 異常な保護パケットの受信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Due to reordering and loss, protected packets might be received by an endpoint before the final TLS handshake messages are received. A client will be unable to decrypt 1-RTT packets from the server, whereas a server will be able to decrypt 1-RTT packets from the client. Endpoints in either role MUST NOT decrypt 1-RTT packets from their peer prior to completing the handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
並べ替えや損失のため、最後のTLSハンドシェイクメッセージが受信される前に、保護されたパケットがエンドポイントによって受信される可能性があります。クライアントはサーバーから1-RTTパケットを復号化できませんが、サーバーはクライアントから1-RTTパケットを復号化できます。どちらの役割のエンドポイントも、ハンドシェイクを完了する前に、ピアから1 RTTパケットを復号化してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even though 1-RTT keys are available to a server after receiving the first handshake messages from a client, it is missing assurances on the client state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントから最初のハンドシェイクメッセージを受信した後、1-RTTキーをサーバーに使用できる場合でも、クライアントの状態の保証がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The client is not authenticated, unless the server has chosen to use a pre-shared key and validated the client&#39;s pre-shared key binder; see Section 4.2.11 of [TLS13].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* サーバーが事前共有キーを使用してクライアントの事前共有キーバインダーを検証した場合を除き、クライアントは認証されません。[TLS13]の4.2.11節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The client has not demonstrated liveness, unless the server has validated the client&#39;s address with a Retry packet or other means; see Section 8.1 of [QUIC-TRANSPORT].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* サーバーがリトライパケットまたは他の手段を使用してクライアントのアドレスを検証していない限り、クライアントは活性を示していません。[QUIC-TRANSPORT]のセクション8.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Any received 0-RTT data that the server responds to might be due to a replay attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* サーバーが応答する受信された0-RTTデータは、再生攻撃によるものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, the server&#39;s use of 1-RTT keys before the handshake is complete is limited to sending data. A server MUST NOT process incoming 1-RTT protected packets before the TLS handshake is complete. Because sending acknowledgments indicates that all frames in a packet have been processed, a server cannot send acknowledgments for 1-RTT packets until the TLS handshake is complete. Received packets protected with 1-RTT keys MAY be stored and later decrypted and used once the handshake is complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、ハンドシェイクが完成する前の1-RTTキーのサーバーの使用はデータの送信に制限されています。TLSハンドシェイクが完了する前に、サーバーは着信1-RTT保護パケットを処理してはなりません。送信確認応答は、パケット内のすべてのフレームが処理されたことを示し、サーバーはTLSハンドシェイクが完了するまで1 RTTパケットに対して確認応答を送信できません。1-RTTキーで保護された受信パケットは、ハンドシェイクが完了すると、保存され、後で復号化され、使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: TLS implementations might provide all 1-RTT secrets prior to handshake completion.  Even where QUIC implementations have 1-RTT read keys, those keys are not to be used prior to completing the handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：TLS実装は、ハンドシェイクが完了する前にすべての1-RTTシークレットを提供する場合があります。 QUIC実装に1-RTT読み取りキーがある場合でも、ハンドシェイクを完了する前にそれらのキーを使用することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The requirement for the server to wait for the client Finished message creates a dependency on that message being delivered. A client can avoid the potential for head-of-line blocking that this implies by sending its 1-RTT packets coalesced with a Handshake packet containing a copy of the CRYPTO frame that carries the Finished message, until one of the Handshake packets is acknowledged. This enables immediate server processing for those packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが完了したメッセージが完了したメッセージを待つサーバーの要件は、そのメッセージが配信されているそのメッセージに依存します。クライアントは、これが完成したメッセージを搭載したCryptoフレームのコピーを含むハンドシェイクパケットと合成したその1 RTTパケットを承認するまで、これがその1-RTTパケットを送信することによって暗証率ブロックの可能性を避けることができる。これにより、それらのパケットに対して即時のサーバー処理が可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server could receive packets protected with 0-RTT keys prior to receiving a TLS ClientHello. The server MAY retain these packets for later decryption in anticipation of receiving a ClientHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、TLS ClientHelloを受信する前に、0-RTTキーで保護されているパケットを受信できます。サーバは、ClientHelloを受信することを見越して後の復号化のためにこれらのパケットを保持することができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client generally receives 1-RTT keys at the same time as the handshake completes. Even if it has 1-RTT secrets, a client MUST NOT process incoming 1-RTT protected packets before the TLS handshake is complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは一般に、ハンドシェイクが完了するのと同時に1-RTTキーを受信します。1-RTTの秘密がある場合でも、TLSハンドシェイクが完了する前に、クライアントは着信1-RTT保護パケットを処理してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-8--Retry-Packet-Integrity">
5.8. Retry Packet Integrity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8. リトライパケットの完全性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Retry packets (see Section 17.2.5 of [QUIC-TRANSPORT]) carry a Retry Integrity Tag that provides two properties: it allows the discarding of packets that have accidentally been corrupted by the network, and only an entity that observes an Initial packet can send a valid Retry packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再試行パケット（[QUIC-TRANSPORTのセクション17.2.5]を参照）は2つのプロパティを提供する再試行整合性タグを搭載します。これにより、ネットワークによって誤って破損しているパケットを破棄し、初期パケットを守るエンティティのみを廃棄できます。有効な再試行パケットを送信してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Retry Integrity Tag is a 128-bit field that is computed as the output of AEAD_AES_128_GCM [AEAD] used with the following inputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Retry Integrityタグは、次の入力で使用されているAEAD_AES_128_GCM [AEAD]の出力として計算される128ビットフィールドです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The secret key, K, is 128 bits equal to 0xbe0c690b9f66575a1d766b54e368c84e.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 秘密鍵 K は、0xbe0c690b9f66575a1d766b54e368c84e の128ビットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The nonce, N, is 96 bits equal to 0x461599d35d632bf2239825bb.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ナンス N は、0x461599d35d632bf2239825bb の96ビットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The plaintext, P, is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 平文 P は空文字です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The associated data, A, is the contents of the Retry Pseudo-Packet, as illustrated in Figure 8:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 関連データ A は、図8に示すように、再試行疑似パケットの内容です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The secret key and the nonce are values derived by calling HKDF-Expand-Label using 0xd9c9943e6101fd200021506bcc02814c73030f25c79d71ce876eca876e6fca8e as the secret, with labels being &#34;quic key&#34; and &#34;quic iv&#34; (Section 5.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
秘密鍵とNonceは、0xd9c9943e6101fd200021506bcc02814c73030f25c79d71ce876eca876e6fca8e を使ってHKDF-Expand-Labelで導出した秘密で、ラベルは「quic key」と「quic iv」（セクション5.1）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Retry Pseudo-Packet {
     ODCID Length (8),
     Original Destination Connection ID (0..160),
     Header Form (1) = 1,
     Fixed Bit (1) = 1,
     Long Packet Type (2) = 3,
     Unused (4),
     Version (32),
     DCID Len (8),
     Destination Connection ID (0..160),
     SCID Len (8),
     Source Connection ID (0..160),
     Retry Token (..),
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
Figure 8: Retry Pseudo-Packet
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
図8：再試行疑似パケット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Retry Pseudo-Packet is not sent over the wire. It is computed by taking the transmitted Retry packet, removing the Retry Integrity Tag, and prepending the two following fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リトライ疑似パケットはワイヤー上には送信されません。送信された再試行パケットを取得し、Retry Integrityタグを削除し、次の2つのフィールドを付加することによって計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ODCID Length: The ODCID Length field contains the length in bytes of the Original Destination Connection ID field that follows it, encoded as an 8-bit unsigned integer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ODCID長：ODCID長フィールドには、それに続く元の宛先接続IDフィールドの長さが含まれています。これは、8ビットの符号なし整数としてエンコードされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Original Destination Connection ID: The Original Destination Connection ID contains the value of the Destination Connection ID from the Initial packet that this Retry is in response to. The length of this field is given in ODCID Length. The presence of this field ensures that a valid Retry packet can only be sent by an entity that observes the Initial packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
元の宛先接続ID：元の宛先接続IDには、最初のパケットからの宛先接続IDの値が、この再試行が対応していることが含まれています。このフィールドの長さはODCIDの長さで与えられます。このフィールドの存在は、有効な再試行パケットが最初のパケットを監視するエンティティによってのみ送信されることができるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Key-Update">
6. Key Update
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. キーアップデート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the handshake is confirmed (see Section 4.1.2), an endpoint MAY initiate a key update.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハンドシェイクが確認されると（セクション4.1.2参照）、エンドポイントはキーアップデートを開始することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Key Phase bit indicates which packet protection keys are used to protect the packet. The Key Phase bit is initially set to 0 for the first set of 1-RTT packets and toggled to signal each subsequent key update.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーフェーズビットは、パケットを保護するためにどのパケット保護キーを使用するかを示します。キーフェーズビットは、最初は1つの1-RTTパケットのセットに対して0に設定され、後続の各キーアップデートの信号をシグナルに切り替えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Key Phase bit allows a recipient to detect a change in keying material without needing to receive the first packet that triggered the change. An endpoint that notices a changed Key Phase bit updates keys and decrypts the packet that contains the changed value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーフェーズビットは、受信者が、変更をトリガする最初のパケットを受信する必要なしにキーイングマテリアルの変更を検出することを可能にする。変更されたキーフェーズビットに通知されるエンドポイントは、キーが更新され、変更された値を含むパケットを復号化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initiating a key update results in both endpoints updating keys. This differs from TLS where endpoints can update keys independently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キー更新を開始すると、両方のエンドポイントがキーを更新します。これは、エンドポイントがキーを独立して更新できるTLSとは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This mechanism replaces the key update mechanism of TLS, which relies on KeyUpdate messages sent using 1-RTT encryption keys. Endpoints MUST NOT send a TLS KeyUpdate message. Endpoints MUST treat the receipt of a TLS KeyUpdate message as a connection error of type 0x010a, equivalent to a fatal TLS alert of unexpected_message; see Section 4.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメカニズムは、1-RTT暗号化キーを使用して送信されたKeyUpdateメッセージに依存するTLSのキーアップデートメカニズムを置き換えます。エンドポイントはTLS KeyUpdateメッセージを送信してはいけません。エンドポイントは、TLS keyUpdateメッセージの受信をTLS 0x010Aの接続エラーとして扱う必要があります。セクション4.8を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 9 shows a key update process, where the initial set of keys used (identified with @M) are replaced by updated keys (identified with @N). The value of the Key Phase bit is indicated in brackets [].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図9は、使用されているキーのセット（@M）が更新されたキー（@N）に置き換えられているキーアップデートプロセスを示しています。キー位相ビットの値は大括弧[]に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Initiating Peer                    Responding Peer

   @M [0] QUIC Packets

   ... Update to @N
   @N [1] QUIC Packets
                         --------&gt;
                                            Update to @N ...
                                         QUIC Packets [1] @N
                         &lt;--------
                                         QUIC Packets [1] @N
                                       containing ACK
                         &lt;--------
   ... Key Update Permitted
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   @N [1] QUIC Packets
            containing ACK for @N packets
                         --------&gt;
                                    Key Update Permitted ...
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-28">
Figure 9: Key Update
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-28">
図9：キーの更新
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1--Initiating-a-Key-Update">
6.1. Initiating a Key Update
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. キーアップデートを開始します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints maintain separate read and write secrets for packet protection. An endpoint initiates a key update by updating its packet protection write secret and using that to protect new packets. The endpoint creates a new write secret from the existing write secret as performed in Section 7.2 of [TLS13]. This uses the KDF function provided by TLS with a label of &#34;quic ku&#34;. The corresponding key and IV are created from that secret as defined in Section 5.1. The header protection key is not updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、パケット保護のための個別の読み書き秘密を維持します。エンドポイントは、パケット保護の書き込み秘密を更新し、新しいパケットを保護するためにそれを使用してキーアップデートを開始します。エンドポイントは、[TLS13]のセクション7.2で実行された既存の書き込み秘密から新しい書き込み秘密を作成します。これは、TLSによって提供されるKDF関数を「QUIC KU」のラベルを使用します。対応するキーとIVは、セクション5.1で定義されているようにその秘密から作成されます。ヘッダー保護キーは更新されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, to update write keys with TLS 1.3, HKDF-Expand-Label is used as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、TLS 1.3で書き込みキーを更新するには、HKDF-Expand-Labelが次のように使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   secret_&lt;n+1&gt; = HKDF-Expand-Label(secret_&lt;n&gt;, &#34;quic ku&#34;,
                                    &#34;&#34;, Hash.length)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The endpoint toggles the value of the Key Phase bit and uses the updated key and IV to protect all subsequent packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントはキーフェーズビットの値を切り替え、更新キーとIVを使用して後続のすべてのパケットを保護します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint MUST NOT initiate a key update prior to having confirmed the handshake (Section 4.1.2). An endpoint MUST NOT initiate a subsequent key update unless it has received an acknowledgment for a packet that was sent protected with keys from the current key phase. This ensures that keys are available to both peers before another key update can be initiated. This can be implemented by tracking the lowest packet number sent with each key phase and the highest acknowledged packet number in the 1-RTT space: once the latter is higher than or equal to the former, another key update can be initiated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、ハンドシェイクを確認した前にキーアップデートを開始してはなりません（セクション4.1.2）。現在のキーフェーズからのキーで保護されたパケットの確認応答を受け取っていない限り、エンドポイントは後続のキーアップデートを開始してはなりません。これにより、別のキーアップデートを開始する前に、キーが両方のピアに使用可能になります。これは、各キーフェーズで送信された最低パケット番号と1-RTTスペース内の最も高い確認されたパケット番号を追跡することによって実装することができます。後者が前者以上であると、別のキーアップデートを開始することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: Keys of packets other than the 1-RTT packets are never updated; their keys are derived solely from the TLS handshake state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注：1-RTTパケット以外のパケットのキーは更新されません。 それらのキーは、TLSハンドシェイク状態からのみ派生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The endpoint that initiates a key update also updates the keys that it uses for receiving packets. These keys will be needed to process packets the peer sends after updating.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーアップデートを開始するエンドポイントは、パケットの受信に使用するキーも更新されます。これらのキーは、更新後にピア送信をパケットを処理するために必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint MUST retain old keys until it has successfully unprotected a packet sent using the new keys. An endpoint SHOULD retain old keys for some time after unprotecting a packet sent using the new keys. Discarding old keys too early can cause delayed packets to be discarded. Discarding packets will be interpreted as packet loss by the peer and could adversely affect performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、新しいキーを使用して送信されたパケットが保護されていないまで、古いキーを保持する必要があります。新しいキーを使用して送信されたパケットを保護しないと、エンドポイントはしばらくの間古いキーを保持する必要があります。古いキーを捨てると、遅延パケットを破棄することがあります。パケットを破棄するパケットは、ピアによるパケット損失として解釈され、パフォーマンスに悪影響を及ぼす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2--Responding-to-a-Key-Update">
6.2. Responding to a Key Update
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. キーアップデートへの応答
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer is permitted to initiate a key update after receiving an acknowledgment of a packet in the current key phase. An endpoint detects a key update when processing a packet with a key phase that differs from the value used to protect the last packet it sent. To process this packet, the endpoint uses the next packet protection key and IV. See Section 6.3 for considerations about generating these keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のキーフェーズ内のパケットの確認応答を受け取った後、ピアはキーアップデートを開始することが許可されています。エンドポイントは、送信された最後のパケットを保護するために使用される値とは異なるキーフェーズでパケットを処理するときにキーアップデートを検出します。このパケットを処理するために、エンドポイントは次のパケット保護キーとIVを使用します。これらのキーの生成に関する考慮事項については、セクション6.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a packet is successfully processed using the next key and IV, then the peer has initiated a key update. The endpoint MUST update its send keys to the corresponding key phase in response, as described in Section 6.1. Sending keys MUST be updated before sending an acknowledgment for the packet that was received with updated keys. By acknowledging the packet that triggered the key update in a packet protected with the updated keys, the endpoint signals that the key update is complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のキーとIVを使用してパケットが正常に処理された場合、ピアはキーアップデートを開始しました。セクション6.1で説明されているように、エンドポイントはその送信キーを応答して対応するキーフェーズに更新する必要があります。更新されたキーで受信したパケットの確認応答を送信する前に、キーを送信する必要があります。更新されたキーで保護されたパケット内のキー更新をトリガしたパケットを認めて、キー更新が完了したエンドポイント信号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint can defer sending the packet or acknowledgment according to its normal packet sending behavior; it is not necessary to immediately generate a packet in response to a key update. The next packet sent by the endpoint will use the updated keys. The next packet that contains an acknowledgment will cause the key update to be completed. If an endpoint detects a second update before it has sent any packets with updated keys containing an acknowledgment for the packet that initiated the key update, it indicates that its peer has updated keys twice without awaiting confirmation. An endpoint MAY treat such consecutive key updates as a connection error of type KEY_UPDATE_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、通常のパケット送信動作に従ってパケットまたは確認応答を延期することができます。キーアップデートに応答してすぐにパケットを生成する必要はありません。エンドポイントによって送信された次のパケットは更新されたキーを使用します。確認応答を含む次のパケットは、キーアップデートを完了させます。キーアップデートを開始したパケットの確認応答を含む更新されたキーを含むパケットを送信する前にエンドポイントが2番目の更新を検出した場合、そのピアが確認を待っていることなく2回キーを2回更新していることを示します。エンドポイントは、そのような連続したキー更新をタイプkey_update_error型の接続エラーとして扱うことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint that receives an acknowledgment that is carried in a packet protected with old keys where any acknowledged packet was protected with newer keys MAY treat that as a connection error of type KEY_UPDATE_ERROR. This indicates that a peer has received and acknowledged a packet that initiates a key update, but has not updated keys in response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認されたパケットが新しいキーで保護されていた古いキーで保護されたパケットで搬送されるエンドポイントは、key_update_error型の接続エラーとしてそれを扱うことができます。これは、ピアがキーアップデートを開始するパケットを受信して認識したが、それに応答して更新されていないパケットを受信したことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3--Timing-of-Receive-Key-Generation">
6.3. Timing of Receive Key Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. 受信キーの生成のタイミング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints responding to an apparent key update MUST NOT generate a timing side-channel signal that might indicate that the Key Phase bit was invalid (see Section 9.5). Endpoints can use randomized packet protection keys in place of discarded keys when key updates are not yet permitted. Using randomized keys ensures that attempting to remove packet protection does not result in timing variations, and results in packets with an invalid Key Phase bit being rejected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
見かけのキーアップデートに応答するエンドポイントは、キーフェーズビットが無効であることを示す可能性があるタイミングサイドチャネル信号を生成してはいけません（セクション9.5を参照）。エンドポイントは、キーアップデートがまだ許可されていない場合、廃棄されたキーの代わりにランダム化されたパケット保護キーを使用できます。ランダム化キーを使用すると、パケット保護を除去しようとするとタイミングバリエーションが発生しないことが保証され、無効なキーフェーズビットが拒否されたパケットが表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The process of creating new packet protection keys for receiving packets could reveal that a key update has occurred. An endpoint MAY generate new keys as part of packet processing, but this creates a timing signal that could be used by an attacker to learn when key updates happen and thus leak the value of the Key Phase bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットを受信するための新しいパケット保護キーを作成するプロセスは、キーアップデートが発生したことを明らかにします。エンドポイントは、パケット処理の一部として新しいキーを生成する可能性があるが、これは攻撃者がキー更新が発生したときに学習するために攻撃者によって使用され得るタイミング信号を作成する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints are generally expected to have current and next receive packet protection keys available. For a short period after a key update completes, up to the PTO, endpoints MAY defer generation of the next set of receive packet protection keys. This allows endpoints to retain only two sets of receive keys; see Section 6.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは一般に、現在および次の受信パケット保護キーを使用可能になると予想されます。キーアップデートが完了した後、PTOまでの間、エンドポイントは次の受信パケット保護キーのセットの生成を延期することがある。これにより、エンドポイントは2セットの受信キーのみを保持することができます。6.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once generated, the next set of packet protection keys SHOULD be retained, even if the packet that was received was subsequently discarded. Packets containing apparent key updates are easy to forge, and while the process of key update does not require significant effort, triggering this process could be used by an attacker for DoS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一旦生成されると、受信したパケットが続いて破棄されたとしても、次のパケット保護キーのセットを保持する必要があります。見かけのキーアップデートを含むパケットは鍛造が容易であり、キーアップデートのプロセスは大きな努力を必要としないが、このプロセスを起動することはDOSの攻撃者によって使用され得る。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For this reason, endpoints MUST be able to retain two sets of packet protection keys for receiving packets: the current and the next. Retaining the previous keys in addition to these might improve performance, but this is not essential.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このため、エンドポイントは、パケットを受信するための2セットのパケット保護キーを保持できる必要があります。これらに加えて前のキーを保持すると、パフォーマンスが向上する可能性がありますが、これは必須ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4--Sending-with-Updated-Keys">
6.4. Sending with Updated Keys
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. 更新された鍵による送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint never sends packets that are protected with old keys. Only the current keys are used. Keys used for protecting packets can be discarded immediately after switching to newer keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは古いキーで保護されているパケットを送信しません。現在のキーのみが使用されます。パケットを保護するために使用されるキーは、新しいキーに切り替えた直後に破棄できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packets with higher packet numbers MUST be protected with either the same or newer packet protection keys than packets with lower packet numbers. An endpoint that successfully removes protection with old keys when newer keys were used for packets with lower packet numbers MUST treat this as a connection error of type KEY_UPDATE_ERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
より高いパケット番号を持つパケットは、パケット番号が小さいパケットよりも同じまたは新しいパケット保護キーで保護する必要があります。より低いパケット番号を持つパケットに新しいキーを使用したときに古いキーを使用して保護を削除するエンドポイントは、これをキー_Update_Error型の接続エラーとして扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-5--Receiving-with-Different-Keys">
6.5. Receiving with Different Keys
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. 異なる鍵による受信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For receiving packets during a key update, packets protected with older keys might arrive if they were delayed by the network. Retaining old packet protection keys allows these packets to be successfully processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーアップデート中にパケットを受信するために、古いキーで保護されているパケットがネットワークによって遅延された場合に到着する可能性があります。古いパケット保護キーを保持すると、これらのパケットを正常に処理できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As packets protected with keys from the next key phase use the same Key Phase value as those protected with keys from the previous key phase, it is necessary to distinguish between the two if packets protected with old keys are to be processed. This can be done using packet numbers. A recovered packet number that is lower than any packet number from the current key phase uses the previous packet protection keys; a recovered packet number that is higher than any packet number from the current key phase requires the use of the next packet protection keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のキーフェーズからのキーで保護されているパケットが、前のキーフェーズからのキーで保護されているものと同じキー位相値を使用しているため、古いキーで保護されているIFパケットを2つ区別する必要があります。これはパケット番号を使用して行うことができます。現在のキーフェーズからのパケット番号より低い回復したパケット番号は、前のパケット保護キーを使用します。現在のキーフェーズからのパケット番号よりも高い回復されたパケット番号は、次のパケット保護キーを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some care is necessary to ensure that any process for selecting between previous, current, and next packet protection keys does not expose a timing side channel that might reveal which keys were used to remove packet protection. See Section 9.5 for more information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前の、電流、および次のパケット保護キーを選択するプロセスが、パケット保護を除去するために使用されたタイミングサイドチャネルを公開しないようにするために、いくつかの注意が必要です。詳細については9.5項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alternatively, endpoints can retain only two sets of packet protection keys, swapping previous for next after enough time has passed to allow for reordering in the network. In this case, the Key Phase bit alone can be used to select keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あるいは、エンドポイントは2セットのパケット保護キーのみを保持することができ、ネットワーク内の並べ替えを可能にするのに十分な時間が経過した後に次のために前のためにスワッピングすることができます。この場合、キーフェーズビットのみを使用してキーを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint MAY allow a period of approximately the Probe Timeout (PTO; see [QUIC-RECOVERY]) after promoting the next set of receive keys to be current before it creates the subsequent set of packet protection keys. These updated keys MAY replace the previous keys at that time. With the caveat that PTO is a subjective measure -- that is, a peer could have a different view of the RTT -- this time is expected to be long enough that any reordered packets would be declared lost by a peer even if they were acknowledged and short enough to allow a peer to initiate further key updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、次の受信キーのセットを作成する前に、プローブタイムアウトの周期（PTO; [QUIC-Recovery]を参照）の後続のパケット保護キーのセットを作成する前に行うことができます。これらの更新されたキーはその時点で前のキーを置き換えることができます。PTOが主観的な尺度であるという警告を使用して、その議案はRTTの異なる見方をすることができます - 今回は、並べ替えられたパケットが承認されたとしても、並べ替えされたパケットが宣言されるのに十分な長さであると予想されます。そしてピアがさらなる重要な更新を開始できるように十分に短い。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints need to allow for the possibility that a peer might not be able to decrypt packets that initiate a key update during the period when the peer retains old keys. Endpoints SHOULD wait three times the PTO before initiating a key update after receiving an acknowledgment that confirms that the previous key update was received. Failing to allow sufficient time could lead to packets being discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、ピアが古いキーを保持する期間中にキーアップデートを開始するパケットを復号化できない可能性がある可能性を考慮する必要があります。前のキー更新が受信されたことを確認する確認応答を受け取った後、エンドポイントは、確認応答を受信した後にキーアップデートを開始する前に、PTOの3回待機する必要があります。十分な時間を許可することに失敗すると、パケットが破棄される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint SHOULD retain old read keys for no more than three times the PTO after having received a packet protected using the new keys. After this period, old read keys and their corresponding secrets SHOULD be discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、新しいキーを使用して保護されたパケットを受信した後、PTOの3回以内の古い読み取りキーを保持する必要があります。この期間の後、古い読み取りキーとそれらの対応する秘密は破棄されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-6--Limits-on-AEAD-Usage">
6.6. Limits on AEAD Usage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6. AEAD使用の制限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document sets usage limits for AEAD algorithms to ensure that overuse does not give an adversary a disproportionate advantage in attacking the confidentiality and integrity of communications when using QUIC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、QUICを使用するときに機密性と通信の完全性を攻撃する際に、不用格に不均衡な利点を攻撃しないようにするために、AEADアルゴリズムの使用制限を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The usage limits defined in TLS 1.3 exist for protection against attacks on confidentiality and apply to successful applications of AEAD protection. The integrity protections in authenticated encryption also depend on limiting the number of attempts to forge packets. TLS achieves this by closing connections after any record fails an authentication check. In comparison, QUIC ignores any packet that cannot be authenticated, allowing multiple forgery attempts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS 1.3で定義されている使用制限は、機密性に対する攻撃に対する保護に存在し、AEAD保護の成功申請に適用されます。認証された暗号化の整合性保護はまた、パケットを偽造するための試み回数を制限することによって異なります。認証確認に失敗した後に接続を閉じることによってTLSがこれを達成します。比較すると、QUICは認証できないパケットを無視し、複数の偽造試行を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC accounts for AEAD confidentiality and integrity limits separately. The confidentiality limit applies to the number of packets encrypted with a given key. The integrity limit applies to the number of packets decrypted within a given connection. Details on enforcing these limits for each AEAD algorithm follow below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AEAD機密性と完全性制限を別々に求める熟練した勘定科目。機密性の制限は、特定のキーで暗号化されたパケット数に適用されます。整合性制限は、特定の接続内で復号化されたパケット数に適用されます。以下のAEADアルゴリズムごとにこれらの制限を強制する方法の詳細。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints MUST count the number of encrypted packets for each set of keys. If the total number of encrypted packets with the same key exceeds the confidentiality limit for the selected AEAD, the endpoint MUST stop using those keys. Endpoints MUST initiate a key update before sending more protected packets than the confidentiality limit for the selected AEAD permits. If a key update is not possible or integrity limits are reached, the endpoint MUST stop using the connection and only send stateless resets in response to receiving packets. It is RECOMMENDED that endpoints immediately close the connection with a connection error of type AEAD_LIMIT_REACHED before reaching a state where key updates are not possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、各キーのセットの暗号化パケットの数をカウントする必要があります。同じキーを持つ暗号化パケットの総数が選択されたAEADの機密性制限を超えると、エンドポイントはそれらのキーを使用して停止する必要があります。エンドポイントは、選択したAEAD許可の機密性限界よりも、より保護されたパケットを送信する前にキーアップデートを開始する必要があります。キーアップデートが不可能または整合性の制限に達すると、エンドポイントは接続の使用を停止し、受信パケットに応答してステートレスリセットを送信するだけです。エンドポイントは、キーアップデートが不可能な状態に達する前に、AEAD_LIMIT_REACHEDの接続エラーとの接続を直ちに閉じることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For AEAD_AES_128_GCM and AEAD_AES_256_GCM, the confidentiality limit is 2^23 encrypted packets; see Appendix B.1. For AEAD_CHACHA20_POLY1305, the confidentiality limit is greater than the number of possible packets (2^62) and so can be disregarded. For AEAD_AES_128_CCM, the confidentiality limit is 2^21.5 encrypted packets; see Appendix B.2. Applying a limit reduces the probability that an attacker can distinguish the AEAD in use from a random permutation; see [AEBounds], [ROBUST], and [GCM-MU].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AEAD_AES_128_GCMおよびAEAD_AES_256_GCMの場合、機密性の制限は2^23暗号化されたパケットです。付録B.1を参照してください。aead_chacha20_poly1305の場合、機密性の制限は可能なパケットの数より多い（2^62）、無視することができます。AEAD_AES_128_CCMの場合、機密性の制限は2^21.5暗号化されたパケットです。付録B.2を参照してください。制限を適用すると、攻撃者がランダムな置換から使用中のAEADを区別できる確率が低下します。[AEBounds]、[ROBUST]、[GCM-MU]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to counting packets sent, endpoints MUST count the number of received packets that fail authentication during the lifetime of a connection. If the total number of received packets that fail authentication within the connection, across all keys, exceeds the integrity limit for the selected AEAD, the endpoint MUST immediately close the connection with a connection error of type AEAD_LIMIT_REACHED and not process any more packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信されたパケットのカウントに加えて、エンドポイントは接続の有効期間中に認証に失敗した受信パケットの数をカウントする必要があります。接続内の認証に失敗した受信パケットの総数が、選択されたAEADの整合性制限を超えている場合、エンドポイントはAEAD_LIMIT_RIMIT_REACHED型の接続エラーとの接続を直ちに閉じる必要があり、それ以上のパケットを処理しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For AEAD_AES_128_GCM and AEAD_AES_256_GCM, the integrity limit is 2^52 invalid packets; see Appendix B.1. For AEAD_CHACHA20_POLY1305, the integrity limit is 2^36 invalid packets; see [AEBounds]. For AEAD_AES_128_CCM, the integrity limit is 2^21.5 invalid packets; see Appendix B.2. Applying this limit reduces the probability that an attacker can successfully forge a packet; see [AEBounds], [ROBUST], and [GCM-MU].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AEAD_AES_128_GCMおよびAEAD_AES_256_GCMの場合、整合性制限は2^52無効なパケットです。付録B.1を参照してください。AEAD_CHACHA20_POLY1305の場合、整合性制限は2^36無効なパケットです。[AEBounds]を参照してください。AEAD_AES_128_CCMの場合、整合性制限は2^21 21.5無効なパケットです。付録B.2を参照してください。この制限を適用すると、攻撃者がパケットを偽造できた可能性が低下します。[AEBounds]、[ROBUST]、[GCM-MU]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints that limit the size of packets MAY use higher confidentiality and integrity limits; see Appendix B for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットのサイズを制限するエンドポイントは、より高い機密性と完全性の制限を使用する可能性があります。詳細については付録Bを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Future analyses and specifications MAY relax confidentiality or integrity limits for an AEAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将来の分析と仕様は、AEADの機密性や完全性の制限を緩和することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any TLS cipher suite that is specified for use with QUIC MUST define limits on the use of the associated AEAD function that preserves margins for confidentiality and integrity. That is, limits MUST be specified for the number of packets that can be authenticated and for the number of packets that can fail authentication. Providing a reference to any analysis upon which values are based -- and any assumptions used in that analysis -- allows limits to be adapted to varying usage conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICで使用するように指定されているTLS暗号スイートは、機密性と整合性のためのマージンを保持する関連するAEAD関数を使用する限界を定義しなければなりません。つまり、認証可能なパケットの数と認証に失敗する可能性があるパケットの数に制限を指定する必要があります。どの値が基づいているか、およびその分析で使用されている任意の仮定への参照を提供する - 制限を様々な使用条件に適応させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-7--Key-Update-Error-Code">
6.7. Key Update Error Code
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7. キーアップデートエラーコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The KEY_UPDATE_ERROR error code (0x0e) is used to signal errors related to key updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
KEY_UPDATE_ERRORエラーコード（0x0e）は、キーアップデートに関連するエラーを信号にするために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Security-of-Initial-Messages">
7. Security of Initial Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 初期メッセージのセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initial packets are not protected with a secret key, so they are subject to potential tampering by an attacker. QUIC provides protection against attackers that cannot read packets but does not attempt to provide additional protection against attacks where the attacker can observe and inject packets. Some forms of tampering -- such as modifying the TLS messages themselves -- are detectable, but some -- such as modifying ACKs -- are not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期パケットは秘密鍵で保護されていないため、攻撃者による潜在的な改ざんの対象となります。QUICは、パケットを読み取れないが、攻撃者がパケットを観察して注入できる攻撃に対して追加の保護を提供しようとしない攻撃者に対する保護を提供します。TLSメッセージ自体を変更するなど、改ざんの一部の形式は検出可能ですが、ACKSの変更などの一部のものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, an attacker could inject a packet containing an ACK frame to make it appear that a packet had not been received or to create a false impression of the state of the connection (e.g., by modifying the ACK Delay). Note that such a packet could cause a legitimate packet to be dropped as a duplicate. Implementations SHOULD use caution in relying on any data that is contained in Initial packets that is not otherwise authenticated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、攻撃者は、ACKフレームを含むパケットを注入して、パケットが受信されていないように見え、または接続の状態（例えば、ACK遅延を修正することによって）の状態の誤った印象を作成することができる。このようなパケットは、正当なパケットを複製としてドロップさせる可能性があることに注意してください。実装は、認証されていない初期パケットに含まれるデータに頼る際に注意を払うべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is also possible for the attacker to tamper with data that is carried in Handshake packets, but because that sort of tampering requires modifying TLS handshake messages, any such tampering will cause the TLS handshake to fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者がハンドシェイクパケットで運ばれるデータを改ざんすることも可能であるが、その種の改ざんがTLSハンドシェイクメッセージを修正することを必要とするので、そのような改ざんはTLSハンドシェイクを失敗させるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--QUIC-Specific-Adjustments-to-the-TLS-Handshake">
8. QUIC-Specific Adjustments to the TLS Handshake
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. TLSハンドシェイクへの厳密な固有の調整
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Certain aspects of the TLS handshake are different when used with QUIC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSハンドシェイクの特定の側面は、QUICで使用されている場合は異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC also requires additional features from TLS. In addition to negotiation of cryptographic parameters, the TLS handshake carries and authenticates values for QUIC transport parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICにはTLSから追加の機能も必要です。暗号化パラメータのネゴシエーションに加えて、TLSハンドシェイクはQUICトランスポートパラメータの値を実行して認証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1--Protocol-Negotiation">
8.1. Protocol Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. プロトコルネゴシエーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC requires that the cryptographic handshake provide authenticated protocol negotiation. TLS uses Application-Layer Protocol Negotiation [ALPN] to select an application protocol. Unless another mechanism is used for agreeing on an application protocol, endpoints MUST use ALPN for this purpose.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICでは、暗号化ハンドシェイクが認証されたプロトコルネゴシエーションを提供することを必要とします。TLSはアプリケーションレイヤプロトコルネゴシエーション[ALPN]を使用してアプリケーションプロトコルを選択します。アプリケーションプロトコルに同意するために別のメカニズムが使用されていない限り、エンドポイントはこの目的のためにALPNを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When using ALPN, endpoints MUST immediately close a connection (see Section 10.2 of [QUIC-TRANSPORT]) with a no_application_protocol TLS alert (QUIC error code 0x0178; see Section 4.8) if an application protocol is not negotiated. While [ALPN] only specifies that servers use this alert, QUIC clients MUST use error 0x0178 to terminate a connection when ALPN negotiation fails.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ALPNを使用する場合、エンドポイントは、no_application_protocol TLSアラートを使用して接続をすぐに閉じる必要があります（[QUIC-TRANSPORT]のセクション10.2）、アプリケーションプロトコルがネゴシエートされていない場合は、(QUICエラーコード0x0178; セクション4.8を参照）。[ALPN]サーバーはこのアラートを使用することだけを指定しているが、ALPNネゴシエーションが失敗したときに接続を終了するには、QUICクライアントはエラー0x0178を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application protocol MAY restrict the QUIC versions that it can operate over. Servers MUST select an application protocol compatible with the QUIC version that the client has selected. The server MUST treat the inability to select a compatible application protocol as a connection error of type 0x0178 (no_application_protocol). Similarly, a client MUST treat the selection of an incompatible application protocol by a server as a connection error of type 0x0178.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションプロトコルは、それが操作できるQUICバージョンを制限するかもしれません。サーバーは、クライアントが選択したQUICバージョンと互換性のあるアプリケーションプロトコルを選択する必要があります。サーバーは、タイプ0x0178（no_application_protocol）の接続エラーとして互換性のあるアプリケーションプロトコルを選択できないことを扱う必要があります。同様に、クライアントは、Type 0x0178の接続エラーとして、サーバーによる互換性のないアプリケーションプロトコルの選択を扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2--QUIC-Transport-Parameters-Extension">
8.2. QUIC Transport Parameters Extension
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. QUICトランスポートパラメータ拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC transport parameters are carried in a TLS extension. Different versions of QUIC might define a different method for negotiating transport configuration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICのトランスポートパラメータはTLS拡張機能で搭載されています。QUICの異なるバージョンは、トランスポート設定をネゴシエーションするための異なる方法を定義することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Including transport parameters in the TLS handshake provides integrity protection for these values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSハンドシェイクのトランスポートパラメータを含めると、これらの値に対して完全性保護があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum {
         quic_transport_parameters(0x39), (65535)
      } ExtensionType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The extension_data field of the quic_transport_parameters extension contains a value that is defined by the version of QUIC that is in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC_TRANSPORT_PARAMETERS拡張子のextension_dataフィールドには、使用中のQUICのバージョンによって定義される値が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The quic_transport_parameters extension is carried in the ClientHello and the EncryptedExtensions messages during the handshake. Endpoints MUST send the quic_transport_parameters extension; endpoints that receive ClientHello or EncryptedExtensions messages without the quic_transport_parameters extension MUST close the connection with an error of type 0x016d (equivalent to a fatal TLS missing_extension alert, see Section 4.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quic_transport_parameters拡張は、ハンドシェイク中にClientHelloおよびEncryptedExtensionsメッセージで搭載されています。エンドポイントはquic_transport_parameters拡張機能を送信する必要があります。quic_transport_parametersのないClientHelloまたはEncryptedExtensionsメッセージを受信するエンドポイントは、拡張子が0x016Dとタイプ0x016Dのエラーで接続を閉じる必要があります（致命的なTLS MUSINESTENSER ALECTENT警告と同等）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transport parameters become available prior to the completion of the handshake. A server might use these values earlier than handshake completion. However, the value of transport parameters is not authenticated until the handshake completes, so any use of these parameters cannot depend on their authenticity. Any tampering with transport parameters will cause the handshake to fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハンドシェイクが完了する前にトランスポートパラメータが利用可能になります。サーバーは、ハンドシェイクの完了よりも早くこれらの値を使用することがあります。ただし、移送パラメータの値は、ハンドシェイクが完了するまで認証されませんので、これらのパラメータを使用すると、それらの信頼性に依存できません。トランスポートパラメータを改ざんすることは、ハンドシェイクを失敗させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints MUST NOT send this extension in a TLS connection that does not use QUIC (such as the use of TLS with TCP defined in [TLS13]). A fatal unsupported_extension alert MUST be sent by an implementation that supports this extension if the extension is received when the transport is not QUIC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、QUICを使用しないTLS接続でこの拡張子を送信してはいけません（[TLS13]でTCPのTCPの使用など）。atfort unsupported_extensionアラートは、トランスポートがQUICでないときに拡張子が受信された場合にこの拡張機能をサポートする実装によって送信されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Negotiating the quic_transport_parameters extension causes the EndOfEarlyData to be removed; see Section 8.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quic_transport_parameters拡張子のネゴシエーションはEndOfEarlyDataを削除します。8.3節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-3--Removing-the-EndOfEarlyData-Message">
8.3. Removing the EndOfEarlyData Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. EndOfEarlyDataメッセージの削除
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS EndOfEarlyData message is not used with QUIC. QUIC does not rely on this message to mark the end of 0-RTT data or to signal the change to Handshake keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS EndOfEarlyDataメッセージはQUICでは使用されません。QUICは0-RTTデータの終わりをマークするか、ハンドシェイクキーへの変更をシグナリングするためにこのメッセージに依存しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients MUST NOT send the EndOfEarlyData message. A server MUST treat receipt of a CRYPTO frame in a 0-RTT packet as a connection error of type PROTOCOL_VIOLATION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはEndOfEarlyDataメッセージを送信してはいけません。サーバーはPROTOCOL_VIOLATION型の接続エラーとして、0-RTTパケット内の暗号フレームの受信を扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a result, EndOfEarlyData does not appear in the TLS handshake transcript.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その結果、EndOfEarlyDataはTLSハンドシェイクトランスクリプトには表示されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-4--Prohibit-TLS-Middlebox-Compatibility-Mode">
8.4. Prohibit TLS Middlebox Compatibility Mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. TLSミドルボックス互換性モードの禁止
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Appendix D.4 of [TLS13] describes an alteration to the TLS 1.3 handshake as a workaround for bugs in some middleboxes. The TLS 1.3 middlebox compatibility mode involves setting the legacy_session_id field to a 32-byte value in the ClientHello and ServerHello, then sending a change_cipher_spec record. Both field and record carry no semantic content and are ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS13]の付録D.4は、いくつかのミドルボックスのバグの回避策としてのTLS 1.3ハンドシェイクへの変更を示しています。TLS 1.3ミドルボックス互換性モードでは、LEGACY_SESSION_IDフィールドをClientHelloとServerHelloの32バイトの値に設定してから、change_cipher_specレコードを送信します。フィールドとレコードの両方で意味のあるコンテンツはありませんが無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This mode has no use in QUIC as it only applies to middleboxes that interfere with TLS over TCP. QUIC also provides no means to carry a change_cipher_spec record. A client MUST NOT request the use of the TLS 1.3 compatibility mode. A server SHOULD treat the receipt of a TLS ClientHello with a non-empty legacy_session_id field as a connection error of type PROTOCOL_VIOLATION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPを介してTLSを妨害するミドルボックスにのみ適用されるように、このモードでは使用されません。QUICは、change_cipher_specレコードを搬送する手段もありません。クライアントはTLS 1.3互換モードの使用を要求してはいけません。サーバーは、PROTOCOL_VIOLATION型の接続エラーとして、空のLEGACY_SESSION_IDフィールドを使用してTLS ClientHelloの受信を扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--Security-Considerations">
9. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All of the security considerations that apply to TLS also apply to the use of TLS in QUIC. Reading all of [TLS13] and its appendices is the best way to gain an understanding of the security properties of QUIC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSに適用されるすべてのセキュリティ上の考慮事項は、QUICのTLSの使用にも適用されます。[TLS13]のすべてを読んでその付録は、QUICのセキュリティ特性を理解するための最良の方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section summarizes some of the more important security aspects specific to the TLS integration, though there are many security-relevant details in the remainder of the document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、TLS統合に特有のより重要なセキュリティ側面のいくつかをまとめたものですが、残りの文書には多くのセキュリティ関連の詳細があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1--Session-Linkability">
9.1. Session Linkability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. セッションリンク可能性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of TLS session tickets allows servers and possibly other entities to correlate connections made by the same client; see Section 4.5 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSセッションチケットの使用は、サーバーと他のエンティティが同じクライアントによって行われた接続を相関させることを可能にします。詳細は4.5節をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2--Replay-Attacks-with-0-RTT">
9.2. Replay Attacks with 0-RTT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 0-RTTでのリプレイ攻撃
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 8 of [TLS13], use of TLS early data comes with an exposure to replay attack. The use of 0-RTT in QUIC is similarly vulnerable to replay attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS13]のセクション8で説明されているように、TLSの初期データの使用には再生攻撃にさらされています。QUICの0-RTTの使用は、再生攻撃に同様に脆弱です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints MUST implement and use the replay protections described in [TLS13], however it is recognized that these protections are imperfect. Therefore, additional consideration of the risk of replay is needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは[TLS13]で説明されている再生保護を実装して使用する必要がありますが、これらの保護は不完全であることが認識されます。したがって、リプレイの危険性に関する追加の考慮が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC is not vulnerable to replay attack, except via the application protocol information it might carry. The management of QUIC protocol state based on the frame types defined in [QUIC-TRANSPORT] is not vulnerable to replay. Processing of QUIC frames is idempotent and cannot result in invalid connection states if frames are replayed, reordered, or lost. QUIC connections do not produce effects that last beyond the lifetime of the connection, except for those produced by the application protocol that QUIC serves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICは、運搬する可能性があるアプリケーションプロトコル情報を介して、再生攻撃に対して脆弱ではありません。[QUIC-TRANSPORT]で定義されているフレームタイプに基づくQUICプロトコル状態の管理は、再生に脆弱ではありません。QUICフレームの処理はIDEmpotentであり、フレームが再生、並べ替え、または失われた場合に無効な接続状態をもたらすことはできません。QUIC接続は、QUICが機能するアプリケーションプロトコルによって作成されたものを除いて、接続の有効期間を超えて続く効果を生みません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS session tickets and address validation tokens are used to carry QUIC configuration information between connections, specifically, to enable a server to efficiently recover state that is used in connection establishment and address validation. These MUST NOT be used to communicate application semantics between endpoints; clients MUST treat them as opaque values. The potential for reuse of these tokens means that they require stronger protections against replay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSセッションチケットおよびアドレス検証トークンは、接続間でQUICの設定情報をキャリアするために使用され、特にサーバーが接続確立とアドレス検証で使用される状態を効率的に回復できるようにするために使用されます。これらはエンドポイント間のアプリケーションセマンティクスを通信するために使用してはいけません。クライアントはそれらを不透明な値として扱う必要があります。これらのトークンを再利用する可能性は、それらが再生に対するより強い保護を必要とすることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that accepts 0-RTT on a connection incurs a higher cost than accepting a connection without 0-RTT. This includes higher processing and computation costs. Servers need to consider the probability of replay and all associated costs when accepting 0-RTT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続上の0-RTTを受け入れるサーバーは、0-RTTなしで接続を受け付けるよりも高いコストを招きます。これには、より高い処理と計算コストが含まれます。サーバーは、0-RTTを受け入れるときに、再生の可能性とすべての関連コストの可能性を考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ultimately, the responsibility for managing the risks of replay attacks with 0-RTT lies with an application protocol. An application protocol that uses QUIC MUST describe how the protocol uses 0-RTT and the measures that are employed to protect against replay attack. An analysis of replay risk needs to consider all QUIC protocol features that carry application semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最終的には、0-RTTでの再生攻撃のリスクを管理する責任は、アプリケーションプロトコルと共にあります。QUICを使用するアプリケーションプロトコルは、プロトコルが0-RTTと再生攻撃から保護するために使用される対策をどのように使用するかを説明しなければなりません。再生リスクの分析は、アプリケーションセマンティクスを運ぶすべてのQUICプロトコル機能を考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Disabling 0-RTT entirely is the most effective defense against replay attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0-RTTを無効にする完全にリプレイ攻撃に対する最も効果的な防御です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC extensions MUST either describe how replay attacks affect their operation or prohibit the use of the extension in 0-RTT. Application protocols MUST either prohibit the use of extensions that carry application semantics in 0-RTT or provide replay mitigation strategies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICの拡張機能は、再生攻撃が自分の操作にどのように影響するか、または0-RTTの拡張の使用を禁止するかを説明する必要があります。アプリケーションプロトコルは、0-RTTでアプリケーションセマンティクスを運ぶ拡張機能の使用を禁止したり、再生緩和戦略を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3--Packet-Reflection-Attack-Mitigation">
9.3. Packet Reflection Attack Mitigation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. パケット反射攻撃の軽減
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A small ClientHello that results in a large block of handshake messages from a server can be used in packet reflection attacks to amplify the traffic generated by an attacker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーからのハンドシェイクメッセージの大きなブロックをもたらす小さなClientHelloをパケットの反射攻撃で使用して、攻撃者によって生成されたトラフィックを増幅することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC includes three defenses against this attack. First, the packet containing a ClientHello MUST be padded to a minimum size. Second, if responding to an unverified source address, the server is forbidden to send more than three times as many bytes as the number of bytes it has received (see Section 8.1 of [QUIC-TRANSPORT]). Finally, because acknowledgments of Handshake packets are authenticated, a blind attacker cannot forge them. Put together, these defenses limit the level of amplification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICには、この攻撃に対する3つの防御が含まれています。まず、ClientHelloを含むパケットを最小サイズに埋め込む必要があります。第2に、未確認の送信元アドレスに応答している場合、サーバーは、受信したバイト数と同じ3倍以上のバイトを送信することを禁止されています（[QUIC-TRANSPORT]のセクション8.1参照）。最後に、ハンドシェイクパケットの確認応答が認証されているため、盲目の攻撃者はそれらを偽造できません。まとめると、これらの防御は増幅のレベルを制限します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4--Header-Protection-Analysis">
9.4. Header Protection Analysis
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. ヘッダー保護分析
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NAN] analyzes authenticated encryption algorithms that provide nonce privacy, referred to as &#34;Hide Nonce&#34; (HN) transforms. The general header protection construction in this document is one of those algorithms (HN1). Header protection is applied after the packet protection AEAD, sampling a set of bytes (&#34;sample&#34;) from the AEAD output and encrypting the header field using a pseudorandom function (PRF) as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NAN]は、「Hide Nonce」（HN）変換と呼ばれる、ナンスプライバシーを提供する認証済み暗号化アルゴリズムを分析します。 このドキュメントの一般的なヘッダー保護構造は、それらのアルゴリズム（HN1）の1つです。 ヘッダー保護は、パケット保護AEADの後に適用され、AEAD出力からバイトセット（「サンプル」）をサンプリングし、次のように疑似ランダム関数（PRF）を使用してヘッダーフィールドを暗号化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   protected_field = field XOR PRF(hp_key, sample)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The header protection variants in this document use a pseudorandom permutation (PRP) in place of a generic PRF. However, since all PRPs are also PRFs [IMC], these variants do not deviate from the HN1 construction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のヘッダー保護バリアントは、一般的なPRFの代わりに疑似乱数順列（PRP）を使用しています。しかし、すべてのPRPもPRFS [IMC]であるため、これらの変種はHN1構造から逸脱しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As &#34;hp_key&#34; is distinct from the packet protection key, it follows that header protection achieves AE2 security as defined in [NAN] and therefore guarantees privacy of &#34;field&#34;, the protected packet header. Future header protection variants based on this construction MUST use a PRF to ensure equivalent security guarantees.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「hp_key」がパケット保護キーとは異なるため、ヘッダ保護は[NaN]で定義されているようにAE2セキュリティを実現し、したがって保護されたパケットヘッダの「フィールド」のプライバシーを保証する。この建設に基づく将来のヘッダー保護の亜種は、同等のセキュリティ保証を確保するためにPRFを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of the same key and ciphertext sample more than once risks compromising header protection. Protecting two different headers with the same key and ciphertext sample reveals the exclusive OR of the protected fields. Assuming that the AEAD acts as a PRF, if L bits are sampled, the odds of two ciphertext samples being identical approach 2^(-L/2), that is, the birthday bound. For the algorithms described in this document, that probability is one in 2^64.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダー保護を犠牲にすると、同じキーと暗号文のサンプルを複数回使用します。同じキーと暗号文のサンプルを持つ2つの異なるヘッダーを保護すると、保護されたフィールドの排他的論理和を明らかにします。AEADがPRFとして機能すると仮定すると、Lビットがサンプリングされた場合、2つの暗号文サンプルのオッズは同一の方法 2^(-L/2）、すなわち誕生日バウンド。この文書に記載されているアルゴリズムの場合、その確率は2^64の1つです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To prevent an attacker from modifying packet headers, the header is transitively authenticated using packet protection; the entire packet header is part of the authenticated additional data. Protected fields that are falsified or modified can only be detected once the packet protection is removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者がパケットヘッダーを変更するのを防ぐために、ヘッダーはパケット保護を使用して統制的に認証されます。パケットヘッダー全体は認証された追加データの一部です。改ざんまたは変更された保護されたフィールドは、パケット保護が削除されると検出できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-5--Header-Protection-Timing-Side-Channels">
9.5. Header Protection Timing Side Channels
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5. ヘッダー保護タイミングサイドチャンネル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attacker could guess values for packet numbers or Key Phase and have an endpoint confirm guesses through timing side channels. Similarly, guesses for the packet number length can be tried and exposed. If the recipient of a packet discards packets with duplicate packet numbers without attempting to remove packet protection, they could reveal through timing side channels that the packet number matches a received packet. For authentication to be free from side channels, the entire process of header protection removal, packet number recovery, and packet protection removal MUST be applied together without timing and other side channels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者は、パケット番号またはキーフェーズの値を推測し、エンドポイントがタイミングサイドチャネルを通って推測を確認する可能性があります。同様に、パケット番号の長さの推測を試みて公開することができます。パケット保護を除去しようとすると、パケットの受信者が重複したパケット番号を持つパケットを破棄した場合、パケット番号が受信したパケットと一致するタイミングサイドチャネルを通じて表示できます。認証のためには、サイドチャネルから解放されるためには、ヘッダ保護除去、パケット番号回復、およびパケット保護の除去の全プロセスを、タイミングや他の側面チャネルなしに一緒に適用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the sending of packets, construction and protection of packet payloads and packet numbers MUST be free from side channels that would reveal the packet number or its encoded size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットの送信のために、パケットペイロードとパケット番号の構築と保護は、パケット番号またはその符号化されたサイズを明らかにするサイドチャネルから自由でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During a key update, the time taken to generate new keys could reveal through timing side channels that a key update has occurred. Alternatively, where an attacker injects packets, this side channel could reveal the value of the Key Phase on injected packets. After receiving a key update, an endpoint SHOULD generate and save the next set of receive packet protection keys, as described in Section 6.3. By generating new keys before a key update is received, receipt of packets will not create timing signals that leak the value of the Key Phase.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーアップデート中に、新しいキーを生成するのにかかる時間は、キーアップデートが発生したタイミングサイドチャネルを通じて明らかにされます。あるいは、攻撃者がパケットを注入する場合、このサイドチャネルは注入されたパケットのキーフェーズの値を明らかにすることができる。キー更新を受けた後、セクション6.3で説明されているように、エンドポイントは次の受信パケット保護キーのセットを生成して保存する必要があります。キーアップデートが受信される前に新しいキーを生成することによって、パケットの受信はキーフェーズの値を漏らすタイミング信号を作成しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This depends on not doing this key generation during packet processing, and it can require that endpoints maintain three sets of packet protection keys for receiving: for the previous key phase, for the current key phase, and for the next key phase. Endpoints can instead choose to defer generation of the next receive packet protection keys until they discard old keys so that only two sets of receive keys need to be retained at any point in time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはパケット処理中にこの鍵の生成をしていないことに依存し、エンドポイントが受信するための3セットのパケット保護キーを受信するための3セットを維持することを要求することができます。エンドポイントは、2セットの受信キーのみを任意の時点で保持する必要があるように、古いキーを破棄するまで、次の受信パケット保護キーの生成を遅らせることを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-6--Key-Diversity">
9.6. Key Diversity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6. キーダイバーシティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In using TLS, the central key schedule of TLS is used. As a result of the TLS handshake messages being integrated into the calculation of secrets, the inclusion of the QUIC transport parameters extension ensures that the handshake and 1-RTT keys are not the same as those that might be produced by a server running TLS over TCP. To avoid the possibility of cross-protocol key synchronization, additional measures are provided to improve key separation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSを使用する場合、TLSの中心キースケジュールが使用されます。TLSハンドシェイクメッセージが秘密の計算に統合された結果として、QUICトランスポートパラメータの拡張子を含めることで、ハンドシェイクと1-RTTキーがTCPを介してTLSを実行しているサーバーによって生成される可能性があるものと同じになります。。クロスプロトコルキー同期の可能性を避けるために、キー分離を向上させるために追加の対策が提供されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The QUIC packet protection keys and IVs are derived using a different label than the equivalent keys in TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICのパケット保護キーとIVSは、TLSの等価キーとは異なるラベルを使用して導き出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To preserve this separation, a new version of QUIC SHOULD define new labels for key derivation for packet protection key and IV, plus the header protection keys. This version of QUIC uses the string &#34;quic&#34;. Other versions can use a version-specific label in place of that string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この分離を維持するために、新しいバージョンのQUICは、パケット保護キーとIVのキー導出のための新しいラベルとヘッダー保護キーを定義する必要があります。このバージョンのQUICは文字列 &#34;quic&#34;を使用します。他のバージョンは、その文字列の代わりにバージョン固有のラベルを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial secrets use a key that is specific to the negotiated QUIC version. New QUIC versions SHOULD define a new salt value used in calculating initial secrets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の秘密は、ネゴシエートされたQUICバージョンに固有のキーを使用します。新しいQUICバージョンは、最初の秘密の計算に使用される新しい塩値を定義する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-7--Randomness">
9.7. Randomness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.7. ランダム性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUIC depends on endpoints being able to generate secure random numbers, both directly for protocol values such as the connection ID, and transitively via TLS. See [RFC4086] for guidance on secure random number generation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QUICは、接続IDなどのプロトコル値のために直接安全な乱数を生成することができるエンドポイントによって、およびTLSを介して列挙されます。安全な乱数生成に関するガイダンスについては、[RFC4086]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--IANA-Considerations">
10. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has registered a codepoint of 57 (or 0x39) for the quic_transport_parameters extension (defined in Section 8.2) in the &#34;TLS ExtensionType Values&#34; registry [TLS-REGISTRIES].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、「TLS ExtenctType値」レジストリ[TLSレジストリ]のQUIC_TRANSPORT_PARAMETERS拡張（セクション8.2で定義）のCodePointを登録しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Recommended column for this extension is marked Yes. The TLS 1.3 Column includes CH (ClientHello) and EE (EncryptedExtensions).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この拡張子の推奨列は、はいマークです。TLS 1.3列にはCH（ClientHello）とEE（EncryptedExtensions）が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +=======+===========================+=====+=============+===========+
   | Value | Extension Name            | TLS | Recommended | Reference |
   |       |                           | 1.3 |             |           |
   +=======+===========================+=====+=============+===========+
   |    57 | quic_transport_parameters | CH, | Y           | This      |
   |       |                           | EE  |             | document  |
   +-------+---------------------------+-----+-------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Table 2: TLS ExtensionType Values Registry Entry
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
表2：MLS ExtensionType値レジストリエントリ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11--References">
11. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1--Normative-References">
11.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[AEAD] McGrew, D., &#34;An Interface and Algorithms for Authenticated Encryption&#34;, RFC 5116, DOI 10.17487/RFC5116, January 2008, &lt;https://www.rfc-editor.org/info/rfc5116&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[AEAD] MCGREW、D。、「認証された暗号化のためのインタフェースとアルゴリズム」、RFC 5116、DOI 10.17487 / RFC5116、2008年1月、&lt;https：//www.rfc-editor.org/info/rfc5116&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[AES] &#34;Advanced encryption standard (AES)&#34;, National Institute of Standards and Technology report, DOI 10.6028/nist.fips.197, November 2001, &lt;https://doi.org/10.6028/nist.fips.197&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[AES]「高度な暗号化規格（AES）」、国立標準化学研究所、DOI 10.6028 / NIST.FIPS.197、2001年11月、&lt;https：//doi.org/10.6028/nist.fips.197&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ALPN] Friedl, S., Popov, A., Langley, A., and E. Stephan, &#34;Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension&#34;, RFC 7301, DOI 10.17487/RFC7301, July 2014, &lt;https://www.rfc-editor.org/info/rfc7301&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ALPN] Friedl、S.、Popov、A.、Langley、A.、およびE.Stethan、「トランスポート層セキュリティ（TLS）アプリケーション層プロトコルネゴシエーション拡張」、RFC 7301、DOI 10.17487 / RFC7301、2014年7月、&lt;https://www.rfc-editor.org/info/rfc7301&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CHACHA] Nir, Y. and A. Langley, &#34;ChaCha20 and Poly1305 for IETF Protocols&#34;, RFC 8439, DOI 10.17487/RFC8439, June 2018, &lt;https://www.rfc-editor.org/info/rfc8439&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Chacha] NIR、Y。およびA. Langley、RFC 8439、DOI 10.17487 / RFC8439、2018年6月、&lt;https://www.rfc-editor.org/info/rfc8439&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HKDF] Krawczyk, H. and P. Eronen, &#34;HMAC-based Extract-and-Expand Key Derivation Function (HKDF)&#34;, RFC 5869, DOI 10.17487/RFC5869, May 2010, &lt;https://www.rfc-editor.org/info/rfc5869&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HKDF] Krawczyk、H.およびP. Eronen、 &#34;HMACベースの抽出抽出及び拡張キー派生機能（HKDF）&#34;、RFC 5869、DOI 10.17487 / RFC5869、&lt;https：//www.rfc-編集者.org / info / rfc5869&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[QUIC-RECOVERY] Iyengar, J., Ed. and I. Swett, Ed., &#34;QUIC Loss Detection and Congestion Control&#34;, RFC 9002, DOI 10.17487/RFC9002, May 2021, &lt;https://www.rfc-editor.org/info/rfc9002&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[QUIC回復] Iyngar、J.、ED。I.SWETT、ED。、「QUICの損失検出および輻輳制御」、RFC 9002、DOI 10.17487 / RFC9002、2021年5月、&lt;https：//www.rfc-editor.org/info/rfc9002&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[QUIC-TRANSPORT] Iyengar, J., Ed. and M. Thomson, Ed., &#34;QUIC: A UDP-Based Multiplexed and Secure Transport&#34;, RFC 9000, DOI 10.17487/RFC9000, May 2021, &lt;https://www.rfc-editor.org/info/rfc9000&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[QUIC-TRANSPORT] Iyengar、J.、ED。そして、「Q. Thomson」、「QUIC：UDPベースの多重化および安全な輸送」、RFC 9000、DOI 10.17487 / RFC9000、&lt;https：//www.rfc-editor.org/info/rfc9000&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] BRADNER、S、「RFCSで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;https：//www.rfc-editor.org/info/RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, &lt;https://www.rfc-editor.org/info/rfc4086&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086]イーストレイク3RD、D.、Schiller、J.、S. Crocker、「セキュリティのためのランダム性要件」、BCP 106、RFC 4086、DOI 10.17487 / RFC4086、2005年6月、&lt;https：//www.rfc-編集者.org / info / rfc4086&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba、B、「RFC 2119キーワードの大文字の曖昧さ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、&lt;https：//www.rfc-editor.org/info/RFC8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SHA] Dang, Q., &#34;Secure Hash Standard&#34;, National Institute of Standards and Technology report, DOI 10.6028/nist.fips.180-4, July 2015, &lt;https://doi.org/10.6028/nist.fips.180-4&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SHA] Dang、Q.、国立標準技術研究所、DOI 10.6028 / NIST.FIPS.180-4、&lt;https://doi.org/10.6028/10.6028/10.6028/10.6028/nist.fips.fips.fips.fips.fips.fips.180-4&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS-REGISTRIES] Salowey, J. and S. Turner, &#34;IANA Registry Updates for TLS and DTLS&#34;, RFC 8447, DOI 10.17487/RFC8447, August 2018, &lt;https://www.rfc-editor.org/info/rfc8447&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS-Registries] Salowey、J.およびS.ターナー、「TLSおよびDTLSのIANAレジストリアップデート」、RFC 8447、DOI 10.17487 / RFC8447、2018年8月、&lt;https：//www.rfc-editor.org/info/RFC8447&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS13] Rescorla, E., &#34;The Transport Layer Security (TLS) Protocol Version 1.3&#34;, RFC 8446, DOI 10.17487/RFC8446, August 2018, &lt;https://www.rfc-editor.org/info/rfc8446&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS13] RESCORLA、E。、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487 / RFC8446、2018年8月、&lt;https：//www.rfc-editor.org/info/rfc8446&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-2--Informative-References">
11.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[AEBounds] Luykx, A. and K. Paterson, &#34;Limits on Authenticated Encryption Use in TLS&#34;, 28 August 2017, &lt;https://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[AEBounds] Luykx、A.およびK. Paterson、2017年8月28日、&lt;https://www.isg.rhul.ac.uk/~kp/tls-aebounds.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ASCII] Cerf, V., &#34;ASCII format for network interchange&#34;, STD 80, RFC 20, DOI 10.17487/RFC0020, October 1969, &lt;https://www.rfc-editor.org/info/rfc20&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ASCII] CERF、V.、「ネットワークインターチェンジのASCIIフォーマット」、STD 80、RFC 20、DOI 10.17487 / RFC0020、1969年10月、&lt;https：//www.rfc-editor.org/info/rfc20&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CCM-ANALYSIS] Jonsson, J., &#34;On the Security of CTR + CBC-MAC&#34;, Selected Areas in Cryptography, SAC 2002, Lecture Notes in Computer Science, vol 2595, pp. 76-93, DOI 10.1007/3-540-36492-7_7, 2003, &lt;https://doi.org/10.1007/3-540-36492-7_7&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CCM-Analysis] Jonsson、J.、「CTR CBC-MACのセキュリティについて」、Cryptographyの選択領域、SAC 2002、PP.76-93、DOI 10.1007 / 3-540-36492-7_7,2003、&lt;https://doi.org/10.1007/3-540-36492-7_7&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[COMPRESS] Ghedini, A. and V. Vasiliev, &#34;TLS Certificate Compression&#34;, RFC 8879, DOI 10.17487/RFC8879, December 2020, &lt;https://www.rfc-editor.org/info/rfc8879&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[圧縮] Ghedini、A.およびV.Vasiliev、「TLS証明書圧縮」、RFC 8879、DOI 10.17487 / RFC8879、2020年12月、&lt;https://www.rfc-editor.org/info/rfc8879&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GCM-MU] Hoang, V., Tessaro, S., and A. Thiruvengadam, &#34;The Multi-user Security of GCM, Revisited: Tight Bounds for Nonce Randomization&#34;, CCS &#39;18: Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, pp. 1429-1440, DOI 10.1145/3243734.3243816, 2018, &lt;https://doi.org/10.1145/3243734.3243816&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GCM-MU]ホアアン、V.、Tessaro、S.、およびA.Thiruvengadam、「GCMのマルチユーザーセキュリティ、再検討：Nonceランダム化のためのタイトな範囲」、CCS &#39;18：2018年ACM SIGSAC会議の手続きコンピュータと通信セキュリティ、PP。1429-1440、DOI 10.1145 / 3243734.3243816,2018、&lt;https://doi.org/10.1145/3243734.3243816&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP-REPLAY] Thomson, M., Nottingham, M., and W. Tarreau, &#34;Using Early Data in HTTP&#34;, RFC 8470, DOI 10.17487/RFC8470, September 2018, &lt;https://www.rfc-editor.org/info/rfc8470&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP-REPLAY] Thomson、M.、Nottingham、M.、およびW. Tarreau、2018年9月、2018年9月、&lt;https：///www.rfc-編集者。org / info / rfc8470&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP2-TLS13] Benjamin, D., &#34;Using TLS 1.3 with HTTP/2&#34;, RFC 8740, DOI 10.17487/RFC8740, February 2020, &lt;https://www.rfc-editor.org/info/rfc8740&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP2-TLS13] Benjamin、D.、「HTTP / 2のTLS 1.3を使用して、RFC 8740、DOI 10.17487 / RFC8740、2020年2月、&lt;https：//www.rfc-editor.org/info/rfc8740&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IMC] Katz, J. and Y. Lindell, &#34;Introduction to Modern Cryptography, Second Edition&#34;, ISBN 978-1466570269, 6 November 2014.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IMC] Katz、J.およびY. Lindell、2014年11月6日、ISBN 978-1466570269、ISBN 978-1466570269。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NAN] Bellare, M., Ng, R., and B. Tackmann, &#34;Nonces Are Noticed: AEAD Revisited&#34;, Advances in Cryptology - CRYPTO 2019, Lecture Notes in Computer Science, vol 11692, pp. 235-265, DOI 10.1007/978-3-030-26948-7_9, 2019, &lt;https://doi.org/10.1007/978-3-030-26948-7_9&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Nan] Bellare、M.、NG、R.、B. Tackmann、Cryptolysの進歩 -  Crypto 2019、Crypto 2019、PP。235-265、DOI10.1007 / 978-3-030-26948-7_9、2019、&lt;https：//doi.org/10.1007/978-3-030-26948-7_9&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[QUIC-HTTP] Bishop, M., Ed., &#34;Hypertext Transfer Protocol Version 3 (HTTP/3)&#34;, Work in Progress, Internet-Draft, draft-ietf-quic-http-34, 2 February 2021, &lt;https://tools.ietf.org/html/draft-ietf-quic-http-34&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[QUIC-HTTP] Bishop、M.、Ed。、「Hypertext Transfer Protocol Version 3（HTTP/3）」、進行中の作業、インターネットドラフト、romft-ietf-quic-quic-http-34,2021、&lt;HTTPS：//tools.ietf.org/html/draft-ietf-quic-http-34&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2818] Rescorla, E., &#34;HTTP Over TLS&#34;, RFC 2818, DOI 10.17487/RFC2818, May 2000, &lt;https://www.rfc-editor.org/info/rfc2818&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2818] RESCORLA、E.、「HTTP over TLS」、RFC 2818、DOI 10.17487 / RFC2818、2000年5月、&lt;https：//www.rfc-editor.org/info/rfc2818&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &#34;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&#34;, RFC 5280, DOI 10.17487/RFC5280, May 2008, &lt;https://www.rfc-editor.org/info/rfc5280&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5280] Cooper、D.、Santesson、S.、Farrell、S.、Boeyen、S.、Housley、R.、およびW.Polk、 &#34;Internet X.509公開鍵インフラストラクチャ証明書および証明書失効リスト（CRL）プロファイル「、RFC 5280、DOI 10.17487 / RFC5280、2008年5月、&lt;https://www.rfc-editor.org/info/rfc5280&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ROBUST] Fischlin, M., Günther, F., and C. Janson, &#34;Robust Channels: Handling Unreliable Networks in the Record Layers of QUIC and DTLS 1.3&#34;, 16 May 2020, &lt;https://eprint.iacr.org/2020/718&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[堅牢な] Fischlin、M.、Günther、F.、およびC.Janson、 &#34;堅牢なチャンネル：QUICおよびDTLS 1.3の記録層の信頼性の低いネットワークの取り扱い、2020年5月16日、https://eprint.iacr.org/ 2020/718&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--Sample-Packet-Protection">
Appendix A. Sample Packet Protection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A.サンプルパケット保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section shows examples of packet protection so that implementations can be verified incrementally. Samples of Initial packets from both client and server plus a Retry packet are defined. These packets use an 8-byte client-chosen Destination Connection ID of 0x8394c8f03e515708. Some intermediate values are included. All values are shown in hexadecimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、実装を段階的に検証できるようにパケット保護の例を示します。クライアントとサーバーと再試行パケットの両方からの初期パケットのサンプルが定義されています。これらのパケットは、0x8394C8F03E515708の8バイトのクライアント選択先接続IDを使用します。いくつかの中間値が含まれています。すべての値は16進数で表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-1--Keys">
A.1. Keys
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. キー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The labels generated during the execution of the HKDF-Expand-Label function (that is, HkdfLabel.label) and part of the value given to the HKDF-Expand function in order to produce its output are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その出力を生成するために、HKDF-Expand-Label関数の実行中に生成されたラベル（つまり、HkdfLabel.label）とHKDF-Expand関数に与えられた値の一部は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   client in:  00200f746c73313320636c69656e7420696e00

   server in:  00200f746c7331332073657276657220696e00

   quic key:  00100e746c7331332071756963206b657900

   quic iv:  000c0d746c733133207175696320697600

   quic hp:  00100d746c733133207175696320687000
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial secret is common:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期の秘密は共通です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   initial_secret = HKDF-Extract(initial_salt, cid)
       = 7db5df06e7a69e432496adedb0085192
         3595221596ae2ae9fb8115c1e9ed0a44
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The secrets for protecting client packets are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントパケットを保護するための秘密は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   client_initial_secret
       = HKDF-Expand-Label(initial_secret, &#34;client in&#34;, &#34;&#34;, 32)
       = c00cf151ca5be075ed0ebfb5c80323c4
         2d6b7db67881289af4008f1f6c357aea
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   key = HKDF-Expand-Label(client_initial_secret, &#34;quic key&#34;, &#34;&#34;, 16)
       = 1f369613dd76d5467730efcbe3b1a22d
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   iv = HKDF-Expand-Label(client_initial_secret, &#34;quic iv&#34;, &#34;&#34;, 12)
       = fa044b2f42a3fd3b46fb255c
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   hp  = HKDF-Expand-Label(client_initial_secret, &#34;quic hp&#34;, &#34;&#34;, 16)
       = 9f50449e04a0e810283a1e9933adedd2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The secrets for protecting server packets are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーパケットを保護するための秘密は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   server_initial_secret
       = HKDF-Expand-Label(initial_secret, &#34;server in&#34;, &#34;&#34;, 32)
       = 3c199828fd139efd216c155ad844cc81
         fb82fa8d7446fa7d78be803acdda951b
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   key = HKDF-Expand-Label(server_initial_secret, &#34;quic key&#34;, &#34;&#34;, 16)
       = cf3a5331653c364c88f0f379b6067e37
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   iv = HKDF-Expand-Label(server_initial_secret, &#34;quic iv&#34;, &#34;&#34;, 12)
       = 0ac1493ca1905853b0bba03e
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   hp  = HKDF-Expand-Label(server_initial_secret, &#34;quic hp&#34;, &#34;&#34;, 16)
       = c206b8d9b9f0f37644430b490eeaa314
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-2--Client-Initial">
A.2. Client Initial
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. クライアントの初期
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client sends an Initial packet. The unprotected payload of this packet contains the following CRYPTO frame, plus enough PADDING frames to make a 1162-byte payload:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは初期パケットを送信します。このパケットの保護されていないペイロードには、次の暗号フレームが含まれており、1162バイトのペイロードを作成するのに十分なパディングフレームが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   060040f1010000ed0303ebf8fa56f129 39b9584a3896472ec40bb863cfd3e868
   04fe3a47f06a2b69484c000004130113 02010000c000000010000e00000b6578
   616d706c652e636f6dff01000100000a 00080006001d00170018001000070005
   04616c706e0005000501000000000033 00260024001d00209370b2c9caa47fba
   baf4559fedba753de171fa71f50f1ce1 5d43e994ec74d748002b000302030400
   0d0010000e0403050306030203080408 050806002d00020101001c0002400100
   3900320408ffffffffffffffff050480 00ffff07048000ffff08011001048000
   75300901100f088394c8f03e51570806 048000ffff
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The unprotected header indicates a length of 1182 bytes: the 4-byte packet number, 1162 bytes of frames, and the 16-byte authentication tag. The header includes the connection ID and a packet number of 2:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保護されていないヘッダーは1182バイトの長さを示します.4バイトのパケット番号、1162バイトのフレーム、および16バイトの認証タグを示します。ヘッダは接続IDと2のパケット番号を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   c300000001088394c8f03e5157080000449e00000002
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Protecting the payload produces output that is sampled for header protection. Because the header uses a 4-byte packet number encoding, the first 16 bytes of the protected payload is sampled and then applied to the header as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ペイロードの保護ヘッダー保護のためにサンプリングされた出力が生成されます。ヘッダーは4バイトのパケット番号エンコーディングを使用するため、保護されたペイロードの最初の16バイトがサンプリングされ、次のようにヘッダーに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   sample = d1b1c98dd7689fb8ec11d242b123dc9b

   mask = AES-ECB(hp, sample)[0..4]
        = 437b9aec36

   header[0] ^= mask[0] &amp; 0x0f
        = c0
   header[18..21] ^= mask[1..4]
        = 7b9aec34
   header = c000000001088394c8f03e5157080000449e7b9aec34
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resulting protected packet is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果の保護されたパケットは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   c000000001088394c8f03e5157080000 449e7b9aec34d1b1c98dd7689fb8ec11
   d242b123dc9bd8bab936b47d92ec356c 0bab7df5976d27cd449f63300099f399
   1c260ec4c60d17b31f8429157bb35a12 82a643a8d2262cad67500cadb8e7378c
   8eb7539ec4d4905fed1bee1fc8aafba1 7c750e2c7ace01e6005f80fcb7df6212
   30c83711b39343fa028cea7f7fb5ff89 eac2308249a02252155e2347b63d58c5
   457afd84d05dfffdb20392844ae81215 4682e9cf012f9021a6f0be17ddd0c208
   4dce25ff9b06cde535d0f920a2db1bf3 62c23e596d11a4f5a6cf3948838a3aec
   4e15daf8500a6ef69ec4e3feb6b1d98e 610ac8b7ec3faf6ad760b7bad1db4ba3
   485e8a94dc250ae3fdb41ed15fb6a8e5 eba0fc3dd60bc8e30c5c4287e53805db
   059ae0648db2f64264ed5e39be2e20d8 2df566da8dd5998ccabdae053060ae6c
   7b4378e846d29f37ed7b4ea9ec5d82e7 961b7f25a9323851f681d582363aa5f8
   9937f5a67258bf63ad6f1a0b1d96dbd4 faddfcefc5266ba6611722395c906556
   be52afe3f565636ad1b17d508b73d874 3eeb524be22b3dcbc2c7468d54119c74
   68449a13d8e3b95811a198f3491de3e7 fe942b330407abf82a4ed7c1b311663a
   c69890f4157015853d91e923037c227a 33cdd5ec281ca3f79c44546b9d90ca00
   f064c99e3dd97911d39fe9c5d0b23a22 9a234cb36186c4819e8b9c5927726632
   291d6a418211cc2962e20fe47feb3edf 330f2c603a9d48c0fcb5699dbfe58964
   25c5bac4aee82e57a85aaf4e2513e4f0 5796b07ba2ee47d80506f8d2c25e50fd
   14de71e6c418559302f939b0e1abd576 f279c4b2e0feb85c1f28ff18f58891ff
   ef132eef2fa09346aee33c28eb130ff2 8f5b766953334113211996d20011a198
   e3fc433f9f2541010ae17c1bf202580f 6047472fb36857fe843b19f5984009dd
   c324044e847a4f4a0ab34f719595de37 252d6235365e9b84392b061085349d73
   203a4a13e96f5432ec0fd4a1ee65accd d5e3904df54c1da510b0ff20dcc0c77f
   cb2c0e0eb605cb0504db87632cf3d8b4 dae6e705769d1de354270123cb11450e
   fc60ac47683d7b8d0f811365565fd98c 4c8eb936bcab8d069fc33bd801b03ade
   a2e1fbc5aa463d08ca19896d2bf59a07 1b851e6c239052172f296bfb5e724047
   90a2181014f3b94a4e97d117b4381303 68cc39dbb2d198065ae3986547926cd2
   162f40a29f0c3c8745c0f50fba3852e5 66d44575c29d39a03f0cda721984b6f4
   40591f355e12d439ff150aab7613499d bd49adabc8676eef023b15b65bfc5ca0
   6948109f23f350db82123535eb8a7433 bdabcb909271a6ecbcb58b936a88cd4e
   8f2e6ff5800175f113253d8fa9ca8885 c2f552e657dc603f252e1a8e308f76f0
   be79e2fb8f5d5fbbe2e30ecadd220723 c8c0aea8078cdfcb3868263ff8f09400
   54da48781893a7e49ad5aff4af300cd8 04a6b6279ab3ff3afb64491c85194aab
   760d58a606654f9f4400e8b38591356f bf6425aca26dc85244259ff2b19c41b9
   f96f3ca9ec1dde434da7d2d392b905dd f3d1f9af93d1af5950bd493f5aa731b4
   056df31bd267b6b90a079831aaf579be 0a39013137aac6d404f518cfd4684064
   7e78bfe706ca4cf5e9c5453e9f7cfd2b 8b4c8d169a44e55c88d4a9a7f9474241
   e221af44860018ab0856972e194cd934
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-3--Server-Initial">
A.3. Server Initial
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.3. サーバーのイニシャル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server sends the following payload in response, including an ACK frame, a CRYPTO frame, and no PADDING frames:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ACKフレーム、暗号フレーム、およびパディングフレームを含む、それに応じて次のペイロードを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   02000000000600405a020000560303ee fce7f7b37ba1d1632e96677825ddf739
   88cfc79825df566dc5430b9a045a1200 130100002e00330024001d00209d3c94
   0d89690b84d08a60993c144eca684d10 81287c834d5311bcf32bb9da1a002b00
   020304
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The header from the server includes a new connection ID and a 2-byte packet number encoding for a packet number of 1:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバからのヘッダは、パケット番号1の新しい接続IDと2バイトのパケット番号エンコーディングを含む。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   c1000000010008f067a5502a4262b50040750001
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a result, after protection, the header protection sample is taken starting from the third protected byte:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その結果、保護後、ヘッダー保護サンプルは3番目の保護バイトから出発します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   sample = 2cd0991cd25b0aac406a5816b6394100
   mask   = 2ec0d8356a
   header = cf000000010008f067a5502a4262b5004075c0d9
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The final protected packet is then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の保護されたパケットは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   cf000000010008f067a5502a4262b500 4075c0d95a482cd0991cd25b0aac406a
   5816b6394100f37a1c69797554780bb3 8cc5a99f5ede4cf73c3ec2493a1839b3
   dbcba3f6ea46c5b7684df3548e7ddeb9 c3bf9c73cc3f3bded74b562bfb19fb84
   022f8ef4cdd93795d77d06edbb7aaf2f 58891850abbdca3d20398c276456cbc4
   2158407dd074ee
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-4--Retry">
A.4. Retry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4. リトライ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This shows a Retry packet that might be sent in response to the Initial packet in Appendix A.2. The integrity check includes the client-chosen connection ID value of 0x8394c8f03e515708, but that value is not included in the final Retry packet:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、付録A.2の初期パケットに応答して送信される可能性がある再試行パケットを示しています。整合性チェックには、クライアント選択された接続ID値が0x8394C8F03E515708に含まれていますが、その値は最後の再試行パケットに含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ff000000010008f067a5502a4262b574 6f6b656e04a265ba2eff4d829058fb3f
   0f2496ba
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-5--ChaCha20-Poly1305-Short-Header-Packet">
A.5. ChaCha20-Poly1305 Short Header Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.5. Chacha20-Poly1305ショートヘッダーパケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This example shows some of the steps required to protect a packet with a short header. This example uses AEAD_CHACHA20_POLY1305.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例は、短いヘッダーを持つパケットを保護するために必要なステップのいくつかを示しています。この例では、AEAD_CHACHA20_POLY1305を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this example, TLS produces an application write secret from which a server uses HKDF-Expand-Label to produce four values: a key, an IV, a header protection key, and the secret that will be used after keys are updated (this last value is not used further in this example).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例では、TLSは、サーバーがHKDF-Expand-Labelを使用して4つの値を生成するアプリケーションの書き込みシークレットを生成します。キー、IV、ヘッダー保護キー、およびキーの後に使用される秘密（この最後の最後）この例では値はさらに使用されません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   secret
       = 9ac312a7f877468ebe69422748ad00a1
         5443f18203a07d6060f688f30f21632b

   key = HKDF-Expand-Label(secret, &#34;quic key&#34;, &#34;&#34;, 32)
       = c6d98ff3441c3fe1b2182094f69caa2e
         d4b716b65488960a7a984979fb23e1c8

   iv  = HKDF-Expand-Label(secret, &#34;quic iv&#34;, &#34;&#34;, 12)
       = e0459b3474bdd0e44a41c144

   hp  = HKDF-Expand-Label(secret, &#34;quic hp&#34;, &#34;&#34;, 32)
       = 25a282b9e82f06f21f488917a4fc8f1b
         73573685608597d0efcb076b0ab7a7a4

   ku  = HKDF-Expand-Label(secret, &#34;quic ku&#34;, &#34;&#34;, 32)
       = 1223504755036d556342ee9361d25342
         1a826c9ecdf3c7148684b36b714881f9
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following shows the steps involved in protecting a minimal packet with an empty Destination Connection ID. This packet contains a single PING frame (that is, a payload of just 0x01) and has a packet number of 654360564. In this example, using a packet number of length 3 (that is, 49140 is encoded) avoids having to pad the payload of the packet; PADDING frames would be needed if the packet number is encoded on fewer bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、空の宛先接続IDを使用して最小限のパケットを保護することに関与する手順を示しています。このパケットは単一のpingフレーム（すなわち、たった0x01のペイロード）を含み、パケット番号は654360564を有する。この例では、パケット数3（つまり、49140がエンコードされている）を使用してペイロードを埋める必要があることを回避するパケットの。パケット番号がより少ないバイトでエンコードされている場合、パディングフレームは必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   pn                 = 654360564 (decimal)
   nonce              = e0459b3474bdd0e46d417eb0
   unprotected header = 4200bff4
   payload plaintext  = 01
   payload ciphertext = 655e5cd55c41f69080575d7999c25a5bfb
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resulting ciphertext is the minimum size possible. One byte is skipped to produce the sample for header protection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果の暗号文は可能な限り最小サイズです。1バイトはスキップされてヘッダ保護のためのサンプルが生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   sample = 5e5cd55c41f69080575d7999c25a5bfb
   mask   = aefefe7d03
   header = 4cfe4189
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protected packet is the smallest possible packet size of 21 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保護されたパケットは21バイトの最小のパケットサイズです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   packet = 4cfe4189655e5cd55c41f69080575d7999c25a5bfb
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-B--AEAD-Algorithm-Analysis">
Appendix B. AEAD Algorithm Analysis
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録B. AEADアルゴリズム分析
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section documents analyses used in deriving AEAD algorithm limits for AEAD_AES_128_GCM, AEAD_AES_128_CCM, and AEAD_AES_256_GCM. The analyses that follow use symbols for multiplication (*), division (/), and exponentiation (^), plus parentheses for establishing precedence. The following symbols are also used:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションこのセクションは、AEAD_AES_128_GCM、AEAD_AES_128_CCM、およびAEAD_AES_256_GCMのAEADアルゴリズムの制限を導出することで使用される分析を文書化しています。各分析は、乗算（*）、除算（/）、および指数（^）のシンボルに、優先順位を確立するための括弧を使用します。以下の記号も使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
t: The size of the authentication tag in bits. For these ciphers, t is 128.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
t：ビット内の認証タグのサイズ。これらの暗号のために、tは128です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
n: The size of the block function in bits. For these ciphers, n is 128.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
n：ブロック関数のサイズビット内のサイズ。これらの暗号のために、nは128です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
k: The size of the key in bits. This is 128 for AEAD_AES_128_GCM and AEAD_AES_128_CCM; 256 for AEAD_AES_256_GCM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
k：ビット内のキーのサイズ。これは、AEAD_AES_128_GCMおよびAEAD_AES_128_CCMの場合は128です。AEAD_AES_256_GCMの場合は256。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
l: The number of blocks in each packet (see below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
l：各パケット内のブロック数（下記参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
q: The number of genuine packets created and protected by endpoints. This value is the bound on the number of packets that can be protected before updating keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
q：エンドポイントによって作成および保護された本物のパケットの数。この値は、キーを更新する前に保護できるパケット数のバインドです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
v: The number of forged packets that endpoints will accept. This value is the bound on the number of forged packets that an endpoint can reject before updating keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
v：エンドポイントが受け入れる鍛造パケットの数。この値は、キーを更新する前にエンドポイントが拒否できる鍛造パケットの数のバインドです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o: The amount of offline ideal cipher queries made by an adversary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o：敵対者によって作られたオフラインの理想的な暗号クエリの量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The analyses that follow rely on a count of the number of block operations involved in producing each message. This analysis is performed for packets of size up to 2^11 (l = 2^7) and 2^16 (l = 2^12). A size of 2^11 is expected to be a limit that matches common deployment patterns, whereas the 2^16 is the maximum possible size of a QUIC packet. Only endpoints that strictly limit packet size can use the larger confidentiality and integrity limits that are derived using the smaller packet size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の分析は、各メッセージの作成に含まれるブロック操作の数の数に依存しています。この分析は、最大2^11（L = 2^7）および2^16（L = 2^12）のサイズのパケットについて実行されます。2^11のサイズは、共通の展開パターンに一致する限界であると予想されますが、2^16はQUICパケットの最大可能サイズです。パケットサイズを厳密に制限するエンドポイントだけが、小さいパケットサイズを使用して導出される大きな機密性と整合性の制限を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For AEAD_AES_128_GCM and AEAD_AES_256_GCM, the message length (l) is the length of the associated data in blocks plus the length of the plaintext in blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AEAD_AES_128_GCMおよびAEAD_AES_256_GCMの場合、メッセージ長（l）は、ブロック内の関連データの長さとプレーンテキストの長さをブロック内の長さです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For AEAD_AES_128_CCM, the total number of block cipher operations is the sum of the following: the length of the associated data in blocks, the length of the ciphertext in blocks, the length of the plaintext in blocks, plus 1. In this analysis, this is simplified to a value of twice the length of the packet in blocks (that is, &#34;2l = 2^8&#34; for packets that are limited to 2^11 bytes, or &#34;2l = 2^13&#34; otherwise). This simplification is based on the packet containing all of the associated data and ciphertext. This results in a one to three block overestimation of the number of operations per packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AEAD_AES_128_CCMの場合、ブロック暗号化操作の総数は、以下の合計です。ブロック内のパケットの長さの2倍の値（つまり、2^11バイトに制限されているパケットの場合は「2l = 2^8」、またはそうでない場合は「2l = 2^13」）の値に簡素化されています。この単純化は、関連するデータと暗号文のすべてを含むパケットに基づいています。これにより、パケットごとの操作数が1から3ブロックの過大評価になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-1--Analysis-of-AEADAES128GCM-and-AEADAES256GCM-Usage-Limits">
B.1. Analysis of AEAD_AES_128_GCM and AEAD_AES_256_GCM Usage Limits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.1. AEAD_AES_128_GCMおよびAEAD_AES_256_GCM使用制限の分析
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GCM-MU] specifies concrete bounds for AEAD_AES_128_GCM and AEAD_AES_256_GCM as used in TLS 1.3 and QUIC. This section documents this analysis using several simplifying assumptions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GCM-MU]は、TLS 1.3およびQUICで使用されているAEAD_AES_128_GCMおよびAEAD_AES_256_GCMの具体的な境界を指定します。このセクションでは、この分析をいくつか単純化してこの分析を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The number of ciphertext blocks an attacker uses in forgery attempts is bounded by v * l, which is the number of forgery attempts multiplied by the size of each packet (in blocks).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* CipherTextブロックの数は、偽造試行での攻撃者が v * l によって制限されます。これは、各パケットのサイズ（ブロック内）のサイズを掛けた偽造試行の数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The amount of offline work done by an attacker does not dominate other factors in the analysis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 攻撃者によって行われたオフライン作業の量は、分析における他の要因を支配しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bounds in [GCM-MU] are tighter and more complete than those used in [AEBounds], which allows for larger limits than those described in [TLS13].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GCM-MU]の境界は、[AEBounds]で使用されているものよりも厳密かつ完全です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-1-1--Confidentiality-Limit">
B.1.1. Confidentiality Limit
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.1.1. 機密性の制限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For confidentiality, Theorem (4.3) in [GCM-MU] establishes that, for a single user that does not repeat nonces, the dominant term in determining the distinguishing advantage between a real and random AEAD algorithm gained by an attacker is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
機密性のために、[GCM-MU]の定理（4.3）は、ノンスを繰り返さない単一のユーザーのために、攻撃者によって得られた実際のAEADアルゴリズムとランダムなAEADアルゴリズムの間の識別上の利点を決定する際の支配的な用語を確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   2 * (q * l)^2 / 2^n
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a target advantage of 2^-57, this results in the relation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2^-57の目標利点については、これは関係にある。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   q &lt;= 2^35 / l
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, endpoints that do not send packets larger than 2^11 bytes cannot protect more than 2^28 packets in a single connection without causing an attacker to gain a more significant advantage than the target of 2^-57. The limit for endpoints that allow for the packet size to be as large as 2^16 is instead 2^23.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、2^11バイトより大きいパケットを送信しないエンドポイントは、攻撃者が2^-57の目標よりも大きな利点を得ることなく、単一の接続で2^28パケットを保護することはできません。パケットサイズを2^16と同じ大きさにすることを可能にするエンドポイントの制限は、代わりに2^23です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-1-2--Integrity-Limit">
B.1.2. Integrity Limit
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.1.2. 完全性の制限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For integrity, Theorem (4.3) in [GCM-MU] establishes that an attacker gains an advantage in successfully forging a packet of no more than the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
整合性のために、[GCM-MU]の定理（4.3）は、攻撃者が以下のもの以下のパケットを首尾よく獲得することにおいて利点を得ることを確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (1 / 2^(8 * n)) + ((2 * v) / 2^(2 * n))
           + ((2 * o * v) / 2^(k + n)) + (n * (v + (v * l)) / 2^k)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goal is to limit this advantage to 2^-57. For AEAD_AES_128_GCM, the fourth term in this inequality dominates the rest, so the others can be removed without significant effect on the result. This produces the following approximation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目標はこの利点を2^-57に制限することです。AEAD_AES_128_GCMの場合、この不等式の4番目の項は残りを支配しているため、結果に大きな影響を与えずに他のものを削除できます。これにより、次の近似値が生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   v &lt;= 2^64 / l
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints that do not attempt to remove protection from packets larger than 2^11 bytes can attempt to remove protection from at most 2^57 packets. Endpoints that do not restrict the size of processed packets can attempt to remove protection from at most 2^52 packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2^11バイトより大きいパケットから保護を除去しようとしないエンドポイントは、最大2^57パケットから保護を削除しようとします。処理されたパケットのサイズを制限しないエンドポイントは、最大2^52パケットから保護を除去しようとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For AEAD_AES_256_GCM, the same term dominates, but the larger value of k produces the following approximation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AEAD_AES_256_GCMの場合、同じ用語が支配的ですが、Kの値が大きいほど次の近似値が生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   v &lt;= 2^192 / l
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is substantially larger than the limit for AEAD_AES_128_GCM. However, this document recommends that the same limit be applied to both functions as either limit is acceptably large.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、AEAD_AES_128_GCMの制限より実質的に大きいです。ただし、この文書では、どちらの制限も両方の機能に適用されることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-2--Analysis-of-AEADAES128CCM-Usage-Limits">
B.2. Analysis of AEAD_AES_128_CCM Usage Limits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.2. AEAD_AES_128_CCM使用制限の分析
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS [TLS13] and [AEBounds] do not specify limits on usage for AEAD_AES_128_CCM. However, any AEAD that is used with QUIC requires limits on use that ensure that both confidentiality and integrity are preserved. This section documents that analysis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS [TLS13]と[AEBounds]は、AEAD_AES_128_CCMの使用上の制限を指定しません。ただし、QUICで使用されるAEADは、機密性と完全性の両方が保存されていることを保証する使用時の制限が必要です。このセクションはその分析を文書化しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CCM-ANALYSIS] is used as the basis of this analysis. The results of that analysis are used to derive usage limits that are based on those chosen in [TLS13].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CCM分析]はこの分析の基礎として使用されます。その分析の結果は、[TLS13]で選択されたものに基づく使用制限を導き出すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For confidentiality, Theorem 2 in [CCM-ANALYSIS] establishes that an attacker gains a distinguishing advantage over an ideal pseudorandom permutation (PRP) of no more than the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
機密性のために、[CCM分析]の定理2は、攻撃者が以下の理想的な疑似乱数順列（PRP）よりも区別的な利点を得ることを確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (2l * q)^2 / 2^n
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The integrity limit in Theorem 1 in [CCM-ANALYSIS] provides an attacker a strictly higher advantage for the same number of messages. As the targets for the confidentiality advantage and the integrity advantage are the same, only Theorem 1 needs to be considered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CCM-Analysis]の定理1の整合性制限は、同じ数のメッセージに対して厳密に高い利点を担持します。機密性の利点と完全性の利点の対象となるにつれて、定理1のみを考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Theorem 1 establishes that an attacker gains an advantage over an ideal PRP of no more than the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定理1は、攻撃者が以下のもの以下の理想的なPRPよりも利点を利益を得ることを確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   v / 2^t + (2l * (v + q))^2 / 2^n
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As &#34;t&#34; and &#34;n&#34; are both 128, the first term is negligible relative to the second, so that term can be removed without a significant effect on the result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「t」および「n」は両方とも128であるので、第1の項は第2に対して無視できるので、その結果は結果に大きな影響を与えずに除去することができる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This produces a relation that combines both encryption and decryption attempts with the same limit as that produced by the theorem for confidentiality alone. For a target advantage of 2^-57, this results in the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、機密性のみのために、定理によって生成されたものと同じ制限で、暗号化と復号化の両方の試みの両方を組み合わせる関係が生成されます。2^-57の目標利点については、これにより次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   v + q &lt;= 2^34.5 / l
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By setting &#34;q = v&#34;, values for both confidentiality and integrity limits can be produced. Endpoints that limit packets to 2^11 bytes therefore have both confidentiality and integrity limits of 2^26.5 packets. Endpoints that do not restrict packet size have a limit of 2^21.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「q = v」を設定することで、機密性と整合性の両方の値の値を生成することができます。したがって、パケットを2^11バイトに制限するエンドポイントは、2^26.5パケットの機密性と整合性の両方の制限を持ちます。パケットサイズを制限しないエンドポイントには、2^21.5の制限があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Contributors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
貢献者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF QUIC Working Group received an enormous amount of support from many people. The following people provided substantive contributions to this document:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF熟練したワーキンググループは、多くの人々から膨大な量のサポートを受けました。以下の人々はこの文書への実質的な貢献を提供しました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Adam Langley * Alessandro Ghedini * Christian Huitema * Christopher Wood * David Schinazi * Dragana Damjanovic * Eric Rescorla * Felix Günther * Ian Swett * Jana Iyengar * 奥 一穂 (Kazuho Oku) * Marten Seemann * Martin Duke * Mike Bishop * Mikkel Fahnøe Jørgensen * Nick Banks * Nick Harper * Roberto Peon * Rui Paulo * Ryan Hamilton * Victor Vasiliev
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Adam Langley * Alessandro Ghedini * Christian Huitema * Christopher Wood * David Schinazi * Dragana Damjanovic * Eric Rescorla * Felix Günther * Ian Swett * Jana Iyengar * 奥 一穂 (Kazuho Oku) * Marten Seemann * Martin Duke * Mike Bishop * Mikkel Fahnøe Jørgensen * Nick Banks * Nick Harper * Roberto Peon * Rui Paulo * Ryan Hamilton * Victor Vasiliev
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者の住所
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Martin Thomson (editor) Mozilla
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Martin Thomson（編集）Mozilla.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: mt@lowentropy.net
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sean Turner (editor) sn3rd
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sean Turner（編集）sn3rd
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: sean@sn3rd.com
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
