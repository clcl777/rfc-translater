<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 8699 - Coupled congestion control for RTP media 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">8699</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc8699">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 8699 - Coupled congestion control for RTP media 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc8699">
            https://datatracker.ietf.org/doc/html/rfc8699
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 8699 - RTPメディアの結合輻輳制御</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                          S. Islam
Request for Comments: 8699                                      M. Welzl
Category: Experimental                                       S. Gjessing
ISSN: 2070-1721                                       University of Oslo
                                                            January 2020
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
Coupled Congestion Control for RTP Media
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
RTPメディアの結合輻輳制御
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When multiple congestion-controlled Real-time Transport Protocol (RTP) sessions traverse the same network bottleneck, combining their controls can improve the total on-the-wire behavior in terms of delay, loss, and fairness. This document describes such a method for flows that have the same sender, in a way that is as flexible and simple as possible while minimizing the number of changes needed to existing RTP applications. This document also specifies how to apply the method for the Network-Assisted Dynamic Adaptation (NADA) congestion control algorithm and provides suggestions on how to apply it to other congestion control algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数の輻輳制御Real-time Transport Protocol（RTP）セッションが同じネットワークボトルネックを通過する場合、それらの制御を組み合わせると、遅延、損失、および公平性の観点から、ネットワーク上の動作全体を改善できます。このドキュメントでは、既存のRTPアプリケーションに必要な変更の数を最小限に抑えながら、可能な限り柔軟でシンプルな方法で、同じ送信者を持つフローのそのような方法について説明します。このドキュメントでは、Network-Assisted Dynamic Adaptation（NADA）輻輳制御アルゴリズムの方法を適用する方法も指定し、それを他の輻輳制御アルゴリズムに適用する方法に関する提案を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはInternet Standards Trackの仕様ではありません。試験、実験、評価のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are candidates for any level of Internet Standard; see Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、インターネットコミュニティの実験プロトコルを定義します。このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。 IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補であるとは限りません。 RFC 7841のセクション2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8699.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8699で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2020 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction
   2.  Definitions
   3.  Limitations
   4.  Architectural Overview
   5.  Roles
     5.1.  SBD
     5.2.  FSE
     5.3.  Flows
       5.3.1.  Example Algorithm 1 - Active FSE
       5.3.2.  Example Algorithm 2 - Conservative Active FSE
   6.  Application
     6.1.  NADA
     6.2.  General Recommendations
   7.  Expected Feedback from Experiments
   8.  IANA Considerations
   9.  Security Considerations
   10. References
     10.1.  Normative References
     10.2.  Informative References
   Appendix A.  Application to GCC
   Appendix B.  Scheduling
   Appendix C.  Example Algorithm - Passive FSE
     C.1.  Example Operation (Passive)
   Acknowledgements
   Authors&#39; Addresses
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When there is enough data to send, a congestion controller attempts to increase its sending rate until the path&#39;s capacity has been reached. Some controllers detect path capacity by increasing the sending rate further, until packets are ECN-marked [RFC8087] or dropped, and then decreasing the sending rate until that stops happening. This process inevitably creates undesirable queuing delay when multiple congestion-controlled connections traverse the same network bottleneck, and each connection overshoots the path capacity as it determines its sending rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信するのに十分なデータがある場合、輻輳コントローラは、パスの容量に達するまで送信レートを上げようとします。一部のコントローラーは、パケットにECNマークが付けられるか[RFC8087]になるまで送信レートをさらに上げ、それが発生しなくなるまで送信レートを下げて、パス容量を検出します。このプロセスは、複数の輻輳制御接続が同じネットワークボトルネックを通過し、送信レートを決定するときに各接続がパス容量をオーバーシュートすると、必然的に望ましくないキューイング遅延を作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Congestion Manager (CM) [RFC3124] couples flows by providing a single congestion controller. It is hard to implement because it requires an additional congestion controller and removes all per-connection congestion control functionality, which is quite a significant change to existing RTP-based applications. This document presents a method to combine the behavior of congestion control mechanisms that is easier to implement than the Congestion Manager [RFC3124] and also requires fewer significant changes to existing RTP-based applications. It attempts to roughly approximate the CM behavior by sharing information between existing congestion controllers. It is able to honor user-specified priorities, which is required by WebRTC [RTCWEB-OVERVIEW] [RFC7478].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Congestion Manager（CM）[RFC3124]は、単一の輻輳コントローラーを提供することにより、フローを結合します。追加の輻輳コントローラーが必要であり、すべての接続ごとの輻輳制御機能が削除されるため、実装は困難です。これは、既存のRTPベースのアプリケーションに対する非常に大きな変更です。このドキュメントでは、Congestion Manager [RFC3124]よりも実装が容易で、既存のRTPベースのアプリケーションに大幅な変更を加える必要がない、輻輳制御メカニズムの動作を組み合わせる方法を示します。既存の輻輳コントローラー間で情報を共有することにより、CMの動作を大まかに近似しようとします。 WebRTC [RTCWEB-OVERVIEW] [RFC7478]で必要とされるユーザー指定の優先度を尊重することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The described mechanisms are believed safe to use, but they are experimental and are presented for wider review and operational evaluation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明されたメカニズムは安全に使用できると考えられていますが、それらは実験的であり、より広範なレビューと運用評価のために提示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Definitions">
2. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Available Bandwidth: The available bandwidth is the nominal link capacity minus the amount of traffic that traversed the link during a certain time interval, divided by that time interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
利用可能な帯域幅：利用可能な帯域幅は、公称リンク容量から特定の時間間隔中にリンクを通過したトラフィックの量を差し引いたものを、その時間間隔で割った値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bottleneck: The first link with the smallest available bandwidth along the path between a sender and receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ボトルネック：送信者と受信者の間のパスに沿って利用可能な最小の帯域幅を持つ最初のリンク。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow: A flow is the entity that congestion control is operating on. It could, for example, be a transport-layer connection or an RTP stream [RFC7656], regardless of whether or not this RTP stream is multiplexed onto an RTP session with other RTP streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー：フローは、輻輳制御が動作しているエンティティです。たとえば、このRTPストリームが他のRTPストリームとのRTPセッションに多重化されているかどうかに関係なく、トランスポート層接続またはRTPストリーム[RFC7656]である可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow Group Identifier (FGI): A unique identifier for each subset of flows that is limited by a common bottleneck.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローグループ識別子（FGI）：共通のボトルネックによって制限されるフローの各サブセットの一意の識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow State Exchange (FSE): The entity that maintains information that is exchanged between flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow State Exchange（FSE）：フロー間で交換される情報を維持するエンティティ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow Group (FG): A group of flows having the same FGI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローグループ（FG）：同じFGIを持つフローのグループ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Shared Bottleneck Detection (SBD): The entity that determines which flows traverse the same bottleneck in the network or the process of doing so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有ボトルネック検出（SBD）：どのフローがネットワーク内の同じボトルネックを通過するかを決定するエンティティまたはそのプロセス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Limitations">
3. Limitations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 制限事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sender-side only: Shared bottlenecks can exist when multiple flows originate from the same sender or when flows from different senders reach the same receiver (see Section 3 of [RFC8382]). Coupled congestion control, as described here, only supports the former case, not the latter, as it operates inside a single host on the sender side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者側のみ：複数のフローが同じ送信者から発信された場合、または異なる送信者からのフローが同じ受信者に到達した場合、共有ボトルネックが存在する可能性があります（[RFC8382]のセクション3を参照）。ここで説明する結合輻輳制御は、送信側の単一ホスト内で動作するため、前者のケースのみをサポートし、後者はサポートしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Shared bottlenecks do not change quickly: As per the definition above, a bottleneck depends on cross traffic, and since such traffic can heavily fluctuate, bottlenecks can change at a high frequency (e.g., there can be oscillation between two or more links). This means that, when flows are partially routed along different paths, they may quickly change between sharing and not sharing a bottleneck. For simplicity, here it is assumed that a shared bottleneck is valid for a time interval that is significantly longer than the interval at which congestion controllers operate. Note that, for the only SBD mechanism defined in this document (multiplexing on the same five-tuple), the notion of a shared bottleneck stays correct even in the presence of fast traffic fluctuations; since all flows that are assumed to share a bottleneck are routed in the same way, if the bottleneck changes, it will still be shared.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有ボトルネックはすぐには変化しません。上記の定義に従って、ボトルネックはクロストラフィックに依存します。このようなトラフィックは大きく変動する可能性があるため、ボトルネックは高頻度で変化する可能性があります（たとえば、2つ以上のリンク間に振動がある可能性があります）。これは、フローが異なるパスに沿って部分的にルーティングされている場合、ボトルネックを共有することと共有しないこととの間ですぐに変わる可能性があることを意味します。簡単にするために、ここでは、共有ボトルネックが、輻輳コントローラーが動作する間隔よりも大幅に長い時間間隔で有効であると想定しています。このドキュメントで定義されている唯一のSBDメカニズム（同じ5タプルでの多重化）の場合、共有トラフィックのボトルネックの概念は、トラフィックの変動が速い場合でも正しいままです。ボトルネックを共有すると想定されているすべてのフローは同じ方法でルーティングされるため、ボトルネックが変化しても、共有されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Architectural-Overview">
4. Architectural Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. アーキテクチャの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 1 shows the elements of the architecture for coupled congestion control: the Flow State Exchange (FSE), Shared Bottleneck Detection (SBD), and Flows. The FSE is a storage element that can be implemented in two ways: active and passive. In the active version, it initiates communication with flows and SBD. However, in the passive version, it does not actively initiate communication with flows and SBD; its only active role is internal state maintenance (e.g., an implementation could use soft state to remove a flow&#39;s data after long periods of inactivity). Every time a flow&#39;s congestion control mechanism would normally update its sending rate, the flow instead updates information in the FSE and performs a query on the FSE, leading to a sending rate that can be different from what the congestion controller originally determined. Using information about/from the currently active flows, SBD updates the FSE with the correct Flow Group Identifiers (FGIs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図1は、結合された輻輳制御のアーキテクチャーの要素、フロー状態交換（FSE）、共有ボトルネック検出（SBD）、およびフローを示しています。 FSEは、アクティブとパッシブの2つの方法で実装できるストレージ要素です。アクティブバージョンでは、フローおよびSBDとの通信を開始します。ただし、パッシブバージョンでは、フローおよびSBDとの通信をアクティブに開始しません。その唯一のアクティブな役割は、内部状態のメンテナンスです（たとえば、実装では、ソフトステートを使用して、長期間非アクティブになった後にフローのデータを削除できます）。フローの輻輳制御メカニズムが通常はその送信レートを更新するたびに、フローは代わりにFSEの情報を更新し、FSEに対してクエリを実行するため、輻輳コントローラーが最初に決定したものとは異なる送信レートになる可能性があります。 SBDは、現在アクティブなフローに関する情報を使用して、FSEを正しいフローグループ識別子（FGI）で更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes both active and passive versions. While the passive algorithm works better for congestion controls with RTT-independent convergence, it can still produce oscillations on short time scales. The passive algorithm, described in Appendix C, is therefore considered highly experimental and not safe to deploy outside of testbed environments. Figure 2 shows the interaction between flows and the FSE using the variable names defined in Section 5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、アクティブバージョンとパッシブバージョンの両方について説明します。パッシブアルゴリズムは、RTTに依存しない収束による輻輳制御に適していますが、短い時間スケールで振動を生成する可能性があります。したがって、付録Cで説明されているパッシブアルゴリズムは非常に実験的であり、テストベッド環境の外に展開するのは安全ではありません。図2は、セクション5.2で定義された変数名を使用したフローとFSE間の相互作用を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                         -------  &lt;---  Flow 1
                         | FSE |  &lt;---  Flow 2 ..
                         -------  &lt;---  .. Flow N
                            ^
                            |             |
                         -------          |
                         | SBD |  &lt;-------|
                         -------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Figure 1: Coupled congestion control architecture
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
図1：結合された輻輳制御アーキテクチャ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Flow#1(cc)                     FSE                    Flow#2(cc)
     ----------                     ---                    ----------
     #1 JOIN     ----register--&gt; REGISTER
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
REGISTER &lt;--register-- JOIN #1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
登録&lt;-register-- JOIN＃1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     #2 CC_R(1)  ----UPDATE----&gt; UPDATE (in)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     #3 NEW RATE &lt;---FSE_R(1)-- UPDATE (out) --FSE_R(2)-&gt; #3 NEW RATE
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
Figure 2: Flow-FSE interactions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
図2：Flow-FSEの相互作用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since everything shown in Figure 1 is assumed to operate on a single host (the sender) only, this document only describes aspects that have an influence on the resulting on-the-wire behavior. It does not, for instance, define how many bits must be used to represent FGIs or in which way the entities communicate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図1に示されているものはすべて、単一のホスト（送信側）でのみ動作することを前提としているため、このドキュメントでは、結果として生じるネットワーク上の動作に影響を与える側面のみを説明します。たとえば、FGIを表すために使用する必要があるビット数や、エンティティがどのように通信するかは定義しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations can take various forms; for instance, all the elements in the figure could be implemented within a single application, thereby operating on flows generated by that application only. Another alternative could be to implement both the FSE and SBD together in a separate process that different applications communicate with via some form of Inter-Process Communication (IPC). Such an implementation would extend the scope to flows generated by multiple applications. The FSE and SBD could also be included in the Operating System kernel. However, only one type of coupling algorithm should be used for all flows. Combinations of multiple algorithms at different aggregation levels (e.g., the Operating System coupling application aggregates with one algorithm, and applications coupling their flows with another) have not been tested and are therefore not recommended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装にはさまざまな形式があります。たとえば、図のすべての要素を単一のアプリケーション内に実装して、そのアプリケーションのみで生成されたフローを操作できます。別の方法としては、FSEとSBDの両方を、異なるアプリケーションが何らかの形式のプロセス間通信（IPC）を介して通信する個別のプロセスに一緒に実装することもできます。そのような実装は、複数のアプリケーションによって生成されるフローに範囲を拡張します。 FSEとSBDは、オペレーティングシステムカーネルに含めることもできます。ただし、すべてのフローに使用する結合アルゴリズムのタイプは1つだけにする必要があります。異なる集約レベルでの複数のアルゴリズムの組み合わせ（たとえば、オペレーティングシステムカップリングアプリケーションが1つのアルゴリズムと集約し、アプリケーションがフローを別のアルゴリズムとカップリングする）はテストされていないため、推奨されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Roles">
5. Roles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 役割
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section gives an overview of the roles of the elements of coupled congestion control and provides an example of how coupled congestion control can operate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、結合された輻輳制御の要素の役割の概要を示し、結合された輻輳制御がどのように動作するかの例を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--SBD">
5.1. SBD
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. SBD
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SBD uses knowledge about the flows to determine which flows belong in the same Flow Group (FG) and assigns FGIs accordingly. This knowledge can be derived in three basic ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SBDは、フローに関する知識を使用して、どのフローが同じフローグループ（FG）に属しているかを判断し、それに応じてFGIを割り当てます。この知識は、3つの基本的な方法で導き出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. From multiplexing: It can be based on the simple assumption that packets sharing the same five-tuple (IP source and destination address, protocol, and transport-layer port number pair) and having the same values for the Differentiated Services Code Point (DSCP) and the ECN field in the IP header are typically treated in the same way along the path. This method is the only one specified in this document; SBD MAY consider all flows that use the same five-tuple, DSCP, and ECN field value to belong to the same FG. This classification applies to certain tunnels or RTP flows that are multiplexed over one transport (cf. [TRANSPORT-MULTIPLEX]). Such multiplexing is also a recommended usage of RTP in WebRTC [RTCWEB-RTP-USAGE].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 多重化から：同じ5タプル（IP送信元と宛先のアドレス、プロトコル、トランスポート層のポート番号のペア）を共有し、Differentiated Services Code Point（DSCP）に同じ値を持つパケットという単純な仮定に基づくことができます。 IPヘッダーのECNフィールドは、通常、パスに沿って同じ方法で処理されます。このメソッドは、このドキュメントで指定されている唯一のメソッドです。 SBDは、同じ5タプル、DSCP、およびECNフィールド値を使用するすべてのフローが同じFGに属すると見なす場合があります。この分類は、1つのトランスポートを介して多重化される特定のトンネルまたはRTPフローに適用されます（[TRANSPORT-MULTIPLEX]を参照）。このような多重化は、WebRTC [RTCWEB-RTP-USAGE]でのRTPの推奨される使用法でもあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Via configuration: e.g., by assuming that a common wireless uplink is also a shared bottleneck.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 構成経由：たとえば、一般的なワイヤレスアップリンクも共有ボトルネックであると想定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. From measurements: e.g., by considering correlations among measured delay and loss as an indication of a shared bottleneck.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 測定から：たとえば、測定された遅延と損失の間の相関を、共有ボトルネックの指標として検討することによって。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The methods above have some essential trade-offs. For example, multiplexing is a completely reliable measure, but it is limited in scope to two endpoints (i.e., it cannot be applied to couple congestion controllers of one sender talking to multiple receivers). A measurement-based SBD mechanism is described in [RFC8382]. Measurements can never be 100% reliable, in particular because they are based on the past, but applying coupled congestion control involves making an assumption about the future; it is therefore recommended to implement cautionary measures, e.g., by disabling coupled congestion control if enabling it causes a significant increase in delay and/or packet loss. Measurements also take time, which entails a certain delay for turning on coupling (refer to [RFC8382] for details). When this is possible, it can be more efficient to statically configure shared bottlenecks (e.g., via a system configuration or user input) based on assumptions about the network environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の方法にはいくつかの本質的なトレードオフがあります。たとえば、多重化は完全に信頼できる手段ですが、範囲は2つのエンドポイントに限定されます（つまり、1つの送信者の輻輳コントローラーを複数の受信者と通信するために適用することはできません）。測定ベースのSBDメカニズムは、[RFC8382]で説明されています。特に過去に基づいているため、測定が100％信頼できるとは限りませんが、結合された輻輳制御を適用すると、将来についての仮定が必要になります。したがって、遅延やパケット損失の大幅な増加を引き起こす可能性がある場合は、結合された輻輳制御を無効にするなど、注意事項を実装することをお勧めします。測定にも時間がかかるため、カップリングをオンにするために一定の遅延が生じます（詳細については、[RFC8382]を参照してください）。これが可能な場合は、ネットワーク環境に関する想定に基づいて、共有のボトルネックを静的に構成すること（システム構成やユーザー入力など）の方が効率的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--FSE">
5.2. FSE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. ESF
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The FSE contains a list of all flows that have registered with it. For each flow, the FSE stores the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FSEには、FSEに登録されているすべてのフローのリストが含まれています。 FSEは、フローごとに次のものを格納します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* a unique flow number f to identify the flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* フローを識別する一意のフロー番号f。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* the FGI of the FG that it belongs to (based on the definitions in this document, a flow has only one bottleneck and can therefore be in only one FG).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 所属するFGのFGI（このドキュメントの定義に基づいて、フローにはボトルネックが1つしかないため、1つのFGに​​しか存在できません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* a priority P(f), which is a number greater than zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 優先度P（f）。これはゼロより大きい数値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The rate used by the flow in bits per second, FSE_R(f).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* フローが使用するレート（ビット/秒）、FSE_R（f）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The desired rate DR(f) of flow f. This can be smaller than FSE_R(f) if the application feeding into the flow has less data to send than FSE_R(f) would allow or if a maximum value is imposed on the rate. In the absence of such limits, DR(f) must be set to the sending rate provided by the congestion control module of flow f.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* フローfの望ましいレートDR（f）。フローにフィードするアプリケーションがFSE_R（f）が許可するよりも送信するデータが少ない場合、または最大値がレートに課せられている場合、これはFSE_R（f）よりも小さくなる可能性があります。そのような制限がない場合、DR（f）はフローfの輻輳制御モジュールによって提供される送信レートに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the absolute range of priorities does not matter; the algorithm works with a flow&#39;s priority portion of the sum of all priority values. For example, if there are two flows, flow 1 with priority 1 and flow 2 with priority 2, the sum of the priorities is 3. Then, flow 1 will be assigned 1/3 of the aggregate sending rate, and flow 2 will be assigned 2/3 of the aggregate sending rate. Priorities can be mapped to the &#34;very-low&#34;, &#34;low&#34;, &#34;medium&#34;, or &#34;high&#34; priority levels described in [WEBRTC-TRANS] by simply using the values 1, 2, 4, and 8, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
優先順位の絶対的な範囲は重要ではないことに注意してください。アルゴリズムは、すべての優先順位値の合計のフローの優先順位部分で機能します。たとえば、フロー1に優先度1のフロー1と優先度2のフロー2がある場合、優先度の合計は3になります。次に、フロー1には集約送信レートの1/3が割り当てられ、フロー2は総送信レートの2/3が割り当てられます。優先度は、[WEBRTC-TRANS]で説明されている「非常に低い」、「低い」、「中」、または「高い」優先度レベルにそれぞれ1、2、4、および8の値を使用するだけでマッピングできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the FSE, each FG contains one static variable, S_CR, which is the sum of the calculated rates of all flows in the same FG. This value is used to calculate the sending rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FSEでは、各FGに1つの静的変数S_CRが含まれています。これは、同じFG内のすべてのフローの計算されたレートの合計です。この値は、送信速度の計算に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The information listed here is enough to implement the sample flow algorithm given below. FSE implementations could easily be extended to store, e.g., a flow&#39;s current sending rate for statistics gathering or future potential optimizations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここにリストされている情報は、以下に示すサンプルフローアルゴリズムを実装するのに十分です。 FSEの実装は、統計収集や将来の潜在的な最適化のためのフローの現在の送信レートなどを格納するように簡単に拡張できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3--Flows">
5.3. Flows
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. 流れ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flows register themselves with SBD and FSE when they start, deregister from the FSE when they stop, and carry out an UPDATE function call every time their congestion controller calculates a new sending rate. Via UPDATE, they provide the newly calculated rate and, optionally (if the algorithm supports it), the desired rate. The desired rate is less than the calculated rate in case of application-limited flows; otherwise, it is the same as the calculated rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローは、開始時にSBDおよびFSEに自分自身を登録し、フローが停止するとFSEから登録解除し、輻輳コントローラーが新しい送信レートを計算するたびにUPDATE関数呼び出しを実行します。 UPDATEを介して、それらは新しく計算されたレートを提供し、オプションで（アルゴリズムがサポートしている場合は）望ましいレートを提供します。アプリケーションで制限されたフローの場合、望ましいレートは計算されたレートよりも低くなります。それ以外の場合は、計算されたレートと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Below, two example algorithms are described. While other algorithms could be used instead, the same algorithm must be applied to all flows. Names of variables used in the algorithms are explained below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下に、2つのアルゴリズムの例を示します。他のアルゴリズムを代わりに使用できますが、同じアルゴリズムをすべてのフローに適用する必要があります。アルゴリズムで使用される変数の名前を以下に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CC_R(f) The rate received from the congestion controller of flow f when it calls UPDATE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CC_R（f）UPDATEを呼び出したときに、フローfの輻輳コントローラーから受信したレート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FSE_R(f) The rate calculated by the FSE for flow f.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FSE_R（f）フローfのFSEによって計算されたレート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DR(f) The desired rate of flow f.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DR（f）望ましい流量f。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_CR The sum of the calculated rates of all flows in the same FG; this value is used to calculate the sending rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_CR同じFG内のすべてのフローの計算されたレートの合計。この値は、送信速度の計算に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FG A group of flows having the same FGI and hence, sharing the same bottleneck.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FG同じFGIを持ち、したがって同じボトルネックを共有するフローのグループ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P(f) The priority of flow f, which is received from the flow&#39;s congestion controller; the FSE uses this variable for calculating FSE_R(f).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P（f）フローの輻輳コントローラから受信したフローfの優先度。 FSEはこの変数を使用してFSE_R（f）を計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_P The sum of all the priorities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_Pすべての優先度の合計。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLO The total leftover rate; the sum of rates that could not be assigned to flows that were limited by their desired rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLO残りの合計レート。望ましいレートによって制限されたフローに割り当てることができなかったレートの合計。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AR The aggregate rate that is assigned to flows that are not limited by their desired rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AR必要なレートによって制限されないフローに割り当てられる総レート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3-1--Example-Algorithm-1---Active-FSE">
5.3.1. Example Algorithm 1 - Active FSE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1. アルゴリズム例1-アクティブなFSE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This algorithm was designed to be the simplest possible method to assign rates according to the priorities of flows. Simulation results in [FSE] indicate that it does not, however, significantly reduce queuing delay and packet loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムは、フローの優先順位に従ってレートを割り当てる最も簡単な方法になるように設計されました。 [FSE]のシミュレーション結果は、キューイング遅延とパケット損失を大幅に削減しないことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) When a flow f starts, it registers itself with SBD and the FSE. FSE_R(f) is initialized with the congestion controller&#39;s initial rate. SBD will assign the correct FGI. When a flow is assigned an FGI, it adds its FSE_R(f) to S_CR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（1）フローfが開始されると、フロー自体がSBDおよびFSEに登録されます。 FSE_R（f）は、輻輳コントローラーの初期レートで初期化されます。 SBDは正しいFGIを割り当てます。フローにFGIが割り当てられると、フローはそのFSE_R（f）をS_CRに追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) When a flow f stops or pauses, its entry is removed from the list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（2）フローfが停止または一時停止すると、そのエントリはリストから削除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) Every time the congestion controller of the flow f determines a new sending rate CC_R(f), the flow calls UPDATE, which carries out the tasks listed below to derive the new sending rates for all the flows in the FG. A flow&#39;s UPDATE function uses three local (i.e., per-flow) temporary variables: S_P, TLO, and AR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3）フローfの輻輳コントローラーが新しい送信レートCC_R（f）を決定するたびに、フローはUPDATEを呼び出します。UPDATEは、以下のタスクを実行して、FG内のすべてのフローの新しい送信レートを導き出します。フローのUPDATE関数は、S_P、TLO、ARの3つのローカル（フローごと）一時変数を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
(a) It updates S_CR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
（a）S_CRを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       S_CR = S_CR + CC_R(f) - FSE_R(f)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
(b) It calculates the sum of all the priorities, S_P, and initializes FSE_R.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
（b）すべての優先度の合計S_Pを計算し、FSE_Rを初期化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
S_P = 0 for all flows i in FG do S_P = S_P + P(i) FSE_R(i) = 0 end for
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
FG内のすべてのフローiに対してS_P = 0 do S_P = S_P + P（i）FSE_R（i）= 0終了
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
(c) It distributes S_CR among all flows, ensuring that each flow&#39;s desired rate is not exceeded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
（c）すべてのフロー間でS_CRを分散し、各フローの希望レートを超えないようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       TLO = S_CR
                       while(TLO-AR&gt;0 and S_P&gt;0)
                           AR = 0
                           for all flows i in FG do
                               if FSE_R[i] &lt; DR[i] then
                                   if TLO * P[i] / S_P &gt;= DR[i] then
                                       TLO = TLO - DR[i]
                                       FSE_R[i] = DR[i]
                                       S_P = S_P - P[i]
                                   else
                                       FSE_R[i] = TLO * P[i] / S_P
                                       AR = AR + TLO * P[i] / S_P
                                   end if
                               end if
                           end for
                       end while
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
(d) It distributes FSE_R to all the flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
（d）FSE_Rをすべてのフローに分散します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
for all flows i in FG do send FSE_R(i) to the flow i end for
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
FG内のすべてのフローについて、FSE_R（i）をフローiに送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3-2--Example-Algorithm-2---Conservative-Active-FSE">
5.3.2. Example Algorithm 2 - Conservative Active FSE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.2. アルゴリズム例2-保守的なアクティブFSE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This algorithm changes algorithm 1 to conservatively emulate the behavior of a single flow by proportionally reducing the aggregate rate on congestion. Simulation results in [FSE] indicate that it can significantly reduce queuing delay and packet loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムは、アルゴリズム1を変更して、輻輳時の総レートを比例的に低下させることにより、単一のフローの動作を控えめにエミュレートします。 [FSE]のシミュレーション結果は、キューイング遅延とパケット損失を大幅に削減できることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Step (a) of the UPDATE function is changed as described below. This also introduces a local variable DELTA, which is used to calculate the difference between CC_R(f) and the previously stored FSE_R(f). To prevent flows from either ignoring congestion or overreacting, a timer keeps them from changing their rates immediately after the common rate reduction that follows a congestion event. This timer is set to two RTTs of the flow that experienced congestion because it is assumed that a congestion event can persist for up to one RTT of that flow, with another RTT added to compensate for fluctuations in the measured RTT value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UPDATE関数のステップ（a）は、次のように変更されます。これは、CC_R（f）と以前に保存されたFSE_R（f）の間の差を計算するために使用されるローカル変数DELTAも導入します。フローが輻輳を無視したり過剰に反応したりするのを防ぐために、タイマーは、輻輳イベントに続く一般的なレート削減の直後にフローがレートを変更しないようにします。このタイマーは、輻輳が発生したフローの2つのRTTに設定されます。これは、測定されたRTT値の変動を補正するために別のRTTが追加されて、そのフローの最大1つのRTTまで輻輳イベントが持続することが想定されるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(a) It updates S_CR based on DELTA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（a）DELTAに基づいてS_CRを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  if Timer has expired or was not set then
                    DELTA = CC_R(f) - FSE_R(f)
                    if DELTA &lt; 0 then  // Reduce S_CR proportionally
                      S_CR = S_CR * CC_R(f) / FSE_R(f)
                      Set Timer for 2 RTTs
                    else
                      S_CR = S_CR + DELTA
                    end if
                   end if
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Application">
6. Application
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 応用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section specifies how the FSE can be applied to specific congestion control mechanisms and makes general recommendations that facilitate applying the FSE to future congestion controls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、FSEを特定の輻輳制御メカニズムに適用する方法を指定し、FSEを将来の輻輳制御に適用することを容易にする一般的な推奨事項を作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1--NADA">
6.1. NADA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 何も
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Network-Assisted Dynamic Adaptation (NADA) [RFC8698] is a congestion control scheme for WebRTC. It calculates a reference rate r_ref upon receiving an acknowledgment and then, based on the reference rate, calculates a video target rate r_vin and a sending rate for the flows, r_send.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Network-Assisted Dynamic Adaptation（NADA）[RFC8698]は、WebRTCの輻輳制御方式です。確認応答の受信時に参照レートr_refを計算し、参照レートに基づいて、ビデオのターゲットレートr_vinとフローの送信レートr_sendを計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When applying the FSE to NADA, the UPDATE function call described in Section 5.3 gives the FSE NADA&#39;s reference rate r_ref. The recommended algorithm for NADA is the Active FSE in Section 5.3.1. In step 3 (d), when the FSE_R(i) is &#34;sent&#34; to the flow i, r_ref (r_vin and r_send) of flow i is updated with the value of FSE_R(i).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FSEをNADAに適用する場合、セクション5.3で説明されているUPDATE関数呼び出しは、FSE NADAの参照レートr_refを提供します。 NADAの推奨アルゴリズムは、セクション5.3.1のアクティブFSEです。ステップ3（d）では、FSE_R（i）がフローiに「送信」されると、フローiのr_ref（r_vinおよびr_send）がFSE_R（i）の値で更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2--General-Recommendations">
6.2. General Recommendations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. 一般的な推奨事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides general advice for applying the FSE to congestion control mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、FSEを輻輳制御メカニズムに適用するための一般的なアドバイスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Receiver-side calculations: When receiver-side calculations make assumptions about the rate of the sender, the calculations need to be synchronized, or the receiver needs to be updated accordingly. This applies to TCP Friendly Rate Control (TFRC) [RFC5348], for example, where simulations showed somewhat less favorable results when using the FSE without a receiver-side change [FSE].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信者側の計算：受信者側の計算で送信者のレートを想定する場合、計算を同期させるか、受信者をそれに応じて更新する必要があります。これは、TCPフレンドリーレートコントロール（TFRC）[RFC5348]に適用されます。たとえば、受信者側の変更なしでFSEを使用すると、シミュレーションがやや不利な結果を示した[FSE]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateful algorithms: When a congestion control algorithm is stateful (e.g., during the TCP slow start, congestion avoidance, or fast recovery phase), these states should be carefully considered such that the overall state of the aggregate flow is correct. This may require sharing more information in the UPDATE call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステートフルアルゴリズム：輻輳制御アルゴリズムがステートフルである場合（TCPスロースタート、輻輳回避、高速リカバリフェーズなど）、これらの状態は、集約フローの全体的な状態が正しくなるように慎重に検討する必要があります。これには、UPDATE呼び出しでより多くの情報を共有する必要がある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rate jumps: The FSE-based coupling algorithms can let a flow quickly increase its rate to its fair share, e.g., when a new flow joins or after a quiescent period. In case of window-based congestion controls, this may produce a burst that should be mitigated in some way. An example of how this could be done without using a timer is presented in [ANRW2016], using TCP as an example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レートジャンプ：FSEベースのカップリングアルゴリズムを使用すると、フローは、たとえば新しいフローが加わったときや休止期間の後で、そのレートをフェアシェアにすばやく上げることができます。ウィンドウベースの輻輳制御の場合、これはバーストを生成する可能性があり、何らかの方法で軽減する必要があります。タイマーを使用せずにこれを行う方法の例は、TCPを例にして[ANRW2016]に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Expected-Feedback-from-Experiments">
7. Expected Feedback from Experiments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 実験からの予想されるフィードバック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm described in this memo has so far been evaluated using simulations covering all the tests for more than one flow from [RMCAT-PROPOSALS] (see [IETF-93] and [IETF-94]). Experiments should confirm these results using at least the NADA congestion control algorithm with real-life code (e.g., browsers communicating over an emulated network covering the conditions in [RMCAT-PROPOSALS]). The tests with real-life code should be repeated afterwards in real network environments and monitored. Experiments should investigate cases where the media coder&#39;s output rate is below the rate that is calculated by the coupling algorithm (FSE_R(i) in algorithms 1 (Section 5.3.1) and 2 (Section 5.3.2)). Implementers and testers are invited to document their findings in an Internet-Draft.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモで説明されているアルゴリズムは、これまでのところ[RMCAT-PROPOSALS]（[IETF-93]および[IETF-94]を参照）からの複数のフローに対するすべてのテストをカバーするシミュレーションを使用して評価されています。実験では、少なくとも実際のコードを使用したNADA輻輳制御アルゴリズムを使用してこれらの結果を確認する必要があります（たとえば、[RMCAT-PROPOSALS]の条件をカバーするエミュレートされたネットワークを介して通信するブラウザ）。その後、実際のコードを使用したテストを実際のネットワーク環境で繰り返し、監視する必要があります。実験では、メディアコーダーの出力レートが、結合アルゴリズム（アルゴリズム1（セクション5.3.1）および2（セクション5.3.2）のFSE_R（i））によって計算されたレートを下回るケースを調査する必要があります。実装者とテスターは、発見したことをインターネットドラフトに文書化することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--IANA-Considerations">
8. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. IANAに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document has no IANA actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントにはIANAアクションはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--Security-Considerations">
9. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In scenarios where the architecture described in this document is applied across applications, various cheating possibilities arise, e.g., supporting wrong values for the calculated rate, desired rate, or priority of a flow. In the worst case, such cheating could either prevent other flows from sending or make them send at a rate that is unreasonably large. The end result would be unfair behavior at the network bottleneck, akin to what could be achieved with any UDP-based application. Hence, since this is no worse than UDP in general, there seems to be no significant harm in using this in the absence of UDP rate limiters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで説明されているアーキテクチャがアプリケーション全体に適用されるシナリオでは、たとえば、フローの計算されたレート、望ましいレート、または優先度の誤った値をサポートするなど、さまざまな不正の可能性が発生します。最悪の場合、このような不正行為は、他のフローが送信できないようにするか、不当に大きいレートで送信する可能性があります。最終結果は、UDPベースのアプリケーションで実現できるものと同様に、ネットワークボトルネックでの不公平な動作になります。したがって、これは一般的にUDPよりも悪くないため、UDPレートリミッターがない場合にこれを使用しても、重大な害はないようです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of a single-user system, it should also be in the interest of any application programmer to give the user the best possible experience by using reasonable flow priorities or even letting the user choose them. In a multi-user system, this interest may not be given, and one could imagine the worst case of an &#34;arms race&#34; situation where applications end up setting their priorities to the maximum value. If all applications do this, the end result is a fair allocation in which the priority mechanism is implicitly eliminated and no major harm is done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シングルユーザーシステムの場合、適切なフローの優先順位を使用するか、ユーザーに選択させることで、ユーザーに最高のエクスペリエンスを提供することも、アプリケーションプログラマの利益になるはずです。マルチユーザーシステムでは、この関心は与えられない可能性があり、アプリケーションが優先度を最大値に設定してしまう「軍拡競争」状況の最悪のケースを想像できます。すべてのアプリケーションがこれを行う場合、最終的な結果は、優先メカニズムが暗黙的に排除され、大きな害が行われない公正な割り当てになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementers should also be aware of the Security Considerations sections of [RFC3124], [RFC5348], and [RFC7478].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装者は、[RFC3124]、[RFC5348]、および[RFC7478]のセキュリティに関する考慮事項のセクションにも注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--References">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-1--Normative-References">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;https://www.rfc-editor.org/info/ rfc2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3124] Balakrishnan, H. and S. Seshan, &#34;The Congestion Manager&#34;, RFC 3124, DOI 10.17487/RFC3124, June 2001, &lt;https://www.rfc-editor.org/info/rfc3124&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3124] Balakrishnan、H。およびS. Seshan、「The Congestion Manager」、RFC 3124、DOI 10.17487 / RFC3124、2001年6月、&lt;https://www.rfc-editor.org/info/rfc3124&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5348] Floyd, S., Handley, M., Padhye, J., and J. Widmer, &#34;TCP Friendly Rate Control (TFRC): Protocol Specification&#34;, RFC 5348, DOI 10.17487/RFC5348, September 2008, &lt;https://www.rfc-editor.org/info/rfc5348&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5348] Floyd、S.、Handley、M.、Padhye、J。、およびJ. Widmer、「TCP Friendly Rate Control（TFRC）：Protocol Specification」、RFC 5348、DOI 10.17487 / RFC5348、2008年9月、&lt;https： //www.rfc-editor.org/info/rfc5348&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、&lt;https://www.rfc-editor.org/info/ rfc8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8698] Zhu, X., Pan, R., Ramalho, M., and S. Mena, &#34;Network-Assisted Dynamic Adaptation (NADA): A Unified Congestion Control Scheme for Real-Time Media&#34;, RFC 8698, DOI 10.17487/RFC8698, January 2020, &lt;https://www.rfc-editor.org/info/rfc8698&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8698] Zhu、X.、Pan、R.、Ramalho、M。、およびS. Mena、「Network-Assisted Dynamic Adaptation（NADA）：A Unified Congestion Control Scheme for Real-Time Media」、RFC 8698、DOI 10.17487 / RFC8698、2020年1月、&lt;https://www.rfc-editor.org/info/rfc8698&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-2--Informative-References">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ANRW2016] Islam, S. and M. Welzl, &#34;Start Me Up: Determining and Sharing TCP&#39;s Initial Congestion Window&#34;, ACM, IRTF, ISOC Applied Networking Research Workshop 2016 (ANRW 2016), DOI 10.1145/2959424.2959440, Proceedings of the 2016 Applied Networking Research Workshop Pages 52-54, July 2016, &lt;https://doi.org/10.1145/2959424.2959440&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ANRW2016] Islam、S. and M. Welzl、 &#34;Start Me Up：Determining and Sharing TCP&#39;s Initial Congestion Window&#34;、ACM、IRTF、ISOC Applied Networking Research Workshop 2016（ANRW 2016）、DOI 10.1145 / 2959424.2959440、Proceedings of the 2016 Applied Networking Research Workshop Pages 52-54、July 2016、&lt;https://doi.org/10.1145/2959424.2959440&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FSE] Islam, S., Welzl, M., Gjessing, S., and N. Khademi, &#34;Coupled Congestion Control for RTP Media&#34;, ACM SIGCOMM Capacity Sharing Workshop (CSWS 2014) and ACM SIGCOMM CCR 44(4) 2014, March 2014, &lt;http://safiquli.at.ifi.uio.no/paper/fse-tech-report.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FSE] Islam、S.、Welzl、M.、Gjessing、S.、and N. Khademi、 &#34;Coupled Congestion Control for RTP Media&#34;、ACM SIGCOMM Capacity Sharing Workshop（CSWS 2014）and ACM SIGCOMM CCR 44（4）2014 、2014年3月、&lt;http://safiquli.at.ifi.uio.no/paper/fse-tech-report.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FSE-NOMS] Islam, S., Welzl, M., Hayes, D., and S. Gjessing, &#34;Managing real-time media flows through a flow state exchange&#34;, IEEE NOMS 2016, DOI 10.1109/NOMS.2016.7502803, &lt;https://doi.org/10.1109/NOMS.2016.7502803&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FSE-NOMS] Islam、S.、Welzl、M.、Hayes、D.、and S. Gjessing、 &#34;Managing real-time media flow through a flow state exchange&#34;、IEEE NOMS 2016、DOI 10.1109 / NOMS.2016.7502803、 &lt;https://doi.org/10.1109/NOMS.2016.7502803&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GCC-RTCWEB] Holmer, S., Lundin, H., Carlucci, G., Cicco, L., and S. Mascolo, &#34;A Google Congestion Control Algorithm for Real-Time Communication&#34;, Work in Progress, Internet-Draft, draft-ietf-rmcat-gcc-02, 8 July 2016, &lt;https://tools.ietf.org/html/draft-ietf-rmcat-gcc-02&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GCC-RTCWEB] Holmer、S.、Lundin、H.、Carlucci、G.、Cicco、L.、and S. Mascolo、 &#34;A Google Congestion Control Algorithm for Real-Time Communication&#34;、Work in Progress、Internet-Draft 、draft-ietf-rmcat-gcc-02、2016年7月8日、&lt;https://tools.ietf.org/html/draft-ietf-rmcat-gcc-02&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IETF-93] Islam, S., Welzl, M., and S. Gjessing, &#34;Updates on &#39;Coupled Congestion Control for RTP Media&#39;&#34;, RTP Media Congestion Avoidance Techniques (rmcat) Working Group, IETF 93, July 2015, &lt;https://www.ietf.org/proceedings/93/rmcat.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IETF-93] Islam、S.、Welzl、M.、and S. Gjessing、 &#34;Updates on &#39;Coupled Congestion Control for RTP Media&#39;、RTP Media Congestion Improvement Techniques（rmcat）Working Group、IETF 93、July 2015、 &lt;https://www.ietf.org/proceedings/93/rmcat.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IETF-94] Islam, S., Welzl, M., and S. Gjessing, &#34;Updates on &#39;Coupled Congestion Control for RTP Media&#39;&#34;, RTP Media Congestion Avoidance Techniques (rmcat) Working Group, IETF 94, November 2015, &lt;https://www.ietf.org/proceedings/94/rmcat.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IETF-94] Islam、S.、Welzl、M.、and S. Gjessing、 &#34;Updates on &#39;Coupled Congestion Control for RTP Media&#39;、RTP Media Congestion Improvement Techniques（rmcat）Working Group、IETF 94、November 2015、 &lt;https://www.ietf.org/proceedings/94/rmcat.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7478] Holmberg, C., Hakansson, S., and G. Eriksson, &#34;Web Real-Time Communication Use Cases and Requirements&#34;, RFC 7478, DOI 10.17487/RFC7478, March 2015, &lt;https://www.rfc-editor.org/info/rfc7478&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7478] Holmberg、C.、Hakansson、S。、およびG. Eriksson、「Web Real-Time Communication Use Cases and Requirements」、RFC 7478、DOI 10.17487 / RFC7478、2015年3月、&lt;https：//www.rfc- editor.org/info/rfc7478&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7656] Lennox, J., Gross, K., Nandakumar, S., Salgueiro, G., and B. Burman, Ed., &#34;A Taxonomy of Semantics and Mechanisms for Real-Time Transport Protocol (RTP) Sources&#34;, RFC 7656, DOI 10.17487/RFC7656, November 2015, &lt;https://www.rfc-editor.org/info/rfc7656&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7656] Lennox、J.、Gross、K.、Nandakumar、S.、Salgueiro、G。、およびB. Burman、編、「リアルタイムの転送プロトコル（RTP）ソースのセマンティクスとメカニズムの分類法」、 RFC 7656、DOI 10.17487 / RFC7656、2015年11月、&lt;https://www.rfc-editor.org/info/rfc7656&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8087] Fairhurst, G. and M. Welzl, &#34;The Benefits of Using Explicit Congestion Notification (ECN)&#34;, RFC 8087, DOI 10.17487/RFC8087, March 2017, &lt;https://www.rfc-editor.org/info/rfc8087&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8087] Fairhurst、G。、およびM. Welzl、「明示的な輻輳通知（ECN）を使用する利点」、RFC 8087、DOI 10.17487 / RFC8087、2017年3月、&lt;https://www.rfc-editor.org/info / rfc8087&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8382] Hayes, D., Ed., Ferlin, S., Welzl, M., and K. Hiorth, &#34;Shared Bottleneck Detection for Coupled Congestion Control for RTP Media&#34;, RFC 8382, DOI 10.17487/RFC8382, June 2018, &lt;https://www.rfc-editor.org/info/rfc8382&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8382] Hayes、D。、編、Ferlin、S.、Welzl、M。、およびK. Hiorth、「RTPメディアの結合輻輳制御のための共有ボトルネック検出」、RFC 8382、DOI 10.17487 / RFC8382、2018年6月、 &lt;https://www.rfc-editor.org/info/rfc8382&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RMCAT-PROPOSALS] Sarker, Z., Singh, V., Zhu, X., and M. Ramalho, &#34;Test Cases for Evaluating RMCAT Proposals&#34;, Work in Progress, Internet-Draft, draft-ietf-rmcat-eval-test-10, 23 May 2019, &lt;https://tools.ietf.org/html/draft-ietf-rmcat-eval-test-10&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RMCAT-PROPOSALS] Sarker、Z.、Singh、V.、Zhu、X。、およびM. Ramalho、「RMCATプロポーザルを評価するためのテストケース」、進行中の作業、インターネットドラフト、draft-ietf-rmcat-eval- test-10、2019年5月23日、&lt;https://tools.ietf.org/html/draft-ietf-rmcat-eval-test-10&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RTCWEB-OVERVIEW] Alvestrand, H., &#34;Overview: Real Time Protocols for Browser-based Applications&#34;, Work in Progress, Internet-Draft, draft-ietf-rtcweb-overview-19, 11 November 2017, &lt;https://tools.ietf.org/html/draft-ietf-rtcweb-overview-19&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RTCWEB-OVERVIEW] Alvestrand、H。、「Overview：Real Time Protocols for Browser-based Applications」、Work in Progress、Internet-Draft、draft-ietf-rtcweb-overview-19、11 November 2017、&lt;https：// tools.ietf.org/html/draft-ietf-rtcweb-overview-19&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RTCWEB-RTP-USAGE] Perkins, C., Westerlund, M., and J. Ott, &#34;Web Real-Time Communication (WebRTC): Media Transport and Use of RTP&#34;, Work in Progress, Internet-Draft, draft-ietf-rtcweb-rtp-usage-26, 17 March 2016, &lt;https://tools.ietf.org/html/ draft-ietf-rtcweb-rtp-usage-26&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RTCWEB-RTP-USAGE] Perkins、C.、Westerlund、M.、J。Ott、「Web Real-Time Communication（WebRTC）：Media Transport and Use of RTP」、Work in Progress、Internet-Draft、draft- ietf-rtcweb-rtp-usage-26、2016年3月17日、&lt;https://tools.ietf.org/html/draft-ietf-rtcweb-rtp-usage-26&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TRANSPORT-MULTIPLEX] Westerlund, M. and C. Perkins, &#34;Multiple RTP Sessions on a Single Lower-Layer Transport&#34;, Work in Progress, Internet-Draft, draft-westerlund-avtcore-transport-multiplexing-07, October 2013, &lt;https://tools.ietf.org/html/draft-westerlund-avtcore-transport-multiplexing-07&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TRANSPORT-MULTIPLEX] Westerlund、M。およびC. Perkins、「単一の下位層トランスポートでの複数のRTPセッション」、作業中、Internet-Draft、draft-westerlund-avtcore-transport-multiplexing-07、2013年10月、 &lt;https://tools.ietf.org/html/draft-westerlund-avtcore-transport-multiplexing-07&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[WEBRTC-TRANS] Alvestrand, H., &#34;Transports for WebRTC&#34;, Work in Progress, Internet-Draft, draft-ietf-rtcweb-transports-17, 26 October 2016, &lt;https://tools.ietf.org/html/draft-ietf-rtcweb-transports-17&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[WEBRTC-TRANS] Alvestrand、H。、「Transports for WebRTC」、Work in Progress、Internet-Draft、draft-ietf-rtcweb-transports-17、2016年10月26日、&lt;https://tools.ietf.org/html / draft-ietf-rtcweb-transports-17&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--Application-to-GCC">
Appendix A. Application to GCC
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A. GCCへの適用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Google Congestion Control (GCC) [GCC-RTCWEB] is another congestion control scheme for RTP flows that is under development. GCC is not yet finalized, but at the time of this writing, the rate control of GCC employs two parts: controlling the bandwidth estimate based on delay and controlling the bandwidth estimate based on loss. Both are designed to estimate the available bandwidth, A_hat.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Google輻輳制御（GCC）[GCC-RTCWEB]は、開発中のRTPフローのもう1つの輻輳制御方式です。 GCCはまだ確定されていませんが、この記事の執筆時点では、GCCのレート制御は、遅延に基づく帯域幅推定の制御と損失に基づく帯域幅推定の制御の2つの部分を採用しています。どちらも使用可能な帯域幅A_hatを推定するように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When applying the FSE to GCC, the UPDATE function call described in Section 5.3 gives the FSE GCC&#39;s estimate of available bandwidth A_hat. The recommended algorithm for GCC is the Active FSE in Section 5.3.1. In step 3 (d) of this algorithm, when the FSE_R(i) is &#34;sent&#34; to the flow i, A_hat of flow i is updated with the value of FSE_R(i).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FSEをGCCに適用する場合、セクション5.3で説明されているUPDATE関数呼び出しは、FSE GCCの使用可能な帯域幅の推定値A_hatを提供します。 GCCの推奨アルゴリズムは、セクション5.3.1のアクティブFSEです。このアルゴリズムのステップ3（d）では、FSE_R（i）がフローiに「送信」されると、フローiのA_hatがFSE_R（i）の値で更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-B--Scheduling">
Appendix B. Scheduling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録B.スケジュール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When flows originate from the same host, it would be possible to use only one sender-side congestion controller that determines the overall allowed sending rate and then use a local scheduler to assign a proportion of this rate to each RTP session. This way, priorities could also be implemented as a function of the scheduler. The Congestion Manager (CM) [RFC3124] also uses such a scheduling function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローが同じホストから発信された場合、許可される送信レート全体を決定する送信側の輻輳コントローラーを1つだけ使用し、ローカルスケジューラを使用してこのレートの比率を各RTPセッションに割り当てることができます。このように、優先度はスケジューラの機能として実装することもできます。 Congestion Manager（CM）[RFC3124]もこのようなスケジューリング機能を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-C--Example-Algorithm---Passive-FSE">
Appendix C. Example Algorithm - Passive FSE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録C.アルゴリズムの例-パッシブFSE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Active algorithms calculate the rates for all the flows in the FG and actively distribute them. In a passive algorithm, UPDATE returns a rate that should be used instead of the rate that the congestion controller has determined. This can make a passive algorithm easier to implement; however, when round-trip times of flows are unequal, flows with shorter RTTs may (depending on the congestion control algorithm) update and react to the overall FSE state more often than flows with longer RTTs, which can produce unwanted side effects. This problem is more significant when the congestion control convergence depends on the RTT. While the passive algorithm works better for congestion controls with RTT-independent convergence, it can still produce oscillations on short time scales. The algorithm described below is therefore considered highly experimental and not safe to deploy outside of testbed environments. Results of a simplified passive FSE algorithm with both NADA and GCC can be found in [FSE-NOMS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクティブアルゴリズムは、FG内のすべてのフローのレートを計算し、それらをアクティブに分散します。パッシブアルゴリズムでは、UPDATEは、輻輳コントローラーが決定したレートの代わりに使用する必要があるレートを返します。これにより、パッシブアルゴリズムの実装が容易になります。ただし、フローのラウンドトリップ時間が等しくない場合、RTTが短いフローは（輻輳制御アルゴリズムに応じて）、RTTが長いフローよりも頻繁に更新され、全体的なFSE状態に反応する可能性があります。これにより、不要な副作用が発生する可能性があります。この問題は、輻輳制御の収束がRTTに依存している場合により重要になります。パッシブアルゴリズムは、RTTに依存しない収束による輻輳制御に適していますが、短い時間スケールで振動を生成することもできます。したがって、以下で説明するアルゴリズムは非常に実験的であり、テストベッド環境の外に展開するのは安全ではないと見なされています。 NADAとGCCの両方を使用した単純化されたパッシブFSEアルゴリズムの結果は、[FSE-NOMS]にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the passive version of the FSE, TLO (Total Leftover Rate) is a static variable per FG that is initialized to 0. Additionally, S_CR is limited to increase or decrease as conservatively as a flow&#39;s congestion controller decides in order to prohibit sudden rate jumps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FSEのパッシブバージョンでは、TLO（Total Leftover Rate）はFGごとの静的変数であり、0に初期化されます。さらに、S_CRは、フローの輻輳コントローラーが突然のレートジャンプを禁止するために決定するのと同じくらい控えめに増減するように制限されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) When a flow f starts, it registers itself with SBD and the FSE. FSE_R(f) and DR(f) are initialized with the congestion controller&#39;s initial rate. SBD will assign the correct FGI. When a flow is assigned an FGI, it adds its FSE_R(f) to S_CR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（1）フローfが開始されると、フロー自体がSBDおよびFSEに登録されます。 FSE_R（f）とDR（f）は、輻輳コントローラーの初期レートで初期化されます。 SBDは正しいFGIを割り当てます。フローにFGIが割り当てられると、フローはそのFSE_R（f）をS_CRに追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) When a flow f stops or pauses, it sets its DR(f) to 0 and sets P(f) to -1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（2）フローfは、停止または一時停止すると、そのDR（f）を0に設定し、P（f）を-1に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) Every time the congestion controller of the flow f determines a new sending rate CC_R(f), assuming the flow&#39;s new desired rate new_DR(f) to be &#34;infinity&#34; in case of a bulk data transfer with an unknown maximum rate, the flow calls UPDATE, which carries out the tasks listed below to derive the flow&#39;s new sending rate, Rate(f). A flow&#39;s UPDATE function uses a few local (i.e., per-flow) temporary variables, which are all initialized to 0: DELTA, new_S_CR, and S_P.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3）フローfの輻輳コントローラーが新しい送信レートCC_R（f）を決定するたびに、最大レートが不明なバルクデータ転送の場合にフローの新しい希望レートnew_DR（f）が「無限大」であると想定し、フローはUPDATEを呼び出します。UPDATEは以下にリストされているタスクを実行して、フローの新しい送信レートであるRate（f）を導出します。フローのUPDATE関数は、いくつかのローカル（フローごと）一時変数を使用します。これらはすべて0に初期化されます：DELTA、new_S_CR、およびS_P。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
(a) For all the flows in its FG (including itself), it calculates the sum of all the calculated rates, new_S_CR. Then, it calculates DELTA: the difference between FSE_R(f) and CC_R(f).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
（a）FG内のすべてのフロー（自身を含む）について、計算されたすべてのレートの合計new_S_CRを計算します。次に、FSE_R（f）とCC_R（f）の差であるDELTAを計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                     for all flows i in FG do
                         new_S_CR = new_S_CR + FSE_R(i)
                     end for
                     DELTA =  CC_R(f) - FSE_R(f)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
(b) It updates S_CR, FSE_R(f), and DR(f).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
（b）S_CR、FSE_R（f）、およびDR（f）を更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                     FSE_R(f) = CC_R(f)
                     if DELTA &gt; 0 then  // the flow&#39;s rate has increased
                         S_CR = S_CR + DELTA
                     else if DELTA &lt; 0 then
                         S_CR = new_S_CR + DELTA
                     end if
                     DR(f) = min(new_DR(f),FSE_R(f))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
(c) It calculates the leftover rate TLO, removes the terminated flows from the FSE, and calculates the sum of all the priorities, S_P.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
（c）残存率TLOを計算し、終了したフローをFSEから削除し、すべての優先度の合計S_Pを計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       for all flows i in FG do
                          if P(i)&lt;0 then
                             delete flow
                          else
                             S_P = S_P + P(i)
                          end if
                       end for
                       if DR(f) &lt; FSE_R(f) then
                          TLO = TLO + (P(f)/S_P) * S_CR - DR(f))
                       end if
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
(d) It calculates the sending rate, Rate(f).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
（d）送信レート、Rate（f）を計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       Rate(f) = min(new_DR(f), (P(f)*S_CR)/S_P + TLO)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       if Rate(f) != new_DR(f) and TLO &gt; 0 then
                           TLO = 0  // f has &#39;taken&#39; TLO
                       end if
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
(e) It updates DR(f) and FSE_R(f) with Rate(f).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
（e）DR（f）およびFSE_R（f）をRate（f）で更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       if Rate(f) &gt; DR(f) then
                           DR(f) = Rate(f)
                       end if
                       FSE_R(f)  = Rate(f)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goals of the flow algorithm are to achieve prioritization, improve network utilization in the face of application-limited flows, and impose limits on the increase behavior such that the negative impact of multiple flows trying to increase their rate together is minimized. It does that by assigning a flow a sending rate that may not be what the flow&#39;s congestion controller expected. It therefore builds on the assumption that no significant inefficiencies arise from temporary application-limited behavior or from quickly jumping to a rate that is higher than the congestion controller intended. How problematic these issues really are depends on the controllers in use and requires careful per-controller experimentation. The coupled congestion control mechanism described here also does not require all controllers to be equal; effects of heterogeneous controllers, or homogeneous controllers being in different states, are also subject to experimentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローアルゴリズムの目的は、優先順位付けを実現し、アプリケーションが制限されたフローに直面してネットワーク使用率を改善し、増加動作に制限を課して、複数のフローが一緒にレートを増加させようとする悪影響を最小限に抑えることです。これは、フローの輻輳コントローラが期待したものとは異なる送信レートをフローに割り当てることによって行われます。したがって、一時的なアプリケーション制限の動作から、または輻輳コントローラーが意図したよりも高いレートに素早くジャンプすることによって、重大な非効率が発生しないという仮定に基づいています。これらの問題の実際の問題の程度は、使用しているコントローラーによって異なり、コントローラーごとに注意深く実験する必要があります。ここで説明する結合された輻輳制御メカニズムでも、すべてのコントローラーが同じである必要はありません。異種コントローラ、または異なる状態にある同種コントローラの影響も実験の対象となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This algorithm gives the leftover rate of application-limited flows to the first flow that updates its sending rate, provided that this flow needs it all (otherwise, its own leftover rate can be taken by the next flow that updates its rate). Other policies could be applied, e.g., to divide the leftover rate of a flow equally among all other flows in the FGI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムは、アプリケーションが制限するフローの残りのレートを、送信レートを更新する最初のフローに提供します。ただし、このフローがすべてを必要とする場合（そうでない場合、独自の残りのレートは、レートを更新する次のフローで使用できます）。他のポリシーを適用して、たとえば、フローの残りのレートをFGI内の他のすべてのフロー間で均等に分割することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="C-1--Example-Operation-Passive">
C.1. Example Operation (Passive)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
C.1. 操作例（パッシブ）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to illustrate the operation of the passive coupled congestion control algorithm, this section presents a toy example of two flows that use it. Let us assume that both flows traverse a common 10 Mbit/s bottleneck and use a simplistic congestion controller that starts out with 1 Mbit/s, increases its rate by 1 Mbit/s in the absence of congestion, and decreases it by 2 Mbit/s in the presence of congestion. For simplicity, flows are assumed to always operate in a round-robin fashion. Rate numbers below without units are assumed to be in Mbit/s. For illustration purposes, the actual sending rate is also shown for every flow in FSE diagrams even though it is not really stored in the FSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パッシブ結合輻輳制御アルゴリズムの動作を説明するために、このセクションでは、それを使用する2つのフローのおもちゃの例を示します。両方のフローが共通の10メガビット/秒のボトルネックを通過し、1メガビット/秒で開始し、輻輳がない場合はレートを1メガビット/秒増加させ、2メガビット/秒減少させる単純な輻輳コントローラーを使用するとします。 s混雑が存在する場合。簡単にするために、フローは常にラウンドロビン方式で動作すると想定されています。単位のない以下のレート番号はMbit / sであると想定されています。説明のために、実際の送信レートは実際にはFSEに格納されていなくても、FSE図のすべてのフローについても示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow #1 begins. It is a bulk data transfer and considers itself to have top priority. This is the FSE after the flow algorithm&#39;s step 1:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー＃1が始まります。これはバルクデータ転送であり、自分自身を最優先と見なします。これは、フローアルゴリズムのステップ1の後のFSEです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ----------------------------------------
   | # | FGI |  P  | FSE_R  |  DR  | Rate |
   |   |     |     |        |      |      |
   | 1 |  1  |  1  |   1    |   1  |   1  |
   ----------------------------------------
   S_CR = 1, TLO = 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Its congestion controller gradually increases its rate. Eventually, at some point, the FSE should look like this:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その輻輳コントローラーは徐々に速度を上げます。最終的に、ある時点で、FSEは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   -----------------------------------------
   | # | FGI |  P  |  FSE_R  |  DR  | Rate |
   |   |     |     |         |      |      |
   | 1 |  1  |  1  |   10    |  10  |  10  |
   -----------------------------------------
   S_CR = 10, TLO = 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now, another flow joins. It is also a bulk data transfer and has a lower priority (0.5):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これで、別のフローが参加します。これはバルクデータ転送でもあり、優先度は低くなります（0.5）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ------------------------------------------
   | # | FGI |   P   | FSE_R  |  DR  | Rate |
   |   |     |       |        |      |      |
   | 1 |  1  |   1   |   10   |  10  |  10  |
   | 2 |  1  |  0.5  |    1   |   1  |   1  |
   ------------------------------------------
   S_CR = 11, TLO = 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now, assume that the first flow updates its rate to 8, because the total sending rate of 11 exceeds the total capacity. Let us take a closer look at what happens in step 3 of the flow algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、11の合計送信レートが合計容量を超えるため、最初のフローがレートを8に更新するとします。フローアルゴリズムのステップ3で何が起こるかを詳しく見てみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CC_R(1) = 8. new_DR(1) = infinity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CC_R（1）=8。new_DR（1）=無限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3a) new_S_CR = 11; DELTA = 8 - 10 = -2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3a）new_S_CR = 11; DELTA = 8-10 = -2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   (3b)  FSE_R(1) = 8.  DELTA is negative, hence S_CR = 9; DR(1) = 8
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3c) S_P = 1.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3c）S_P = 1.5。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3d) new sending rate Rate(1) = min(infinity, 1/1.5 * 9 + 0) = 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3d）新しい送信レートRate（1）= min（infinity、1 / 1.5 * 9 + 0）= 6。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3e) FSE_R(1) = 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3e）FSE_R（1）= 6。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resulting FSE looks as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果のFSEは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   -------------------------------------------
   | # | FGI |   P   |  FSE_R  |  DR  | Rate |
   |   |     |       |         |      |      |
   | 1 |  1  |   1   |    6    |   8  |   6  |
   | 2 |  1  |  0.5  |    1    |   1  |   1  |
   -------------------------------------------
   S_CR = 9, TLO = 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The effect is that flow #1 is sending with 6 Mbit/s instead of the 8 Mbit/s that the congestion controller derived. Let us now assume that flow #2 updates its rate. Its congestion controller detects that the network is not fully saturated (the actual total sending rate is 6+1=7) and increases its rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その結果、フロー＃1は、輻輳コントローラーが導出した8 Mbit / sではなく、6 Mbit / sで送信しています。フロー＃2がレートを更新すると仮定します。その輻輳コントローラーは、ネットワークが完全に飽和していないことを検出し（実際の総送信速度は6 + 1 = 7）、その速度を上げます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CC_R(2) = 2. new_DR(2) = infinity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CC_R（2）=2。new_DR（2）=無限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3a) new_S_CR = 7; DELTA = 2 - 1 = 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3a）new_S_CR = 7; DELTA = 2-1 = 1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3b) FSE_R(2) = 2. DELTA is positive, hence S_CR = 9 + 1 = 10; DR(2) = 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3b）FSE_R（2）= 2. DELTAは正なので、S_CR = 9 + 1 = 10; DR（2）= 2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3c) S_P = 1.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3c）S_P = 1.5。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3d) Rate(2) = min(infinity, 0.5/1.5 * 10 + 0) = 3.33.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3d）レート（2）=最小（無限大、0.5 / 1.5 * 10 + 0）= 3.33。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3e) DR(2) = FSE_R(2) = 3.33.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3e）DR（2）= FSE_R（2）= 3.33。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resulting FSE looks as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果のFSEは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   -------------------------------------------
   | # | FGI |   P   |  FSE_R  |  DR  | Rate |
   |   |     |       |         |      |      |
   | 1 |  1  |   1   |    6    |   8  |   6  |
   | 2 |  1  |  0.5  |   3.33  | 3.33 | 3.33 |
   -------------------------------------------
   S_CR = 10, TLO = 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The effect is that flow #2 is now sending with 3.33 Mbit/s, which is close to half of the rate of flow #1 and leads to a total utilization of 6(#1) + 3.33(#2) = 9.33 Mbit/s. Flow #2&#39;s congestion controller has increased its rate faster than the controller actually expected. Now, flow #1 updates its rate. Its congestion controller detects that the network is not fully saturated and increases its rate. Additionally, the application feeding into flow #1 limits the flow&#39;s sending rate to at most 2 Mbit/s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
効果は、フロー＃2が3.33 Mbit / sで送信していることです。これは、フロー＃1のレートの半分に近く、合計使用率は6（＃1）+ 3.33（＃2）= 9.33 Mbit /になります。 s。フロー＃2の輻輳コントローラーは、コントローラーが実際に予想したよりも速く速度を上げました。これで、フロー＃1がレートを更新します。その輻輳コントローラーは、ネットワークが完全に飽和していないことを検出し、その速度を上げます。さらに、フロー＃1にフィードするアプリケーションは、フローの送信速度を最大2 Mbit / sに制限します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CC_R(1) = 7. new_DR(1) = 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CC_R（1）= 7. new_DR（1）= 2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3a) new_S_CR = 9.33; DELTA = 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3a）new_S_CR = 9.33; DELTA = 1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3b) FSE_R(1) = 7, DELTA is positive, hence S_CR = 10 + 1 = 11; DR(1) = min(2, 7) = 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3b）FSE_R（1）= 7、DELTAは正であるため、S_CR = 10 + 1 = 11; DR（1）= min（2、7）= 2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3c) S_P = 1.5; DR(1) &lt; FSE_R(1), hence TLO = 1/1.5 * 11 - 2 = 5.33.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3c）S_P = 1.5; DR（1）&lt;FSE_R（1）、したがってTLO = 1 / 1.5 * 11-2 = 5.33。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3d) Rate(1) = min(2, 1/1.5 * 11 + 5.33) = 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3d）レート（1）= min（2、1 / 1.5 * 11 + 5.33）= 2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3e) FSE_R(1) = 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3e）FSE_R（1）= 2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resulting FSE looks as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果のFSEは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   -------------------------------------------
   | # | FGI |   P   |  FSE_R  |  DR  | Rate |
   |   |     |       |         |      |      |
   | 1 |  1  |   1   |    2    |   2  |   2  |
   | 2 |  1  |  0.5  |   3.33  | 3.33 | 3.33 |
   -------------------------------------------
   S_CR = 11, TLO = 5.33
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now, the total rate of the two flows is 2 + 3.33 = 5.33 Mbit/s, i.e., the network is significantly underutilized due to the limitation of flow #1. Flow #2 updates its rate. Its congestion controller detects that the network is not fully saturated and increases its rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在、2つのフローの合計レートは2 + 3.33 = 5.33 Mbit / sです。つまり、フロー＃1の制限により、ネットワークは十分に活用されていません。フロー＃2はレートを更新します。その輻輳コントローラーは、ネットワークが完全に飽和していないことを検出し、その速度を上げます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CC_R(2) = 4.33. new_DR(2) = infinity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CC_R（2）= 4.33。 new_DR（2）=無限大。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3a) new_S_CR = 5.33; DELTA = 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3a）new_S_CR = 5.33; DELTA = 1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3b) FSE_R(2) = 4.33. DELTA is positive, hence S_CR = 12; DR(2) = 4.33.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3b）FSE_R（2）= 4.33。 DELTAは正なので、S_CR = 12です。 DR（2）= 4.33。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3c) S_P = 1.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3c）S_P = 1.5。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3d) Rate(2) = min(infinity, 0.5/1.5 * 12 + 5.33 ) = 9.33.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3d）Rate（2）= min（infinity、0.5 / 1.5 * 12 + 5.33）= 9.33。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3e) FSE_R(2) = 9.33, DR(2) = 9.33.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3e）FSE_R（2）= 9.33、DR（2）= 9.33。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resulting FSE looks as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果のFSEは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   -------------------------------------------
   | # | FGI |   P   |  FSE_R  |  DR  | Rate |
   |   |     |       |         |      |      |
   | 1 |  1  |   1   |    2    |   2  |   2  |
   | 2 |  1  |  0.5  |   9.33  | 9.33 | 9.33 |
   -------------------------------------------
   S_CR = 12, TLO = 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now, the total rate of the two flows is 2 + 9.33 = 11.33 Mbit/s. Finally, flow #1 terminates. It sets P(1) to -1 and DR(1) to 0. Let us assume that it terminated late enough for flow #2 to still experience the network in a congested state, i.e., flow #2 decreases its rate in the next iteration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在、2つのフローの合計レートは2 + 9.33 = 11.33 Mbit / sです。最後に、フロー＃1が終了します。 P（1）を-1に設定し、DR（1）を0に設定します。フロー＃2がネットワークを引き続き輻輳状態にするのに十分なほど遅く終了したと仮定します。反復。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CC_R(2) = 7.33. new_DR(2) = infinity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CC_R（2）= 7.33。 new_DR（2）=無限大。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3a) new_S_CR = 11.33; DELTA = -2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3a）new_S_CR = 11.33; DELTA = -2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3b) FSE_R(2) = 7.33. DELTA is negative, hence S_CR = 9.33; DR(2) = 7.33.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3b）FSE_R（2）= 7.33。 DELTAは負なので、S_CR = 9.33; DR（2）= 7.33。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3c) Flow 1 has P(1) = -1, hence it is deleted from the FSE. S_P = 0.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3c）フロー1にはP（1）= -1があるため、FSEから削除されます。 S_P = 0.5。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3d) Rate(2) = min(infinity, 0.5/0.5*9.33 + 0) = 9.33.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3d）レート（2）=最小（無限大、0.5 / 0.5 * 9.33 + 0）= 9.33。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3e) FSE_R(2) = DR(2) = 9.33.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3e）FSE_R（2）= DR（2）= 9.33。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resulting FSE looks as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果のFSEは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   -------------------------------------------
   | # | FGI |   P   |  FSE_R  |  DR  | Rate |
   |   |     |       |         |      |      |
   | 2 |  1  |  0.5  |   9.33  | 9.33 | 9.33 |
   -------------------------------------------
   S_CR = 9.33, TLO = 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document benefited from discussions with and feedback from Andreas Petlund, Anna Brunstrom, Colin Perkins, David Hayes, David Ros (who also gave the FSE its name), Ingemar Johansson, Karen Nielsen, Kristian Hiorth, Martin Stiemerling, Mirja Kühlewind, Spencer Dawkins, Varun Singh, Xiaoqing Zhu, and Zaheduzzaman Sarker. The authors would like to especially thank Xiaoqing Zhu and Stefan Holmer for helping with NADA and GCC, and Anna Brunstrom as well as Julius Flohr for helping us correct the active algorithm for the case of application-limited flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、Andreas Petlund、Anna Brunstrom、Colin Perkins、David Hayes、David Ros（FSEにもその名前を付けた）、Ingemar Johansson、Karen Nielsen、Kristian Hiorth、Martin Stiemerling、MirjaKühlewind、Spencer Dawkinsとのディスカッションとフィードバックから利益を得ました、Varun Singh、Xiaoqing Zhu、Zaheduzzaman Sarker。著者は、NADAとGCCを支援してくれたXiaoqing ZhuとStefan Holmer、アプリケーションが限定されたフローの場合のアクティブアルゴリズムを修正してくれたAnna BrunstromとJulius Flohrに特に感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This work was partially funded by the European Community under its Seventh Framework Program through the Reducing Internet Transport Latency (RITE) project (ICT-317700).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この作業は、第7フレームワークプログラムに基づいて、インターネットトランスポートレイテンシの削減（RITE）プロジェクト（ICT-317700）を通じて、欧州共同体によって部分的に資金提供されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Safiqul Islam University of Oslo PO Box 1080 Blindern N-0316 Oslo Norway
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Safiqul Islam University of Oslo PO Box 1080 Blindern N-0316オスロノルウェー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +47 22 84 08 37
   Email: safiquli@ifi.uio.no
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Michael Welzl University of Oslo PO Box 1080 Blindern N-0316 Oslo Norway
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイケルウェルズル大学オスロ私書箱1080ブリンデンN-0316オスロノルウェー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +47 22 85 24 20
   Email: michawe@ifi.uio.no
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stein Gjessing University of Oslo PO Box 1080 Blindern N-0316 Oslo Norway
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スタインジェシン大学オスロ私書箱1080 Blindern N-0316オスロノルウェー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +47 22 85 24 44
   Email: steing@ifi.uio.no
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
