<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 8033 - Proportional Integral Controller Enhanced (PIE): A Lightweight Control Scheme to Address the Bufferbloat Problem 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">8033</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc8033">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 8033 - Proportional Integral Controller Enhanced (PIE): A Lightweight Control Scheme to Address the Bufferbloat Problem 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc8033">
            https://datatracker.ietf.org/doc/html/rfc8033
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 8033 - プロポーショナルインテグラルコントローラーエンハンスド（PIE）：Bufferbloat問題に対処するための軽量制御スキーム</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                            R. Pan
Request for Comments: 8033                                  P. Natarajan
Category: Experimental                                     Cisco Systems
ISSN: 2070-1721                                                 F. Baker
                                                            Unaffiliated
                                                                G. White
                                                               CableLabs
                                                           February 2017
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 Proportional Integral Controller Enhanced (PIE): A Lightweight Control Scheme to Address the Bufferbloat Problem
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
プロポーショナルインテグラルコントローラーエンハンスド（PIE）：Bufferbloat問題に対処するための軽量制御スキーム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bufferbloat is a phenomenon in which excess buffers in the network cause high latency and latency variation. As more and more interactive applications (e.g., voice over IP, real-time video streaming, and financial transactions) run in the Internet, high latency and latency variation degrade application performance. There is a pressing need to design intelligent queue management schemes that can control latency and latency variation, and hence provide desirable quality of service to users.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bufferbloatは、ネットワーク内の過剰なバッファーが原因で、レイテンシとレイテンシの変動が大きくなる現象です。インタラクティブアプリケーション（Voi​​ce over IP、リアルタイムビデオストリーミング、金融取引など）がインターネットで実行されるにつれ、レイテンシとレイテンシの変動が大きくなり、アプリケーションのパフォーマンスが低下します。レイテンシとレイテンシの変動を制御できるインテリジェントなキュー管理スキームを設計し、それによってユーザーに望ましいサービス品質を提供することが急務です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document presents a lightweight active queue management design called &#34;PIE&#34; (Proportional Integral controller Enhanced) that can effectively control the average queuing latency to a target value. Simulation results, theoretical analysis, and Linux testbed results have shown that PIE can ensure low latency and achieve high link utilization under various congestion situations. The design does not require per-packet timestamps, so it incurs very little overhead and is simple enough to implement in both hardware and software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、「PIE」（Proportional Integral Controller Enhanced）と呼ばれる軽量のアクティブキュー管理設計を紹介します。これにより、平均キューレイテンシを目標値まで効果的に制御できます。シミュレーション結果、理論的分析、およびLinuxテストベッドの結果は、PIEがさまざまな輻輳状況下で低遅延を保証し、高いリンク使用率を達成できることを示しています。この設計はパケットごとのタイムスタンプを必要としないため、オーバーヘッドはほとんど発生せず、ハードウェアとソフトウェアの両方に実装できるほど単純です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはInternet Standards Trackの仕様ではありません。試験、実験、評価のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、インターネットコミュニティの実験プロトコルを定義します。このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。 IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補になるわけではありません。 RFC 7841のセクション2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8033.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc8033で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2017 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................3
   2. Terminology .....................................................5
   3. Design Goals ....................................................5
   4. The Basic PIE Scheme ............................................6
      4.1. Random Dropping ............................................7
      4.2. Drop Probability Calculation ...............................7
      4.3. Latency Calculation ........................................9
      4.4. Burst Tolerance ...........................................10
   5. Optional Design Elements of PIE ................................11
      5.1. ECN Support ...............................................11
      5.2. Dequeue Rate Estimation ...................................11
      5.3. Setting PIE Active and Inactive ...........................13
      5.4. Derandomization ...........................................14
      5.5. Cap Drop Adjustment .......................................15
   6. Implementation Cost ............................................15
   7. Scope of Experimentation .......................................17
   8. Incremental Deployment .........................................17
   9. Security Considerations ........................................18
   10. References ....................................................18
      10.1. Normative References .....................................18
      10.2. Informative References ...................................18
   Appendix A. The Basic PIE Pseudocode ..............................21
   Appendix B. Pseudocode for PIE with Optional Enhancement ..........24
   Contributors ......................................................29
   Authors&#39; Addresses ................................................30
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The explosion of smart phones, tablets, and video traffic in the Internet brings about a unique set of challenges for congestion control. To avoid packet drops, many service providers or data-center operators require vendors to put in as much buffer as possible. Because of the rapid decrease in memory chip prices, these requests are easily accommodated to keep customers happy. While this solution succeeds in assuring low packet loss and high TCP throughput, it suffers from a major downside. TCP continuously increases its sending rate and causes network buffers to fill up. TCP cuts its rate only when it receives a packet drop or mark that is interpreted as a congestion signal. However, drops and marks usually occur when network buffers are full or almost full. As a result, excess buffers, initially designed to avoid packet drops, would lead to highly elevated queuing latency and latency variation. Designing a queue management scheme is a delicate balancing act: it not only should allow short-term bursts to smoothly pass but also should control the average latency in the presence of long-running greedy flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スマートフォン、タブレット、およびインターネットでのビデオトラフィックの爆発的な増加は、輻輳制御に固有の一連の課題をもたらします。パケットドロップを回避するために、多くのサービスプロバイダーまたはデータセンターオペレーターは、ベンダーにできるだけ多くのバッファーを配置するように要求しています。メモリチップの価格が急速に下がっているので、これらの要求は顧客を満足させるために簡単に対応できます。このソリューションは、パケット損失を少なくし、TCPスループットを高くすることに成功していますが、大きな欠点があります。 TCPは送信レートを継続的に増加させ、ネットワークバッファをいっぱいにします。 TCPは、輻輳信号として解釈されるパケットドロップまたはマークを受信した場合にのみ、レートを削減します。ただし、ドロップとマークは通常、ネットワークバッファがいっぱいまたはほとんどいっぱいのときに発生します。その結果、最初はパケットのドロップを回避するように設計された過剰なバッファが原因で、キューの待機時間と待機時間の変動が非常に高くなります。キュー管理スキームの設計は、微妙なバランスをとる行為です。短期バーストをスムーズに通過させるだけでなく、長時間実行される貪欲なフローが存在する場合の平均レイテンシも制御する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Active Queue Management (AQM) schemes could potentially solve the aforementioned problem. AQM schemes, such as Random Early Detection (RED) [RED] as suggested in [RFC2309] (which is now obsoleted by [RFC7567]), have been around for well over a decade. RED is implemented in a wide variety of network devices, both in hardware and software. Unfortunately, due to the fact that RED needs careful tuning of its parameters for various network conditions, most network operators don&#39;t turn RED on. In addition, RED is designed to control the queue length, which would affect latency implicitly. It does not control latency directly. Hence, the Internet today still lacks an effective design that can control buffer latency to improve the quality of experience to latency-sensitive applications. The more recently published RFC 7567 calls for new methods of controlling network latency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクティブキュー管理（AQM）スキームは、前述の問題を解決できる可能性があります。 [RFC2309]（[RFC7567]で廃止された）で提案されているランダム早期検出（RED）[RED]などのAQMスキームは、10年以上前から存在しています。 REDは、ハードウェアとソフトウェアの両方で、さまざまなネットワークデバイスに実装されています。残念ながら、REDはさまざまなネットワーク条件に合わせてパラメーターを注意深く調整する必要があるため、ほとんどのネットワークオペレーターはREDをオンにしません。さらに、REDはキューの長さを制御するように設計されています。これは暗黙的にレイテンシに影響します。レイテンシを直接制御することはありません。したがって、今日のインターネットには、遅延の影響を受けやすいアプリケーションのエクスペリエンス品質を向上させるためにバッファの遅延を制御できる効果的な設計がまだありません。最近公開されたRFC 7567では、ネットワーク遅延を制御する新しい方法が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
New algorithms are beginning to emerge to control queuing latency directly to address the bufferbloat problem [CoDel]. Along these lines, Proportional Integral controller Enhanced (PIE) also aims to keep the benefits of RED, including easy implementation and scalability to high speeds. Similar to RED, PIE randomly drops an incoming packet at the onset of congestion. Congestion detection, however, is based on the queuing latency instead of the queue length (as with RED). Furthermore, PIE also uses the derivative (rate of change) of the queuing latency to help determine congestion levels and an appropriate response. The design parameters of PIE are chosen via control theory stability analysis. While these parameters can be fixed to work in various traffic conditions, they could be made self-tuning to optimize system performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいアルゴリズムが登場し、キューイングレイテンシを直接制御して、バッファブロート問題に対処します[CoDel]。これらの方針に沿って、プロポーショナルインテグラルコントローラーエンハンスド（PIE）は、簡単な実装や高速へのスケーラビリティなど、REDの利点を維持することも目的としています。 REDと同様に、PIEは輻輳の開始時に着信パケットをランダムにドロップします。ただし、輻輳検出は、キューの長さ（REDと同様）ではなく、キューの待機時間に基づいています。さらに、PIEはキューイングレイテンシの導関数（変化率）も使用して、輻輳レベルと適切な応答を決定します。 PIEの設計パラメータは、制御理論の安定性解析によって選択されます。これらのパラメータは、さまざまな交通状況で機能するように修正できますが、システムパフォーマンスを最適化するために自己調整することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Separately, it is assumed that any latency-based AQM scheme would be applied over a Fair Queuing (FQ) structure or one of its approximate designs, Flow Queuing or Class-Based Queuing (CBQ). FQ is one of the most studied scheduling algorithms since it was first proposed in 1985 [RFC970]. CBQ has been a standard feature in most network devices today [CBQ]. Any AQM scheme that is built on top of FQ or CBQ could benefit from these advantages. Furthermore, these advantages, such as per-flow or per-class fairness, are orthogonal to the AQM design whose primary goal is to control latency for a given queue. For flows that are classified into the same class and put into the same queue, one needs to ensure that their latency is better controlled and that their fairness is not worse than those under the standard DropTail or RED design. More details about the relationship between FQ and AQM can be found in [RFC7806].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これとは別に、レイテンシベースのAQMスキームは、フェアキューイング（FQ）構造またはその近似設計の1つであるフローキューイングまたはクラスベースキューイング（CBQ）に適用されると想定されています。 FQは、1985年に最初に提案されて以来、最も研究されているスケジューリングアルゴリズムの1つです[RFC970]。 CBQは、今日のほとんどのネットワークデバイスの標準機能です[CBQ]。 FQまたはCBQの上に構築されたAQMスキームはすべて、これらの利点の恩恵を受けることができます。さらに、フローごとやクラスごとの公平性などのこれらの利点は、特定のキューのレイテンシを制御することを主な目的とするAQM設計に直交しています。同じクラスに分類され、同じキューに入れられるフローの場合、レイテンシがより適切に制御され、公平性が標準のDropTailまたはRED設計のフローよりも悪くないことを確認する必要があります。 FQとAQMの関係の詳細については、[RFC7806]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In October 2013, CableLabs&#39; Data-Over-Cable Service Interface Specification 3.1 (DOCSIS 3.1) specification [DOCSIS_3.1] mandated that cable modems implement a specific variant of the PIE design as the active queue management algorithm. In addition to cable-specific improvements, the PIE design in DOCSIS 3.1 [RFC8034] has improved the original design in several areas, including derandomization of coin tosses and enhanced burst protection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2013年10月、CableLabsのData-Over-Cable Service Interface Specification 3.1（DOCSIS 3.1）仕様[DOCSIS_3.1]は、ケーブルモデムがPIE設計の特定のバリアントをアクティブキュー管理アルゴリズムとして実装することを義務付けました。ケーブル固有の改善に加えて、DOCSIS 3.1 [RFC8034]のPIE設計は、コイントスの非ランダム化や強化されたバースト保護など、いくつかの領域で元の設計を改善しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes the design of PIE and separates it into basic elements and optional components that may be implemented to enhance the performance of PIE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、PIEの設計について説明し、PIEのパフォーマンスを向上させるために実装できる基本要素とオプションコンポーネントに分けています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Terminology">
2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [RFC2119]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Design-Goals">
3. Design Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 設計目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A queue management framework is designed to improve the performance of interactive and latency-sensitive applications. It should follow the general guidelines set by the AQM working group document &#34;IETF Recommendations Regarding Active Queue Management&#34; [RFC7567]. More specifically, the PIE design has the following basic criteria.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キュー管理フレームワークは、対話型で遅延の影響を受けやすいアプリケーションのパフォーマンスを向上させるように設計されています。これは、AQMワーキンググループドキュメント「アクティブキュー管理に関するIETFの推奨事項」[RFC7567]で設定された一般的なガイドラインに従う必要があります。具体的には、PIE設計には次の基本的な基準があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* First, queuing latency, instead of queue length, is controlled. Queue sizes change with queue draining rates and various flows&#39; round-trip times. Latency bloat is the real issue that needs to be addressed, as it impairs real-time applications. If latency can be controlled, bufferbloat is not an issue. In fact, once latency is under control, it frees up buffers for sporadic bursts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* まず、キューの長さではなく、キューの待機時間が制御されます。キューのサイズは、キューの排出速度とさまざまなフローの往復時間によって変化します。レイテンシー膨張は、リアルタイムアプリケーションを損なうため、対処する必要のある実際の問題です。レイテンシを制御できれば、バッファブロートは問題になりません。実際、レイテンシが制御下になると、散発的なバーストのためにバッファが解放されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Secondly, PIE aims to attain high link utilization. The goal of low latency shall be achieved without suffering link underutilization or losing network efficiency. An early congestion signal could cause TCP to back off and avoid queue buildup. On the other hand, however, TCP&#39;s rate reduction could result in link underutilization. There is a delicate balance between achieving high link utilization and low latency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 次に、PIEは高いリンク使用率を達成することを目的としています。リンクの使用率が低下したり、ネットワーク効率が低下したりすることなく、低遅延の目標を達成する必要があります。初期の輻輳信号により、TCPがバックオフし、キューの増加を回避できます。ただし、その一方で、TCPのレート削減により、リンクの使用率が低下する可能性があります。高いリンク使用率と低遅延の実現には微妙なバランスがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Furthermore, the scheme should be simple to implement and easily scalable in both hardware and software. PIE strives to maintain design simplicity similar to that of RED, which has been implemented in a wide variety of network devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* さらに、このスキームは実装が簡単で、ハードウェアとソフトウェアの両方で簡単に拡張できる必要があります。 PIEは、さまざまなネットワークデバイスに実装されているREDと同様の設計のシンプルさを維持するよう努めています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Finally, the scheme should ensure system stability for various network topologies and scale well across an arbitrary number of streams. Design parameters shall be set automatically. Users only need to set performance-related parameters such as target queue latency, not design parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 最後に、このスキームは、さまざまなネットワークトポロジのシステムの安定性を確保し、任意の数のストリームにわたって適切に拡張する必要があります。設計パラメータは自動的に設定されます。ユーザーは、設計パラメーターではなく、ターゲットキューのレイテンシなどのパフォーマンス関連のパラメーターを設定するだけで済みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following text, the design of PIE and its operation are described in detail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のテキストでは、PIEの設計とその操作について詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--The-Basic-PIE-Scheme">
4. The Basic PIE Scheme
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 基本的なPIEスキーム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As illustrated in Figure 1, PIE is comprised of three simple basic components: a) random dropping at enqueuing, b) periodic drop probability updates, and c) latency calculation. When a packet arrives, a random decision is made regarding whether to drop the packet. The drop probability is updated periodically based on how far the current latency is away from the target value and whether the queuing latency is currently trending up or down. The queuing latency can be obtained using direct measurements or using estimations calculated from the queue length and the dequeue rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図1に示すように、PIEは3つの単純な基本コンポーネントで構成されています。a）エンキュー時のランダムドロップ、b）定期的なドロップ確率の更新、c）レイテンシの計算パケットが到着すると、パケットをドロップするかどうかに関してランダムな決定が行われます。ドロップ確率は、現在のレイテンシが目標値からどれだけ離れているか、およびキューイングレイテンシが現在上昇傾向か下降傾向かに基づいて定期的に更新されます。キューイング待ち時間は、直接測定を使用して、またはキューの長さとデキュー率から計算された推定を使用して取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The detailed definition of parameters can be found in Appendix A of this document (&#34;The Basic PIE Pseudocode&#34;). Any state variables that PIE maintains are noted using &#34;PIE-&gt;&#34;. For a full description of the algorithm, one can refer to the full paper [HPSR-PIE].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パラメータの詳細な定義は、このドキュメントの付録A（「基本的なPIE擬似コード」）にあります。 PIEが維持するすべての状態変数は、「PIE-&gt;」を使用して示されます。アルゴリズムの詳細については、論文[HPSR-PIE]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Random Drop
              /               --------------
      -------/  --------------&gt;    | | | | | --------------&gt;
             /|\                   | | | | |
              |               --------------
              |             Queue Buffer   \
              |                     |       \
              |                     |Queue   \
              |                     |Length   \
              |                     |          \
              |                    \|/         \/
              |          -----------------    -------------------
              |          |     Drop      |    |                 |
              -----&lt;-----|  Probability  |&lt;---| Latency         |
                         |  Calculation  |    | Calculation     |
                         -----------------    -------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
Figure 1: The PIE Structure
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
図1：PIE構造
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Random-Dropping">
4.1. Random Dropping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. ランダムドロップ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIE randomly drops a packet upon its arrival to a queue according to a drop probability, PIE-&gt;drop_prob_, that is obtained from the drop-probability-calculation component. The random drop is triggered by a packet&#39;s arrival before enqueuing into a queue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIEは、ドロップ確率計算コンポーネントから取得されるドロップ確率PIE-&gt; drop_prob_に従って、パケットがキューに到着するとランダムにドロップします。ランダムドロップは、キューにエンキューする前のパケットの到着によってトリガーされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Upon a packet enqueue:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* パケットがキューに入ると：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
randomly drop the packet with a probability of PIE-&gt;drop_prob_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PIE-&gt; drop_prob_の確率でパケットをランダムにドロップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To ensure that PIE is &#34;work conserving&#34;, we bypass the random drop if the latency sample, PIE-&gt;qdelay_old_, is smaller than half of the target latency value (QDELAY_REF) when the drop probability is not too high (i.e., PIE-&gt;drop_prob_ &lt; 0.2), or if the queue has less than a couple of packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ドロップ確率が高すぎない場合（つまり、PIE-）、レイテンシサンプルPIE-&gt; qdelay_old_がターゲットレイテンシ値（QDELAY_REF）の半分より小さい場合、PIEが「作業節約」であることを確認するために、ランダムドロップをバイパスします。 &gt; drop_prob_ &lt;0.2）、またはキューのパケット数が少ない場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Upon a packet enqueue, PIE does the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* パケットエンキュー時に、PIEは次のことを行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
//Safeguard PIE to be work conserving if ( (PIE-&gt;qdelay_old_ &lt; QDELAY_REF/2 &amp;&amp; PIE-&gt;drop_prob_ &lt; 0.2) || (queue_.byte_length() &lt;= 2 * MEAN_PKTSIZE) ) return ENQUE; else randomly drop the packet with a probability of PIE-&gt;drop_prob_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
//（（PIE-&gt; qdelay_old_ &lt;QDELAY_REF / 2 &amp;&amp; PIE-&gt; drop_prob_ &lt;0.2）||（queue_.byte_length()&lt;= 2 * MEAN_PKTSIZE））return ENQUE;それ以外の場合は、PIE-&gt; drop_prob_の確率でパケットをランダムにドロップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIE optionally supports Explicit Congestion Notification (ECN); see Section 5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIEはオプションで明示的輻輳通知（ECN）をサポートします。セクション5.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Drop-Probability-Calculation">
4.2. Drop Probability Calculation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. ドロップ確率計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PIE algorithm periodically updates the drop probability based on the latency samples -- not only the current latency sample but also whether the latency is trending up or down. This is the classical Proportional Integral (PI) controller method, which is known for eliminating steady-state errors. This type of controller has been studied before for controlling the queue length [PI] [QCN]. PIE adopts the PI controller for controlling latency. The algorithm also auto-adjusts the control parameters based on how heavy the congestion is, which is reflected in the current drop probability. Note that the current drop probability is a direct measure of the current congestion level; there is no need to measure the arrival rate and dequeue rate mismatches.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIEアルゴリズムは、レイテンシサンプル（現在のレイテンシサンプルだけでなく、レイテンシが上昇傾向か下降傾向か）に基づいて定期的にドロップ確率を更新します。これは、定常誤差をなくすことで知られている、古典的な比例積分（PI）コントローラー法です。このタイプのコントローラーは、キューの長さ[PI] [QCN]を制御するために以前に研究されています。 PIEは、レイテンシを制御するためにPIコントローラーを採用しています。アルゴリズムはまた、現在のドロップ確率に反映される輻輳の重さに基づいて制御パラメーターを自動調整します。現在のドロップ確率は、現在の輻輳レベルの直接的な尺度であることに注意してください。到着率とデキュー率の不一致を測定する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 When a congestion period ends, we might be left with a high drop probability with light packet arrivals. Hence, the PIE algorithm includes a mechanism by which the drop probability decays exponentially (rather than linearly) when the system is not congested. This would help the drop probability converge to 0 more quickly, while the PI controller ensures that it would eventually reach zero. The decay parameter of 2% gives us a time constant around 50 * T_UPDATE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
輻輳期間が終了すると、パケットの到着が軽く、ドロップ確率が高くなる可能性があります。したがって、PIEアルゴリズムには、システムが輻輳していないときに、ドロップ確率が（線形ではなく）指数関数的に減衰するメカニズムが含まれています。これにより、ドロップ確率がより速く0に収束するのに役立ちますが、PIコントローラーは最終的にゼロに到達することを保証します。減衰パラメータが2％の場合、時定数は約50 * T_UPDATEになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specifically, the PIE algorithm periodically adjusts the drop probability every T_UPDATE interval:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体的には、PIEアルゴリズムはT_UPDATE間隔ごとに定期的に廃棄確率を調整します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* calculate drop probability PIE-&gt;drop_prob_, and autotune it as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ドロップ確率PIE-&gt; drop_prob_を計算し、次のように自動調整します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         p = alpha * (current_qdelay - QDELAY_REF) +
                beta * (current_qdelay - PIE-&gt;qdelay_old_);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         if (PIE-&gt;drop_prob_ &lt; 0.000001) {
             p /= 2048;
         } else if (PIE-&gt;drop_prob_ &lt; 0.00001) {
             p /= 512;
         } else if (PIE-&gt;drop_prob_ &lt; 0.0001) {
             p /= 128;
         } else if (PIE-&gt;drop_prob_ &lt; 0.001) {
             p /= 32;
         } else if (PIE-&gt;drop_prob_ &lt; 0.01) {
             p /= 8;
         } else if (PIE-&gt;drop_prob_ &lt; 0.1) {
             p /= 2;
         } else {
             p = p;
         }
         PIE-&gt;drop_prob_ += p;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* decay the drop probability exponentially:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ドロップ確率を指数関数的に減衰させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         if (current_qdelay == 0 &amp;&amp; PIE-&gt;qdelay_old_ == 0) {
             PIE-&gt;drop_prob_ = PIE-&gt;drop_prob_ * 0.98;
                                                 //1 - 1/64 is
                                                 //sufficient
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* bound the drop probability:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 落下確率の限界：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         if (PIE-&gt;drop_prob_ &lt; 0)
                  PIE-&gt;drop_prob_ = 0.0
         if (PIE-&gt;drop_prob_ &gt; 1)
                  PIE-&gt;drop_prob_ = 1.0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* store the current latency value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 現在のレイテンシ値を保存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
PIE-&gt;qdelay_old_ = current_qdelay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
PIE-&gt; qdelay_old_ = current_qdelay。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The update interval, T_UPDATE, is defaulted to be 15 milliseconds. It MAY be reduced on high-speed links in order to provide smoother response. The target latency value, QDELAY_REF, SHOULD be set to 15 milliseconds. The variables current_qdelay and PIE-&gt;qdelay_old_ represent the current and previous samples of the queuing latency, which are calculated by the &#34;latency calculation&#34; component (see Section 4.3). The variable current_qdelay is actually a temporary variable, while PIE-&gt;qdelay_old_ is a state variable that PIE keeps. The drop probability is a value between 0 and 1. However, implementations can certainly use integers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
更新間隔T_UPDATEのデフォルトは15ミリ秒です。より高速な応答を提供するために、高速リンクでは削減される場合があります。ターゲットレイテンシ値、QDELAY_REF、は15ミリ秒に設定する必要があります。変数current_qdelayおよびPIE-&gt; qdelay_old_は、「レイテンシ計算」コンポーネントによって計算されるキューイングレイテンシの現在および以前のサンプルを表します（セクション4.3を参照）。変数current_qdelayは実際には一時変数ですが、PIE-&gt; qdelay_old_はPIEが保持する状態変数です。ドロップ確率は0​​〜1の値です。ただし、実装では整数を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The controller parameters, alpha and beta (expressed in Hz), are designed using feedback loop analysis, where TCP&#39;s behaviors are modeled using the results from well-studied prior art [TCP-Models]. Note that the above adjustment of &#39;p&#39; effectively scales the alpha and beta parameters based on the current congestion level indicated by the drop probability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コントローラパラメータのアルファとベータ（Hzで表現）は、フィードバックループ分析を使用して設計されます。TCPの動作は、十分に研究された従来の[TCPモデル]の結果を使用してモデル化されます。上記の「p」の調整は、ドロップ確率によって示される現在の輻輳レベルに基づいてアルファおよびベータパラメーターを効果的にスケーリングすることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The theoretical analysis of PIE can be found in [HPSR-PIE]. As a rule of thumb, to keep the same feedback loop dynamics, if we cut T_UPDATE in half, we should also cut alpha by half and increase beta by alpha/4. If the target latency is reduced, e.g., for data-center use, the values of alpha and beta should be increased by the same order of magnitude by which the target latency is reduced. For example, if QDELAY_REF is reduced and changed from 15 milliseconds to 150 microseconds -- a reduction of two orders of magnitude -- then alpha and beta values should be increased to alpha * 100 and beta * 100.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIEの理論的分析は[HPSR-PIE]にあります。経験則として、同じフィードバックループのダイナミクスを維持するには、T_UPDATEを半分に削減する場合、アルファを半分に削減し、ベータをalpha / 4だけ増やす必要があります。データセンターで使用する場合など、ターゲットレイテンシが減少する場合、アルファとベータの値は、ターゲットレイテンシが減少するのと同じ桁数だけ増加する必要があります。たとえば、QDELAY_REFが15ミリ秒から150マイクロ秒に減少し、2桁減少すると、アルファ値とベータ値はアルファ* 100とベータ* 100に増加する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--Latency-Calculation">
4.3. Latency Calculation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 待ち時間の計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PIE algorithm uses latency to calculate drop probability in one of two ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIEアルゴリズムはレイテンシを使用して、ドロップ確率を次の2つの方法のいずれかで計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* It estimates the current queuing latency using Little&#39;s law (see Section 5.2 for details):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* リトルの法則を使用して、現在のキュー待機時間を推定します（詳細については、セクション5.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         current_qdelay = queue_.byte_length()/dequeue_rate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* It may use other techniques for calculating queuing latency, e.g., time-stamp the packets at enqueue, and use the timestamps to calculate latency during dequeue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* それは、キューの待ち時間を計算するために他の技術を使用するかもしれません、例えば、エンキューでパケットにタイムスタンプを付け、タイムスタンプを使ってデキューの間の待ち時間を計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4--Burst-Tolerance">
4.4. Burst Tolerance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. バースト耐性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIE does not penalize short-term packet bursts as suggested in [RFC7567]. PIE allows bursts of traffic that create finite-duration events in which current queuing latency exceeds QDELAY_REF without triggering packet drops. This document introduces a parameter called &#34;MAX_BURST&#34;; MAX_BURST defines the burst duration that will be protected. By default, the parameter SHOULD be set to 150 milliseconds. For simplicity, the PIE algorithm MAY effectively round MAX_BURST up to an integer multiple of T_UPDATE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7567]で提案されているように、PIEは短期パケットバーストにペナルティを課しません。 PIEは、パケットのドロップをトリガーすることなく、現在のキュー待機時間がQDELAY_REFを超える有限期間イベントを作成するトラフィックのバーストを許可します。このドキュメントでは、「MAX_BURST」と呼ばれるパラメータを紹介しています。 MAX_BURSTは、保護されるバースト期間を定義します。デフォルトでは、パラメータは150ミリ秒に設定する必要があります（SHOULD）。簡単にするために、PIEアルゴリズムは、MAX_BURSTをT_UPDATEの整数倍に効果的に丸める場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To implement the burst tolerance function, two basic components of PIE are involved: &#34;random dropping&#34; and &#34;drop probability calculation&#34;. The PIE algorithm does the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バーストトレランス機能を実装するには、PIEの2つの基本コンポーネントである「ランダムドロップ」と「ドロップ確率計算」が関係します。 PIEアルゴリズムは次のことを行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* In the &#34;random dropping&#34; block and upon packet arrival, PIE checks the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 「ランダムドロップ」ブロックでパケットが到着すると、PIEは次のことをチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Upon a packet enqueue: if PIE-&gt;burst_allowance_ &gt; 0 enqueue packet; else randomly drop a packet with a probability of PIE-&gt;drop_prob_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケットエンキュー時：PIE-&gt; burst_allowance_&gt; 0の場合、パケットをエンキューします。それ以外の場合は、確率的にPIE-&gt; drop_prob_の確率でパケットをドロップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         if (PIE-&gt;drop_prob_ == 0 and current_qdelay &lt; QDELAY_REF/2 and
             PIE-&gt;qdelay_old_ &lt; QDELAY_REF/2)
             PIE-&gt;burst_allowance_ = MAX_BURST;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* In the &#34;drop probability calculation&#34; block, PIE additionally calculates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 「ドロップ確率計算」ブロックでは、PIEはさらに以下を計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      PIE-&gt;burst_allowance_ = max(0,PIE-&gt;burst_allowance_ - T_UPDATE);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The burst allowance, noted by PIE-&gt;burst_allowance_, is initialized to MAX_BURST. As long as PIE-&gt;burst_allowance_ is above zero, an incoming packet will be enqueued, bypassing the random drop process. During each update instance, the value of PIE-&gt;burst_allowance_ is decremented by the update period, T_UPDATE, and is bottomed at 0. When the congestion goes away -- defined here as PIE-&gt;drop_prob_ equals 0 and both the current and previous samples of estimated latency are less than half of QDELAY_REF -- PIE-&gt;burst_allowance_ is reset to MAX_BURST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIE-&gt; burst_allowance_で示されるバースト許容値は、MAX_BURSTに初期化されます。 PIE-&gt; burst_allowance_がゼロより大きい限り、着信パケットはランダムドロッププロセスをバイパスしてキューに入れられます。各更新インスタンスの間、PIE-&gt; burst_allowance_の値は更新期間T_UPDATEによって減分され、0でボトムされます。輻輳が解消すると、ここではPIE-&gt; drop_prob_が0に等しく、現在のサンプルと以前のサンプルの両方が定義されます。推定レイテンシの半分はQDELAY_REFの半分未満です-PIE-&gt; burst_allowance_はMAX_BURSTにリセットされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Optional-Design-Elements-of-PIE">
5. Optional Design Elements of PIE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. PIEのオプションのデザイン要素
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several enhancements that are added to further augment the performance of the basic algorithm. For purposes of clarity, they are included in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本的なアルゴリズムのパフォーマンスをさらに強化するために追加されたいくつかの機能強化があります。明確にするために、これらはこのセクションに含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--ECN-Support">
5.1. ECN Support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. ECNサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIE MAY support ECN by marking (rather than dropping) ECN-capable packets [ECN]. This document introduces an additional threshold called &#34;mark_ecnth&#34;, which acts as a safeguard: if the calculated drop probability exceeds mark_ecnth, PIE reverts to packet-dropping for ECN-capable packets. The variable mark_ecnth SHOULD be set to 0.1 (10%).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIEは、ECN対応パケット[ECN]を（ドロップするのではなく）マークすることでECNをサポートする場合があります。このドキュメントでは、安全対策として機能する「mark_ecnth」と呼ばれる追加のしきい値を紹介します。計算された廃棄確率がmark_ecnthを超えると、PIEはECN対応パケットのパケット廃棄に戻ります。変数mark_ecnthは0.1（10％）に設定する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* To support ECN, the &#34;random drop with a probability of PIE-&gt;drop_prob_&#34; function in the &#34;random dropping&#34; block is changed to the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ECNをサポートするために、「ランダムドロップ」ブロックの「PIE-&gt; drop_prob_の確率でのランダムドロップ」関数は次のように変更されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Upon a packet enqueue:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* パケットがキューに入ると：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         if rand() &lt; PIE-&gt;drop_prob_:
          if PIE-&gt;drop_prob_ &lt; mark_ecnth &amp;&amp; ecn_capable_packet == TRUE:
             mark packet;
          else
             drop packet;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--Dequeue-Rate-Estimation">
5.2. Dequeue Rate Estimation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. デキュー率の見積もり
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Using timestamps, a latency sample can only be obtained when a packet reaches the head of a queue. When a quick response time is desired or a direct latency sample is not available, one may obtain latency through measuring the dequeue rate. The draining rate of a queue in the network often varies either because other queues are sharing the same link or because the link capacity fluctuates. Rate fluctuation is particularly common in wireless networks. One may measure directly at the dequeue operation. Short, non-persistent bursts of packets result in empty queues from time to time; this would make the measurement less accurate. PIE only measures latency when there is sufficient data in the buffer, i.e., when the queue length is over a certain threshold (DQ_THRESHOLD). PIE measures how long it takes to drain DQ_THRESHOLD packets. More specifically, the rate estimation can be implemented as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
タイムスタンプを使用すると、パケットがキューの先頭に達したときにのみ遅延サンプルを取得できます。迅速な応答時間が必要な場合、または直接レイテンシサンプルが利用できない場合は、デキュー率を測定することでレイテンシを取得できます。他のキューが同じリンクを共有しているため、またはリンク容量が変動するため、ネットワーク内のキューの排出率はしばしば変動します。レート変動は、ワイヤレスネットワークで特に一般的です。デキュー操作で直接測定できます。パケットの短い非永続的なバーストにより、空のキューが発生することがあります。これにより、測定の精度が低下します。 PIEは、バッファに十分なデータがある場合、つまりキューの長さが特定のしきい値（DQ_THRESHOLD）を超えている場合にのみレイテンシを測定します。 PIEは、DQ_THRESHOLDパケットを排出するのにかかる時間を測定します。より具体的には、レート推定は次のように実装できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      current_qdelay = queue_.byte_length() *
                       PIE-&gt;avg_dq_time_/DQ_THRESHOLD;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Upon a packet dequeue:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* パケットがキューから取り出されると：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if PIE-&gt;in_measurement_ == FALSE and queue.byte_length() &gt;=
      DQ_THRESHOLD:
         PIE-&gt;in_measurement_ = TRUE;
         PIE-&gt;measurement_start_ = now;
         PIE-&gt;dq_count_ = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if PIE-&gt;in_measurement_ == TRUE:
         PIE-&gt;dq_count_ = PIE-&gt;dq_count_ + deque_pkt_size;
         if PIE-&gt;dq_count_ &gt;= DQ_THRESHOLD then
            weight = DQ_THRESHOLD/2^16
            PIE-&gt;avg_dq_time_ = (now - PIE-&gt;measurement_start_) *
                                weight + PIE-&gt;avg_dq_time_ *
                                (1 - weight);
            PIE-&gt;dq_count_ = 0;
            PIE-&gt;measurement_start_ = now
         else
            PIE-&gt;in_measurement_ = FALSE;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The parameter PIE-&gt;dq_count_ represents the number of bytes departed since the last measurement. Once PIE-&gt;dq_count_ is over DQ_THRESHOLD, a measurement sample is obtained. It is recommended that the threshold be set to 16 KB, assuming a typical packet size of around 1 KB or 1.5 KB. This threshold would allow sufficient data to obtain an average draining rate but would also be fast enough (&lt; 64 KB) to reflect sudden changes in the draining rate. If DQ_THRESHOLD is smaller than 64 KB, a small weight is used to smooth out the dequeue time and obtain PIE-&gt;avg_dq_time_. The dequeue rate is simply DQ_THRESHOLD divided by PIE-&gt;avg_dq_time_. This threshold is not crucial for the system&#39;s stability. Please note that the update interval for calculating the drop probability is different from the rate measurement cycle. The drop probability calculation is done periodically per Section 4.2, and it is done even when the algorithm is not in a measurement cycle; in this case, the previously latched value of PIE-&gt;avg_dq_time_ is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パラメータPIE-&gt; dq_count_は、最後の測定以降に離脱したバイト数を表します。 PIE-&gt; dq_count_がDQ_THRESHOLDを超えると、測定サンプルが取得されます。一般的なパケットサイズが約1 KBまたは1.5 KBであると想定して、しきい値を16 KBに設定することをお勧めします。このしきい値により、平均的な排水速度を取得するのに十分なデータが得られますが、排水速度の突然の変化を反映するのに十分な速さ（&lt;64 KB）になります。 DQ_THRESHOLDが64 KBより小さい場合、小さな重みを使用してデキュー時間を平滑化し、PIE-&gt; avg_dq_time_を取得します。デキュー率は、単にDQ_THRESHOLDをPIE-&gt; avg_dq_time_で除算したものです。このしきい値は、システムの安定性にとって重要ではありません。ドロップ確率を計算するための更新間隔は、レート測定サイクルとは異なることに注意してください。落下確率の計算はセクション4.2に従って定期的に行われ、アルゴリズムが測定サイクルにない場合でも行われます。この場合、以前にラッチされたPIE-&gt; avg_dq_time_の値が使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            Random Drop
                /                     --------------
        -------/  --------------------&gt;    | | | | | --------------&gt;
               /|\             |           | | | | |
                |              |      --------------
                |              |       Queue Buffer
                |              |             |
                |              |             |Queue
                |              |             |Length
                |              |             |
                |             \|/           \|/
                |          ------------------------------
                |          |     Dequeue Rate           |
                -----&lt;-----|  &amp; Drop Probability        |
                           |        Calculation         |
                           ------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
Figure 2: The Enqueue-Based PIE Structure
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
図2：エンキューベースのPIE構造
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some platforms, enqueuing and dequeuing functions belong to different modules that are independent of each other. In such situations, a pure enqueue-based design can be developed. An enqueue-based design is depicted in Figure 2. The dequeue rate is deduced from the number of packets enqueued and the queue length. The design is based on the following key observation: over a certain time interval, the number of dequeued packets = the number of enqueued packets minus the number of remaining packets in the queue. In this design, everything can be triggered by packet arrival, including the background update process. The design complexity here is similar to the original design.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のプラットフォームでは、エンキューおよびデキュー機能は、互いに独立した異なるモジュールに属しています。このような状況では、純粋なエンキューベースの設計を開発できます。エンキューベースの設計を図2に示します。デキュー率は、エンキューされたパケット数とキューの長さから推定されます。設計は、次の重要な観察に基づいています。特定の時間間隔における、デキューされたパケットの数=エンキューされたパケットの数からキュー内の残りのパケットの数を引いたもの。この設計では、バックグラウンド更新プロセスを含め、すべてがパケットの到着によってトリガーされます。ここでの設計の複雑さは、元の設計と似ています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3--Setting-PIE-Active-and-Inactive">
5.3. Setting PIE Active and Inactive
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. PIEをアクティブおよび非アクティブに設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Traffic naturally fluctuates in a network. It would be preferable not to unnecessarily drop packets due to a spurious uptick in queuing latency. PIE has an optional feature of automatically becoming active/inactive. To implement this feature, PIE may choose to only become active (from inactive) when the buffer occupancy is over a certain threshold, which may be set to 1/3 of the tail drop threshold. PIE becomes inactive when congestion ends; i.e., when the drop probability reaches 0, current and previous latency samples are all below half of QDELAY_REF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トラフィックはネットワーク内で自然に変動します。キューの待機時間の偽の増加のために、不必要にパケットをドロップしないことが望ましいでしょう。 PIEには、自動的にアクティブ/非アクティブになるオプション機能があります。この機能を実装するために、PIEは、バッファ占有率がテールドロップしきい値の1/3に設定されている可能性がある特定のしきい値を超えている場合にのみ、非アクティブからアクティブになることを選択できます。輻輳が終了すると、PIEは非アクティブになります。つまり、ドロップ確率が0に達すると、現在および以前のレイテンシサンプルはすべてQDELAY_REFの半分未満になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ideally, PIE should become active/inactive based on latency. However, calculating latency when PIE is inactive would introduce unnecessary packet-processing overhead. Weighing the trade-offs, we decided to compare against the tail drop threshold to keep things simple.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
理想的には、PIEは遅延に基づいてアクティブ/非アクティブになる必要があります。ただし、PIEが非アクティブのときに待ち時間を計算すると、不要なパケット処理オーバーヘッドが発生します。トレードオフを考慮して、物事を簡単に保つためにテールドロップしきい値と比較することにしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When PIE optionally becomes active/inactive, the burst protection logic described in Section 4.4 is modified as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIEがオプションでアクティブ/非アクティブになると、セクション4.4で説明されているバースト保護ロジックが次のように変更されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* &#34;Random dropping&#34; block: PIE adds the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 「ランダムドロップ」ブロック：PIEは以下を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Upon packet arrival:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケット到着時：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if PIE-&gt;active_ == FALSE &amp;&amp; queue_length &gt;= TAIL_DROP/3:
         PIE-&gt;active_ = TRUE;
         PIE-&gt;burst_allowance_ = MAX_BURST;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
if PIE-&gt;burst_allowance_ &gt; 0 enqueue packet; else randomly drop a packet with a probability of PIE-&gt;drop_prob_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PIE-&gt; burst_allowance_&gt; 0の場合、パケットをエンキューします。それ以外の場合は、確率的にPIE-&gt; drop_prob_の確率でパケットをドロップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if (PIE-&gt;drop_prob_ == 0 and current_qdelay &lt; QDELAY_REF/2 and
          PIE-&gt;qdelay_old_ &lt; QDELAY_REF/2)
          PIE-&gt;active_ = FALSE;
          PIE-&gt;burst_allowance_ = MAX_BURST;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   *  &#34;Drop probability calculation&#34; block: PIE does the following:
      if PIE-&gt;active_ == TRUE:
         PIE-&gt;burst_allowance_ =
            max(0,PIE-&gt;burst_allowance_ - T_UPDATE);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4--Derandomization">
5.4. Derandomization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. でランド三佐地温
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Although PIE adopts random dropping to achieve latency control, independent coin tosses could introduce outlier situations where packets are dropped too close to each other or too far from each other. This would cause the real drop percentage to temporarily deviate from the intended value PIE-&gt;drop_prob_. In certain scenarios, such as a small number of simultaneous TCP flows, these deviations can cause significant deviations in link utilization and queuing latency. PIE may use a derandomization mechanism to avoid such situations. A parameter called &#34;PIE-&gt;accu_prob_&#34; is reset to 0 after a drop. Upon packet arrival, PIE-&gt;accu_prob_ is incremented by the amount of drop probability, PIE-&gt;drop_prob_. If PIE-&gt;accu_prob_ is less than a low threshold, e.g., 0.85, the arriving packet is enqueued; on the other hand, if PIE-&gt;accu_prob_ is more than a high threshold, e.g., 8.5, and the queue is congested, the arrival packet is forced to be dropped. A packet is only randomly dropped if PIE-&gt;accu_prob_ falls between the two thresholds. Since PIE-&gt;accu_prob_ is reset to 0 after a drop, another drop will not happen until 0.85/PIE-&gt;drop_prob_ packets later. This avoids packets being dropped too close to each other. In the other extreme case where 8.5/PIE-&gt;drop_prob_ packets have been enqueued without incurring a drop, PIE would force a drop in order to prevent the drops from being spaced too far apart. Further analysis can be found in [RFC8034].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
PIEはランダムドロップを採用してレイテンシ制御を実現しますが、独立したコイントスは、パケットが互いに近すぎたり遠すぎたりしてドロップされるという異常な状況を引き起こす可能性があります。これにより、実際のドロップ率が一時的に意図した値PIE-&gt; drop_prob_から逸脱します。少数の同時TCPフローなどの特定のシナリオでは、これらの偏差により、リンクの使用率とキューの待ち時間に大きな偏差が生じる可能性があります。 PIEは、このような状況を回避するために、ランダム化解除メカニズムを使用することがあります。 「PIE-&gt; accu_prob_」というパラメーターは、ドロップ後に0にリセットされます。パケットが到着すると、PIE-&gt; accu_prob_は、ドロップ確率の量、PIE-&gt; drop_prob_だけインクリメントされます。 PIE-&gt; accu_prob_が低いしきい値（0.85など）未満の場合、到着したパケットはキューに入れられます。一方、PIE-&gt; accu_prob_が高しきい値（8.5など）を超えており、キューが混雑している場合、到着パケットは強制的にドロップされます。パケットは、PIE-&gt; accu_prob_が2つのしきい値の間にある場合にのみランダムにドロップされます。ドロップ後、PIE-&gt; accu_prob_は0にリセットされるため、0.85 / PIE-&gt; drop_prob_パケットがなくなるまで、別のドロップは発生しません。これにより、パケットが互いに近づきすぎてドロップされることが回避されます。ドロップが発生せずに8.5 / PIE-&gt; drop_prob_パケットがキューに入れられている他の極端なケースでは、PIEは強制的にドロップして、ドロップの間隔が離れすぎないようにします。さらなる分析は[RFC8034]で見つけることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-5--Cap-Drop-Adjustment">
5.5. Cap Drop Adjustment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. キャップドロップ調整
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of a single TCP flow, during the slow-start phase the queue could quickly increase, which could result in a very rapid increase in drop probability. In order to prevent an excessive ramp-up that could negatively impact the throughput in this scenario, PIE can cap the maximum drop probability increase in each step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一のTCPフローの場合、スロースタートフェーズ中にキューが急速に増加し、その結果、廃棄確率が非常に急速に増加する可能性があります。このシナリオでスループットに悪影響を与える可能性のある過度のランプアップを防ぐために、PIEは各ステップでの最大ドロップ確率の増加を制限できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* &#34;Drop probability calculation&#34; block: PIE adds the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 「ドロップ確率計算」ブロック：PIEは以下を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if (PIE-&gt;drop_prob_ &gt;= 0.1 &amp;&amp; p &gt; 0.02) {
          p = 0.02;
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Implementation-Cost">
6. Implementation Cost
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 実装コスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIE can be applied to existing hardware or software solutions. There are three steps involved in PIE, as discussed in Section 4. Their complexities are examined below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIEは、既存のハードウェアまたはソフトウェアソリューションに適用できます。セクション4で説明したように、PIEには3つのステップが含まれます。それらの複雑さを以下で検討します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon packet arrival, the algorithm simply drops a packet randomly, based on the drop probability. This step is straightforward and requires no packet header examination and manipulation. If the implementation doesn&#39;t rely on packet timestamps for calculating latency, PIE does not require extra memory. Furthermore, the input side of a queue is typically under software control while the output side of a queue is hardware based. Hence, a drop at enqueuing can be readily retrofitted into existing or software implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットが到着すると、アルゴリズムは、ドロップ確率に基づいて、単にパケットをランダムにドロップします。この手順は簡単で、パケットヘッダーの検査と操作は必要ありません。実装がパケットタイムスタンプに依存してレイテンシを計算しない場合、PIEは追加のメモリを必要としません。さらに、キューの入力側は通常ソフトウェア制御下にあり、キューの出力側はハードウェアベースです。したがって、エンキューの低下は、既存の実装またはソフトウェア実装に容易に組み込むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The drop probability calculation is done in the background, and it occurs every T_UPDATE interval. Given modern high-speed links, this period translates into once every tens, hundreds, or even thousands of packets. Hence, the calculation occurs at a much slower time scale than the packet-processing time -- at least an order of magnitude slower. The calculation of drop probability involves multiplications using alpha and beta. Since PIE&#39;s control law is robust to minor changes in alpha and beta values, an implementation MAY choose these values to the closest multiples of 2 or 1/2 (e.g., alpha = 1/8, beta = 1 + 1/4) such that the multiplications can be done using simple adds and shifts. As no complicated functions are required, PIE can be easily implemented in both hardware and software. The state requirement is only three variables per queue: burst_allowance_, PIE-&gt;drop_prob_, and PIE-&gt;qdelay_old_. Hence, the memory overhead is small.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ドロップ確率の計算はバックグラウンドで実行され、T_UPDATE間隔ごとに発生します。最新の高速リンクを考えると、この期間は数十、数百、または数千のパケットに1回に相当します。したがって、計算はパケット処理時間よりもはるかに遅い時間スケールで発生します-少なくとも1桁遅い。ドロップ確率の計算には、アルファとベータを使用した乗算が含まれます。 PIEの制御法則はアルファ値とベータ値のマイナーな変更に対してロバストであるため、実装はこれらの値を2または1/2の最も近い倍数（たとえば、アルファ= 1/8、ベータ= 1 + 1/4）に選択できます。乗算は、単純な加算とシフトを使用して実行できます。複雑な機能は必要ないため、PIEはハードウェアとソフトウェアの両方で簡単に実装できます。状態要件は、キューごとに3つの変数（burst_allowance_、PIE-&gt; drop_prob_、およびPIE-&gt; qdelay_old_）のみです。したがって、メモリのオーバーヘッドは小さいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If one chooses to implement the departure rate estimation, PIE uses a counter to keep track of the number of bytes departed for the current interval. This counter is incremented per packet departure. Every T_UPDATE, PIE calculates latency using the departure rate, which can be implemented using a single multiply operation. Note that many network devices keep track of an interface&#39;s departure rate. In this case, PIE might be able to reuse this information and simply skip the third step of the algorithm; hence, it would incur no extra cost. If a platform already leverages packet timestamps for other purposes, PIE can make use of these packet timestamps for latency calculation instead of estimating the departure rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
逸脱率の推定を実装することを選択した場合、PIEはカウンターを使用して、現在の間隔で出発したバイト数を追跡​​します。このカウンタは、パケットの発信ごとに増分されます。 T_UPDATEごとに、PIEは逸脱率を使用してレイテンシを計算します。これは、単一の乗算演算を使用して実装できます。多くのネットワークデバイスは、インターフェイスの離脱率を追跡していることに注意してください。この場合、PIEはこの情報を再利用して、アルゴリズムの3番目のステップを単にスキップできる可能性があります。したがって、追加費用は発生しません。プラットフォームがすでに他の目的でパケットタイムスタンプを利用している場合、PIEは、逸脱率を推定する代わりに、これらのパケットタイムスタンプをレイテンシ計算に利用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow queuing can also be combined with PIE to provide isolation between flows. In this case, it is preferable to have an independent value of drop probability per queue. This allows each flow to receive the most appropriate level of congestion signal and ensures that sparse flows are protected from experiencing packet drops. However, running the entire PIE algorithm independently on each queue in order to calculate the drop probability may be overkill. Furthermore, in the case where departure rate estimation is used to predict queuing latency, it is not possible to calculate an accurate per-queue departure rate upon which to implement the PIE drop probability calculation. Instead, it has been proposed [DOCSIS-AQM] that a single implementation of the PIE drop probability calculation based on the overall latency estimate be used, followed by a per-queue scaling of drop probability based on the ratio of queue depth between the queue in question and the current largest queue. This scaling is reasonably simple and has a couple of nice properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローキューイングをPIEと組み合わせて、フロー間の分離を実現することもできます。この場合、キューごとのドロップ確率の独立した値を持つことが望ましいです。これにより、各フローは最も適切なレベルの輻輳信号を受信でき、スパースフローがパケットドロップの発生から保護されます。ただし、廃棄確率を計算するためにPIEアルゴリズム全体を各キューで個別に実行することは、やり過ぎになる場合があります。さらに、逸脱率推定を使用してキュー待機時間を予測する場合、PIEドロップ確率計算を実装する正確なキューごとの逸脱率を計算することはできません。代わりに、全体的なレイテンシ推定に基づくPIEドロップ確率計算の単一の実装が使用され、その後、キュー間のキュー深度の比率に基づくドロップ確率のキューごとのスケーリングが使用されることが提案されています[DOCSIS-AQM]。問題の現在の最大のキュー。このスケーリングはかなり単純で、いくつかの優れたプロパティがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If a packet is arriving to an empty queue, it is given immunity from packet drops altogether, regardless of the state of the other queues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* パケットが空のキューに到着すると、他のキューの状態に関係なく、パケットドロップに対する耐性が完全に与えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* In the situation where only a single queue is in use, the algorithm behaves exactly like the single-queue PIE algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 単一キューのみが使用されている状況では、アルゴリズムは単一キューPIEアルゴリズムとまったく同じように動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In summary, PIE is simple enough to be implemented in both software and hardware.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要約すると、PIEはソフトウェアとハ​​ードウェアの両方に実装できるほど単純です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Scope-of-Experimentation">
7. Scope of Experimentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 実験の範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The design of the PIE algorithm is presented in this document. The PIE algorithm effectively controls the average queuing latency to a target value. The following areas can be used for further study and experimentation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、PIEアルゴリズムの設計について説明します。 PIEアルゴリズムは、平均キューイングレイテンシをターゲット値に効果的に制御します。次の領域は、さらなる調査と実験に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Autotuning of target latency without losing utilization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 使用率を失うことなくターゲットレイテンシを自動調整します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Autotuning for the average round-trip time of traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* トラフィックの平均往復時間の自動調整。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The proper threshold to transition smoothly between ECN marking and dropping.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ECNマーキングとドロップの間をスムーズに移行するための適切なしきい値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The enhancements described in Section 5, which can be used in experiments to see if they would be of more value in the real world. If so, they will be incorporated into the basic PIE algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* セクション5で説明した拡張機能は、実験で使用して、現実世界でより価値があるかどうかを確認できます。その場合、それらは基本的なPIEアルゴリズムに組み込まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The PIE design, which is separated into the data path and the control path. The control path can be implemented in software. Field tests of other control laws can be performed to experiment with further improvements to PIE&#39;s performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* データパスと制御パスに分離されたPIE設計。制御パスはソフトウェアで実装できます。他の制御法則のフィールドテストを実行して、PIEのパフォーマンスをさらに向上させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although all network nodes cannot be changed altogether to adopt latency-based AQM schemes such as PIE, a gradual adoption would eventually lead to end-to-end low-latency service for all applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのネットワークノードを完全に変更して、PIEなどの遅延ベースのAQMスキームを採用することはできませんが、徐々に採用すると、最終的にすべてのアプリケーションでエンドツーエンドの低遅延サービスが実現します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Incremental-Deployment">
8. Incremental Deployment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 増分展開
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From testbed experiments and large-scale simulations of PIE so far, PIE has been shown to be effective across a diverse range of network scenarios. There is no indication that PIE would be harmful to deploy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまでのPIEのテストベッド実験と大規模シミュレーションから、PIEはさまざまなネットワークシナリオで効果的であることが示されています。 PIEの展開が有害であるという兆候はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PIE scheme can be independently deployed and managed without a need for interoperability between different network devices. In addition, any individual buffer queue can be incrementally upgraded to PIE, as it can coexist with existing AQM schemes such as Weighted RED (WRED).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIEスキームは、異なるネットワークデバイス間の相互運用性を必要とせずに、独立して展開および管理できます。さらに、個々のバッファキューは、加重RED（WRED）などの既存のAQMスキームと共存できるため、PIEに段階的にアップグレードできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIE is intended to be self-configuring. Users should not need to configure any design parameters. Upon installation, the two user-configurable parameters -- QDELAY_REF and MAX_BURST -- will be defaulted to 15 milliseconds and 150 milliseconds for non-data-center network devices and to 15 microseconds and 150 microseconds for data-center switches, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIEは、自己構成を目的としています。ユーザーは設計パラメータを構成する必要はありません。インストール時に、2つのユーザー構成可能なパラメーター（QDELAY_REFとMAX_BURST）は、デフォルトで非データセンターネットワークデバイスの場合は15ミリ秒と150ミリ秒に、データセンタースイッチの場合は15マイクロ秒と150マイクロ秒に設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the data path of the algorithm needs only a simple coin toss and the control-path calculation happens in a much slower time scale, we don&#39;t foresee any scaling issues associated with the algorithm as the link speed scales up.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アルゴリズムのデータパスに必要なのは単純なコイントスだけであり、制御パスの計算ははるかに遅いタイムスケールで行われるため、リンク速度の拡大に伴うアルゴリズムに関連するスケーリングの問題は予測されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--Security-Considerations">
9. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes PIE, an active queue management algorithm based on implementations in different products. The PIE algorithm introduces no specific security exposures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、さまざまな製品の実装に基づくアクティブなキュー管理アルゴリズムであるPIEについて説明します。 PIEアルゴリズムは、特定の機密漏れをもたらしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--References">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-1--Normative-References">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;http://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;http://www.rfc-editor.org/info/ rfc2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-2--Informative-References">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC970] Nagle, J., &#34;On Packet Switches With Infinite Storage&#34;, RFC 970, DOI 10.17487/RFC0970, December 1985, &lt;http://www.rfc-editor.org/info/rfc970&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC970] Nagle、J。、「On Packet Switches With Infinite Storage」、RFC 970、DOI 10.17487 / RFC0970、1985年12月、&lt;http://www.rfc-editor.org/info/rfc970&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2309] Braden, B., Clark, D., Crowcroft, J., Davie, B., Deering, S., Estrin, D., Floyd, S., Jacobson, V., Minshall, G., Partridge, C., Peterson, L., Ramakrishnan, K., Shenker, S., Wroclawski, J., and L. Zhang, &#34;Recommendations on Queue Management and Congestion Avoidance in the Internet&#34;, RFC 2309, DOI 10.17487/RFC2309, April 1998, &lt;http://www.rfc-editor.org/info/rfc2309&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2309]ブレーデン、B。、クラーク、D。、クロウクロフト、J。、デイビー、B。、ディアリング、S。、エストリン、D。、フロイド、S。、ジェイコブソン、V。、ミンシャル、G。、パートリッジ、 C.、Peterson、L.、Ramakrishnan、K.、Shenker、S.、Wroclawski、J。、およびL. Zhang、「インターネットでのキュー管理と輻輳回避に関する推奨事項」、RFC 2309、DOI 10.17487 / RFC2309、4月1998、&lt;http://www.rfc-editor.org/info/rfc2309&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7567] Baker, F., Ed., and G. Fairhurst, Ed., &#34;IETF Recommendations Regarding Active Queue Management&#34;, BCP 197, RFC 7567, DOI 10.17487/RFC7567, July 2015, &lt;http://www.rfc-editor.org/info/rfc7567&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7567]ベイカー、F。、エド、およびG.フェアハースト、エド、「アクティブキュー管理に関するIETFの推奨事項」、BCP 197、RFC 7567、DOI 10.17487 / RFC7567、2015年7月、&lt;http：//www.rfc -editor.org/info/rfc7567&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7806] Baker, F. and R. Pan, &#34;On Queuing, Marking, and Dropping&#34;, RFC 7806, DOI 10.17487/RFC7806, April 2016, &lt;http://www.rfc-editor.org/info/rfc7806&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7806]ベイカー、F。およびR.パン、「キューイング、マーキング、およびドロップ時」、RFC 7806、DOI 10.17487 / RFC7806、2016年4月、&lt;http://www.rfc-editor.org/info/rfc7806&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8034] White, G. and R. Pan, &#34;Active Queue Management (AQM) Based on Proportional Integral Controller Enhanced (PIE) for Data-Over-Cable Service Interface Specifications (DOCSIS) Cable Modems&#34;, RFC 8034, DOI 10.17487/RFC8034, February 2017, &lt;http://www.rfc-editor.org/info/rfc8034&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8034]ホワイト、G.、R。パン、「Data-Over-Cable Service Interface Specifications（DOCSIS）Cable Modems用のProportional Integral Controller Enhanced（PIE）に基づくアクティブキュー管理（AQM）」、RFC 8034、DOI 10.17487 / RFC8034、2017年2月、&lt;http://www.rfc-editor.org/info/rfc8034&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CBQ] Cisco, &#34;Class-Based Weighted Fair Queueing&#34;, &lt;http://www.cisco.com/en/US/docs/ios/12_0t/12_0t5/ feature/guide/cbwfq.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CBQ] Cisco、「Class-Based Weighted Fair Queueing」、&lt;http://www.cisco.com/en/US/docs/ios/12_0t/12_0t5/ feature / guide / cbwfq.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CoDel] Nichols, K. and V. Jacobson, &#34;Controlling Queue Delay&#34;, Communications of the ACM, Volume 55, Issue 7, pp. 42-50, DOI 10.1145/2209249.2209264, July 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CoDel] Nichols、K。およびV. Jacobson、「Controlling Queue Delay」、Communications of the ACM、Volume 55、Issue 7、42--50ページ、DOI 10.1145 / 2209249.2209264、2012年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DOCSIS_3.1] CableLabs, &#34;MAC and Upper Layer Protocols Interface Specification&#34;, DOCSIS 3.1, January 2017, &lt;https://apps.cablelabs.com/specification/ CM-SP-MULPIv3.1&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DOCSIS_3.1] CableLabs、「MAC and Upper Layer Protocols Interface Specification」、DOCSIS 3.1、2017年1月、&lt;https://apps.cablelabs.com/specification/ CM-SP-MULPIv3.1&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DOCSIS-AQM] White, G., &#34;Active Queue Management in DOCSIS 3.x Cable Modems&#34;, May 2014, &lt;http://www.cablelabs.com/wp-content/ uploads/2014/06/DOCSIS-AQM_May2014.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DOCSIS-AQM]ホワイト、G。、「DOCSIS 3.xケーブルモデムでのアクティブキュー管理」、2014年5月、&lt;http://www.cablelabs.com/wp-content/uploads/2014/06/DOCSIS-AQM_May2014 .pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ECN] Briscoe, B., Kaippallimalil, J., and P. Thaler, &#34;Guidelines for Adding Congestion Notification to Protocols that Encapsulate IP&#34;, Work in Progress, draft-ietf-tsvwg-ecn-encap-guidelines-07, July 2016.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ECN] Briscoe、B.、Kaippallimalil、J。、およびP. Thaler、「IPをカプセル化するプロトコルに輻輳通知を追加するためのガイドライン」、作業中、draft-ietf-tsvwg-ecn-encap-guidelines-07、7月2016。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HPSR-PIE] Pan, R., Natarajan, P., Piglione, C., Prabhu, M.S., Subramanian, V., Baker, F., and B. Ver Steeg, &#34;PIE: A lightweight control scheme to address the bufferbloat problem&#34;, IEEE HPSR, DOI 10.1109/HPSR.2013.6602305, 2013, &lt;https://www.researchgate.net/publication/ 261134127_PIE_A_lightweight_control_scheme_to_address_ the_bufferbloat_problem?origin=mail&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HPSR-PIE] Pan、R.、Natarajan、P.、Piglione、C.、Prabhu、MS、Subramanian、V.、Baker、F.、and B. Ver Steeg、 &#34;PIE：a軽量制御スキームに対処するための軽量制御スキームbufferbloat problem」、IEEE HPSR、DOI 10.1109 / HPSR.2013.6602305、2013、&lt;https://www.researchgate.net/publication/ 261134127_PIE_A_lightweight_control_scheme_to_address_ the_bufferbloat_problem？origin = mail&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PI] Hollot, C.V., Misra, V., Towsley, D., and W. Gong, &#34;On designing improved controllers for AQM routers supporting TCP flows&#34;, INFOCOM 2001, DOI 10.1109/INFCOM.2001.916670, April 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PI] Hollot、C.V.、Misra、V.、Towsley、D。、およびW. Gong、「TCPフローをサポートするAQMルーター用の改良されたコントローラーの設計について」、INFOCOM 2001、DOI 10.1109 / INFCOM.2001.916670、2001年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[QCN] IEEE, &#34;IEEE Standard for Local and Metropolitan Area Networks--Virtual Bridged Local Area Networks - Amendment: 10: Congestion Notification&#34;, IEEE 802.1Qau, &lt;http://www.ieee802.org/1/pages/802.1au.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[QCN] IEEE、「IEEE Standard for Local and Metropolitan Area Networks--Virtual Bridged Local Area Networks-Amendment：10：Congestion Notification」、IEEE 802.1Qau、&lt;http://www.ieee802.org/1/pages/802.1 au.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RED] Floyd, S. and V. Jacobson, &#34;Random Early Detection (RED) Gateways for Congestion Avoidance&#34;, IEEE/ACM Transactions on Networking, Volume 1, Issue 4, DOI 10.1109/90.251892, August 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RED] Floyd、S.およびV. Jacobson、「Random Early Detection（RED）Gateways for Congestion Avoidance」、IEEE / ACM Transactions on Networking、Volume 1、Issue 4、DOI 10.1109 / 90.251892、1993年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCP-Models] Misra, V., Gong, W., and D. Towsley, &#34;Fluid-based analysis of a network of AQM routers supporting TCP flows with an application to RED&#34;, SIGCOMM 2000, Volume 30, Issue 4, pp. 151-160, DOI 10.1145/347057.347421, October 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCPモデル] Misra、V.、Gong、W。、およびD. Towsley、「REDへのアプリケーションを使用したTCPフローをサポートするAQMルーターのネットワークの流体ベースの分析」、SIGCOMM 2000、第30巻、第4号pp。151-160、DOI 10.1145 / 347057.347421、2000年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--The-Basic-PIE-Pseudocode">
Appendix A. The Basic PIE Pseudocode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A.基本的なPIE擬似コード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Configurable parameters:
      -  QDELAY_REF.  AQM Latency Target (default: 15 milliseconds)
      -  MAX_BURST.  AQM Max Burst Allowance (default: 150 milliseconds)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Internal parameters:
      -  Weights in the drop probability calculation (1/s):
         alpha (default: 1/8), beta (default: 1 + 1/4)
      -  T_UPDATE: a period to calculate drop probability
         (default: 15 milliseconds)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Table that stores status variables (ending with &#34;_&#34;):
      -  burst_allowance_: current burst allowance
      -  drop_prob_: The current packet drop probability.  Reset to 0
      -  qdelay_old_: The previous queue delay.  Reset to 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Public/system functions:
      -  queue_.  Holds the pending packets
      -  drop(packet).  Drops/discards a packet
      -  now().  Returns the current time
      -  random().  Returns a uniform r.v. in the range 0 ~ 1
      -  queue_.byte_length().  Returns current queue_ length in bytes
      -  queue_.enque(packet).  Adds packet to tail of queue_
      -  queue_.deque().  Returns the packet from the head of queue_
      -  packet.size().  Returns size of packet
      -  packet.timestamp_delay().  Returns timestamped packet latency
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ============================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   //Called on each packet arrival
     enque(Packet packet) {
          if (PIE-&gt;drop_prob_ == 0 &amp;&amp; current_qdelay &lt; QDELAY_REF/2
              &amp;&amp; PIE-&gt;qdelay_old_ &lt; QDELAY_REF/2) {
              PIE-&gt;burst_allowance_ = MAX_BURST;
          }
          if (PIE-&gt;burst_allowance_ == 0 &amp;&amp; drop_early() == DROP) {
                   drop(packet);
          } else {
                   queue_.enque(packet);
          }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ============================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
drop_early() {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
drop_early(){
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         //Safeguard PIE to be work conserving
         if ( (PIE-&gt;qdelay_old_ &lt; QDELAY_REF/2 &amp;&amp; PIE-&gt;drop_prob_ &lt; 0.2)
               || (queue_.byte_length() &lt;= 2 * MEAN_PKTSIZE) ) {
              return ENQUE;
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         double u = random();
         if (u &lt; PIE-&gt;drop_prob_) {
              return DROP;
         } else {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              return ENQUE;
         }
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ============================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   //We choose the timestamp option of obtaining latency for clarity
   //Rate estimation method can be found in the extended PIE pseudocode
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
deque(Packet packet) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
deque（パケットパケット）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       current_qdelay = packet.timestamp_delay();
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ============================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   //Update periodically, T_UPDATE = 15 milliseconds
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
calculate_drop_prob() {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
calculate_drop_prob(){
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
//Can be implemented using integer multiply
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
//整数乗算を使用して実装できます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          p = alpha * (current_qdelay - QDELAY_REF) + \
              beta * (current_qdelay - PIE-&gt;qdelay_old_);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          if (PIE-&gt;drop_prob_ &lt; 0.000001) {
              p /= 2048;
          } else if (PIE-&gt;drop_prob_ &lt; 0.00001) {
              p /= 512;
          } else if (PIE-&gt;drop_prob_ &lt; 0.0001) {
              p /= 128;
          } else if (PIE-&gt;drop_prob_ &lt; 0.001) {
              p /= 32;
          } else if (PIE-&gt;drop_prob_ &lt; 0.01) {
              p /= 8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          } else if (PIE-&gt;drop_prob_ &lt; 0.1) {
              p /= 2;
          } else {
              p = p;
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          PIE-&gt;drop_prob_ += p;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          //Exponentially decay drop prob when congestion goes away
          if (current_qdelay == 0 &amp;&amp; PIE-&gt;qdelay_old_ == 0) {
              PIE-&gt;drop_prob_ *= 0.98;           //1 - 1/64 is
                                                 //sufficient
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          //Bound drop probability
          if (PIE-&gt;drop_prob_ &lt; 0)
                   PIE-&gt;drop_prob_ = 0.0
          if (PIE-&gt;drop_prob_ &gt; 1)
                   PIE-&gt;drop_prob_ = 1.0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          PIE-&gt;qdelay_old_ = current_qdelay;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          PIE-&gt;burst_allowance_ =
             max(0,PIE-&gt;burst_allowance_ - T_UPDATE);
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-B--Pseudocode-for-PIE-with-Optional-Enhancement">
Appendix B. Pseudocode for PIE with Optional Enhancement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録B.オプションの拡張機能を備えたPIEの疑似コード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Configurable parameters:
      -  QDELAY_REF.  AQM Latency Target (default: 15 milliseconds)
      -  MAX_BURST.  AQM Max Burst Allowance (default: 150 milliseconds)
      -  MAX_ECNTH.  AQM Max ECN Marking Threshold (default: 10%)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Internal parameters:
      -  Weights in the drop probability calculation (1/s):
         alpha (default: 1/8), beta (default: 1 + 1/4)
      -  DQ_THRESHOLD: (in bytes, default: 2^14 (in a power of 2) )
      -  T_UPDATE: a period to calculate drop probability
         (default: 15 milliseconds)
      -  TAIL_DROP: the tail drop threshold (max allowed queue depth)
         for the queue
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Table that stores status variables (ending with &#34;_&#34;):
      -  active_: INACTIVE/ACTIVE
      -  burst_allowance_: current burst allowance
      -  drop_prob_: The current packet drop probability.  Reset to 0
      -  accu_prob_: Accumulated drop probability.  Reset to 0
      -  qdelay_old_: The previous queue delay estimate.  Reset to 0
      -  last_timestamp_: Timestamp of previous status update
      -  dq_count_, measurement_start_, in_measurement_, avg_dq_time_.
         Variables for measuring average dequeue rate
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Public/system functions:
      -  queue_.  Holds the pending packets
      -  drop(packet).  Drops/discards a packet
      -  mark(packet).  Marks ECN for a packet
      -  now().  Returns the current time
      -  random().  Returns a uniform r.v. in the range 0 ~ 1
      -  queue_.byte_length().  Returns current queue_ length in bytes
      -  queue_.enque(packet).  Adds packet to tail of queue_
      -  queue_.deque().  Returns the packet from the head of queue_
      -  packet.size().  Returns size of packet
      -  packet.ecn().  Returns whether packet is ECN capable or not
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ============================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   //Called on each packet arrival
     enque(Packet packet) {
          if (queue_.byte_length() + packet.size() &gt; TAIL_DROP) {
                 drop(packet);
                 PIE-&gt;accu_prob_ = 0;
          } else if (PIE-&gt;active_ == TRUE &amp;&amp; drop_early() == DROP
                     &amp;&amp; PIE-&gt;burst_allowance_ == 0) {
                 if (PIE-&gt;drop_prob_ &lt; MAX_ECNTH &amp;&amp; packet.ecn() ==
                     TRUE)
                       mark(packet);
                 else
                       drop(packet);
                       PIE-&gt;accu_prob_ = 0;
          } else {
                 queue_.enque(packet);
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          //If the queue is over a certain threshold, turn on PIE
          if (PIE-&gt;active_ == INACTIVE
              &amp;&amp; queue_.byte_length() &gt;= TAIL_DROP/3) {
               PIE-&gt;active_ = ACTIVE;
               PIE-&gt;qdelay_old_ = 0;
               PIE-&gt;drop_prob_ = 0;
               PIE-&gt;in_measurement_ = TRUE;
               PIE-&gt;dq_count_ = 0;
               PIE-&gt;avg_dq_time_ = 0;
               PIE-&gt;last_timestamp_ = now;
               PIE-&gt;burst_allowance_ = MAX_BURST;
               PIE-&gt;accu_prob_ = 0;
               PIE-&gt;measurement_start_ = now;
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          //If the queue has been idle for a while, turn off PIE
          //Reset counters when accessing the queue after some idle
          //period if PIE was active before
          if ( PIE-&gt;drop_prob_ == 0 &amp;&amp; PIE-&gt;qdelay_old_ == 0
               &amp;&amp; current_qdelay == 0) {
               PIE-&gt;active_ = INACTIVE;
               PIE-&gt;in_measurement_ = FALSE;
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
｝
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ============================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
drop_early() {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
drop_early(){
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         //PIE is active but the queue is not congested: return ENQUE
         if ( (PIE-&gt;qdelay_old_ &lt; QDELAY_REF/2 &amp;&amp; PIE-&gt;drop_prob_ &lt; 0.2)
               || (queue_.byte_length() &lt;= 2 * MEAN_PKTSIZE) ) {
              return ENQUE;
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         if (PIE-&gt;drop_prob_ == 0) {
                  PIE-&gt;accu_prob_ = 0;
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         //For practical reasons, drop probability can be further scaled
         //according to packet size, but one needs to set a bound to
         //avoid unnecessary bias
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         //Random drop
         PIE-&gt;accu_prob_ += PIE-&gt;drop_prob_;
         if (PIE-&gt;accu_prob_ &lt; 0.85)
             return ENQUE;
         if (PIE-&gt;accu_prob_ &gt;= 8.5)
             return DROP;
                 double u = random();
         if (u &lt; PIE-&gt;drop_prob_) {
                      PIE-&gt;accu_prob_ = 0;
                      return DROP;
         } else {
                      return ENQUE;
         }
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ============================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    //Update periodically, T_UPDATE = 15 milliseconds
    calculate_drop_prob() {
        if ( (now - PIE-&gt;last_timestamp_) &gt;= T_UPDATE &amp;&amp;
                PIE-&gt;active_ == ACTIVE) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          //Can be implemented using integer multiply
          //DQ_THRESHOLD is power of 2 value
          current_qdelay = queue_.byte_length() *
          PIE-&gt;avg_dq_time_/DQ_THRESHOLD;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          p = alpha * (current_qdelay - QDELAY_REF) + \
              beta * (current_qdelay - PIE-&gt;qdelay_old_);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          if (PIE-&gt;drop_prob_ &lt; 0.000001) {
              p /= 2048;
          } else if (PIE-&gt;drop_prob_ &lt; 0.00001) {
              p /= 512;
          } else if (PIE-&gt;drop_prob_ &lt; 0.0001) {
              p /= 128;
          } else if (PIE-&gt;drop_prob_ &lt; 0.001) {
              p /= 32;
          } else if (PIE-&gt;drop_prob_ &lt; 0.01) {
              p /= 8;
          } else if (PIE-&gt;drop_prob_ &lt; 0.1) {
              p /= 2;
          } else {
              p = p;
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          if (PIE-&gt;drop_prob_ &gt;= 0.1 &amp;&amp; p &gt; 0.02) {
              p = 0.02;
          }
          PIE-&gt;drop_prob_ += p;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          //Exponentially decay drop prob when congestion goes away
          if (current_qdelay &lt; QDELAY_REF/2 &amp;&amp; PIE-&gt;qdelay_old_ &lt;
              QDELAY_REF/2) {
                 PIE-&gt;drop_prob_ *= 0.98;        //1 - 1/64 is
                                                 //sufficient
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          //Bound drop probability
          if (PIE-&gt;drop_prob_ &lt; 0)
                   PIE-&gt;drop_prob_ = 0
          if (PIE-&gt;drop_prob_ &gt; 1)
                   PIE-&gt;drop_prob_ = 1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          PIE-&gt;qdelay_old_ = current_qdelay;
          PIE-&gt;last_timestamp_ = now;
          PIE-&gt;burst_allowance_ = max(0,PIE-&gt;burst_allowance_ -
             T_UPDATE);
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ============================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   //Called on each packet departure
     deque(Packet packet) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        //Dequeue rate estimation
        if (PIE-&gt;in_measurement_ == TRUE) {
             PIE-&gt;dq_count_ = packet.size() + PIE-&gt;dq_count_;
             //Start a new measurement cycle if we have enough packets
             if ( PIE-&gt;dq_count_ &gt;= DQ_THRESHOLD) {
               dq_time = now - PIE-&gt;measurement_start_;
               if (PIE-&gt;avg_dq_time_ == 0) {
                   PIE-&gt;avg_dq_time_ = dq_time;
               } else {
                   weight = DQ_THRESHOLD/2^16
                   PIE-&gt;avg_dq_time_ = dq_time * weight +
                      PIE-&gt;avg_dq_time_ * (1 - weight);
               }
               PIE-&gt;in_measurement_ = FALSE;
             }
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        //Start a measurement if we have enough data in the queue
        if (queue_.byte_length() &gt;= DQ_THRESHOLD &amp;&amp;
            PIE-&gt;in_measurement_ == FALSE) {
               PIE-&gt;in_measurement_ = TRUE;
               PIE-&gt;measurement_start_ = now;
               PIE-&gt;dq_count_ = 0;
        }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Contributors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
貢献者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bill Ver Steeg Comcast Cable Email: William_VerSteeg@comcast.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bill Ver Steeg Comcast Cableメール：William_VerSteeg@comcast.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mythili Prabhu* Akamai Technologies 3355 Scott Blvd. Santa Clara, CA 95054 United States of America Email: mythili@akamai.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Maithili Prabhu *マネジメントテクノロジースコットビルド。アメリカ合衆国、サンタクララメール：Maithili Camp.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Chiara Piglione* Broadcom Corporation 3151 Zanker Road San Jose, CA 95134 United States of America Email: chiara@broadcom.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Chiara Piglione * Broadcom Corporation 3151 Zanker Road San Jose、CA 95134アメリカ合衆国メール：chiara@broadcom.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Vijay Subramanian* PLUMgrid, Inc. 350 Oakmead Parkway Suite 250 Sunnyvale, CA 94085 United States of America Email: vns@plumgrid.com * Formerly at Cisco Systems
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Vijay Subramanian * PLUMgrid、Inc. 350 Oakmead Parkway Suite 250 Sunnyvale、CA 94085 United States of Email Email：vns@plumgrid.com *旧Cisco Systems
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rong Pan Cisco Systems 3625 Cisco Way San Jose, CA 95134 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rong Pan Cisco Systems 3625 Cisco Way San Jose、CA 95134アメリカ合衆国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: ropan@cisco.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Preethi Natarajan Cisco Systems 725 Alder Drive Milpitas, CA 95035 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Preethi Natarajan Cisco Systems 725 Alder Drive Milpitas、CA 95035アメリカ合衆国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: prenatar@cisco.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fred Baker Santa Barbara, CA 93117 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレッドベイカーサンタバーバラ、カリフォルニア州93117アメリカ合衆国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: FredBaker.IETF@gmail.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Greg White CableLabs 858 Coal Creek Circle Louisville, CO 80027 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グレッグホワイトCableLabs 858コールクリークサークルルイビル、CO 80027アメリカ合衆国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: g.white@cablelabs.com
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
