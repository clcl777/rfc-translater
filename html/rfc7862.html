<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 7862 - Network File System (NFS) Version 4 Minor Version 2 Protocol 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">7862</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc7862">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 7862 - Network File System (NFS) Version 4 Minor Version 2 Protocol 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc7862">
            https://datatracker.ietf.org/doc/html/rfc7862
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 7862 - ネットワークファイルシステム（NFS）バージョン4マイナーバージョン2プロトコル</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <h6 class="card-title">要約（自動生成）</h6>
            <p class="card-text">RFC 7862は、NFSバージョン4マイナーバージョン2プロトコルに関する仕様です。このRFCの目的は、NFSv4.2プロトコルの機能と拡張を定義し、NFSv4.1からの進化を促進することです。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         T. Haynes
Request for Comments: 7862                                  Primary Data
Category: Standards Track                                  November 2016
ISSN: 2070-1721
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Network File System (NFS) Version 4 Minor Version 2 Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ネットワークファイルシステム（NFS）バージョン4マイナーバージョン2プロトコル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes NFS version 4 minor version 2; it describes the protocol extensions made from NFS version 4 minor version 1. Major extensions introduced in NFS version 4 minor version 2 include the following: Server-Side Copy, Application Input/Output (I/O) Advise, Space Reservations, Sparse Files, Application Data Blocks, and Labeled NFS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、NFSバージョン4マイナーバージョン2について説明します。 NFSバージョン4マイナーバージョン1から作成されたプロトコル拡張機能について説明します。NFSバージョン4マイナーバージョン2で導入された主な拡張機能には、サーバー側コピー、アプリケーション入出力（I / O）アドバイス、スペース予約、スパースファイル、アプリケーションデータブロック、およびラベル付きNFS。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはInternet Standards Trackドキュメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。インターネット標準の詳細については、RFC 7841のセクション2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7862.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7862で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2016 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................4
      1.1. Requirements Language ......................................4
      1.2. Scope of This Document .....................................5
      1.3. NFSv4.2 Goals ..............................................5
      1.4. Overview of NFSv4.2 Features ...............................6
           1.4.1. Server-Side Clone and Copy ..........................6
           1.4.2. Application Input/Output (I/O) Advise ...............6
           1.4.3. Sparse Files ........................................6
           1.4.4. Space Reservation ...................................7
           1.4.5. Application Data Block (ADB) Support ................7
           1.4.6. Labeled NFS .........................................7
           1.4.7. Layout Enhancements .................................7
      1.5. Enhancements to Minor Versioning Model .....................7
   2. Minor Versioning ................................................8
   3. pNFS Considerations for New Operations ..........................9
      3.1. Atomicity for ALLOCATE and DEALLOCATE ......................9
      3.2. Sharing of Stateids with NFSv4.1 ...........................9
      3.3. NFSv4.2 as a Storage Protocol in pNFS: The File
           Layout Type ................................................9
           3.3.1. Operations Sent to NFSv4.2 Data Servers .............9
   4. Server-Side Copy ...............................................10
      4.1. Protocol Overview .........................................10
           4.1.1. COPY Operations ....................................11
           4.1.2. Requirements for Operations ........................11
      4.2. Requirements for Inter-Server Copy ........................13
      4.3. Implementation Considerations .............................13
           4.3.1. Locking the Files ..................................13
           4.3.2. Client Caches ......................................14
      4.4. Intra-Server Copy .........................................14
      4.5. Inter-Server Copy .........................................16
      4.6. Server-to-Server Copy Protocol ............................19
           4.6.1. Considerations on Selecting a Copy Protocol ........19
           4.6.2. Using NFSv4.x as the Copy Protocol .................19
           4.6.3. Using an Alternative Copy Protocol .................20
      4.7. netloc4 - Network Locations ...............................21
      4.8. Copy Offload Stateids .....................................21
      4.9. Security Considerations for Server-Side Copy ..............22
           4.9.1. Inter-Server Copy Security .........................22
   5. Support for Application I/O Hints ..............................30
   6. Sparse Files ...................................................30
      6.1. Terminology ...............................................31
      6.2. New Operations ............................................32
           6.2.1. READ_PLUS ..........................................32
           6.2.2. DEALLOCATE .........................................32
   7. Space Reservation ..............................................32
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   8. Application Data Block Support .................................34
      8.1. Generic Framework .........................................35
           8.1.1. Data Block Representation ..........................36
      8.2. An Example of Detecting Corruption ........................36
      8.3. An Example of READ_PLUS ...................................38
      8.4. An Example of Zeroing Space ...............................39
   9. Labeled NFS ....................................................39
      9.1. Definitions ...............................................40
      9.2. MAC Security Attribute ....................................41
           9.2.1. Delegations ........................................41
           9.2.2. Permission Checking ................................42
           9.2.3. Object Creation ....................................42
           9.2.4. Existing Objects ...................................42
           9.2.5. Label Changes ......................................42
      9.3. pNFS Considerations .......................................43
      9.4. Discovery of Server Labeled NFS Support ...................43
      9.5. MAC Security NFS Modes of Operation .......................43
           9.5.1. Full Mode ..........................................44
           9.5.2. Limited Server Mode ................................45
           9.5.3. Guest Mode .........................................45
      9.6. Security Considerations for Labeled NFS ...................46
   10. Sharing Change Attribute Implementation Characteristics
       with NFSv4 Clients ............................................46
   11. Error Values ..................................................47
      11.1. Error Definitions ........................................47
           11.1.1. General Errors ....................................47
           11.1.2. Server-to-Server Copy Errors ......................47
           11.1.3. Labeled NFS Errors ................................48
      11.2. New Operations and Their Valid Errors ....................49
      11.3. New Callback Operations and Their Valid Errors ...........53
   12. New File Attributes ...........................................54
      12.1. New RECOMMENDED Attributes - List and Definition
            References ...............................................54
      12.2. Attribute Definitions ....................................54
   13. Operations: REQUIRED, RECOMMENDED, or OPTIONAL ................57
   14. Modifications to NFSv4.1 Operations ...........................61
      14.1. Operation 42: EXCHANGE_ID - Instantiate the client ID ....61
      14.2. Operation 48: GETDEVICELIST - Get all device
            mappings for a file system ...............................63
   15. NFSv4.2 Operations ............................................64
      15.1. Operation 59: ALLOCATE - Reserve space in a
            region of a file .........................................64
      15.2. Operation 60: COPY - Initiate a server-side copy .........65
      15.3. Operation 61: COPY_NOTIFY - Notify a source
            server of a future copy ..................................70
      15.4. Operation 62: DEALLOCATE - Unreserve space in a
            region of a file .........................................72
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
      15.5. Operation 63: IO_ADVISE - Send client I/O access
            pattern hints to the server ..............................73
      15.6. Operation 64: LAYOUTERROR - Provide errors for
            the layout ...............................................79
      15.7. Operation 65: LAYOUTSTATS - Provide statistics
            for the layout ...........................................82
      15.8. Operation 66: OFFLOAD_CANCEL - Stop an offloaded
            operation ................................................84
      15.9. Operation 67: OFFLOAD_STATUS - Poll for the
            status of an asynchronous operation ......................85
      15.10. Operation 68: READ_PLUS - READ data or holes
             from a file .............................................86
      15.11. Operation 69: SEEK - Find the next data or hole .........91
      15.12. Operation 70: WRITE_SAME - WRITE an ADB multiple
             times to a file .........................................92
      15.13. Operation 71: CLONE - Clone a range of a file
             into another file .......................................96
   16. NFSv4.2 Callback Operations ...................................98
      16.1. Operation 15: CB_OFFLOAD - Report the results of
            an asynchronous operation ................................98
   17. Security Considerations .......................................99
   18. IANA Considerations ...........................................99
   19. References ...................................................100
      19.1. Normative References ....................................100
      19.2. Informative References ..................................101
   Acknowledgments ..................................................103
   Author&#39;s Address .................................................104
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 minor version 2 (NFSv4.2) protocol is the third minor version of the NFS version 4 (NFSv4) protocol. The first minor version, NFSv4.0, is described in [RFC7530], and the second minor version, NFSv4.1, is described in [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4マイナーバージョン2（NFSv4.2）プロトコルは、NFSバージョン4（NFSv4）プロトコルの3番目のマイナーバージョンです。最初のマイナーバージョンであるNFSv4.0は[RFC7530]で説明されており、2番目のマイナーバージョンであるNFSv4.1は[RFC5661]で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a minor version, NFSv4.2 is consistent with the overall goals for NFSv4, but NFSv4.2 extends the protocol so as to better meet those goals, based on experiences with NFSv4.1. In addition, NFSv4.2 has adopted some additional goals, which motivate some of the major extensions in NFSv4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイナーバージョンとして、NFSv4.2はNFSv4の全体的な目標と一致していますが、NFSv4.2は、NFSv4.1の経験に基づいて、これらの目標をよりよく満たすようにプロトコルを拡張します。さらに、NFSv4.2は、NFSv4.2の主要な拡張機能のいくつかを動機付けるいくつかの追加目標を採用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-1--Requirements-Language">
1.1. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 要件言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [RFC2119]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-2--Scope-of-This-Document">
1.2. Scope of This Document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. このドキュメントの範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes the NFSv4.2 protocol as a set of extensions to the specification for NFSv4.1. That specification remains current and forms the basis for the additions defined herein. The specification for NFSv4.0 remains current as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、NFSv4.2プロトコルをNFSv4.1の仕様の拡張セットとして説明しています。その仕様は最新のままであり、ここで定義される追加の基礎を形成します。 NFSv4.0の仕様も最新のままです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is necessary to implement all the REQUIRED features of NFSv4.1 before adding NFSv4.2 features to the implementation. With respect to NFSv4.0 and NFSv4.1, this document does not:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2機能を実装に追加する前に、NFSv4.1のすべての必須機能を実装する必要があります。 NFSv4.0とNFSv4.1に関して、このドキュメントは以下を行いません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o describe the NFSv4.0 or NFSv4.1 protocols, except where needed to contrast with NFSv4.2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.2と対比する必要がある場合を除いて、NFSv4.0またはNFSv4.1プロトコルについて説明する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o modify the specification of the NFSv4.0 or NFSv4.1 protocols
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.0またはNFSv4.1プロトコルの仕様を変更する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o clarify the NFSv4.0 or NFSv4.1 protocols -- that is, any clarifications made here apply only to NFSv4.2 and not to NFSv4.0 or NFSv4.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.0またはNFSv4.1プロトコルを明確にします。つまり、ここで行ったすべての明確化はNFSv4.2にのみ適用され、NFSv4.0またはNFSv4.1には適用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2 is a superset of NFSv4.1, with all of the new features being optional. As such, NFSv4.2 maintains the same compatibility that NFSv4.1 had with NFSv4.0. Any interactions of a new feature with NFSv4.1 semantics is described in the relevant text.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2はNFSv4.1のスーパーセットであり、すべての新機能はオプションです。そのため、NFSv4.2はNFSv4.1がNFSv4.0と持っていたのと同じ互換性を維持します。新機能とNFSv4.1セマンティクスの相互作用については、関連するテキストで説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The full External Data Representation (XDR) [RFC4506] for NFSv4.2 is presented in [RFC7863].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2の完全な外部データ表現（XDR）[RFC4506]は、[RFC7863]で提示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-3--NFSv4-2-Goals">
1.3. NFSv4.2 Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. NFSv4.2の目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A major goal of the enhancements provided in NFSv4.2 is to take common local file system features that have not been available through earlier versions of NFS and to offer them remotely. These features might
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2で提供される機能拡張の主な目的は、以前のバージョンのNFSでは利用できなかった一般的なローカルファイルシステム機能を利用して、リモートで提供することです。これらの機能は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o already be available on the servers, e.g., sparse files
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o すでにスパースファイルなどのサーバーで利用可能
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o be under development as a new standard, e.g., SEEK pulls in both SEEK_HOLE and SEEK_DATA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 新しい標準として開発中です。たとえば、SEEKはSEEK_HOLEとSEEK_DATAの両方を取り込みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o be used by clients with the servers via some proprietary means, e.g., Labeled NFS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ラベル付きNFSなどの独自の手段を介してクライアントとサーバーを使用する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2 provides means for clients to leverage these features on the server in cases in which such leveraging had previously not been possible within the confines of the NFS protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2は、NFSプロトコルの範囲内でこれまでそのような活用が不可能であった場合に、クライアントがサーバー上のこれらの機能を活用する手段を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4--Overview-of-NFSv4-2-Features">
1.4. Overview of NFSv4.2 Features
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. NFSv4.2機能の概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4-1--Server-Side-Clone-and-Copy">
1.4.1. Server-Side Clone and Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.1. サーバー側のクローンとコピー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A traditional file copy of a remotely accessed file, whether from one server to another or between locations in the same server, results in the data being put on the network twice -- source to client and then client to destination. New operations are introduced to allow unnecessary traffic to be eliminated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リモートでアクセスされるファイルの従来のファイルコピーでは、あるサーバーから別のサーバーへ、または同じサーバー内の場所間で、データがネットワークに2回送信されます（ソースからクライアントへ、次にクライアントから宛先へ）。不要なトラフィックを排除するための新しい操作が導入されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The intra-server CLONE feature allows the client to request a synchronous cloning, perhaps by copy-on-write semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバー内のCLONE機能を使用すると、クライアントは、おそらくコピーオンライトセマンティクスによって同期クローンを要求できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The intra-server COPY feature allows the client to request the server to perform the copy internally, avoiding unnecessary network traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバー内のCOPY機能により、クライアントはサーバーに内部的にコピーを実行するように要求でき、不要なネットワークトラフィックを回避できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The inter-server COPY feature allows the client to authorize the source and destination servers to interact directly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバー間のCOPY機能により、クライアントはソースサーバーと宛先サーバーが直接対話することを承認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As such copies can be lengthy, asynchronous support is also provided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このようなコピーは長くなる可能性があるため、非同期サポートも提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4-2--Application-InputOutput-IO-Advise">
1.4.2. Application Input/Output (I/O) Advise
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.2. アプリケーション入出力（I / O）アドバイス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications and clients want to advise the server as to expected I/O behavior. Using IO_ADVISE (see Section 15.5) to communicate future I/O behavior such as whether a file will be accessed sequentially or randomly, and whether a file will or will not be accessed in the near future, allows servers to optimize future I/O requests for a file by, for example, prefetching or evicting data. This operation can be used to support the posix_fadvise() [posix_fadvise] function. In addition, it may be helpful to applications such as databases and video editors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションとクライアントは、予想されるI / O動作についてサーバーに通知する必要があります。 IO_ADVISE（セクション15.5を参照）を使用して、ファイルが順次またはランダムにアクセスされるかどうか、ファイルが近い将来アクセスされるかどうかなどの将来のI / O動作を通信することにより、サーバーは将来のI / O要求を最適化できますたとえば、データのプリフェッチまたは削除によるファイルの場合。この操作を使用して、posix_fadvise()[posix_fadvise]関数をサポートできます。さらに、データベースやビデオエディタなどのアプリケーションにも役立つ場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4-3--Sparse-Files">
1.4.3. Sparse Files
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3. スパースファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sparse files are files that have unallocated or uninitialized data blocks as holes in the file. Such holes are typically transferred as zeros when read from the file. READ_PLUS (see Section 15.10) allows a server to send back to the client metadata describing the hole, and DEALLOCATE (see Section 15.4) allows the client to punch holes into a file. In addition, SEEK (see Section 15.11) is provided to scan for the next hole or data from a given location.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スパースファイルとは、未割り当てまたは初期化されていないデータブロックがファイルの穴として存在するファイルです。このような穴は、通常、ファイルから読み取られるときにゼロとして転送されます。 READ_PLUS（セクション15.10を参照）を使用すると、サーバーはクライアントにホールを説明するメタデータを送り返すことができ、DEALLOCATE（セクション15.4を参照）を使用すると、クライアントはファイルにホールをパンチできます。さらに、SEEK（セクション15.11を参照）が提供され、特定の場所から次の穴またはデータをスキャンします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4-4--Space-Reservation">
1.4.4. Space Reservation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.4. スペース予約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a file is sparse, one concern that applications have is ensuring that there will always be enough data blocks available for the file during future writes. ALLOCATE (see Section 15.1) allows a client to request a guarantee that space will be available. Also, DEALLOCATE (see Section 15.4) allows the client to punch a hole into a file, thus releasing a space reservation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルがスパースである場合、アプリケーションが懸念することの1つは、将来の書き込み時に、ファイルに使用できる十分なデータブロックが常に確保されることです。 ALLOCATE（セクション15.1を参照）により、クライアントはスペースが利用可能であるという保証を要求できます。また、DEALLOCATE（セクション15.4を参照）を使用すると、クライアントはファイルに穴を開け、スペースの予約を解放できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4-5--Application-Data-Block-ADB-Support">
1.4.5. Application Data Block (ADB) Support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.5. アプリケーションデータブロック（ADB）のサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some applications treat a file as if it were a disk and as such want to initialize (or format) the file image. The WRITE_SAME operation (see Section 15.12) is introduced to send this metadata to the server to allow it to write the block contents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のアプリケーションは、ファイルをディスクのように扱い、ファイルイメージを初期化（またはフォーマット）したい場合があります。 WRITE_SAME操作（セクション15.12を参照）が導入され、このメタデータをサーバーに送信して、サーバーがブロックの内容を書き込めるようになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4-6--Labeled-NFS">
1.4.6. Labeled NFS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.6. ラベル付きNFS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While both clients and servers can employ Mandatory Access Control (MAC) security models to enforce data access, there has been no protocol support for interoperability. A new file object attribute, sec_label (see Section 12.2.4), allows the server to store MAC labels on files, which the client retrieves and uses to enforce data access (see Section 9.5.3). The format of the sec_label accommodates any MAC security system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーの両方で強制アクセス制御（MAC）セキュリティモデルを使用してデータアクセスを実施できますが、相互運用性をサポートするプロトコルはありませんでした。新しいファイルオブジェクト属性であるsec_l​​abel（セクション12.2.4を参照）を使用すると、サーバーはファイルにMACラベルを保存でき、クライアントはこれを取得して、データアクセスを強制するために使用します（セクション9.5.3を参照）。 sec_l​​abelのフォーマットは、あらゆるMACセキュリティシステムに対応しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-4-7--Layout-Enhancements">
1.4.7. Layout Enhancements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.7. レイアウトの機能強化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the parallel NFS implementations of NFSv4.1 (see Section 12 of [RFC5661]), the client cannot communicate back to the metadata server any errors or performance characteristics with the storage devices. NFSv4.2 provides two new operations to do so: LAYOUTERROR (see Section 15.6) and LAYOUTSTATS (see Section 15.7), respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1の並列NFS実装（[RFC5661]のセクション12を参照）では、クライアントはストレージデバイスとのエラーやパフォーマンス特性をメタデータサーバーに通信できません。 NFSv4.2には、LAYOUTERROR（セクション15.6を参照）とLAYOUTSTATS（セクション15.7を参照）という2つの新しい操作がそれぞれ用意されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-5--Enhancements-to-Minor-Versioning-Model">
1.5. Enhancements to Minor Versioning Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.5. マイナーバージョン管理モデルの機能強化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In NFSv4.1, the only way to introduce new variants of an operation was to introduce a new operation. For instance, READ would have to be replaced or supplemented by, say, either READ2 or READ_PLUS. With the use of discriminated unions as parameters for such functions in NFSv4.2, it is possible to add a new &#34;arm&#34; (i.e., a new entry in the union and a corresponding new field in the structure) in a subsequent minor version. It is also possible to move such an operation from OPTIONAL/RECOMMENDED to REQUIRED. Forcing an implementation to adopt each arm of a discriminated union at such a time does not meet the spirit of the minor versioning rules. As such, new arms of a discriminated union MUST follow the same guidelines for minor versioning as operations in NFSv4.1 -- i.e., they may not be made REQUIRED. To support this, a new error code, NFS4ERR_UNION_NOTSUPP, allows the server to communicate to the client that the operation is supported but the specific arm of the discriminated union is not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
NFSv4.1では、操作の新しいバリアントを導入する唯一の方法は、新しい操作を導入することでした。たとえば、READは、たとえばREAD2またはREAD_PLUSのいずれかに置き換えるか、補足する必要があります。 NFSv4.2でこのような関数のパラメーターとして識別された共用体を使用すると、後続のマイナーバージョンに新しい「アーム」（つまり、共用体の新しいエントリと対応する構造体の新しいフィールド）を追加できます。このような操作をOPTIONAL / RECOMMENDEDからREQUIREDに移動することもできます。そのようなときに、差別化された労働組合の各部門を採用するように実装を強制することは、マイナーバージョン管理ルールの精神を満たしていません。そのため、差別化された労働組合の新しい武器は、NFSv4.1での操作と同じマイナーバージョニングのガイドラインに準拠する必要があります。つまり、それらを必須にすることはできません。これをサポートするために、新しいエラーコードNFS4ERR_UNION_NOTSUPPを使用すると、サーバーはクライアントと通信でき、操作はサポートされますが、識別された共用体の特定のアームはサポートされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Minor-Versioning">
2. Minor Versioning
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. マイナーバージョン管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2 is a minor version of NFSv4 and is built upon NFSv4.1 as documented in [RFC5661] and [RFC5662].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2はNFSv4のマイナーバージョンであり、[RFC5661]および[RFC5662]で文書化されているようにNFSv4.1に基づいて構築されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2 does not modify the rules applicable to the NFSv4 versioning process and follows the rules set out in [RFC5661] or in Standards Track documents updating that document (e.g., in an RFC based on [NFSv4-Versioning]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2は、NFSv4バージョン管理プロセスに適用されるルールを変更せず、[RFC5661]またはそのドキュメントを更新するStandards Trackドキュメント（たとえば、[NFSv4-Versioning]に基づくRFC）で設定されたルールに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2 only defines extensions to NFSv4.1, each of which may be supported (or not) independently. It does not
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2は、NFSv4.1への拡張のみを定義します。各拡張は、独立してサポートされている（またはサポートされていない）場合があります。それはしません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o introduce infrastructural features
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o インフラストラクチャ機能を紹介する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o make existing features MANDATORY to NOT implement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 実装しないように既存の機能を必須にする
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o change the status of existing features (i.e., by changing their status among OPTIONAL, RECOMMENDED, REQUIRED)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 既存の機能のステータスを変更する（つまり、オプション、推奨、必須の間でステータスを変更する）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following versioning-related considerations should be noted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のバージョン管理関連の考慮事項に注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a new case is added to an existing switch, servers need to report non-support of that new case by returning NFS4ERR_UNION_NOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 新しいケースが既存のスイッチに追加されると、サーバーはNFS4ERR_UNION_NOTSUPPを返すことにより、その新しいケースの非サポートを報告する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o As regards the potential cross-minor-version transfer of stateids, Parallel NFS (pNFS) (see Section 12 of [RFC5661]) implementations of the file-mapping type may support the use of an NFSv4.2 metadata server (see Sections 1.7.2.2 and 12.2.2 of [RFC5661]) with NFSv4.1 data servers. In this context, a stateid returned by an NFSv4.2 COMPOUND will be used in an NFSv4.1 COMPOUND directed to the data server (see Sections 3.2 and 3.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o マイナーバージョン間のステートIDの転送の可能性に関して、Parallel NFS（pNFS）（[RFC5661]のセクション12を参照）の実装では、ファイルマッピングタイプのNFSv4.2メタデータサーバーの使用をサポートする場合があります（セクション1.7を参照）。 [RFC5661]の2.2および12.2.2）とNFSv4.1データサーバー。このコンテキストでは、NFSv4.2 COMPOUNDによって返される状態IDは、データサーバーに向けられたNFSv4.1 COMPOUNDで使用されます（セクション3.2および3.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--pNFS-Considerations-for-New-Operations">
3. pNFS Considerations for New Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 新しい操作に関するpNFSの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The interactions of the new operations with non-pNFS functionality are straightforward and are covered in the relevant sections. However, the interactions of the new operations with pNFS are more complicated. This section provides an overview.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい操作と非pNFS機能の相互作用は簡単で、関連するセクションで説明されています。ただし、新しい操作とpNFSの相互作用はより複雑です。このセクションでは、概要を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Atomicity-for-ALLOCATE-and-DEALLOCATE">
3.1. Atomicity for ALLOCATE and DEALLOCATE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. ALLOCATEおよびDEALLOCATEの原子性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both ALLOCATE (see Section 15.1) and DEALLOCATE (see Section 15.4) are sent to the metadata server, which is responsible for coordinating the changes onto the storage devices. In particular, both operations must either fully succeed or fail; it cannot be the case that one storage device succeeds whilst another fails.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ALLOCATE（セクション15.1を参照）とDEALLOCATE（セクション15.4を参照）の両方がメタデータサーバーに送信されます。メタデータサーバーは、ストレージデバイスへの変更を調整します。特に、両方の操作は完全に成功または失敗する必要があります。あるストレージデバイスが成功し、別のストレージデバイスが失敗することはあり得ません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--Sharing-of-Stateids-with-NFSv4-1">
3.2. Sharing of Stateids with NFSv4.1
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. NFSv4.1でのStateidの共有
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An NFSv4.2 metadata server can hand out a layout to an NFSv4.1 storage device. Section 13.9.1 of [RFC5661] discusses how the client gets a stateid from the metadata server to present to a storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2メタデータサーバーは、レイアウトをNFSv4.1ストレージデバイスに渡すことができます。 [RFC5661]のセクション13.9.1は、クライアントがメタデータサーバーからstateidを取得してストレージデバイスに提示する方法について説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--NFSv4-2-as-a-Storage-Protocol-in-pNFS-The-File-Layout-Type">
3.3. NFSv4.2 as a Storage Protocol in pNFS: The File Layout Type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. pNFSのストレージプロトコルとしてのNFSv4.2：ファイルレイアウトタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A file layout provided by an NFSv4.2 server may refer to either (1) a storage device that only implements NFSv4.1 as specified in [RFC5661] or (2) a storage device that implements additions from NFSv4.2, in which case the rules in Section 3.3.1 apply. As the file layout type does not provide a means for informing the client as to which minor version a particular storage device is providing, the client will have to negotiate this with the storage device via the normal Remote Procedure Call (RPC) semantics of major and minor version discovery. For example, as per Section 16.2.3 of [RFC5661], the client could try a COMPOUND with a minorversion field value of 2; if it gets NFS4ERR_MINOR_VERS_MISMATCH, it would drop back to 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2サーバーによって提供されるファイルレイアウトは、（1）[RFC5661]で指定されているようにNFSv4.1のみを実装するストレージデバイス、または（2）NFSv4.2からの追加を実装するストレージデバイスのいずれかを指します。セクション3.3.1のルールが適用されます。ファイルレイアウトタイプは、特定のストレージデバイスが提供しているマイナーバージョンについてクライアントに通知する手段を提供しないため、メジャーおよび通常のリモートプロシージャコール（RPC）セマンティクスを介して、クライアントはこれをストレージデバイスとネゴシエートする必要があります。マイナーバージョンの発見。たとえば、[RFC5661]のセクション16.2.3に従って、クライアントはマイナーバージョンフィールド値が2のCOMPOUNDを試すことができます。 NFS4ERR_MINOR_VERS_MISMATCHを取得すると、1に戻ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3-1--Operations-Sent-to-NFSv4-2-Data-Servers">
3.3.1. Operations Sent to NFSv4.2 Data Servers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. NFSv4.2データサーバーに送信される操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to the commands listed in [RFC5661], NFSv4.2 data servers MAY accept a COMPOUND containing the following additional operations: IO_ADVISE (see Section 15.5), READ_PLUS (see Section 15.10), WRITE_SAME (see Section 15.12), and SEEK (see Section 15.11), which will be treated like the subset specified as &#34;Operations Sent to NFSv4.1 Data Servers&#34; in Section 13.6 of [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661]にリストされているコマンドに加えて、NFSv4.2データサーバーは、IO_ADVISE（セクション15.5を参照）、READ_PLUS（セクション15.10を参照）、WRITE_SAME（セクション15.12を参照）、およびSEEK（ [RFC5661]のセクション13.6で「NFSv4.1データサーバーに送信される操作」として指定されたサブセットのように扱われるセクション15.11を参照）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional details on the implementation of these operations in a pNFS context are documented in the operation-specific sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの操作のpNFSコンテキストでの実装に関する詳細は、操作固有のセクションに記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Server-Side-Copy">
4. Server-Side Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. サーバー側のコピー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server-side copy features provide mechanisms that allow an NFS client to copy file data on a server or between two servers without the data being transmitted back and forth over the network through the NFS client. Without these features, an NFS client would copy data from one location to another by reading the data from the source server over the network and then writing the data back over the network to the destination server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー側のコピー機能は、NFSクライアントがNFSクライアントを介してネットワーク経由でデータを送受信することなく、サーバーまたは2つのサーバー間でファイルデータをコピーできるメカニズムを提供します。これらの機能がない場合、NFSクライアントは、ネットワーク経由でソースサーバーからデータを読み取り、ネットワーク経由で宛先サーバーにデータを書き戻すことによって、ある場所から別の場所にデータをコピーします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the source object and destination object are on different file servers, the file servers will communicate with one another to perform the COPY operation. The server-to-server protocol by which this is accomplished is not defined in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースオブジェクトと宛先オブジェクトが異なるファイルサーバーにある場合、ファイルサーバーは相互に通信してCOPY操作を実行します。これを実現するサーバー間プロトコルは、このドキュメントでは定義されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The copy feature allows the server to perform the copying either synchronously or asynchronously. The client can request synchronous copying, but the server may not be able to honor this request. If the server intends to perform asynchronous copying, it supplies the client with a request identifier that the client can use to monitor the progress of the copying and, if appropriate, cancel a request in progress. The request identifier is a stateid representing the internal state held by the server while the copying is performed. Multiple asynchronous copies of all or part of a file may be in progress in parallel on a server; the stateid request identifier allows monitoring and canceling to be applied to the correct request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コピー機能により、サーバーは同期的または非同期的にコピーを実行できます。クライアントは同期コピーを要求できますが、サーバーはこの要求を受け入れることができない場合があります。サーバーが非同期コピーを実行する場合、サーバーはクライアントにリクエスト識別子を提供し、クライアントがコピーの進行状況を監視し、必要に応じて進行中のリクエストをキャンセルすることができます。要求識別子は、コピーが実行されている間、サーバーが保持する内部状態を表すstateidです。ファイルのすべてまたは一部の複数の非同期コピーがサーバー上で並行して進行している可能性があります。 stateidリクエスト識別子により、監視とキャンセルを正しいリクエストに適用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Protocol-Overview">
4.1. Protocol Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. プロトコルの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server-side copy offload operations support both intra-server and inter-server file copies. An intra-server copy is a copy in which the source file and destination file reside on the same server. In an inter-server copy, the source file and destination file are on different servers. In both cases, the copy may be performed synchronously or asynchronously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー側のコピーオフロード操作は、サーバー内とサーバー間のファイルコピーの両方をサポートします。サーバー内コピーは、ソースファイルと宛先ファイルが同じサーバーに存在するコピーです。サーバー間コピーでは、ソースファイルと宛先ファイルが異なるサーバー上にあります。どちらの場合も、コピーは同期または非同期で実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, the CLONE operation provides COPY-like functionality in the intra-server case, which is both synchronous and atomic in that other operations may not see the target file in any state between the state before the CLONE operation and the state after it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、CLONE操作はサーバー内の場合にCOPYに似た機能を提供します。これは同期的かつアトミックであり、他の操作はCLONE操作前の状態とその後の状態の間のどの状態でもターゲットファイルを認識できない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Throughout the rest of this document, the NFS server containing the source file is referred to as the &#34;source server&#34; and the NFS server to which the file is transferred as the &#34;destination server&#34;. In the case of an intra-server copy, the source server and destination server are the same server. Therefore, in the context of an intra-server copy, the terms &#34;source server&#34; and &#34;destination server&#34; refer to the single server performing the copy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの残りの部分では、ソースファイルを含むNFSサーバーを「ソースサーバー」と呼び、ファイルの転送先のNFSサーバーを「宛先サーバー」と呼びます。サーバー内コピーの場合、ソースサーバーと宛先サーバーは同じサーバーです。したがって、サーバー内コピーのコンテキストでは、「ソースサーバー」と「宛先サーバー」という用語は、コピーを実行する単一のサーバーを指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The new operations are designed to copy files or regions within them. Other file system objects can be copied by building on these operations or using other techniques. For example, if a user wishes to copy a directory, the client can synthesize a directory COPY operation by first creating the destination directory and the individual (empty) files within it and then copying the contents of the source directory&#39;s files to files in the new destination directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい操作は、ファイルまたはその中のリージョンをコピーするように設計されています。他のファイルシステムオブジェクトは、これらの操作に基づいて、または他の手法を使用してコピーできます。たとえば、ユーザーがディレクトリをコピーしたい場合、クライアントは、最初に宛先ディレクトリとその中の個々の（空の）ファイルを作成し、次にソースディレクトリのファイルの内容を新しいディレクトリ内のファイルにコピーすることにより、ディレクトリCOPY操作を合成できます。宛先ディレクトリ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the inter-server copy, the operations are defined to be compatible with the traditional copy authorization approach. The client and user are authorized at the source for reading. Then, they are authorized at the destination for writing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー間コピーの場合、操作は、従来のコピー許可アプローチと互換性があるように定義されています。クライアントとユーザーは、ソースで読み取りを許可されます。次に、宛先で書き込みが許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1-1--COPY-Operations">
4.1.1. COPY Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. コピー操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLONE: Used by the client to request a synchronous atomic COPY-like operation. (Section 15.13)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLONE：クライアントが同期のアトミックCOPYのような操作を要求するために使用します。 （セクション15.13）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPY_NOTIFY: Used by the client to request the source server to authorize a future file copy that will be made by a given destination server on behalf of the given user. (Section 15.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPY_NOTIFY：特定のユーザーの代わりに特定の宛先サーバーによって作成される将来のファイルコピーを承認するようにソースサーバーに要求するためにクライアントによって使用されます。 （セクション15.3）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPY: Used by the client to request a file copy. (Section 15.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPY：クライアントがファイルのコピーを要求するために使用します。 （セクション15.2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OFFLOAD_CANCEL: Used by the client to terminate an asynchronous file copy. (Section 15.8)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OFFLOAD_CANCEL：非同期ファイルコピーを終了するためにクライアントによって使用されます。 （セクション15.8）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OFFLOAD_STATUS: Used by the client to poll the status of an asynchronous file copy. (Section 15.9)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OFFLOAD_STATUS：クライアントが非同期ファイルコピーのステータスをポーリングするために使用します。 （セクション15.9）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_OFFLOAD: Used by the destination server to report the results of an asynchronous file copy to the client. (Section 16.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_OFFLOAD：非同期のファイルコピーの結果をクライアントに報告するために宛先サーバーで使用されます。 （セクション16.1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1-2--Requirements-for-Operations">
4.1.2. Requirements for Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. 運用の要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inter-server copy, intra-server copy, and intra-server clone are each OPTIONAL features in the context of server-side copy. A server may choose independently to implement any of them. A server implementing any of these features may be REQUIRED to implement certain operations. Other operations are OPTIONAL in the context of a particular feature (see Table 5 in Section 13) but may become REQUIRED, depending on server behavior. Clients need to use these operations to successfully copy a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー間コピー、サーバー内コピー、およびサーバー内複製は、サーバー側コピーのコンテキストでは、それぞれオプションの機能です。サーバーは、それらのいずれかを実装するために独立して選択できます。これらの機能のいずれかを実装するサーバーは、特定の操作を実装するために必要になる場合があります。他の操作は、特定の機能のコンテキストではオプションですが（セクション13の表5を参照）、サーバーの動作によっては必須になる場合があります。クライアントは、ファイルを正常にコピーするためにこれらの操作を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a client to do an intra-server file copy, it needs to use either the COPY or the CLONE operation. If COPY is used, the client MUST support the CB_OFFLOAD operation. If COPY is used and it returns a stateid, then the client MAY use the OFFLOAD_CANCEL and OFFLOAD_STATUS operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがサーバー内のファイルコピーを行うには、COPYまたはCLONE操作を使用する必要があります。 COPYを使用する場合、クライアントはCB_OFFLOAD操作をサポートする必要があります。 COPYが使用され、stateidが返される場合、クライアントはOFFLOAD_CANCELおよびOFFLOAD_STATUS操作を使用できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a client to do an inter-server file copy, it needs to use the COPY and COPY_NOTIFY operations and MUST support the CB_OFFLOAD operation. If COPY returns a stateid, then the client MAY use the OFFLOAD_CANCEL and OFFLOAD_STATUS operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがサーバー間ファイルのコピーを行うには、COPYおよびCOPY_NOTIFY操作を使用する必要があり、CB_OFFLOAD操作をサポートする必要があります。 COPYがstateidを返す場合、クライアントはOFFLOAD_CANCELおよびOFFLOAD_STATUS操作を使用できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server supports the intra-server COPY feature, then the server MUST support the COPY operation. If a server&#39;s COPY operation returns a stateid, then the server MUST also support these operations: CB_OFFLOAD, OFFLOAD_CANCEL, and OFFLOAD_STATUS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがサーバー内COPY機能をサポートする場合、サーバーはCOPY操作をサポートする必要があります。サーバーのCOPY操作がstateidを返す場合、サーバーはこれらの操作もサポートする必要があります：CB_OFFLOAD、OFFLOAD_CANCEL、およびOFFLOAD_STATUS。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server supports the CLONE feature, then it MUST support the CLONE operation and the clone_blksize attribute on any file system on which CLONE is supported (as either source or destination file).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがCLONE機能をサポートする場合は、CLONEがサポートされているファイルシステム（ソースファイルまたは宛先ファイルのいずれか）でCLONE操作とclone_blksize属性をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a source server supports the inter-server COPY feature, then it MUST support the COPY_NOTIFY and OFFLOAD_CANCEL operations. If a destination server supports the inter-server COPY feature, then it MUST support the COPY operation. If a destination server&#39;s COPY operation returns a stateid, then the destination server MUST also support these operations: CB_OFFLOAD, OFFLOAD_CANCEL, COPY_NOTIFY, and OFFLOAD_STATUS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースサーバーがサーバー間のCOPY機能をサポートしている場合は、COPY_NOTIFYおよびOFFLOAD_CANCEL操作をサポートする必要があります。宛先サーバーがサーバー間COPY機能をサポートしている場合、COPY操作をサポートする必要があります。宛先サーバーのCOPY操作がstateidを返す場合、宛先サーバーは次の操作もサポートする必要があります（CB_OFFLOAD、OFFLOAD_CANCEL、COPY_NOTIFY、およびOFFLOAD_STATUS）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each operation is performed in the context of the user identified by the Open Network Computing (ONC) RPC credential in the RPC request containing the COMPOUND or CB_COMPOUND request. For example, an OFFLOAD_CANCEL operation issued by a given user indicates that a specified COPY operation initiated by the same user is to be canceled. Therefore, an OFFLOAD_CANCEL MUST NOT interfere with a copy of the same file initiated by another user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各操作は、COMPOUNDまたはCB_COMPOUND要求を含むRPC要求のOpen Network Computing（ONC）RPC資格情報によって識別されるユーザーのコンテキストで実行されます。たとえば、特定のユーザーが発行したOFFLOAD_CANCEL操作は、同じユーザーが開始した指定のCOPY操作がキャンセルされることを示しています。したがって、OFFLOAD_CANCELは、別のユーザーが開始した同じファイルのコピーを妨害してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An NFS server MAY allow an administrative user to monitor or cancel COPY operations using an implementation-specific interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSサーバーは、管理ユーザーが実装固有のインターフェースを使用してCOPY操作を監視またはキャンセルできるようにする場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Requirements-for-Inter-Server-Copy">
4.2. Requirements for Inter-Server Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. サーバー間コピーの要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The specification of the inter-server copy is driven by several requirements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー間コピーの仕様は、いくつかの要件によって決まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The specification MUST NOT mandate the server-to-server protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 仕様はサーバー間プロトコルを義務付けてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The specification MUST provide guidance for using NFSv4.x as a copy protocol. For those source and destination servers willing to use NFSv4.x, there are specific security considerations that the specification MUST address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 仕様では、NFSv4.xをコピープロトコルとして使用するためのガイダンスを提供する必要があります。 NFSv4.xを使用することをいとわないソースサーバーと宛先サーバーについては、仕様が対処しなければならない特定のセキュリティ上の考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The specification MUST NOT mandate preconfiguration between the source and destination servers. Requiring that the source and destination servers first have a &#34;copying relationship&#34; increases the administrative burden. However, the specification MUST NOT preclude implementations that require preconfiguration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 仕様では、ソースサーバーと宛先サーバー間の事前構成を必須にしてはなりません。移行元サーバーと移行先サーバーに最初に「コピー関係」があることを要求すると、管理上の負担が増大します。ただし、仕様では、事前設定が必要な実装を排除してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The specification MUST NOT mandate a trust relationship between the source and destination servers. The NFSv4 security model requires mutual authentication between a principal on an NFS client and a principal on an NFS server. This model MUST continue with the introduction of COPY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 仕様は、ソースサーバーと宛先サーバー間の信頼関係を義務付けてはなりません。 NFSv4セキュリティモデルでは、NFSクライアントのプリンシパルとNFSサーバーのプリンシパル間の相互認証が必要です。このモデルは、COPYの導入を継続する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--Implementation-Considerations">
4.3. Implementation Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 実装に関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3-1--Locking-the-Files">
4.3.1. Locking the Files
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. ファイルをロックする
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both the source file and the destination file may need to be locked to protect the content during the COPY operations. A client can achieve this by a combination of OPEN and LOCK operations. That is, either share locks or byte-range locks might be desired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPY操作中にコンテンツを保護するために、ソースファイルと宛先ファイルの両方をロックする必要がある場合があります。クライアントは、OPEN操作とLOCK操作の組み合わせによってこれを実現できます。つまり、共有ロックまたはバイト範囲ロックのいずれかが必要になる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that when the client establishes a lock stateid on the source, the context of that stateid is for the client and not the destination. As such, there might already be an outstanding stateid, issued to the destination as the client of the source, with the same value as that provided for the lock stateid. The source MUST interpret the lock stateid as that of the client, i.e., when the destination presents it in the context of an inter-server copy, it is on behalf of the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがソースでロック状態IDを確立するとき、その状態IDのコンテキストは宛先ではなくクライアント用であることに注意してください。そのため、ソースのクライアントとして宛先に発行された未処理の状態IDがすでに存在する可能性があり、ロック状態IDに提供されたものと同じ値を持ちます。ソースはロック状態IDをクライアントのロックとして解釈する必要があります。つまり、宛先がサーバー間コピーのコンテキストでロック状態IDを提示すると、クライアントの代わりになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3-2--Client-Caches">
4.3.2. Client Caches
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. クライアントキャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a traditional copy, if the client is in the process of writing to the file before the copy (and perhaps with a write delegation), it will be straightforward to update the destination server. With an inter-server copy, the source has no insight into the changes cached on the client. The client SHOULD write the data back to the source. If it does not do so, it is possible that the destination will receive a corrupt copy of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
従来のコピーでは、クライアントがコピーの前に（おそらく書き込み委任を使用して）ファイルに書き込みを行っている場合、宛先サーバーを更新するのは簡単です。サーバー間コピーでは、ソースはクライアントにキャッシュされた変更を把握できません。クライアントはデータをソースに書き戻す必要があります（SHOULD）。そうしないと、宛先がファイルの破損したコピーを受け取る可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4--Intra-Server-Copy">
4.4. Intra-Server Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. サーバー内コピー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To copy a file on a single server, the client uses a COPY operation. The server may respond to the COPY operation with the final results of the copy, or it may perform the copy asynchronously and deliver the results using a CB_OFFLOAD callback operation. If the copy is performed asynchronously, the client may poll the status of the copy using OFFLOAD_STATUS or cancel the copy using OFFLOAD_CANCEL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一サーバー上のファイルをコピーするために、クライアントはCOPY操作を使用します。サーバーは、コピーの最終結果でCOPY操作に応答するか、非同期にコピーを実行し、CB_OFFLOADコールバック操作を使用して結果を配信します。コピーが非同期で実行される場合、クライアントはOFFLOAD_STATUSを使用してコピーのステータスをポーリングするか、OFFLOAD_CANCELを使用してコピーをキャンセルできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A synchronous intra-server copy is shown in Figure 1. In this example, the NFS server chooses to perform the copy synchronously. The COPY operation is completed, either successfully or unsuccessfully, before the server replies to the client&#39;s request. The server&#39;s reply contains the final result of the operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同期的なサーバー内コピーを図1に示します。この例では、NFSサーバーはコピーを同期的に実行することを選択します。 COPY操作は、サーバーがクライアントの要求に応答する前に、成功または失敗のいずれかで完了します。サーバーの応答には、操作の最終結果が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Client                                  Server
        +                                      +
        |                                      |
        |--- OPEN ----------------------------&gt;| Client opens
        |&lt;------------------------------------/| the source file
        |                                      |
        |--- OPEN ----------------------------&gt;| Client opens
        |&lt;------------------------------------/| the destination file
        |                                      |
        |--- COPY ----------------------------&gt;| Client requests
        |&lt;------------------------------------/| a file copy
        |                                      |
        |--- CLOSE ---------------------------&gt;| Client closes
        |&lt;------------------------------------/| the destination file
        |                                      |
        |--- CLOSE ---------------------------&gt;| Client closes
        |&lt;------------------------------------/| the source file
        |                                      |
        |                                      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
Figure 1: A Synchronous Intra-Server Copy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
図1：同期サーバー内コピー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An asynchronous intra-server copy is shown in Figure 2. In this example, the NFS server performs the copy asynchronously. The server&#39;s reply to the copy request indicates that the COPY operation was initiated and the final result will be delivered at a later time. The server&#39;s reply also contains a copy stateid. The client may use this copy stateid to poll for status information (as shown) or to cancel the copy using an OFFLOAD_CANCEL. When the server completes the copy, the server performs a callback to the client and reports the results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非同期のサーバー内コピーを図2に示します。この例では、NFSサーバーが非同期にコピーを実行します。コピー要求に対するサーバーの応答は、COPY操作が開始され、最終結果が後で配信されることを示しています。サーバーの応答には、コピーの状態IDも含まれます。クライアントは、このコピーの状態IDを使用して、ステータス情報（図に示されている）をポーリングするか、OFFLOAD_CANCELを使用してコピーをキャンセルします。サーバーがコピーを完了すると、サーバーはクライアントへのコールバックを実行し、結果を報告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Client                                  Server
        +                                      +
        |                                      |
        |--- OPEN ----------------------------&gt;| Client opens
        |&lt;------------------------------------/| the source file
        |                                      |
        |--- OPEN ----------------------------&gt;| Client opens
        |&lt;------------------------------------/| the destination file
        |                                      |
        |--- COPY ----------------------------&gt;| Client requests
        |&lt;------------------------------------/| a file copy
        |                                      |
        |                                      |
        |--- OFFLOAD_STATUS ------------------&gt;| Client may poll
        |&lt;------------------------------------/| for status
        |                                      |
        |                  .                   | Multiple OFFLOAD_STATUS
        |                  .                   | operations may be sent
        |                  .                   |
        |                                      |
        |&lt;-- CB_OFFLOAD -----------------------| Server reports results
        |\------------------------------------&gt;|
        |                                      |
        |--- CLOSE ---------------------------&gt;| Client closes
        |&lt;------------------------------------/| the destination file
        |                                      |
        |--- CLOSE ---------------------------&gt;| Client closes
        |&lt;------------------------------------/| the source file
        |                                      |
        |                                      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
Figure 2: An Asynchronous Intra-Server Copy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
図2：非同期のサーバー内コピー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-5--Inter-Server-Copy">
4.5. Inter-Server Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. サーバー間コピー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A copy may also be performed between two servers. The copy protocol is designed to accommodate a variety of network topologies. As shown in Figure 3, the client and servers may be connected by multiple networks. In particular, the servers may be connected by a specialized, high-speed network (network 192.0.2.0/24 in the diagram) that does not include the client. The protocol allows the client to set up the copy between the servers (over network 203.0.113.0/24 in the diagram) and for the servers to communicate on the high-speed network if they choose to do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのサーバー間でコピーを実行することもできます。コピープロトコルは、さまざまなネットワークトポロジに対応するように設計されています。図3に示すように、クライアントとサーバーは複数のネットワークで接続されている場合があります。特に、サーバーは、クライアントを含まない専用の高速ネットワーク（図ではネットワーク192.0.2.0/24）によって接続されている場合があります。このプロトコルにより、クライアントはサーバー間のコピー（図のネットワーク203.0.113.0/24を介して）をセットアップし、サーバーが選択した場合は高速ネットワークで通信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             192.0.2.0/24
                 +-------------------------------------+
                 |                                     |
                 |                                     |
                 | 192.0.2.18                          | 192.0.2.56
         +-------+------+                       +------+------+
         |     Source   |                       | Destination |
         +-------+------+                       +------+------+
                 | 203.0.113.18                        | 203.0.113.56
                 |                                     |
                 |                                     |
                 |             203.0.113.0/24          |
                 +------------------+------------------+
                                    |
                                    |
                                    | 203.0.113.243
                              +-----+-----+
                              |   Client  |
                              +-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Figure 3: An Example Inter-Server Network Topology
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
図3：サーバー間ネットワークトポロジの例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For an inter-server copy, the client notifies the source server that a file will be copied by the destination server using a COPY_NOTIFY operation. The client then initiates the copy by sending the COPY operation to the destination server. The destination server may perform the copy synchronously or asynchronously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー間コピーの場合、クライアントはCOPY_NOTIFY操作を使用して宛先サーバーによってファイルがコピーされることをソースサーバーに通知します。次にクライアントは、COPY操作を宛先サーバーに送信することにより、コピーを開始します。宛先サーバーは、同期的または非同期的にコピーを実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A synchronous inter-server copy is shown in Figure 4. In this case, the destination server chooses to perform the copy before responding to the client&#39;s COPY request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同期サーバー間コピーを図4に示します。この場合、宛先サーバーは、クライアントのCOPY要求に応答する前にコピーを実行することを選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Client                Source         Destination
        +                    +                 +
        |                    |                 |
        |--- OPEN        ---&gt;|                 | Returns
        |&lt;------------------/|                 | open state os1
        |                    |                 |
        |--- COPY_NOTIFY ---&gt;|                 |
        |&lt;------------------/|                 |
        |                    |                 |
        |--- OPEN ----------------------------&gt;| Returns
        |&lt;------------------------------------/| open state os2
        |                    |                 |
        |--- COPY ----------------------------&gt;|
        |                    |                 |
        |                    |                 |
        |                    |&lt;----- READ -----|
        |                    |\---------------&gt;|
        |                    |                 |
        |                    |        .        | Multiple READs may
        |                    |        .        | be necessary
        |                    |        .        |
        |                    |                 |
        |                    |                 |
        |&lt;------------------------------------/| Destination replies
        |                    |                 | to COPY
        |                    |                 |
        |--- CLOSE ---------------------------&gt;| Release os2
        |&lt;------------------------------------/|
        |                    |                 |
        |--- CLOSE       ---&gt;|                 | Release os1
        |&lt;------------------/|                 |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
Figure 4: A Synchronous Inter-Server Copy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
図4：サーバー間の同期コピー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An asynchronous inter-server copy is shown in Figure 5. In this case, the destination server chooses to respond to the client&#39;s COPY request immediately and then perform the copy asynchronously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非同期のサーバー間コピーを図5に示します。この場合、宛先サーバーは、クライアントのCOPY要求にすぐに応答して、非同期にコピーを実行することを選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Client                Source         Destination
       +                    +                 +
       |                    |                 |
       |--- OPEN        ---&gt;|                 | Returns
       |&lt;------------------/|                 | open state os1
       |                    |                 |
       |--- LOCK        ---&gt;|                 | Optional; could be done
       |&lt;------------------/|                 | with a share lock
       |                    |                 |
       |--- COPY_NOTIFY ---&gt;|                 | Need to pass in
       |&lt;------------------/|                 | os1 or lock state
       |                    |                 |
       |                    |                 |
       |                    |                 |
       |--- OPEN ----------------------------&gt;| Returns
       |&lt;------------------------------------/| open state os2
       |                    |                 |
       |--- LOCK ----------------------------&gt;| Optional ...
       |&lt;------------------------------------/|
       |                    |                 |
       |--- COPY ----------------------------&gt;| Need to pass in
       |&lt;------------------------------------/| os2 or lock state
       |                    |                 |
       |                    |                 |
       |                    |&lt;----- READ -----|
       |                    |\---------------&gt;|
       |                    |                 |
       |                    |        .        | Multiple READs may
       |                    |        .        | be necessary
       |                    |        .        |
       |                    |                 |
       |                    |                 |
       |--- OFFLOAD_STATUS ------------------&gt;| Client may poll
       |&lt;------------------------------------/| for status
       |                    |                 |
       |                    |        .        | Multiple OFFLOAD_STATUS
       |                    |        .        | operations may be sent
       |                    |        .        |
       |                    |                 |
       |                    |                 |
       |                    |                 |
       |&lt;-- CB_OFFLOAD -----------------------| Destination reports
       |\------------------------------------&gt;| results
       |                    |                 |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       |--- LOCKU ---------------------------&gt;| Only if LOCK was done
       |&lt;------------------------------------/|
       |                    |                 |
       |--- CLOSE ---------------------------&gt;| Release os2
       |&lt;------------------------------------/|
       |                    |                 |
       |--- LOCKU       ---&gt;|                 | Only if LOCK was done
       |&lt;------------------/|                 |
       |                    |                 |
       |--- CLOSE       ---&gt;|                 | Release os1
       |&lt;------------------/|                 |
       |                    |                 |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
Figure 5: An Asynchronous Inter-Server Copy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
図5：非同期のサーバー間コピー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6--Server-to-Server-Copy-Protocol">
4.6. Server-to-Server Copy Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. サーバー間コピープロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The choice of what protocol to use in an inter-server copy is ultimately the destination server&#39;s decision. However, the destination server has to be cognizant that it is working on behalf of the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー間コピーで使用するプロトコルの選択は、最終的に宛先サーバーの決定です。ただし、宛先サーバーは、クライアントの代わりに機能していることを認識する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6-1--Considerations-on-Selecting-a-Copy-Protocol">
4.6.1. Considerations on Selecting a Copy Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. コピープロトコルの選択に関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client can have requirements over both the size of transactions and error recovery semantics. It may want to split the copy up such that each chunk is synchronously transferred. It may want the copy protocol to copy the bytes in consecutive order such that upon an error the client can restart the copy at the last known good offset. If the destination server cannot meet these requirements, the client may prefer the traditional copy mechanism such that it can meet those requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントには、トランザクションのサイズとエラー回復のセマンティクスの両方に対する要件があります。各チャンクが同期して転送されるようにコピーを分割したい場合があります。エラー時にクライアントが最後の既知の適切なオフセットでコピーを再開できるように、コピープロトコルでバイトを連続した順序でコピーする必要がある場合があります。宛先サーバーがこれらの要件を満たせない場合、クライアントは、これらの要件を満たすことができるように、従来のコピーメカニズムを好む場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6-2--Using-NFSv4-x-as-the-Copy-Protocol">
4.6.2. Using NFSv4.x as the Copy Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2. コピープロトコルとしてのNFSv4.xの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The destination server MAY use standard NFSv4.x (where x &gt;= 1) operations to read the data from the source server. If NFSv4.x is used for the server-to-server copy protocol, the destination server can use the source filehandle and ca_src_stateid provided in the COPY request with standard NFSv4.x operations to read data from the source server. Note that the ca_src_stateid MUST be the cnr_stateid returned from the source via the COPY_NOTIFY (Section 15.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先サーバーは、標準のNFSv4.x（ここでx&gt; = 1）操作を使用して、ソースサーバーからデータを読み取ることができます。サーバー間のコピープロトコルにNFSv4.xが使用されている場合、宛先サーバーは、標準のNFSv4.x操作でCOPY要求に提供されているソースファイルハンドルとca_src_stateidを使用して、ソースサーバーからデータを読み取ることができます。 ca_src_stateidは、COPY_NOTIFYを介してソースから返されたcnr_stateidでなければならないことに注意してください（セクション15.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6-3--Using-an-Alternative-Copy-Protocol">
4.6.3. Using an Alternative Copy Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3. 代替コピープロトコルの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a homogeneous environment, the source and destination servers might be able to perform the file copy extremely efficiently using specialized protocols. For example, the source and destination servers might be two nodes sharing a common file system format for the source and destination file systems. Thus, the source and destination are in an ideal position to efficiently render the image of the source file to the destination file by replicating the file system formats at the block level. Another possibility is that the source and destination might be two nodes sharing a common storage area network, and thus there is no need to copy any data at all; instead, ownership of the file and its contents might simply be reassigned to the destination. To allow for these possibilities, the destination server is allowed to use a server-to-server copy protocol of its choice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同種環境では、ソースサーバーと宛先サーバーは、特殊なプロトコルを使用して非常に効率的にファイルコピーを実行できる場合があります。たとえば、ソースサーバーと宛先サーバーは、ソースファイルシステムと宛先ファイルシステムの共通のファイルシステム形式を共有する2つのノードである場合があります。したがって、ソースと宛先は、ブロックレベルでファイルシステムフォーマットを複製することにより、ソースファイルのイメージを宛先ファイルに効率的にレンダリングするのに理想的な位置にあります。もう1つの可能性は、ソースと宛先が共通のストレージエリアネットワークを共有する2つのノードであり、データをまったくコピーする必要がない場合です。代わりに、ファイルとその内容の所有権が宛先に再割り当てされるだけかもしれません。これらの可能性を可能にするために、宛先サーバーは、選択したサーバー間コピープロトコルを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a heterogeneous environment, using a protocol other than NFSv4.x (e.g., HTTP [RFC7230] or FTP [RFC959]) presents some challenges. In particular, the destination server is presented with the challenge of accessing the source file given only an NFSv4.x filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異機種環境では、NFSv4.x以外のプロトコル（HTTP [RFC7230]またはFTP [RFC959]など）を使用すると、いくつかの課題が生じます。特に、宛先サーバーには、NFSv4.xファイルハンドルのみが与えられている場合に、ソースファイルにアクセスするという課題があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One option for protocols that identify source files with pathnames is to use an ASCII hexadecimal representation of the source filehandle as the filename.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パス名でソースファイルを識別するプロトコルの1つのオプションは、ファイル名としてソースファイルハンドルのASCII 16進表記を使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another option for the source server is to use URLs to direct the destination server to a specialized service. For example, the response to COPY_NOTIFY could include the URL &lt;ftp://s1.example.com:9999/_FH/0x12345&gt;, where 0x12345 is the ASCII hexadecimal representation of the source filehandle. When the destination server receives the source server&#39;s URL, it would use &#34;_FH/0x12345&#34; as the filename to pass to the FTP server listening on port 9999 of s1.example.com. On port 9999 there would be a special instance of the FTP service that understands how to convert NFS filehandles to an open file descriptor (in many operating systems, this would require a new system call, one that is the inverse of the makefh() function that the pre-NFSv4 MOUNT service needs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースサーバーのもう1つのオプションは、URLを使用して宛先サーバーを専用のサービスに送信することです。たとえば、COPY_NOTIFYへの応答には、URL &lt;ftp://s1.example.com:9999/_FH/0x12345&gt;を含めることができます。0x12345は、ソースファイルハンドルのASCII 16進表記です。宛先サーバーがソースサーバーのURLを受信すると、ファイル名として「_FH / 0x12345」を使用して、s1.example.comのポート9999でリッスンするFTPサーバーに渡します。ポート9999には、NFSファイルハンドルをオープンファイル記述子に変換する方法を理解するFTPサービスの特別なインスタンスがあります（多くのオペレーティングシステムでは、makefh()関数の逆である新しいシステムコールが必要になります） NFSv4以前のMOUNTサービスが必要とするもの）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Authenticating and identifying the destination server to the source server is also a challenge. One solution would be to construct unique URLs for each destination server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースサーバーに対して宛先サーバーを認証および識別することも、課題です。 1つの解決策は、宛先サーバーごとに一意のURLを作成することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-7--netloc4---Network-Locations">
4.7. netloc4 - Network Locations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. netloc4-ネットワークロケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server-side COPY operations specify network locations using the netloc4 data type shown below (see [RFC7863]):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー側のCOPY操作は、以下に示すnetloc4データ型を使用してネットワークロケーションを指定します（[RFC7863]を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum netloc_type4 {
           NL4_NAME        = 1,
           NL4_URL         = 2,
           NL4_NETADDR     = 3
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union netloc4 switch (netloc_type4 nl_type) {
           case NL4_NAME:          utf8str_cis nl_name;
           case NL4_URL:           utf8str_cis nl_url;
           case NL4_NETADDR:       netaddr4    nl_addr;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the netloc4 is of type NL4_NAME, the nl_name field MUST be specified as a UTF-8 string. The nl_name is expected to be resolved to a network address via DNS, the Lightweight Directory Access Protocol (LDAP), the Network Information Service (NIS), /etc/hosts, or some other means. If the netloc4 is of type NL4_URL, a server URL [RFC3986] appropriate for the server-to-server COPY operation is specified as a UTF-8 string. If the netloc4 is of type NL4_NETADDR, the nl_addr field MUST contain a valid netaddr4 as defined in Section 3.3.9 of [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
netloc4のタイプがNL4_NAMEの場合、nl_nameフィールドはUTF-8文字列として指定する必要があります。 nl_nameは、DNS、ライトウェイトディレクトリアクセスプロトコル（LDAP）、ネットワーク情報サービス（NIS）、/ etc / hosts、またはその他の手段によってネットワークアドレスに解決されることが期待されています。 netloc4のタイプがNL4_URLの場合、サーバー間のCOPY操作に適したサーバーURL [RFC3986]がUTF-8文字列として指定されます。 netloc4のタイプがNL4_NETADDRの場合、nl_addrフィールドには、[RFC5661]のセクション3.3.9で定義されている有効なnetaddr4が含まれている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When netloc4 values are used for an inter-server copy as shown in Figure 3, their values may be evaluated on the source server, destination server, and client. The network environment in which these systems operate should be configured so that the netloc4 values are interpreted as intended on each system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図3に示すように、サーバー間コピーにnetloc4値を使用すると、それらの値はソースサーバー、宛先サーバー、およびクライアントで評価されます。これらのシステムが動作するネットワーク環境は、netloc4の値が各システムで意図したとおりに解釈されるように構成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-8--Copy-Offload-Stateids">
4.8. Copy Offload Stateids
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. オフロード状態IDのコピー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server may perform a copy offload operation asynchronously. An asynchronous copy is tracked using a copy offload stateid. Copy offload stateids are included in the COPY, OFFLOAD_CANCEL, OFFLOAD_STATUS, and CB_OFFLOAD operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、コピーオフロード操作を非同期で実行できます。非同期コピーは、コピーオフロード状態IDを使用して追跡されます。コピーオフロード状態IDは、COPY、OFFLOAD_CANCEL、OFFLOAD_STATUS、およびCB_OFFLOAD操作に含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A copy offload stateid will be valid until either (A) the client or server restarts or (B) the client returns the resource by issuing an OFFLOAD_CANCEL operation or the client replies to a CB_OFFLOAD operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コピーオフロードの状態IDは、（A）クライアントまたはサーバーが再起動するか、（B）クライアントがOFFLOAD_CANCEL操作を発行してリソースを返すか、クライアントがCB_OFFLOAD操作に応答するまで有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A copy offload stateid&#39;s seqid MUST NOT be zero. In the context of a copy offload operation, it is inappropriate to indicate &#34;the most recent copy offload operation&#34; using a stateid with a seqid of zero (see Section 8.2.2 of [RFC5661]). It is inappropriate because the stateid refers to internal state in the server and there may be several asynchronous COPY operations being performed in parallel on the same file by the server. Therefore, a copy offload stateid with a seqid of zero MUST be considered invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コピーオフロード状態IDのシーケンス番号はゼロであってはなりません。コピーオフロード操作のコンテキストでは、seqidがゼロの状態IDを使用して「最新のコピーオフロード操作」を示すことは不適切です（[RFC5661]のセクション8.2.2を参照）。 stateidはサーバーの内部状態を参照しており、サーバーによって同じファイルに対して並行して実行されるいくつかの非同期COPY操作が存在する可能性があるため、これは不適切です。したがって、seqidがゼロのコピーオフロードステートIDは無効と見なす必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9--Security-Considerations-for-Server-Side-Copy">
4.9. Security Considerations for Server-Side Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9. サーバー側コピーのセキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All security considerations pertaining to NFSv4.1 [RFC5661] apply to this section; as such, the standard security mechanisms used by the protocol can be used to secure the server-to-server operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1 [RFC5661]に関連するすべてのセキュリティの考慮事項がこのセクションに適用されます。そのため、プロトコルで使用される標準のセキュリティメカニズムを使用して、サーバー間の操作を保護できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4 clients and servers supporting the inter-server COPY operations described in this section are REQUIRED to implement the mechanism described in Section 4.9.1.1 and to support rejecting COPY_NOTIFY requests that do not use the RPC security protocol (RPCSEC_GSS) [RFC7861] with privacy. If the server-to-server copy protocol is based on ONC RPC, the servers are also REQUIRED to implement [RFC7861], including the RPCSEC_GSSv3 &#34;copy_to_auth&#34;, &#34;copy_from_auth&#34;, and &#34;copy_confirm_auth&#34; structured privileges. This requirement to implement is not a requirement to use; for example, a server may, depending on configuration, also allow COPY_NOTIFY requests that use only AUTH_SYS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションで説明されているサーバー間COPY操作をサポートするNFSv4クライアントとサーバーは、セクション4.9.1.1で説明されているメカニズムを実装し、プライバシーを備えたRPCセキュリティプロトコル（RPCSEC_GSS）[RFC7861]を使用しないCOPY_NOTIFY要求の拒否をサポートする必要があります。サーバー間のコピープロトコルがONC RPCに基づいている場合、サーバーはRPCSEC_GSSv3 &#34;copy_to_auth&#34;、 &#34;copy_from_auth&#34;、および &#34;copy_confirm_auth&#34;構造化特権を含む[RFC7861]を実装することも必要です。実装するためのこの要件は、使用するための要件ではありません。たとえば、サーバーは、設定に応じて、AUTH_SYSのみを使用するCOPY_NOTIFYリクエストも許可します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server requires the use of an RPCSEC_GSSv3 copy_to_auth, copy_from_auth, or copy_confirm_auth privilege and it is not used, the server will reject the request with NFS4ERR_PARTNER_NO_AUTH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがRPCSEC_GSSv3のcopy_to_auth、copy_from_auth、またはcopy_confirm_auth特権の使用を必要とし、それが使用されていない場合、サーバーはNFS4ERR_PARTNER_NO_AUTHで要求を拒否します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9-1--Inter-Server-Copy-Security">
4.9.1. Inter-Server Copy Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1. サーバー間コピーセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9-1-1--Inter-Server-Copy-via-ONC-RPC-with-RPCSECGSSv3">
4.9.1.1. Inter-Server Copy via ONC RPC with RPCSEC_GSSv3
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1. RPCSEC_GSSv3を使用したONC RPCによるサーバー間コピー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client sends a COPY_NOTIFY to the source server to expect the destination to attempt to copy data from the source server, it is expected that this copy is being done on behalf of the principal (called the &#34;user principal&#34;) that sent the RPC request that encloses the COMPOUND procedure that contains the COPY_NOTIFY operation. The user principal is identified by the RPC credentials. A mechanism that allows the user principal to authorize the destination server to perform the copy, lets the source server properly authenticate the destination&#39;s copy, and does not allow the destination server to exceed this authorization is necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがCOPY_NOTIFYをソースサーバーに送信して、宛先がソースサーバーからデータをコピーすることを期待している場合、RPCを送信したプリンシパル（「ユーザープリンシパル」と呼ばれる）に代わってこのコピーが行われることが予想されます。 COPY_NOTIFY操作を含むCOMPOUNDプロシージャを囲むリクエスト。ユーザープリンシパルは、RPC資格情報によって識別されます。ユーザープリンシパルが宛先サーバーにコピーを実行することを許可し、ソースサーバーが宛先のコピーを適切に認証できるようにし、宛先サーバーがこの許可を超えないようにするメカニズムが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An approach that sends delegated credentials of the client&#39;s user principal to the destination server is not used for the following reason. If the client&#39;s user delegated its credentials, the destination would authenticate as the user principal. If the destination were using the NFSv4 protocol to perform the copy, then the source server would authenticate the destination server as the user principal, and the file copy would securely proceed. However, this approach would allow the destination server to copy other files. The user principal would have to trust the destination server to not do so. This is counter to the requirements and therefore is not considered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の理由により、クライアントのユーザープリンシパルの委任された資格情報を宛先サーバーに送信するアプローチは使用されません。クライアントのユーザーが資格情報を委任した場合、宛先はユーザープリンシパルとして認証されます。コピー先がNFSv4プロトコルを使用してコピーを実行している場合、コピー元サーバーはコピー先サーバーをユーザープリンシパルとして認証し、ファイルのコピーは安全に続行されます。ただし、このアプローチでは、宛先サーバーが他のファイルをコピーできます。ユーザープリンシパルは、これを行わないように宛先サーバーを信頼する必要があります。これは要件に反するため、考慮されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Instead, a feature of the RPCSEC_GSSv3 protocol [RFC7861] can be used: RPC-application-defined structured privilege assertion. This feature allows the destination server to authenticate to the source server as acting on behalf of the user principal and to authorize the destination server to perform READs of the file to be copied from the source on behalf of the user principal. Once the copy is complete, the client can destroy the RPCSEC_GSSv3 handles to end the authorization of both the source and destination servers to copy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代わりに、RPCSEC_GSSv3プロトコル[RFC7861]の機能を使用できます。RPCアプリケーションで定義された構造化特権アサーション。この機能により、宛先サーバーはユーザープリンシパルに代わって動作するソースサーバーに対して認証し、ユーザープリンシパルに代わってソースからコピーされるファイルの読み取りを宛先サーバーに実行することを許可します。コピーが完了すると、クライアントはRPCSEC_GSSv3ハンドルを破棄して、コピーするソースサーバーと宛先サーバーの両方の承認を終了できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each structured privilege assertion defined by an RPC application, RPCSEC_GSSv3 requires the application to define a name string and a data structure that will be encoded and passed between client and server as opaque data. For NFSv4, the data structures specified below MUST be serialized using XDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSSv3は、RPCアプリケーションによって定義された構造化された特権アサーションごとに、名前文字列と、クライアントとサーバーの間でエンコードされ、不透明なデータとして渡されるデータ構造を定義する必要があります。 NFSv4の場合、以下で指定するデータ構造は、XDRを使用してシリアル化する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Three RPCSEC_GSSv3 structured privilege assertions that work together to authorize the copy are defined here. For each of the assertions, the description starts with the name string passed in the rp_name field of the rgss3_privs structure defined in Section 2.7.1.4 of [RFC7861] and specifies the XDR encoding of the associated structured data passed via the rp_privilege field of the structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでは、コピーを承認するために連携して機能する3つのRPCSEC_GSSv3構造化特権アサーションが定義されています。各アサーションについて、説明は[RFC7861]のセクション2.7.1.4で定義されたrgss3_privs構造体のrp_nameフィールドに渡される名前文字列で始まり、構造体のrp_privilegeフィールドを介して渡される関連する構造化データのXDRエンコーディングを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
copy_from_auth: A user principal is authorizing a source principal (&#34;nfs@&lt;source&gt;&#34;) to allow a destination principal (&#34;nfs@&lt;destination&gt;&#34;) to set up the copy_confirm_auth privilege required to copy a file from the source to the destination on behalf of the user principal. This privilege is established on the source server before the user principal sends a COPY_NOTIFY operation to the source server, and the resultant RPCSEC_GSSv3 context is used to secure the COPY_NOTIFY operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
copy_from_auth：ユーザープリンシパルは、ソースプリンシパル（ &#34;nfs @ &lt;source&gt;&#34;）を承認して、宛先プリンシパル（ &#34;nfs @ &lt;destination&gt;&#34;）がファイルをソースから宛先にコピーするために必要なcopy_confirm_auth特権を設定できるようにしますユーザープリンシパルに代わって。この特権は、ユーザープリンシパルがCOPY_NOTIFY操作をソースサーバーに送信する前にソースサーバーで確立され、結果のRPCSEC_GSSv3コンテキストを使用してCOPY_NOTIFY操作が保護されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct copy_from_auth_priv {
           secret4             cfap_shared_secret;
           netloc4             cfap_destination;
           /* the NFSv4 user name that the user principal maps to */
           utf8str_mixed       cfap_username;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
cfap_shared_secret is an automatically generated random number secret value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
cfap_shared_secretは、自動的に生成される乱数の秘密値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
copy_to_auth: A user principal is authorizing a destination principal (&#34;nfs@&lt;destination&gt;&#34;) to set up a copy_confirm_auth privilege with a source principal (&#34;nfs@&lt;source&gt;&#34;) to allow it to copy a file from the source to the destination on behalf of the user principal. This privilege is established on the destination server before the user principal sends a COPY operation to the destination server, and the resultant RPCSEC_GSSv3 context is used to secure the COPY operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
copy_to_auth：ユーザープリンシパルは、宛先プリンシパル（ &#34;nfs @ &lt;destination&gt;&#34;）に、ソースプリンシパル（ &#34;nfs @ &lt;source&gt;&#34;）でcopy_confirm_auth特権を設定して、ファイルをソースからユーザープリンシパルに代わって宛先。この特権は、ユーザープリンシパルがCOPY操作を送信先サーバーに送信する前に送信先サーバーで確立され、結果のRPCSEC_GSSv3コンテキストがCOPY操作を保護するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct copy_to_auth_priv {
           /* equal to cfap_shared_secret */
           secret4              ctap_shared_secret;
           netloc4              ctap_source&lt;&gt;;
           /* the NFSv4 user name that the user principal maps to */
           utf8str_mixed        ctap_username;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ctap_shared_secret is the automatically generated secret value used to establish the copy_from_auth privilege with the source principal. See Section 4.9.1.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ctap_shared_secretは、ソースプリンシパルとのcopy_from_auth特権を確立するために使用される自動的に生成されたシークレット値です。セクション4.9.1.1.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
copy_confirm_auth: A destination principal (&#34;nfs@&lt;destination&gt;&#34;) is confirming with the source principal (&#34;nfs@&lt;source&gt;&#34;) that it is authorized to copy data from the source. This privilege is established on the destination server before the file is copied from the source to the destination. The resultant RPCSEC_GSSv3 context is used to secure the READ operations from the source to the destination server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
copy_confirm_auth：宛先プリンシパル（ &#34;nfs @ &lt;destination&gt;&#34;）は、ソースプリンシパル（ &#34;nfs @ &lt;source&gt;&#34;）に、ソースからデータをコピーする権限があることを確認しています。この特権は、ファイルがソースから宛先にコピーされる前に宛先サーバーで確立されます。結果のRPCSEC_GSSv3コンテキストは、ソースから宛先サーバーへのREAD操作を保護するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct copy_confirm_auth_priv {
           /* equal to GSS_GetMIC() of cfap_shared_secret */
           opaque              ccap_shared_secret_mic&lt;&gt;;
           /* the NFSv4 user name that the user principal maps to */
           utf8str_mixed       ccap_username;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9-1-1-1--Establishing-a-Security-Context">
4.9.1.1.1. Establishing a Security Context
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1.1. セキュリティコンテキストの確立
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the user principal wants to copy a file between two servers, if it has not established copy_from_auth and copy_to_auth privileges on the servers, it establishes them as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザープリンシパルが2つのサーバー間でファイルをコピーする場合、サーバーでcopy_from_auth特権とcopy_to_auth特権を確立していないと、次のように確立されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o As noted in [RFC7861], the client uses an existing RPCSEC_GSSv3 context termed the &#34;parent&#34; handle to establish and protect RPCSEC_GSSv3 structured privilege assertion exchanges. The copy_from_auth privilege will use the context established between the user principal and the source server used to OPEN the source file as the RPCSEC_GSSv3 parent handle. The copy_to_auth privilege will use the context established between the user principal and the destination server used to OPEN the destination file as the RPCSEC_GSSv3 parent handle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o [RFC7861]で述べたように、クライアントは「親」ハンドルと呼ばれる既存のRPCSEC_GSSv3コンテキストを使用して、RPCSEC_GSSv3構造化特権アサーション交換を確立および保護します。 copy_from_auth特権は、RPCSEC_GSSv3親ハンドルとしてソースファイルを開くために使用されるユーザープリンシパルとソースサーバー間で確立されたコンテキストを使用します。 copy_to_auth特権は、RPCSEC_GSSv3親ハンドルとして宛先ファイルを開くために使用されるユーザープリンシパルと宛先サーバー間で確立されたコンテキストを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A random number is generated to use as a secret to be shared between the two servers. Note that the random number SHOULD NOT be reused between establishing different security contexts. The resulting shared secret will be placed in the copy_from_auth_priv cfap_shared_secret field and the copy_to_auth_priv ctap_shared_secret field. Because of this shared_secret, the RPCSEC_GSS3_CREATE control messages for copy_from_auth and copy_to_auth MUST use a Quality of Protection (QoP) of rpc_gss_svc_privacy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2つのサーバー間で共有される秘密として使用する乱数が生成されます。乱数は、異なるセキュリティコンテキストを確立する間で再利用しないでください。結果の共有シークレットは、copy_from_auth_priv cfap_shared_secretフィールドとcopy_to_auth_priv ctap_shared_secretフィールドに配置されます。このshared_secretのため、copy_from_authおよびcopy_to_authのRPCSEC_GSS3_CREATE制御メッセージは、rpc_gss_svc_privacyの保護品質（QoP）を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An instance of copy_from_auth_priv is filled in with the shared secret, the destination server, and the NFSv4 user id of the user principal and is placed in rpc_gss3_create_args assertions[0].privs.privilege. The string &#34;copy_from_auth&#34; is placed in assertions[0].privs.name. The source server unwraps the rpc_gss_svc_privacy RPCSEC_GSS3_CREATE payload and verifies that the NFSv4 user id being asserted matches the source server&#39;s mapping of the user principal. If it does, the privilege is established on the source server as &lt;copy_from_auth, user id, destination&gt;. The field &#34;handle&#34; in a successful reply is the RPCSEC_GSSv3 copy_from_auth &#34;child&#34; handle that the client will use in COPY_NOTIFY requests to the source server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o copy_from_auth_privのインスタンスには、共有シークレット、宛先サーバー、およびユーザープリンシパルのNFSv4ユーザーIDが入力され、rpc_gss3_create_args assertions [0] .privs.privilegeに配置されます。文字列「copy_from_auth」はassertions [0] .privs.nameに配置されます。ソースサーバーは、rpc_gss_svc_privacy RPCSEC_GSS3_CREATEペイロードをアンラップし、アサートされるNFSv4ユーザーIDがソースサーバーのユーザープリンシパルのマッピングと一致することを確認します。存在する場合、権限は&lt;copy_from_auth、user id、destination&gt;としてソースサーバー上で確立されます。成功した応答のフィールド「handle」は、クライアントがソースサーバーへのCOPY_NOTIFYリクエストで使用するRPCSEC_GSSv3 copy_from_auth「子」ハンドルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An instance of copy_to_auth_priv is filled in with the shared secret, the cnr_source_server list returned by COPY_NOTIFY, and the NFSv4 user id of the user principal. The copy_to_auth_priv instance is placed in rpc_gss3_create_args assertions[0].privs.privilege. The string &#34;copy_to_auth&#34; is placed in assertions[0].privs.name. The destination server unwraps the rpc_gss_svc_privacy RPCSEC_GSS3_CREATE payload and verifies that the NFSv4 user id being asserted matches the destination server&#39;s mapping of the user principal. If it does, the privilege is established on the destination server as &lt;copy_to_auth, user id, source list&gt;. The field &#34;handle&#34; in a successful reply is the RPCSEC_GSSv3 copy_to_auth child handle that the client will use in COPY requests to the destination server involving the source server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o copy_to_auth_privのインスタンスには、共有シークレット、COPY_NOTIFYによって返されるcnr_source_serverリスト、およびユーザープリンシパルのNFSv4ユーザーIDが入力されます。 copy_to_auth_privインスタンスは、rpc_gss3_create_argsアサーション[0] .privs.privilegeに配置されます。文字列「copy_to_auth」はassertions [0] .privs.nameに配置されます。宛先サーバーは、rpc_gss_svc_privacy RPCSEC_GSS3_CREATEペイロードをアンラップし、アサートされるNFSv4ユーザーIDが宛先サーバーのユーザープリンシパルのマッピングと一致することを確認します。存在する場合、権限は&lt;copy_to_auth、user id、source list&gt;として宛先サーバーで確立されます。成功した応答の「ハンドル」フィールドは、RPCSEC_GSSv3 copy_to_auth子ハンドルであり、クライアントは、ソースサーバーが関係する宛先サーバーへのCOPY要求で使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As noted in Section 2.7.1 of [RFC7861] (&#34;New Control Procedure - RPCSEC_GSS_CREATE&#34;), both the client and the source server should associate the RPCSEC_GSSv3 child handle with the parent RPCSEC_GSSv3 handle used to create the RPCSEC_GSSv3 child handle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7861]のセクション2.7.1（「新しい制御手順-RPCSEC_GSS_CREATE」）に記載されているように、クライアントとソースサーバーの両方が、RPCSEC_GSSv3子ハンドルを、RPCSEC_GSSv3子ハンドルの作成に使用される親RPCSEC_GSSv3ハンドルに関連付ける必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9-1-1-2--Starting-a-Secure-Inter-Server-Copy">
4.9.1.1.2. Starting a Secure Inter-Server Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1.2. 安全なサーバー間コピーの開始
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client sends a COPY_NOTIFY request to the source server, it uses the privileged copy_from_auth RPCSEC_GSSv3 handle. cna_destination_server in the COPY_NOTIFY MUST be the same as cfap_destination specified in copy_from_auth_priv. Otherwise, the COPY_NOTIFY will fail with NFS4ERR_ACCESS. The source server verifies that the privilege &lt;copy_from_auth, user id, destination&gt; exists and annotates it with the source filehandle, if the user principal has read access to the source file and if administrative policies give the user principal and the NFS client read access to the source file (i.e., if the ACCESS operation would grant read access). Otherwise, the COPY_NOTIFY will fail with NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがCOPY_NOTIFY要求をソースサーバーに送信するとき、クライアントは特権copy_from_auth RPCSEC_GSSv3ハンドルを使用します。 COPY_NOTIFYのcna_destination_serverは、copy_from_auth_privで指定されたcfap_destinationと同じでなければなりません。そうでない場合、COPY_NOTIFYはNFS4ERR_ACCESSで失敗します。ユーザープリンシパルにソースファイルへの読み取りアクセス権があり、管理ポリシーによってユーザープリンシパルとNFSクライアントに読み取りアクセス権が与えられている場合、ソースサーバーは特権&lt;copy_from_auth、user id、destination&gt;が存在することを確認し、ソースファイルハンドルで注釈を付けますソースファイル（つまり、ACCESS操作で読み取りアクセスが許可される場合）。そうでない場合、COPY_NOTIFYはNFS4ERR_ACCESSで失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client sends a COPY request to the destination server, it uses the privileged copy_to_auth RPCSEC_GSSv3 handle. ca_source_server list in the COPY MUST be the same as ctap_source list specified in copy_to_auth_priv. Otherwise, the COPY will fail with NFS4ERR_ACCESS. The destination server verifies that the privilege &lt;copy_to_auth, user id, source list&gt; exists and annotates it with the source and destination filehandles. If the COPY returns a wr_callback_id, then this is an asynchronous copy and the wr_callback_id must also must be annotated to the copy_to_auth privilege. If the client has failed to establish the copy_to_auth privilege, it will reject the request with NFS4ERR_PARTNER_NO_AUTH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがCOPY要求を宛先サーバーに送信するとき、特権のあるcopy_to_auth RPCSEC_GSSv3ハンドルを使用します。 COPYのca_source_serverリストは、copy_to_auth_privで指定されたctap_sourceリストと同じである必要があります。そうでない場合、COPYはNFS4ERR_ACCESSで失敗します。宛先サーバーは、特権&lt;copy_to_auth、user id、source list&gt;が存在することを確認し、ソースと宛先のファイルハンドルで注釈を付けます。 COPYがwr_callback_idを返す場合、これは非同期コピーであり、wr_callback_idにもcopy_to_auth特権の注釈を付ける必要があります。クライアントがcopy_to_auth特権の確立に失敗した場合、クライアントはNFS4ERR_PARTNER_NO_AUTHで要求を拒否します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If either the COPY_NOTIFY operation or the COPY operations fail, the associated copy_from_auth and copy_to_auth RPCSEC_GSSv3 handles MUST be destroyed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPY_NOTIFY操作またはCOPY操作のいずれかが失敗した場合、関連するcopy_from_authおよびcopy_to_auth RPCSEC_GSSv3ハンドルを破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9-1-1-3--Securing-ONC-RPC-Server-to-Server-Copy-Protocols">
4.9.1.1.3. Securing ONC RPC Server-to-Server Copy Protocols
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1.3. ONC RPCサーバー間コピープロトコルの保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After a destination server has a copy_to_auth privilege established on it and it receives a COPY request, if it knows it will use an ONC RPC protocol to copy data, it will establish a copy_confirm_auth privilege on the source server prior to responding to the COPY operation, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先サーバーでcopy_to_auth特権が確立され、COPY要求を受け取った後、ONC RPCプロトコルを使用してデータをコピーすることがわかっている場合は、COPY操作に応答する前に、ソースサーバーでcopy_confirm_auth特権を確立します。次のように：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Before establishing an RPCSEC_GSSv3 context, a parent context needs to exist between nfs@&lt;destination&gt; as the initiator principal and nfs@&lt;source&gt; as the target principal. If NFS is to be used as the copy protocol, this means that the destination server must mount the source server using RPCSEC_GSSv3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RPCSEC_GSSv3コンテキストを確立する前に、イニシエータープリンシパルとしてのnfs @ &lt;destination&gt;とターゲットプリンシパルとしてのnfs @ &lt;source&gt;の間に親コンテキストが存在する必要があります。 NFSをコピープロトコルとして使用する場合、これは、宛先サーバーがRPCSEC_GSSv3を使用してソースサーバーをマウントする必要があることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An instance of copy_confirm_auth_priv is filled in with information from the established copy_to_auth privilege. The value of the ccap_shared_secret_mic field is a GSS_GetMIC() of the ctap_shared_secret in the copy_to_auth privilege using the parent handle context. The ccap_username field is the mapping of the user principal to an NFSv4 user name (&#34;user&#34;@&#34;domain&#34; form) and MUST be the same as the ctap_username in the copy_to_auth privilege. The copy_confirm_auth_priv instance is placed in rpc_gss3_create_args assertions[0].privs.privilege. The string &#34;copy_confirm_auth&#34; is placed in assertions[0].privs.name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o copy_confirm_auth_privのインスタンスは、確立されたcopy_to_auth特権からの情報で埋められます。 ccap_shared_secret_micフィールドの値は、親ハンドルコンテキストを使用するcopy_to_auth特権のctap_shared_secretのGSS_GetMIC()です。 ccap_usernameフィールドは、ユーザープリンシパルのNFSv4ユーザー名（ &#34;user&#34; @ &#34;domain&#34;形式）へのマッピングであり、copy_to_auth特権のctap_usernameと同じである必要があります。 copy_confirm_auth_privインスタンスは、rpc_gss3_create_args assertions [0] .privs.privilegeに配置されます。文字列「copy_confirm_auth」はassertions [0] .privs.nameに配置されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The RPCSEC_GSS3_CREATE copy_from_auth message is sent to the source server with a QoP of rpc_gss_svc_privacy. The source server unwraps the rpc_gss_svc_privacy RPCSEC_GSS3_CREATE payload and verifies the cap_shared_secret_mic by calling GSS_VerifyMIC() using the parent context on the cfap_shared_secret from the established copy_from_auth privilege, and verifies that the ccap_username equals the cfap_username.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RPCSEC_GSS3_CREATE copy_from_authメッセージは、rpc_gss_svc_privacyのQoPでソースサーバーに送信されます。ソース・サーバーは、rpc_gss_svc_privacy RPCSEC_GSS3_CREATEペイロードをアンラップし、確立されたcopy_from_auth特権からcfap_shared_secretの親コンテキストを使用してGSS_VerifyMIC()を呼び出すことによりcap_shared_secret_micを検証し、ccap_usernameがcfap_usernameと等しいことを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If all verifications succeed, the copy_confirm_auth privilege is established on the source server as &lt;copy_confirm_auth, shared_secret_mic, user id&gt;. Because the shared secret has been verified, the resultant copy_confirm_auth RPCSEC_GSSv3 child handle is noted to be acting on behalf of the user principal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o すべての検証が成功した場合、copy_confirm_auth特権がソースサーバーで&lt;copy_confirm_auth、shared_secret_mic、user id&gt;として確立されます。共有シークレットが検証されているため、結果のcopy_confirm_auth RPCSEC_GSSv3子ハンドルは、ユーザープリンシパルに代わって動作していることがわかります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the source server fails to verify the copy_from_auth privilege, the COPY_NOTIFY operation will be rejected with NFS4ERR_PARTNER_NO_AUTH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ソースサーバーがcopy_from_auth特権の確認に失敗した場合、COPY_NOTIFY操作はNFS4ERR_PARTNER_NO_AUTHで拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the destination server fails to verify the copy_to_auth or copy_confirm_auth privilege, the COPY will be rejected with NFS4ERR_PARTNER_NO_AUTH, causing the client to destroy the associated copy_from_auth and copy_to_auth RPCSEC_GSSv3 structured privilege assertion handles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 宛先サーバーがcopy_to_authまたはcopy_confirm_auth特権の検証に失敗した場合、COPYはNFS4ERR_PARTNER_NO_AUTHで拒否され、クライアントは関連するcopy_from_authおよびcopy_to_auth RPCSEC_GSSv3構造化特権アサーションハンドルを破棄します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All subsequent ONC RPC READ requests sent from the destination to copy data from the source to the destination will use the RPCSEC_GSSv3 copy_confirm_auth child handle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ソースから宛先にデータをコピーするために宛先から送信される後続のすべてのONC RPC READ要求は、RPCSEC_GSSv3 copy_confirm_auth子ハンドルを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the use of the copy_confirm_auth privilege accomplishes the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
copy_confirm_auth特権を使用すると、以下が実行されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If a protocol like NFS is being used with export policies, the export policies can be overridden if the destination server is not authorized to act as an NFS client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSなどのプロトコルがエクスポートポリシーで使用されている場合、宛先サーバーがNFSクライアントとして動作することを承認されていないと、エクスポートポリシーが上書きされる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Manual configuration to allow a copy relationship between the source and destination is not needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ソースと宛先の間のコピー関係を可能にする手動構成は必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9-1-1-4--Maintaining-a-Secure-Inter-Server-Copy">
4.9.1.1.4. Maintaining a Secure Inter-Server Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1.4. 安全なサーバー間コピーの維持
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client determines that either the copy_from_auth or the copy_to_auth handle becomes invalid during a copy, then the copy MUST be aborted by the client sending an OFFLOAD_CANCEL to both the source and destination servers and destroying the respective copy-related context handles as described in Section 4.9.1.1.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コピー中にcopy_from_authハンドルまたはcopy_to_authハンドルのいずれかが無効になるとクライアントが判断した場合、セクションで説明されているように、ソースサーバーと宛先サーバーの両方にOFFLOAD_CANCELを送信し、それぞれのコピー関連コンテキストハンドルを破棄することで、コピーを中止する必要があります。 4.9.1.1.5。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9-1-1-5--Finishing-or-Stopping-a-Secure-Inter-Server-Copy">
4.9.1.1.5. Finishing or Stopping a Secure Inter-Server Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1.5. 安全なサーバー間コピーの終了または停止
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Under normal operation, the client MUST destroy the copy_from_auth and the copy_to_auth RPCSEC_GSSv3 handle once the COPY operation returns for a synchronous inter-server copy or a CB_OFFLOAD reports the result of an asynchronous copy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常の操作では、COPY操作が同期サーバー間コピーに対して戻るか、CB_OFFLOADが非同期コピーの結果を報告すると、クライアントはcopy_from_authおよびcopy_to_auth RPCSEC_GSSv3ハンドルを破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The copy_confirm_auth privilege is constructed from information held by the copy_to_auth privilege and MUST be destroyed by the destination server (via an RPCSEC_GSS3_DESTROY call) when the copy_to_auth RPCSEC_GSSv3 handle is destroyed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
copy_confirm_auth特権は、copy_to_auth特権が保持する情報から構築され、copy_to_auth RPCSEC_GSSv3ハンドルが破棄されるときに、（RPCSEC_GSS3_DESTROY呼び出しを介して）宛先サーバーによって破棄される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The copy_confirm_auth RPCSEC_GSS3 handle is associated with a copy_from_auth RPCSEC_GSS3 handle on the source server via the shared secret and MUST be locally destroyed (there is no RPCSEC_GSS3_DESTROY, as the source server is not the initiator) when the copy_from_auth RPCSEC_GSSv3 handle is destroyed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
copy_from_auth RPCSEC_GSSv3ハンドルが破棄されると、copy_confirm_auth RPCSEC_GSS3ハンドルは共有シークレットを介してソースサーバーのcopy_from_auth RPCSEC_GSS3ハンドルに関連付けられ、ローカルで破棄される必要があります（ソースサーバーはイニシエーターではないため、RPCSEC_GSS3_DESTROYはありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client sends an OFFLOAD_CANCEL to the source server to rescind the destination server&#39;s synchronous copy privilege, it uses the privileged copy_from_auth RPCSEC_GSSv3 handle, and the cra_destination_server in the OFFLOAD_CANCEL MUST be the same as the name of the destination server specified in copy_from_auth_priv. The source server will then delete the &lt;copy_from_auth, user id, destination&gt; privilege and fail any subsequent copy requests sent under the auspices of this privilege from the destination server. The client MUST destroy both the copy_from_auth and the copy_to_auth RPCSEC_GSSv3 handles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがOFFLOAD_CANCELをソースサーバーに送信して宛先サーバーの同期コピー特権を取り消す場合、クライアントは特権copy_from_auth RPCSEC_GSSv3ハンドルを使用し、OFFLOAD_CANCELのcra_destination_serverはcopy_from_auth_privで指定された宛先サーバーの名前と同じでなければなりません。次に、ソースサーバーは&lt;copy_from_auth、user id、destination&gt;特権を削除し、この特権の支援を受けてターゲットサーバーから送信された後続のコピー要求をすべて失敗させます。クライアントは、copy_from_authおよびcopy_to_auth RPCSEC_GSSv3ハンドルの両方を破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client sends an OFFLOAD_STATUS to the destination server to check on the status of an asynchronous copy, it uses the privileged copy_to_auth RPCSEC_GSSv3 handle, and the osa_stateid in the OFFLOAD_STATUS MUST be the same as the wr_callback_id specified in the copy_to_auth privilege stored on the destination server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがOFFLOAD_STATUSを宛先サーバーに送信して非同期コピーのステータスを確認する場合、クライアントは特権copy_to_auth RPCSEC_GSSv3ハンドルを使用し、OFFLOAD_STATUSのosa_stateidは宛先に格納されたcopy_to_auth特権で指定されたwr_callback_idと同じでなければなりませんサーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client sends an OFFLOAD_CANCEL to the destination server to cancel an asynchronous copy, it uses the privileged copy_to_auth RPCSEC_GSSv3 handle, and the oaa_stateid in the OFFLOAD_CANCEL MUST be the same as the wr_callback_id specified in the copy_to_auth privilege stored on the destination server. The destination server will then delete the &lt;copy_to_auth, user id, source list&gt; privilege and the associated copy_confirm_auth RPCSEC_GSSv3 handle. The client MUST destroy both the copy_to_auth and copy_from_auth RPCSEC_GSSv3 handles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがOFFLOAD_CANCELを宛先サーバーに送信して非同期コピーをキャンセルする場合、クライアントは特権copy_to_auth RPCSEC_GSSv3ハンドルを使用し、OFFLOAD_CANCELのoaa_stateidは宛先サーバーに格納されているcopy_to_auth特権で指定されたwr_callback_idと同じでなければなりません。次に、宛先サーバーは、&lt;copy_to_auth、user id、source list&gt;特権および関連するcopy_confirm_auth RPCSEC_GSSv3ハンドルを削除します。クライアントは、copy_to_authおよびcopy_from_auth RPCSEC_GSSv3ハンドルの両方を破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-9-1-2--Inter-Server-Copy-via-ONC-RPC-without-RPCSECGSS">
4.9.1.2. Inter-Server Copy via ONC RPC without RPCSEC_GSS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.2. RPCSEC_GSSなしのONC RPCによるサーバー間コピー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ONC RPC security flavors other than RPCSEC_GSS MAY be used with the server-side copy offload operations described in this section. In particular, host-based ONC RPC security flavors such as AUTH_NONE and AUTH_SYS MAY be used. If a host-based security flavor is used, a minimal level of protection for the server-to-server copy protocol is possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSS以外のONC RPCセキュリティフレーバーは、このセクションで説明するサーバー側のコピーオフロード操作で使用できます。特に、AUTH_NONEやAUTH_SYSなどのホストベースのONC RPCセキュリティフレーバーを使用できます。ホストベースのセキュリティフレーバーが使用されている場合、サーバー間コピープロトコルの最小レベルの保護が可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The biggest issue is that there is a lack of a strong security method to allow the source server and destination server to identify themselves to each other. A further complication is that in a multihomed environment the destination server might not contact the source server from the same network address specified by the client in the COPY_NOTIFY. The cnr_stateid returned from the COPY_NOTIFY can be used to uniquely identify the destination server to the source server. The use of the cnr_stateid provides initial authentication of the destination server but cannot defend against man-in-the-middle attacks after authentication or against an eavesdropper that observes the opaque stateid on the wire. Other secure communication techniques (e.g., IPsec) are necessary to block these attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最大の問題は、送信元サーバーと送信先サーバーが互いを識別するための強力なセキュリティメソッドがないことです。さらに複雑なのは、マルチホーム環境では、宛先サーバーがクライアントによってCOPY_NOTIFYで指定された同じネットワークアドレスからソースサーバーに接続できない可能性があることです。 COPY_NOTIFYから返されたcnr_stateidを使用して、宛先サーバーをソースサーバーに対して一意に識別できます。 cnr_stateidを使用すると、宛先サーバーの初期認証が提供されますが、認証後の中間者攻撃や、ネットワーク上の不透明なstateidを監視する盗聴者を防御できません。これらの攻撃をブロックするには、他の安全な通信技術（IPsecなど）が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers SHOULD reject COPY_NOTIFY requests that do not use RPCSEC_GSS with privacy, thus ensuring that the cnr_stateid in the COPY_NOTIFY reply is encrypted. For the same reason, clients SHOULD send COPY requests to the destination using RPCSEC_GSS with privacy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、RPCSEC_GSSをプライバシーとともに使用しないCOPY_NOTIFY要求を拒否する必要があるため、COPY_NOTIFY応答のcnr_stateidが確実に暗号化されます。同じ理由で、クライアントはプライバシーを備えたRPCSEC_GSSを使用して宛先にCOPYリクエストを送信する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Support-for-Application-IO-Hints">
5. Support for Application I/O Hints
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. アプリケーションI / Oヒントのサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications can issue client I/O hints via posix_fadvise() [posix_fadvise] to the NFS client. While this can help the NFS client optimize I/O and caching for a file, it does not allow the NFS server and its exported file system to do likewise. The IO_ADVISE procedure (Section 15.5) is used to communicate the client file access patterns to the NFS server. The NFS server, upon receiving an IO_ADVISE operation, MAY choose to alter its I/O and caching behavior but is under no obligation to do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、posix_fadvise()[posix_fadvise]を介してクライアントI / OヒントをNFSクライアントに発行できます。これは、NFSクライアントがファイルのI / Oとキャッシュを最適化するのに役立ちますが、NFSサーバーとそのエクスポートされたファイルシステムが同様に行うことはできません。 IO_ADVISEプロシージャ（セクション15.5）は、クライアントファイルアクセスパターンをNFSサーバーに通信するために使用されます。 NFSサーバーは、IO_ADVISE操作を受信すると、I / Oとキャッシュの動作を変更することを選択できますが、そうする義務はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Application-specific NFS clients such as those used by hypervisors and databases can also leverage application hints to communicate their specialized requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハイパーバイザーやデータベースで使用されるようなアプリケーション固有のNFSクライアントも、アプリケーションのヒントを利用して、それらの特殊な要件を伝達できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Sparse-Files">
6. Sparse Files
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. スパースファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sparse file is a common way of representing a large file without having to utilize all of the disk space for it. Consequently, a sparse file uses less physical space than its size indicates. This means the file contains &#34;holes&#34;, byte ranges within the file that contain no data. Most modern file systems support sparse files, including most UNIX file systems and Microsoft&#39;s New Technology File System (NTFS); however, it should be noted that Apple&#39;s Hierarchical File System Plus (HFS+) does not. Common examples of sparse files include Virtual Machine (VM) OS/disk images, database files, log files, and even checkpoint recovery files most commonly used by the High-Performance Computing (HPC) community.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スパースファイルは、すべてのディスク領域を使用することなく大きなファイルを表す一般的な方法です。したがって、スパースファイルは、そのサイズが示すよりも少ない物理スペースを使用します。これは、ファイルに「ホール」、つまりデータを含まないファイル内のバイト範囲が含まれていることを意味します。最近のほとんどのファイルシステムは、ほとんどのUNIXファイルシステムやMicrosoftの新技術ファイルシステム（NTFS）を含むスパースファイルをサポートしています。ただし、AppleのHierarchical File System Plus（HFS +）にはないことに注意してください。スパースファイルの一般的な例には、仮想マシン（VM）OS /ディスクイメージ、データベースファイル、ログファイル、さらにはハイパフォーマンスコンピューティング（HPC）コミュニティで最も一般的に使用されるチェックポイント回復ファイルが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, many modern file systems support the concept of &#34;unwritten&#34; or &#34;uninitialized&#34; blocks, which have uninitialized space allocated to them on disk but will return zeros until data is written to them. Such functionality is already present in the data model of the pNFS block/volume layout (see [RFC5663]). Uninitialized blocks can be thought of as holes inside a space reservation window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、多くの最新のファイルシステムは、「未書き込み」または「未初期化」ブロックの概念をサポートしています。これらのブロックには、ディスク上に未初期化スペースが割り当てられていますが、データが書き込まれるまでゼロが返されます。このような機能は、pNFSブロック/ボリュームレイアウトのデータモデルにすでに存在しています（[RFC5663]を参照）。初期化されていないブロックは、スペース予約ウィンドウ内の穴と考えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an application reads a hole in a sparse file, the file system must return all zeros to the application. For local data access there is little penalty, but with NFS these zeros must be transferred back to the client. If an application uses the NFS client to read data into memory, this wastes time and bandwidth as the application waits for the zeros to be transferred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションがスパースファイルのホールを読み取る場合、ファイルシステムはアプリケーションにすべてゼロを返す必要があります。ローカルデータアクセスの場合、ペナルティはほとんどありませんが、NFSではこれらのゼロをクライアントに転送する必要があります。アプリケーションがNFSクライアントを使用してデータをメモリに読み込む場合、アプリケーションがゼロが転送されるのを待つため、これは時間と帯域幅を浪費します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sparse file is typically created by initializing the file to be all zeros. Nothing is written to the data in the file; instead, the hole is recorded in the metadata for the file. So, an 8G disk image might be represented initially by a few hundred bits in the metadata (on UNIX file systems, the inode) and nothing on the disk. If the VM then writes 100M to a file in the middle of the image, there would now be two holes represented in the metadata and 100M in the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スパースファイルは通常、ファイルをすべてゼロに初期化することによって作成されます。ファイルのデータには何も書き込まれません。代わりに、穴はファイルのメタデータに記録されます。したがって、8Gディスクイメージは、最初はメタデータ（UNIXファイルシステムではiノード）の数百ビットで表され、ディスクには何も表されない場合があります。 VMがイメージの中央にあるファイルに100Mを書き込むと、メタデータに2つの穴が、データに100Mの穴が表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
No new operation is needed to allow the creation of a sparsely populated file; when a file is created and a write occurs past the current size of the file, the non-allocated region will either be a hole or be filled with zeros. The choice of behavior is dictated by the underlying file system and is transparent to the application. However, the abilities to read sparse files and to punch holes to reinitialize the contents of a file are needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データがまばらに作成されたファイルを作成するために、新しい操作は必要ありません。ファイルが作成され、ファイルの現在のサイズを超えて書き込みが行われると、割り当てられていない領域はホールになるか、ゼロで埋められます。動作の選択は、基盤となるファイルシステムによって決定され、アプリケーションに対して透過的です。ただし、スパースファイルを読み取ったり、ファイルの内容を再初期化するために穴を開けたりする機能が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two new operations -- DEALLOCATE (Section 15.4) and READ_PLUS (Section 15.10) -- are introduced. DEALLOCATE allows for the hole punching, where an application might want to reset the allocation and reservation status of a range of the file. READ_PLUS supports all the features of READ but includes an extension to support sparse files. READ_PLUS is guaranteed to perform no worse than READ and can dramatically improve performance with sparse files. READ_PLUS does not depend on pNFS protocol features but can be used by pNFS to support sparse files.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つの新しい操作-DEALLOCATE（セクション15.4）とREAD_PLUS（セクション15.10）-が導入されました。 DEALLOCATEは、アプリケーションがファイルの範囲の割り当てと予約のステータスをリセットしたい場合があるホールパンチングを可能にします。 READ_PLUSはREADのすべての機能をサポートしますが、スパースファイルをサポートするための拡張が含まれています。 READ_PLUSは、READよりもパフォーマンスが低下しないことが保証されており、スパースファイルのパフォーマンスを劇的に向上させることができます。 READ_PLUSはpNFSプロトコル機能に依存しませんが、pNFSがスパースファイルをサポートするために使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1--Terminology">
6.1. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regular file: An object of file type NF4REG or NF4NAMEDATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常のファイル：ファイルタイプNF4REGまたはNF4NAMEDATTRのオブジェクト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sparse file: A regular file that contains one or more holes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スパースファイル：1つ以上の穴を含む通常のファイル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hole: A byte range within a sparse file that contains all zeros. A hole might or might not have space allocated or reserved to it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホール：すべてゼロを含むスパースファイル内のバイト範囲。ホールには、スペースが割り当てられたり、予約されたりする場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2--New-Operations">
6.2. New Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. 新しいオペレーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-1--READPLUS">
6.2.1. READ_PLUS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. READ_PLUS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ_PLUS is a new variant of the NFSv4.1 READ operation [RFC5661]. Besides being able to support all of the data semantics of the READ operation, it can also be used by the client and server to efficiently transfer holes. Because the client does not know in advance whether a hole is present or not, if the client supports READ_PLUS and so does the server, then it should always use the READ_PLUS operation in preference to the READ operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ_PLUSは、NFSv4.1 READ操作の新しいバリアントです[RFC5661]。 READ操作のすべてのデータセマンティクスをサポートできるほか、クライアントとサーバーが効率的にホールを転送するためにも使用できます。クライアントはホールが存在するかどうかを事前に知らないため、クライアントがREAD_PLUSをサポートし、サーバーもサポートしている場合、READ操作よりも常にREAD_PLUS操作を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ_PLUS extends the response with a new arm representing holes to avoid returning data for portions of the file that are initialized to zero and may or may not contain a backing store. Returning actual data blocks corresponding to holes wastes computational and network resources, thus reducing performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ_PLUSは、穴を表す新しいアームで応答を拡張し、ゼロに初期化され、バッキングストアが含まれている場合と含まれていない場合があるファイルの部分のデータを返さないようにします。ホールに対応する実際のデータブロックを返すと、計算リソースとネットワークリソースが浪費され、パフォーマンスが低下します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client sends a READ operation, it is not prepared to accept a READ_PLUS-style response providing a compact encoding of the scope of holes. If a READ occurs on a sparse file, then the server must expand such data to be raw bytes. If a READ occurs in the middle of a hole, the server can only send back bytes starting from that offset. By contrast, if a READ_PLUS occurs in the middle of a hole, the server can send back a range that starts before the offset and extends past the requested length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがREAD操作を送信するとき、ホールのスコープのコンパクトなエンコーディングを提供するREAD_PLUSスタイルの応答を受け入れる準備はできていません。スパースファイルでREADが発生した場合、サーバーはそのようなデータを生のバイトに拡張する必要があります。ホールの途中でREADが発生した場合、サーバーはそのオフセットから始まるバイトのみを送信できます。対照的に、READ_PLUSがホールの中央で発生した場合、サーバーは、オフセットの前に開始し、要求された長さを超える範囲を送り返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2-2--DEALLOCATE">
6.2.2. DEALLOCATE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. 割り当て解除
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client can use the DEALLOCATE operation on a range of a file as a hole punch, which allows the client to avoid the transfer of a repetitive pattern of zeros across the network. This hole punch is a result of the unreserved space returning all zeros until overwritten.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、ファイルの範囲に対するDEALLOCATE操作をホールパンチとして使用できます。これにより、クライアントは、ネットワーク上でゼロの反復パターンが転送されることを回避できます。このホールパンチは、予約されていないスペースが上書きされるまですべてゼロを返す結果です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Space-Reservation">
7. Space Reservation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. スペース予約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications want to be able to reserve space for a file, report the amount of actual disk space a file occupies, and free up the backing space of a file when it is not required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、ファイル用のスペースを予約し、ファイルが占有する実際のディスクスペースの量を報告し、必要のないときにファイルのバッキングスペースを解放できることを望んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One example is the posix_fallocate() operation [posix_fallocate], which allows applications to ask for space reservations from the operating system, usually to provide a better file layout and reduce overhead for random or slow-growing file-appending workloads.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つの例は、posix_fallocate()オペレーション[posix_fallocate]です。これにより、アプリケーションはオペレーティングシステムからスペース予約を要求できるようになり、通常はファイルレイアウトが改善され、ランダムまたはゆっくりと増加するファイル追加ワークロードのオーバーヘッドが削減されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another example is space reservation for virtual disks in a hypervisor. In virtualized environments, virtual disk files are often stored on NFS-mounted volumes. When a hypervisor creates a virtual disk file, it often tries to preallocate the space for the file so that there are no future allocation-related errors during the operation of the VM. Such errors prevent a VM from continuing execution and result in downtime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別の例は、ハイパーバイザー内の仮想ディスクのスペース予約です。仮想化環境では、仮想ディスクファイルは多くの場合NFSマウントされたボリュームに保存されます。ハイパーバイザーが仮想ディスクファイルを作成するとき、ハイパーバイザーは多くの場合、ファイルのスペースを事前に割り当てようとするため、VMの操作中に将来の割り当て関連のエラーは発生しません。このようなエラーにより、VMが実行を継続できなくなり、ダウンタイムが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Currently, in order to achieve such a guarantee, applications zero the entire file. The initial zeroing allocates the backing blocks, and all subsequent writes are overwrites of already-allocated blocks. This approach is not only inefficient in terms of the amount of I/O done; it is also not guaranteed to work on file systems that are log-structured or deduplicated. An efficient way of guaranteeing space reservation would be beneficial to such applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在、このような保証を実現するために、アプリケーションはファイル全体をゼロにします。最初のゼロ化によりバッキングブロックが割り当てられ、その後の書き込みはすべて、すでに割り当てられているブロックの上書きになります。このアプローチは、実行されるI / O量の点で非効率であるだけではありません。また、ログ構造または重複排除されたファイルシステムでの動作も保証されていません。スペース予約を保証する効率的な方法は、このようなアプリケーションにとって有益です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The new ALLOCATE operation (see Section 15.1) allows a client to request a guarantee that space will be available. The ALLOCATE operation guarantees that any future writes to the region it was successfully called for will not fail with NFS4ERR_NOSPC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいALLOCATE操作（セクション15.1を参照）により、クライアントはスペースが使用可能であることの保証を要求できます。 ALLOCATE操作は、正常に呼び出された領域への今後の書き込みがNFS4ERR_NOSPCで失敗しないことを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another useful feature is the ability to report the number of blocks that would be freed when a file is deleted. Currently, NFS reports two size attributes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別の便利な機能は、ファイルが削除されたときに解放されるブロックの数を報告する機能です。現在、NFSは2つのサイズ属性を報告しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
size The logical file size of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sizeファイルの論理ファイルサイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_used The size in bytes that the file occupies on disk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_usedファイルがディスク上で占めるサイズ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While these attributes are sufficient for space accounting in traditional file systems, they prove to be inadequate in modern file systems that support block-sharing. In such file systems, multiple inodes (the metadata portion of the file system object) can point to a single block with a block reference count to guard against premature freeing. Having a way to tell the number of blocks that would be freed if the file was deleted would be useful to applications that wish to migrate files when a volume is low on space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの属性は、従来のファイルシステムでのスペースアカウンティングには十分ですが、ブロック共有をサポートする最新のファイルシステムでは不十分であることがわかります。このようなファイルシステムでは、複数のiノード（ファイルシステムオブジェクトのメタデータ部分）が、ブロック参照カウントを持つ単一のブロックをポイントして、早期の解放を防ぐことができます。ファイルが削除された場合に解放されるブロック数を通知する方法があれば、ボリュームのスペースが少ないときにファイルを移行したいアプリケーションに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since virtual disks represent a hard drive in a VM, a virtual disk can be viewed as a file system within a file. Since not all blocks within a file system are in use, there is an opportunity to reclaim blocks that are no longer in use. A call to deallocate blocks could result in better space efficiency; less space might be consumed for backups after block deallocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仮想ディスクはVM内のハードドライブを表すため、仮想ディスクはファイル内のファイルシステムと見なすことができます。ファイルシステム内のすべてのブロックが使用されているわけではないため、使用されなくなったブロックを再利用する機会があります。ブロックの割り当て解除を呼び出すと、スペース効率が向上する可能性があります。ブロックの割り当て解除後、バックアップに消費されるスペースが少なくなる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following attribute and operation can be used to resolve these issues:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の属性と操作を使用して、これらの問題を解決できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_freed This attribute reports the space that would be freed when a file is deleted, taking block-sharing into consideration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_freedこの属性は、ブロック共有を考慮して、ファイルが削除されたときに解放されるスペースを報告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DEALLOCATE This operation deallocates the blocks backing a region of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DEALLOCATEこの操作は、ファイルの領域をバッキングするブロックの割り当てを解除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If space_used of a file is interpreted to mean the size in bytes of all disk blocks pointed to by the inode of the file, then shared blocks get double-counted, over-reporting the space utilization. This also has the adverse effect that the deletion of a file with shared blocks frees up less than space_used bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルのspace_usedが、ファイルのiノードが指すすべてのディスクブロックのバイト単位のサイズを意味すると解釈された場合、共有ブロックが二重にカウントされ、スペース使用率が過剰に報告されます。これは、共有ブロックを含むファイルを削除すると、space_usedバイト未満しか解放されないという悪影響もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On the other hand, if space_used is interpreted to mean the size in bytes of those disk blocks unique to the inode of the file, then shared blocks are not counted in any file, resulting in under-reporting of the space utilization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方、space_usedがファイルのiノードに固有のディスクブロックのバイト単位のサイズを意味すると解釈された場合、共有ブロックはどのファイルでもカウントされず、スペース使用率が過小報告されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, two files, A and B, have 10 blocks each. Let six of these blocks be shared between them. Thus, the combined space utilized by the two files is 14 * BLOCK_SIZE bytes. In the former case, the combined space utilization of the two files would be reported as 20 * BLOCK_SIZE. However, deleting either would only result in 4 * BLOCK_SIZE being freed. Conversely, the latter interpretation would report that the space utilization is only 8 * BLOCK_SIZE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、AとBの2つのファイルには、それぞれ10個のブロックがあります。これらのブロックのうち6つをそれらの間で共有します。したがって、2つのファイルが使用するスペースの合計は14 * BLOCK_SIZEバイトです。前者の場合、2つのファイルの合計スペース使用率は20 * BLOCK_SIZEとして報告されます。ただし、どちらかを削除しても4 * BLOCK_SIZEが解放されるだけです。逆に、後者の解釈では、スペース使用率は8 * BLOCK_SIZEのみであると報告されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using the space_freed attribute (see Section 12.2.2) is helpful in solving this problem. space_freed is the number of blocks that are allocated to the given file that would be freed on its deletion. In the example, both A and B would report space_freed as 4 * BLOCK_SIZE and space_used as 10 * BLOCK_SIZE. If A is deleted, B will report space_freed as 10 * BLOCK_SIZE, as the deletion of B would result in the deallocation of all 10 blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_freed属性（セクション12.2.2を参照）を使用すると、この問題を解決できます。 space_freedは、指定のファイルに割り当てられ、削除時に解放されるブロックの数です。この例では、AとBの両方がspace_freedを4 * BLOCK_SIZEとして報告し、space_usedを10 * BLOCK_SIZEとして報告します。 Aを削除すると、Bを削除すると10ブロックすべての割り当てが解除されるため、Bはspace_freedを10 * BLOCK_SIZEとして報告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using the space_freed attribute does not solve the problem of space being over-reported. However, over-reporting is better than under-reporting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_freed属性を使用しても、スペースが過剰に報告されるという問題は解決されません。ただし、過大報告は過少報告よりも優れています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Application-Data-Block-Support">
8. Application Data Block Support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. アプリケーションデータブロックのサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the OS level, files are contained on disk blocks. Applications are also free to impose structure on the data contained in a file and thus can define an Application Data Block (ADB) to be such a structure. From the application&#39;s viewpoint, it only wants to handle ADBs and not raw bytes (see [Strohm11]). An ADB is typically
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSレベルでは、ファイルはディスクブロックに含まれます。アプリケーションは、ファイルに含まれるデータに自由に構造を課すこともできるため、アプリケーションデータブロック（ADB）をそのような構造に定義できます。アプリケーションの観点からは、生のバイトではなくADBのみを処理したい（[Strohm11]を参照）。 ADBは通常
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
comprised of two sections: header and data. The header describes the characteristics of the block and can provide a means to detect corruption in the data payload. The data section is typically initialized to all zeros.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーとデータの2つのセクションで構成されます。ヘッダーはブロックの特性を説明し、データペイロードの破損を検出する手段を提供できます。通常、データセクションはすべてゼロに初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The format of the header is application specific, but there are two main components typically encountered:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーの形式はアプリケーション固有ですが、通常遭遇する2つの主要なコンポーネントがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. An Application Data Block Number (ADBN), which allows the application to determine which data block is being referenced. This is useful when the client is not storing the blocks in contiguous memory, i.e., a logical block number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. アプリケーションデータブロック番号（ADBN）。これにより、アプリケーションは参照されているデータブロックを判別できます。これは、クライアントがブロックを連続したメモリ、つまり論理ブロック番号に格納していない場合に役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Fields to describe the state of the ADB and a means to detect block corruption. For both pieces of data, a useful property would be that the allowed values are specially selected so that, if passed across the network, corruption due to translation between big-endian and little-endian architectures is detectable. For example, 0xf0dedef0 has the same (32 wide) bit pattern in both architectures, making it inappropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. ADBの状態を説明するフィールドと、ブロックの破損を検出する手段。両方のデータについて、有用なプロパティは、許可された値が特別に選択されるため、ネットワークを介して渡された場合に、ビッグエンディアンとリトルエンディアンのアーキテクチャ間の変換による破損が検出されることです。たとえば、0xf0dedef0は両方のアーキテクチャで同じ（32幅）ビットパターンを持っているため、不適切です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications already impose structures on files [Strohm11] and detect corruption in data blocks [Ashdown08]. What they are not able to do is efficiently transfer and store ADBs. To initialize a file with ADBs, the client must send each full ADB to the server, and that must be stored on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは既にファイルに構造を課し[Strohm11]、データブロックの破損を検出します[Ashdown08]。彼らができないことは、ADBを効率的に転送して保存することです。 ADBでファイルを初期化するには、クライアントが完全なADBをそれぞれサーバーに送信し、それがサーバーに格納されている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section defines a framework for transferring the ADB from client to server and presents one approach to detecting corruption in a given ADB implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、ADBをクライアントからサーバーに転送するためのフレームワークを定義し、特定のADB実装の破損を検出するための1つのアプローチを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1--Generic-Framework">
8.1. Generic Framework
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. 一般的なフレームワーク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The representation of the ADB needs to be flexible enough to support many different applications. The most basic approach is no imposition of a block at all, which entails working with the raw bytes. Such an approach would be useful for storing holes, punching holes, etc. In more complex deployments, a server might be supporting multiple applications, each with their own definition of the ADB. One might store the ADBN at the start of the block and then have a guard pattern to detect corruption [Section 11.4.3: Detecting Memory Corruption&#34;&#34;&gt;McDougall07]. The next might store the ADBN at an offset of 100 bytes within the block and have no guard pattern at all, i.e., existing applications might already have well-defined formats for their data blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ADBの表現は、多くの異なるアプリケーションをサポートするのに十分な柔軟性が必要です。最も基本的なアプローチは、ブロックを強制しないことです。これは、生のバイトを操作することを伴います。このようなアプローチは、ホールの格納、パンチングホールなどに役立ちます。より複雑なデプロイメントでは、サーバーが複数のアプリケーションをサポートし、それぞれが独自のADBの定義を持っている場合があります。 ADBNをブロックの先頭に保存してから、破損を検出するためのガードパターンを用意することができます[セクション11.4.3：メモリ破損の検出] &#34;&gt; McDougall07]。次は、ブロック内の100バイトのオフセットでADBNを格納し、ガードパターンをまったく持たない場合があります。つまり、既存のアプリケーションには、データブロックのフォーマットがすでに明確に定義されている場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The guard pattern can be used to represent the state of the block, to protect against corruption, or both. Again, it needs to be able to be placed anywhere within the ADB.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ガードパターンは、ブロックの状態を表す、破損から保護する、またはその両方に使用できます。ここでも、ADB内のどこにでも配置できる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both the starting offset of the block and the size of the block need to be represented. Note that nothing prevents the application from defining different-sized blocks in a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロックの開始オフセットとブロックのサイズの両方を表す必要があります。アプリケーションがファイル内で異なるサイズのブロックを定義することを妨げるものは何もないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1-1--Data-Block-Representation">
8.1.1. Data Block Representation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1. データブロック表現
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct app_data_block4 {
           offset4         adb_offset;
           length4         adb_block_size;
           length4         adb_block_count;
           length4         adb_reloff_blocknum;
           count4          adb_block_num;
           length4         adb_reloff_pattern;
           opaque          adb_pattern&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The app_data_block4 structure captures the abstraction presented for the ADB. The additional fields present are to allow the transmission of adb_block_count ADBs at one time. The adb_block_num is used to convey the ADBN of the first block in the sequence. Each ADB will contain the same adb_pattern string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
app_data_block4構造は、ADBに対して提示された抽象化をキャプチャします。存在する追加フ​​ィールドは、adb_block_count ADBを一度に送信できるようにすることです。 adb_block_numは、シーケンスの最初のブロックのADBNを伝達するために使用されます。各ADBには同じadb_pattern文字列が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As both adb_block_num and adb_pattern are optional, if either adb_reloff_pattern or adb_reloff_blocknum is set to NFS4_UINT64_MAX, then the corresponding field is not set in any of the ADBs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
adb_block_numとadb_patternはどちらもオプションであるため、adb_reloff_patternまたはadb_reloff_blocknumがNFS4_UINT64_MAXに設定されている場合、対応するフィールドはどのADBにも設定されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2--An-Example-of-Detecting-Corruption">
8.2. An Example of Detecting Corruption
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. 破損の検出の例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this section, an example ADB format is defined in which corruption can be detected. Note that this is just one possible format and means to detect corruption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、破損を検出できるADB形式の例を定義します。これは可能な形式の1つにすぎず、破損を検出することを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider a very basic implementation of an operating system&#39;s disk blocks. A block is either data or an indirect block that allows for files that are larger than one block. It is desired to be able to initialize a block. Lastly, to quickly unlink a file, a block can be marked invalid. The contents remain intact; this would enable the OS application in question to undelete a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オペレーティングシステムのディスクブロックの非常に基本的な実装を検討してください。ブロックは、1つのブロックよりも大きいファイルを許可するデータまたは間接ブロックです。ブロックを初期化できることが望まれます。最後に、ファイルのリンクをすばやく解除するために、ブロックに無効のマークを付けることができます。内容はそのままです。これにより、問題のOSアプリケーションがファイルの削除を取り消すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application defines 4K-sized data blocks, with an 8-byte block counter occurring at offset 0 in the block, and with the guard pattern occurring at offset 8 inside the block. Furthermore, the guard pattern can take one of four states:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは4Kサイズのデータ​​ブロックを定義し、8バイトのブロックカウンターがブロック内のオフセット0で発生し、ガードパターンがブロック内のオフセット8で発生します。さらに、ガードパターンは次の4つの状態のいずれかになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0xfeedface - This is the FREE state and indicates that the ADB format has been applied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0xfeedface-これはFREE状態であり、ADB形式が適用されたことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0xcafedead - This is the DATA state and indicates that real data has been written to this block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0xcafedead-これはDATA状態であり、実際のデータがこのブロックに書き込まれたことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0xe4e5c001 - This is the INDIRECT state and indicates that the block contains block counter numbers that are chained off of this block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0xe4e5c001-これはINDIRECT状態であり、ブロックに、このブロックからチェーンされたブロックカウンター番号が含まれていることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0xba1ed4a3 - This is the INVALID state and indicates that the block contains data whose contents are garbage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0xba1ed4a3-これはINVALID状態であり、ブロックに内容が不要なデータが含まれていることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, it also defines an 8-byte checksum starting at byte 16 that applies to the remaining contents of the block (see [Baira08] for an example of using checksums to detect data corruption). If the state is FREE, then that checksum is trivially zero. As such, the application has no need to transfer the checksum implicitly inside the ADB -- it need not make the transfer layer aware of the fact that there is a checksum (see [Ashdown08] for an example of checksums used to detect corruption in application data blocks).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、ブロックの残りの内容に適用されるバイト16から始まる8バイトのチェックサムも定義します（チェックサムを使用してデータの破損を検出する例については、[Baira08]を参照してください）。状態がFREEの場合、そのチェックサムはゼロです。したがって、アプリケーションはADB内で暗黙的にチェックサムを転送する必要はありません-アプリケーションの破損を検出するために使用されるチェックサムの例については、チェックサムがあることを転送層に認識させる必要はありません（[Ashdown08]を参照）。データブロック）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Corruption in each ADB can thus be detected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、各ADBの破損を検出できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the guard pattern is anything other than one of the allowed values, including all zeros.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ガードパターンがすべてのゼロを含む、許可された値のいずれか以外の場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the guard pattern is FREE and any other byte in the remainder of the ADB is anything other than zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ガードパターンがFREEで、ADBの残りのバイトがゼロ以外の場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the guard pattern is anything other than FREE, then if the stored checksum does not match the computed checksum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ガードパターンがFREE以外の場合、格納されているチェックサムが計算されたチェックサムと一致しない場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the guard pattern is INDIRECT and one of the stored indirect block numbers has a value greater than the number of ADBs in the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ガードパターンがINDIRECTで、保存されている間接ブロック番号の1つに、ファイル内のADBの数より大きい値がある場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the guard pattern is INDIRECT and one of the stored indirect block numbers is a duplicate of another stored indirect block number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ガードパターンがINDIRECTで、格納されている間接ブロック番号の1つが、別の格納されている間接ブロック番号の複製である場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As can be seen, the application can detect errors based on the combination of the guard pattern state and the checksum but also can detect corruption based on the state and the contents of the ADB.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ご覧のように、アプリケーションはガードパターンの状態とチェックサムの組み合わせに基づいてエラーを検出できますが、ADBの状態と内容に基づいて破損を検出することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This last point is important in validating the minimum amount of data incorporated into the generic framework. That is, the guard pattern is sufficient in allowing applications to design their own corruption detection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この最後の点は、一般的なフレームワークに組み込まれるデータの最小量を検証する上で重要です。つまり、アプリケーションが独自の破損検出を設計できるようにするには、ガードパターンで十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, it is important to note that none of these corruption checks occur in the transport layer. The server and client components are totally unaware of the file format and might report everything as being transferred correctly, even in cases where the application detects corruption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、これらの破損チェックはトランスポート層では発生しないことに注意することが重要です。サーバーとクライアントのコンポーネントは、ファイル形式をまったく認識せず、アプリケーションが破損を検出した場合でも、すべてが正しく転送されていると報告する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-3--An-Example-of-READPLUS">
8.3. An Example of READ_PLUS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. READ_PLUSの例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The hypothetical application presented in Section 8.2 can be used to illustrate how READ_PLUS would return an array of results. A file is created and initialized with 100 4K ADBs in the FREE state with the WRITE_SAME operation (see Section 15.12):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション8.2で示した架空のアプリケーションを使用して、READ_PLUSが結果の配列を返す方法を説明できます。ファイルが作成され、WRITE_SAME操作でFREE状態の100個の4K ADBで初期化されます（セクション15.12を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
WRITE_SAME {0, 4K, 100, 0, 0, 8, 0xfeedface}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
WRITE_SAME {0、4K、100、0、0、8、0xfeedface}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Further, assume that the application writes a single ADB at 16K, changing the guard pattern to 0xcafedead; then there would be in memory:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、アプリケーションが16Kで単一のADBを書き込み、ガードパターンを0xcafedeadに変更するとします。その後、メモリにあります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0K -&gt;   (4K - 1) : 00 00 00 00 ... fe ed fa ce 00 00 ... 00
       4K -&gt;   (8K - 1) : 00 00 00 01 ... fe ed fa ce 00 00 ... 00
       8K -&gt;  (12K - 1) : 00 00 00 02 ... fe ed fa ce 00 00 ... 00
      12K -&gt;  (16K - 1) : 00 00 00 03 ... fe ed fa ce 00 00 ... 00
      16K -&gt;  (20K - 1) : 00 00 00 04 ... ca fe de ad 00 00 ... 00
      20K -&gt;  (24K - 1) : 00 00 00 05 ... fe ed fa ce 00 00 ... 00
      24K -&gt;  (28K - 1) : 00 00 00 06 ... fe ed fa ce 00 00 ... 00
         ...
     396K -&gt; (400K - 1) : 00 00 00 63 ... fe ed fa ce 00 00 ... 00
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
And when the client did a READ_PLUS of 64K at the start of the file, it could get back a result of data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、クライアントがファイルの先頭で64KのREAD_PLUSを実行すると、データの結果を返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0K -&gt;   (4K - 1) : 00 00 00 00 ... fe ed fa ce 00 00 ... 00
       4K -&gt;   (8K - 1) : 00 00 00 01 ... fe ed fa ce 00 00 ... 00
       8K -&gt;  (12K - 1) : 00 00 00 02 ... fe ed fa ce 00 00 ... 00
      12K -&gt;  (16K - 1) : 00 00 00 03 ... fe ed fa ce 00 00 ... 00
      16K -&gt;  (20K - 1) : 00 00 00 04 ... ca fe de ad 00 00 ... 00
      20K -&gt;  (24K - 1) : 00 00 00 05 ... fe ed fa ce 00 00 ... 00
      24K -&gt;  (28K - 1) : 00 00 00 06 ... fe ed fa ce 00 00 ... 00
         ...
      62K -&gt;  (64K - 1) : 00 00 00 15 ... fe ed fa ce 00 00 ... 00
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-4--An-Example-of-Zeroing-Space">
8.4. An Example of Zeroing Space
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. スペースのゼロ化の例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A simpler use case for WRITE_SAME is applications that want to efficiently zero out a file, but do not want to modify space reservations. This can easily be achieved by a call to WRITE_SAME without an ADB block numbers and pattern, e.g.:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITE_SAMEのより単純な使用例は、ファイルを効率的にゼロ化したいが、スペース予約を変更したくないアプリケーションです。これは、ADBブロック番号とパターンなしでWRITE_SAMEを呼び出すことで簡単に実現できます。例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
WRITE_SAME {0, 1K, 10000, 0, 0, 0, 0}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
WRITE_SAME {0、1K、10000、0、0、0、0}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--Labeled-NFS">
9. Labeled NFS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. ラベル付きNFS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Access control models such as UNIX permissions or Access Control Lists (ACLs) are commonly referred to as Discretionary Access Control (DAC) models. These systems base their access decisions on user identity and resource ownership. In contrast, Mandatory Access Control (MAC) models base their access control decisions on the label on the subject (usually a process) and the object it wishes to access [RFC4949]. These labels may contain user identity information but usually contain additional information. In DAC systems, users are free to specify the access rules for resources that they own. MAC models base their security decisions on a system-wide policy -- established by an administrator or organization -- that the users do not have the ability to override. In this section, a MAC model is added to NFSv4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIXアクセス許可やアクセス制御リスト（ACL）などのアクセス制御モデルは、一般に随意アクセス制御（DAC）モデルと呼ばれます。これらのシステムは、ユーザーIDとリソースの所有権に基づいてアクセスを決定します。対照的に、強制アクセス制御（MAC）モデルは、サブジェクト（通常はプロセス）とアクセスしたいオブジェクトのラベルに基づいてアクセス制御の決定を行います[RFC4949]。これらのラベルにはユーザーID情報が含まれる場合がありますが、通常は追加情報が含まれます。 DACシステムでは、ユーザーは自分が所有するリソースのアクセスルールを自由に指定できます。 MACモデルは、システム全体のポリシー（管理者または組織によって確立された）に基づいてセキュリティの決定を行います。これは、ユーザーがオーバーライドすることはできません。このセクションでは、NFSv4.2にMACモデルが追加されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, a method is provided for transporting and storing security label data on NFSv4 file objects. Security labels have several semantics that are met by NFSv4 recommended attributes such as the ability to set the label value upon object creation. Access control on these attributes is done through a combination of two mechanisms. As with other recommended attributes on file objects, the usual DAC checks, based on the ACLs and permission bits, will be performed to ensure that proper file ownership is enforced. In addition, a MAC system MAY be employed on the client, server, or both to enforce additional policy on what subjects may modify security label information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まず、NFSv4ファイルオブジェクトにセキュリティラベルデータを転送して保存する方法が提供されます。セキュリティラベルには、オブジェクトの作成時にラベル値を設定する機能など、NFSv4の推奨属性が満たすセマンティクスがいくつかあります。これらの属性のアクセス制御は、2つのメカニズムの組み合わせによって行われます。ファイルオブジェクトの他の推奨属性と同様に、通常のDACチェックは、ACLとアクセス許可ビットに基づいて実行され、適切なファイル所有権が適用されていることを確認します。さらに、MACシステムをクライアント、サーバー、またはその両方で使用して、セキュリティラベル情報を変更する可能性のあるサブジェクトに追加のポリシーを適用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Second, a method is described for the client to determine if an NFSv4 file object security label has changed. A client that needs to know if a label on a file or set of files is going to change SHOULD request a delegation on each labeled file. In order to change such a security label, the server will have to recall delegations on any file affected by the label change, so informing clients of the label change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、クライアントがNFSv4ファイルオブジェクトのセキュリティラベルが変更されたかどうかを判断する方法について説明します。ファイルまたはファイルセットのラベルが変更されるかどうかを知る必要のあるクライアントは、各ラベル付きファイルの委任を要求する必要があります（SHOULD）。このようなセキュリティラベルを変更するには、サーバーはラベルの変更の影響を受けるファイルの委任を呼び戻す必要があるため、クライアントにラベルの変更を通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An additional useful feature would be modification to the RPC layer used by NFSv4 to allow RPCs to assert client process subject security labels and enable the enforcement of Full Mode as described in Section 9.5.1. Such modifications are outside the scope of this document (see [RFC7861]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加の便利な機能は、NFSv4によって使用されるRPCレイヤーの変更であり、RPCがクライアントプロセスサブジェクトセキュリティラベルをアサートし、セクション9.5.1で説明されているようにフルモードの実施を可能にします。このような変更は、このドキュメントの範囲外です（[RFC7861]を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1--Definitions">
9.1. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. 定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Label Format Specifier (LFS): an identifier used by the client to establish the syntactic format of the security label and the semantic meaning of its components. LFSs exist in a registry associated with documents describing the format and semantics of the label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ラベル形式指定子（LFS）：セキュリティラベルの構文形式とそのコンポーネントの意味の意味を確立するためにクライアントが使用する識別子。 LFSは、ラベルのフォーマットとセマンティクスを説明するドキュメントに関連付けられたレジストリに存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security Label Format Selection Registry: the IANA registry (see [RFC7569]) containing all registered LFSs, along with references to the documents that describe the syntactic format and semantics of the security label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティラベル形式選択レジストリ：すべての登録済みLFSを含むIANAレジストリ（[RFC7569]を参照）、およびセキュリティラベルの構文形式とセマンティクスを説明するドキュメントへの参照。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Policy Identifier (PI): an optional part of the definition of an LFS. The PI allows clients and servers to identify specific security policies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポリシー識別子（PI）：LFSの定義のオプションの部分。 PIにより、クライアントとサーバーは特定のセキュリティポリシーを識別できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Object: a passive resource within the system that is to be protected. Objects can be entities such as files, directories, pipes, sockets, and many other system resources relevant to the protection of the system state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクト：保護されるシステム内のパッシブリソース。オブジェクトは、ファイル、ディレクトリ、パイプ、ソケット、およびシステム状態の保護に関連する他の多くのシステムリソースなどのエンティティです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Subject: an active entity, usually a process that is requesting access to an object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
件名：アクティブなエンティティ、通常はオブジェクトへのアクセスを要求しているプロセス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC-Aware: a server that can transmit and store object labels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC対応：オブジェクトラベルを送信および保存できるサーバー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC-Functional: a client or server that is Labeled NFS enabled. Such a system can interpret labels and apply policies based on the security system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC機能：NFSのラベルが有効になっているクライアントまたはサーバー。このようなシステムは、セキュリティシステムに基づいてラベルを解釈し、ポリシーを適用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multi-Level Security (MLS): a traditional model where objects are given a sensitivity level (Unclassified, Secret, Top Secret, etc.) and a category set (see [LB96], [RFC1108], [RFC2401], and [RFC4949]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチレベルセキュリティ（MLS）：オブジェクトに機密レベル（未分類、シークレット、トップシークレットなど）とカテゴリセット（[LB96]、[RFC1108]、[RFC2401]、および[RFC4949を参照] ]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(Note: RFC 2401 has been obsoleted by RFC 4301, but we list RFC 2401 here because RFC 4301 does not discuss MLS.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
（注：RFC 2401はRFC 4301によって廃止されましたが、RFC 4301はMLSについて説明していないため、ここではRFC 2401をリストしています。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2--MAC-Security-Attribute">
9.2. MAC Security Attribute
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. MACセキュリティ属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC models base access decisions on security attributes bound to subjects (usually processes) and objects (for NFS, file objects). This information can range from a user identity for an identity-based MAC model, sensitivity levels for MLS, or a type for type enforcement. These models base their decisions on different criteria, but the semantics of the security attribute remain the same. The semantics required by the security attribute are listed below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MACモデルは、サブジェクト（通常はプロセス）とオブジェクト（NFSの場合はファイルオブジェクト）にバインドされたセキュリティ属性に基づいてアクセス決定を行います。この情報は、IDベースのMACモデルのユーザーID、MLSの機密レベル、またはタイプ強制のタイプの範囲です。これらのモデルは、さまざまな基準に基づいて決定を行いますが、セキュリティ属性のセマンティクスは変わりません。セキュリティ属性に必要なセマンティクスは以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MUST provide flexibility with respect to the MAC model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MACモデルに関して柔軟性を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MUST provide the ability to atomically set security information upon object creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o オブジェクトの作成時にセキュリティ情報を自動的に設定する機能を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MUST provide the ability to enforce access control decisions on both the client and the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントとサーバーの両方でアクセス制御の決定を実施する機能を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MUST NOT expose an object to either the client or server namespace before its security information has been bound to it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o セキュリティ情報がバインドされる前に、オブジェクトをクライアントまたはサーバーの名前空間に公開してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4 implements the MAC security attribute as a recommended attribute. This attribute has a fixed format and semantics, which conflicts with the flexible nature of security attributes in general. To resolve this, the MAC security attribute consists of two components. The first component is an LFS, as defined in [RFC7569], to allow for interoperability between MAC mechanisms. The second component is an opaque field, which is the actual security attribute data. To allow for various MAC models, NFSv4 should be used solely as a transport mechanism for the security attribute. It is the responsibility of the endpoints to consume the security attribute and make access decisions based on their respective models. In addition, creation of objects through OPEN and CREATE allows the security attribute to be specified upon creation. By providing an atomic create and set operation for the security attribute, it is possible to enforce the second and fourth requirements listed above. The recommended attribute FATTR4_SEC_LABEL (see Section 12.2.4) will be used to satisfy this requirement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4は、MACセキュリティ属性を推奨属性として実装しています。この属性には固定の形式とセマンティクスがあり、一般にセキュリティ属性の柔軟な性質と競合します。これを解決するために、MACセキュリティ属性は2つのコンポーネントで構成されています。最初のコンポーネントは、[RFC7569]で定義されているLFSで、MACメカニズム間の相互運用を可能にします。 2番目のコンポーネントは不透明なフィールドで、実際のセキュリティ属性データです。さまざまなMACモデルに対応するには、NFSv4をセキュリティ属性のトランスポートメカニズムとしてのみ使用する必要があります。セキュリティ属性を使用し、それぞれのモデルに基づいてアクセスを決定するのは、エンドポイントの責任です。さらに、OPENおよびCREATEによるオブジェクトの作成では、作成時にセキュリティ属性を指定できます。セキュリティー属性にアトミックな作成および設定操作を提供することにより、上記の2番目と4番目の要件を適用できます。この要件を満たすために、推奨属性FATTR4_SEC_LABEL（セクション12.2.4を参照）が使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2-1--Delegations">
9.2.1. Delegations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.1. 代表団
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event that a security attribute is changed on the server while a client holds a delegation on the file, both the server and the client MUST follow the NFSv4.1 protocol (see Section 10 of [RFC5661]) with respect to attribute changes. It SHOULD flush all changes back to the server and relinquish the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがファイルの委任を保持している間にサーバーでセキュリティ属性が変更された場合、サーバーとクライアントの両方が属性の変更に関してNFSv4.1プロトコル（[RFC5661]のセクション10を参照）に従う必要があります。すべての変更をサーバーにフラッシュして、委任を放棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2-2--Permission-Checking">
9.2.2. Permission Checking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.2. 権限チェック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is not feasible to enumerate all possible MAC models and even levels of protection within a subset of these models. This means that the NFSv4 client and servers cannot be expected to directly make access control decisions based on the security attribute. Instead, NFSv4 should defer permission checking on this attribute to the host system. These checks are performed in addition to existing DAC and ACL checks outlined in the NFSv4 protocol. Section 9.5 gives a specific example of how the security attribute is handled under a particular MAC model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての可能なMACモデルを列挙し、さらにこれらのモデルのサブセット内の保護レベルを列挙することは不可能です。つまり、NFSv4クライアントとサーバーは、セキュリティ属性に基づいてアクセス制御を直接決定することはできません。代わりに、NFSv4はこの属性の権限チェックをホストシステムに委任する必要があります。これらのチェックは、NFSv4プロトコルで概説されている既存のDACおよびACLチェックに加えて実行されます。セクション9.5は、特定のMACモデルでのセキュリティ属性の処理方法の具体例を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2-3--Object-Creation">
9.2.3. Object Creation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.3. オブジェクトの作成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When creating files in NFSv4, the OPEN and CREATE operations are used. One of the parameters for these operations is an fattr4 structure containing the attributes the file is to be created with. This allows NFSv4 to atomically set the security attribute of files upon creation. When a client is MAC-Functional, it must always provide the initial security attribute upon file creation. In the event that the server is MAC-Functional as well, it should determine by policy whether it will accept the attribute from the client or instead make the determination itself. If the client is not MAC-Functional, then the MAC-Functional server must decide on a default label. A more in-depth explanation can be found in Section 9.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4でファイルを作成する場合、OPENおよびCREATE操作が使用されます。これらの操作のパラメーターの1つは、ファイルの作成に使用する属性を含むfattr4構造です。これにより、NFSv4は作成時にファイルのセキュリティ属性を自動的に設定できます。クライアントがMAC機能である場合、ファイル作成時に常に初期セキュリティ属性を提供する必要があります。サーバーもMAC機能である場合は、クライアントからの属性を受け入れるか、またはそれ自体を決定するかをポリシーによって決定する必要があります。クライアントがMAC機能ではない場合、MAC機能サーバーはデフォルトのラベルを決定する必要があります。より詳細な説明はセクション9.5にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2-4--Existing-Objects">
9.2.4. Existing Objects
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.4. 既存のオブジェクト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that under the MAC model, all objects must have labels. Therefore, if an existing server is upgraded to include Labeled NFS support, then it is the responsibility of the security system to define the behavior for existing objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MACモデルでは、すべてのオブジェクトにラベルが必要であることに注意してください。したがって、既存のサーバーをアップグレードしてLabeled NFSサポートを組み込む場合、既存のオブジェクトの動作を定義するのはセキュリティシステムの責任です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2-5--Label-Changes">
9.2.5. Label Changes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.5. ラベルの変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider a Guest Mode system (Section 9.5.3) in which the clients enforce MAC checks and the server has only a DAC security system that stores the labels along with the file data. In this type of system, a user with the appropriate DAC credentials on a client with poorly configured or disabled MAC labeling enforcement is allowed access to the file label (and data) on the server and can change the label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがMACチェックを実施し、サーバーがファイルデータと一緒にラベルを保存するDACセキュリティシステムのみを持つゲストモードシステム（セクション9.5.3）を考えてみます。このタイプのシステムでは、適切に設定されていないか無効になっているMACラベル付けの実施を備えたクライアントで適切なDAC資格情報を持つユーザーは、サーバー上のファイルラベル（およびデータ）へのアクセスを許可され、ラベルを変更できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients that need to know if a label on a file or set of files has changed SHOULD request a delegation on each labeled file so that a label change by another client will be known via the process described in Section 9.2.1, which must be followed: the delegation will be recalled, which effectively notifies the client of the change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルまたはファイルセットのラベルが変更されたかどうかを知る必要があるクライアントは、セクション9.2.1で説明されているプロセスを介して別のクライアントによるラベル変更が認識されるように、各ラベル付きファイルの委任を要求する必要があります（SHOULD）。 ：委任がリコールされ、クライアントに変更が事実上通知されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the MAC security policies on a client can be such that the client does not have access to the file unless it has a delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのMACセキュリティポリシーは、委任がない限り、クライアントがファイルにアクセスできないようにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3--pNFS-Considerations">
9.3. pNFS Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. pNFSに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The new FATTR4_SEC_LABEL attribute is metadata information, and as such the storage device is not aware of the value contained on the metadata server. Fortunately, the NFSv4.1 protocol [RFC5661] already has provisions for doing access-level checks from the storage device to the metadata server. In order for the storage device to validate the subject label presented by the client, it SHOULD utilize this mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいFATTR4_SEC_LABEL属性はメタデータ情報であるため、ストレージデバイスはメタデータサーバーに含まれている値を認識しません。さいわい、NFSv4.1プロトコル[RFC5661]には、ストレージデバイスからメタデータサーバーへのアクセスレベルチェックを実行するための機能がすでに用意されています。ストレージデバイスがクライアントによって提示されたサブジェクトラベルを検証するために、このメカニズムを利用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4--Discovery-of-Server-Labeled-NFS-Support">
9.4. Discovery of Server Labeled NFS Support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. サーバーラベル付きNFSサポートの検出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server can easily determine that a client supports Labeled NFS when it queries for the FATTR4_SEC_LABEL label for an object. Further, it can then determine which LFS the client understands. The client might want to discover whether the server supports Labeled NFS and which LFS the server supports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、オブジェクトのFATTR4_SEC_LABELラベルを照会するときに、クライアントがLabeled NFSをサポートしていることを簡単に判断できます。さらに、クライアントが理解できるLFSを判別できます。クライアントは、サーバーがラベル付きNFSをサポートしているかどうか、およびサーバーがサポートしているLFSを検出したい場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following COMPOUND MUST NOT be denied by any MAC label check:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のCOMPOUNDは、MACラベルチェックによって拒否されてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
PUTROOTFH, GETATTR {FATTR4_SEC_LABEL}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
PUTROOTFH、GETATTR {FATTR4_SEC_LABEL}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the server might have imposed a security flavor on the root that precludes such access. That is, if the server requires Kerberized access and the client presents a COMPOUND with AUTH_SYS, then the server is allowed to return NFS4ERR_WRONGSEC in this case. But if the client presents a correct security flavor, then the server MUST return the FATTR4_SEC_LABEL attribute with the supported LFS filled in.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがルートにセキュリティフレーバーを課している可能性があることに注意してください。つまり、サーバーがKerberos化されたアクセスを必要とし、クライアントがAUTH_SYSでCOMPOUNDを提示する場合、サーバーはこの場合にNFS4ERR_WRONGSECを返すことが許可されます。ただし、クライアントが正しいセキュリティフレーバーを提示する場合、サーバーはサポートされているLFSが入力されたFATTR4_SEC_LABEL属性を返さなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-5--MAC-Security-NFS-Modes-of-Operation">
9.5. MAC Security NFS Modes of Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5. MACセキュリティNFSの動作モード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 A system using Labeled NFS may operate in three modes (see Section 4 of [RFC7204]). The first mode provides the most protection and is called &#34;Full Mode&#34;. In this mode, both the client and server implement a MAC model allowing each end to make an access control decision. The second mode is a subset of the Full Mode and is called &#34;Limited Server Mode&#34;. In this mode, the server cannot enforce the labels, but it can store and transmit them. The remaining mode is called the &#34;Guest Mode&#34;; in this mode, one end of the connection is not implementing a MAC model and thus offers less protection than Full Mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Labeled NFSを使用するシステムは、3つのモードで動作する場合があります（[RFC7204]のセクション4を参照）。最初のモードは最も高い保護を提供し、「フルモード」と呼ばれます。このモードでは、クライアントとサーバーの両方がMACモデルを実装し、両端でアクセス制御を決定できるようにします。 2番目のモードはフルモードのサブセットであり、「制限付きサーバーモード」と呼ばれます。このモードでは、サーバーはラベルを強制できませんが、ラベルを保存および送信できます。残りのモードは「ゲストモード」と呼ばれます。このモードでは、接続の一方の端がMACモデルを実装していないため、フルモードよりも保護が不十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-5-1--Full-Mode">
9.5.1. Full Mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.1. フルモード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Full Mode environments consist of MAC-Functional NFSv4 servers and clients and may be composed of mixed MAC models and policies. The system requires that both the client and server have an opportunity to perform an access control check based on all relevant information within the network. The file object security attribute is provided using the mechanism described in Section 9.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フルモード環境は、MAC機能のNFSv4サーバーとクライアントで構成され、混合MACモデルとポリシーで構成されている場合があります。このシステムでは、クライアントとサーバーの両方に、ネットワーク内のすべての関連情報に基づいてアクセス制御チェックを実行する機会が必要です。ファイルオブジェクトのセキュリティ属性は、セクション9.2で説明されているメカニズムを使用して提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fully MAC-Functional NFSv4 servers are not possible in the absence of RPCSEC_GSSv3 [RFC7861] support for client process subject label assertion. However, servers may make decisions based on the RPC credential information available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントプロセスサブジェクトラベルアサーションに対するRPCSEC_GSSv3 [RFC7861]サポートがない場合、完全にMAC機能のNFSv4サーバーは不可能です。ただし、サーバーは、使用可能なRPC資格情報に基づいて決定を行う場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-5-1-1--Initial-Labeling-and-Translation">
9.5.1.1. Initial Labeling and Translation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.1.1. 最初のラベル付けと翻訳
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ability to create a file is an action that a MAC model may wish to mediate. The client is given the responsibility to determine the initial security attribute to be placed on a file. This allows the client to make a decision as to the acceptable security attribute to create a file with before sending the request to the server. Once the server receives the creation request from the client, it may choose to evaluate if the security attribute is acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルを作成する機能は、MACモデルが仲介したいと考えるアクションです。クライアントには、ファイルに配置する初期セキュリティ属性を決定する責任があります。これにより、クライアントは、サーバーに要求を送信する前に、ファイルを作成するための許容可能なセキュリティ属性について決定を下すことができます。サーバーがクライアントから作成要求を受信すると、セキュリティ属性が受け入れ可能かどうかを評価することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security attributes on the client and server may vary based on MAC model and policy. To handle this, the security attribute field has an LFS component. This component is a mechanism for the host to identify the format and meaning of the opaque portion of the security attribute. A Full Mode environment may contain hosts operating in several different LFSs. In this case, a mechanism for translating the opaque portion of the security attribute is needed. The actual translation function will vary based on MAC model and policy and is outside the scope of this document. If a translation is unavailable for a given LFS, then the request MUST be denied. Another recourse is to allow the host to provide a fallback mapping for unknown security attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーのセキュリティ属性は、MACモデルとポリシーによって異なる場合があります。これを処理するために、セキュリティ属性フィールドにはLFSコンポーネントがあります。このコンポーネントは、ホストがセキュリティ属性の不透明部分の形式と意味を識別するためのメカニズムです。フルモード環境には、複数の異なるLFSで動作するホストが含まれる場合があります。この場合、セキュリティ属性の不透明な部分を変換するメカニズムが必要です。実際の変換機能はMACモデルとポリシーに基づいて異なり、このドキュメントの範囲外です。特定のLFSで変換が利用できない場合は、要求を拒否する必要があります。もう1つの手段は、ホストが不明なセキュリティ属性のフォールバックマッピングを提供できるようにすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-5-1-2--Policy-Enforcement">
9.5.1.2. Policy Enforcement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.1.2. ポリシーの施行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In Full Mode, access control decisions are made by both the clients and servers. When a client makes a request, it takes the security attribute from the requesting process and makes an access control decision based on that attribute and the security attribute of the object it is trying to access. If the client denies that access, an RPC to the server is never made. If, however, the access is allowed, the client will make a call to the NFS server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
フルモードでは、アクセス制御の決定はクライアントとサーバーの両方によって行われます。クライアントが要求を行うと、クライアントは要求プロセスからセキュリティ属性を取得し、その属性とアクセスしようとしているオブジェクトのセキュリティ属性に基づいてアクセス制御を決定します。クライアントがそのアクセスを拒否した場合、サーバーへのRPCは行われません。ただし、アクセスが許可されている場合、クライアントはNFSサーバーを呼び出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server receives the request from the client, it uses any credential information conveyed in the RPC request and the attributes of the object the client is trying to access to make an access control decision. If the server&#39;s policy allows this access, it will fulfill the client&#39;s request; otherwise, it will return NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、クライアントから要求を受信すると、RPC要求で伝達された資格情報と、クライアントがアクセスしようとしているオブジェクトの属性を使用して、アクセス制御を決定します。サーバーのポリシーでこのアクセスが許可されている場合は、クライアントの要求を満たします。それ以外の場合は、NFS4ERR_ACCESSを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Future protocol extensions may also allow the server to factor into the decision a security label extracted from the RPC request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将来のプロトコル拡張により、サーバーはRPC要求から抽出されたセキュリティラベルを決定に含めることもできるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MAY validate security attributes supplied over the network to ensure that they are within a set of attributes permitted from a specific peer and, if not, reject them. Note that a system may permit a different set of attributes to be accepted from each peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、ネットワークを介して提供されるセキュリティ属性を検証して、それらが特定のピアから許可された属性のセット内にあることを確認し、そうでない場合は拒否します。システムは、各ピアから受け入れられる属性の異なるセットを許可する場合があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-5-2--Limited-Server-Mode">
9.5.2. Limited Server Mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.2. 限定サーバーモード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Limited Server mode (see Section 4.2 of [RFC7204]) consists of a server that is label aware but does not enforce policies. Such a server will store and retrieve all object labels presented by clients and will utilize the methods described in Section 9.2.5 to allow the clients to detect changing labels, but may not factor the label into access decisions. Instead, it will expect the clients to enforce all such access locally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制限付きサーバーモード（[RFC7204]のセクション4.2を参照）は、ラベルに対応しているがポリシーを適用しないサーバーで構成されています。このようなサーバーは、クライアントから提示されたすべてのオブジェクトラベルを格納および取得し、セクション9.2.5で説明されている方法を使用して、クライアントが変化するラベルを検出できるようにしますが、アクセス決定にラベルを含めることはできません。代わりに、クライアントがそのようなすべてのアクセスをローカルで実施することを期待します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-5-3--Guest-Mode">
9.5.3. Guest Mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.3. ゲストモード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Guest Mode implies that either the client or the server does not handle labels. If the client is not Labeled NFS aware, then it will not offer subject labels to the server. The server is the only entity enforcing policy and may selectively provide standard NFS services to clients based on their authentication credentials and/or associated network attributes (e.g., IP address, network interface). The level of trust and access extended to a client in this mode is configuration specific. If the server is not Labeled NFS aware, then it will not return object labels to the client. Clients in this environment may consist of groups implementing different MAC model policies. The system requires that all clients in the environment be responsible for access control checks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ゲストモードは、クライアントまたはサーバーがラベルを処理しないことを意味します。クライアントがラベル付きNFS対応でない場合、サーバーにサブジェクトラベルを提供しません。サーバーは唯一のエンティティ実行ポリシーであり、認証資格情報や関連するネットワーク属性（IPアドレス、ネットワークインターフェースなど）に基づいて、クライアントに標準のNFSサービスを選択的に提供できます。このモードでクライアントに拡張される信頼とアクセスのレベルは、構成固有です。サーバーがラベル付きNFS対応でない場合、サーバーはオブジェクトラベルをクライアントに返しません。この環境のクライアントは、異なるMACモデルポリシーを実装するグループで構成される場合があります。システムでは、環境内のすべてのクライアントがアクセス制御チェックを担当する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-6--Security-Considerations-for-Labeled-NFS">
9.6. Security Considerations for Labeled NFS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6. ラベル付きNFSのセキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on the level of protection the MAC system offers, there may be a requirement to tightly bind the security attribute to the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MACシステムが提供する保護レベルに応じて、セキュリティ属性をデータにしっかりとバインドする必要がある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When only one of the client or server enforces labels, it is important to realize that the other side is not enforcing MAC protections. Alternate methods might be in use to handle the lack of MAC support, and care should be taken to identify and mitigate threats from possible tampering outside of these methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントまたはサーバーの1つだけがラベルを適用する場合、もう一方がMAC保護を適用していないことを認識することが重要です。 MACサポートの欠如を処理するために別の方法が使用されている可能性があり、これらの方法の外で起こりうる改ざんから脅威を特定して軽減するように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example of this is that a server that modifies READDIR or LOOKUP results based on the client&#39;s subject label might want to always construct the same subject label for a client that does not present one. This will prevent a non-Labeled NFS client from mixing entries in the directory cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例として、クライアントのサブジェクトラベルに基づいてREADDIRまたはLOOKUPの結果を変更するサーバーが、サブジェクトラベルを提示しないクライアントに対して常に同じサブジェクトラベルを作成したい場合があります。これにより、ラベル付けされていないNFSクライアントがディレクトリキャッシュ内のエントリを混在させることがなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
10. Sharing Change Attribute Implementation Characteristics with NFSv4 Clients
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
10. 変更属性の実装特性をNFSv4クライアントと共有する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although both the NFSv4 [RFC7530] and NFSv4.1 [RFC5661] protocols define the change attribute as being mandatory to implement, there is little in the way of guidance as to its construction. The only mandated constraint is that the value must change whenever the file data or metadata changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4 [RFC7530]とNFSv4.1 [RFC5661]の両方のプロトコルでは、変更属性の実装が必須であると定義されていますが、その構成に関するガイダンスはほとんどありません。唯一の必須の制約は、ファイルデータまたはメタデータが変更されるたびに値を変更する必要があることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While this allows for a wide range of implementations, it also leaves the client with no way to determine which is the most recent value for the change attribute in a case where several RPCs have been issued in parallel. In other words, if two COMPOUNDs, both containing WRITE and GETATTR requests for the same file, have been issued in parallel, how does the client determine which of the two change attribute values returned in the replies to the GETATTR requests corresponds to the most recent state of the file? In some cases, the only recourse may be to send another COMPOUND containing a third GETATTR that is fully serialized with the first two.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、さまざまな実装が可能になりますが、複数のRPCが同時に発行された場合に、クライアントが変更属性の最新の値を判別する方法がなくなります。つまり、同じファイルに対するWRITE要求とGETATTR要求の両方を含む2つのCOMPOUNDが並行して発行された場合、クライアントは、GETATTR要求への応答で返された2つの変更属性値のうち、どれが最新のものに対応するかをどのように判断しますかファイルの状態？場合によっては、最初の2つで完全にシリアル化された3番目のGETATTRを含む別のCOMPOUNDを送信することが唯一の手段になることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2 avoids this kind of inefficiency by allowing the server to share details about how the change attribute is expected to evolve, so that the client may immediately determine which, out of the several change attribute values returned by the server, is the most recent. change_attr_type is defined as a new recommended attribute (see Section 12.2.3) and is a per-file system attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2は、サーバーが変更属性の展開方法に関する詳細を共有できるようにすることで、このような非効率性を回避し、クライアントがサーバーから返されたいくつかの変更属性値の中から最新のものを即座に判断できるようにします。 。 change_attr_typeは、新しい推奨属性（セクション12.2.3を参照）として定義され、ファイルシステムごとの属性です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11--Error-Values">
11. Error Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. エラー値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS error numbers are assigned to failed operations within a COMPOUND (COMPOUND or CB_COMPOUND) request. A COMPOUND request contains a number of NFS operations that have their results encoded in sequence in a COMPOUND reply. The results of successful operations will consist of an NFS4_OK status followed by the encoded results of the operation. If an NFS operation fails, an error status will be entered in the reply and the COMPOUND request will be terminated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSエラー番号は、COMPOUND（COMPOUNDまたはCB_COMPOUND）要求内の失敗した操作に割り当てられます。 COMPOUND要求には、その結果がCOMPOUND応答で順番にエンコードされたいくつかのNFS操作が含まれています。成功した操作の結果は、NFS4_OKステータスと、それに続く操作のエンコードされた結果で構成されます。 NFS操作が失敗した場合、エラーステータスが応答に入力され、COMPOUND要求が終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1--Error-Definitions">
11.1. Error Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. エラー定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          +-------------------------+--------+------------------+
          | Error                   | Number | Description      |
          +-------------------------+--------+------------------+
          | NFS4ERR_BADLABEL        | 10093  | Section 11.1.3.1 |
          | NFS4ERR_OFFLOAD_DENIED  | 10091  | Section 11.1.2.1 |
          | NFS4ERR_OFFLOAD_NO_REQS | 10094  | Section 11.1.2.2 |
          | NFS4ERR_PARTNER_NO_AUTH | 10089  | Section 11.1.2.3 |
          | NFS4ERR_PARTNER_NOTSUPP | 10088  | Section 11.1.2.4 |
          | NFS4ERR_UNION_NOTSUPP   | 10090  | Section 11.1.1.1 |
          | NFS4ERR_WRONG_LFS       | 10092  | Section 11.1.3.2 |
          +-------------------------+--------+------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
Table 1: Protocol Error Definitions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
表1：プロトコルエラーの定義
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1-1--General-Errors">
11.1.1. General Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1. 一般的なエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section deals with errors that are applicable to a broad set of different purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、さまざまな目的に適用できるエラーについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1-1-1--NFS4ERRUNIONNOTSUPP-Error-Code-10090">
11.1.1.1. NFS4ERR_UNION_NOTSUPP (Error Code 10090)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1.1. NFS4ERR_UNION_NOTSUPP（エラーコード10090）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One of the arguments to the operation is a discriminated union, and while the server supports the given operation, it does not support the selected arm of the discriminated union.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作の引数の1つは、識別された共用体であり、サーバーは指定された操作をサポートしていますが、選択された識別された共用体のアームをサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1-2--Server-to-Server-Copy-Errors">
11.1.2. Server-to-Server Copy Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2. サーバー間のコピーエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These errors deal with the interaction between server-to-server copies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのエラーは、サーバー間のコピー間の相互作用を扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1-2-1--NFS4ERROFFLOADDENIED-Error-Code-10091">
11.1.2.1. NFS4ERR_OFFLOAD_DENIED (Error Code 10091)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2.1. NFS4ERR_OFFLOAD_DENIED（エラーコード10091）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COPY offload operation is supported by both the source and the destination, but the destination is not allowing it for this file. If the client sees this error, it should fall back to the normal copy semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPYオフロード操作は、ソースと宛先の両方でサポートされていますが、宛先ではこのファイルを許可していません。クライアントでこのエラーが発生した場合は、通常のコピーセマンティクスにフォールバックする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1-2-2--NFS4ERROFFLOADNOREQS-Error-Code-10094">
11.1.2.2. NFS4ERR_OFFLOAD_NO_REQS (Error Code 10094)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2.2. NFS4ERR_OFFLOAD_NO_REQS（エラーコード10094）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COPY offload operation is supported by both the source and the destination, but the destination cannot meet the client requirements for either consecutive byte copy or synchronous copy. If the client sees this error, it should either relax the requirements (if any) or fall back to the normal copy semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPYオフロード操作は、ソースと宛先の両方でサポートされていますが、宛先は、連続バイトコピーまたは同期コピーのいずれかのクライアント要件を満たすことができません。クライアントでこのエラーが発生した場合は、要件があれば緩和するか、通常のコピーセマンティクスにフォールバックする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1-2-3--NFS4ERRPARTNERNOAUTH-Error-Code-10089">
11.1.2.3. NFS4ERR_PARTNER_NO_AUTH (Error Code 10089)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2.3. NFS4ERR_PARTNER_NO_AUTH（エラーコード10089）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The source server does not authorize a server-to-server COPY offload operation. This may be due to the client&#39;s failure to send the COPY_NOTIFY operation to the source server, the source server receiving a server-to-server copy offload request after the copy lease time expired, or some other permission problem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースサーバーは、サーバー間のCOPYオフロード操作を許可しません。これは、クライアントがCOPY_NOTIFY操作をソースサーバーに送信できなかったか、コピーリース時間が経過した後にサーバーからサーバーへのコピーオフロード要求を受信したか、またはその他の権限の問題が原因である可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The destination server does not authorize a server-to-server COPY offload operation. This may be due to an inter-server COPY request where the destination server requires RPCSEC_GSSv3 and it is not used, or some other permissions problem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先サーバーは、サーバー間のCOPYオフロード操作を許可しません。これは、宛先サーバーがRPCSEC_GSSv3を必要とし、それが使用されていないサーバー間COPY要求、またはその他の権限の問題が原因である可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1-2-4--NFS4ERRPARTNERNOTSUPP-Error-Code-10088">
11.1.2.4. NFS4ERR_PARTNER_NOTSUPP (Error Code 10088)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2.4. NFS4ERR_PARTNER_NOTSUPP（エラーコード10088）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remote server does not support the server-to-server COPY offload protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リモートサーバーは、サーバー間のCOPYオフロードプロトコルをサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1-3--Labeled-NFS-Errors">
11.1.3. Labeled NFS Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.3. ラベル付きNFSエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These errors are used in Labeled NFS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのエラーは、ラベル付きNFSで使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1-3-1--NFS4ERRBADLABEL-Error-Code-10093">
11.1.3.1. NFS4ERR_BADLABEL (Error Code 10093)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.3.1. NFS4ERR_BADLABEL（エラーコード10093）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The label specified is invalid in some manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたラベルは何らかの方法で無効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-1-3-2--NFS4ERRWRONGLFS-Error-Code-10092">
11.1.3.2. NFS4ERR_WRONG_LFS (Error Code 10092)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.3.2. NFS4ERR_WRONG_LFS（エラーコード10092）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LFS specified in the subject label is not compatible with the LFS in the object label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブジェクトラベルで指定されたLFSは、オブジェクトラベルのLFSと互換性がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-2--New-Operations-and-Their-Valid-Errors">
11.2. New Operations and Their Valid Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. 新しい操作とその有効なエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section contains a table that gives the valid error returns for each new NFSv4.2 protocol operation. The error code NFS4_OK (indicating no error) is not listed but should be understood to be returnable by all new operations. The error values for all other operations are defined in Section 15.2 of [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションには、新しいNFSv4.2プロトコル操作ごとに有効なエラーが返される表が含まれています。エラーコードNFS4_OK（エラーがないことを示す）はリストされていませんが、すべての新しい操作で返されると理解されているはずです。他のすべての操作のエラー値は、[RFC5661]のセクション15.2で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----------------+--------------------------------------------------+
   | Operation      | Errors                                           |
   +----------------+--------------------------------------------------+
   | ALLOCATE       | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,            |
   |                | NFS4ERR_EXPIRED, NFS4ERR_FBIG,                   |
   |                | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |
   |                | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_MOVED,        |
   |                | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,             |
   |                | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |
   |                | NFS4ERR_OPENMODE, NFS4ERR_OP_NOT_IN_SESSION,     |
   |                | NFS4ERR_REP_TOO_BIG,                             |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,               |
   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,                  |
   |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE         |
   +----------------+--------------------------------------------------+
   | CLONE          | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,            |
   |                | NFS4ERR_EXPIRED, NFS4ERR_FBIG,                   |
   |                | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |
   |                | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_MOVED,        |
   |                | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,             |
   |                | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |
   |                | NFS4ERR_OPENMODE, NFS4ERR_OP_NOT_IN_SESSION,     |
   |                | NFS4ERR_REP_TOO_BIG,                             |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,               |
   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,                  |
   |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE,        |
   |                | NFS4ERR_XDEV                                     |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----------------+--------------------------------------------------+
   | COPY           | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,            |
   |                | NFS4ERR_EXPIRED, NFS4ERR_FBIG,                   |
   |                | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |
   |                | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,       |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_NOSPC, NFS4ERR_OFFLOAD_DENIED,           |
   |                | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,           |
   |                | NFS4ERR_OP_NOT_IN_SESSION,                       |
   |                | NFS4ERR_PARTNER_NO_AUTH,                         |
   |                | NFS4ERR_PARTNER_NOTSUPP, NFS4ERR_PNFS_IO_HOLE,   |
   |                | NFS4ERR_PNFS_NO_LAYOUT, NFS4ERR_REP_TOO_BIG,     |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,               |
   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,                  |
   |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE         |
   +----------------+--------------------------------------------------+
   | COPY_NOTIFY    | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,          |
   |                | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |
   |                | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,       |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,           |
   |                | NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PNFS_IO_HOLE, |
   |                | NFS4ERR_PNFS_NO_LAYOUT, NFS4ERR_REP_TOO_BIG,     |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,              |
   |                | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,           |
   |                | NFS4ERR_WRONG_TYPE                               |
   +----------------+--------------------------------------------------+
   | DEALLOCATE     | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,          |
   |                | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,  |
   |                | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR,        |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |
   |                | NFS4ERR_OPENMODE, NFS4ERR_OP_NOT_IN_SESSION,     |
   |                | NFS4ERR_REP_TOO_BIG,                             |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,               |
   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,                  |
   |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE         |
   +----------------+--------------------------------------------------+
   | GETDEVICELIST  | NFS4ERR_NOTSUPP                                  |
   +----------------+--------------------------------------------------+
   | IO_ADVISE      | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,          |
   |                | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,  |
   |                | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR,        |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |
   |                | NFS4ERR_OP_NOT_IN_SESSION,                       |
   |                | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_SERVERFAULT, |
   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,                  |
   |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE         |
   +----------------+--------------------------------------------------+
   | LAYOUTERROR    | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,           |
   |                | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION,        |
   |                | NFS4ERR_DELAY, NFS4ERR_DELEG_REVOKED,            |
   |                | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,              |
   |                | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_ISDIR,     |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_NOTSUPP, NFS4ERR_NO_GRACE,               |
   |                | NFS4ERR_OLD_STATEID, NFS4ERR_OP_NOT_IN_SESSION,  |
   |                | NFS4ERR_REP_TOO_BIG,                             |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,              |
   |                | NFS4ERR_TOO_MANY_OPS,                            |
   |                | NFS4ERR_UNKNOWN_LAYOUTTYPE, NFS4ERR_WRONG_CRED,  |
   |                | NFS4ERR_WRONG_TYPE                               |
   +----------------+--------------------------------------------------+
   | LAYOUTSTATS    | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,           |
   |                | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION,        |
   |                | NFS4ERR_DELAY, NFS4ERR_DELEG_REVOKED,            |
   |                | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,              |
   |                | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_ISDIR,     |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_NOTSUPP, NFS4ERR_NO_GRACE,               |
   |                | NFS4ERR_OLD_STATEID, NFS4ERR_OP_NOT_IN_SESSION,  |
   |                | NFS4ERR_REP_TOO_BIG,                             |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,              |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                | NFS4ERR_TOO_MANY_OPS,                            |
   |                | NFS4ERR_UNKNOWN_LAYOUTTYPE, NFS4ERR_WRONG_CRED,  |
   |                | NFS4ERR_WRONG_TYPE                               |
   +----------------+--------------------------------------------------+
   | OFFLOAD_CANCEL | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,           |
   |                | NFS4ERR_BAD_STATEID, NFS4ERR_COMPLETE_ALREADY,   |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_EXPIRED, NFS4ERR_GRACE, NFS4ERR_NOTSUPP, |
   |                | NFS4ERR_OLD_STATEID, NFS4ERR_OP_NOT_IN_SESSION,  |
   |                | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS        |
   +----------------+--------------------------------------------------+
   | OFFLOAD_STATUS | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,           |
   |                | NFS4ERR_BAD_STATEID, NFS4ERR_COMPLETE_ALREADY,   |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_EXPIRED, NFS4ERR_GRACE, NFS4ERR_NOTSUPP, |
   |                | NFS4ERR_OLD_STATEID, NFS4ERR_OP_NOT_IN_SESSION,  |
   |                | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS        |
   +----------------+--------------------------------------------------+
   | READ_PLUS      | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,          |
   |                | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |
   |                | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,       |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |
   |                | NFS4ERR_OPENMODE, NFS4ERR_OP_NOT_IN_SESSION,     |
   |                | NFS4ERR_PARTNER_NO_AUTH, NFS4ERR_PNFS_IO_HOLE,   |
   |                | NFS4ERR_PNFS_NO_LAYOUT, NFS4ERR_REP_TOO_BIG,     |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,              |
   |                | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,           |
   |                | NFS4ERR_WRONG_TYPE                               |
   +----------------+--------------------------------------------------+
   | SEEK           | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,          |
   |                | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |
   |                | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,       |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |
   |                | NFS4ERR_OPENMODE, NFS4ERR_OP_NOT_IN_SESSION,     |
   |                | NFS4ERR_PNFS_IO_HOLE, NFS4ERR_PNFS_NO_LAYOUT,    |
   |                | NFS4ERR_REP_TOO_BIG,                             |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,              |
   |                | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,           |
   |                | NFS4ERR_UNION_NOTSUPP, NFS4ERR_WRONG_TYPE        |
   +----------------+--------------------------------------------------+
   | WRITE_SAME     | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,            |
   |                | NFS4ERR_EXPIRED, NFS4ERR_FBIG,                   |
   |                | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |
   |                | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,       |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_NOSPC, NFS4ERR_NOTSUPP,                  |
   |                | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,           |
   |                | NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PNFS_IO_HOLE, |
   |                | NFS4ERR_PNFS_NO_LAYOUT, NFS4ERR_REP_TOO_BIG,     |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,               |
   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,                  |
   |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE         |
   +----------------+--------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Table 2: Valid Error Returns for Each New Protocol Operation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
表2：新しいプロトコル操作ごとに有効なエラーが返される
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11-3--New-Callback-Operations-and-Their-Valid-Errors">
11.3. New Callback Operations and Their Valid Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. 新しいコールバック操作とその有効なエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section contains a table that gives the valid error returns for each new NFSv4.2 callback operation. The error code NFS4_OK (indicating no error) is not listed but should be understood to be returnable by all new callback operations. The error values for all other callback operations are defined in Section 15.3 of [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションには、新しいNFSv4.2コールバック操作ごとに有効なエラーが返される表が含まれています。エラーコードNFS4_OK（エラーがないことを示す）はリストされていませんが、すべての新しいコールバック操作で返されると理解されているはずです。他のすべてのコールバック操作のエラー値は、[RFC5661]のセクション15.3で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------+------------------------------------------------------+
   | Callback   | Errors                                               |
   | Operation  |                                                      |
   +------------+------------------------------------------------------+
   | CB_OFFLOAD | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,                   |
   |            | NFS4ERR_BAD_STATEID, NFS4ERR_DELAY,                  |
   |            | NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_REP_TOO_BIG,      |
   |            | NFS4ERR_REP_TOO_BIG_TO_CACHE, NFS4ERR_REQ_TOO_BIG,   |
   |            | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_SERVERFAULT,     |
   |            | NFS4ERR_TOO_MANY_OPS                                 |
   +------------+------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 3: Valid Error Returns for Each New Protocol Callback Operation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表3：新しいプロトコルコールバック操作ごとに有効なエラーが返される
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12--New-File-Attributes">
12. New File Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. 新しいファイル属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-1--New-RECOMMENDED-Attributes---List-and-Definition-References">
12.1. New RECOMMENDED Attributes - List and Definition References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. 新しい推奨属性-リストと定義の参照
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The list of new RECOMMENDED attributes appears in Table 4. The meanings of the columns of the table are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいRECOMMENDED属性のリストを表4に示します。表の列の意味は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Name: The name of the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前：属性の名前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Id: The number assigned to the attribute. In the event of conflicts between the assigned number and [RFC7863], the latter is authoritative, but in such an event, it should be resolved with errata to this document and/or [RFC7863]. See [IESG08] for the errata process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Id：属性に割り当てられた番号。割り当てられた番号と[RFC7863]の間に矛盾がある場合、後者は信頼できるものですが、そのような場合は、このドキュメントまたは[RFC7863]への正誤表で解決する必要があります。エラッタプロセスについては、[IESG08]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data Type: The XDR data type of the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ型：属性のXDRデータ型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Acc: Access allowed to the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Acc：属性へのアクセスが許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
R means read-only (GETATTR may retrieve, SETATTR may not set).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Rは読み取り専用を意味します（GETATTRは取得、SETATTRは設定されない場合があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
W means write-only (SETATTR may set, GETATTR may not retrieve).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Wは書き込み専用を意味します（SETATTRが設定され、GETATTRが取得されない場合があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
R W means read/write (GETATTR may retrieve, SETATTR may set).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
R Wは読み取り/書き込みを意味します（GETATTRは取得、SETATTRは設定可能）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Defined in: The section of this specification that describes the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定義先：属性を説明するこの仕様のセクション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------------+----+-------------------+-----+----------------+
   | Name             | Id | Data Type         | Acc | Defined in     |
   +------------------+----+-------------------+-----+----------------+
   | clone_blksize    | 77 | uint32_t          | R   | Section 12.2.1 |
   | space_freed      | 78 | length4           | R   | Section 12.2.2 |
   | change_attr_type | 79 | change_attr_type4 | R   | Section 12.2.3 |
   | sec_label        | 80 | sec_label4        | R W | Section 12.2.4 |
   +------------------+----+-------------------+-----+----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
Table 4: New RECOMMENDED Attributes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
表4：新しいRECOMMENDED属性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2--Attribute-Definitions">
12.2. Attribute Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. 属性の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-1--Attribute-77-cloneblksize">
12.2.1. Attribute 77: clone_blksize
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.1. 属性77：clone_blksize
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The clone_blksize attribute indicates the granularity of a CLONE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clone_blksize属性は、CLONE操作の粒度を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-2--Attribute-78-spacefreed">
12.2.2. Attribute 78: space_freed
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.2. 属性78：space_freed
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_freed gives the number of bytes freed if the file is deleted. This attribute is read-only and is of type length4. It is a per-file attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_freedは、ファイルが削除された場合に解放されたバイト数を示します。この属性は読み取り専用で、タイプはlength4です。これはファイルごとの属性です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-3--Attribute-79-changeattrtype">
12.2.3. Attribute 79: change_attr_type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.3. 属性79：change_attr_type
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum change_attr_type4 {
              NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR         = 0,
              NFS4_CHANGE_TYPE_IS_VERSION_COUNTER        = 1,
              NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS = 2,
              NFS4_CHANGE_TYPE_IS_TIME_METADATA          = 3,
              NFS4_CHANGE_TYPE_IS_UNDEFINED              = 4
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
change_attr_type is a per-file system attribute that enables the NFSv4.2 server to provide additional information about how it expects the change attribute value to evolve after the file data or metadata has changed. While Section 5.4 of [RFC5661] discusses per-file system attributes, it is expected that the value of change_attr_type will not depend on the value of &#34;homogeneous&#34; and will only change in the event of a migration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
change_attr_typeはファイルシステムごとの属性であり、NFSv4.2サーバーは、ファイルデータまたはメタデータが変更された後、変更属性値がどのように変化すると予想されるかについての追加情報を提供できます。 [RFC5661]のセクション5.4ではファイルごとのシステム属性について説明していますが、change_attr_typeの値は「同種」の値に依存せず、移行時にのみ変更されることが予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR: The change attribute value MUST monotonically increase for every atomic change to the file attributes, data, or directory contents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR：変更属性の値は、ファイル属性、データ、またはディレクトリの内容に対するアトミックな変更ごとに単調に増加する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_CHANGE_TYPE_IS_VERSION_COUNTER: The change attribute value MUST be incremented by one unit for every atomic change to the file attributes, data, or directory contents. This property is preserved when writing to pNFS data servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_CHANGE_TYPE_IS_VERSION_COUNTER：ファイル属性、データ、またはディレクトリの内容に対するアトミックな変更ごとに、変更属性値を1ユニットずつ増分する必要があります。このプロパティは、pNFSデータサーバーに書き込むときに保持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS: The change attribute value MUST be incremented by one unit for every atomic change to the file attributes, data, or directory contents. In the case where the client is writing to pNFS data servers, the number of increments is not guaranteed to exactly match the number of WRITEs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS：ファイル属性、データ、またはディレクトリの内容へのアトミックな変更ごとに、変更属性値を1ユニットずつ増やす必要があります。クライアントがpNFSデータサーバーに書き込んでいる場合、インクリメントの数はWRITEの数と正確に一致するとは限りません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_CHANGE_TYPE_IS_TIME_METADATA: The change attribute is implemented as suggested in [RFC7530] in terms of the time_metadata attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_CHANGE_TYPE_IS_TIME_METADATA：[RFC7530]で提案されているように、time_metadata属性に関してchange属性が実装されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_CHANGE_TYPE_IS_UNDEFINED: The change attribute does not take values that fit into any of these categories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_CHANGE_TYPE_IS_UNDEFINED：変更属性は、これらのカテゴリのいずれにも該当する値を取りません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If either NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR, NFS4_CHANGE_TYPE_IS_VERSION_COUNTER, or NFS4_CHANGE_TYPE_IS_TIME_METADATA is set, then the client knows at the very least that the change attribute is monotonically increasing, which is sufficient to resolve the question of which value is the most recent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR、NFS4_CHANGE_TYPE_IS_VERSION_COUNTER、またはNFS4_CHANGE_TYPE_IS_TIME_METADATAのいずれかが設定されている場合、クライアントは少なくとも変更属性が単調に増加していることを知っています。これは、どの値が最新であるかという問題を解決するのに十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client sees the value NFS4_CHANGE_TYPE_IS_TIME_METADATA, then by inspecting the value of the &#34;time_delta&#34; attribute it additionally has the option of detecting rogue server implementations that use time_metadata in violation of the specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが値NFS4_CHANGE_TYPE_IS_TIME_METADATAを見つけた場合、「time_delta」属性の値を検査することにより、仕様に違反してtime_metadataを使用する不正なサーバーの実装を検出するオプションが追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client sees NFS4_CHANGE_TYPE_IS_VERSION_COUNTER, it has the ability to predict what the resulting change attribute value should be after a COMPOUND containing a SETATTR, WRITE, or CREATE. This again allows it to detect changes made in parallel by another client. The value NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS permits the same, but only if the client is not doing pNFS WRITEs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがNFS4_CHANGE_TYPE_IS_VERSION_COUNTERを参照する場合、SETATTR、WRITE、またはCREATEを含むCOMPOUNDの後に、結果として生じる変更属性値を予測することができます。これにより、別のクライアントによって並行して行われた変更を検出できます。値NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFSは同じことを許可しますが、クライアントがpNFS書き込みを実行していない場合のみです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, if the server does not support change_attr_type or if NFS4_CHANGE_TYPE_IS_UNDEFINED is set, then the server SHOULD make an effort to implement the change attribute in terms of the time_metadata attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、サーバーがchange_attr_typeをサポートしていない場合、またはNFS4_CHANGE_TYPE_IS_UNDEFINEDが設定されている場合、サーバーは、time_metadata属性に関して変更属性を実装するよう努力する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2-4--Attribute-80-seclabel">
12.2.4. Attribute 80: sec_label
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.4. 属性80：sec_l​​abel
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t policy4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint32_t policy4;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct labelformat_spec4 {
           policy4 lfs_lfs;
           policy4 lfs_pi;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct sec_label4 {
           labelformat_spec4       slai_lfs;
           opaque                  slai_data&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 &lt;CODE ENDS&gt; The FATTR4_SEC_LABEL contains an array of two components, with the first component being an LFS. It serves to provide the receiving end with the information necessary to translate the security attribute into a form that is usable by the endpoint. Label Formats assigned an LFS may optionally choose to include a Policy Identifier field to allow for complex policy deployments. The LFS and the Security Label Format Selection Registry are described in detail in [RFC7569]. The translation used to interpret the security attribute is not specified as part of the protocol, as it may depend on various factors. The second component is an opaque section that contains the data of the attribute. This component is dependent on the MAC model to interpret and enforce.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
&lt;コード終了&gt; FATTR4_SEC_LABELには2つのコンポーネントの配列が含まれており、最初のコンポーネントはLFSです。これは、セキュリティ属性をエンドポイントで使用可能な形式に変換するために必要な情報を受信側に提供するのに役立ちます。 LFSが割り当てられたラベル形式では、オプションで、ポリシー識別子フィールドを含めて、複雑なポリシーの導入を可能にすることができます。 LFSとSecurity Label Format Selection Registryは、[RFC7569]で詳細に説明されています。セキュリティ属性を解釈するために使用される変換は、さまざまな要因に依存する可能性があるため、プロトコルの一部として指定されていません。 2番目のコンポーネントは、属性のデータを含む不透明なセクションです。このコンポーネントは、解釈および適用するMACモデルに依存しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In particular, it is the responsibility of the LFS specification to define a maximum size for the opaque section, slai_data&lt;&gt;. When creating or modifying a label for an object, the client needs to be guaranteed that the server will accept a label that is sized correctly. By both client and server being part of a specific MAC model, the client will be aware of the size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に、不透明セクションslai_data &lt;&gt;の最大サイズを定義するのはLFS仕様の責任です。オブジェクトのラベルを作成または変更する場合、クライアントは、サーバーが正しいサイズのラベルを受け入れることを保証する必要があります。クライアントとサーバーの両方が特定のMACモデルの一部であることにより、クライアントはサイズを認識します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="13--Operations-REQUIRED-RECOMMENDED-or-OPTIONAL">
13. Operations: REQUIRED, RECOMMENDED, or OPTIONAL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. 操作：REQUIRED、RECOMMENDED、またはOPTIONAL
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tables 5 and 6 summarize the operations of the NFSv4.2 protocol and the corresponding designations of REQUIRED, RECOMMENDED, and OPTIONAL to implement or MUST NOT implement. The &#34;MUST NOT implement&#34; designation is reserved for those operations that were defined in either NFSv4.0 or NFSv4.1 and MUST NOT be implemented in NFSv4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表5および6は、NFSv4.2プロトコルの操作と、実装する、または実装してはならない必須、推奨、オプションの対応する指定をまとめたものです。 「実装してはならない」の指定は、NFSv4.0またはNFSv4.1で定義された操作のために予約されており、NFSv4.2で実装してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the most part, the REQUIRED, RECOMMENDED, or OPTIONAL designation for operations sent by the client is for the server implementation. The client is generally required to implement the operations needed for the operating environment that it serves. For example, a read-only NFSv4.2 client would have no need to implement the WRITE operation and is not required to do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどの場合、クライアントから送信された操作のREQUIRED、RECOMMENDED、またはOPTIONALの指定は、サーバーの実装用です。クライアントは通常、サービスを提供するオペレーティング環境に必要な操作を実装する必要があります。たとえば、読み取り専用のNFSv4.2クライアントは、WRITE操作を実装する必要がなく、実装する必要もありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The REQUIRED or OPTIONAL designation for callback operations sent by the server is for both the client and server. Generally, the client has the option of creating the backchannel and sending the operations on the forechannel that will be a catalyst for the server sending callback operations. A partial exception is CB_RECALL_SLOT; the only way the client can avoid supporting this operation is by not creating a backchannel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーによって送信されるコールバック操作の必須またはオプションの指定は、クライアントとサーバーの両方に適用されます。通常、クライアントには、バックチャネルを作成し、サーバーがコールバックオペレーションを送信するための触媒となる、フォアチャネルでオペレーションを送信するオプションがあります。部分的な例外はCB_RECALL_SLOTです。クライアントがこの操作のサポートを回避できる唯一の方法は、バックチャネルを作成しないことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since this is a summary of the operations and their designation, there are subtleties that are not presented here. Therefore, if there is a question regarding implementation requirements, the operation descriptions themselves must be consulted, along with other relevant explanatory text within either this specification or the NFSv4.1 specification [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは操作とその指定の要約であるため、ここには示されていない微妙な点があります。したがって、実装要件に関する質問がある場合は、この仕様またはNFSv4.1仕様[RFC5661]内の他の関連する説明文とともに、操作の説明自体を参照する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The abbreviations used in the second and third columns of Tables 5 and 6 are defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表5および6の2列目と3列目で使用されている略語は、次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ: REQUIRED to implement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ：実装が必要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REC: RECOMMENDED to implement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
記録：実装することを推奨
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPT: OPTIONAL to implement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPT：実装するオプション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MNI: MUST NOT implement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MNI：実装してはならない
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the NFSv4.2 features that are OPTIONAL, the operations that support those features are OPTIONAL, and the server MUST return NFS4ERR_NOTSUPP in response to the client&#39;s use of those operations when those operations are not implemented by the server. If an OPTIONAL feature is supported, it is possible that a set of operations related to the feature become REQUIRED to implement. The third column of the tables designates the feature(s) and if the operation is REQUIRED or OPTIONAL in the presence of support for the feature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPTIONALであるNFSv4.2機能の場合、それらの機能をサポートする操作はOPTIONALであり、これらの操作がサーバーによって実装されていない場合、サーバーはクライアントによるこれらの操作の使用に応答してNFS4ERR_NOTSUPPを返さなければなりません。 OPTIONAL機能がサポートされている場合、その機能に関連する一連の操作を実装する必要が生じる可能性があります。表の3列目は、機能と、その機能がサポートされている場合に操作が必須かオプションかを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPTIONAL features identified and their abbreviations are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
識別されたオプションの機能とその省略形は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFS: Parallel NFS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFS：並列NFS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FDELG: File Delegations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FDELG：ファイルの委任
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DDELG: Directory Delegations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DDELG：ディレクトリ委任
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPYra: Intra-server Server-Side Copy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPYra：サーバー内サーバー側コピー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPYer: Inter-server Server-Side Copy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPYer：サーバー間のサーバー側コピー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ADB: Application Data Blocks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ADB：アプリケーションデータブロック
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----------------------+--------------------+-----------------------+
   | Operation            | REQ, REC, OPT, or  | Feature (REQ, REC, or |
   |                      | MNI                | OPT)                  |
   +----------------------+--------------------+-----------------------+
   | ACCESS               | REQ                |                       |
   | ALLOCATE             | OPT                |                       |
   | BACKCHANNEL_CTL      | REQ                |                       |
   | BIND_CONN_TO_SESSION | REQ                |                       |
   | CLONE                | OPT                |                       |
   | CLOSE                | REQ                |                       |
   | COMMIT               | REQ                |                       |
   | COPY                 | OPT                | COPYer (REQ), COPYra  |
   |                      |                    | (REQ)                 |
   | COPY_NOTIFY          | OPT                | COPYer (REQ)          |
   | CREATE               | REQ                |                       |
   | CREATE_SESSION       | REQ                |                       |
   | DEALLOCATE           | OPT                |                       |
   | DELEGPURGE           | OPT                | FDELG (REQ)           |
   | DELEGRETURN          | OPT                | FDELG, DDELG, pNFS    |
   |                      |                    | (REQ)                 |
   | DESTROY_CLIENTID     | REQ                |                       |
   | DESTROY_SESSION      | REQ                |                       |
   | EXCHANGE_ID          | REQ                |                       |
   | FREE_STATEID         | REQ                |                       |
   | GETATTR              | REQ                |                       |
   | GETDEVICEINFO        | OPT                | pNFS (REQ)            |
   | GETDEVICELIST        | MNI                | pNFS (MNI)            |
   | GETFH                | REQ                |                       |
   | GET_DIR_DELEGATION   | OPT                | DDELG (REQ)           |
   | ILLEGAL              | REQ                |                       |
   | IO_ADVISE            | OPT                |                       |
   | LAYOUTCOMMIT         | OPT                | pNFS (REQ)            |
   | LAYOUTERROR          | OPT                | pNFS (OPT)            |
   | LAYOUTGET            | OPT                | pNFS (REQ)            |
   | LAYOUTRETURN         | OPT                | pNFS (REQ)            |
   | LAYOUTSTATS          | OPT                | pNFS (OPT)            |
   | LINK                 | OPT                |                       |
   | LOCK                 | REQ                |                       |
   | LOCKT                | REQ                |                       |
   | LOCKU                | REQ                |                       |
   | LOOKUP               | REQ                |                       |
   | LOOKUPP              | REQ                |                       |
   | NVERIFY              | REQ                |                       |
   | OFFLOAD_CANCEL       | OPT                | COPYer (OPT), COPYra  |
   |                      |                    | (OPT)                 |
   | OFFLOAD_STATUS       | OPT                | COPYer (OPT), COPYra  |
   |                      |                    | (OPT)                 |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | OPEN                 | REQ                |                       |
   | OPENATTR             | OPT                |                       |
   | OPEN_CONFIRM         | MNI                |                       |
   | OPEN_DOWNGRADE       | REQ                |                       |
   | PUTFH                | REQ                |                       |
   | PUTPUBFH             | REQ                |                       |
   | PUTROOTFH            | REQ                |                       |
   | READ                 | REQ                |                       |
   | READDIR              | REQ                |                       |
   | READLINK             | OPT                |                       |
   | READ_PLUS            | OPT                |                       |
   | RECLAIM_COMPLETE     | REQ                |                       |
   | RELEASE_LOCKOWNER    | MNI                |                       |
   | REMOVE               | REQ                |                       |
   | RENAME               | REQ                |                       |
   | RENEW                | MNI                |                       |
   | RESTOREFH            | REQ                |                       |
   | SAVEFH               | REQ                |                       |
   | SECINFO              | REQ                |                       |
   | SECINFO_NO_NAME      | REC                | pNFS file layout      |
   |                      |                    | (REQ)                 |
   | SEEK                 | OPT                |                       |
   | SEQUENCE             | REQ                |                       |
   | SETATTR              | REQ                |                       |
   | SETCLIENTID          | MNI                |                       |
   | SETCLIENTID_CONFIRM  | MNI                |                       |
   | SET_SSV              | REQ                |                       |
   | TEST_STATEID         | REQ                |                       |
   | VERIFY               | REQ                |                       |
   | WANT_DELEGATION      | OPT                | FDELG (OPT)           |
   | WRITE                | REQ                |                       |
   | WRITE_SAME           | OPT                | ADB (REQ)             |
   +----------------------+--------------------+-----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-28">
Table 5: Operations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-28">
表5：オペレーション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------------------+------------------+----------------------+
   | Operation               | REQ, REC, OPT,   | Feature (REQ, REC,   |
   |                         | or MNI           | or OPT)              |
   +-------------------------+------------------+----------------------+
   | CB_GETATTR              | OPT              | FDELG (REQ)          |
   | CB_ILLEGAL              | REQ              |                      |
   | CB_LAYOUTRECALL         | OPT              | pNFS (REQ)           |
   | CB_NOTIFY               | OPT              | DDELG (REQ)          |
   | CB_NOTIFY_DEVICEID      | OPT              | pNFS (OPT)           |
   | CB_NOTIFY_LOCK          | OPT              |                      |
   | CB_OFFLOAD              | OPT              | COPYer (REQ), COPYra |
   |                         |                  | (REQ)                |
   | CB_PUSH_DELEG           | OPT              | FDELG (OPT)          |
   | CB_RECALL               | OPT              | FDELG, DDELG, pNFS   |
   |                         |                  | (REQ)                |
   | CB_RECALL_ANY           | OPT              | FDELG, DDELG, pNFS   |
   |                         |                  | (REQ)                |
   | CB_RECALL_SLOT          | REQ              |                      |
   | CB_RECALLABLE_OBJ_AVAIL | OPT              | DDELG, pNFS (REQ)    |
   | CB_SEQUENCE             | OPT              | FDELG, DDELG, pNFS   |
   |                         |                  | (REQ)                |
   | CB_WANTS_CANCELLED      | OPT              | FDELG, DDELG, pNFS   |
   |                         |                  | (REQ)                |
   +-------------------------+------------------+----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
Table 6: Callback Operations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
表6：コールバック操作
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14--Modifications-to-NFSv4-1-Operations">
14. Modifications to NFSv4.1 Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. NFSv4.1操作の変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-1--Operation-42-EXCHANGEID---Instantiate-the-client-ID">
14.1. Operation 42: EXCHANGE_ID - Instantiate the client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. 操作42：EXCHANGE_ID-クライアントIDをインスタンス化します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-1-1--ARGUMENT">
14.1.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* new */
      const EXCHGID4_FLAG_SUPP_FENCE_OPS      = 0x00000004;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-1-2--RESULT">
14.1.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Unchanged
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
変更なし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-1-3--MOTIVATION">
14.1.3. MOTIVATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.3. 動機
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Enterprise applications require guarantees that an operation has either aborted or completed. NFSv4.1 provides this guarantee as long as the session is alive: simply send a SEQUENCE operation on the same slot with a new sequence number, and the successful return of SEQUENCE indicates that the previous operation has completed. However, if the session is lost, there is no way to know when any operations in progress have aborted or completed. In hindsight, the NFSv4.1 specification should have mandated that DESTROY_SESSION either abort or complete all outstanding operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンタープライズアプリケーションでは、操作が中止または完了したことを保証する必要があります。 NFSv4.1は、セッションが存続している限りこの保証を提供します。同じシーケンス番号で新しいシーケンス番号を使用してSEQUENCE操作を送信するだけで、SEQUENCEが正常に返されると、前の操作が完了したことを示します。ただし、セッションが失われた場合、進行中の操作がいつ中止または完了したかを知る方法はありません。後で見ると、NFSv4.1仕様ではDESTROY_SESSIONがすべての未処理の操作を中止または完了するように義務付けられているはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-1-4--DESCRIPTION">
14.1.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client SHOULD request the EXCHGID4_FLAG_SUPP_FENCE_OPS capability when it sends an EXCHANGE_ID operation. The server SHOULD set this capability in the EXCHANGE_ID reply whether the client requests it or not. It is the server&#39;s return that determines whether this capability is in effect. When it is in effect, the following will occur:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、EXCHANGE_ID操作を送信するときに、EXCHGID4_FLAG_SUPP_FENCE_OPS機能を要求する必要があります（SHOULD）。サーバーは、クライアントが要求するかどうかにかかわらず、EXCHANGE_ID応答でこの機能を設定する必要があります（SHOULD）。この機能が有効かどうかを決定するのはサーバーの戻りです。有効になると、次のことが起こります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server will not reply to any DESTROY_SESSION invoked with the client ID until all operations in progress are completed or aborted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、進行中のすべての操作が完了するか中止されるまで、クライアントIDで呼び出されたDESTROY_SESSIONに応答しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server will not reply to subsequent EXCHANGE_ID operations invoked on the same client owner with a new verifier until all operations in progress on the client ID&#39;s session are completed or aborted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o サーバーは、クライアントIDのセッションで進行中のすべての操作が完了するか中止されるまで、新しいベリファイアを使用して同じクライアント所有者で呼び出された後続のEXCHANGE_ID操作に応答しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In implementations where the NFS server is deployed as a cluster, it does support client ID trunking, and the EXCHGID4_FLAG_SUPP_FENCE_OPS capability is enabled, then a session ID created on one node of the storage cluster MUST be destroyable via DESTROY_SESSION. In addition, DESTROY_CLIENTID and an EXCHANGE_ID with a new verifier affect all sessions, regardless of what node the sessions were created on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSサーバーがクラスターとして展開されている実装では、NFSサーバーはクライアントIDトランキングをサポートし、EXCHGID4_FLAG_SUPP_FENCE_OPS機能が有効になっている場合、ストレージクラスターの1つのノードで作成されたセッションIDはDESTROY_SESSIONで破棄できる必要があります。さらに、セッションが作成されたノードに関係なく、新しい検証機能を備えたDESTROY_CLIENTIDとEXCHANGE_IDはすべてのセッションに影響します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
14.2. Operation 48: GETDEVICELIST - Get all device mappings for a file system
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
14.2. 操作48：GETDEVICELIST-ファイルシステムのすべてのデバイスマッピングを取得する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-1--ARGUMENT">
14.2.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETDEVICELIST4args {
           /* CURRENT_FH: object belonging to the file system */
           layouttype4     gdla_layout_type;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* number of device IDs to return */
           count4          gdla_maxdevices;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           nfs_cookie4     gdla_cookie;
           verifier4       gdla_cookieverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-2--RESULT">
14.2.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETDEVICELIST4resok {
           nfs_cookie4             gdlr_cookie;
           verifier4               gdlr_cookieverf;
           deviceid4               gdlr_deviceid_list&lt;&gt;;
           bool                    gdlr_eof;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union GETDEVICELIST4res switch (nfsstat4 gdlr_status) {
   case NFS4_OK:
           GETDEVICELIST4resok     gdlr_resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-3--MOTIVATION">
14.2.3. MOTIVATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.3. 動機
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The GETDEVICELIST operation was introduced in [RFC5661] specifically to request a list of devices at file system mount time from block layout type servers. However, the use of the GETDEVICELIST operation introduces a race condition versus notification about changes to pNFS device IDs as provided by CB_NOTIFY_DEVICEID. Implementation experience with block layout servers has shown that there is no need for GETDEVICELIST. Clients have to be able to request new devices using GETDEVICEINFO at any time in response to either a new deviceid in LAYOUTGET results or the CB_NOTIFY_DEVICEID callback operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
GETDEVICELIST操作は、特にブロックレイアウトタイプのサーバーからファイルシステムのマウント時にデバイスのリストを要求するために[RFC5661]で導入されました。ただし、GETDEVICELIST操作を使用すると、CB_NOTIFY_DEVICEIDによって提供されるpNFSデバイスIDの変更に関する通知に対して競合状態が発生します。ブロックレイアウトサーバーの実装経験から、GETDEVICELISTは不要であることがわかっています。クライアントは、LAYOUTGET結果の新しいデバイスIDまたはCB_NOTIFY_DEVICEIDコールバック操作のいずれかに応答して、いつでもGETDEVICEINFOを使用して新しいデバイスを要求できる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="14-2-4--DESCRIPTION">
14.2.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.4. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients and servers MUST NOT implement the GETDEVICELIST operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーはGETDEVICELIST操作を実装してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15--NFSv4-2-Operations">
15. NFSv4.2 Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. NFSv4.2の操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1--Operation-59-ALLOCATE---Reserve-space-in-a-region-of-a-file">
15.1. Operation 59: ALLOCATE - Reserve space in a region of a file
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1. 操作59：ALLOCATE-ファイルの領域にスペースを予約します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-1--ARGUMENT">
15.1.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ALLOCATE4args {
           /* CURRENT_FH: file */
           stateid4        aa_stateid;
           offset4         aa_offset;
           length4         aa_length;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-2--RESULT">
15.1.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ALLOCATE4res {
           nfsstat4        ar_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-1-3--DESCRIPTION">
15.1.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever a client wishes to reserve space for a region in a file, it calls the ALLOCATE operation with the current filehandle set to the filehandle of the file in question, and with the start offset and length in bytes of the region set in aa_offset and aa_length, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがファイル内の領域用にスペースを予約する場合は常に、問題のファイルのファイルハンドルに設定された現在のファイルハンドルと、aa_offsetとaa_lengthに設定された領域の開始オフセットと長さ（バイト）を指定してALLOCATE操作を呼び出します、それぞれ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CURRENT_FH must be a regular file. If CURRENT_FH is not a regular file, the operation MUST fail and return NFS4ERR_WRONG_TYPE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CURRENT_FHは通常のファイルでなければなりません。 CURRENT_FHが通常のファイルでない場合、操作は失敗し、NFS4ERR_WRONG_TYPEを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The aa_stateid MUST refer to a stateid that is valid for a WRITE operation and follows the rules for stateids in Sections 8.2.5 and 18.32.3 of [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
aa_stateidは、WRITE操作に有効であり、[RFC5661]のセクション8.2.5および18.32.3のステートIDのルールに従うステートIDを参照する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server will ensure that backing blocks are reserved to the region specified by aa_offset and aa_length, and that no future writes into this region will return NFS4ERR_NOSPC. If the region lies partially or fully outside the current file size, the file size will be set to aa_offset + aa_length implicitly. If the server cannot guarantee this, it must return NFS4ERR_NOSPC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、バッキングブロックがaa_offsetおよびaa_lengthによって指定された領域に予約されていること、およびこの領域への今後の書き込みがNFS4ERR_NOSPCを返さないことを保証します。領域が現在のファイルサイズの一部または全部外にある場合、ファイルサイズは暗黙的にaa_offset + aa_lengthに設定されます。サーバーがこれを保証できない場合は、NFS4ERR_NOSPCを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ALLOCATE operation can also be used to extend the size of a file if the region specified by aa_offset and aa_length extends beyond the current file size. In that case, any data outside of the previous file size will return zeros when read before data is written to it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ALLOCATE操作は、aa_offsetおよびaa_lengthで指定された領域が現在のファイルサイズを超えている場合、ファイルのサイズを拡張するためにも使用できます。その場合、以前のファイルサイズ外のデータは、データが書き込まれる前に読み取られるとゼロを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is not required that the server allocate the space to the file before returning success. The allocation can be deferred; however, it must be guaranteed that it will not fail for lack of space. The deferral does not result in an asynchronous reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功を返す前に、サーバーがファイルにスペースを割り当てる必要はありません。割り当ては延期できます。ただし、スペースが不足しても失敗しないことが保証されている必要があります。延期によって非同期応答が発生することはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ALLOCATE operation will result in the space_used and space_freed attributes being increased by the number of bytes reserved, unless they were previously reserved or written and not shared.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ALLOCATE操作では、space_usedおよびspace_freed属性が、予約済みまたは書き込み済みで共有されていない場合を除いて、予約済みのバイト数だけ増加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-2--Operation-60-COPY---Initiate-a-server-side-copy">
15.2. Operation 60: COPY - Initiate a server-side copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2. 操作60：COPY-サーバー側のコピーを開始します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-2-1--ARGUMENT">
15.2.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COPY4args {
           /* SAVED_FH: source file */
           /* CURRENT_FH: destination file */
           stateid4        ca_src_stateid;
           stateid4        ca_dst_stateid;
           offset4         ca_src_offset;
           offset4         ca_dst_offset;
           length4         ca_count;
           bool            ca_consecutive;
           bool            ca_synchronous;
           netloc4         ca_source_server&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-2-2--RESULT">
15.2.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct write_response4 {
           stateid4        wr_callback_id&lt;1&gt;;
           length4         wr_count;
           stable_how4     wr_committed;
           verifier4       wr_writeverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct copy_requirements4 {
           bool            cr_consecutive;
           bool            cr_synchronous;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COPY4resok {
           write_response4         cr_response;
           copy_requirements4      cr_requirements;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union COPY4res switch (nfsstat4 cr_status) {
   case NFS4_OK:
           COPY4resok              cr_resok4;
   case NFS4ERR_OFFLOAD_NO_REQS:
           copy_requirements4      cr_requirements;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-2-3--DESCRIPTION">
15.2.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COPY operation is used for both intra-server and inter-server copies. In both cases, the COPY is always sent from the client to the destination server of the file copy. The COPY operation requests that a range in the file specified by SAVED_FH be copied to a range in the file specified by CURRENT_FH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPY操作は、サーバー内コピーとサーバー間コピーの両方に使用されます。どちらの場合も、COPYは常にクライアントからファイルコピーの宛先サーバーに送信されます。 COPY操作は、SAVED_FHで指定されたファイルの範囲を、CURRENT_FHで指定されたファイルの範囲にコピーすることを要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both SAVED_FH and CURRENT_FH must be regular files. If either SAVED_FH or CURRENT_FH is not a regular file, the operation MUST fail and return NFS4ERR_WRONG_TYPE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SAVED_FHとCURRENT_FHはどちらも通常のファイルである必要があります。 SAVED_FHまたはCURRENT_FHのいずれかが通常のファイルでない場合、操作は失敗し、NFS4ERR_WRONG_TYPEを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SAVED_FH and CURRENT_FH must be different files. If SAVED_FH and CURRENT_FH refer to the same file, the operation MUST fail with NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SAVED_FHとCURRENT_FHは異なるファイルでなければなりません。 SAVED_FHとCURRENT_FHが同じファイルを参照している場合、操作はNFS4ERR_INVALで失敗する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the request is for an inter-server copy, the source-fh is a filehandle from the source server and the COMPOUND procedure is being executed on the destination server. In this case, the source-fh is a foreign filehandle on the server receiving the COPY request. If either PUTFH or SAVEFH checked the validity of the filehandle, the operation would likely fail and return NFS4ERR_STALE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求がサーバー間コピーに対するものである場合、source-fhはソースサーバーからのファイルハンドルであり、COMPOUNDプロシージャは宛先サーバーで実行されています。この場合、source-fhは、COPY要求を受信するサーバー上の外部ファイルハンドルです。 PUTFHまたはSAVEFHのいずれかがファイルハンドルの有効性をチェックした場合、操作は失敗し、NFS4ERR_STALEを返す可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server supports the inter-server copy feature, a PUTFH followed by a SAVEFH MUST NOT return NFS4ERR_STALE for either operation. These restrictions do not pose substantial difficulties for servers. CURRENT_FH and SAVED_FH may be validated in the context of the operation referencing them and an NFS4ERR_STALE error returned for an invalid filehandle at that point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがサーバー間コピー機能をサポートしている場合、PUTFHの後にSAVEFHが続くと、どちらの操作でもNFS4ERR_STALEを返してはなりません（MUST NOT）。これらの制限は、サーバーに大きな困難をもたらすことはありません。 CURRENT_FHおよびSAVED_FHは、それらを参照する操作のコンテキストで検証され、その時点で無効なファイルハンドルに対してNFS4ERR_STALEエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ca_dst_stateid MUST refer to a stateid that is valid for a WRITE operation and follows the rules for stateids in Sections 8.2.5 and 18.32.3 of [RFC5661]. For an inter-server copy, the ca_src_stateid MUST be the cnr_stateid returned from the earlier COPY_NOTIFY operation, while for an intra-server copy ca_src_stateid MUST refer to a stateid that is valid for a READ operation and follows the rules for stateids in Sections 8.2.5 and 18.22.3 of [RFC5661]. If either stateid is invalid, then the operation MUST fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ca_dst_stateidは、WRITE操作に有効であり、[RFC5661]のセクション8.2.5および18.32.3のステートIDのルールに従うステートIDを参照する必要があります。サーバー間コピーの場合、ca_src_stateidは、以前のCOPY_NOTIFY操作から返されたcnr_stateidでなければなりませんが、サーバー内コピーの場合、ca_src_stateidは、READ操作に有効なstateidを参照し、セクション8.2のステートIDのルールに従う必要があります。 [RFC5661]の5および18.22.3。どちらかのstateidが無効な場合、操作は失敗する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ca_src_offset is the offset within the source file from which the data will be read, the ca_dst_offset is the offset within the destination file to which the data will be written, and the ca_count is the number of bytes that will be copied. An offset of 0 (zero) specifies the start of the file. A count of 0 (zero) requests that all bytes from ca_src_offset through EOF be copied to the destination. If concurrent modifications to the source file overlap with the source file region being copied, the data copied may include all, some, or none of the modifications. The client can use standard NFS operations (e.g., OPEN with OPEN4_SHARE_DENY_WRITE or mandatory byte-range locks) to protect against concurrent modifications if the client is concerned about this. If the source file&#39;s EOF is being modified in parallel with a COPY that specifies a count of 0 (zero) bytes, the amount of data copied is implementation dependent (clients may guard against this case by specifying a non-zero count value or preventing modification of the source file as mentioned above).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ca_src_offsetは、データが読み取られるソースファイル内のオフセットであり、ca_dst_offsetは、データが書き込まれる宛先ファイル内のオフセットであり、ca_countは、コピーされるバイト数です。オフセット0（ゼロ）は、ファイルの開始を指定します。カウント0（ゼロ）は、ca_src_offsetからEOFまでのすべてのバイトを宛先にコピーすることを要求します。ソースファイルへの同時変更がコピーされるソースファイル領域と重複する場合、コピーされるデータには変更のすべてまたは一部が含まれるか、まったく含まれない場合があります。クライアントは、標準のNFS操作（たとえば、OPEN4_SHARE_DENY_WRITEによるOPENまたは必須のバイト範囲ロック）を使用して、クライアントがこれを懸念している場合、同時変更から保護できます。ソースファイルのEOFが0（ゼロ）バイトのカウントを指定するCOPYと並行して変更されている場合、コピーされるデータの量は実装に依存します（クライアントは、ゼロ以外のカウント値を指定するか、変更を防ぐことにより、このケースを防ぐことができます。上記のソースファイルの）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the source offset or the source offset plus count is greater than the size of the source file, the operation MUST fail with NFS4ERR_INVAL. The destination offset or destination offset plus count may be greater than the size of the destination file. This allows the client to issue parallel copies to implement operations such as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースオフセットまたはソースオフセットとカウントがソースファイルのサイズより大きい場合、操作はNFS4ERR_INVALで失敗する必要があります。宛先オフセットまたは宛先オフセットとカウントは、宛先ファイルのサイズよりも大きい場合があります。これにより、クライアントは並列コピーを発行して、次のような操作を実装できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
% cat file1 file2 file3 file4 &gt; dest
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
％cat file1 file2 file3 file4&gt; dest
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the ca_source_server list is specified, then this is an inter-server COPY operation and the source file is on a remote server. The client is expected to have previously issued a successful COPY_NOTIFY request to the remote source server. The ca_source_server list MUST be the same as the COPY_NOTIFY response&#39;s cnr_source_server list. If the client includes the entries from the COPY_NOTIFY response&#39;s cnr_source_server list in the ca_source_server list, the source server can indicate a specific copy protocol for the destination server to use by returning a URL that specifies both a protocol service and server name. Server-to-server copy protocol considerations are described in Sections 4.6 and 4.9.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ca_source_serverリストが指定されている場合、これはサーバー間のCOPY操作であり、ソースファイルはリモートサーバー上にあります。クライアントは、以前にリモートソースサーバーにCOPY_NOTIFY要求を正常に発行したことが期待されています。 ca_source_serverリストは、COPY_NOTIFY応答のcnr_source_serverリストと同じである必要があります。クライアントがCOPY_NOTIFY応答のcnr_source_serverリストのエントリをca_source_serverリストに含める場合、ソースサーバーは、プロトコルサービスとサーバー名の両方を指定するURLを返すことにより、宛先サーバーが使用する特定のコピープロトコルを示すことができます。サーバー間のコピープロトコルの考慮事項については、セクション4.6および4.9.1で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If ca_consecutive is set, then the client has specified that the copy protocol selected MUST copy bytes in consecutive order from ca_src_offset to ca_count. If the destination server cannot meet this requirement, then it MUST return an error of NFS4ERR_OFFLOAD_NO_REQS and set cr_consecutive to be FALSE. Likewise, if ca_synchronous is set, then the client has required that the copy protocol selected MUST perform a synchronous copy. If the destination server cannot meet this requirement, then it MUST return an error of NFS4ERR_OFFLOAD_NO_REQS and set cr_synchronous to be FALSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ca_consecutiveが設定されている場合、クライアントは、選択されたコピープロトコルがバイトをca_src_offsetからca_countに連続してコピーする必要があることを指定しています。宛先サーバーがこの要件を満たせない場合は、NFS4ERR_OFFLOAD_NO_REQSのエラーを返し、cr_consecutiveをFALSEに設定する必要があります。同様に、ca_synchronousが設定されている場合、クライアントは、選択されたコピープロトコルが同期コピーを実行する必要があることを要求しています。宛先サーバーがこの要件を満たせない場合は、NFS4ERR_OFFLOAD_NO_REQSのエラーを返し、cr_synchronousをFALSEに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If both are set by the client, then the destination SHOULD try to determine if it can respond to both requirements at the same time. If it cannot make that determination, it must set to TRUE the one it can and set to FALSE the other. The client, upon getting an NFS4ERR_OFFLOAD_NO_REQS error, has to examine both cr_consecutive and cr_synchronous against the respective values of ca_consecutive and ca_synchronous to determine the possible requirement not met. It MUST be prepared for the destination server not being able to determine both requirements at the same time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントによって両方が設定されている場合、宛先は両方の要件に同時に応答できるかどうかを判断する必要があります（SHOULD）。その判断ができない場合は、可能な方をTRUEに設定し、もう一方をFALSEに設定する必要があります。クライアントは、NFS4ERR_OFFLOAD_NO_REQSエラーが発生すると、cr_consecutiveとcr_synchronousの両方をca_consecutiveとca_synchronousのそれぞれの値に対して検査して、満たされていない可能性のある要件を判別する必要があります。宛先サーバーが両方の要件を同時に判断できない場合に備えて準備する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receiving the NFS4ERR_OFFLOAD_NO_REQS error, the client has to determine whether it wants to re-request the copy with a relaxed set of requirements or revert to manually copying the data. If it decides to manually copy the data and this is a remote copy, then the client is responsible for informing the source that the earlier COPY_NOTIFY is no longer valid by sending it an OFFLOAD_CANCEL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OFFLOAD_NO_REQSエラーを受信すると、クライアントは、要件の緩和されたセットを使用してコピーを再要求するか、手動でデータをコピーするように戻すかを決定する必要があります。データを手動でコピーすることを決定し、これがリモートコピーである場合、クライアントは、OFFLOAD_CANCELを送信することにより、以前のCOPY_NOTIFYが無効であることをソースに通知する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the operation does not result in an immediate failure, the server will return NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作の結果、すぐに失敗しない場合、サーバーはNFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the wr_callback_id is returned, this indicates that an asynchronous COPY operation was initiated and a CB_OFFLOAD callback will deliver the final results of the operation. The wr_callback_id stateid is termed a &#34;copy stateid&#34; in this context. The server is given the option of returning the results in a callback because the data may require a relatively long period of time to copy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wr_callback_idが返された場合、これは非同期のCOPY操作が開始され、CB_OFFLOADコールバックが操作の最終結果を配信することを示しています。このコンテキストでは、wr_callback_idの状態IDを「コピーの状態ID」と呼びます。データのコピーには比較的長い時間が必要になる場合があるため、サーバーにはコールバックで結果を返すオプションが与えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If no wr_callback_id is returned, the operation completed synchronously and no callback will be issued by the server. The completion status of the operation is indicated by cr_status.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wr_callback_idが返されない場合、操作は同期的に完了し、サーバーはコールバックを発行しません。操作の完了ステータスはcr_statusで示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the copy completes successfully, either synchronously or asynchronously, the data copied from the source file to the destination file MUST appear identical to the NFS client. However, the NFS server&#39;s on-disk representation of the data in the source file and destination file MAY differ. For example, the NFS server might encrypt, compress, deduplicate, or otherwise represent the on-disk data in the source and destination files differently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コピーが同期的または非同期的に正常に完了した場合、ソースファイルから宛先ファイルにコピーされたデータは、NFSクライアントと同一に見える必要があります。ただし、ソースファイルと宛先ファイルのデータのNFSサーバーのディスク上表現は異なる場合があります。たとえば、NFSサーバーでは、ソースファイルと宛先ファイルのディスク上のデータを暗号化、圧縮、重複排除、または別の方法で表す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a failure does occur for a synchronous copy, wr_count will be set to the number of bytes copied to the destination file before the error occurred. If cr_consecutive is TRUE, then the bytes were copied in order. If the failure occurred for an asynchronous copy, then the client will have gotten the notification of the consecutive copy order when it got the copy stateid. It will be able to determine the bytes copied from the coa_bytes_copied in the CB_OFFLOAD argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同期コピーで障害が発生した場合、wr_countは、エラーが発生する前に宛先ファイルにコピーされたバイト数に設定されます。 cr_consecutiveがTRUEの場合、バイトは順番にコピーされました。非同期コピーで障害が発生した場合、クライアントは、コピーの状態IDを取得したときに、連続したコピー順序の通知を受け取っています。 CB_OFFLOAD引数のcoa_bytes_copiedからコピーされたバイトを判別できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In either case, if cr_consecutive was not TRUE, there is no assurance as to exactly which bytes in the range were copied. The client MUST assume that there exists a mixture of the original contents of the range and the new bytes. If the COPY wrote past the end of the file on the destination, then the last byte written to will determine the new file size. The contents of any block not written to and past the original size of the file will be as if a normal WRITE extended the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらの場合も、cr_consecutiveがTRUEでない場合、範囲内のどのバイトがコピーされたかについては保証されません。クライアントは、範囲の元の内容と新しいバイトの混合が存在すると想定しなければなりません（MUST）。 COPYが宛先のファイルの終わりを超えて書き込んだ場合、書き込まれた最後のバイトが新しいファイルサイズを決定します。書き込まれず、ファイルの元のサイズを超えていないブロックの内容は、通常のWRITEがファイルを拡張した場合と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
15.3. Operation 61: COPY_NOTIFY - Notify a source server of a future copy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
15.3. 操作61：COPY_NOTIFY-ソースサーバーに将来のコピーを通知する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-3-1--ARGUMENT">
15.3.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COPY_NOTIFY4args {
           /* CURRENT_FH: source file */
           stateid4        cna_src_stateid;
           netloc4         cna_destination_server;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-3-2--RESULT">
15.3.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COPY_NOTIFY4resok {
           nfstime4        cnr_lease_time;
           stateid4        cnr_stateid;
           netloc4         cnr_source_server&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union COPY_NOTIFY4res switch (nfsstat4 cnr_status) {
   case NFS4_OK:
           COPY_NOTIFY4resok       resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-3-3--DESCRIPTION">
15.3.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used for an inter-server copy. A client sends this operation in a COMPOUND request to the source server to authorize a destination server identified by cna_destination_server to read the file specified by CURRENT_FH on behalf of the given user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、サーバー間のコピーに使用されます。クライアントは、COMPOUND要求でこの操作をソースサーバーに送信し、cna_destination_serverで識別される宛先サーバーが、指定されたユーザーに代わってCURRENT_FHで指定されたファイルを読み取ることを承認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cna_src_stateid MUST refer to either open or locking states provided earlier by the server. If it is invalid, then the operation MUST fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cna_src_stateidは、サーバーによって以前に提供されたオープン状態またはロック状態のいずれかを参照する必要があります。無効な場合、操作は失敗する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cna_destination_server MUST be specified using the netloc4 network location format. The server is not required to resolve the cna_destination_server address before completing this operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cna_destination_serverは、netloc4ネットワークロケーションフォーマットを使用して指定する必要があります。サーバーは、この操作を完了する前にcna_destination_serverアドレスを解決する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If this operation succeeds, the source server will allow the cna_destination_server to copy the specified file on behalf of the given user as long as both of the following conditions are met:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作が成功した場合、次の両方の条件が満たされている限り、ソースサーバーは、cna_destination_serverが指定されたユーザーに代わって指定されたファイルをコピーすることを許可します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The destination server begins reading the source file before the cnr_lease_time expires. If the cnr_lease_time expires while the destination server is still reading the source file, the destination server is allowed to finish reading the file. If the cnr_lease_time expires before the destination server uses READ or READ_PLUS to begin the transfer, the source server can use NFS4ERR_PARTNER_NO_AUTH to inform the destination server that the cnr_lease_time has expired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 宛先サーバーは、cnr_lease_timeが期限切れになる前にソースファイルの読み取りを開始します。宛先サーバーがまだソースファイルを読み取っているときにcnr_lease_timeの期限が切れた場合、宛先サーバーはファイルの読み取りを完了することができます。宛先サーバーがREADまたはREAD_PLUSを使用して転送を開始する前にcnr_lease_timeの期限が切れた場合、ソースサーバーはNFS4ERR_PARTNER_NO_AUTHを使用して、cnr_lease_timeの期限が切れたことを宛先サーバーに通知できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client has not issued an OFFLOAD_CANCEL for the same combination of user, filehandle, and destination server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o クライアントは、ユーザー、ファイルハンドル、および宛先サーバーの同じ組み合わせに対してOFFLOAD_CANCELを発行していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cnr_lease_time is chosen by the source server. A cnr_lease_time of 0 (zero) indicates an infinite lease. To avoid the need for synchronized clocks, copy lease times are granted by the server as a time delta. To renew the copy lease time, the client should resend the same copy notification request to the source server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cnr_lease_timeは、ソースサーバーによって選択されます。 cnr_lease_timeが0（ゼロ）の場合、リースが無限であることを示します。同期されたクロックの必要性を回避するために、コピーリース時間はサーバーによってタイムデルタとして付与されます。コピーのリース期間を更新するには、クライアントは同じコピー通知要求をソースサーバーに再送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cnr_stateid is a copy stateid that uniquely describes the state needed on the source server to track the proposed COPY. As defined in Section 8.2 of [RFC5661], a stateid is tied to the current filehandle, and if the same stateid is presented by two different clients, it may refer to different states. As the source does not know which netloc4 network location the destination might use to establish the COPY operation, it can use the cnr_stateid to identify that the destination is operating on behalf of the client. Thus, the source server MUST construct copy stateids such that they are distinct from all other stateids handed out to clients. These copy stateids MUST denote the same set of locks as each of the earlier delegation, locking, and open states for the client on the given file (see Section 4.3.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cnr_stateidは、提案されたCOPYを追跡するためにソースサーバーで必要な状態を一意に表すコピーのstateidです。 [RFC5661]のセクション8.2で定義されているように、stateidは現在のファイルハンドルに関連付けられており、同じstateidが2つの異なるクライアントによって提示される場合、異なるstateを参照する可能性があります。ソースは、宛先がCOPY操作を確立するために使用できるnetloc4ネットワークロケーションを認識していないため、cnr_stateidを使用して、宛先がクライアントに代わって動作していることを識別できます。したがって、ソースサーバーは、クライアントに渡される他のすべてのステートIDとは異なるコピーステートIDを構築する必要があります。これらのコピー状態IDは、指定されたファイルのクライアントの以前の委任、ロック、およびオープン状態のそれぞれと同じロックのセットを示す必要があります（セクション4.3.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A successful response will also contain a list of netloc4 network location formats called cnr_source_server, on which the source is willing to accept connections from the destination. These might not be reachable from the client and might be located on networks to which the client has no connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功した応答には、cnr_source_serverと呼ばれるnetloc4ネットワークロケーションフォーマットのリストも含まれます。このリストでは、ソースは宛先からの接続を受け入れます。これらはクライアントから到達できず、クライアントが接続していないネットワーク上にある可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is unnecessary for an intra-server copy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、サーバー内コピーの場合は不要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-4--Operation-62-DEALLOCATE---Unreserve-space-in-a-region-of-a-file">
15.4. Operation 62: DEALLOCATE - Unreserve space in a region of a file
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4. 操作62：DEALLOCATE-ファイルの領域のスペースを予約解除
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-4-1--ARGUMENT">
15.4.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DEALLOCATE4args {
           /* CURRENT_FH: file */
           stateid4        da_stateid;
           offset4         da_offset;
           length4         da_length;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-4-2--RESULT">
15.4.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DEALLOCATE4res {
           nfsstat4        dr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-4-3--DESCRIPTION">
15.4.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever a client wishes to unreserve space for a region in a file, it calls the DEALLOCATE operation with the current filehandle set to the filehandle of the file in question, and with the start offset and length in bytes of the region set in da_offset and da_length, respectively. If no space was allocated or reserved for all or parts of the region, the DEALLOCATE operation will have no effect for the region that already is in unreserved state. All further READs from the region passed to DEALLOCATE MUST return zeros until overwritten.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがファイル内の領域のスペースを予約解除したい場合は常に、現在のファイルハンドルを問題のファイルのファイルハンドルに設定し、領域の開始オフセットと長さをda_offsetとda_lengthに設定して、DEALLOCATE操作を呼び出します。 、それぞれ。領域のすべてまたは一部にスペースが割り当てられていないか、予約されていない場合、DEALLOCATE操作は、すでに予約されていない状態の領域には影響を与えません。 DEALLOCATEに渡された領域からのそれ以降のすべてのREADは、上書きされるまでゼロを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CURRENT_FH must be a regular file. If CURRENT_FH is not a regular file, the operation MUST fail and return NFS4ERR_WRONG_TYPE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CURRENT_FHは通常のファイルでなければなりません。 CURRENT_FHが通常のファイルでない場合、操作は失敗し、NFS4ERR_WRONG_TYPEを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The da_stateid MUST refer to a stateid that is valid for a WRITE operation and follows the rules for stateids in Sections 8.2.5 and 18.32.3 of [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
da_stateidは、WRITE操作に有効な状態IDを参照しなければならず、[RFC5661]のセクション8.2.5および18.32.3の状態IDのルールに従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Situations may arise where da_offset and/or da_offset + da_length will not be aligned to a boundary for which the server does allocations or deallocations. For most file systems, this is the block size of the file system. In such a case, the server can deallocate as many bytes as it can in the region. The blocks that cannot be deallocated MUST be zeroed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
da_offsetまたはda_offset + da_length、あるいはその両方が、サーバーが割り当てまたは割り当て解除を行う境界に位置合わせされない状況が発生する可能性があります。ほとんどのファイルシステムでは、これはファイルシステムのブロックサイズです。このような場合、サーバーは領域内で可能な限り多くのバイトの割り当てを解除できます。割り当てを解除できないブロックはゼロに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DEALLOCATE will result in the space_used attribute being decreased by the number of bytes that were deallocated. The space_freed attribute may or may not decrease, depending on the support and whether the blocks backing the specified range were shared or not. The size attribute will remain unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DEALLOCATEを指定すると、割り当て解除されたバイト数だけspace_used属性が減少します。 space_freed属性は、サポートと、指定された範囲をサポートするブロックが共有されているかどうかによって、減少する場合と減少しない場合があります。サイズ属性は変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
15.5. Operation 63: IO_ADVISE - Send client I/O access pattern hints to the server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
15.5. 操作63：IO_ADVISE-サーバーへのクライアントI / Oアクセスパターンヒントの送信
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-5-1--ARGUMENT">
15.5.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum IO_ADVISE_type4 {
           IO_ADVISE4_NORMAL                       = 0,
           IO_ADVISE4_SEQUENTIAL                   = 1,
           IO_ADVISE4_SEQUENTIAL_BACKWARDS         = 2,
           IO_ADVISE4_RANDOM                       = 3,
           IO_ADVISE4_WILLNEED                     = 4,
           IO_ADVISE4_WILLNEED_OPPORTUNISTIC       = 5,
           IO_ADVISE4_DONTNEED                     = 6,
           IO_ADVISE4_NOREUSE                      = 7,
           IO_ADVISE4_READ                         = 8,
           IO_ADVISE4_WRITE                        = 9,
           IO_ADVISE4_INIT_PROXIMITY               = 10
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct IO_ADVISE4args {
           /* CURRENT_FH: file */
           stateid4        iaa_stateid;
           offset4         iaa_offset;
           length4         iaa_count;
           bitmap4         iaa_hints;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-5-2--RESULT">
15.5.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct IO_ADVISE4resok {
           bitmap4 ior_hints;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union IO_ADVISE4res switch (nfsstat4 ior_status) {
   case NFS4_OK:
           IO_ADVISE4resok resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-5-3--DESCRIPTION">
15.5.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IO_ADVISE operation sends an I/O access pattern hint to the server for the owner of the stateid for a given byte range specified by iar_offset and iar_count. The byte range specified by iaa_offset and iaa_count need not currently exist in the file, but the iaa_hints will apply to the byte range when it does exist. If iaa_count is 0, all data following iaa_offset is specified. The server MAY ignore the advice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE操作は、iar_offsetおよびiar_countで指定された特定のバイト範囲のstateidの所有者のI / Oアクセスパターンヒントをサーバーに送信します。 iaa_offsetおよびiaa_countで指定されたバイト範囲は、現在ファイルに存在する必要はありませんが、iaa_hintsは、存在する場合にバイト範囲に適用されます。 iaa_countが0の場合、iaa_offsetに続くすべてのデータが指定されます。サーバーはアドバイスを無視してもよい（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following are the allowed hints for a stateid holder:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、stateidホルダーに許可されるヒントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_NORMAL There is no advice to give. This is the default behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_NORMALアドバイスはありません。これがデフォルトの動作です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_SEQUENTIAL Expects to access the specified data sequentially from lower offsets to higher offsets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_SEQUENTIAL低いオフセットから高いオフセットまで、指定されたデータに順次アクセスすることを期待します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_SEQUENTIAL_BACKWARDS Expects to access the specified data sequentially from higher offsets to lower offsets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_SEQUENTIAL_BACKWARDS高いオフセットから低いオフセットへと順番に指定されたデータにアクセスすることを期待します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_RANDOM Expects to access the specified data in a random order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_RANDOM指定されたデータにランダムな順序でアクセスすることを期待しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_WILLNEED Expects to access the specified data in the near future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_WILLNEED近い将来、指定されたデータにアクセスする予定です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_WILLNEED_OPPORTUNISTIC Expects to possibly access the data in the near future. This is a speculative hint, and therefore the server should prefetch data or indirect blocks only if it can be done at a marginal cost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_WILLNEED_OPPORTUNISTIC近い将来にデータにアクセスする可能性があります。これは投機的なヒントであるため、サーバーはデータまたは間接ブロックをプリフェッチする必要があります（限界コストで実行できる場合のみ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE_DONTNEED Expects that it will not access the specified data in the near future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE_DONTNEED近い将来、指定されたデータにアクセスしないことを期待します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE_NOREUSE Expects to access the specified data once and then not reuse it thereafter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE_NOREUSE指定されたデータに一度アクセスし、その後それを再利用しないことを期待します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_READ Expects to read the specified data in the near future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_READ近い将来、指定されたデータを読み取ることが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_WRITE Expects to write the specified data in the near future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_WRITE近い将来、指定されたデータを書き込むことが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_INIT_PROXIMITY Informs the server that the data in the byte range remains important to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_INIT_PROXIMITYバイト範囲のデータがクライアントにとって引き続き重要であることをサーバーに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since IO_ADVISE is a hint, a server SHOULD NOT return an error and invalidate an entire COMPOUND request if one of the sent hints in iar_hints is not supported by the server. Also, the server MUST NOT return an error if the client sends contradictory hints to the server, e.g., IO_ADVISE4_SEQUENTIAL and IO_ADVISE4_RANDOM in a single IO_ADVISE operation. In these cases, the server MUST return success and an ior_hints value that indicates the hint it intends to implement. This may mean simply returning IO_ADVISE4_NORMAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISEはヒントであるため、サーバーがiar_hintsで送信されたヒントの1つをサポートしていない場合、サーバーはエラーを返さず、COMPOUND要求全体を無効にする必要があります（SHOULD NOT）。また、クライアントがサーバーに矛盾するヒントを送信した場合、サーバーはエラーを返してはなりません（例：IO_ADVISE4_SEQUENTIALとIO_ADVISE4_RANDOMが1つのIO_ADVISE操作で）。これらの場合、サーバーは成功と、実装しようとしているヒントを示すior_hints値を返さなければなりません（MUST）。これは単にIO_ADVISE4_NORMALを返すことを意味する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ior_hints returned by the server is primarily for debugging purposes, since the server is under no obligation to carry out the hints that it describes in the ior_hints result. In addition, while the server may have intended to implement the hints returned in ior_hints, the server may need to change its handling of a given file -- for example, because of memory pressure, additional IO_ADVISE hints sent by other clients, or heuristically detected file access patterns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがior_hintsの結果で説明するヒントを実行する義務はサーバーにないため、サーバーから返されるior_hintsは主にデバッグを目的としています。さらに、サーバーはior_hintsに返されるヒントを実装することを意図していたとしても、サーバーは特定のファイルの処理を変更する必要がある場合があります-たとえば、メモリの負荷、他のクライアントから送信された追加のIO_ADVISEヒント、またはヒューリスティックに検出されたファイルアクセスパターン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MAY return different advice than what the client requested. Some examples include another client advising of a different I/O access pattern, another client employing a different I/O access pattern, or inability of the server to support the requested I/O access pattern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、クライアントが要求したものとは異なるアドバイスを返す場合があります。いくつかの例には、異なるI / Oアクセスパターンを通知する別のクライアント、異なるI / Oアクセスパターンを使用する別のクライアント、またはサーバーが要求されたI / Oアクセスパターンをサポートできないことなどがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each issuance of the IO_ADVISE operation overrides all previous issuances of IO_ADVISE for a given byte range. This effectively follows a strategy of &#34;last hint wins&#34; for a given stateid and byte range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE操作の各発行は、指定されたバイト範囲のIO_ADVISEの以前のすべての発行をオーバーライドします。これは、指定されたステートIDとバイト範囲の「最後のヒントが勝つ」という戦略に従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients should assume that hints included in an IO_ADVISE operation will be forgotten once the file is closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、ファイルが閉じられると、IO_ADVISE操作に含まれるヒントが忘れられると想定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-5-4--IMPLEMENTATION">
15.5.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS client may choose to issue an IO_ADVISE operation to the server in several different instances.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSクライアントは、いくつかの異なるインスタンスでIO_ADVISE操作をサーバーに発行することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The most obvious is in direct response to an application&#39;s execution of posix_fadvise(). In this case, IO_ADVISE4_WRITE and IO_ADVISE4_READ may be set, based upon the type of file access specified when the file was opened.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最も明白なのは、posix_fadvise()のアプリケーションの実行に対する直接の応答です。この場合、ファイルを開いたときに指定したファイルアクセスのタイプに基づいて、IO_ADVISE4_WRITEおよびIO_ADVISE4_READを設定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-5-5--IOADVISE4INITPROXIMITY">
15.5.5. IO_ADVISE4_INIT_PROXIMITY
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.5. IO_ADVISE4_INIT_PROXIMITY
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IO_ADVISE4_INIT_PROXIMITY hint is non-POSIX in origin and can be used to convey that the client has recently accessed the byte range in its own cache. That is, it has not accessed it on the server but has accessed it locally. When the server reaches resource exhaustion, knowing which data is more important allows the server to make better choices about which data to, for example, purge from a cache or move to secondary storage. It also informs the server as to which delegations are more important, because if delegations are working correctly, once delegated to a client and the client has read the content for that byte range, a server might never receive another READ request for that byte range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_INIT_PROXIMITYヒントはPOSIX以外のものであり、クライアントが最近、自身のキャッシュのバイト範囲にアクセスしたことを伝えるために使用できます。つまり、サーバーではアクセスしていませんが、ローカルではアクセスしています。サーバーがリソースの枯渇に達したとき、どのデータがより重要であるかを知ることで、サーバーは、たとえば、キャッシュからパージしたり、セカンダリストレージに移動したりするデータについてより良い選択を行うことができます。委任が正しく機能している場合、クライアントに委任され、クライアントがそのバイト範囲のコンテンツを読み取った後、サーバーはそのバイト範囲の別のREAD要求を受信しない可能性があるため、サーバーにどの委任がより重要かについても通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IO_ADVISE4_INIT_PROXIMITY hint can also be used in a pNFS setting to let the client inform the metadata server as to the I/O statistics between the client and the storage devices. The metadata server is then free to use this information about client I/O to optimize the data storage location.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE4_INIT_PROXIMITYヒントをpNFS設定で使用して、クライアントとストレージデバイス間のI / O統計に関してクライアントがメタデータサーバーに通知することもできます。メタデータサーバーは、クライアントI / Oに関するこの情報を自由に使用して、データストレージの場所を最適化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This hint is also useful in the case of NFS clients that are network-booting from a server. If the first client to be booted sends this hint, then it keeps the cache warm for the remaining clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このヒントは、サーバーからネットワーク起動するNFSクライアントの場合にも役立ちます。起動する最初のクライアントがこのヒントを送信すると、残りのクライアントのキャッシュを温かく保ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-5-6--pNFS-File-Layout-Data-Type-Considerations">
15.5.6. pNFS File Layout Data Type Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.6. pNFSファイルレイアウトのデータタイプに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IO_ADVISE considerations for pNFS are very similar to the COMMIT considerations for pNFS (see Section 13.7 of [RFC5661]). That is, as with COMMIT, some NFS server implementations prefer that IO_ADVISE be done on the storage device, and some prefer that it be done on the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSのIO_ADVISEの考慮事項は、pNFSのCOMMITの考慮事項と非常によく似ています（[RFC5661]のセクション13.7を参照）。つまり、COMMITと同様に、NFSサーバーの実装によっては、IO_ADVISEがストレージデバイスで実行されることを好む場合と、メタデータサーバーで実行されることを好む場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 For the file&#39;s layout type, NFSv4.2 includes an additional hint, NFL42_CARE_IO_ADVISE_THRU_MDS, which is valid only on metadata servers running NFSv4.2 or higher. (&#34;NFL&#34; stands for &#34;NFS File Layout&#34;.) Any file&#39;s layout obtained from an NFSv4.1 metadata server MUST NOT have NFL42_UFLG_IO_ADVISE_THRU_MDS set. Any file&#39;s layout obtained with an NFSv4.2 metadata server MAY have NFL42_UFLG_IO_ADVISE_THRU_MDS set. However, if the layout utilizes NFSv4.1 storage devices, the IO_ADVISE operation cannot be sent to them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ファイルのレイアウトタイプの場合、NFSv4.2には追加のヒント、NFL42_CARE_IO_ADVISE_THRU_MDSが含まれます。これは、NFSv4.2以降を実行しているメタデータサーバーでのみ有効です。 （「NFL」は「NFSファイルレイアウト」を表します。）NFSv4.1メタデータサーバーから取得したファイルのレイアウトには、NFL42_UFLG_IO_ADVISE_THRU_MDSを設定してはなりません。 NFSv4.2メタデータサーバーで取得したファイルのレイアウトには、NFL42_UFLG_IO_ADVISE_THRU_MDSが設定されている場合があります。ただし、レイアウトがNFSv4.1ストレージデバイスを利用している場合、IO_ADVISE操作はそれらに送信できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If NFL42_UFLG_IO_ADVISE_THRU_MDS is set, the client MUST send the IO_ADVISE operation to the metadata server in order for it to be honored by the storage device. Once the metadata server receives the IO_ADVISE operation, it will communicate the advice to each storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFL42_UFLG_IO_ADVISE_THRU_MDSが設定されている場合、クライアントはIO_ADVISE操作をメタデータサーバーに送信して、ストレージデバイスがそれを受け入れる必要があります。メタデータサーバーがIO_ADVISE操作を受信すると、各ストレージデバイスにアドバイスを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If NFL42_UFLG_IO_ADVISE_THRU_MDS is not set, then the client SHOULD send an IO_ADVISE operation to the appropriate storage device for the specified byte range. While the client MAY always send IO_ADVISE to the metadata server, if the server has not set NFL42_UFLG_IO_ADVISE_THRU_MDS, the client should expect that such an IO_ADVISE is futile. Note that a client SHOULD use the same set of arguments on each IO_ADVISE sent to a storage device for the same open file reference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFL42_UFLG_IO_ADVISE_THRU_MDSが設定されていない場合、クライアントは、指定されたバイト範囲の適切なストレージデバイスにIO_ADVISE操作を送信する必要があります（SHOULD）。クライアントは常にIO_ADVISEをメタデータサーバーに送信することができますが、サーバーがNFL42_UFLG_IO_ADVISE_THRU_MDSを設定していない場合、クライアントはそのようなIO_ADVISEが無駄であることを期待する必要があります。クライアントは、同じオープンファイルリファレンスのストレージデバイスに送信される各IO_ADVISEで同じ引数のセットを使用する必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server is not required to support different advice for different storage devices with the same open file reference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、同じオープンファイルリファレンスを持つ異なるストレージデバイスに対する異なるアドバイスをサポートする必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-5-6-1--Dense-and-Sparse-Packing-Considerations">
15.5.6.1. Dense and Sparse Packing Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.6.1. 密および疎パッキングの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IO_ADVISE operation MUST use the iar_offset and byte range as dictated by the presence or absence of NFL4_UFLG_DENSE (see Section 13.4.4 of [RFC5661]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IO_ADVISE操作では、NFL4_UFLG_DENSEの有無によって指定されたiar_offsetおよびバイト範囲を使用する必要があります（[RFC5661]のセクション13.4.4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, if NFL4_UFLG_DENSE is present, then (1) a READ or WRITE to the storage device for iaa_offset 0 really means iaa_offset 10000 in the logical file and (2) an IO_ADVISE for iaa_offset 0 means iaa_offset 10000 in the logical file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、NFL4_UFLG_DENSEが存在する場合、（1）iaa_offset 0のストレージデバイスへのREADまたはWRITEは実際には論理ファイルのiaa_offset 10000を意味し、（2）iaa_offset 0のIO_ADVISEは論理ファイルのiaa_offset 10000を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, if NFL4_UFLG_DENSE is absent, then (1) a READ or WRITE to the storage device for iaa_offset 0 really means iaa_offset 0 in the logical file and (2) an IO_ADVISE for iaa_offset 0 means iaa_offset 0 in the logical file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、NFL4_UFLG_DENSEがない場合、（1）iaa_offset 0のストレージデバイスへのREADまたはWRITEは実際には論理ファイルのiaa_offset 0を意味し、（2）iaa_offset 0のIO_ADVISEは論理ファイルのiaa_offset 0を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, if NFL4_UFLG_DENSE is present, the stripe unit is 1000 bytes and the stripe count is 10, and the dense storage device file is serving iar_offset 0. A READ or WRITE to the storage device for iaa_offsets 0, 1000, 2000, and 3000 really means iaa_offsets 10000, 20000, 30000, and 40000 (implying a stripe count of 10 and a stripe unit of 1000), and then an IO_ADVISE sent to the same storage device with an iaa_offset of 500 and an iaa_count of 3000 means that the IO_ADVISE applies to these byte ranges of the dense storage device file:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、NFL4_UFLG_DENSEが存在する場合、ストライプユニットは1000バイト、ストライプカウントは10であり、高密度ストレージデバイスファイルはiar_offset 0を提供しています。iaa_offsets0、1000、2000、および3000のストレージデバイスへの読み取りまたは書き込み実際には、iaa_offsets 10000、20000、30000、および40000（ストライプカウント10およびストライプユニット1000を意味する）を意味し、iaa_offsetが500でiaa_countが3000の同じストレージデバイスに送信されたIO_ADVISEは、IO_ADVISE高密度ストレージデバイスファイルのこれらのバイト範囲に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 500 to 999 - 1000 to 1999 - 2000 to 2999 - 3000 to 3499
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 500から999-1000から1999-2000から2999-3000から3499
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
That is, the contiguous range 500 to 3499, as specified in IO_ADVISE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
つまり、IO_ADVISEで指定された連続範囲500〜3499です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It also applies to these byte ranges of the logical file:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、論理ファイルの次のバイト範囲にも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 10500 to 10999 (500 bytes) - 20000 to 20999 (1000 bytes) - 30000 to 30999 (1000 bytes) - 40000 to 40499 (500 bytes) (total 3000 bytes)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 10500〜10999（500バイト）-20000〜20999（1000バイト）-30000〜30999（1000バイト）-40000〜40499（500バイト）（合計3000バイト）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, if NFL4_UFLG_DENSE is absent, the stripe unit is 250 bytes, the stripe count is 4, and the sparse storage device file is serving iaa_offset 0. Then, a READ or WRITE to the storage device for iaa_offsets 0, 1000, 2000, and 3000 really means iaa_offsets 0, 1000, 2000, and 3000 in the logical file, keeping in mind that in the storage device file byte ranges 250 to 999, 1250 to 1999, 2250 to 2999, and 3250 to 3999 are not accessible. Then, an IO_ADVISE sent to the same storage device with an iaa_offset of 500 and an iaa_count of 3000 means that the IO_ADVISE applies to these byte ranges of the logical file and the sparse storage device file:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、NFL4_UFLG_DENSEが存在しない場合、ストライプ単位は250バイト、ストライプカウントは4、スパースストレージデバイスファイルはiaa_offset 0を提供します。次に、iaa_offsets 0、1000、2000のストレージデバイスへの読み取りまたは書き込み、 3000は、論理ファイルのiaa_offsets 0、1000、2000、および3000を実際に意味します。ただし、ストレージデバイスファイルのバイト範囲250〜999、1250〜1999、2250〜2999、および3250〜3999にはアクセスできません。次に、iaa_offsetが500、iaa_countが3000の同じストレージデバイスに送信されたIO_ADVISEは、IO_ADVISEが論理ファイルとスパースストレージデバイスファイルのこれらのバイト範囲に適用されることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     - 500 to 999   (500 bytes) - no effect
     - 1000 to 1249 (250 bytes) - effective
     - 1250 to 1999 (750 bytes) - no effect
     - 2000 to 2249 (250 bytes) - effective
     - 2250 to 2999 (750 bytes) - no effect
     - 3000 to 3249 (250 bytes) - effective
     - 3250 to 3499 (250 bytes) - no effect
     (subtotal      2250 bytes) - no effect
     (subtotal       750 bytes) - effective
     (grand total   3000 bytes) - no effect + effective
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If neither the NFL42_UFLG_IO_ADVISE_THRU_MDS flag nor the NFL4_UFLG_DENSE flag is set in the layout, then any IO_ADVISE request sent to the data server with a byte range that overlaps stripe units that the data server does not serve MUST NOT result in the status NFS4ERR_PNFS_IO_HOLE. Instead, the response SHOULD be successful, and if the server applies IO_ADVISE hints on any stripe units that overlap with the specified range, those hints SHOULD be indicated in the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFL42_UFLG_IO_ADVISE_THRU_MDSフラグもNFL4_UFLG_DENSEフラグもレイアウトに設定されていない場合、データサーバーが処理しないストライプユニットと重複するバイト範囲でデータサーバーに送信されたIO_ADVISE要求は、ステータスNFS4ERR_PNFS_IO_HOLEにならないはずです。代わりに、応答は成功する必要があり（SHOULD）、サーバーが指定された範囲と重複するストライプユニットにIO_ADVISEヒントを適用する場合、それらのヒントは応答で示される必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-6--Operation-64-LAYOUTERROR---Provide-errors-for-the-layout">
15.6. Operation 64: LAYOUTERROR - Provide errors for the layout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6. 操作64：LAYOUTERROR-レイアウトのエラーを提供します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-6-1--ARGUMENT">
15.6.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct device_error4 {
           deviceid4       de_deviceid;
           nfsstat4        de_status;
           nfs_opnum4      de_opnum;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LAYOUTERROR4args {
           /* CURRENT_FH: file */
           offset4                 lea_offset;
           length4                 lea_length;
           stateid4                lea_stateid;
           device_error4           lea_errors&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-6-2--RESULT">
15.6.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LAYOUTERROR4res {
           nfsstat4        ler_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-6-3--DESCRIPTION">
15.6.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client can use LAYOUTERROR to inform the metadata server about errors in its interaction with the layout (see Section 12 of [RFC5661]) represented by the current filehandle, client ID (derived from the session ID in the preceding SEQUENCE operation), byte range (lea_offset + lea_length), and lea_stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはLAYOUTERRORを使用して、現在のファイルハンドル、クライアントID（前のSEQUENCE操作のセッションIDから派生）、バイト範囲で表されるレイアウト（[RFC5661]のセクション12を参照）とのやり取りのエラーについてメタデータサーバーに通知できます。 （lea_offset + lea_length）、およびlea_stateid。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each individual device_error4 describes a single error associated with a storage device, which is identified via de_deviceid. If the layout type (see Section 12.2.7 of [RFC5661]) supports NFSv4 operations, then the operation that returned the error is identified via de_opnum. If the layout type does not support NFSv4 operations, then either (1) it MAY choose to map the operation onto one of the allowed operations that can be sent to a storage device with the file layout type (see Section 3.3) or (2) it can signal no support for operations by marking de_opnum with the ILLEGAL operation. Finally, the NFS error value (nfsstat4) encountered is provided via de_status and may consist of the following error codes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
個々のdevice_error4は、de_deviceidによって識別されるストレージデバイスに関連する単一のエラーを記述します。レイアウトタイプ（[RFC5661]のセクション12.2.7を参照）がNFSv4操作をサポートしている場合、エラーを返した操作はde_opnumによって識別されます。レイアウトタイプがNFSv4操作をサポートしていない場合、（1）ファイルレイアウトタイプ（セクション3.3を参照）または（2）でストレージデバイスに送信できる許可された操作の1つに操作をマップすることを選択できます（MAY）。 de_opnumをILLEGAL操作でマークすることにより、操作のサポートがないことを通知できます。最後に、発生したNFSエラー値（nfsstat4）は、de_statusを介して提供され、以下のエラーコードで構成される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NXIO: The client was unable to establish any communication with the storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NXIO：クライアントはストレージデバイスとの通信を確立できませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_*: The client was able to establish communication with the storage device and is returning one of the allowed error codes for the operation denoted by de_opnum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ *：クライアントはストレージデバイスとの通信を確立でき、de_opnumで示される操作で許可されているエラーコードの1つを返しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that while the metadata server may return an error associated with the layout stateid or the open file, it MUST NOT return an error in the processing of the errors. If LAYOUTERROR is in a COMPOUND before LAYOUTRETURN, it MUST NOT introduce an error other than what LAYOUTRETURN would already encounter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーがレイアウトステートIDまたは開いているファイルに関連するエラーを返す場合がありますが、エラーの処理中にエラーを返してはなりません。 LAYOUTERRORがLAYOUTRETURNの前のCOMPOUNDにある場合、LAYOUTRETURNがすでに発生しているもの以外のエラーを導入してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-6-4--IMPLEMENTATION">
15.6.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two broad classes of errors: transient and persistent. The client SHOULD strive to only use this new mechanism to report persistent errors. It MUST be able to deal with transient issues by itself. Also, while the client might consider an issue to be persistent, it MUST be prepared for the metadata server to consider such issues to be transient. A prime example of this is if the metadata server fences off a client from either a stateid or a filehandle. The client will get an error from the storage device and might relay either NFS4ERR_ACCESS or NFS4ERR_BAD_STATEID back to the metadata server, with the belief that this is a hard error. If the metadata server is informed by the client that there is an error, it can safely ignore that. For the metadata server, the mission is accomplished in that the client has returned a layout that the metadata server had most likely recalled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラーには、一時的なエラーと永続的なエラーの2つの大きなクラスがあります。クライアントは、この新しいメカニズムのみを使用して永続的なエラーを報告するよう努めるべきです（SHOULD）。一時的な問題を単独で処理できなければなりません。また、クライアントは問題を永続的であると見なす可能性がありますが、メタデータサーバーがそのような問題を一時的であると見なすように準備する必要があります。これの主な例は、メタデータサーバーがクライアントをstateidまたはファイルハンドルから隔離する場合です。クライアントはストレージデバイスからエラーを受け取り、ハードエラーであると信じて、NFS4ERR_ACCESSまたはNFS4ERR_BAD_STATEIDのいずれかをメタデータサーバーに中継する可能性があります。メタデータサーバーは、エラーがあることをクライアントから通知された場合、それを安全に無視できます。メタデータサーバーの場合、ミッションは、クライアントがメタデータサーバーがリコールした可能性が最も高いレイアウトを返したことで達成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client might also need to inform the metadata server that it cannot reach one or more of the storage devices. While the metadata server can detect the connectivity of both of these paths:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、1つ以上のストレージデバイスに到達できないことをメタデータサーバーに通知する必要がある場合もあります。メタデータサーバーはこれらの両方のパスの接続を検出できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o metadata server to storage device
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o メタデータサーバーからストレージデバイス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o metadata server to client
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o メタデータサーバーからクライアントへ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
it cannot determine if the client and storage device path is working. As with the case of the storage device passing errors to the client, it must be prepared for the metadata server to consider such outages as being transitory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとストレージデバイスのパスが機能しているかどうかは判別できません。ストレージデバイスがクライアントにエラーを渡す場合と同様に、メタデータサーバーがそのような停止を一時的なものと見なすように準備する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients are expected to tolerate transient storage device errors, and hence clients SHOULD NOT use the LAYOUTERROR error handling for device access problems that may be transient. The methods by which a client decides whether a device access problem is transient or persistent are implementation specific but may include retrying I/Os to a data server under appropriate conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは一時的なストレージデバイスエラーを許容することが期待されているため、クライアントは一時的なデバイスアクセスの問題に対してLAYOUTERRORエラー処理を使用しないでください。デバイスアクセスの問題が一時的であるか永続的であるかをクライアントが決定する方法は実装固有ですが、適切な条件下でデータサーバーへのI / Oを再試行することも含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an I/O to a storage device fails, the client SHOULD retry the failed I/O via the metadata server. In this situation, before retrying the I/O, the client SHOULD return the layout, or the affected portion thereof, and SHOULD indicate which storage device or devices was problematic. The client needs to do this when the storage device is being unresponsive in order to fence off any failed write attempts and ensure that they do not end up overwriting any later data being written through the metadata server. If the client does not do this, the metadata server MAY issue a layout recall callback in order to perform the retried I/O.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージデバイスへのI / Oが失敗すると、クライアントはメタデータサーバー経由で失敗したI / Oを再試行する必要があります（SHOULD）。この状況では、I / Oを再試行する前に、クライアントはレイアウトまたはその影響を受ける部分を返す必要があり（SHOULD）、問題のあるストレージデバイスを示す必要があります（SHOULD）。クライアントは、ストレージデバイスが応答していないときにこれを行う必要があります。これは、失敗した書き込みの試行を回避し、メタデータサーバーを通じて書き込まれる以降のデータを上書きしないようにするためです。クライアントがこれを行わない場合、メタデータサーバーは、再試行されたI / Oを実行するためにレイアウト再呼び出しコールバックを発行できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client needs to be cognizant that since this error handling is optional in the metadata server, the metadata server may silently ignore this functionality. Also, as the metadata server may consider some issues the client reports to be expected, the client might find it difficult to detect a metadata server that has not implemented error handling via LAYOUTERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、このエラー処理がメタデータサーバーではオプションであるため、メタデータサーバーがこの機能を暗黙的に無視する場合があることを認識する必要があります。また、メタデータサーバーはクライアントが予期するいくつかの問題を考慮する可能性があるため、クライアントはLAYOUTERRORによるエラー処理を実装していないメタデータサーバーを検出することが難しい場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a metadata server is aware that a storage device is proving problematic to a client, the metadata server SHOULD NOT include that storage device in any pNFS layouts sent to that client. If the metadata server is aware that a storage device is affecting many clients, then the metadata server SHOULD NOT include that storage device in any pNFS layouts sent out. If a client asks for a new layout for the file from the metadata server, it MUST be prepared for the metadata server to return that storage device in the layout. The metadata server might not have any choice in using the storage device, i.e., there might only be one possible layout for the system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーがストレージデバイスがクライアントに問題があることを認識している場合、メタデータサーバーは、そのクライアントに送信されるpNFSレイアウトにそのストレージデバイスを含めるべきではありません（SHOULD NOT）。メタデータサーバーが、ストレージデバイスが多くのクライアントに影響を与えていることを認識している場合、メタデータサーバーは、そのストレージデバイスを送信されるpNFSレイアウトに含めないでください。クライアントがメタデータサーバーからファイルの新しいレイアウトを要求する場合、メタデータサーバーがそのストレージデバイスをレイアウトで返すように準備する必要があります。メタデータサーバーは、ストレージデバイスの使用に選択肢がない可能性があります。つまり、システムに可能なレイアウトは1つしかない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Also, in the case of existing files, the metadata server might have no choice regarding which storage devices to hand out to clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、既存のファイルの場合、メタデータサーバーは、クライアントに渡すストレージデバイスを選択できない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The metadata server is not required to indefinitely retain per-client storage device error information. The metadata server is also not required to automatically reinstate the use of a previously problematic storage device; administrative intervention may be required instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーは、クライアントごとのストレージデバイスのエラー情報を無期限に保持する必要はありません。メタデータサーバーは、以前は問題があったストレージデバイスの使用を自動的に回復する必要もありません。代わりに、管理者の介入が必要になる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-7--Operation-65-LAYOUTSTATS---Provide-statistics-for-the-layout">
15.7. Operation 65: LAYOUTSTATS - Provide statistics for the layout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.7. 操作65：LAYOUTSTATS-レイアウトの統計を提供します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-7-1--ARGUMENT">
15.7.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.7.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct layoutupdate4 {
           layouttype4             lou_type;
           opaque                  lou_body&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct io_info4 {
           uint64_t        ii_count;
           uint64_t        ii_bytes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LAYOUTSTATS4args {
           /* CURRENT_FH: file */
           offset4                 lsa_offset;
           length4                 lsa_length;
           stateid4                lsa_stateid;
           io_info4                lsa_read;
           io_info4                lsa_write;
           deviceid4               lsa_deviceid;
           layoutupdate4           lsa_layoutupdate;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-7-2--RESULT">
15.7.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.7.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LAYOUTSTATS4res {
           nfsstat4        lsr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-7-3--DESCRIPTION">
15.7.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.7.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client can use LAYOUTSTATS to inform the metadata server about its interaction with the layout (see Section 12 of [RFC5661]) represented by the current filehandle, client ID (derived from the session ID in the preceding SEQUENCE operation), byte range (lsa_offset and lsa_length), and lsa_stateid. lsa_read and lsa_write allow non-layout-type-specific statistics to be reported. lsa_deviceid allows the client to specify to which storage device the statistics apply. The remaining information the client is presenting is specific to the layout type and presented in the lsa_layoutupdate field. Each layout type MUST define the contents of lsa_layoutupdate in their respective specifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはLAYOUTSTATSを使用して、現在のファイルハンドル、クライアントID（前のSEQUENCE操作のセッションIDから派生）、バイト範囲（lsa_offset）で表されるレイアウト（[RFC5661]のセクション12を参照）との相互作用についてメタデータサーバーに通知できます。およびlsa_length）、およびlsa_stateid。 lsa_readおよびlsa_writeを使用すると、レイアウトタイプ固有ではない統計情報を報告できます。 lsa_deviceidを使用すると、クライアントは統計が適用されるストレージデバイスを指定できます。クライアントが提示する残りの情報は、レイアウトタイプに固有であり、lsa_layoutupdateフィールドに提示されます。各レイアウトタイプは、それぞれの仕様でlsa_layoutupdateの内容を定義する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTSTATS can be combined with IO_ADVISE (see Section 15.5) to augment the decision-making process of how the metadata server handles a file. That is, IO_ADVISE lets the server know that a byte range has a certain characteristic, but not necessarily the intensity of that characteristic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTSTATSをIO_ADVISE（セクション15.5を参照）と組み合わせて、メタデータサーバーがファイルを処理する方法の意思決定プロセスを強化できます。つまり、IO_ADVISEは、バイト範囲に特定の特性があることをサーバーに知らせますが、必ずしもその特性の強度ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The statistics are cumulative, i.e., multiple LAYOUTSTATS updates can be in flight at the same time. The metadata server can examine the packet&#39;s timestamp to order the different calls. The first LAYOUTSTATS sent by the client SHOULD be from the opening of the file. The choice of how often to update the metadata server is made by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
統計は累積的です。つまり、複数のLAYOUTSTATS更新を同時に実行できます。メタデータサーバーは、パケットのタイムスタンプを調べて、さまざまな呼び出しを順序付けることができます。クライアントが送信する最初のLAYOUTSTATSは、ファイルを開いたときのものである必要があります（SHOULD）。メタデータサーバーを更新する頻度の選択は、クライアントが行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that while the metadata server may return an error associated with the layout stateid or the open file, it MUST NOT return an error in the processing of the statistics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバーはレイアウトステートIDまたは開いているファイルに関連するエラーを返す場合がありますが、統計の処理中にエラーを返してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-8--Operation-66-OFFLOADCANCEL---Stop-an-offloaded-operation">
15.8. Operation 66: OFFLOAD_CANCEL - Stop an offloaded operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.8. 操作66：OFFLOAD_CANCEL-オフロードされた操作を停止します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-8-1--ARGUMENT">
15.8.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.8.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OFFLOAD_CANCEL4args {
           /* CURRENT_FH: file to cancel */
           stateid4        oca_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-8-2--RESULT">
15.8.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.8.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OFFLOAD_CANCEL4res {
           nfsstat4        ocr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-8-3--DESCRIPTION">
15.8.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.8.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OFFLOAD_CANCEL is used by the client to terminate an asynchronous operation, which is identified by both CURRENT_FH and the oca_stateid. That is, there can be multiple OFFLOAD_CANCEL operations acting on the file, and the stateid will identify to the server exactly which one is to be stopped. Currently, there are only two operations that can decide to be asynchronous: COPY and WRITE_SAME.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OFFLOAD_CANCELは、クライアントが非同期操作を終了するために使用します。非同期操作は、CURRENT_FHとoca_stateidの両方で識別されます。つまり、ファイルに対して複数のOFFLOAD_CANCEL操作が行われる可能性があり、stateidはサーバーに対して、停止する操作を正確に識別します。現在、非同期であると判断できる操作は、COPYとWRITE_SAMEの2つだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the context of server-to-server copy, the client can send OFFLOAD_CANCEL to either the source or destination server, albeit with a different stateid. The client uses OFFLOAD_CANCEL to inform the destination to stop the active transfer and uses the stateid it got back from the COPY operation. The client uses OFFLOAD_CANCEL and the stateid it used in the COPY_NOTIFY to inform the source to not allow any more copying from the destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー間のコピーのコンテキストでは、クライアントは、異なるstateidを使用して、OFFLOAD_CANCELをソースサーバーまたは宛先サーバーのいずれかに送信できます。クライアントは、OFFLOAD_CANCELを使用して、アクティブな転送を停止するように宛先に通知し、COPY操作から取得した状態IDを使用します。クライアントは、OFFLOAD_CANCELとCOPY_NOTIFYで使用した状態IDを使用して、宛先からのコピーをこれ以上許可しないようにソースに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OFFLOAD_CANCEL is also useful in situations in which the source server granted a very long or infinite lease on the destination server&#39;s ability to read the source file and all COPY operations on the source file have been completed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OFFLOAD_CANCELは、ソースサーバーがソースファイルを読み取る宛先サーバーの機能に対して非常に長いまたは無限のリースを許可し、ソースファイルに対するすべてのCOPY操作が完了した場合にも役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
15.9. Operation 67: OFFLOAD_STATUS - Poll for the status of an asynchronous operation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
15.9. 操作67：OFFLOAD_STATUS-非同期操作のステータスをポーリングします
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-9-1--ARGUMENT">
15.9.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.9.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OFFLOAD_STATUS4args {
           /* CURRENT_FH: destination file */
           stateid4        osa_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-9-2--RESULT">
15.9.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.9.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OFFLOAD_STATUS4resok {
           length4         osr_count;
           nfsstat4        osr_complete&lt;1&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OFFLOAD_STATUS4res switch (nfsstat4 osr_status) {
   case NFS4_OK:
           OFFLOAD_STATUS4resok            osr_resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-9-3--DESCRIPTION">
15.9.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.9.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OFFLOAD_STATUS can be used by the client to query the progress of an asynchronous operation, which is identified by both CURRENT_FH and the osa_stateid. If this operation is successful, the number of bytes processed is returned to the client in the osr_count field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはOFFLOAD_STATUSを使用して、非同期操作の進行状況を照会できます。これは、CURRENT_FHとosa_stateidの両方で識別されます。この操作が成功すると、処理されたバイト数がosr_countフィールドでクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the optional osr_complete field is present, the asynchronous operation has completed. In this case, the status value indicates the result of the asynchronous operation. In all cases, the server will also deliver the final results of the asynchronous operation in a CB_OFFLOAD operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションのosr_completeフィールドが存在する場合、非同期操作は完了しています。この場合、ステータス値は非同期操作の結果を示します。すべての場合において、サーバーは非同期操作の最終結果もCB_OFFLOAD操作で配信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The failure of this operation does not indicate the result of the asynchronous operation in any way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作の失敗は、非同期操作の結果を示すものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-10--Operation-68-READPLUS---READ-data-or-holes-from-a-file">
15.10. Operation 68: READ_PLUS - READ data or holes from a file
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10. 操作68：READ_PLUS-ファイルからデータまたはホールを読み取る
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-10-1--ARGUMENT">
15.10.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READ_PLUS4args {
           /* CURRENT_FH: file */
           stateid4        rpa_stateid;
           offset4         rpa_offset;
           count4          rpa_count;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-10-2--RESULT">
15.10.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum data_content4 {
           NFS4_CONTENT_DATA = 0,
           NFS4_CONTENT_HOLE = 1
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct data_info4 {
           offset4         di_offset;
           length4         di_length;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct data4 {
           offset4         d_offset;
           opaque          d_data&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union read_plus_content switch (data_content4 rpc_content) {
   case NFS4_CONTENT_DATA:
           data4           rpc_data;
   case NFS4_CONTENT_HOLE:
           data_info4      rpc_hole;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Allow a return of an array of contents.
    */
   struct read_plus_res4 {
           bool                    rpr_eof;
           read_plus_content       rpr_contents&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READ_PLUS4res switch (nfsstat4 rp_status) {
   case NFS4_OK:
           read_plus_res4  rp_resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-10-3--DESCRIPTION">
15.10.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READ_PLUS operation is based upon the NFSv4.1 READ operation (see Section 18.22 of [RFC5661]) and similarly reads data from the regular file identified by the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ_PLUS操作は、NFSv4.1 READ操作（[RFC5661]のセクション18.22を参照）に基づいており、現在のファイルハンドルで識別される通常のファイルから同様にデータを読み取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client provides an rpa_offset of where the READ_PLUS is to start and an rpa_count of how many bytes are to be read. An rpa_offset of zero means that data will be read starting at the beginning of the file. If rpa_offset is greater than or equal to the size of the file, the status NFS4_OK is returned with di_length (the data length) set to zero and eof set to TRUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、READ_PLUSを開始する場所のrpa_offsetと、読み取るバイト数のrpa_countを提供します。 rpa_offsetがゼロの場合、データはファイルの先頭から読み取られます。 rpa_offsetがファイルのサイズ以上の場合、ステータスNFS4_OKが返され、di_length（データ長）がゼロに設定され、eofがTRUEに設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READ_PLUS result is comprised of an array of rpr_contents, each of which describes a data_content4 type of data. For NFSv4.2, the allowed values are data and hole. A server MUST support both the data type and the hole if it uses READ_PLUS. If it does not want to support a hole, it MUST use READ. The array contents MUST be contiguous in the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ_PLUSの結果はrpr_contentsの配列で構成され、それぞれの配列はdata_content4タイプのデータを記述します。 NFSv4.2の場合、許可される値はデータとホールです。サーバーは、READ_PLUSを使用する場合、データ型とホールの両方をサポートする必要があります。ホールをサポートしたくない場合は、READを使用する必要があります。配列の内容は、ファイル内で連続している必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Holes SHOULD be returned in their entirety -- clients must be prepared to get more information than they requested. Both the start and the end of the hole may exceed what was requested. If data to be returned is comprised entirely of zeros, then the server SHOULD return that data as a hole instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホールは完全に返される必要があります-クライアントは、要求した以上の情報を取得する準備をする必要があります。穴の開始と終了の両方が、要求されたものを超える可能性があります。返されるデータが完全にゼロで構成されている場合、サーバーは代わりにそのデータをホールとして返す必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server may elect to return adjacent elements of the same type. For example, if the server has a range of data comprised entirely of zeros and then a hole, it might want to return two adjacent holes to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、同じタイプの隣接する要素を返すことを選択できます。たとえば、サーバーに完全にゼロとそれから1つのホールで構成されるデータの範囲がある場合、2つの隣接するホールをクライアントに返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client specifies an rpa_count value of zero, the READ_PLUS succeeds and returns zero bytes of data. In all situations, the server may choose to return fewer bytes than specified by the client. The client needs to check for this condition and handle the condition appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがrpa_count値としてゼロを指定した場合、READ_PLUSは成功し、ゼロバイトのデータを返します。すべての状況で、サーバーは、クライアントが指定したバイトよりも少ないバイトを返すことを選択できます。クライアントはこの状態を確認し、状態を適切に処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client specifies data that is entirely contained within a hole of the file (i.e., both rpa_offset and rpa_offset + rpa_count are within the hole), then the di_offset and di_length returned MAY be for the entire hole. If the owner has a locked byte range covering rpa_offset and rpa_count entirely, the di_offset and di_length MUST NOT be extended outside the locked byte range. This result is considered valid until the file is changed (detected via the change attribute). The server MUST provide the same semantics for the hole as if the client read the region and received zeros; the implied hole&#39;s contents lifetime MUST be exactly the same as any other read data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがファイルのホール内に完全に含まれるデータを指定する場合（つまり、rpa_offsetとrpa_offset + rpa_countの両方がホール内にある場合）、返されるdi_offsetとdi_lengthはホール全体の場合があります。所有者がrp​​a_offsetとrpa_countを完全にカバーするロックされたバイト範囲を持っている場合、di_offsetとdi_lengthはロックされたバイト範囲の外に拡張してはなりません（MUST NOT）。この結果は、ファイルが変更される（change属性で検出される）まで有効と見なされます。サーバーは、クライアントが領域を読み取ってゼロを受信した場合と同じセマンティクスをホールに提供する必要があります。暗黙のホールのコンテンツのライフタイムは、他の読み取りデータとまったく同じでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client specifies data by an rpa_offset that begins in a non-hole of the file but extends into a hole (the rpa_offset + rpa_count is in the hole), the server should return an array comprised of both data and a hole. The client MUST be prepared for the server to return a short read describing just the data. The client will then issue another READ_PLUS for the remaining bytes, to which the server will respond with information about the hole in the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが、ファイルの非ホールから始まり、ホールに拡張するrpa_offsetによってデータを指定する場合（rpa_offset + rpa_countがホールにある）、サーバーはデータとホールの両方で構成される配列を返す必要があります。クライアントは、サーバーがデータのみを説明する短い読み取りを返すように準備する必要があります。その後、クライアントは残りのバイトに対して別のREAD_PLUSを発行し、サーバーはファイルのホールに関する情報で応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Except when special stateids are used, the stateid value for a READ_PLUS request represents a value returned from a previous byte-range lock or share reservation request or the stateid associated with a delegation. The stateid identifies the associated owners, if any, and is used by the server to verify that the associated locks are still valid (e.g., have not been revoked).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特別な状態IDが使用される場合を除いて、READ_PLUS要求の状態ID値は、前のバイト範囲ロックまたは共有予約要求から返された値、または委任に関連付けられた状態IDを表します。 stateidは、関連付けられている所有者を識別し、関連付けられているロックがまだ有効であること（たとえば、取り消されていないこと）を確認するためにサーバーによって使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the read ended at the end of the file (formally, in a correctly formed READ_PLUS operation, if rpa_offset + rpa_count is equal to the size of the file) or the READ_PLUS operation extends beyond the size of the file (if rpa_offset + rpa_count is greater than the size of the file), eof is returned as TRUE; otherwise, it is FALSE. A successful READ_PLUS of an empty file will always return eof as TRUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
読み取りがファイルの最後で終了した場合（正式には、正しく形成されたREAD_PLUS操作で、rpa_offset + rpa_countがファイルのサイズと等しい場合）、またはREAD_PLUS操作がファイルのサイズを超えている場合（rpa_offset + rpa_countがファイルのサイズよりも大きい場合）、eofはTRUEとして返されます。それ以外の場合はFALSEです。空のファイルのREAD_PLUSが成功すると、常にeofがTRUEとして返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is not an ordinary file, an error will be returned to the client. In the case that the current filehandle represents an object of type NF4DIR, NFS4ERR_ISDIR is returned. If the current filehandle designates a symbolic link, NFS4ERR_SYMLINK is returned. In all other cases, NFS4ERR_WRONG_TYPE is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが通常のファイルではない場合、クライアントにエラーが返されます。現在のファイルハンドルがNF4DIRタイプのオブジェクトを表す場合、NFS4ERR_ISDIRが返されます。現在のファイルハンドルがシンボリックリンクを指定している場合、NFS4ERR_SYMLINKが返されます。それ以外の場合はすべて、NFS4ERR_WRONG_TYPEが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a READ_PLUS with a stateid value of all bits equal to zero, the server MAY allow the READ_PLUS to be serviced subject to mandatory byte-range locks or the current share deny modes for the file. For a READ_PLUS with a stateid value of all bits equal to one, the server MAY allow READ_PLUS operations to bypass locking checks at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのビットのstateid値がゼロに等しいREAD_PLUSの場合、サーバーは、ファイルの必須のバイト範囲ロックまたは現在の共有拒否モードに従って、READ_PLUSのサービスを許可できます（MAY）。すべてのビットのstateid値が1であるREAD_PLUSの場合、サーバーは、READ_PLUS操作がサーバーでのロックチェックをバイパスすることを許可する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルはその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-10-3-1--Note-on-Client-Support-of-Arms-of-the-Union">
15.10.3.1. Note on Client Support of Arms of the Union
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.3.1. Arms of the Unionのクライアントサポートに関するメモ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It was decided not to add a means for the client to inform the server as to which arms of READ_PLUS it would support. In a later minor version, it may become necessary for the introduction of a new operation that would allow the client to inform the server as to whether it supported the new arms of the union of data types available in READ_PLUS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがREAD_PLUSのどのアームをサポートするかについてサーバーに通知する手段を追加しないことが決定されました。新しいマイナーバージョンでは、READ_PLUSで使用可能なデータ型のユニオンの新しいアームをサポートしているかどうかをクライアントがサーバーに通知できるようにする新しい操作の導入が必要になる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-10-4--IMPLEMENTATION">
15.10.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.4. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, the IMPLEMENTATION notes for READ in Section 18.22.4 of [RFC5661] also apply to READ_PLUS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般に、[RFC5661]のセクション18.22.4にあるREADの実装に関する注記は、READ_PLUSにも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-10-4-1--Additional-pNFS-Implementation-Information">
15.10.4.1. Additional pNFS Implementation Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.4.1. 追加のpNFS実装情報
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With pNFS, the semantics of using READ_PLUS remains the same. Any data server MAY return a hole result for a READ_PLUS request that it receives. When a data server chooses to return such a result, it has the option of returning information for the data stored on that data server (as defined by the data layout), but it MUST NOT return results for a byte range that includes data managed by another data server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSでは、READ_PLUSを使用するセマンティクスは変わりません。データサーバーは、受信したREAD_PLUSリクエストに対してホール結果を返す場合があります。データサーバーがこのような結果を返すことを選択した場合、そのデータサーバーに格納されているデータの情報を返すオプションがあります（データレイアウトで定義されているとおり）。ただし、管理対象のデータを含むバイト範囲の結果を返してはなりません（MUST NOT）別のデータサーバー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If mandatory locking is enforced, then the data server must also ensure that only information that is within the owner&#39;s locked byte range is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
強制ロックが実施されている場合、データサーバーは、所有者のロックされたバイト範囲内の情報のみが返されることも確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-10-5--READPLUS-with-Sparse-Files-Example">
15.10.5. READ_PLUS with Sparse Files: Example
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.5. スパースファイルを含むREAD_PLUS：例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following table describes a sparse file. For each byte range, the file contains either non-zero data or a hole. In addition, the server in this example will only create a hole if it is greater than 32K.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の表は、スパースファイルについて説明しています。各バイト範囲について、ファイルにはゼロ以外のデータまたはホールが含まれています。さらに、この例のサーバーは、32Kより大きい場合にのみホールを作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        +-------------+----------+
                        | Byte Range  | Contents |
                        +-------------+----------+
                        | 0-15999     | Hole     |
                        | 16K-31999   | Non-Zero |
                        | 32K-255999  | Hole     |
                        | 256K-287999 | Non-Zero |
                        | 288K-353999 | Hole     |
                        | 354K-417999 | Non-Zero |
                        +-------------+----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
Table 7: Sparse File
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
表7：スパースファイル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Under the given circumstances, if a client was to read from the file with a maximum read size of 64K, the following will be the results for the given READ_PLUS calls. This assumes that the client has already opened the file, acquired a valid stateid (&#34;s&#34; in the example), and just needs to issue READ_PLUS requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定の状況下で、クライアントが64Kの最大読み取りサイズでファイルから読み取る場合、以下は特定のREAD_PLUS呼び出しの結果です。これは、クライアントがすでにファイルを開き、有効な状態ID（例では &#34;s&#34;）を取得しており、READ_PLUS要求を発行するだけであると想定しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. READ_PLUS(s, 0, 64K) --&gt; NFS_OK, eof = FALSE, &lt;data[0,32K], hole[32K,224K]&gt;. Since the first hole is less than the server&#39;s minimum hole size, the first 32K of the file is returned as data and the remaining 32K is returned as a hole that actually extends to 256K.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. READ_PLUS（s、0、64K）-&gt; NFS_OK、eof = FALSE、&lt;data [0,32K]、hole [32K、224K]&gt;。最初のホールはサーバーの最小ホールサイズよりも小さいため、ファイルの最初の32Kはデータとして返され、残りの32Kは実際には256Kに及ぶホールとして返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. READ_PLUS(s, 32K, 64K) --&gt; NFS_OK, eof = FALSE, &lt;hole[32K,224K]&gt;. The requested range was all zeros, and the current hole begins at offset 32K and is 224K in length. Note that the client should not have followed up the previous READ_PLUS request with this one, as the hole information from the previous call extended past what the client was requesting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. READ_PLUS（s、32K、64K）-&gt; NFS_OK、eof = FALSE、&lt;hole [32K、224K]&gt;。要求された範囲はすべてゼロであり、現在のホールはオフセット32Kで始まり、長さは224Kです。以前の呼び出しからのホール情報がクライアントが要求していたものを超えて拡張されたため、クライアントは以前のREAD_PLUS要求をこの要求でフォローアップしてはならないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. READ_PLUS(s, 256K, 64K) --&gt; NFS_OK, eof = FALSE, &lt;data[256K, 288K], hole[288K, 354K]&gt;. Returns an array of the 32K data and the hole, which extends to 354K.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. READ_PLUS（s、256K、64K）-&gt; NFS_OK、eof = FALSE、&lt;data [256K、288K]、hole [288K、354K]&gt;。 32Kのデータと354Kに及ぶ穴の配列を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. READ_PLUS(s, 354K, 64K) --&gt; NFS_OK, eof = TRUE, &lt;data[354K, 418K]&gt;. Returns the final 64K of data and informs the client that there is no more data in the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. READ_PLUS（s、354K、64K）-&gt; NFS_OK、eof = TRUE、&lt;data [354K、418K]&gt;。データの最後の64Kを返し、ファイルにデータがなくなったことをクライアントに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-11--Operation-69-SEEK---Find-the-next-data-or-hole">
15.11. Operation 69: SEEK - Find the next data or hole
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.11. 操作69：シーク-次のデータまたはホールを見つける
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-11-1--ARGUMENT">
15.11.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.11.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum data_content4 {
           NFS4_CONTENT_DATA = 0,
           NFS4_CONTENT_HOLE = 1
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SEEK4args {
           /* CURRENT_FH: file */
           stateid4        sa_stateid;
           offset4         sa_offset;
           data_content4   sa_what;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-11-2--RESULT">
15.11.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.11.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct seek_res4 {
           bool            sr_eof;
           offset4         sr_offset;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union SEEK4res switch (nfsstat4 sa_status) {
   case NFS4_OK:
           seek_res4       resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-11-3--DESCRIPTION">
15.11.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.11.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEEK is an operation that allows a client to determine the location of the next data_content4 in a file. It allows an implementation of the emerging extension to the lseek(2) function to allow clients to determine the next hole whilst in data or the next data whilst in a hole.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEEKは、クライアントがファイル内の次のdata_content4の場所を特定できるようにする操作です。これにより、lseek（2）関数の新しい拡張機能を実装して、クライアントがデータ内の次のホール、またはホール内の次のデータを特定できるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the given sa_offset, find the next data_content4 of type sa_what in the file. If the server cannot find a corresponding sa_what, then the status will still be NFS4_OK, but sr_eof would be TRUE. If the server can find the sa_what, then the sr_offset is the start of that content. If the sa_offset is beyond the end of the file, then SEEK MUST return NFS4ERR_NXIO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたsa_offsetから、ファイル内のタイプsa_whatの次のdata_content4を見つけます。サーバーが対応するsa_whatを見つけられない場合、ステータスはNFS4_OKのままですが、sr_eofはTRUEになります。サーバーがsa_whatを見つけることができる場合、sr_offsetはそのコンテンツの始まりです。 sa_offsetがファイルの終わりを超えている場合、SEEKはNFS4ERR_NXIOを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All files MUST have a virtual hole at the end of the file. That is, if a file system does not support sparse files, then a COMPOUND with {SEEK 0 NFS4_CONTENT_HOLE;} would return a result of {SEEK 1 X;}, where &#34;X&#34; was the size of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのファイルには、ファイルの最後に仮想ホールがなければなりません。つまり、ファイルシステムがスパースファイルをサポートしていない場合、{SEEK 0 NFS4_CONTENT_HOLE;}を指定したCOMPOUNDは{SEEK 1 X;}の結果を返します。ここで、「X」はファイルのサイズです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEEK must follow the same rules for stateids as READ_PLUS (Section 15.10.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEEKは、READ_PLUS（セクション15.10.3）と同じ状態IDのルールに従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-12--Operation-70-WRITESAME---WRITE-an-ADB-multiple-times-to-a-file">
15.12. Operation 70: WRITE_SAME - WRITE an ADB multiple times to a file
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12. 操作70：WRITE_SAME-ADBをファイルに複数回書き込む
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-12-1--ARGUMENT">
15.12.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum stable_how4 {
           UNSTABLE4       = 0,
           DATA_SYNC4      = 1,
           FILE_SYNC4      = 2
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct app_data_block4 {
           offset4         adb_offset;
           length4         adb_block_size;
           length4         adb_block_count;
           length4         adb_reloff_blocknum;
           count4          adb_block_num;
           length4         adb_reloff_pattern;
           opaque          adb_pattern&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct WRITE_SAME4args {
           /* CURRENT_FH: file */
           stateid4        wsa_stateid;
           stable_how4     wsa_stable;
           app_data_block4 wsa_adb;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-12-2--RESULT">
15.12.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct write_response4 {
           stateid4        wr_callback_id&lt;1&gt;;
           length4         wr_count;
           stable_how4     wr_committed;
           verifier4       wr_writeverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union WRITE_SAME4res switch (nfsstat4 wsr_status) {
   case NFS4_OK:
           write_response4         resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-12-3--DESCRIPTION">
15.12.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WRITE_SAME operation writes an application data block to the regular file identified by the current filehandle (see WRITE SAME (10) in [T10-SBC2]). The target file is specified by the current filehandle. The data to be written is specified by an app_data_block4 structure (Section 8.1.1). The client specifies with the wsa_stable parameter the method of how the data is to be processed by the server. It is treated like the stable parameter in the NFSv4.1 WRITE operation (see Section 18.32.3 of [RFC5661]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITE_SAME操作は、現在のファイルハンドルで識別される通常のファイルにアプリケーションデータブロックを書き込みます（[T10-SBC2]のWRITE SAME（10）を参照）。ターゲットファイルは、現在のファイルハンドルによって指定されます。書き込まれるデータは、app_data_block4構造体によって指定されます（セクション8.1.1）。クライアントは、wsa_stableパラメーターを使用して、サーバーによるデータの処理方法を指定します。これは、NFSv4.1 WRITE操作の安定したパラメータのように扱われます（[RFC5661]のセクション18.32.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A successful WRITE_SAME will construct a reply for wr_count, wr_committed, and wr_writeverf as per the NFSv4.1 WRITE operation results. If wr_callback_id is set, it indicates an asynchronous reply (see Section 15.12.3.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正常なWRITE_SAMEは、NFSv4.1 WRITE操作の結果に従って、wr_count、wr_committed、およびwr_writeverfに対する応答を構築します。 wr_callback_idが設定されている場合は、非同期応答を示します（15.12.3.1項を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As it is an OPTIONAL operation, WRITE_SAME has to support NFS4ERR_NOTSUPP. As it is an extension of WRITE, it has to support all of the errors returned by WRITE. If the client supports WRITE_SAME, it MUST support CB_OFFLOAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはオプションの操作であるため、WRITE_SAMEはNFS4ERR_NOTSUPPをサポートする必要があります。これはWRITEの拡張であるため、WRITEによって返されるすべてのエラーをサポートする必要があります。クライアントがWRITE_SAMEをサポートする場合、CB_OFFLOADをサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server supports ADBs, then it MUST support the WRITE_SAME operation. The server has no concept of the structure imposed by the application. It is only when the application writes to a section of the file does order get imposed. In order to detect corruption even before the application utilizes the file, the application will want to initialize a range of ADBs using WRITE_SAME.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがADBをサポートする場合は、WRITE_SAME操作をサポートする必要があります。サーバーには、アプリケーションによって課される構造の概​​念はありません。これは、アプリケーションがファイルのセクションに書き込むときにのみ、順序付けが課されます。アプリケーションがファイルを使用する前でも破損を検出するために、アプリケーションはWRITE_SAMEを使用して一連のADBを初期化する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client invokes the WRITE_SAME operation, it wants to record the block structure described by the app_data_block4 into the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがWRITE_SAME操作を呼び出すと、app_data_block4で記述されたブロック構造をファイルに記録する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server receives the WRITE_SAME operation, it MUST populate adb_block_count ADBs in the file, starting at adb_offset. The block size will be given by adb_block_size. The ADBN (if provided) will start at adb_reloff_blocknum, and each block will be monotonically numbered, starting from adb_block_num in the first block. The pattern (if provided) will be at adb_reloff_pattern of each block and will be provided in adb_pattern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはWRITE_SAMEオペレーションを受信すると、adb_block_count ADBをadb_offsetからファイルに追加する必要があります。ブロックサイズはadb_block_sizeで指定されます。 ADBN（指定されている場合）はadb_reloff_blocknumから始まり、各ブロックは最初のブロックのadb_block_numから始まり、単調に番号が付けられます。パターン（提供されている場合）は各ブロックのadb_reloff_patternにあり、adb_patternで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server SHOULD return an asynchronous result if it can determine that the operation will be long-running (see Section 15.12.3.1). Once either the WRITE_SAME finishes synchronously or the server uses CB_OFFLOAD to inform the client of the asynchronous completion of the WRITE_SAME, the server MUST return the ADBs to clients as data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作が長時間実行されると判断できる場合、サーバーは非同期の結果を返す必要があります（セクション15.12.3.1を参照）。 WRITE_SAMEが同期的に完了するか、サーバーがCB_OFFLOADを使用してWRITE_SAMEの非同期完了をクライアントに通知すると、サーバーはADBをデータとしてクライアントに返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-12-3-1--Asynchronous-Transactions">
15.12.3.1. Asynchronous Transactions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12.3.1. 非同期トランザクション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ADB initialization may cause a server to decide to service the operation asynchronously. If it decides to do so, it sets the stateid in wr_callback_id to be that of the wsa_stateid. If it does not set the wr_callback_id, then the result is synchronous.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ADBの初期化により、サーバーが操作を非同期で処理することを決定する場合があります。そうすることに決めた場合は、wr_callback_idの状態IDをwsa_stateidの状態IDに設定します。 wr_callback_idを設定しない場合、結果は同期的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client determines that the reply will be given asynchronously, it should not assume anything about the contents of what it wrote until it is informed by the server that the operation is complete. It can use OFFLOAD_STATUS (Section 15.9) to monitor the operation and OFFLOAD_CANCEL (Section 15.8) to cancel the operation. An example of an asynchronous WRITE_SAME is shown in Figure 6. Note that, as with the COPY operation, WRITE_SAME must provide a stateid for tracking the asynchronous operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが応答が非同期で行われることを決定した場合、サーバーは、操作が完了したことを通知されるまで、書き込んだ内容について何も想定しないでください。 OFFLOAD_STATUS（セクション15.9）を使用して操作を監視し、OFFLOAD_CANCEL（セクション15.8）を使用して操作をキャンセルできます。非同期WRITE_SAMEの例を図6に示します。COPY操作と同様に、WRITE_SAMEは非同期操作を追跡するための状態IDを提供する必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Client                                  Server
        +                                      +
        |                                      |
        |--- OPEN ----------------------------&gt;| Client opens
        |&lt;------------------------------------/| the file
        |                                      |
        |--- WRITE_SAME ----------------------&gt;| Client initializes
        |&lt;------------------------------------/| an ADB
        |                                      |
        |                                      |
        |--- OFFLOAD_STATUS ------------------&gt;| Client may poll
        |&lt;------------------------------------/| for status
        |                                      |
        |                  .                   | Multiple OFFLOAD_STATUS
        |                  .                   | operations may be sent.
        |                  .                   |
        |                                      |
        |&lt;-- CB_OFFLOAD -----------------------| Server reports results
        |\------------------------------------&gt;|
        |                                      |
        |--- CLOSE ---------------------------&gt;| Client closes
        |&lt;------------------------------------/| the file
        |                                      |
        |                                      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
Figure 6: An Asynchronous WRITE_SAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
図6：非同期のWRITE_SAME
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When CB_OFFLOAD informs the client of the successful WRITE_SAME, the write_response4 embedded in the operation will provide the necessary information that a synchronous WRITE_SAME would have provided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_OFFLOADがクライアントにWRITE_SAMEが成功したことを通知すると、操作に埋め込まれたwrite_response4が、同期WRITE_SAMEが提供する必要のある必要な情報を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of whether the operation is asynchronous or synchronous, it MUST still support the COMMIT operation semantics as outlined in Section 18.3 of [RFC5661]. That is, COMMIT works on one or more WRITE operations, and the WRITE_SAME operation can appear as several WRITE operations to the server. The client can use locking operations to control the behavior on the server with respect to long-running asynchronous WRITE_SAME operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661]のセクション18.3で概説されているように、操作が非同期か同期かに関係なく、COMMIT操作のセマンティクスをサポートする必要があります。つまり、COMMITは1つ以上のWRITE操作で機能し、WRITE_SAME操作はサーバーに対していくつかのWRITE操作として表示されます。クライアントは、ロック操作を使用して、長時間実行される非同期のWRITE_SAME操作に関してサーバー上の動作を制御できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-12-3-2--Error-Handling-of-a-Partially-Complete-WRITESAME">
15.12.3.2. Error Handling of a Partially Complete WRITE_SAME
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12.3.2. 部分的に完了したWRITE_SAMEのエラー処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITE_SAME will clone adb_block_count copies of the given ADB in consecutive order in the file, starting at adb_offset. An error can occur after writing the Nth ADB to the file. WRITE_SAME MUST appear to populate the range of the file as if the client used WRITE to transfer the instantiated ADBs. That is, the contents of the range will be easy for the client to determine in the case of a partially complete WRITE_SAME.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITE_SAMEは、adb_offsetから開始して、指定されたADBのadb_block_countコピーをファイル内で連続した順序で複製します。 N番目のADBをファイルに書き込んだ後、エラーが発生する可能性があります。 WRITE_SAMEは、イン​​スタンス化されたADBを転送するためにクライアントがWRITEを使用するかのように、ファイルの範囲を設定するように見える必要があります。つまり、範囲の内容は、部分的に完全なWRITE_SAMEの場合、クライアントが簡単に判断できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-13--Operation-71-CLONE---Clone-a-range-of-a-file-into-another-file">
15.13. Operation 71: CLONE - Clone a range of a file into another file
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.13. 操作71：CLONE-ファイルの範囲を別のファイルに複製
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-13-1--ARGUMENT">
15.13.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.13.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CLONE4args {
           /* SAVED_FH: source file */
           /* CURRENT_FH: destination file */
           stateid4        cl_src_stateid;
           stateid4        cl_dst_stateid;
           offset4         cl_src_offset;
           offset4         cl_dst_offset;
           length4         cl_count;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-13-2--RESULT">
15.13.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.13.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CLONE4res {
           nfsstat4        cl_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="15-13-3--DESCRIPTION">
15.13.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.13.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CLONE operation is used to clone file content from a source file specified by the SAVED_FH value into a destination file specified by CURRENT_FH without actually copying the data, e.g., by using a copy-on-write mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLONE操作は、SAVED_FH値で指定されたソースファイルからCURRENT_FHで指定された宛先ファイルにファイルの内容を複製するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both SAVED_FH and CURRENT_FH must be regular files. If either SAVED_FH or CURRENT_FH is not a regular file, the operation MUST fail and return NFS4ERR_WRONG_TYPE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SAVED_FHとCURRENT_FHはどちらも通常のファイルである必要があります。 SAVED_FHまたはCURRENT_FHのいずれかが通常のファイルでない場合、操作は失敗し、NFS4ERR_WRONG_TYPEを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ca_dst_stateid MUST refer to a stateid that is valid for a WRITE operation and follows the rules for stateids in Sections 8.2.5 and 18.32.3 of [RFC5661]. The ca_src_stateid MUST refer to a stateid that is valid for a READ operation and follows the rules for stateids in Sections 8.2.5 and 18.22.3 of [RFC5661]. If either stateid is invalid, then the operation MUST fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ca_dst_stateidは、WRITE操作に有効であり、[RFC5661]のセクション8.2.5および18.32.3のステートIDのルールに従うステートIDを参照する必要があります。 ca_src_stateidは、READ操作に有効な状態IDを参照しなければならず、[RFC5661]のセクション8.2.5および18.22.3の状態IDのルールに従う必要があります。どちらかのstateidが無効な場合、操作は失敗する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cl_src_offset is the starting offset within the source file from which the data to be cloned will be obtained, and the cl_dst_offset is the starting offset of the target region into which the cloned data will be placed. An offset of 0 (zero) indicates the start of the respective file. The number of bytes to be cloned is obtained from cl_count, except that a cl_count of 0 (zero) indicates that the number of bytes to be cloned is the count of bytes between cl_src_offset and the EOF of the source file. Both cl_src_offset and cl_dst_offset must be aligned to the clone block size (Section 12.2.1). The number of bytes to be cloned must be a multiple of the clone block size, except in the case in which cl_src_offset plus the number of bytes to be cloned is equal to the source file size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cl_src_offsetは、複製されるデータが取得されるソースファイル内の開始オフセットであり、cl_dst_offsetは、複製されたデータが配置されるターゲット領域の開始オフセットです。オフセット0（ゼロ）は、それぞれのファイルの開始を示します。クローンされるバイト数はcl_countから取得されます。ただし、cl_countの0（ゼロ）は、クローンされるバイト数がcl_src_offsetとソースファイルのEOFの間のバイト数であることを示します。 cl_src_offsetとcl_dst_offsetの両方をクローンブロックサイズに揃える必要があります（セクション12.2.1）。クローンするバイト数は、クローンブロックサイズの倍数である必要があります。ただし、cl_src_offsetとクローンするバイト数の合計がソースファイルのサイズと等しい場合は除きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the source offset or the source offset plus count is greater than the size of the source file, the operation MUST fail with NFS4ERR_INVAL. The destination offset or destination offset plus count may be greater than the size of the destination file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースオフセットまたはソースオフセットとカウントがソースファイルのサイズより大きい場合、操作はNFS4ERR_INVALで失敗する必要があります。宛先オフセットまたは宛先オフセットとカウントは、宛先ファイルのサイズよりも大きい場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If SAVED_FH and CURRENT_FH refer to the same file and the source and target ranges overlap, the operation MUST fail with NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SAVED_FHとCURRENT_FHが同じファイルを参照し、ソースとターゲットの範囲が重複している場合、操作はNFS4ERR_INVALで失敗する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the target area of the CLONE operation ends beyond the end of the destination file, the offset at the end of the target area will determine the new size of the destination file. The contents of any block not part of the target area will be the same as if the file size were extended by a WRITE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLONE操作のターゲット領域が宛先ファイルの終わりを超えて終了する場合、ターゲット領域の終わりのオフセットにより、宛先ファイルの新しいサイズが決まります。ターゲット領域の一部ではないブロックの内容は、ファイルサイズがWRITEによって拡張された場合と同じになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the area to be cloned is not a multiple of the clone block size and the size of the destination file is past the end of the target area, the area between the end of the target area and the next multiple of the clone block size will be zeroed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クローンする領域がクローンブロックサイズの倍数ではなく、宛先ファイルのサイズがターゲット領域の終わりを超えている場合、ターゲット領域の終わりとクローンブロックサイズの次の倍数の間の領域はゼロになる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CLONE operation is atomic in that other operations may not see any intermediate states between the state of the two files before the operation and after the operation. READs of the destination file will never see some blocks of the target area cloned without all of them being cloned. WRITEs of the source area will either have no effect on the data of the target file or be fully reflected in the target area of the destination file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLONE操作はアトミックであり、他の操作では、操作前と操作後の2つのファイルの状態の中間状態を確認できない場合があります。宛先ファイルのREADは、すべてのクローンが作成されない限り、クローンされたターゲット領域の一部のブロックを決して見ることはありません。ソース領域の書き込みは、ターゲットファイルのデータに影響しないか、宛先ファイルのターゲット領域に完全に反映されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The completion status of the operation is indicated by cr_status.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作の完了ステータスはcr_statusで示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16--NFSv4-2-Callback-Operations">
16. NFSv4.2 Callback Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. NFSv4.2コールバック操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
16.1. Operation 15: CB_OFFLOAD - Report the results of an asynchronous operation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
16.1. 操作15：CB_OFFLOAD-非同期操作の結果を報告する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16-1-1--ARGUMENT">
16.1.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.1. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct write_response4 {
           stateid4        wr_callback_id&lt;1&gt;;
           length4         wr_count;
           stable_how4     wr_committed;
           verifier4       wr_writeverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union offload_info4 switch (nfsstat4 coa_status) {
   case NFS4_OK:
           write_response4 coa_resok4;
   default:
           length4         coa_bytes_copied;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_OFFLOAD4args {
           nfs_fh4         coa_fh;
           stateid4        coa_stateid;
           offload_info4   coa_offload_info;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16-1-2--RESULT">
16.1.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.2. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード開始&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_OFFLOAD4res {
           nfsstat4        cor_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;コード終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="16-1-3--DESCRIPTION">
16.1.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.3. 説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_OFFLOAD is used to report to the client the results of an asynchronous operation, e.g., server-side COPY or WRITE_SAME. The coa_fh and coa_stateid identify the transaction, and the coa_status indicates success or failure. The coa_resok4.wr_callback_id MUST NOT be set. If the transaction failed, then the coa_bytes_copied contains the number of bytes copied before the failure occurred. The coa_bytes_copied value indicates the number of bytes copied but not which specific bytes have been copied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_OFFLOADは、サーバー側のCOPYまたはWRITE_SAMEなどの非同期操作の結果をクライアントに報告するために使用されます。 coa_fhおよびcoa_stateidはトランザクションを識別し、coa_statusは成功または失敗を示します。 coa_resok4.wr_callback_idを設定してはなりません（MUST NOT）。トランザクションが失敗した場合、coa_bytes_copiedには、失敗が発生する前にコピーされたバイト数が含まれます。 coa_bytes_copied値は、コピーされたバイト数を示しますが、コピーされた特定のバイトは示しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client supports any of the following operations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが次の操作のいずれかをサポートしている場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPY: for both intra-server and inter-server asynchronous copies
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPY：サーバー内とサーバー間の非同期コピーの両方
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITE_SAME: for ADB initialization
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITE_SAME：ADB初期化用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
then the client is REQUIRED to support the CB_OFFLOAD operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、クライアントはCB_OFFLOAD操作をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is a potential race between the reply to the original transaction on the forechannel and the CB_OFFLOAD callback on the backchannel. Section 2.10.6.3 of [RFC5661] describes how to handle this type of issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フォアチャネルでの元のトランザクションへの応答とバックチャネルでのCB_OFFLOADコールバックの間には潜在的な競合があります。 [RFC5661]のセクション2.10.6.3では、この種の問題の処理方法について説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon success, the coa_resok4.wr_count presents for each operation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、coa_resok4.wr_countが各操作に対して存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPY: the total number of bytes copied
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COPY：コピーされた合計バイト数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITE_SAME: the same information that a synchronous WRITE_SAME would provide
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITE_SAME：同期WRITE_SAMEが提供するのと同じ情報
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="17--Security-Considerations">
17. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2 has all of the security concerns present in NFSv4.1 (see Section 21 of [RFC5661]), as well as those present in the server-side copy (see Section 4.9) and in Labeled NFS (see Section 9.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.2には、NFSv4.1（[RFC5661]のセクション21を参照）だけでなく、サーバー側のコピー（セクション4.9を参照）およびラベル付きNFS（セクション9.6を参照）に存在するすべてのセキュリティ上の懸念があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="18--IANA-Considerations">
18. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. IANAに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IANA considerations for Labeled NFS are addressed in [RFC7569].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ラベル付きNFSに関するIANAの考慮事項は、[RFC7569]で対処されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19--References">
19. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19-1--Normative-References">
19.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[posix_fadvise] The Open Group, &#34;Section &#39;posix_fadvise()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2016 Edition (HTML Version), ISBN 1937218812, September 2016, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[posix_fadvise]オープングループ、「オープングループの基本仕様の問題7のシステムインターフェースの「posix_fadvise()」セクション、IEEE Std 1003.1、2016年版（HTMLバージョン）、ISBN 1937218812、2016年9月、&lt;http：// www .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[posix_fallocate] The Open Group, &#34;Section &#39;posix_fallocate()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2016 Edition (HTML Version), ISBN 1937218812, September 2016, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[posix_fallocate]オープングループ、「オープングループの基本仕様の問題7のシステムインターフェースの「posix_fallocate()」セクション、IEEE Std 1003.1、2016年版（HTMLバージョン）、ISBN 1937218812、2016年9月、&lt;http：// www .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;http://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;http://www.rfc-editor.org/info/ rfc2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, &#34;Uniform Resource Identifier (URI): Generic Syntax&#34;, STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, &lt;http://www.rfc-editor.org/info/rfc3986&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3986] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月、&lt;http：/ /www.rfc-editor.org/info/rfc3986&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Minor Version 1 Protocol&#34;, RFC 5661, DOI 10.17487/RFC5661, January 2010, &lt;http://www.rfc-editor.org/info/rfc5661&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661] Shepler、S.、Ed。、Eisler、M.、Ed。、and D. Noveck、Ed。、 &#34;Network File System（NFS）Version 4 Minor Version 1 Protocol&#34;、RFC 5661、DOI 10.17487 / RFC5661、 2010年1月、&lt;http://www.rfc-editor.org/info/rfc5661&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5662] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Minor Version 1 External Data Representation Standard (XDR) Description&#34;, RFC 5662, DOI 10.17487/RFC5662, January 2010, &lt;http://www.rfc-editor.org/info/rfc5662&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5662] Shepler、S.、Ed。、Eisler、M.、Ed。、and D. Noveck、Ed。、 &#34;Network File System（NFS）Version 4 Minor Version 1 External Data Representation Standard（XDR）Description&#34;、RFC 5662、DOI 10.17487 / RFC5662、2010年1月、&lt;http://www.rfc-editor.org/info/rfc5662&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7569] Quigley, D., Lu, J., and T. Haynes, &#34;Registry Specification for Mandatory Access Control (MAC) Security Label Formats&#34;, RFC 7569, DOI 10.17487/RFC7569, July 2015, &lt;http://www.rfc-editor.org/info/rfc7569&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7569] Quigley、D.、Lu、J。、およびT. Haynes、「Registry Specification for Mandatory Access Control（MAC）Security Label Formats」、RFC 7569、DOI 10.17487 / RFC7569、2015年7月、&lt;http：// www .rfc-editor.org / info / rfc7569&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7861] Adamson, A. and N. Williams, &#34;Remote Procedure Call (RPC) Security Version 3&#34;, RFC 7861, DOI 10.17487/RFC7861, November 2016, &lt;http://www.rfc-editor.org/info/rfc7861&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7861] Adamson、A。およびN. Williams、「Remote Procedure Call（RPC）Security Version 3」、RFC 7861、DOI 10.17487 / RFC7861、2016年11月、&lt;http://www.rfc-editor.org/info/ rfc7861&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7863] Haynes, T., &#34;Network File System (NFS) Version 4 Minor Version 2 External Data Representation Standard (XDR) Description&#34;, RFC 7863, DOI 10.17487/RFC7863, November 2016, &lt;http://www.rfc-editor.org/info/rfc7863&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7863]ヘインズ、T。、「ネットワークファイルシステム（NFS）バージョン4マイナーバージョン2外部データ表現標準（XDR）の説明」、RFC 7863、DOI 10.17487 / RFC7863、2016年11月、&lt;http：//www.rfc- editor.org/info/rfc7863&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="19-2--Informative-References">
19.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Ashdown08] Ashdown, L., &#34;Chapter 15: Validating Database Files and Backups&#34;, Oracle Database Backup and Recovery User&#39;s Guide 11g Release 1 (11.1), August 2008, &lt;http://download.oracle.com/docs/cd/B28359_01/backup.111/ b28270/rcmvalid.htm&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Ashdown08] Ashdown、L。、「Chapter 15：Validating Database Files and Backups」、 『Oracle Databaseバックアップおよびリカバリユーザーズガイド11gリリース1（11.1）、2008年8月、&lt;http://download.oracle.com/docs/cd /B28359_01/backup.111/ b28270 / rcmvalid.htm&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Baira08] Bairavasundaram, L., Goodson, G., Schroeder, B., Arpaci-Dusseau, A., and R. Arpaci-Dusseau, &#34;An Analysis of Data Corruption in the Storage Stack&#34;, Proceedings of the 6th USENIX Symposium on File and Storage Technologies (FAST &#39;08), 2008, &lt;http://www.usenix.org/events/fast08/tech/full_papers/ bairavasundaram/bairavasundaram.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Baira08] Bairavasundaram、L.、Goodson、G.、Schroeder、B.、Arpaci-Dusseau、A.、and R. Arpaci-Dusseau、 &#34;An Analysis of Data Corruption in the Storage Stack&#34;、Proceedings of the 6th USENIX Symposium on File and Storage Technologies（FAST &#39;08）、2008、&lt;http://www.usenix.org/events/fast08/tech/full_papers/ bairavasundaram / bairavasundaram.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IESG08] IESG, &#34;IESG Processing of RFC Errata for the IETF Stream&#34;, July 2008, &lt;https://www.ietf.org/iesg/statement/ errata-processing.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IESG08] IESG、「IETF StreamのRFCエラータのIESG処理」、2008年7月、&lt;https://www.ietf.org/iesg/statement/ errata-processing.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LB96] LaPadula, L. and D. Bell, &#34;MITRE Technical Report 2547, Volume II&#34;, Journal of Computer Security, Volume 4, Issue 2-3, 239-263, IOS Press, Amsterdam, The Netherlands, January 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LB96] LaPadula、L。およびD. Bell、「MITRE Technical Report 2547、Volume II」、Journal of Computer Security、Volume 4、Issue 2-3、239-263、IOS Press、アムステルダム、オランダ、1996年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[McDougall07] McDougall, R. and J. Mauro, &#34;Section 11.4.3: Detecting Memory Corruption&#34;, Solaris Internals: Solaris 10 and OpenSolaris Kernel Architecture, 2nd Edition, 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[McDougall07] McDougall、R。およびJ. Mauro、「セクション11.4.3：Detecting Memory Corruption」、Solaris Internals：Solaris 10 and OpenSolaris Kernel Architecture、2nd Edition、2007。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NFSv4-Versioning] Noveck, D., &#34;Rules for NFSv4 Extensions and Minor Versions&#34;, Work in Progress, draft-ietf-nfsv4-versioning-07, October 2016.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NFSv4-Versioning] Noveck、D。、「Rules for NFSv4 Extensions and Minor Versions」、Work in Progress、draft-ietf-nfsv4-versioning-07、2016年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC959] Postel, J. and J. Reynolds, &#34;File Transfer Protocol&#34;, STD 9, RFC 959, DOI 10.17487/RFC0959, October 1985, &lt;http://www.rfc-editor.org/info/rfc959&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC959] Postel、J。およびJ. Reynolds、「ファイル転送プロトコル」、STD 9、RFC 959、DOI 10.17487 / RFC0959、1985年10月、&lt;http://www.rfc-editor.org/info/rfc959&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1108] Kent, S., &#34;U.S. Department of Defense Security Options for the Internet Protocol&#34;, RFC 1108, DOI 10.17487/RFC1108, November 1991, &lt;http://www.rfc-editor.org/info/rfc1108&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1108]ケントS.、「インターネットプロトコルのための米国国防総省セキュリティオプション」、RFC 1108、DOI 10.17487 / RFC1108、1991年11月、&lt;http://www.rfc-editor.org/info/rfc1108&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2401] Kent, S. and R. Atkinson, &#34;Security Architecture for the Internet Protocol&#34;, RFC 2401, DOI 10.17487/RFC2401, November 1998, &lt;http://www.rfc-editor.org/info/rfc2401&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2401]ケント、S。、およびR.アトキンソン、「インターネットプロトコルのセキュリティアーキテクチャ」、RFC 2401、DOI 10.17487 / RFC2401、1998年11月、&lt;http://www.rfc-editor.org/info/rfc2401&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4506] Eisler, M., Ed., &#34;XDR: External Data Representation Standard&#34;, STD 67, RFC 4506, DOI 10.17487/RFC4506, May 2006, &lt;http://www.rfc-editor.org/info/rfc4506&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4506] Eisler、M。、編、「XDR：外部データ表現標準」、STD 67、RFC 4506、DOI 10.17487 / RFC4506、2006年5月、&lt;http://www.rfc-editor.org/info/rfc4506 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4949] Shirey, R., &#34;Internet Security Glossary, Version 2&#34;, FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007, &lt;http://www.rfc-editor.org/info/rfc4949&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4949] Shirey、R。、「インターネットセキュリティ用語集、バージョン2」、FYI 36、RFC 4949、DOI 10.17487 / RFC4949、2007年8月、&lt;http://www.rfc-editor.org/info/rfc4949&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5663] Black, D., Fridella, S., and J. Glasgow, &#34;Parallel NFS (pNFS) Block/Volume Layout&#34;, RFC 5663, DOI 10.17487/RFC5663, January 2010, &lt;http://www.rfc-editor.org/info/rfc5663&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5663] Black、D.、Fridella、S。、およびJ. Glasgow、「Parallel NFS（pNFS）Block / Volume Layout」、RFC 5663、DOI 10.17487 / RFC5663、2010年1月、&lt;http：//www.rfc- editor.org/info/rfc5663&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7204] Haynes, T., &#34;Requirements for Labeled NFS&#34;, RFC 7204, DOI 10.17487/RFC7204, April 2014, &lt;http://www.rfc-editor.org/info/rfc7204&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7204]ヘインズ、T。、「ラベル付きNFSの要件」、RFC 7204、DOI 10.17487 / RFC7204、2014年4月、&lt;http://www.rfc-editor.org/info/rfc7204&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7230] Fielding, R., Ed., and J. Reschke, Ed., &#34;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&#34;, RFC 7230, DOI 10.17487/RFC7230, June 2014, &lt;http://www.rfc-editor.org/info/rfc7230&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7230] Fielding、R.、Ed。、and J. Reschke、Ed。、 &#34;Hypertext Transfer Protocol（HTTP / 1.1）：Message Syntax and Routing&#34;、RFC 7230、DOI 10.17487 / RFC7230、June 2014、&lt;http：/ /www.rfc-editor.org/info/rfc7230&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7530] Haynes, T., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Protocol&#34;, RFC 7530, DOI 10.17487/RFC7530, March 2015, &lt;http://www.rfc-editor.org/info/rfc7530&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7530] Haynes、T。、編、およびD. Noveck、編、「Network File System（NFS）Version 4 Protocol」、RFC 7530、DOI 10.17487 / RFC7530、2015年3月、&lt;http：//www.rfc -editor.org/info/rfc7530&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Strohm11] Strohm, R., &#34;Chapter 2: Data Blocks, Extents, and Segments&#34;, Oracle Database Concepts 11g Release 1 (11.1), January 2011, &lt;http://download.oracle.com/docs/cd/B28359_01/server.111/ b28318/logical.htm&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Strohm11] Strohm、R。、「Chapter 2：Data Blocks、Extents、and Segments」、Oracle Database Concepts 11g Release 1（11.1）、2011年1月、&lt;http://download.oracle.com/docs/cd/B28359_01 /server.111/ b28318 / logical.htm&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[T10-SBC2] Elliott, R., Ed., &#34;ANSI INCITS 405-2005, Information Technology - SCSI Block Commands - 2 (SBC-2)&#34;, November 2004, &lt;ftp://www.t10.org/t10/document.05/05-344r0.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[T10-SBC2]エリオット、R。、編、「ANSI INCITS 405-2005、情報技術-SCSIブロックコマンド-2（SBC-2）」、2004年11月、&lt;ftp://www.t10.org/t10 /document.05/05-344r0.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tom Haynes would like to thank NetApp, Inc. for its funding of his time on this project.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トム・ヘインズは、このプロジェクトに費やしたNetApp、Inc.に感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the topic &#34;sharing change attribute implementation characteristics with NFSv4 clients&#34;, the original document was by Trond Myklebust.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「NFSv4クライアントとの変更属性実装特性の共有」というトピックについては、元の文書はTrond Myklebustによるものでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the NFS server-side copy, the original document was by James Lentini, Mike Eisler, Deepak Kenchammana, Anshul Madan, and Rahul Iyer. Tom Talpey co-authored an unpublished version of that document. It was also reviewed by a number of individuals: Pranoop Erasani, Tom Haynes, Arthur Lent, Trond Myklebust, Dave Noveck, Theresa Lingutla-Raj, Manjunath Shankararao, Satyam Vaghani, and Nico Williams. Anna Schumaker&#39;s early prototyping experience helped us avoid some traps. Also, both Olga Kornievskaia and Andy Adamson brought implementation experience to the use of copy stateids in the inter-server copy. Jorge Mora was able to optimize the handling of errors for the result of COPY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSサーバー側のコピーの場合、元のドキュメントはJames Lentini、Mike Eisler、Deepak Kenchammana、Anshul Madan、Rahul Iyerによるものです。 Tom Talpeyは、そのドキュメントの未公開バージョンを共同執筆しました。また、Pranoop Erasani、Tom Haynes、Arthur Lent、Trond Myklebust、Dave Noveck、Theresa Lingutla-Raj、Manjunath Shankararao、Satyam Vaghani、Nico Williamsなどの多数の個人によってレビューされました。 Anna Schumakerの初期のプロトタイピング経験は、いくつかの罠を回避するのに役立ちました。また、Olga KornievskaiaとAndy Adamsonの両方が、サーバー間コピーでのコピー状態IDの使用に実装経験をもたらしました。 Jorge Moraは、COPYの結果のエラー処理を最適化することができました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the NFS space reservation operations, the original document was by Mike Eisler, James Lentini, Manjunath Shankararao, and Rahul Iyer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSスペース予約操作の場合、元の文書はMike Eisler、James Lentini、Manjunath Shankararao、およびRahul Iyerによるものでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the sparse file support, the original document was by Dean Hildebrand and Marc Eshel. Valuable input and advice was received from Sorin Faibish, Bruce Fields, Benny Halevy, Trond Myklebust, and Richard Scheffenegger.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スパースファイルのサポートについては、元のドキュメントはDean HildebrandとMarc Eshelによるものでした。 Sorin Faibish、Bruce Fields、Benny Halevy、Trond Myklebust、Richard Scheffeneggerから貴重な情報とアドバイスを受けました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the application I/O hints, the original document was by Dean Hildebrand, Mike Eisler, Trond Myklebust, and Sam Falkner. Some early reviewers included Benny Halevy and Pranoop Erasani.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションのI / Oヒントについては、元のドキュメントはDean Hildebrand、Mike Eisler、Trond Myklebust、Sam Falknerによるものでした。初期のレビュアーには、Benny HalevyとPranoop Erasaniが含まれていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For Labeled NFS, the original document was by David Quigley, James Morris, Jarrett Lu, and Tom Haynes. Peter Staubach, Trond Myklebust, Stephen Smalley, Sorin Faibish, Nico Williams, and David Black also contributed in the final push to get this accepted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Labeled NFSの場合、元のドキュメントはDavid Quigley、James Morris、Jarrett Lu、Tom Haynesによるものでした。 Peter Staubach、Trond Myklebust、Stephen Smalley、Sorin Faibish、Nico Williams、David Blackもこれを承認するための最後のプッシュに貢献しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Christoph Hellwig was very helpful in getting the WRITE_SAME semantics to model more of what T10 was doing for WRITE SAME (10) [T10-SBC2]. And he led the push to get space reservations to more closely model the posix_fallocate() operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Christoph Hellwigは、WRITE_SAMEセマンティクスがT10がWRITE SAME（10）[T10-SBC2]に対して行っていたことをよりモデル化するのに非常に役立ちました。そして彼は、posix_fallocate()オペレーションをより厳密にモデル化するために、スペース予約を取得するようにプッシュしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Andy Adamson picked up the RPCSEC_GSSv3 work, which enabled both Labeled NFS and server-side copy to provide more secure options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Andy AdamsonはRPCSEC_GSSv3の作業を取り上げました。これにより、Labeled NFSとサーバー側のコピーの両方がより安全なオプションを提供できるようになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Christoph Hellwig provided the update to GETDEVICELIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Christoph HellwigがGETDEVICELISTのアップデートを提供しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jorge Mora provided a very detailed review and caught some important issues with the tables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jorge Moraは非常に詳細なレビューを提供し、テーブルに関するいくつかの重要な問題を捉えました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During the review process, Talia Reyes-Ortiz helped the sessions run smoothly. While many people contributed here and there, the core reviewers were Andy Adamson, Pranoop Erasani, Bruce Fields, Chuck Lever, Trond Myklebust, David Noveck, Peter Staubach, and Mike Kupfer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レビュープロセスの間、Talia Reyes-Ortizがセッションのスムーズな進行を助けました。あちこちで多くの人が寄稿しましたが、中心的なレビュー担当者は、Andy Adamson、Pranoop Erasani、Bruce Fields、Chuck Lever、Trond Myklebust、David Noveck、Peter Staubach、Mike Kupferでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Elwyn Davies was the General Area Reviewer for this document, and his insights as to the relationship of this document and both [RFC5661] and [RFC7530] were very much appreciated!
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Elwyn DaviesはこのドキュメントのGeneral Area Reviewerであり、このドキュメントと[RFC5661]と[RFC7530]の両方の関係に関する洞察は非常に高く評価されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thomas Haynes Primary Data, Inc. 4300 El Camino Real Ste 100 Los Altos, CA 94022 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thomas Haynes Primary Data、Inc. 4300 El Camino Real Ste 100 Los Altos、CA 94022アメリカ合衆国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1 408 215 1519
   Email: thomas.haynes@primarydata.com
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
