<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 2803 - Digest Values for DOM (DOMHASH) 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">2803</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc2803">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 2803 - Digest Values for DOM (DOMHASH) 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc2803">
            https://datatracker.ietf.org/doc/html/rfc2803
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 2803 - DOM（domhash）のダイジェスト値</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                         H. Maruyama
Request for Comments: 2803                                      K. Tamura
Category: Informational                                        N. Uramoto
                                                                      IBM
                                                               April 2000
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
Digest Values for DOM (DOMHASH)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
DOM（domhash）のダイジェスト値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2000). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）The Internet Society（2000）。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo defines a clear and unambiguous definition of digest (hash) values of the XML objects regardless of the surface string variation of XML. This definition can be used for XML digital signature as well efficient replication of XML objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、XMLの表面文字列変化に関係なく、XMLオブジェクトのダイジェスト（ハッシュ）値の明確で明確な定義を定義します。この定義は、XMLデジタル署名にもXMLオブジェクトの効率的な複製に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1. Introduction............................................2
   2. Digest Calculation......................................3
   2.1. Overview..............................................3
   2.2. Namespace Considerations..............................4
   2.3. Definition with Code Fragments........................5
   2.3.1. Text Nodes..........................................5
   2.3.2. Processing Instruction Nodes........................6
   2.3.3. Attr Nodes..........................................6
   2.3.4. Element Nodes.......................................7
   2.3.5. Document Nodes......................................9
   3. Discussion..............................................9
   4. Security Considerations.................................9
   References................................................10
   Authors&#39; Addresses........................................10
   Full Copyright Statement..................................11
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of this document is to give a clear and unambiguous definition of digest (hash) values of the XML objects [XML]. Two subtrees are considered identical if their hash values are the same, and different if their hash values are different.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの目的は、XMLオブジェクト[XML]のダイジェスト（ハッシュ）値の明確で明確な定義を提供することです。ハッシュ値が同じ場合、2つのサブツリーは同一であると見なされ、ハッシュ値が異なる場合は異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are at least two usage scenarios of DOMHASH. One is as a basis for digital signatures for XML. Digital signature algorithms normally require hashing a signed content before signing. DOMHASH provides a concrete definition of the hash value calculation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Domhashには少なくとも2つの使用シナリオがあります。1つは、XMLのデジタル署名の基礎としてです。デジタル署名アルゴリズムは通常、署名する前に署名されたコンテンツをハッシュする必要があります。Domhashは、ハッシュ値計算の具体的な定義を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The other is to use DOMHASH when synchronizing two DOM structures [DOM]. Suppose that a server program generates a DOM structure which is to be rendered by clients. If the server makes frequent small changes on a large DOM tree, it is desirable that only the modified parts are sent over to the client. A client can initiate a request by sending the root hash value of the structure in the cache memory. If it matches with the root hash value of the current server structure, nothing needs be sent. If not, then the server compares the client hash with the older versions in the server&#39;s cache. If it finds one that matches the client&#39;s version of the structure, then it locates differences with the current version by recursively comparing the hash values of each node. This way, the client can receive only an updated portion of a large structure without requesting the whole thing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もう1つは、2つのDOM構造[DOM]を同期するときにDomhashを使用することです。サーバープログラムがクライアントによってレンダリングされるDOM構造を生成すると仮定します。サーバーが大きなDOMツリーで頻繁に小さな変更を加える場合、修正された部品のみがクライアントに送信されることが望ましいです。クライアントは、キャッシュメモリ内の構造のルートハッシュ値を送信して、要求を開始できます。現在のサーバー構造のルートハッシュ値と一致する場合、送信する必要はありません。そうでない場合、サーバーはクライアントハッシュをサーバーのキャッシュ内の古いバージョンと比較します。クライアントの構造のバージョンに一致するものが見つかった場合、各ノードのハッシュ値を再帰的に比較することにより、現在のバージョンとの違いを見つけます。このようにして、クライアントは、全体を要求することなく、大きな構造の更新された部分のみを受信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One way of defining digest values is to take a surface string as the input for a digest algorithm. However, this approach has several drawbacks. The same internal DOM structure may be represented in may different ways as surface strings even if they strictly conform to the XML specification. Treatment of white spaces, selection of character encodings, entity references (i.e., use of ampersands), and so on have impact on the generation of a surface string. If the implementations of surface string generation are different, the hash values would be different, resulting in unvalidatable digital signatures and unsuccessful detection of identical DOM structures. Therefore, it is desirable that digest of DOM is defined in the DOM terms -- that is, as an unambiguous algorithm operating on a DOM tree. This is the approach we take in this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ダイジェスト値を定義する1つの方法は、Digestアルゴリズムの入力としてSurface Stringを使用することです。ただし、このアプローチにはいくつかの欠点があります。同じ内部DOM構造は、XML仕様に厳密に準拠していても、表面弦とは異なる方法で表される可能性があります。白い空間の処理、文字エンコーディングの選択、エンティティ参照（つまり、アンパサンドの使用）、その他は表面弦の生成に影響を与えます。Surface Stringの生成の実装が異なる場合、ハッシュ値は異なります。その結果、Validatable Digital Signaturesと同一のDOM構造の検出に失敗します。したがって、DOMのダイジェストはDOM用語で定義されること、つまり、DOMツリーで動作する明確なアルゴリズムとして定義されることが望ましいです。これは、この仕様で取るアプローチです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Introduction of namespace is another source of variation of surface string because different namespace prefixes can be used for representing the same namespace URI [URI]. In the following example, the namespace prefix &#34;edi&#34; is bound to the URI &#34;http://ecommerce.org/schema&#34; but this prefix can be arbitrary chosen without changing the logical contents as shown in the second example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前空間の導入は、同じ名前空間URI [URI]を表すために異なる名前空間プレフィックスを使用できるため、表面弦の別のバリエーションのソースです。次の例では、名前空間のプレフィックス「EDI」はURI &#34;http://ecommerce.org/schema&#34;にバインドされていますが、このプレフィックスは、2番目の例に示すように論理コンテンツを変更せずに任意に選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    &lt;?xml version=&#34;1.0&#34;?&gt;
    &lt;root xmlns:edi=&#39;http://ecommerce.org/schema&#39;&gt;
        &lt;edi:order&gt;
            :
        &lt;/edi:order&gt;
    &lt;/root&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    &lt;?xml version=&#34;1.0&#34;?&gt;
    &lt;root xmlns:ec=&#39;http://ecommerce.org/schema&#39;&gt;
        &lt;ec:order&gt;
            :
        &lt;/ec:order&gt;
    &lt;/root&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DOMHASH defined in this document is designed so that the choice of the namespace prefix does not affect the digest value. In the above example, both the &#34;root&#34; elements will get the same digest value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで定義されているドンハッシュは、名前空間プレフィックスの選択がダイジェスト値に影響しないように設計されています。上記の例では、両方の「ルート」要素が同じダイジェスト値を取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Digest-Calculation">
2. Digest Calculation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 消化計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-1--Overview">
2.1. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. 概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hash values are defined on the DOM type Node. We consider the following five node types that are used for representing a DOM document structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハッシュ値は、DOMタイプノードで定義されています。DOMドキュメント構造を表すために使用される次の5つのノードタイプを検討します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Text - ProcessingInstruction - Attr - Element - Document
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- テキスト-ProcessinStruction -attr-要素 - ドキュメント
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Comment nodes and Document Type Definitions (DTDs) do not participate in the digest value calculation. This is because DOM does not require a conformant processor to create data structures for these. DOMHASH is designed so that it can be computed with any XML processor conformant to the DOM or SAX [SAX] specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コメントノードとドキュメントタイプ定義（DTD）は、ダイジェスト値の計算に参加しません。これは、DOMがこれらのデータ構造を作成するためにコンフォーマントプロセッサを必要としないためです。Domhashは、DOMまたはSAX [SAX]仕様に適合したXMLプロセッサで計算できるように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nodes with the node type EntityReference must be expanded prior to digest calculation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードタイプのエンティティリファレンスを備えたノードは、消化計算の前に拡張する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The digest values are defined recursively on each level of the DOM tree so that only a relevant part needs to be recalculated when a small portion of the tree is changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ダイジェスト値は、DOMツリーの各レベルで再帰的に定義されるため、ツリーのごく一部を変更すると、関連する部分のみを再計算する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Below, we give the precise definitions of digest for these types. We describe the format of the data to be supplied to a hash algorithm using a figure and a simple description, followed by a Java code fragment using the DOM API and the JDK 1.1 Platform Core API only. Therefore, the semantics should be unambiguous.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下に、これらのタイプのダイジェストの正確な定義を示します。図と簡単な説明を使用して、ハッシュアルゴリズムに提供されるデータの形式を説明し、その後、Dom APIとJDK 1.1プラットフォームコアAPIのみを使用してJavaコードフラグメントを使用します。したがって、セマンティクスは明確でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As the rule of thumb, all strings are to be in UTF-16BE [UTF16]. If there is a sequence of text nodes without any element nodes in between, these text nodes are merged into one by concatenating them. A zero-length text node is always ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
経験則として、すべての弦はUTF-16BE [UTF16]にあることになります。その間に要素ノードがない一連のテキストノードがある場合、これらのテキストノードはそれらを連結することにより1つにマージされます。ゼロ長さのテキストノードは常に無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that validating and non-validating XML processors may generate different DOM trees from the same XML document, due to attribute normalization and default attributes. If DOMHASH is to be used for testing logical equivalence between two XML documents (as opposed to DOM trees), it may be necessary to normalize attributes and supply default attributes prior to DOMHASH calculation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XMLプロセッサの検証と非検証は、属性正規化とデフォルト属性により、同じXMLドキュメントから異なるDOMツリーを生成する場合があることに注意してください。Domhashが2つのXMLドキュメント間の論理等価性のテストに使用される場合（DOMツリーとは対照的に）、Domhash計算前に属性を正常化し、デフォルトの属性を提供する必要がある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some legacy character encodings (such as ISO-2022-JP) have certain ambiguity in translating into Unicode. This is again dependent on XML processors. Treatment of such processor dependencies is out of scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のレガシーキャラクターエンコーディング（ISO-2022-JPなど）は、Unicodeに翻訳する際に一定の曖昧さを持っています。これもXMLプロセッサに依存します。このようなプロセッサ依存関係の処理は、このドキュメントの範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-2--Namespace-Considerations">
2.2. Namespace Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. 名前空間の考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid the dependence on the namespace prefix, we use &#34;expanded names&#34; to do digest calculation. If an element name or an attribute name is qualified either by a explicit namespace prefix or by a default namespace, the name&#39;s LocalPart is prepended by the URI of the namespace (the namespace name as defined in the Namespace specification [NAM]) and a colon before digest calculation. In the following example, the default qualified name &#34;order&#34; is expanded into &#34;http://ecommerce.org/schema:order&#34; while the explicit qualified name &#34;book:title&#34; is expanded into &#34;urn:loc.gov:books:title&#34; before digest calculation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前空間プレフィックスへの依存を回避するために、「拡張名」を使用して計算を消化します。要素名または属性名が明示的な名前空間プレフィックスまたはデフォルトの名前空間のいずれかによって資格がある場合、名前のLocalPartが名前空間のURI（名前空間仕様[NAM]で定義されている名前空間名）とコロンによって準備されている場合消化の計算前。次の例では、デフォルトの資格のある名前「注文」が「http://ecommerce.org/schema：order」に拡張され、明示的な資格名「本：タイトル」が「urn：loc.gov：books：タイトル「ダイジェスト計算の前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   &lt;?xml version=&#34;1.0&#34;?&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;root xmlns=&#39;http://ecommerce.org/schema&#39; xmlns:book=&#39;urn:loc.gov:books&#39;&gt; &lt;order&gt; &lt;book:title&gt; ... &lt;/book:title&gt; : &lt;/order&gt; &lt;/root&gt; We define an expanded name (either for element or attribute) as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;root xmlns = &#39;http：//ecommerce.org/schema&#39; xmlns：book = &#39;urn：loc.gov：books&#39;&gt; &lt;order&gt; &lt;book：title&gt; ... &lt;/book&gt;：&lt;/注文&gt; &lt;/root&gt;次のように拡張名（要素または属性のいずれか）を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If a name is not qualified, the expanded name is the name itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
名前が適格でない場合、拡張された名前は名前自体です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If a name is qualified with the prefix &#34;xmlns&#34;, the expanded name is undefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
名前がプレフィックス「xmlns」で適格である場合、拡張された名前は未定義です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If a name is qualified either by default or by an explicit namespace prefix, the expanded name is URI bound to the namespace + &#34;:&#34; + LocalPart
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
名前がデフォルトまたは明示的な名前空間プレフィックスのいずれかによって資格がある場合、拡張された名前はuriが名前空間にバインドされています &#34;：&#34; localpart
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following example code, we assume that the getExpandedName() method (which returns the expanded name as defined above) is defined in both Element and Attr interfaces of DOM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例コードでは、getExpandedName（）メソッド（上記のように展開された名前を返す）は、DOMの要素とATTRインターフェイスの両方で定義されていると仮定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the digest values are not defined on namespace declarations. In other words, the digest value is not defined for an attribute when
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ダイジェスト値は名前空間宣言で定義されていないことに注意してください。言い換えれば、ダイジェスト値は属性に対して定義されていません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- the attribute name is &#34;xmlns&#34;, or - the namespace prefix is &#34;xmlns&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- 属性名は「xmlns」、または - 名前空間プレフィックスは「xmlns」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the above example, the two attributes which are namespace declarations do not have digest values and therefore will not participate in the calculation of the digest value of the &#34;root&#34; element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の例では、名前空間宣言である2つの属性には消化値がなく、したがって「ルート」要素のダイジェスト値の計算に参加しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3--Definition-with-Code-Fragments">
2.3. Definition with Code Fragments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. コードフラグメントを使用した定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The code fragments in the definitions below assume that they are in implementation classes of Node. Therefore, a methods call without an explicit object reference is for the Node itself. For example, getData() returns the text data of the current node if it is a Text node. The parameter digestAlgorithm is to be replaced by an identifier of the digest algorithm, such as &#34;MD5&#34; [MD5] and &#34;SHA-1&#34; [SHA].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の定義のコードフラグメントは、それらがノードの実装クラスにあると仮定しています。したがって、明示的なオブジェクト参照のないメソッドコールは、ノード自体のものです。たとえば、getData（）がテキストノードの場合、現在のノードのテキストデータを返します。パラメーター消化器gorthmは、「md5」[md5]や「sha-1」[sha]などのダイジェストアルゴリズムの識別子に置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The computation should begin with a four byte integer that represents the type of the node, such as TEXT_NODE or ELEMENT_NODE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
計算は、text_nodeやelement_nodeなどのノードのタイプを表す4バイト整数で開始する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-1--Text-Nodes">
2.3.1. Text Nodes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.1. テキストノード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The hash value of a Text node is computed on the four byte header followed by the UTF-16BE encoded text string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
テキストノードのハッシュ値は、4バイトヘッダーで計算され、その後UTF-16BEエンコードされたテキスト文字列が続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- TEXT_NODE (3) in 32 bit network-byte-ordered integer - Text data in UTF-16BE stream (variable length) public byte[] getDigest(String digestAlgorithm) { MessageDigest md = MessageDigest.getInstance(digestAlgorithm); md.update((byte)0); md.update((byte)0); md.update((byte)0); md.update((byte)3); md.update(getData().getBytes(&#34;UnicodeBigUnmarked&#34;)); return md.digest(); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- text_node（3）32ビットのネットワークバイト順序整数 -  UTF-16BEストリーム（可変長）パブリックバイトのテキストデータ[] getDigest（String DigestalGorithm）{Messaged Md = MessageDigest.getInstance（Digestalgorithm）;md.update（（byte）0）;md.update（（byte）0）;md.update（（byte）0）;md.update（（byte）3）;md.update（getData（）。getBytes（ &#34;UnicodeBigunmarked&#34;））;return md.digest（）;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here, MessageDigest is in the package java.security.*, one of the built-in packages of JDK 1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでは、MESSAGED GIGESTがパッケージJava.securityにあります。*、JDK 1.1の組み込みパッケージの1つです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-2--ProcessingInstruction-Nodes">
2.3.2. ProcessingInstruction Nodes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.2. インストラクションノードを処理します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A ProcessingInstruction (PI) node has two components: the target and the data. Accordingly, the hash is computed on the concatenation of both, separated by &#39;x0000&#39;. PI data is from the first non white space character after the target to the character immediately preceding the &#34;?&gt;&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Processinstruction（PI）ノードには、ターゲットとデータの2つのコンポーネントがあります。したがって、ハッシュは、「x0000」で分離された両方の連結時に計算されます。PIデータは、ターゲットの後の最初の非白色空間文字から、「？&gt;」の直前のキャラクターまでです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- PROCESSING_INSTRUCTION_NODE (7) in 32 bit network-byte-ordered integer - PI target in UTF-16BE stream (variable length) - 0x00 0x00 - PI data in UTF-16BE stream (variable length)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Processing_instruction_node（7）32ビットのネットワークバイト順序整数-PiターゲットUTF-16BEストリーム（変数長）-0X00 0x00-UTF-16BEストリームのPIデータ（変数長）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   public byte[] getDigest(String digestAlgorithm) {
       MessageDigest md = MessageDigest.getInstance(digestAlgorithm);
       md.update((byte)0);
       md.update((byte)0);
       md.update((byte)0);
       md.update((byte)7);
       md.update(getName().getBytes(&#34;UnicodeBigUnmarked&#34;));
       md.update((byte)0);
       md.update((byte)0);
       md.update(getData().getBytes(&#34;UnicodeBigUnmarked&#34;));
       return md.digest();
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-3--Attr-Nodes">
2.3.3. Attr Nodes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.3. attrノード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The digest value of Attr nodes are defined similarly to PI nodes, except that we need a separator between the expanded attribute name and the attribute value. The &#39;0x0000&#39; value in UTF-16BE is allowed nowhere in an XML document, so it can serve as an unambiguous separator. The expanded name must be used as the attribute name because it may be qualified. Note that if the attribute is a namespace declaration (either the attribute name is &#34;xmlns&#34; or its prefix is &#34;xmlns&#34;), the digest value is undefined and the getDigest() method should return null.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アットノードのダイジェスト値は、拡張属性名と属性値の間にセパレーターが必要であることを除いて、PIノードと同様に定義されます。UTF-16BEの「0x0000」値はXMLドキュメントではどこにも許可されていないため、明確なセパレーターとして機能します。拡張された名前は、資格がある可能性があるため、属性名として使用する必要があります。属性が名前空間宣言である場合（属性名が「xmlns」またはそのプレフィックスのいずれかのいずれかが「xmlns」）の場合、ダイジェスト値は未定義であり、getDigest（）メソッドはnullを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- ATTRIBUTE_NODE (2) in 32 bit network-byte-ordered integer - Expanded attribute name in UTF-16BE stream (variable length) - 0x00 0x00 - Attribute value in UTF-16BE stream (variable length)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 属性_Node（2）32ビットネットワークバイト順序整数 -  UTF-16BEストリームの拡張属性名（変数長） -  0x00 0x00- UTF-16BEストリームの属性値（変数長）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   public byte[] getDigest(String digestAlgorithm) {
       if (getNodeName().equals(&#34;xmlns&#34;)
               || getNodeName().startsWith(&#34;xmlns:&#34;))
           return null;
       MessageDigest md = MessageDigest.getInstance(digestAlgorithm);
       md.update((byte)0);
       md.update((byte)0);
       md.update((byte)0);
       md.update((byte)2);
       md.update(getExpandedName().getBytes(&#34;UnicodeBigUnmarked&#34;));
       md.update((byte)0);
       md.update((byte)0);
       md.update(getValue().getBytes(&#34;UnicodeBigUnmarked&#34;));
       return md.digest();
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-4--Element-Nodes">
2.3.4. Element Nodes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.4. 要素ノード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Element nodes are the most complex because they consist of other nodes recursively. Hash values of these component nodes are used to calculate the node&#39;s digest so that we can save computation when the structure is partially changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要素ノードは、再帰的に他のノードで構成されているため、最も複雑です。これらのコンポーネントノードのハッシュ値は、構造が部分的に変更されたときに計算を保存できるように、ノードのダイジェストを計算するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, all the attributes except for namespace declarations must be collected. This list is sorted lexicographically by the expanded attribute names (based on Unicode character code points). When no surrogate characters are involved, this is the same as sorting in ascending order in terms of the UTF-16BE encoded expanded attribute names, using the string comparison operator String.compareTo() in Java.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まず、名前空間宣言を除くすべての属性を収集する必要があります。このリストは、拡張された属性名（Unicode文字コードポイントに基づいて）によって辞書化されています。代理文字が関与していない場合、これは、Javaの文字列比較オペレーターString.comPareto（）を使用して、UTF-16BEエンコードされた拡張属性名の観点から昇順でソートすることと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- ELEMENT_NODE (1) in 32 bit network-byte-ordered integer - Expanded element name in UTF-16BE stream (variable length) - 0x00 0x00 - A number of non-namespace-declaration attributes in 32 bit network-byte-ordered unsigned integer - Sequence of digest values of non-namespace-declaration attributes, sorted lexicographically by expanded attribute names - A number of child nodes (except for Comment nodes) in 32bit
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- element_node（1）32ビットのネットワークバイト順序整数 -  UTF-16BEストリームの拡張要素名（変数長）-0x000x00- 32ビットネットワークバイト順序付けられていない整数の属性の多くの非ネームズスペースデクラレーション属性 - 拡張された属性名によって辞書化された非namespace-declaration属性のダイジェスト値のシーケンス -  32ビットの多くの子ノード（コメントノードを除く）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 network-byte-ordered unsigned integer - Sequence of digest values of each child node except for Comment nodes (variable length) (A sequence of child texts is merged to one text. A zero-length text and Comment nodes are not counted as child)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークバイト命令の符号なし整数 - コメントノード（可変長）を除く各子ノードのダイジェスト値のシーケンス（子テキストのシーケンスは1つのテキストにマージされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   public byte[] getDigest(String digestAlgorithm) {
       MessageDigest md = MessageDigest.getInstance(digestAlgorithm);
       ByteArrayOutputStream baos = new ByteArrayOutputStream();
       DataOutputStream dos = new DataOutputStream(baos);
       dos.writeInt(ELEMENT_NODE);//This is stored in network byte order
       dos.write(getExpandedName().getBytes(&#34;UnicodeBigUnmarked&#34;));
       dos.write((byte)0);
       dos.write((byte)0);
       // Collect all attributes except for namespace declarations
       NamedNodeMap nnm = this.getAttributes();
       int len = nnm.getLength()
               // Find &#34;xmlns&#34; or &#34;xmlns:foo&#34; in nnm and omit it.
       ...
       dos.writeInt(len);    // This is sorted in the network byte order
       // Sort attributes lexicographically by expanded attribute
       // names.
       ...
       // Assume that `Attr[] aattr&#39; has sorted Attribute instances.
       for (int i = 0;  i &lt; len;  i ++)
           dos.write(aattr[i].getDigest(digestAlgorithm));
       Node n = this.getFirstChild();
       // Assume that adjoining Texts are merged,
       // there is  no 0-length Text, and
       // comment nodes are removed.
       len = this.getChildNodes().getLength();
       dos.writeInt(len);    // This is stored in the network byte order
       while (n != null) {
           dos.write(n.getDigest(digestAlgorithm));
           n = n.getNextSibling();
       }
       dos.close();
       md.update(baos.toByteArray());
       return md.digest();
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2-3-5--Document-Nodes">
2.3.5. Document Nodes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.5. ドキュメントノード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Document node may have PI nodes before and after the root Element node. The digest value of a Document node is computed based on the sequence of the digest values of the pre-root PI nodes, the root Element node, and the post-root PI nodes in this order. Comment nodes and DocumentType nodes, if any, are ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ドキュメントノードには、ルート要素ノードの前後のPIノードがある場合があります。ドキュメントノードのダイジェスト値は、この順序でのプレルートPIノード、ルート要素ノード、および根ポストPIノードのダイジェスト値のシーケンスに基づいて計算されます。コメントノードとdocumentTypeノードがある場合は無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- DOCUMENT_NODE (9) in 32 bit network-byte-ordered integer - A number of child nodes (except for Comment and DocumentType nodes) in 32bit network-byte-ordered unsigned integer - Sequence of digest values of each child node except for Comment and DocumentType nodes (variable length)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- document_node（9）32ビットネットワークバイト順序整数 -  32ビットのネットワークバイトバイト順序符号なし整数の多くの子ノード（コメントとdocumentTypeノードを除く） - コメントとdocumentTypeを除く各子供ノードのダイジェスト値のシーケンスノード（変数長）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     public byte[] getDigest(String digestAlgorithm) {
         MessageDigest md = MessageDigest.getInstance(digestAlgorithm);
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         DataOutputStream dos = new DataOutputStream(baos);
         dos.writeInt(DOCUMENT_NODE);//This is stored in network byte order
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         // Assume that Comment and DocumentType nodes are removed and this
         // node has only an Element node and PI nodes.
         len = this.getChildNodes().getLength();
         dos.writeInt(len);    // This is stored in the network byte order
         Node n = this.getFirstChild();
         while (n != null) {
             dos.write(n.getDigest(digestAlgorithm));
             n = n.getNextSibling();
         }
         dos.close();
         md.update(baos.toByteArray());
         return md.digest();
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Discussion">
3. Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 考察
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
The definition described above can be efficiently implemented with any XML processor that is conformant to either DOM and SAX specification. Reference implementations are available on request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
上記の定義は、DOMおよびSAX仕様のいずれかに適合するXMLプロセッサで効率的に実装できます。リクエストに応じて参照実装が利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Security-Considerations">
4. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
DOMHASH is expected to be used as the basis for digital signatures and other security and integrity uses. It&#39;s appropriateness for such uses depends on the security of the hash algorithm used and inclusion of the fundamental characteristics it is desired to check in parts of the DOM model incorporated in the digest by DOMHASH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Domhashは、デジタル署名やその他のセキュリティおよび整合性の使用の基礎として使用されることが期待されています。そのような用途に対する適切性は、使用されたハッシュアルゴリズムのセキュリティと、Domhashによってダイジェストに組み込まれたDOMモデルの一部をチェックインすることが望まれる基本特性の包含に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
参考文献
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DOM] &#34;Document Object Model (DOM), Level 1 Specification&#34;, October 1998, http://www.w3.org/TR/REC-DOM-Level-1/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DOM]「ドキュメントオブジェクトモデル（DOM）、レベル1仕様」、1998年10月、http：//www.w3.org/tr/rec-dom-level-1/
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MD5] Rivest, R., &#34;The MD5 Message-Digest Algorithm&#34;, RFC 1321, April 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MD5] Rivest、R。、「The MD5 Message-Digest Algorithm」、RFC 1321、1992年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NAM] Tim Bray, Dave Hollander, Andrew Layman, &#34;Namespaces in XML&#34;, http://www.w3.org/TR/1999/REC-xml-names-19990114.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[nam]ティム・ブレイ、デイブ・ホランダー、アンドリュー・レイマン、「XMLの名前空間」、http：//www.w3.org/tr/1999/rec-xml-names-1990114。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SAX] David Megginson, &#34;SAX 1.0: The Simple API for XML&#34;, http://www.megginson.com/SAX/, May 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Sax] David Megginson、「Sax 1.0：XMLのシンプルなAPI」、http：//www.megginson.com/sax/、1998年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SHA] (US) National Institute of Standards and Technology, &#34;Federal Information Processing Standards Publication 180-1: Secure Hash Standard&#34;, 17 April 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SHA]（米国）国立標準技術研究所、「連邦情報処理基準出版180-1：Secure Hash Standard」、1995年4月17日。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[URI] Berners-Lee, T., Fielding, R. and L. Masinter, &#34;Uniform Resource Identifiers (URI): Generic Syntax&#34;, RFC 2396, August 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[URI] Berners-Lee、T.、Fielding、R。and L. Masinter、「ユニフォームリソース識別子（URI）：汎用構文」、RFC 2396、1998年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UTF16] Hoffman, P., Yergeau, F., &#34;UTF-16, an encoding of ISO 10646&#34;, RFC 2781, February 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UTF16] Hoffman、P.、Yergeau、F。、「UTF-16、ISO 10646のエンコーディング」、RFC 2781、2000年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XML] Tim Bray, Jean Paoli, C. M. Sperber-McQueen, &#34;Extensible Markup Language (XML) 1.0&#34;, http://www.w3.org/TR/1998/REC-xml-19980210
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XML]ティム・ブレイ、ジャン・パオリ、C。M。スペルバー・マッキーティーン、「拡張可能なマークアップ言語（XML）1.0」、http：//www.w3.org/tr/1998/rec-xml-1998021010
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hiroshi Maruyama, IBM Research, Tokyo Research Laboratory
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Maruyama hiroshi、IBM Research、東京研究研究所
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: maruyama@jp.ibm.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kent Tamura, IBM Research, Tokyo Research Laboratory
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kent Tamura、IBM Research、Tokyo Research Laboratory
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: kent@trl.ibm.co.jp
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Naohiko Uramoto, IBM Research, Tokyo Research Laboratory
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Naohiko Uramoto、IBM Research、東京研究研究所
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   EMail: uramoto@jp.ibm.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2000). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）The Internet Society（2000）。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントと翻訳は他の人にコピーされて提供される場合があります。また、それについてコメントまたは説明する派生作品、またはその実装を支援することは、いかなる種類の制限なしに、準備、コピー、公開、および部分的に配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準プロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgment
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
了承
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFCエディター機能の資金は現在、インターネット協会によって提供されています。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
