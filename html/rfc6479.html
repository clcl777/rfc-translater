<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 6479 - IPsec Anti-Replay Algorithm without Bit Shifting 日本語訳</title>
  <meta name="description" content="要約：RFC 6479は、ビットシフトを使用せずにIPsecのアンチリプレイアルゴリズムを実装する方法を提案しています。
目的：このRFCの目的は、IPsecのアンチリプレイ機能を改善し、ビットシフトを使用しない効率的なアルゴリズムを提供することです。">
  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">6479</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc6479">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 6479 - IPsec Anti-Replay Algorithm without Bit Shifting 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc6479">
            https://datatracker.ietf.org/doc/html/rfc6479
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 6479 - IPSECアンチレプレイアルゴリズムは、少しシフトせずに</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] 要約：RFC 6479は、ビットシフトを使用せずにIPsecのアンチリプレイアルゴリズムを実装する方法を提案しています。
目的：このRFCの目的は、IPsecのアンチリプレイ機能を改善し、ビットシフトを使用しない効率的なアルゴリズムを提供することです。</p>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Independent Submission                                          X. Zhang
Request for Comments: 6479                                       T. Tsou
Category: Informational                           Futurewei Technologies
ISSN: 2070-1721                                             January 2012
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
IPsec Anti-Replay Algorithm without Bit Shifting
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
IPSECアンチレプレイアルゴリズムは、少しシフトせずに
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document presents an alternate method to do the anti-replay checks and updates for IP Authentication Header (AH) and Encapsulating Security Protocol (ESP). The method defined in this document obviates the need for bit shifting and it reduces the number of times an anti-replay window is adjusted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、IP認証ヘッダー（AH）およびセキュリティプロトコル（ESP）のカプセル化アンチレプレイチェックと更新を行う代替方法を提示します。このドキュメントで定義されているメソッドは、ビットシフトの必要性を取り除き、アンチレプレイウィンドウが調整される回数を削減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for informational purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネット標準の追跡仕様ではありません。情報目的で公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、他のRFCストリームとは無関係に、RFCシリーズへの貢献です。RFCエディターは、このドキュメントの裁量でこのドキュメントを公開することを選択しており、実装または展開に対する価値について声明を発表しません。RFCエディターによって公開が承認されたドキュメントは、インターネット標準のレベルの候補者ではありません。RFC 5741のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6479.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、http：//www.rfc-editor.org/info/rfc6479で取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2012 IETF Trustおよび文書著者として特定された人。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、BCP 78およびIETFドキュメント（http://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................2
   2. Description of New Anti-Replay Algorithm ........................3
   3. Example of New Anti-Replay Algorithm ............................5
   4. Security Considerations .........................................9
   5. Normative References ............................................9
   6. Acknowledgements ................................................9
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;IP Authentication Header&#34; [RFC4302] and &#34;IP Encapsulating Security Payload (ESP)&#34; [RFC4303] define an anti-replay service that employs a sliding window mechanism. The mechanism, when enabled by a receiver, uses an anti-replay window of size W. This window limits how far out of order a packet can be, relative to the packet with the highest sequence number that has been authenticated so far. The window can be represented by a range [WB, WT], where WB=WT-W+1. The whole anti-replay window can be thought of as a string of bits. The value of each bit indicates whether or not a packet with that sequence number has been received and authenticated, so that the replay packet can be detected and rejected. If the packet is received, the receiver gets the sequence number S in the packet. If S is inside window (S&lt;=WT and S&gt;=WB), then the receiver checks the corresponding bit (location is S-WB) in the window to see if this S has already been seen. If S&lt;WB, the packet is dropped. If S&gt;WT and is validated, the window is advanced by (S-WT) bits. The new window becomes [WB+S-WT, S]. The new bits in this new window are set to indicate that no packets with those sequence numbers have been received. The typical implementation (for example, the integrity algorithm [RFC4302]) is done by shifting (S-WT) bits. In normal cases, the packets arrive in order, which results in continuous updates and bit-shifting operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「IP認証ヘッダー」[RFC4302]および「IPカプセル化セキュリティペイロード（ESP）」[RFC4303]は、スライディングウィンドウメカニズムを使用するアンチレプレイサービスを定義します。メカニズムは、受信機によって有効になった場合、サイズWのアンチレプレイウィンドウを使用します。このウィンドウは、パケットがどれだけ順序付けられているかを制限します。ウィンドウは、範囲[WB、WT]で表すことができます。ここで、WB = WT-W 1.アンチレプレイウィンドウ全体は、ビットの文字列と考えることができます。各ビットの値は、そのシーケンス番号を含むパケットが受信および認証されたかどうかを示し、リプレイパケットを検出して拒否できるようにします。パケットが受信された場合、受信機はパケットにシーケンス番号sを取得します。 sがウィンドウ（s &lt;= wtおよびs&gt; = wb）内にある場合、レシーバーはウィンドウの対応するビット（場所はs-wb）をチェックして、このsが既に見られているかどうかを確認します。 s &lt;wbの場合、パケットが削除されます。 s&gt; wtで検証されている場合、ウィンドウは（s-wt）ビットで[進行します。新しいウィンドウは[wb s-wt、s]になります。この新しいウィンドウの新しいビットは、これらのシーケンス番号を含むパケットが受信されていないことを示すように設定されています。典型的な実装（たとえば、整合性アルゴリズム[RFC4302]）は、（S-WT）ビットをシフトすることによって行われます。通常の場合、パケットが順番に到着するため、継続的な更新とビットシフト操作が行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4302] and [RFC4303] define minimum window sizes of 32 and 64. But no requirement is established for minimum or recommended window sizes beyond 64 packets. The window size needs to be based on reasonable expectations for packet re-ordering. For a high-end, multi-core network processor with multiple crypto cores, a window size bigger than 64 or 128 is needed due to the varied IPsec processing latency caused by different cores. In such a case, the window sliding is tremendously costly even with hardware acceleration to do the bit shifting. This document describes an alternate method to avoid bit shifting. It only discusses the anti-replay processing at the receiving side. The processing is always safe and has no interoperability effects. Even with a window size bigger than the usual 32- or 64-bit window, no interoperability issues are caused.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4302]および[RFC4303]は、32と64の最小ウィンドウサイズを定義します。ただし、64パケットを超える最小または推奨ウィンドウサイズには要件は確立されていません。ウィンドウサイズは、パケットの再注文に対する合理的な期待に基づいている必要があります。複数の暗号コアを備えたハイエンドのマルチコアネットワークプロセッサの場合、さまざまなコアによって引き起こされるさまざまなIPSEC処理レイテンシのために、64または128を超えるウィンドウサイズが必要です。そのような場合、ハードウェアの加速があり、ビットシフトを行うことができても、ウィンドウのスライドが非常にコストがかかります。このドキュメントでは、ビットシフトを避けるための代替方法について説明します。受信側でのアンチレプレイ処理についてのみ説明します。処理は常に安全であり、相互運用性の効果はありません。通常の32ビットまたは64ビットのウィンドウよりも大きいウィンドウサイズがあっても、相互運用性の問題は発生しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any node employing practices that potentially cause reordering beyond the usual 32- or 64-bit window may lead to interoperability or performance problems, however. For instance, if either the sending node or routers along the path cause significant re-ordering, this can lead to inability of the receiving IPsec endpoint to process the packets, as many current implementations do not support the extensions defined in this memo. Similarly, such reordering can cause significant problems for transport and upper-layer protocols, and is generally best avoided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、通常の32ビットまたは64ビットウィンドウを超えて並べ替える可能性のあるプラクティスを使用するノードは、相互運用性またはパフォーマンスの問題につながる可能性があります。たとえば、パスに沿った送信ノードまたはルーターのいずれかが重要な再注文を引き起こす場合、これにより、IPSecエンドポイントが受信されないことがパケットを処理できなくなる可能性があります。同様に、このような並べ替えは、輸送および上層層プロトコルに重大な問題を引き起こす可能性があり、一般的に回避するのが最善です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Description-of-the-New-Anti-Replay-Algorithm">
2. Description of the New Anti-Replay Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 新しい反レプレイアルゴリズムの説明
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here we present an easy way to update the window index only, while also reducing the number window updates. The basic idea is illustrated in the following figures. Suppose that we configure the window size W, which consists of M-1 blocks, where M is a power of two (2). Each block contains N bits, where N is also a power of two (2). It can be a byte (8 bit) or word (32 bit), or multiple words. The supported sliding window size is (M-1)*N. However, it covers up M blocks (four blocks as shown in Figure 1). All these M blocks are circulated and become a ring of blocks, each with N bits. In this way, the supported sliding window (M-1 blocks) is always a subset window of the actual window when the window slides.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでは、ウィンドウインデックスのみを簡単に更新する簡単な方法を提示しながら、数字のウィンドウの更新も削減します。基本的なアイデアは、次の図に示されています。M-1ブロックで構成されるウィンドウサイズwを構成すると仮定します。ここで、mは2つのパワーです（2）。各ブロックにはnビットが含まれています。ここで、nは2つのパワーです（2）。バイト（8ビット）または単語（32ビット）、または複数の単語にすることができます。サポートされているスライディングウィンドウサイズは（M-1）*nです。ただし、Mブロックをカバーします（図1に示すように4つのブロック）。これらすべてのMブロックは循環し、それぞれがNビットのあるブロックのリングになります。このようにして、サポートされているスライディングウィンドウ（M-1ブロック）は、ウィンドウがスライドするときの実際のウィンドウの常にサブセットウィンドウです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initially, the actual window is defined by a low- and high-end index [WB, WT], as illustrated in Figure 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初に、実際のウィンドウは、図1に示すように、低エンドインデックス[WB、WT]によって定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +--------+--------+--------+--------+
      |xxxxxxcc|cccccccc|cccccccc|ccccc100|
      +--------+--------+--------+--------+
             ^                         ^
             |                         |
             WB                        WT
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 1: The sliding window [WB, WT] in which WT is the last validated sequence number, and the supported window size W is WT-WB+1. (x=don&#39;t care bit, c=check bit)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
図1：WTが最後に検証されたシーケンス番号であり、サポートされているウィンドウサイズwがWT-WB 1であるスライドウィンドウ[WB、WT]は（x =気にしないでください、C =チェックビット）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If we receive a packet with the sequence number (S) greater than WT, we slide the window. But we only change the window index by adding the difference (S-WT) to both WT and WB (WB is automatically changed as the window size is fixed). So, S becomes the largest sequence number of the received packets. Figure 2 shows the case that the packet with sequence number S=WT+1 is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WTよりも大きいシーケンス番号が付いたパケットを受け取った場合、ウィンドウをスライドさせます。ただし、WTとWBの両方に差（S-WT）を追加することにより、ウィンドウインデックスを変更するだけです（ウィンドウサイズが固定されているため、WBは自動的に変更されます）。したがって、Sは受信したパケットの最大シーケンス番号になります。図2は、シーケンス番号s = wt 1のパケットが受信された場合を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+--------+--------+--------+
   |xxxxxxcc|cccccccc|cccccccc|ccccc110|
   +--------+--------+--------+--------+
           ^                         ^
           |                         |
           WB                        WT
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Figure 2: The sliding window [WB, WT] after S=WT+1
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If S is in a different block from where WT is, we have to initialize all bit values in the blocks to 0 without bit shifting. If S passes several blocks, we have to initialize several blocks instead of only one block. Figure 3 shows that the sequence number already passed the block boundary. Immediately after the update, all the check bits should be 0 in the block where WT resides.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sがWTがある場所とは異なるブロックにある場合、ビットシフトなしでブロック内のすべてのビット値を0に初期化する必要があります。Sが複数のブロックを通過する場合、1つのブロックではなく複数のブロックを初期化する必要があります。図3は、シーケンス番号が既にブロック境界を通過していることを示しています。更新直後、すべてのチェックビットは、WTが存在するブロック内で0にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+--------+--------+--------+
   |ccc10000|xxxxcccc|cccccccc|cccccccc|
   +--------+--------+--------+--------+
       ^         ^
       |         |
       WT        WB
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 3: The sliding window [WB, WT] after S passes the boundary
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
図3：Sが境界を通過した後のスライドウィンドウ[WB、WT]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the update, the new window still covers the configured window. This means the configured sub-window also slides, conforming to the sliding window protocol. The actual effect is somewhat like shifting the block. In this way, the bit shifting is deemed unnecessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
更新後、新しいウィンドウはまだ構成されたウィンドウをカバーします。これは、設定されたサブウィンドウもスライドして、スライドウィンドウプロトコルに準拠していることを意味します。実際の効果は、ブロックをシフトするようなものです。このようにして、ビットシフトは不要であるとみなされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is also easier and much faster to check the window with the sequence number because the sequence number check does not depend on the lowest index WB. Instead, it only depends on the sequence number of the received packet. If we receive a sequence number S, the bit location is the lowest several bits of the sequence number, which only depends on the block size (N). The block index is several bits before the location bits, which only depends on the window size (M).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、シーケンス番号チェックが最も低いインデックスWBに依存しないため、シーケンス番号でウィンドウをチェックする方が簡単かつ高速です。代わりに、受信したパケットのシーケンス番号のみに依存します。シーケンス番号sを受信すると、ビットの位置は、ブロックサイズ（n）にのみ依存するシーケンス番号の最低数ビットです。ブロックインデックスは、ロケーションビットの前にいくつかのビットであり、ウィンドウサイズ（m）にのみ依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We do not specify how many redundancy bits are needed, except that it should be a power of two (2) for computation efficiency. If the microprocessor is 32 bits, 32 might be a better choice while 64 might be better for 64-bit microprocessor. For a microprocessor with cache support, one cache line is also a good choice. It also depends on the size of the sliding window. If we have N redundancy bits (for example, 32 bits in the above description), we only need 1/N times update of blocks, comparing to the bit-shifting algorithm in [RFC4302].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
計算効率のために2つのパワーである必要があることを除いて、冗長性ビットの数を指定しません。マイクロプロセッサが32ビットの場合、32がより良い選択かもしれませんが、64ビットマイクロプロセッサでは64の方が良いかもしれません。キャッシュサポートを備えたマイクロプロセッサの場合、1つのキャッシュラインも良い選択です。また、スライドウィンドウのサイズに依存します。n冗長ビットがある場合（たとえば、上記の説明では32ビット）、[RFC4302]のビットシフトアルゴリズムと比較して、ブロックの1/n倍の更新のみが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cost of this method is extra byte(s) being used as a redundant window. The cost will be minimal if the window size is big enough. Actually, the extra redundant bits are not completely wasted. We could reuse the unused bits in the block where index WB resides, i.e., the supported window size could be (M-1)*N, plus the unused bits in the last block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この方法のコストは、冗長なウィンドウとして使用される追加のバイトです。ウィンドウサイズが十分に大きい場合、コストは最小限に抑えられます。実際、余分な冗長ビットは完全に無駄になっていません。インデックスWBが存在するブロック内の未使用のビット、つまり、サポートされているウィンドウサイズは（M-1）*nに加えて、最後のブロックの未使用のビットである可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Example-of-the-New-Anti-Replay-Algorithm">
3. Example of the New Anti-Replay Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 新しい反レプレイアルゴリズムの例
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here is the example code to implement the algorithm of anti-replay checks and updates, which is described in the previous sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、前のセクションで説明する反レプレイチェックと更新のアルゴリズムを実装するためのコードの例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
&lt;code begins&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/**
 * Copyright (c) 2012 IETF Trust and the persons identified as
 * authors of the code. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, is permitted pursuant to, and subject to the license
 * terms contained in, the Simplified BSD License set forth in Section
 * 4.c of the IETF Trust&#39;s Legal Provisions Relating to IETF Documents
 * (http://trustee.ietf.org/license-info).
 *
 */
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/**
 * In this algorithm, the hidden window size must be a power of two,
 * for example, 1024 bits.  The redundant bits must also be a power of
 * two, for example 32 bits.  Thus, the supported anti-replay window
 * size is the hidden window size minus the redundant bits.  It is 992
 * in this example.  The size of the integer depends on microprocessor
 * architecture.  In this example, we assume that the software runs on
 * a 32-bit microprocessor.  So the size of the integer is 32.  In order
 * to convert the bitmap into an array of integers, the total number of
 * integers is the hidden window size divided by the size of the
 * integer.
 *
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
* struct ipsec_sa contains the window and window related parameters, * such as the window size and the last acknowledged sequence number. * * all the value of macro can be changed, but must follow the rule * defined in the algorithm. */
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
* struct IPSEC_SAには、ウィンドウサイズや最後に確認されたシーケンス番号など、ウィンドウ関連パラメーターとウィンドウ関連パラメーターが含まれています。* *マクロのすべての値は変更できますが、アルゴリズムで定義されているルール *に従う必要があります。*/
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#define SIZE_OF_INTEGER       32 /** 32-bit microprocessor */
#define BITMAP_LEN            (1024/ SIZE_OF_INTEGER)
                                /** in terms of the 32-bit integer */
#define BITMAP_INDEX_MASK     (IPSEC_BITMAP_LEN-1)
#define REDUNDANT_BIT_SHIFTS  5
#define REDUNDANT_BITS        (1&lt;&lt;REDUNDANT_BIT_SHIFTS)
#define BITMAP_LOC_MASK       (IPSEC_REDUNDANT_BITS-1)
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
int ipsec_check_replay_window (struct ipsec_sa *ipsa, uint32_t sequence_number) { int bit_location; int index;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
int ipsec_check_replay_window（struct ipsec_sa *ipsa、uint32_t sequence_number）{int bit_location;intインデックス;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /**
     * replay shut off
     */
    if (ipsa-&gt;replaywin_size == 0) {
        return 1;
    }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /**
     * first == 0 or wrapped
     */
    if (sequence_number == 0) {
        return 0;
    }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /**
     * first check if the sequence number is in the range
     */
    if (sequence_number&gt;ipsa-&gt;replaywin_lastseq) {
        return 1;  /** larger is always good */
    }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /**
     * The packet is too old and out of the window
     */
    if ((sequence_number + ipsa-&gt;replaywin_size) &lt;
        ipsa-&gt;replaywin_lastseq) {
          return 0;
    }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /**
     * The sequence is inside the sliding window
     * now check the bit in the bitmap
     * bit location only depends on the sequence number
     */
    bit_location = sequence_number&amp;BITMAP_LOC_MASK;
    index = (sequence_number&gt;&gt;REDUNDANT_BIT_SHIFTS)&amp;BITMAP_INDEX_MASK;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /*
     * this packet has already been received
     */
    if (ipsa-&gt;replaywin_bitmap[index]&amp;(1&lt;&lt;bit_location)) {
        return 0;
    }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 return 1; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
1を返します。}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
int
ipsec_update_replay_window (struct ipsec_sa *ipsa,
                            uint32_t sequence_number)
{
    int bit_location;
    int index, index_cur, id;
    int diff;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    if (ipsa-&gt;replaywin_size == 0) {  /** replay shut off */
        return 1;
    }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    if (sequence_number == 0) {
        return 0;     /** first == 0 or wrapped */
    }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /**
     * the packet is too old, no need to update
     */
    if ((ipsa-&gt;replaywin_size + sequence_number) &lt;
        ipsa-&gt;replaywin_lastseq) {
           return 0;
    }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /**
     * now update the bit
     */
    index = (sequence_number&gt;&gt;REDUNDANT_BIT_SHIFTS);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/**
 * first check if the sequence number is in the range
 */
if (sequence_number&gt;ipsa-&gt;replaywin_lastseq) {
    index_cur = ipsa-&gt;replaywin_lastseq&gt;&gt;REDUNDANT_BIT_SHIFTS;
    diff = index - index_cur;
    if (diff &gt; BITMAP_LEN) {  /* something unusual in this case */
        diff = BITMAP_LEN;
    }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (id = 0; id &lt; diff; ++id) {
        ipsa-&gt;replaywin_bitmap[(id+index_cur+1)&amp;BITMAP_INDEX_MASK]
            = 0;
    }
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    ipsa-&gt;replaywin_lastseq = sequence_number;
}
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    index &amp;= BITMAP_INDEX_MASK;
    bit_location = sequence_number&amp;BITMAP_LOC_MASK;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* this packet has already been received */
    if (ipsa-&gt;replaywin_bitmap[index]&amp;(1&lt;&lt;bit_location)) {
    return 0;
}
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    ipsa-&gt;replaywin_bitmap[index] |= (1&lt;&lt;bit_location);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 return 1; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
1を返します。}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
&lt;コードエンド&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Security-Considerations">
4. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. セキュリティに関する考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
This document does not change [RFC4302] or [RFC4303]. It provides an alternate method for anti-replay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
このドキュメントは[RFC4302]または[RFC4303]を変更しません。アンチレプレイの代替方法を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Acknowledgements">
5. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 謝辞
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
The idea in this document came from the software design on one high-performance multi-core network processor. The new network processor core integrates a dozen of crypto core in a distributed way, which makes hardware anti-replay service impossible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
このドキュメントのアイデアは、1つの高性能マルチコアネットワークプロセッサのソフトウェア設計から来ました。新しいネットワークプロセッサコアは、多数の暗号コアを分散方法で統合し、ハードウェアアンチレプレイサービスを不可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Normative-References">
6. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 引用文献
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4302] Kent, S., &#34;IP Authentication Header&#34;, RFC 4302, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4302] Kent、S。、「IP認証ヘッダー」、RFC 4302、2005年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4303] Kent, S., &#34;IP Encapsulating Security Payload (ESP)&#34;, RFC 4303, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4303] Kent、S。、「セキュリティペイロードのカプセル化（ESP）」、RFC 4303、2005年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Xiangyang Zhang Futurewei Technologies 2330 Central Expressway Santa Clara, California 95051 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Xiangyang Zhang FutureWei Technologies 2330 Central Expressway Santa Clara、カリフォルニア95051 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1-408-330-4545
   EMail: xiangyang.zhang@huawei.com
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tina Tsou (Ting Zou) Futurewei Technologies 2330 Central Expressway Santa Clara, California 95051 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tina Tsou（Ting Zou）FutureWei Technologies 2330 Central Expressway Santa Clara、カリフォルニア95051 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Phone: +1-408-859-4996
   EMail: tena@huawei.com
        </pre>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
