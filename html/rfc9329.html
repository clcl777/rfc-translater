<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 9329 - TCP Encapsulation of Internet Key Exchange Protocol (IKE) and IPsec Packets 日本語訳</title>
  <meta name="description" content="RFC 9329 は、UDPでのIKEネゴシエーションがブロックされるネットワークミドルボックスを横断するために、IKEおよびIPsecパケットをTCP接続経由で転送する方法を説明しています。TCPカプセル化は、UDPでのIKEネゴシエーションができない場合の代替オプションとして使用されることを目的としています。">

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">9329</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc9329">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 9329 - TCP Encapsulation of Internet Key Exchange Protocol (IKE) and IPsec Packets 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc9329">
            https://datatracker.ietf.org/doc/html/rfc9329
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 9329 - インターネットキーエクスチェンジプロトコル（IKE）とIPSECパケットのTCPカプセル化</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] RFC 9329 は、UDPでのIKEネゴシエーションがブロックされるネットワークミドルボックスを横断するために、IKEおよびIPsecパケットをTCP接続経由で転送する方法を説明しています。TCPカプセル化は、UDPでのIKEネゴシエーションができない場合の代替オプションとして使用されることを目的としています。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                          T. Pauly
Request for Comments: 9329                                    Apple Inc.
Obsoletes: 8229                                               V. Smyslov
Category: Standards Track                                     ELVIS-PLUS
ISSN: 2070-1721                                            November 2022
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
TCP Encapsulation of Internet Key Exchange Protocol (IKE) and IPsec Packets
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
インターネットキーエクスチェンジプロトコル（IKE）とIPSECパケットのTCPカプセル化
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes a method to transport Internet Key Exchange Protocol (IKE) and IPsec packets over a TCP connection for traversing network middleboxes that may block IKE negotiation over UDP. This method, referred to as &#34;TCP encapsulation&#34;, involves sending both IKE packets for Security Association (SA) establishment and Encapsulating Security Payload (ESP) packets over a TCP connection. This method is intended to be used as a fallback option when IKE cannot be negotiated over UDP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、UDPを介したIKEネゴシエーションをブロックする可能性のあるトラバースネットワークミドルボックスのTCP接続を介したインターネットキーエクスチェンジプロトコル（IKE）とIPSECパケットを輸送する方法について説明します。「TCPカプセル化」と呼ばれるこの方法では、セキュリティ協会（SA）の確立とセキュリティペイロード（ESP）パケットの両方のIKEパケットをTCP接続に介して送信します。この方法は、IKEをUDPで交渉できない場合、フォールバックオプションとして使用することを目的としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP encapsulation for IKE and IPsec was defined in RFC 8229. This document clarifies the specification for TCP encapsulation by including additional clarifications obtained during implementation and deployment of this method. This documents obsoletes RFC 8229.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEおよびIPSECのTCPカプセル化は、RFC 8229で定義されました。このドキュメントは、この方法の実装と展開中に得られた追加の明確化を含めることにより、TCPカプセル化の仕様を明確にします。これは、廃止されたRFC 8229を文書化しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、インターネット標準トラックドキュメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9329.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9329で取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（c）2022 IETF Trustおよび文書著者として特定された人。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、修正されたBSDライセンスで説明されているように保証なしで提供される修正されたBSDライセンステキストを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction
     1.1.  Prior Work and Motivation
     1.2.  Terminology and Notation
   2.  Configuration
   3.  TCP-Encapsulated Data Formats
     3.1.  TCP-Encapsulated IKE Message Format
     3.2.  TCP-Encapsulated ESP Packet Format
   4.  TCP-Encapsulated Stream Prefix
   5.  Applicability
     5.1.  Recommended Fallback from UDP
   6.  Using TCP Encapsulation
     6.1.  Connection Establishment and Teardown
     6.2.  Retransmissions
     6.3.  Cookies and Puzzles
       6.3.1.  Statelessness versus Delay of SA Establishment
     6.4.  Error Handling in IKE_SA_INIT
     6.5.  NAT-Detection Payloads
     6.6.  NAT-Keepalive Packets
     6.7.  Dead Peer Detection and Transport Keepalives
     6.8.  Implications of TCP Encapsulation on IPsec SA Processing
   7.  Interaction with IKEv2 Extensions
     7.1.  MOBIKE Protocol
     7.2.  IKE Redirect
     7.3.  IKEv2 Session Resumption
     7.4.  IKEv2 Protocol Support for High Availability
     7.5.  IKEv2 Fragmentation
   8.  Middlebox Considerations
   9.  Performance Considerations
     9.1.  TCP-in-TCP
     9.2.  Added Reliability for Unreliable Protocols
     9.3.  Quality-of-Service Markings
     9.4.  Maximum Segment Size
     9.5.  Tunneling ECN in TCP
   10. Security Considerations
   11. IANA Considerations
   12. References
     12.1.  Normative References
     12.2.  Informative References
   Appendix A.  Using TCP Encapsulation with TLS
   Appendix B.  Example Exchanges of TCP Encapsulation with TLS 1.3
     B.1.  Establishing an IKE Session
     B.2.  Deleting an IKE Session
     B.3.  Re-establishing an IKE Session
     B.4.  Using MOBIKE between UDP and TCP Encapsulation
   Acknowledgments
   Authors&#39; Addresses
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Internet Key Exchange Protocol version 2 (IKEv2) [RFC7296] is a protocol for establishing IPsec Security Associations (SAs) using IKE messages over UDP for control traffic and using Encapsulating Security Payload (ESP) messages [RFC4303] for encrypted data traffic. Many network middleboxes that filter traffic on public hotspots block all UDP traffic, including IKE and IPsec, but allow TCP connections through because they appear to be web traffic. Devices on these networks that need to use IPsec (to access private enterprise networks, to route Voice over IP calls to carrier networks because of security policies, etc.) are unable to establish IPsec SAs. This document defines a method for encapsulating IKE control messages as well as ESP data messages within a TCP connection. Note that Authentication Header (AH) is not supported by this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インターネットキーエクスチェンジプロトコルバージョン2（IKEV2）[RFC7296]は、制御トラフィックのためにUDPを介してIKEメッセージを使用し、暗号化されたデータトラフィックにセキュリティペイロード（ESP）メッセージ[RFC4303]を使用してIKEセキュリティ関連（SAS）を確立するためのプロトコルです。パブリックホットスポットのトラフィックをフィルタリングする多くのネットワークミドルボックスは、IKEやIPSECを含むすべてのUDPトラフィックをブロックしますが、Webトラフィックのように見えるため、TCP接続を許可します。IPSECを使用する必要があるこれらのネットワーク上のデバイス（プライベートエンタープライズネットワークにアクセスするには、セキュリティポリシーなどのためにキャリアネットワークにVoice over IP通話をルーティングします）は、IPSEC SASを確立できません。このドキュメントでは、IKEコントロールメッセージとTCP接続内のESPデータメッセージをカプセル化する方法を定義します。認証ヘッダー（AH）は、この仕様ではサポートされていないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using TCP as a transport for IPsec packets adds the third option (below) to the list of traditional IPsec transports:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPSECパケットのトランスポートとしてTCPを使用すると、従来のIPSECトランスポートのリストに3番目のオプション（以下）が追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Direct. Usually, IKE negotiations begin over UDP port 500. If no Network Address Translation (NAT) device is detected between the Initiator and the Responder, then subsequent IKE packets are sent over UDP port 500 and IPsec data packets are sent using ESP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 直接。通常、IKEの交渉はUDPポート500で開始されます。ネットワークアドレス変換（NAT）デバイスがイニシエーターとレスポンダーの間で検出されない場合、その後のIKEパケットはUDPポート500で送信され、IPSECデータパケットはESPを使用して送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. UDP Encapsulation. Described in [RFC3948]. If a NAT is detected between the Initiator and the Responder, then subsequent IKE packets are sent over UDP port 4500 with 4 bytes of zero at the start of the UDP payload, and ESP packets are sent out over UDP port 4500. Some implementations default to using UDP encapsulation even when no NAT is detected on the path, as some middleboxes do not support IP protocols other than TCP and UDP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. UDPカプセル化。[RFC3948]で説明されています。イニシエーターとレスポンダーの間でNATが検出された場合、UDPペイロードの開始時に4バイトのゼロでUDPポート4500を介して後続のIKEパケットが送信され、ESPパケットはUDPポート4500で送信されます。一部のミドルボックスはTCPおよびUDP以外のIPプロトコルをサポートしていないため、パスでNATが検出されない場合でもUDPカプセル化を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. TCP Encapsulation. Described in this document. If the other two methods are not available or appropriate, IKE negotiation packets as well as ESP packets can be sent over a single TCP connection to the peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. TCPカプセル化。このドキュメントで説明されています。他の2つの方法が利用可能または適切でない場合、IKEネゴシエーションパケットとESPパケットは、ピアへの単一のTCP接続で送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Direct use of ESP or UDP encapsulation should be preferred by IKE implementations due to performance concerns when using TCP encapsulation (Section 9). Most implementations should use TCP encapsulation only on networks where negotiation over UDP has been attempted without receiving responses from the peer or if a network is known to not support UDP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPカプセル化を使用する場合のパフォーマンスの懸念により、IKEの実装により、ESPまたはUDPカプセル化の直接使用が優先される必要があります（セクション9）。ほとんどの実装では、ピアから応答を受信せずにUDPをめぐる交渉が試みられている、またはネットワークがUDPをサポートしていないことが知られている場合にのみ、TCPカプセル化を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-1--Prior-Work-and-Motivation">
1.1. Prior Work and Motivation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 以前の仕事と動機
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encapsulating IKE connections within TCP streams is a common approach to solve the problem of UDP packets being blocked by network middleboxes. The specific goals of this document are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPストリーム内のIKE接続のカプセル化は、ネットワークミドルボックスによってブロックされているUDPパケットの問題を解決するための一般的なアプローチです。このドキュメントの特定の目標は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* To promote interoperability by defining a standard method of framing IKE and ESP messages within TCP streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* TCPストリーム内でIKEおよびESPメッセージをフレーミングする標準的な方法を定義することにより、相互運用性を促進する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* To be compatible with the current IKEv2 standard without requiring modifications or extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 変更や拡張機能を必要とせずに、現在のIKEV2標準と互換性があること。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* To use IKE over UDP by default to avoid the overhead of other alternatives that always rely on TCP or Transport Layer Security (TLS) [RFC5246] [RFC8446].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* IKEを使用して、デフォルトでUDPを使用して、常にTCPまたは輸送層のセキュリティ（TLS）[RFC5246] [RFC8446]に依存している他の代替のオーバーヘッドを回避します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some previous alternatives include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前の選択肢には次のものがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cellular Network Access: Interworking Wireless LAN (IWLAN) uses IKEv2 to create secure connections to cellular carrier networks for making voice calls and accessing other network services over Wi-Fi networks. 3GPP has recommended that IKEv2 and ESP packets be sent within a TLS connection to be able to establish connections on restrictive networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セルラーネットワークアクセス：ワイヤレスLAN（IWLAN）はIKEV2を使用して、音声通話を行い、Wi-Fiネットワークを介して他のネットワークサービスにアクセスするためのセルラーキャリアネットワークへの安全な接続を作成します。3GPPは、IKEV2およびESPパケットをTLS接続内で送信して、制限ネットワークで接続を確立できることを推奨しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ISAKMP over TCP: Various non-standard extensions to the Internet Security Association and Key Management Protocol (ISAKMP) have been deployed that send IPsec traffic over TCP or TCP-like packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPを介したISAKMP：インターネットセキュリティ協会および主要な管理プロトコル（ISAKMP）へのさまざまな非標準拡張機能が展開されており、TCPまたはTCPのようなパケットを介してIPSECトラフィックを送信しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Secure Sockets Layer (SSL) VPNs: Many proprietary VPN solutions use a combination of TLS and IPsec in order to provide reliability. These often run on TCP port 443.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュアソケットレイヤー（SSL）VPN：多くの独自のVPNソリューションは、信頼性を提供するためにTLSとIPSECの組み合わせを使用します。これらはしばしばTCPポート443で実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEv2 over TCP: IKEv2 over TCP as described in [IPSECME-IKE-TCP] is used to avoid UDP fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IPSecme-kike-TCP]で説明されているように、TCPを超えるIKEV2：IKEV2 TCPを超えるIKEV2は、UDPの断片化を回避するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP encapsulation for IKE and IPsec was defined in [RFC8229]. This document updates the specification for TCP encapsulation by including additional clarifications obtained during implementation and deployment of this method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEおよびIPSECのTCPカプセル化は、[RFC8229]で定義されました。このドキュメントは、この方法の実装と展開中に得られた追加の明確化を含めることにより、TCPカプセル化の仕様を更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In particular:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The interpretation of the Length field preceding every message is clarified (Section 3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* すべてのメッセージに先行する長さフィールドの解釈は、明確にされています（セクション3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The use of the NAT_DETECTION_*_IP notifications is clarified (Sections 5.1, 6.5, and 7.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* NAT_DETECTION _*_ IP通知の使用は明確になります（セクション5.1、6.5、および7.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Retransmission behavior is clarified (Section 6.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 再送信の動作は明らかにされています（セクション6.2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The use of cookies and puzzles is described in more detail (Section 6.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* クッキーとパズルの使用については、より詳細に説明します（セクション6.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Error handling is clarified (Section 6.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* エラー処理が明確になります（セクション6.4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Implications of TCP encapsulation on IPsec SA processing are expanded (Section 6.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* IPSEC SA処理に対するTCPカプセル化の意味が拡大されています（セクション6.8）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Section 7 describing interactions with other IKEv2 extensions is added.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 他のIKEV2拡張機能との相互作用を説明するセクション7を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The interaction of TCP encapsulation with IKEv2 Mobility and Multihoming (MOBIKE) is clarified (Section 7.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* IKEV2モビリティおよびマルチホミング（Mobike）とのTCPカプセル化との相互作用は明らかになります（セクション7.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The recommendation for TLS encapsulation (Appendix A) now includes TLS 1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* TLSカプセル化の推奨事項（付録A）には、TLS 1.3が含まれるようになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Examples of TLS encapsulation are provided using TLS 1.3 (Appendix B).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* TLSカプセル化の例は、TLS 1.3（付録B）を使用して提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* More security considerations are added.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* より多くのセキュリティ上の考慮事項が追加されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1-2--Terminology-and-Notation">
1.2. Terminology and Notation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. 用語と表記
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document distinguishes between the IKE peer that initiates TCP connections to be used for TCP encapsulation and the roles of Initiator and Responder for particular IKE messages. During the course of IKE exchanges, the role of IKE Initiator and Responder may swap for a given SA (as with IKE SA rekeys), while the Initiator of the TCP connection is still responsible for tearing down the TCP connection and re-establishing it if necessary. For this reason, this document will use the term &#34;TCP Originator&#34; to indicate the IKE peer that initiates TCP connections. The peer that receives TCP connections will be referred to as the &#34;TCP Responder&#34;. If an IKE SA is rekeyed one or more times, the TCP Originator MUST remain the peer that originally initiated the first IKE SA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、TCPカプセル化に使用されるTCP接続を開始するIKEピアと、特定のIKEメッセージのイニシエーターとレスポンダーの役割を区別します。IKE交換の過程で、IKEイニシエーターとレスポンダーの役割は、特定のSAを（IKE SA Rekeysと同様に）スワップすることがありますが、TCP接続のイニシエーターはTCP接続を引き裂き、再確立する責任があります。必要。このため、このドキュメントは「TCP Originator」という用語を使用して、TCP接続を開始するIKEピアを示します。TCP接続を受信するピアは、「TCP Responder」と呼ばれます。IKE SAが1回以上再キーにされている場合、TCPオリジネーターは最初に最初のIKE SAを開始したピアのままでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, および &#34;OPTIONAL&#34; はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Configuration">
2. Configuration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 構成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One of the main reasons to use TCP encapsulation is that UDP traffic may be entirely blocked on a network. Because of this, support for TCP encapsulation is not specifically negotiated in the IKE exchange. Instead, support for TCP encapsulation must be preconfigured on both the TCP Originator and the TCP Responder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPカプセル化を使用する主な理由の1つは、UDPトラフィックがネットワーク上で完全にブロックされる可能性があることです。このため、TCPカプセル化のサポートはIKE Exchangeで具体的に交渉されていません。代わりに、TCPカプセル化のサポートは、TCPオリジネーターとTCPレスポンダーの両方で事前に設定される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Compliant implementations MUST support TCP encapsulation on TCP port 4500, which is reserved for IPsec NAT traversal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
準拠の実装は、IPSEC NATトラバーサル用に予約されているTCPポート4500でのTCPカプセル化をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Beyond a flag indicating support for TCP encapsulation, the configuration for each peer can include the following optional parameters:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPカプセル化のサポートを示すフラグを超えて、各ピアの構成には、次のオプションパラメーターを含めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Alternate TCP ports on which the specific TCP Responder listens for incoming connections. Note that the TCP Originator may initiate TCP connections to the TCP Responder from any local port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 特定のTCPレスポンダーが着信接続用に耳を傾ける代替TCPポート。TCPオリジネーターは、ローカルポートからTCP ResponderへのTCP接続を開始できることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* An extra framing protocol to use on top of TCP to further encapsulate the stream of IKE and IPsec packets. See Appendix A for a detailed discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* TCPの上で使用する追加のフレーミングプロトコルは、IKEとIPSECパケットのストリームをさらにカプセル化します。詳細については、付録Aを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since TCP encapsulation of IKE and IPsec packets adds overhead and has potential performance trade-offs compared to direct or UDP-encapsulated SAs (as described in Section 9), implementations SHOULD prefer ESP direct or UDP-encapsulated SAs over TCP-encapsulated SAs when possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEおよびIPSECパケットのTCPカプセル化はオーバーヘッドを追加し、直接またはUDPにカプセル化されたSAS（セクション9で説明されている）と比較して潜在的なパフォーマンストレードオフを持っているため、実装は、可能な場合はTCPでカプセル化されたSAよりもESP直接またはUDPカプセル化SASを好む必要があります。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--TCP-Encapsulated-Data-Formats">
3. TCP-Encapsulated Data Formats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. TCPにカプセル化されたデータ形式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Like UDP encapsulation, TCP encapsulation uses the first 4 bytes of a message to differentiate IKE and ESP messages. TCP encapsulation also adds a 16-bit Length field that precedes every message to define the boundaries of messages within a stream. The value in this field is equal to the length of the original message plus the length of the field itself, in octets. If the first 32 bits of the message are zeros (a non-ESP marker), then the contents comprise an IKE message. Otherwise, the contents comprise an ESP message. AH messages are not supported for TCP encapsulation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPカプセル化と同様に、TCPカプセル化は、メッセージの最初の4バイトを使用して、IKEとESPメッセージを区別します。TCPカプセル化は、すべてのメッセージに先行する16ビットの長さフィールドも追加して、ストリーム内のメッセージの境界を定義します。このフィールドの値は、オクテットの元のメッセージの長さとフィールド自体の長さに等しくなります。メッセージの最初の32ビットがZeros（非ESPマーカー）の場合、内容はIKEメッセージを構成します。それ以外の場合、内容はESPメッセージを構成します。AHメッセージはTCPカプセル化にはサポートされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although a TCP stream may be able to send very long messages, implementations SHOULD limit message lengths to match the lengths used for UDP encapsulation of ESP messages. The maximum message length is used as the effective MTU for connections that are being encrypted using ESP, so the maximum message length will influence characteristics of these connections, such as the TCP Maximum Segment Size (MSS).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPストリームは非常に長いメッセージを送信できる場合がありますが、実装はメッセージの長さを制限して、ESPメッセージのUDPカプセル化に使用される長さに一致する必要があります。最大メッセージ長は、ESPを使用して暗号化されている接続の有効MTUとして使用されるため、最大メッセージの長さは、TCP最大セグメントサイズ（MSS）などのこれらの接続の特性に影響します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Due to the fact that the Length field is 16 bits and includes both the message length and the length of the field itself, it is impossible to encapsulate messages greater than 65533 octets in length. In most cases, this is not a problem. Note that a similar limitation exists for encapsulation ESP in UDP [RFC3948].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さのフィールドは16ビットで、メッセージの長さとフィールド自体の長さの両方が含まれているため、65533オクテットを超えるメッセージをカプセル化することは不可能です。ほとんどの場合、これは問題ではありません。UDP [RFC3948]のカプセル化ESPにも同様の制限が存在することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The minimum size of an encapsulated message is 1 octet (for NAT-keepalive packets, see Section 6.6). Empty messages (where the Length field equals 2) MUST be silently ignored by receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カプセル化されたメッセージの最小サイズは1オクテットです（Nat-Keepaliveパケットの場合、セクション6.6を参照）。空のメッセージ（長さフィールドが2に等しい）は、受信機によって静かに無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this method of encapsulation will also work for placing IKE and ESP messages within any protocol that presents a stream abstraction, beyond TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このカプセル化方法は、TCPを超えてストリーム抽象化を示すプロトコル内にIKEおよびESPメッセージを配置するためにも機能することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--TCP-Encapsulated-IKE-Message-Format">
3.1. TCP-Encapsulated IKE Message Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. TCPでカプセル化されたIKEメッセージ形式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                   |            Length             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Non-ESP Marker                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                     IKE Message (RFC 7296)                    ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Figure 1: IKE Message Format for TCP Encapsulation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
図1：TCPカプセル化のIKEメッセージ形式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IKE message is preceded by a 16-bit Length field in network byte order that specifies the length of the IKE message (including the non-ESP marker) within the TCP stream. As with IKE over UDP port 4500, a zeroed 32-bit non-ESP marker is inserted before the start of the IKE header in order to differentiate the traffic from ESP traffic between the same addresses and ports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEメッセージの前には、TCPストリーム内のIKEメッセージ（非ESPマーカーを含む）の長さを指定するネットワークバイト順序の16ビットの長さフィールドがあります。UDPポート4500のIKEと同様に、同じアドレスとポート間のESPトラフィックを区別するために、IKEヘッダーの開始前にゼロになった32ビットの非ESPマーカーが挿入されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Length (2 octets, unsigned integer): Length of the IKE message, including the Length field and non-ESP marker. The value in the Length field MUST NOT be 0 or 1. The receiver MUST treat these values as fatal errors and MUST close the TCP connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ（2オクテット、符号なし整数）：長さフィールドと非ESPマーカーを含むIKEメッセージの長さ。長さフィールドの値は0または1であってはなりません。受信機は、これらの値を致命的なエラーとして扱う必要があり、TCP接続を閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Non-ESP Marker (4 octets): Four zero-valued bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非ESPマーカー（4オクテット）：4つのゼロ値バイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--TCP-Encapsulated-ESP-Packet-Format">
3.2. TCP-Encapsulated ESP Packet Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. TCPにカプセル化されたESPパケット形式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                   |            Length             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                     ESP Packet (RFC 4303)                     ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Figure 2: ESP Packet Format for TCP Encapsulation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
図2：TCPカプセル化のESPパケット形式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ESP packet is preceded by a 16-bit Length field in network byte order that specifies the length of the ESP packet within the TCP stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ESPパケットの前には、TCPストリーム内のESPパケットの長さを指定するネットワークバイト順序で16ビットの長さフィールドがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Security Parameter Index (SPI) field [RFC7296] in the ESP header MUST NOT be a zero value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ESPヘッダーのセキュリティパラメーターインデックス（SPI）フィールド[RFC7296]はゼロ値である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Length (2 octets, unsigned integer): Length of the ESP packet, including the Length field. The value in the Length field MUST NOT be 0 or 1. The receiver MUST treat these values as fatal errors and MUST close TCP connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ（2オクテット、符号なし整数）：長さフィールドを含むESPパケットの長さ。長さフィールドの値は0または1であってはなりません。受信機は、これらの値を致命的なエラーとして扱う必要があり、TCP接続を閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--TCP-Encapsulated-Stream-Prefix">
4. TCP-Encapsulated Stream Prefix
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. TCPでカプセル化されたストリームプレフィックス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each stream of bytes used for IKE and IPsec encapsulation MUST begin with a fixed sequence of 6 bytes as a magic value, containing the characters &#34;IKETCP&#34; as ASCII values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEおよびIPSECカプセル化に使用されるバイトの各ストリームは、ASCII値として「iketCP」を含むマジック値として6バイトの固定シーケンスで開始する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0      1      2      3      4      5
   +------+------+------+------+------+------+
   | 0x49 | 0x4b | 0x45 | 0x54 | 0x43 | 0x50 |
   +------+------+------+------+------+------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Figure 3: TCP-Encapsulated Stream Prefix
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
図3：TCPにカプセル化されたストリームプレフィックス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This value is intended to identify and validate that the TCP connection is being used for TCP encapsulation as defined in this document, to avoid conflicts with the prevalence of previous non-standard protocols that used TCP port 4500. This value is only sent once, by the TCP Originator only, at the beginning of the TCP stream of IKE and ESP messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この値は、TCPポート4500を使用した以前の非標準プロトコルの有病率との競合との競合を避けるために、TCP接続がこのドキュメントで定義されているTCPカプセル化に使用されていることを特定して検証することを目的としています。この値は、1回しか送信されません。IKEおよびESPメッセージのTCPストリームの開始時にのTCPオリジネーターのみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Initiator                                                   Responder
   ---------------------------------------------------------------------
             &lt;new TCP connection is established by Initiator&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Stream Prefix|Length|non-ESP marker|IKE message --&gt;
                                   &lt;-- Length|non-ESP marker|IKE message
   Length|non-ESP marker|IKE message --&gt;
                                   &lt;-- Length|non-ESP marker|IKE message
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 [...] Length|ESP packet -&gt; &lt;- Length|ESP packet
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[...]長さ| ESPパケット - &gt; &lt; - 長さ| ESPパケット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If other framing protocols are used within TCP to further encapsulate or encrypt the stream of IKE and ESP messages, the stream prefix must be at the start of the TCP Originator&#39;s IKE and ESP message stream within the added protocol layer (Appendix A). Although some framing protocols do support negotiating inner protocols, the stream prefix should always be used in order for implementations to be as generic as possible and not rely on other framing protocols on top of TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEおよびESPメッセージのストリームをさらにカプセル化または暗号化するためにTCP内で他のフレーミングプロトコルを使用している場合、ストリームプレフィックスは、追加されたプロトコルレイヤー内のTCPオリジネーターのIKEおよびESPメッセージストリームの開始時に必要です（付録A）。一部のフレーミングプロトコルは内部プロトコルの交渉をサポートしていますが、実装を可能な限り一般的にし、TCPの上の他のフレーミングプロトコルに依存しないように、ストリームプレフィックスを常に使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Applicability">
5. Applicability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 適用性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP encapsulation is applicable only when it has been configured to be used with specific IKE peers. If a Responder is configured to accept and is allowed to use TCP encapsulation, it MUST listen on the configured port(s) in case any peers will initiate new IKE sessions. Initiators MAY use TCP encapsulation for any IKE session to a peer that is configured to support TCP encapsulation, although it is recommended that Initiators only use TCP encapsulation when traffic over UDP is blocked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPカプセル化は、特定のIKEピアで使用するように構成されている場合にのみ適用できます。レスポンダーが受け入れるように構成され、TCPカプセル化の使用が許可されている場合、ピアが新しいIKEセッションを開始する場合に備えて、構成されたポートで聞く必要があります。イニシエーターは、TCPカプセル化をサポートするように構成されているピアへのIKEセッションのTCPカプセル化を使用する場合がありますが、イニシエーターはUDP上のトラフィックがブロックされている場合にのみTCPカプセル化を使用することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the support of TCP encapsulation is a configured property, not a negotiated one, it is recommended that if there are multiple IKE endpoints representing a single peer (such as multiple machines with different IP addresses when connecting by Fully Qualified Domain Name (FQDN), or endpoints used with IKE redirection), all of the endpoints equally support TCP encapsulation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPカプセル化のサポートは、交渉済みのプロパティではなく構成されたプロパティであるため、単一のピアを表す複数のIKEエンドポイントがある場合（完全資格ドメイン名（FQDN）によって接続するときに異なるIPアドレスを持つ複数のマシンなど、またはIKEリダイレクトで使用されるエンドポイント）、すべてのエンドポイントはTCPカプセル化を等しくサポートしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If TCP encapsulation is being used for a specific IKE SA, all IKE messages for that IKE SA and ESP packets for its Child SAs MUST be sent over a TCP connection until the SA is deleted or IKEv2 Mobility and Multihoming (MOBIKE) is used to change the SA endpoints and/or the encapsulation protocol. See Section 7.1 for more details on using MOBIKE to transition between encapsulation modes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のIKE SAにTCPカプセル化が使用されている場合、SAが削除されるか、IKEV2モビリティとMultihoming（Mobike）が削除されるまで、子供SASのIKE SAおよびESPパケットをTCP接続を介して送信する必要があります。SAエンドポイントおよび/またはカプセル化プロトコル。Mobikeを使用してカプセル化モード間の移行の詳細については、セクション7.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--Recommended-Fallback-from-UDP">
5.1. Recommended Fallback from UDP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. UDPからの推奨フォールバック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since UDP is the preferred method of transport for IKE messages, implementations that use TCP encapsulation should have an algorithm for deciding when to use TCP after determining that UDP is unusable. If an Initiator implementation has no prior knowledge about the network it is on and the status of UDP on that network, it SHOULD always attempt to negotiate IKE over UDP first. IKEv2 defines how to use retransmission timers with IKE messages and, specifically, IKE_SA_INIT messages [RFC7296]. Generally, this means that the implementation will define a frequency of retransmission and the maximum number of retransmissions allowed before marking the IKE SA as failed. An implementation can attempt negotiation over TCP once it has hit the maximum retransmissions over UDP, or slightly before to reduce connection setup delays. It is recommended that the initial message over UDP be retransmitted at least once before falling back to TCP, unless the Initiator knows beforehand that the network is likely to block UDP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPはIKEメッセージの優先輸送方法であるため、TCPカプセル化を使用する実装には、UDPが使用できないと判断した後にTCPを使用するタイミングを決定するためのアルゴリズムが必要です。イニシエーターの実装に、そのネットワークに関する事前の知識がない場合、そのネットワーク上のUDPのステータスが常にUDPを介してIKEを交渉しようとする必要があります。 IKEV2は、IKEメッセージ、具体的にはIKE_SA_INITメッセージ[RFC7296]で再送信タイマーを使用する方法を定義します。一般に、これは、実装が再送信の頻度と、IKE SAに失敗したとマークする前に許可される再送信の最大数を定義することを意味します。実装により、TCPがUDPよりも最大の再送信に達した後、または接続のセットアップ遅延をわずかに減らすと、TCPをめぐる交渉を試みることができます。イニシエーターがネットワークがUDPをブロックする可能性が高いことを事前に知っていない限り、TCPに戻る前に、UDPを介した最初のメッセージを少なくとも1回再送信することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When switching from UDP to TCP, a new IKE_SA_INIT exchange MUST be initiated with the Initiator&#39;s new SPI and with recalculated content of NAT_DETECTION_*_IP notifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPからTCPに切り替える場合、新しいIKE_SA_INIT Exchangeは、イニシエーターの新しいSPIとNAT_DETECTION _*_ IP通知の再計算コンテンツで開始する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Using-TCP-Encapsulation">
6. Using TCP Encapsulation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. TCPカプセル化の使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1--Connection-Establishment-and-Teardown">
6.1. Connection Establishment and Teardown
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 接続の確立と分解
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the IKE Initiator uses TCP encapsulation, it will initiate a TCP connection to the Responder using the Responder&#39;s preconfigured TCP port. The first bytes sent on the TCP stream MUST be the stream prefix value (Section 4). After this prefix, encapsulated IKE messages will negotiate the IKE SA and initial Child SA [RFC7296]. After this point, both encapsulated IKE (Figure 1) and ESP (Figure 2) messages will be sent over the TCP connection. The TCP Responder MUST wait for the entire stream prefix to be received on the stream before trying to parse out any IKE or ESP messages. The stream prefix is sent only once, and only by the TCP Originator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEイニシエーターがTCPカプセル化を使用すると、ResponderのPreconufigured TCPポートを使用してResponderへのTCP接続を開始します。TCPストリームで送信された最初のバイトは、ストリームプレフィックス値（セクション4）でなければなりません。このプレフィックスの後、カプセル化されたIKEメッセージは、IKE SAと初期子SA [RFC7296]をネゴシエートします。この点の後、カプセル化されたIKE（図1）とESP（図2）メッセージの両方がTCP接続を介して送信されます。TCPレスポンダーは、IKEまたはESPメッセージを解析しようとする前に、ストリーム上のストリームプレフィックス全体がストリームで受信されるのを待つ必要があります。ストリームプレフィックスは1回だけ送信され、TCPオリジネーターによってのみ送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to close an IKE session, either the Initiator or Responder SHOULD gracefully tear down IKE SAs with DELETE payloads. Once the SA has been deleted, the TCP Originator SHOULD close the TCP connection if it does not intend to use the connection for another IKE session to the TCP Responder. If the TCP connection is no longer associated with any active IKE SA, the TCP Responder MAY close the connection to clean up IKE resources if the TCP Originator didn&#39;t close it within some reasonable period of time (e.g., a few seconds).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEセッションを閉じるために、イニシエーターまたはレスポンダーのいずれかが、削除ペイロードでIKE SASを優雅に取り壊す必要があります。SAが削除されると、TCPオリジネーターは、TCP Responderへの別のIKEセッションの接続を使用する予定がない場合、TCP接続を閉じる必要があります。TCP接続がアクティブなIKE SAに関連付けられなくなった場合、TCPオリジネーターが何らかの合理的な期間（例えば数秒）以内にそれを閉じなかった場合、TCPリスポンダーが接続を閉じてIKEリソースをクリーンアップすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An unexpected FIN or a TCP Reset on the TCP connection may indicate a loss of connectivity, an attack, or some other error. If a DELETE payload has not been sent, both sides SHOULD maintain the state for their SAs for the standard lifetime or timeout period. The TCP Originator is responsible for re-establishing the TCP connection if it is torn down for any unexpected reason. Since new TCP connections may use different IP addresses and/or ports due to NAT mappings or local address or port allocations changing, the TCP Responder MUST allow packets for existing SAs to be received from new source IP addresses and ports. Note that the IPv6 Flow-ID header MUST remain constant when a new TCP connection is created to avoid ECMP load balancing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP接続の予期しないFINまたはTCPリセットは、接続性の損失、攻撃、またはその他のエラーを示している場合があります。削除ペイロードが送信されていない場合、双方は標準的な寿命またはタイムアウト期間のSASの状態を維持する必要があります。TCPオリジネーターは、予期しない理由で取り壊された場合、TCP接続を再確立する責任があります。新しいTCP接続は、NATマッピングまたはローカルアドレスまたはポートの割り当てが変更されているため、異なるIPアドレスやポートを使用する可能性があるため、TCP Responderは、既存のSASのパケットを新しいソースIPアドレスとポートから受信できるようにする必要があります。ECMPロードバランシングを避けるために、新しいTCP接続が作成されている場合、IPv6フローIDヘッダーは一定のままでなければならないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer MUST discard a partially received message due to a broken connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、接続が壊れているため、部分的に受信したメッセージを破棄する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever the TCP Originator opens a new TCP connection to be used for an existing IKE SA, it MUST send the stream prefix first, before any IKE or ESP messages. This follows the same behavior as the initial TCP connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP Originatorが既存のIKESAに使用する新しいTCP接続を開くたびに、IKEまたはESPメッセージの前に最初にストリームプレフィックスを送信する必要があります。これは、初期のTCP接続と同じ動作に従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiple IKE SAs MUST NOT share a single TCP connection, unless one is a rekey of an existing IKE SA, in which case there will temporarily be two IKE SAs on the same TCP connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のIKE SASは、既存のIKE SAの再キーでない限り、単一のTCP接続を共有してはなりません。その場合、同じTCP接続に一時的に2つのIKE SASがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a TCP connection is being used to continue an existing IKE/ESP session, the TCP Responder can recognize the session using either the IKE SPI from an encapsulated IKE message or the ESP SPI from an encapsulated ESP packet. If the session had been fully established previously, it is suggested that the TCP Originator send an UPDATE_SA_ADDRESSES message if MOBIKE is supported and an empty informational message if it is not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP接続が既存のIKE/ESPセッションを継続するために使用されている場合、TCP Responderは、カプセル化されたIKEメッセージからのIKE SPIまたはカプセル化されたESPパケットからのESP SPIのいずれかを使用してセッションを認識できます。セッションが以前に完全に確立されていた場合、TCP OriginatorがMobikeがサポートされている場合はupdate_sa_addressesメッセージを送信し、そうでない場合は空の情報メッセージを送信することが提案されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TCP Responder MUST NOT accept any messages for the existing IKE session on a new incoming connection, unless that connection begins with the stream prefix. If either the TCP Originator or TCP Responder detects corruption on a connection that was started with a valid stream prefix, it SHOULD close the TCP connection. The connection can be corrupted if there are too many subsequent messages that cannot be parsed as valid IKE messages or ESP messages with known SPIs, or if the authentication check for an IKE message or ESP message with a known SPI fails. Implementations SHOULD NOT tear down a connection if only a few consecutive ESP packets have unknown SPIs since the SPI databases may be momentarily out of sync. If there is instead a syntax issue within an IKE message, an implementation MUST send the INVALID_SYNTAX notify payload and tear down the IKE SA as usual, rather than tearing down the TCP connection directly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPレスポンダーは、その接続がストリームプレフィックスから始まっていない限り、新しい着信接続に関する既存のIKEセッションのメッセージを受け入れてはなりません。TCP OriginatorまたはTCP Responderのいずれかが、有効なストリームプレフィックスで開始された接続で破損を検出する場合、TCP接続を閉じる必要があります。既知のSPIを使用した有効なIKEメッセージまたはESPメッセージとして解析できない後続のメッセージが多すぎる場合、または既知のSPIを使用したIKEメッセージまたはESPメッセージの認証チェックが失敗した場合、接続を破損する可能性があります。SPIデータベースが一時的に同期していない可能性があるため、いくつかの連続したESPパケットのみが不明なSPIを持っている場合、実装は接続を取り壊さないでください。代わりにIKEメッセージ内に構文の問題がある場合、実装は、TCP接続を直接引き裂くのではなく、Invalid_syntaxにペイロードを通知し、通常のようにIKE SAに削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A TCP Originator SHOULD only open one TCP connection per IKE SA, over which it sends all of the corresponding IKE and ESP messages. This helps ensure that any firewall or NAT mappings allocated for the TCP connection apply to all of the traffic associated with the IKE SA equally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPオリジネーターは、IKE SAごとに1つのTCP接続のみを開く必要があり、その上で対応するIKEおよびESPメッセージをすべて送信します。これにより、TCP接続に割り当てられたファイアウォールまたはNATマッピングがIKE SAに関連付けられているすべてのトラフィックに等しく適用されるようにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with TCP Originators, a TCP Responder SHOULD send packets for an IKE SA and its Child SAs over only one TCP connection at any given time. It SHOULD choose the TCP connection on which it last received a valid and decryptable IKE or ESP message. In order to be considered valid for choosing a TCP connection, an IKE message must be successfully decrypted and authenticated, not be a retransmission of a previously received message, and be within the expected window for IKE message IDs. Similarly, an ESP message must be successfully decrypted and authenticated, and must not be a replay of a previous message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPオリジネーターと同様に、TCPレスポンダーは、任意の時間に1つのTCP接続のみでIKE SAとその子SASにパケットを送信する必要があります。最後に有効で復号化可能なIKEまたはESPメッセージを受信したTCP接続を選択する必要があります。TCP接続の選択に有効であると見なされるためには、IKEメッセージを正常に復号化および認証し、以前に受信したメッセージの再送信ではなく、IKEメッセージIDの予想ウィンドウ内にある必要があります。同様に、ESPメッセージを正常に復号化して認証する必要があり、以前のメッセージのリプレイであってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since a connection may be broken and a new connection re-established by the TCP Originator without the TCP Responder being aware, a TCP Responder SHOULD accept receiving IKE and ESP messages on both old and new connections until the old connection is closed by the TCP Originator. A TCP Responder MAY close a TCP connection that it perceives as idle and extraneous (one previously used for IKE and ESP messages that has been replaced by a new connection).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP Responderが認識されていないTCPオリジナーターによって接続が破損し、新しい接続が再確立される可能性があるため、TCP Responderは、TCP Originatorによって古い接続が閉じるまで、古い接続と新しい接続の両方でIKEとESPメッセージの受信を受け入れる必要があります。。TCPレスポンダーは、アイドルと外部として認識されるTCP接続を閉じることができます（新しい接続に置き換えられたIKEおよびESPメッセージに以前に使用されていたもの）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2--Retransmissions">
6.2. Retransmissions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. 再送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 2.1 of [RFC7296] describes how IKEv2 deals with the unreliability of the UDP protocol. In brief, the exchange Initiator is responsible for retransmissions and must retransmit request messages until a response message is received. If no reply is received after several retransmissions, the SA is deleted. The Responder never initiates retransmission, but it must send a response message again in case it receives a retransmitted request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7296]のセクション2.1は、IKEV2がUDPプロトコルの信頼性をどのように扱うかについて説明します。簡単に言えば、Exchangeイニシエーターは再送信を担当し、応答メッセージが受信されるまでリクエストメッセージを再送信する必要があります。いくつかの再送信後に返信がない場合、SAは削除されます。応答者は再送信を開始することはありませんが、再送信リクエストを受信した場合に備えて、応答メッセージを再度送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When IKEv2 uses a reliable transport protocol, like TCP, the retransmission rules are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEV2がTCPのように信頼できる輸送プロトコルを使用する場合、再送信ルールは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The exchange Initiator SHOULD NOT retransmit request message (*); if no response is received within some reasonable period of time, the IKE SA is deleted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Exchangeイニシエーターは、要求メッセージ（*）を再送信しないでください。合理的な期間内に応答がない場合、IKE SAは削除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If a new TCP connection for the IKE SA is established while the exchange Initiator is waiting for a response, the Initiator MUST retransmit its request over this connection and continue to wait for a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Exchangeイニシエーターが応答を待っている間にIKE SAの新しいTCP接続が確立された場合、イニシエーターはこの接続を介して要求を再送信し、応答を待ち続ける必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The exchange Responder does not change its behavior, but acts as described in Section 2.1 of [RFC7296].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Exchange Responderはその動作を変更しませんが、[RFC7296]のセクション2.1で説明されているように機能します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(*) This is an optimization; implementations may continue to use the retransmission logic from Section 2.1 of [RFC7296] for simplicity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（*）これは最適化です。実装は、簡単にするために[RFC7296]のセクション2.1からの再送信ロジックを引き続き使用する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3--Cookies-and-Puzzles">
6.3. Cookies and Puzzles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. クッキーとパズル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEv2 provides a DoS attack protection mechanism through Cookies, which is described in Section 2.6 of [RFC7296]. [RFC8019] extends this mechanism for protection against DDoS attacks by means of Client Puzzles. Both mechanisms allow the Responder to avoid keeping state until the Initiator proves its IP address is legitimate (and after solving a puzzle if required).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEV2は、[RFC7296]のセクション2.6で説明されているCookieを介してDOS攻撃保護メカニズムを提供します。[RFC8019]は、クライアントパズルを使用して、DDOS攻撃に対する保護のためのこのメカニズムを拡張します。どちらのメカニズムでも、イニシエーターがIPアドレスが合法であることを証明するまで（そして必要に応じてパズルを解く後）、レスポンダーが状態を維持することを避けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The connection-oriented nature of TCP transport brings additional considerations for using these mechanisms. In general, Cookies provide less value in the case of TCP encapsulation; by the time a Responder receives the IKE_SA_INIT request, the TCP session has already been established and the Initiator&#39;s IP address has been verified. Moreover, a TCP/IP stack creates state once a TCP SYN packet is received (unless SYN Cookies described in [RFC4987] are employed), which contradicts the statelessness of IKEv2 Cookies. In particular, with TCP, an attacker is able to mount a SYN flooding DoS attack that an IKEv2 Responder cannot prevent using stateless IKEv2 Cookies. Thus, when using TCP encapsulation, it makes little sense to send Cookie requests without Puzzles unless the Responder is concerned with a possibility of TCP sequence number attacks (see [RFC6528] and [RFC9293] for details). Puzzles, on the other hand, still remain useful (and their use requires using Cookies).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP輸送の接続指向の性質は、これらのメカニズムを使用するための追加の考慮事項をもたらします。一般に、TCPカプセル化の場合、Cookieは価値が低くなります。レスポンダーがIKE_SA_INITリクエストを受信するまでに、TCPセッションはすでに確立されており、イニシエーターのIPアドレスが検証されています。さらに、TCP/IPスタックは、TCP Synパケットが受信されると状態を作成します（[RFC4987]で説明されているSyn Cookieが使用されない限り）。特に、TCPを使用すると、攻撃者はIKEV2レスポンダーがStateless IKEV2 Cookieの使用を防ぐことができないSyn Flooding DOS攻撃を取り付けることができます。したがって、TCPカプセル化を使用する場合、詳細については、ResponderがTCPシーケンス数攻撃の可能性に関係しない限り、パズルなしでCookieリクエストを送信することはほとんど意味がありません（詳細については[RFC6528]および[RFC9293]）。一方、パズルはまだ有用なままです（そして、それらの使用にはCookieを使用する必要があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following considerations are applicable for using Cookie and Puzzle mechanisms in the case of TCP encapsulation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の考慮事項は、TCPカプセル化の場合にCookieおよびPuzzleメカニズムの使用に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The exchange Responder SHOULD NOT send an IKEv2 Cookie request without an accompanied Puzzle; implementations might choose to have exceptions to this for cases like mitigating TCP sequence number attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Exchange Responderは、パズルに付随することなくIKEV2 Cookieリクエストを送信しないでください。実装は、TCPシーケンス番号攻撃を軽減するなどのケースについて、これに例外を持つことを選択する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If the Responder chooses to send a Cookie request (possibly along with Puzzle request), then the TCP connection that the IKE_SA_INIT request message was received over SHOULD be closed after the Responder sends its reply and no repeated requests are received within some short period of time to keep the Responder stateless (see Section 6.3.1). Note that the Responder MUST NOT include the Initiator&#39;s TCP port into the Cookie calculation (*) since the Cookie can be returned over a new TCP connection with a different port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ResponderがCookieリクエストを送信することを選択した場合（おそらくパズルリクエストとともに）、IKE_SA_INITリクエストメッセージが受信されたTCP接続は、応答者が返信を送信した後、閉じる必要があります。レスポンダーをステートレスに保つには（セクション6.3.1を参照）。Cookieは、Cookieを別のポートとの新しいTCP接続で返すことができるため、ResponderはCookie計算（*）にイニシエーターのTCPポートを含めてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The exchange Initiator acts as described in Section 2.6 of [RFC7296] and Section 7 of [RFC8019], i.e., using TCP encapsulation doesn&#39;t change the Initiator&#39;s behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Exchangeイニシエーターは、[RFC7296]のセクション2.6および[RFC8019]のセクション7で説明されているように機能します。つまり、TCPカプセル化を使用しても、イニシエーターの動作は変わりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(*) Examples of Cookie calculation methods are given in Section 2.6 of [RFC7296] and in Section 7.1.1.3 of [RFC8019], and they don&#39;t include transport protocol ports. However, these examples are given for illustrative purposes since the Cookie generation algorithm is a local matter and some implementations might include port numbers that won&#39;t work with TCP encapsulation. Note also that these examples include the Initiator&#39;s IP address in Cookie calculation. In general, this address may change between two initial requests (with and without Cookies). This may happen due to NATs, which have more freedom to change source IP addresses for new TCP connections than for UDP. In such cases, cookie verification might fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（*）Cookie計算方法の例は、[RFC7296]のセクション2.6および[RFC8019]のセクション7.1.1.3に示されており、輸送プロトコルポートは含まれていません。ただし、Cookie Generation Algorithmはローカルな問題であり、いくつかの実装にはTCPカプセル化では機能しないポート番号が含まれる場合があるため、これらの例は説明的な目的で示されています。また、これらの例には、Cookie計算におけるイニシエーターのIPアドレスが含まれていることにも注意してください。一般に、このアドレスは2つの初期リクエスト（Cookieの有無にかかわらず）間で変更される場合があります。これは、UDPよりも新しいTCP接続のソースIPアドレスを変更する自由があるNATのために発生する可能性があります。そのような場合、Cookieの検証は失敗する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3-1--Statelessness-versus-Delay-of-SA-Establishment">
6.3.1. Statelessness versus Delay of SA Establishment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. SA施設のステートレスと遅延
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is a trade-off in choosing the period of time after which the TCP connection is closed. If it is too short, then the proper Initiator that repeats its request would need to re-establish the TCP connection, introducing additional delay. On the other hand, if it is too long, then the Responder&#39;s resources would be wasted in case the Initiator never comes back. This document doesn&#39;t mandate the duration of time because it doesn&#39;t affect interoperability, but it is believed that 5-10 seconds is a good compromise. Also, note that if the Responder requests that the Initiator solve a puzzle, then the Responder can estimate how long it would take the Initiator to find a solution and adjust the time interval accordingly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP接続が閉じられた後の期間を選択する際にトレードオフがあります。短すぎる場合、要求を繰り返す適切なイニシエーターは、TCP接続を再確立し、追加の遅延を導入する必要があります。一方、長すぎると、イニシエーターが戻ってこない場合に備えて、レスポンダーのリソースが無駄になります。このドキュメントは、相互運用性に影響しないため、期間を義務付けませんが、5〜10秒は良い妥協であると考えられています。また、Responderがイニシエーターがパズルを解くように要求した場合、レスポンダーはイニシエーターがソリューションを見つけてそれに応じて時間間隔を調整するのにどれだけ時間がかかるかを推定できることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4--Error-Handling-in-IKESAINIT">
6.4. Error Handling in IKE_SA_INIT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. ike_sa_initでのエラー処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 2.21.1 of [RFC7296] describes how error notifications are handled in the IKE_SA_INIT exchange. In particular, it is advised that the Initiator should not act immediately after receiving an error notification; instead, it should wait some time for a valid response since the IKE_SA_INIT messages are completely unauthenticated. This advice does not apply equally in the case of TCP encapsulation. If the Initiator receives a response message over TCP, then either this message is genuine and was sent by the peer or the TCP session was hijacked and the message is forged. In the latter case, no genuine messages from the Responder will be received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7296]のセクション2.21.1では、IKE_SA_INIT Exchangeでエラー通知がどのように処理されるかについて説明します。特に、エラー通知を受け取った後すぐにイニシエーターが行動すべきではないことをお勧めします。代わりに、IKE_SA_INITメッセージは完全に認識されていないため、有効な応答がある時間を待つ必要があります。このアドバイスは、TCPカプセル化の場合に等しく適用されません。イニシエーターがTCPを介して応答メッセージを受信した場合、このメッセージは本物であり、ピアによって送信されたか、TCPセッションがハイジャックされ、メッセージが偽造されます。後者の場合、レスポンダーからの本物のメッセージは受信されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, in the case of TCP encapsulation, an Initiator SHOULD NOT wait for additional messages in case it receives an error notification from the Responder in the IKE_SA_INIT exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、TCPカプセル化の場合、IKE_SA_INIT ExchangeのResponderからエラー通知を受け取った場合、イニシエーターは追加のメッセージを待つべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the IKE_SA_INIT exchange, if the Responder returns an error notification that implies a recovery action from the Initiator (such as INVALID_KE_PAYLOAD or INVALID_MAJOR_VERSION, see Section 2.21.1 of [RFC7296]), then the Responder SHOULD NOT close the TCP connection immediately in anticipation of the fact that the Initiator will repeat the request with corrected parameters. See also Section 6.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKE_SA_INIT Exchangeでは、Responderがイニシエーターからの回復アクション（Invalid_Ke_PayloadやInvalid_major_versionなどのエラー通知を返す場合、[RFC7296]のセクション2.21.1を参照）、レスポンダーはすぐにTCPの接続を閉じることはできません。イニシエーターが修正されたパラメーターでリクエストを繰り返すという事実。セクション6.3も参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-5--NAT-Detection-Payloads">
6.5. NAT-Detection Payloads
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. NAT検出ペイロード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When negotiating over UDP, IKE_SA_INIT packets include NAT_DETECTION_SOURCE_IP and NAT_DETECTION_DESTINATION_IP payloads to determine if UDP encapsulation of IPsec packets should be used. These payloads contain SHA-1 digests of the SPIs, IP addresses, and ports as defined in [RFC7296]. IKE_SA_INIT packets sent on a TCP connection SHOULD include these payloads with the same content as when sending over UDP and SHOULD use the applicable TCP ports when creating and checking the SHA-1 digests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPを介して交渉する場合、IKE_SA_INITパケットにはNAT_DETECTION_SOURCE_IPおよびNAT_DETECTION_DESTINATION_IPペイロードが含まれて、IPSECパケットのUDPカプセル化を使用するかどうかを判断します。これらのペイロードには、[RFC7296]で定義されているSPIS、IPアドレス、およびポートのSHA-1ダイジェストが含まれています。TCP接続で送信されるIKE_SA_INITパケットは、UDPを送信するときと同じコンテンツを持つこれらのペイロードを含める必要があり、SHA-1ダイジェストを作成およびチェックするときに該当するTCPポートを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a NAT is detected due to the SHA-1 digests not matching the expected values, no change should be made for encapsulation of subsequent IKE or ESP packets since TCP encapsulation inherently supports NAT traversal. However, for the transport mode IPsec SAs, implementations need to handle TCP and UDP packet checksum fixup during decapsulation, as defined for UDP encapsulation in [RFC3948].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHA-1消化が期待値と一致しないためにNATが検出された場合、TCPカプセルがNATトラバーサルを本質的にサポートするため、後続のIKEまたはESPパケットのカプセル化に変更を加える必要はありません。ただし、輸送モードIPSEC SASの場合、[RFC3948]のUDPカプセル化のために定義されているように、脱カプセル化中のTCPおよびUDPパケットチェックサムの修正を実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MAY use the information that a NAT is present to influence keepalive timer values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装では、NATが存在する情報を使用して、Keepalive Timerの値に影響を与える場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-6--NAT-Keepalive-Packets">
6.6. NAT-Keepalive Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6. Nat-Keepaliveパケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encapsulating IKE and IPsec inside of a TCP connection can impact the strategy that implementations use to maintain middlebox port mappings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP接続内のIKEとIPSECのカプセル化は、実装がミドルボックスポートマッピングを維持するために使用する戦略に影響を与える可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, TCP port mappings are maintained by NATs longer than UDP port mappings, so IPsec ESP NAT-keepalive packets [RFC3948] SHOULD NOT be sent when using TCP encapsulation. Any implementation using TCP encapsulation MUST silently drop incoming NAT-keepalive packets and not treat them as errors. NAT-keepalive packets over a TCP-encapsulated IPsec connection will be sent as a 1-octet-long payload with the value 0xFF, preceded by the 2-octet Length specifying a length of 3 (since it includes the length of the Length field).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般に、TCPポートマッピングはUDPポートマッピングよりも長いNATによって維持されているため、TCPカプセル化を使用している場合はIPSEC ESP NAT-Keepaliveパケット[RFC3948]を送信しないでください。TCPカプセル化を使用した実装では、入ってくるNat-Keepaliveパケットを静かにドロップし、それらをエラーとして扱わない必要があります。TCPにカプセル化されたIPSEC接続を介したNat-Keepaliveパケットは、3の長さを指定する2オクセットの長さがある値0xffで1オクセットのペイロードとして送信されます（長さフィールドの長さが含まれるため）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-7--Dead-Peer-Detection-and-Transport-Keepalives">
6.7. Dead Peer Detection and Transport Keepalives
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7. 死んだピア検出と輸送キープライブ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peer liveness should be checked using IKE informational packets [RFC7296].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKE情報パケット[RFC7296]を使用して、ピアライブスをチェックする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that, depending on the configuration of TCP and TLS on the connection, TCP keep-alives [RFC1122] and TLS keep-alives [RFC6520] MAY be used. These MUST NOT be used as indications of IKE peer liveness, for which purpose the standard IKEv2 mechanism of exchanging (usually empty) INFORMATIONAL messages is used (see Section 1.4 of [RFC7296]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続上のTCPおよびTLSの構成に応じて、TCP Keep-Alives [RFC1122]およびTLS Keep-Alives [RFC6520]が使用される場合があることに注意してください。これらは、IKEピアリンシーの適応として使用してはなりません。目的のために、情報メッセージの交換（通常は空）の標準IKEV2メカニズムが使用されます（[RFC7296]のセクション1.4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-8--Implications-of-TCP-Encapsulation-on-IPsec-SA-Processing">
6.8. Implications of TCP Encapsulation on IPsec SA Processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.8. IPSEC SA処理に対するTCPカプセル化の意味
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using TCP encapsulation affects some aspects of IPsec SA processing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPカプセル化を使用すると、IPSEC SA処理のいくつかの側面に影響します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Section 8.1 of [RFC4301] requires all tunnel mode IPsec SAs to be able to copy the Don&#39;t Fragment (DF) bit from inner IPv4 header to the outer (tunnel) one. With TCP encapsulation, this is generally not possible because the TCP/IP stack manages the DF bit in the outer IPv4 header, and usually the stack ensures that the DF bit is set for TCP packets to avoid IP fragmentation. Note, that this behavior is compliant with generic tunneling considerations since the outer TCP header acts as a link-layer protocol and its fragmentation and reassembly have no correlation with the inner payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. [RFC4301]のセクション8.1では、すべてのトンネルモードIPSEC SASが、内側のIPv4ヘッダーから外側（トンネル）のヘッダーにdot fragment（df）ビットをコピーできるようにする必要があります。TCPカプセル化では、TCP/IPスタックが外側のIPv4ヘッダーのDFビットを管理し、通常はSTACKがDFビットがTCPパケットに設定されてIP断片化を回避することを保証するため、これは一般に不可能です。外側のTCPヘッダーはリンク層プロトコルとして機能し、その断片化と再組み立ては内部ペイロードとの相関関係がないため、この動作は一般的なトンネルの考慮事項に準拠していることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The other feature that is less applicable with TCP encapsulation is an ability to split traffic of different QoS classes into different IPsec SAs, created by a single IKE SA. In this case, the Differentiated Services Code Point (DSCP) field is usually copied from the inner IP header to the outer (tunnel) one, ensuring that IPsec traffic of each SA receives the corresponding level of service. With TCP encapsulation, all IPsec SAs created by a single IKE SA will share a single TCP connection; thus, they will receive the same level of service (see Section 9.3). If this functionality is needed, implementations should create several IKE SAs each over separate TCP connections and assign a corresponding DSCP value to each of them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. TCPカプセル化ではあまり適用できない他の機能は、異なるQoSクラスのトラフィックを単一のIKE SAによって作成された異なるIPSEC SASに分割する機能です。この場合、差別化されたサービスコードポイント（DSCP）フィールドは通常、内側のIPヘッダーから外側（トンネル）のフィールドにコピーされ、各SAのIPSECトラフィックが対応するサービスレベルを受信するようにします。TCPカプセル化により、単一のIKESAによって作成されたすべてのIPSEC SASは、単一のTCP接続を共有します。したがって、彼らは同じレベルのサービスを受け取ります（セクション9.3を参照）。この機能が必要な場合、実装は、個別のTCP接続でそれぞれ複数のIKE SASを作成し、それぞれに対応するDSCP値を割り当てる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP encapsulation of IPsec packets may have implications on performance of the encapsulated traffic. Performance considerations are discussed in Section 9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPSECパケットのTCPカプセル化は、カプセル化されたトラフィックのパフォーマンスに影響を与える可能性があります。パフォーマンスの考慮事項については、セクション9で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Interaction-with-IKEv2-Extensions">
7. Interaction with IKEv2 Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. IKEV2拡張機能との相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1--MOBIKE-Protocol">
7.1. MOBIKE Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Mobikeプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MOBIKE protocol, which allows SAs to migrate between IP addresses, is defined in [RFC4555]; [RFC4621] further clarifies the details of the protocol. When an IKE session that has negotiated MOBIKE is transitioning between networks, the Initiator of the transition may switch between using TCP encapsulation, UDP encapsulation, or no encapsulation. Implementations that implement both MOBIKE and TCP encapsulation within the same connection configuration MUST support dynamically enabling and disabling TCP encapsulation as interfaces change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SASがIPアドレス間で移行できるようにするMobikeプロトコルは、[RFC4555]で定義されています。[RFC4621]は、プロトコルの詳細をさらに明確にします。Mobikeを交渉したIKEセッションがネットワーク間で移行している場合、遷移のイニシエーターは、TCPカプセル化、UDPカプセル化、またはカプセル化なしの間を切り替えることができます。同じ接続構成内でMobikeとTCPの両方のカプセル化を実装する実装は、インターフェイスが変更されるにつれてTCPカプセル化を動的に有効にし、無効にすることをサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a MOBIKE-enabled Initiator changes networks, the INFORMATIONAL exchange with the UPDATE_SA_ADDRESSES notification SHOULD be initiated first over UDP before attempting over TCP. If there is a response to the request sent over UDP, then the ESP packets should be sent directly over IP or over UDP port 4500 (depending on if a NAT was detected), regardless of if a connection on a previous network was using TCP encapsulation. If no response is received within a certain period of time after several retransmissions, the Initiator ought to change its transport for this exchange from UDP to TCP and resend the request message. A new INFORMATIONAL exchange MUST NOT be started in this situation. If the Responder only responds to the request sent over TCP, then the ESP packets should be sent over the TCP connection, regardless of if a connection on a previous network did not use TCP encapsulation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mobike対応のイニシエーターがネットワークを変更する場合、TCPを介して試行する前に、UDPを介して最初にUPDATE_SA_ADDRESSES通知との情報交換を開始する必要があります。UDPを介して送信されたリクエストへの応答がある場合、ESPパケットは、以前のネットワークの接続がTCPカプセル化を使用しているかどうかに関係なく、IPまたはUDPポート4500に直接送信する必要があります（NATが検出されたかどうかによって異なります）。いくつかの再送信後の特定の期間内に応答がない場合、イニシエーターはこの交換の輸送をUDPからTCPに変更し、リクエストメッセージを再送信する必要があります。この状況では、新しい情報交換を開始してはなりません。ResponderがTCPを介して送信された要求にのみ応答する場合、以前のネットワーク上の接続がTCPカプセル化を使用しなかったかどうかに関係なく、ESPパケットをTCP接続を介して送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value of the timeout and the specific number of retransmissions before switching to TCP can vary depending on the Initiator&#39;s configuration. Implementations ought to provide reasonable defaults to ensure that UDP attempts have a chance to succeed, but can shorten the timeout based on historical data or metrics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPに切り替える前のタイムアウトの値と特定の再送信数は、イニシエーターの構成によって異なる場合があります。実装は、UDPの試みに成功する機会があることを保証するために、合理的なデフォルトを提供する必要がありますが、履歴データまたはメトリックに基づいてタイムアウトを短縮できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the TCP transport was used for the previous network connection, the old TCP connection SHOULD be closed by the Initiator once MOBIKE finishes migration to a new connection (either TCP or UDP).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPトランスポートが以前のネットワーク接続に使用された場合、Mobikeが新しい接続（TCPまたはUDPのいずれか）に移行すると、イニシエーターによって古いTCP接続を閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since switching from UDP to TCP can happen during a single INFORMATIONAL message exchange, the content of the NAT_DETECTION_*_IP notifications will in most cases be incorrect (since UDP and TCP ports will most likely be different), and the peer may incorrectly detect the presence of a NAT. Section 3.5 of [RFC4555] states that a new INFORMATIONAL exchange with the UPDATE_SA_ADDRESSES notify is initiated in case the address (or transport) is changed while waiting for a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPからTCPへの切り替えは、単一の情報メッセージ交換中に発生する可能性があるため、NAT_DETECTION _*_ IP通知のコンテンツはほとんど間違っています（UDPとTCPポートはおそらく異なるため）。ナットの。[RFC4555]のセクション3.5は、応答を待っている間に住所（または輸送）が変更された場合に備えて、更新_SA_ADDRESSES通知との新しい情報交換が開始されることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 3.5 of [RFC4555] also states that once an IKE SA is switched to a new IP address, all outstanding requests in this SA are immediately retransmitted using this address. See also Section 6.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4555]のセクション3.5は、IKE SAが新しいIPアドレスに切り替えると、このSAのすべての未解決のリクエストがこのアドレスを使用してすぐに再送信されることも述べています。セクション6.2も参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MOBIKE protocol defines the NO_NATS_ALLOWED notification that can be used to detect the presence of NAT between peer and to refuse to communicate in this situation. In the case of TCP, the NO_NATS_ALLOWED notification SHOULD be ignored because TCP generally has no problems with NAT boxes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mobikeプロトコルは、ピアとこの状況でのコミュニケーションを拒否するためにNATの存在を検出するために使用できるNO_NATS_ALLOWED通知を定義します。TCPの場合、TCPには一般にNATボックスに問題がないため、NO_NATS_ALLOWED通知は無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 3.7 of [RFC4555] describes an additional optional step in the process of changing IP addresses called &#34;Return Routability Check&#34;. It is performed by Responders in order to be sure that the new Initiator&#39;s address is, in fact, routable. In the case of TCP encapsulation, this check has little value since a TCP handshake proves the routability of the TCP Originator&#39;s address; thus, the Return Routability Check SHOULD NOT be performed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4555]のセクション3.7では、「Return Routability Check」と呼ばれるIPアドレスを変更するプロセスにおける追加のオプションステップについて説明します。新しいイニシエーターのアドレスが実際にルーティング可能であることを確認するために、レスポンダーによって実行されます。TCPカプセル化の場合、TCPハンドシェイクがTCPオリジネーターのアドレスのルー上の可能性を証明するため、このチェックはほとんど価値がありません。したがって、Return Routability Checkを実行しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-2--IKE-Redirect">
7.2. IKE Redirect
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Ike Redirect
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A redirect mechanism for IKEv2 is defined in [RFC5685]. This mechanism allows security gateways to redirect clients to another gateway either during IKE SA establishment or after session setup. If a client is connecting to a security gateway using TCP and then is redirected to another security gateway, the client needs to reset its transport selection. In other words, with the next security gateway, the client MUST first try UDP and then fall back to TCP while establishing a new IKE SA, regardless of the transport of the SA the redirect notification was received over (unless the client&#39;s configuration instructs it to instantly use TCP for the gateway it is redirected to).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEV2のリダイレクトメカニズムは[RFC5685]で定義されています。このメカニズムにより、セキュリティゲートウェイは、IKE SAの設立中またはセッションのセットアップ後、クライアントを別のゲートウェイにリダイレクトできます。クライアントがTCPを使用してセキュリティゲートウェイに接続していて、別のセキュリティゲートウェイにリダイレクトされている場合、クライアントは輸送選択をリセットする必要があります。言い換えれば、次のセキュリティゲートウェイにより、クライアントは最初にUDPを試してから、SAの輸送に関係なく、新しいIKE SAの確立中にTCPに戻る必要があります。リダイレクトされるゲートウェイには、すぐにTCPを使用します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-3--IKEv2-Session-Resumption">
7.3. IKEv2 Session Resumption
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. IKEV2セッション再開
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Session resumption for IKEv2 is defined in [RFC5723]. Once an IKE SA is established, the server creates a resumption ticket where information about this SA is stored and transfers this ticket to the client. The ticket may be later used to resume the IKE SA after it is deleted. In the event of resumption, the client presents the ticket in a new exchange, called IKE_SESSION_RESUME. Some parameters in the new SA are retrieved from the ticket and others are renegotiated (more details are given in Section 5 of [RFC5723]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEV2のセッション再開は、[RFC5723]で定義されています。IKE SAが確立されると、サーバーはこのSAに関する情報が保存され、このチケットをクライアントに転送する再開チケットを作成します。チケットは、削除された後にIKE SAを再開するために後で使用できます。再開の場合、クライアントはIKE_SESSION_RESUMEと呼ばれる新しい交換でチケットを提示します。新しいSAの一部のパラメーターはチケットから取得され、他のパラメーターは再交渉されます（詳細は[RFC5723]のセクション5に記載されています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since network conditions may change while the client is inactive, the fact that TCP encapsulation was used in an old SA SHOULD NOT affect which transport is used during session resumption. In other words, the transport should be selected as if the IKE SA is being created from scratch.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが非アクティブである間にネットワーク条件が変化する可能性があるため、古いSAでTCPカプセル化が使用されたという事実は、セッション再開中に使用される輸送に影響しないはずです。言い換えれば、IKE SAがゼロから作成されているかのように、輸送を選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-4--IKEv2-Protocol-Support-for-High-Availability">
7.4. IKEv2 Protocol Support for High Availability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. IKEV2プロトコルは、高可用性をサポートしています
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6311] defines a support for High Availability in IKEv2. In case of cluster failover, a new active node must immediately initiate a special INFORMATION exchange containing the IKEV2_MESSAGE_ID_SYNC notification, which instructs the client to skip some number of Message IDs that might not be synchronized yet between nodes at the time of failover.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6311]は、IKEV2での高可用性のサポートを定義しています。クラスターフェールオーバーの場合、新しいアクティブノードは、IKEV2_MESSAGE_ID_SYNC通知を含む特別な情報交換を直ちに開始する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Synchronizing states when using TCP encapsulation is much harder than when using UDP; doing so requires access to TCP/IP stack internals, which is not always available from an IKE/IPsec implementation. If a cluster implementation doesn&#39;t synchronize TCP states between nodes, then after failover event the new active node will not have any TCP connection with the client, so the node cannot initiate the INFORMATIONAL exchange as required by [RFC6311]. Since the cluster usually acts as TCP Responder, the new active node cannot re-establish TCP connection because only the TCP Originator can do it. For the client, the cluster failover event may remain undetected for long time if it has no IKE or ESP traffic to send. Once the client sends an ESP or IKEv2 packet, the cluster node will reply with TCP RST and the client (as TCP Originator) will reestablish the TCP connection so that the node will be able to initiate the INFORMATIONAL exchange informing the client about the cluster failover.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPカプセル化を使用する場合の状態の同期は、UDPを使用する場合よりもはるかに困難です。そうするには、IKE/IPSECの実装から常に利用できるとは限らないTCP/IPスタック内部へのアクセスが必要です。クラスターの実装がノード間でTCP状態を同期しない場合、フェールオーバーイベントの後、新しいアクティブノードにクライアントとのTCP接続がありません。したがって、ノードは[RFC6311]の要求に応じて情報交換を開始できません。クラスターは通常TCPレスポンダーとして機能するため、TCPオリジナーターのみが実行できるため、新しいアクティブノードはTCP接続を再確立できません。クライアントの場合、IKEやESPトラフィックがない場合、クラスターフェールオーバーイベントは長期間検出されないままになる場合があります。クライアントがESPまたはIKEV2パケットを送信すると、クラスターノードはTCP RSTで応答し、クライアント（TCPオリジネーターとして）がTCP接続を再確立し、ノードがクラスターフェールオーバーについてクライアントに通知する情報交換を開始できるようにします。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document makes the following recommendation: if support for High Availability in IKEv2 is negotiated and TCP transport is used, a client that is a TCP Originator SHOULD periodically send IKEv2 messages (e.g., by initiating liveness check exchange) whenever there is no IKEv2 or ESP traffic. This differs from the recommendations given in Section 2.4 of [RFC7296] in the following: the liveness check should be periodically performed even if the client has nothing to send over ESP. The frequency of sending such messages should be high enough to allow quick detection and restoration of broken TCP connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは次の推奨事項を作成します。IKEV2での高可用性のサポートがネゴシエートされ、TCPトランスポートが使用されている場合、TCPオリジネーターであるクライアントは、IKEV2またはESPがない場合はいつでもIKEV2メッセージを定期的に送信する必要があります（例えば、活性チェック交換を開始することにより）。トラフィック。これは、[RFC7296]のセクション2.4に記載されている推奨事項とは異なります。クライアントがESPに送信するものがない場合でも、livensionチェックは定期的に実行する必要があります。そのようなメッセージを送信する頻度は、壊れたTCP接続の迅速な検出と回復を可能にするのに十分な高さでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-5--IKEv2-Fragmentation">
7.5. IKEv2 Fragmentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. IKEV2断片化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKE message fragmentation [RFC7383] is not required when using TCP encapsulation since a TCP stream already handles the fragmentation of its contents across packets. Since fragmentation is redundant in this case, implementations might choose to not negotiate IKE fragmentation. Even if fragmentation is negotiated, an implementation SHOULD NOT send fragments when going over a TCP connection, although it MUST support receiving fragments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPストリームはすでにパケット間の内容の断片化を処理しているため、TCPカプセル化を使用する場合、IKEメッセージの断片化[RFC7383]は必要ありません。この場合、断片化は冗長であるため、実装はIKEの断片化と交渉しないことを選択する場合があります。断片化が交渉されたとしても、実装はTCP接続を介して断片を送信するべきではありませんが、受信フラグメントをサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an implementation supports both MOBIKE and IKE fragmentation, it SHOULD negotiate IKE fragmentation over a TCP-encapsulated session in case the session switches to UDP encapsulation on another network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装がMobikeとIKEの断片化の両方をサポートする場合、セッションが別のネットワーク上のUDPカプセル化に切り替えた場合に備えて、TCPでカプセル化されたセッションでIKEの断片化を交渉する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Middlebox-Considerations">
8. Middlebox Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. ミドルボックスの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many security networking devices, such as firewalls or intrusion prevention systems, network optimization/acceleration devices, and NAT devices, keep the state of sessions that traverse through them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイアウォールや侵入防止システム、ネットワークの最適化/加速デバイス、NATデバイスなどの多くのセキュリティネットワーキングデバイスは、それらを通過するセッションの状態を維持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These devices commonly track the transport-layer and/or application-layer data to drop traffic that is anomalous or malicious in nature. While many of these devices will be more likely to pass TCP-encapsulated traffic as opposed to UDP-encapsulated traffic, some may still block or interfere with TCP-encapsulated IKE and IPsec traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのデバイスは一般に、輸送層および/またはアプリケーション層データを追跡して、本質的に異常または悪意のあるトラフィックをドロップします。これらのデバイスの多くは、UDPがカプセル化されたトラフィックとは対照的に、TCPにカプセル化されたトラフィックを通過する可能性が高くなりますが、TCPがカプセル化されたIKEおよびIPSECトラフィックをブロックまたは妨害する人もいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A network device that monitors the transport layer will track the state of TCP sessions, such as TCP sequence numbers. If the IKE implementation has its own minimal implementation of TCP, it SHOULD still use common TCP behaviors to avoid being dropped by middleboxes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輸送層を監視するネットワークデバイスは、TCPシーケンス番号などのTCPセッションの状態を追跡します。IKE実装にTCPの独自の最小限の実装がある場合、中間ボックスによって削除されないように一般的なTCP動作を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Operators that intentionally block IPsec because of security implications might want to also block TCP port 4500 or use other methods to reject TCP encapsulated IPsec traffic (e.g., filter out TCP connections that begin with the &#34;IKETCP&#34; stream prefix).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティの影響のために意図的にIPSECをブロックするオペレーターは、TCPポート4500をブロックするか、他の方法を使用してTCPカプセル化されたIPSECトラフィックを拒否したい場合があります（たとえば、「iketCP」ストリームのプレフィックスで始まるTCP接続を除外します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--Performance-Considerations">
9. Performance Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. パフォーマンスに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several aspects of TCP encapsulation for IKE and IPsec packets may negatively impact the performance of connections within a tunnel-mode IPsec SA. Implementations should be aware of these performance impacts and take these into consideration when determining when to use TCP encapsulation. Implementations MUST favor using direct ESP or UDP encapsulation over TCP encapsulation whenever possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEおよびIPSECパケットのTCPカプセル化のいくつかの側面は、トンネルモードIPSEC SA内の接続のパフォーマンスに悪影響を与える可能性があります。実装は、これらのパフォーマンスへの影響を認識し、TCPカプセル化を使用するタイミングを決定する際にこれらを考慮に入れる必要があります。実装は、可能な限りTCPカプセル化を介した直接的なESPまたはUDPカプセル化を使用することを支持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1--TCP-in-TCP">
9.1. TCP-in-TCP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. TCP-in-TCP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the outer connection between IKE peers is over TCP, inner TCP connections may suffer negative effects from using TCP within TCP. Running TCP within TCP is discouraged since the TCP algorithms generally assume that they are running over an unreliable datagram layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEピア間の外側の接続がTCPを超えている場合、内側のTCP接続はTCP内でTCPを使用することで悪影響を受ける可能性があります。TCPアルゴリズムは一般に、信頼できないデータグラムレイヤーを実行していると想定しているため、TCP内でTCPを実行することは落胆します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the outer (tunnel) TCP connection experiences packet loss, this loss will be hidden from any inner TCP connections since the outer connection will retransmit to account for the losses. Since the outer TCP connection will deliver the inner messages in order, any messages after a lost packet may have to wait until the loss is recovered. This means that loss on the outer connection will be interpreted only as delay by inner connections. The burstiness of inner traffic can increase since a large number of inner packets may be delivered across the tunnel at once. The inner TCP connection may interpret a long period of delay as a transmission problem, triggering a retransmission timeout, which will cause spurious retransmissions. The sending rate of the inner connection may be unnecessarily reduced if the retransmissions are not detected as spurious in time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
外側（トンネル）TCP接続がパケットの損失を経験した場合、外側の接続が損失を考慮して再送信するため、この損失は内部のTCP接続から隠されます。外側のTCP接続は内側のメッセージを順番に配信するため、紛失したパケットの後のメッセージは、損失が回復するまで待つ必要があります。これは、外側の接続の損失は、内部接続による遅延としてのみ解釈されることを意味します。多くの内側のパケットがトンネル全体に一度に配信される可能性があるため、内部交通の爆発が増加する可能性があります。内側のTCP接続は、長い期間の遅延を送信問題として解釈し、再送信タイムアウトをトリガーし、それが偽りの再送信を引き起こします。再送信が時間内に偽として検出されない場合、内部接続の送信率は不必要に減少する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The inner TCP connection&#39;s round-trip-time estimation will be affected by the burstiness of the outer TCP connection if there are long delays when packets are retransmitted by the outer TCP connection. This will make the congestion control loop of the inner TCP traffic less reactive, potentially permanently leading to a lower sending rate than the outer TCP would allow for.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
内側のTCP接続の往復時間推定は、外側のTCP接続によってパケットが再送信された場合に長い遅延がある場合、外側のTCP接続の破裂の影響を受けます。これにより、内側のTCPトラフィックの混雑制御ループが反応性を低下させ、潜在的に永続的に送信率が低下するよりも低い送信率につながります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP-in-TCP can also lead to &#34;TCP meltdown&#34;, where stacked instances of TCP can result in significant impacts to performance [TCP-MELTDOWN]. This can occur when losses in the lower TCP (closer to the link) increase delays seen by the higher TCP (closer to the application) that create timeouts, which, in turn, cause retransmissions that can then cause losses in the lower TCP by overrunning its buffer. The very mechanism intended to avoid loss (retransmission) interacts between the two layers to increase loss. To limit this effect, the timeouts of the two TCP layers need to be carefully managed, e.g., such that the higher layer has a much longer timeout than the lower layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP-in-TCPも「TCPメルトダウン」につながる可能性があり、TCPの積み重ねられたインスタンスがパフォーマンスに大きな影響を与える可能性があります[TCP-Meltdown]。これは、より低いTCP（リンクに近い）の損失がタイムアウトを作成するより高いTCP（アプリケーションに近い）で見られる遅延を増加させると発生する可能性があります。そのバッファー。損失（再送信）を回避することを目的としたまさにそのメカニズムは、2つのレイヤー間で相互作用して損失を増加させます。この効果を制限するには、2つのTCPレイヤーのタイムアウトを慎重に管理する必要があります。たとえば、高層が下層よりもはるかに長いタイムアウトを持つようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that any negative effects will be shared among all flows going through the outer TCP connection. This is of particular concern for any latency-sensitive or real-time applications using the tunnel. If such traffic is using a TCP-encapsulated IPsec connection, it is recommended that the number of inner connections sharing the tunnel be limited as much as possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
外側のTCP接続を通過するすべてのフロー間で負の影響が共有されることに注意してください。これは、トンネルを使用した遅延に敏感またはリアルタイムのアプリケーションにとって特に懸念されます。このようなトラフィックがTCPにカプセル化されたIPSEC接続を使用している場合、トンネルを共有する内部接続の数を可能な限り制限することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2--Added-Reliability-for-Unreliable-Protocols">
9.2. Added Reliability for Unreliable Protocols
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 信頼できないプロトコルの信頼性が追加されました
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since ESP is an unreliable protocol, transmitting ESP packets over a TCP connection will change the fundamental behavior of the packets. Some application-level protocols that prefer packet loss to delay (such as Voice over IP or other real-time protocols) may be negatively impacted if their packets are retransmitted by the TCP connection due to packet loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ESPは信頼性の低いプロトコルであるため、TCP接続を介してESPパケットを送信すると、パケットの基本的な動作が変更されます。パケットがパケットの損失により再送信された場合、パケットが遅延（Voice over IPまたはその他のリアルタイムプロトコルなど）を好むいくつかのアプリケーションレベルのプロトコル（Voice over IPまたはその他のリアルタイムプロトコルなど）は、マイナスの影響を受ける可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3--Quality-of-Service-Markings">
9.3. Quality-of-Service Markings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. サービス品質マーキング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Quality-of-Service (QoS) markings, such as the Differentiated Services Code Point (DSCP) and Traffic Class, should be used with care on TCP connections used for encapsulation. Individual packets SHOULD NOT use different markings than the rest of the connection since packets with different priorities may be routed differently and cause unnecessary delays in the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
差別化されたサービスコードポイント（DSCP）やトラフィッククラスなどのサービス品質（QOS）マーキングは、カプセル化に使用されるTCP接続に注意して使用する必要があります。個々のパケットは、異なる優先順位を持つパケットが異なる方法でルーティングされ、接続に不必要な遅延を引き起こす可能性があるため、接続の残りの部分とは異なるマーキングを使用してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4--Maximum-Segment-Size">
9.4. Maximum Segment Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. 最大セグメントサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A TCP connection used for IKE encapsulation SHOULD negotiate its MSS in order to avoid unnecessary fragmentation of packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEカプセル化に使用されるTCP接続は、パケットの不必要な断片化を避けるためにMSSをネゴシエートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-5--Tunneling-ECN-in-TCP">
9.5. Tunneling ECN in TCP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5. TCPのトンネルECN
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since there is not a one-to-one relationship between outer IP packets and inner ESP/IP messages when using TCP encapsulation, the markings for Explicit Congestion Notification (ECN) [RFC3168] cannot easily be mapped. However, any ECN Congestion Experienced (CE) marking on inner headers should be preserved through the tunnel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPカプセル化を使用する場合、外側のIPパケットと内側のESP/IPメッセージの間に1対1の関係がないため、明示的な混雑通知（ECN）[RFC3168]のマーキングは簡単にマッピングできません。ただし、内側のヘッダーで経験した（CE）マークを経験したECN混雑は、トンネルを通して保存する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations SHOULD follow the ECN compatibility mode for tunnel ingress as described in [RFC6040]. In compatibility mode, the outer tunnel TCP connection marks its packet headers as not ECN-capable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6040]で説明されているように、実装はトンネルイングレスのECN互換モードに従う必要があります。互換性モードでは、外側のトンネルTCP接続は、そのパケットヘッダーをECN対応ではないとマークします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon egress, if the arriving outer header is marked with CE, the implementation will drop the inner packet since there is not a distinct inner packet header onto which to translate the ECN markings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出口時に、到着する外側のヘッダーにCEがマークされている場合、ECNマークを翻訳するための明確な内側パケットヘッダーがないため、実装は内側のパケットをドロップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--Security-Considerations">
10. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKE Responders that support TCP encapsulation may become vulnerable to new Denial-of-Service (DoS) attacks that are specific to TCP, such as SYN-flooding attacks. TCP Responders should be aware of this additional attack surface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPカプセル化をサポートするIKE応答者は、Syn-Flooding攻撃など、TCPに固有の新しいサービス拒否（DOS）攻撃に対して脆弱になる可能性があります。TCPレスポンダーは、この追加の攻撃面に注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP connections are also susceptible to RST and other spoofing attacks [RFC4953]. This specification makes IPsec tolerant of sudden TCP connection drops, but if an attacker is able to tear down TCP connections, IPsec connection&#39;s performance can suffer, effectively making this a DoS attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP接続は、RSTおよびその他のスプーフィング攻撃の影響を受けやすい[RFC4953]。この仕様により、IPSECは突然のTCP接続ドロップに許容されますが、攻撃者がTCP接続を取り壊すことができれば、IPSEC接続のパフォーマンスが低下し、これを効果的にDOS攻撃にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP data injection attacks have no effect on application data since IPsec provides data integrity. However, they can have some effect, mostly by creating DoS attacks:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPSECがデータの整合性を提供するため、TCPデータインジェクション攻撃はアプリケーションデータに影響を与えません。ただし、主にDOS攻撃を作成することにより、何らかの効果をもたらすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If an attacker alters the content of the Length field that separates packets, then the Receiver will incorrectly identify the boundaries of the following packets and will drop all of them or even tear down the TCP connection if the content of the Length field happens to be 0 or 1 (see Section 3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 攻撃者がパケットを分離する長さフィールドのコンテンツを変更すると、レシーバーは次のパケットの境界を誤って識別し、それらのすべてをドロップするか、長さフィールドのコンテンツがたまたま0の場合、TCP接続を取り壊しますまたは1（セクション3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If the content of an IKE message is altered, then it will be dropped by the receiver; if the dropped message is the IKE request message, then the Initiator will tear down the IKE SA after some timeout since, in most cases, the request message will not be retransmitted (as advised in Section 6.2); thus, the response will never be received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* IKEメッセージのコンテンツが変更された場合、レシーバーによって削除されます。ドロップされたメッセージがIKEリクエストメッセージである場合、ほとんどの場合、リクエストメッセージは再送信されないため、イケイターはIke SAをいくつかのタイムアウト後に取り壊します（セクション6.2でアドバイスされています）。したがって、応答は決して受信されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If an attacker alters the non-ESP marker, then IKE packets will be dispatched to ESP (and sometimes visa versa) and those packets will be dropped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 攻撃者が非ESPマーカーを変更すると、IKEパケットがESPにディスパッチされ（およびVisa Versa）、それらのパケットがドロップされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If an attacker modifies TCP-Encapsulated stream prefix or unencrypted IKE messages before IKE SA is established, then in most cases this will result in failure to establish IKE SA, often with false &#34;authentication failed&#34; diagnostics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 攻撃者がIKE SAが確立される前にTCPにカプセル化されたストリームプレフィックスまたは暗号化されていないIKEメッセージを変更した場合、ほとんどの場合、これはIKE SAの確立に失敗し、多くの場合、誤った「認証が失敗した」診断を行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5961] discusses how TCP injection attacks can be mitigated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5961]は、TCP注射攻撃を緩和する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that data injection attacks are also possible on IP level (e.g., when IP fragmentation is used), resulting in DoS attacks even if TCP encapsulation is not used. On the other hand, TCP injection attacks are easier to mount than the IP fragmentation injection attacks because TCP keeps a long receive window open that&#39;s a sitting target for such attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ注入攻撃は、IPレベル（例えば、IPフラグメンテーションが使用される場合）でも可能であり、TCPカプセル化が使用されていなくてもDOS攻撃をもたらすことに注意してください。一方、TCPはIPフラグメンテーションインジェクション攻撃よりも、TCPインジェクション攻撃が簡単に取り付けられます。これは、TCPがそのような攻撃の座位ターゲットである長い受信ウィンドウを開いたままにしているためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an attacker successfully mounts an injection attack on a TCP connection used for encapsulating IPsec traffic and modifies a Length field, the receiver might not be able to correctly identify the boundaries of the following packets in the stream since it will try to parse arbitrary data as an ESP or IKE header. After such a parsing failure, all following packets will be dropped. Communication will eventually recover, but this might take several minutes and can result in IKE SA deletion and re-creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者がIPSECトラフィックのカプセル化に使用されるTCP接続に注射攻撃を正常に取り付け、長さフィールドを変更すると、受信者は、任意のデータを解析しようとするため、ストリーム内の次のパケットの境界を正しく識別できない場合があります。ESPまたはIKEヘッダー。このような解析障害の後、すべての次のパケットが削除されます。コミュニケーションは最終的に回復しますが、これには数分かかる可能性があり、IKE SAの削除と再作成につながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To speed up the recovery from such attacks, implementations are advised to follow recommendations in Section 6.1 and close the TCP connection if incoming packets contain SPIs that don&#39;t match any known SAs. Once the TCP connection is closed, it will be re-created by the TCP Originator as described in Section 6.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのような攻撃からの回復をスピードアップするために、実装はセクション6.1の推奨事項に従い、着信パケットに既知のSASと一致しないSPIが含まれている場合はTCP接続を閉じることをお勧めします。TCP接続が閉じられると、セクション6.1で説明されているように、TCPオリジネーターによって再作成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid performance degradation caused by closing and re-creating TCP connections, implementations MAY alternatively try to resync after they receive unknown SPIs by searching the TCP stream for a 64-bit binary vector consisting of a known SPI in the first 32 bits and a valid Sequence Number for this SPI in the second 32 bits. Then, they can validate the Integrity Check Value (ICV) of this packet candidate by taking the preceding 16 bits as the Length field. They can also search for 4 bytes of zero (non-ESP marker) followed by 128 bits of IKE SPIs of the IKE SA(s) associated with this TCP connection and then validate the ICV of this IKE message candidate by taking the 16 bits preceding the non-ESP marker as the Length field. Implementations SHOULD limit the attempts to resync, because if the injection attack is ongoing, then there is a high probability that the resync process will not succeed or will quickly come under attack again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP接続の閉鎖と再作成によって引き起こされるパフォーマンスの劣化を回避するために、実装は、最初の32ビットの既知のSPIで構成される64ビットバイナリベクトルを検索して有効な64ビットバイナリベクトルを検索することにより、不明なSPIを受け取った後に再調整しようとする場合があります2番目の32ビットのこのSPIのシーケンス番号。次に、前の16ビットを長さフィールドとして取得することにより、このパケット候補の整合性チェック値（ICV）を検証できます。また、4バイトのゼロ（非ESPマーカー）を検索し、その後、このTCP接続に関連付けられたIKE SAの128ビットのIKE SPIを検索し、このIKEメッセージ候補のICVを検証して16ビットを取得することで検証できます。長さフィールドとしての非ESPマーカー。インジェクション攻撃が進行している場合、再配置プロセスが成功しないか、すぐに攻撃を受けている可能性が高いため、実装は再調整の試みを制限する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attacker capable of blocking UDP traffic can force peers to use TCP encapsulation, thus, degrading the performance and making the connection more vulnerable to DoS attacks. Note that an attacker that is able to modify packets on the wire or to block them can prevent peers from communicating regardless of the transport being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPトラフィックをブロックできる攻撃者は、ピアにTCPカプセル化を使用するように強制する可能性があり、したがって、パフォーマンスを低下させ、DOS攻撃に対して接続をより脆弱にします。ワイヤー上のパケットを変更したり、それらをブロックしたりできる攻撃者は、使用されている輸送に関係なく、ピアが通信するのを防ぐことができることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP Responders should be careful to ensure that the stream prefix &#34;IKETCP&#34; uniquely identifies incoming streams as streams that use the TCP encapsulation protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPレスポンダーは、ストリームプレフィックス「iketcp」がTCPカプセル化プロトコルを使用するストリームとして着信ストリームを一意に識別するように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Attackers may be able to disrupt the TCP connection by sending spurious TCP Reset packets. Therefore, implementations SHOULD make sure that IKE session state persists even if the underlying TCP connection is torn down.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者は、偽のTCPリセットパケットを送信することにより、TCP接続を破壊できる場合があります。したがって、実装は、基礎となるTCP接続が取り壊された場合でも、IKEセッション状態が持続することを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If MOBIKE is being used, all of the security considerations outlined for MOBIKE apply [RFC4555].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mobikeが使用されている場合、Mobikeが適用されるために概説されているセキュリティに関するすべての考慮事項[RFC4555]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similar to MOBIKE, TCP encapsulation requires a TCP Responder to handle changes to source address and port due to network or connection disruption. The successful delivery of valid new IKE or ESP messages over a new TCP connection is used by the TCP Responder to determine where to send subsequent responses. If an attacker is able to send packets on a new TCP connection that pass the validation checks of the TCP Responder, it can influence which path future packets will take. For this reason, the validation of messages on the TCP Responder must include decryption, authentication, and replay checks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mobikeと同様に、TCPカプセル化では、ネットワークまたは接続の破壊により、ソースアドレスとポートの変更を処理するためにTCPレスポンダーが必要です。新しいTCP接続を介した有効な新しいIKEまたはESPメッセージの配信の成功は、TCP Responderによって使用され、後続の応答を送信する場所を決定します。攻撃者が、TCPレスポンダーの検証チェックに合格する新しいTCP接続でパケットを送信できる場合、将来のパケットがどのパスを使用するかに影響を与える可能性があります。このため、TCPレスポンダーでのメッセージの検証には、復号化、認証、およびリプレイチェックが含まれている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11--IANA-Considerations">
11. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP port 4500 is already allocated to IPsec for NAT traversal in the &#34;Service Name and Transport Protocol Port Number Registry&#34;. This port SHOULD be used for TCP-encapsulated IKE and ESP as described in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPポート4500は、「サービス名と輸送プロトコルポート番号レジストリ」のNATトラバーサルのIPSECにすでに割り当てられています。このポートは、このドキュメントで説明されているように、TCPにカプセル化されたIKEおよびESPに使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document updates the reference for TCP port 4500 from RFC 8229 to itself:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、RFC 8229からTCPポート4500のリファレンスをそれ自体に更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Service Name: ipsec-nat-t Port Number / Transport Protocol: 4500/tcp Description: IPsec NAT-Traversal Reference: RFC 9329
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サービス名：IPSEC-NAT-Tポート番号 /トランスポートプロトコル：4500 / TCP説明：IPSEC NATトラバーサルリファレンス：RFC 9329
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12--References">
12. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-1--Normative-References">
12.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487/RFC2119、1997年3月、&lt;https://www.rfc-editor.org/info/RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3948] Huttunen, A., Swander, B., Volpe, V., DiBurro, L., and M. Stenberg, &#34;UDP Encapsulation of IPsec ESP Packets&#34;, RFC 3948, DOI 10.17487/RFC3948, January 2005, &lt;https://www.rfc-editor.org/info/rfc3948&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3948] Huttunen、A.、Swander、B.、Volpe、V.、Diburro、L。、およびM. Stenberg、「IPSEC ESPパケットのUDPカプセル化」、RFC 3948、DOI 10.17487/RFC3948、2005年1月、&lt;&lt;https：//www.rfc-editor.org/info/rfc3948&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4301] Kent, S. and K. Seo, &#34;Security Architecture for the Internet Protocol&#34;, RFC 4301, DOI 10.17487/RFC4301, December 2005, &lt;https://www.rfc-editor.org/info/rfc4301&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4301] Kent、S。およびK. SEO、「インターネットプロトコルのセキュリティアーキテクチャ」、RFC 4301、DOI 10.17487/RFC4301、2005年12月、&lt;https://www.rfc-editor.org/info/rfc4301&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4303] Kent, S., &#34;IP Encapsulating Security Payload (ESP)&#34;, RFC 4303, DOI 10.17487/RFC4303, December 2005, &lt;https://www.rfc-editor.org/info/rfc4303&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4303] Kent、S。、「セキュリティペイロード（ESP）をカプセル化するIP」、RFC 4303、DOI 10.17487/RFC4303、2005年12月、&lt;https://www.rfc-editor.org/info/rfc4303&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6040] Briscoe, B., &#34;Tunnelling of Explicit Congestion Notification&#34;, RFC 6040, DOI 10.17487/RFC6040, November 2010, &lt;https://www.rfc-editor.org/info/rfc6040&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6040] Briscoe、B。、「明示的な混雑通知のトンネル」、RFC 6040、DOI 10.17487/RFC6040、2010年11月、&lt;https://www.rfc-editor.org/info/rfc6040&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7296] Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T. Kivinen, &#34;Internet Key Exchange Protocol Version 2 (IKEv2)&#34;, STD 79, RFC 7296, DOI 10.17487/RFC7296, October 2014, &lt;https://www.rfc-editor.org/info/rfc7296&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7296] Kaufman、C.、Hoffman、P.、Nir、Y.、Eronen、P.、およびT. Kivinen、「Internet Key Exchange Protocolバージョン2（IKEV2）」、STD 79、RFC 7296、DOI 10.17487/RFC7296、2014年10月、&lt;https://www.rfc-editor.org/info/rfc7296&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8019] Nir, Y. and V. Smyslov, &#34;Protecting Internet Key Exchange Protocol Version 2 (IKEv2) Implementations from Distributed Denial-of-Service Attacks&#34;, RFC 8019, DOI 10.17487/RFC8019, November 2016, &lt;https://www.rfc-editor.org/info/rfc8019&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8019] NIR、Y。およびV. SMYSLOV、「分散拒否拒否攻撃からのインターネットキーエクスチェンジプロトコル2（IKEV2）の実装の保護」、RFC 8019、DOI 10.17487/RFC8019、2016年11月、&lt;https：//www.rfc-editor.org/info/rfc8019&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487/RFC8174、2017年5月、&lt;https：//www.rfc-editor.org/info/RFC8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2--Informative-References">
12.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IPSECME-IKE-TCP] Nir, Y., &#34;A TCP transport for the Internet Key Exchange&#34;, Work in Progress, Internet-Draft, draft-ietf-ipsecme-ike-tcp-01, 3 December 2012, &lt;https://datatracker.ietf.org/doc/html/draft-ietf-ipsecme-ike-tcp-01&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Ipsecme-yike-tcp] nir、Y。、「インターネットキーエクスチェンジのTCPトランスポート」、進行中の作業、インターネットドラフト、ドラフト-ITF-IPSECME-IKE-TCP-01、2012年12月3日、&lt;HTTPS：//datatracker.ietf.org/doc/html/draft-ietf-ipsecme-ike-tcp-01&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122] Braden, R., Ed., &#34;Requirements for Internet Hosts - Communication Layers&#34;, STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, &lt;https://www.rfc-editor.org/info/rfc1122&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122] Braden、R.、ed。、「インターネットホストの要件 - 通信レイヤー」、STD 3、RFC 1122、DOI 10.17487/RFC1122、1989年10月、&lt;https://www.rfc-editor.org/info/RFC1122&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2817] Khare, R. and S. Lawrence, &#34;Upgrading to TLS Within HTTP/1.1&#34;, RFC 2817, DOI 10.17487/RFC2817, May 2000, &lt;https://www.rfc-editor.org/info/rfc2817&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2817] Khare、R。およびS. Lawrence、「HTTP/1.1内のTLSへのアップグレード」、RFC 2817、DOI 10.17487/RFC2817、2000年5月、&lt;https://www.rfc-editor.org/info/rfc2817&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, &#34;The Addition of Explicit Congestion Notification (ECN) to IP&#34;, RFC 3168, DOI 10.17487/RFC3168, September 2001, &lt;https://www.rfc-editor.org/info/rfc3168&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168]ラマクリシュナン、K。、フロイド、S。、およびD.ブラック、「IPへの明示的な混雑通知（ECN）の追加」、RFC 3168、DOI 10.17487/RFC3168、2001年9月、&lt;https：// www。rfc-editor.org/info/rfc3168&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4555] Eronen, P., &#34;IKEv2 Mobility and Multihoming Protocol (MOBIKE)&#34;, RFC 4555, DOI 10.17487/RFC4555, June 2006, &lt;https://www.rfc-editor.org/info/rfc4555&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4555] Eronen、P。、「IKEV2モビリティおよびマルチホームプロトコル（MOBIKE）」、RFC 4555、DOI 10.17487/RFC4555、2006年6月、&lt;https://www.rfc-editor.org/info/RFC4555&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4621] Kivinen, T. and H. Tschofenig, &#34;Design of the IKEv2 Mobility and Multihoming (MOBIKE) Protocol&#34;, RFC 4621, DOI 10.17487/RFC4621, August 2006, &lt;https://www.rfc-editor.org/info/rfc4621&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4621] Kivinen、T。およびH. Tschofenig、「IKEV2モビリティとマルチホミング（Mobike）プロトコルのデザイン」、RFC 4621、DOI 10.17487/RFC4621、2006年8月、&lt;https://www.rfc-editor.org/情報/RFC4621&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4953] Touch, J., &#34;Defending TCP Against Spoofing Attacks&#34;, RFC 4953, DOI 10.17487/RFC4953, July 2007, &lt;https://www.rfc-editor.org/info/rfc4953&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4953] Touch、J。、「スポーフ攻撃に対するTCPの防御」、RFC 4953、DOI 10.17487/RFC4953、2007年7月、&lt;https://www.rfc-editor.org/info/rfc4953&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4987] Eddy, W., &#34;TCP SYN Flooding Attacks and Common Mitigations&#34;, RFC 4987, DOI 10.17487/RFC4987, August 2007, &lt;https://www.rfc-editor.org/info/rfc4987&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4987] Eddy、W。、「TCP Syn Flooding Attacks and Common Mitigations」、RFC 4987、DOI 10.17487/RFC4987、2007年8月、&lt;https://www.rfc-editor.org/info/rfc4987&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5246] Dierks, T. and E. Rescorla, &#34;The Transport Layer Security (TLS) Protocol Version 1.2&#34;, RFC 5246, DOI 10.17487/RFC5246, August 2008, &lt;https://www.rfc-editor.org/info/rfc5246&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）Protocolバージョン1.2」、RFC 5246、DOI 10.17487/RFC5246、2008年8月、&lt;https://www.rfc-editor.org/info/RFC5246&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5685] Devarapalli, V. and K. Weniger, &#34;Redirect Mechanism for the Internet Key Exchange Protocol Version 2 (IKEv2)&#34;, RFC 5685, DOI 10.17487/RFC5685, November 2009, &lt;https://www.rfc-editor.org/info/rfc5685&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5685] Devarapalli、V。およびK. Weniger、「インターネットキー交換プロトコルバージョン2（IKEV2）のリダイレクトメカニズム」、RFC 5685、DOI 10.17487/RFC5685、2009年11月、&lt;https：//ww.rfc-editor。org/info/rfc5685&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5723] Sheffer, Y. and H. Tschofenig, &#34;Internet Key Exchange Protocol Version 2 (IKEv2) Session Resumption&#34;, RFC 5723, DOI 10.17487/RFC5723, January 2010, &lt;https://www.rfc-editor.org/info/rfc5723&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5723] Sheffer、Y。およびH. Tschofenig、「Internet Key Exchange Protocolバージョン2（IKEV2）セッション再開」、RFC 5723、DOI 10.17487/RFC5723、2010年1月、&lt;https：//www.rfc-editor.org/情報/RFC5723&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5961] Ramaiah, A., Stewart, R., and M. Dalal, &#34;Improving TCP&#39;s Robustness to Blind In-Window Attacks&#34;, RFC 5961, DOI 10.17487/RFC5961, August 2010, &lt;https://www.rfc-editor.org/info/rfc5961&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5961] Ramaiah、A.、Stewart、R。、およびM. Dalal、「Window Inwindow攻撃に対するTCPの堅牢性の向上」、RFC 5961、DOI 10.17487/RFC5961、2010年8月、&lt;https：//www.rfc-editor.org/info/rfc5961&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6311] Singh, R., Ed., Kalyani, G., Nir, Y., Sheffer, Y., and D. Zhang, &#34;Protocol Support for High Availability of IKEv2/ IPsec&#34;, RFC 6311, DOI 10.17487/RFC6311, July 2011, &lt;https://www.rfc-editor.org/info/rfc6311&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6311] Singh、R.、Ed。、Kalyani、G.、Nir、Y.、Sheffer、Y.、およびD. Zhang、「IKEV2/ IPSECの高可用性のプロトコルサポート」、RFC 6311、DOI 10.17487/ RFC631111、2011年7月、&lt;https://www.rfc-editor.org/info/rfc6311&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6520] Seggelmann, R., Tuexen, M., and M. Williams, &#34;Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) Heartbeat Extension&#34;, RFC 6520, DOI 10.17487/RFC6520, February 2012, &lt;https://www.rfc-editor.org/info/rfc6520&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6520] Seggelmann、R.、Tuexen、M。、およびM. Williams、「トランスポートレイヤーセキュリティ（TLS）およびデータグラムトランスポートレイヤーセキュリティ（DTLS）ハートビート拡張」、RFC 6520、DOI 10.17487/RFC6520、2012年2月、&lt;：//www.rfc-editor.org/info/rfc6520&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6528] Gont, F. and S. Bellovin, &#34;Defending against Sequence Number Attacks&#34;, RFC 6528, DOI 10.17487/RFC6528, February 2012, &lt;https://www.rfc-editor.org/info/rfc6528&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6528] Gont、F。およびS. Bellovin、「シーケンス番号攻撃に対する防御」、RFC 6528、DOI 10.17487/RFC6528、2012年2月、&lt;https://www.rfc-editor.org/info/rfc6528&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7383] Smyslov, V., &#34;Internet Key Exchange Protocol Version 2 (IKEv2) Message Fragmentation&#34;, RFC 7383, DOI 10.17487/RFC7383, November 2014, &lt;https://www.rfc-editor.org/info/rfc7383&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7383] Smyslov、V。、「インターネットキー交換プロトコルバージョン2（IKEV2）メッセージフラグメンテーション」、RFC 7383、DOI 10.17487/RFC7383、2014年11月、&lt;https://www.rfc-editor.org/info/rfc7383&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8229] Pauly, T., Touati, S., and R. Mantha, &#34;TCP Encapsulation of IKE and IPsec Packets&#34;, RFC 8229, DOI 10.17487/RFC8229, August 2017, &lt;https://www.rfc-editor.org/info/rfc8229&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8229] Pauly、T.、Touati、S。、およびR. Mantha、「IKEおよびIPSECパケットのTCPカプセル化」、RFC 8229、DOI 10.17487/RFC8229、2017年8月、&lt;https：//www.rfc-editor。org/info/rfc8229&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8446] Rescorla, E., &#34;The Transport Layer Security (TLS) Protocol Version 1.3&#34;, RFC 8446, DOI 10.17487/RFC8446, August 2018, &lt;https://www.rfc-editor.org/info/rfc8446&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8446] Rescorla、E。、「輸送層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487/RFC8446、2018年8月、&lt;https://www.rfc-editor.org/info/rfc846&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9293] Eddy, W., Ed., &#34;Transmission Control Protocol (TCP)&#34;, STD 7, RFC 9293, DOI 10.17487/RFC9293, August 2022, &lt;https://www.rfc-editor.org/info/rfc9293&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9293] Eddy、W.、ed。、「Transmission Control Protocol（TCP）」、Std 7、RFC 9293、DOI 10.17487/RFC9293、2022年8月、&lt;https://www.rfc-editor.org/info/RFC9293333333333333333333333&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9325] Sheffer, Y., Saint-Andre, P., and T. Fossati, &#34;Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)&#34;, RFC 9325, DOI 10.17487/RFC9325, November 2022, &lt;https://www.rfc-editor.org/info/rfc9325&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC9325] Sheffer、Y.、Saint-Andre、P。、およびT. Fossati、「輸送層セキュリティ（TLS）およびデータグラム輸送層のセキュリティ（DTLS）の安全な使用に関する推奨事項」、RFC 9325、DOI 10.17487/RFC9325、2022年11月、&lt;https://www.rfc-editor.org/info/rfc9325&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCP-MELTDOWN] Honda, O., Ohsaki, H., Imase, M., Ishizuka, M., and J. Murayama, &#34;Understanding TCP over TCP: effects of TCP tunneling on end-to-end throughput and latency&#34;, October 2005, &lt;https://doi.org/10.1117/12.630496&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCP-Meltdown] Honda、O.、Ohsaki、H.、Imase、M.、Ishizuka、M.、およびJ. Murayama、「TCPを超えるTCPの理解：エンドツーエンドのスループットとレイテンシに対するTCPトンネルの影響」、2005年10月、&lt;https://doi.org/10.1117/12.630496&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--Using-TCP-Encapsulation-with-TLS">
Appendix A. Using TCP Encapsulation with TLS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A. TLSでTCPカプセル化を使用します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides recommendations on how to use TLS in addition to TCP encapsulation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、TCPカプセル化に加えてTLSの使用方法に関する推奨事項を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When using TCP encapsulation, implementations may choose to use TLS 1.2 [RFC5246] or TLS 1.3 [RFC8446] on the TCP connection to be able to traverse middleboxes, which may otherwise block the traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPカプセル化を使用する場合、実装はTLS 1.2 [RFC5246]またはTLS 1.3 [RFC8446]を使用してTCP接続で使用して、それ以外の場合はトラフィックをブロックする可能性のあるミドルボックスを通過できるようにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a web proxy is applied to the ports used for the TCP connection and TLS is being used, the TCP Originator can send an HTTP CONNECT message to establish an SA through the proxy [RFC2817].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP接続に使用されているポートにWebプロキシが適用され、TLSが使用されている場合、TCPオリジネーターはHTTP接続メッセージを送信して、プロキシ[RFC2817]を介してSAを確立することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of TLS should be configurable on the peers and may be used as the default when using TCP encapsulation or may be used as a fallback when basic TCP encapsulation fails. The TCP Responder may expect to read encapsulated IKE and ESP packets directly from the TCP connection, or it may expect to read them from a stream of TLS data packets. The TCP Originator should be preconfigured regarding whether or not to use TLS when communicating with a given port on the TCP Responder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSの使用は、ピアで構成可能であり、TCPカプセル化を使用する場合はデフォルトとして使用するか、基本的なTCPカプセル化が失敗した場合にフォールバックとして使用できます。TCPレスポンダーは、TCP接続から直接カプセル化されたIKEおよびESPパケットを読み取ることを期待するか、TLSデータパケットのストリームからそれらを読み取ることを期待する場合があります。TCPオリジネーターは、TCPレスポンダーの特定のポートと通信するときにTLSを使用するかどうかについて事前に設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When new TCP connections are re-established due to a broken connection, TLS must be renegotiated. TLS session resumption is recommended to improve efficiency in this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続が壊れているために新しいTCP接続が再確立される場合、TLSは再交渉する必要があります。この場合の効率を改善するには、TLSセッション再開をお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security of the IKE session is entirely derived from the IKE negotiation and key establishment and not from the TLS session (which, in this context, is only used for encapsulation purposes); therefore, when TLS is used on the TCP connection, both the TCP Originator and the TCP Responder SHOULD allow the NULL cipher to be selected for performance reasons. Note that TLS 1.3 only supports AEAD algorithms and at the time of writing this document there was no recommended cipher suite for TLS 1.3 with the NULL cipher. It is RECOMMENDED to follow [RFC9325] when selecting parameters for TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKEセッションのセキュリティは、TLSセッションではなく、IKE交渉と主要な設立から完全に導き出されます（この文脈では、カプセル化の目的でのみ使用されます）。したがって、TCP接続でTLSを使用する場合、TCPオリジネーターとTCPレスポンダーの両方が、パフォーマンス上の理由でnull暗号を選択できるようにする必要があります。TLS 1.3はAEADアルゴリズムのみをサポートしており、このドキュメントを書く時点では、NULL暗号でTLS 1.3に推奨される暗号スイートはありませんでした。TLSのパラメーターを選択するときは、[RFC9325]に従うことをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations should be aware that the use of TLS introduces another layer of overhead requiring more bytes to transmit a given IKE and IPsec packet. For this reason, direct ESP, UDP encapsulation, or TCP encapsulation without TLS should be preferred in situations in which TLS is not required in order to traverse middleboxes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、TLSを使用すると、特定のIKEとIPSECパケットを送信するためにより多くのバイトが必要なオーバーヘッドの別の層が導入されることに注意する必要があります。このため、TLSのない直接ESP、UDPカプセル化、またはTCPのカプセル化は、ミドルボックスを通過するためにTLSが必要ない状況で好まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-B--Example-Exchanges-of-TCP-Encapsulation-with-TLS-1-3">
Appendix B. Example Exchanges of TCP Encapsulation with TLS 1.3
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録B. TLS 1.3とのTCPカプセル化の例の例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This appendix contains examples of data flows in cases where TCP encapsulation of IKE and IPsec packets is used with TLS 1.3. The examples below are provided for illustrative purpose only; readers should refer to the main body of the document for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この付録には、IKEおよびIPSECパケットのTCPカプセル化がTLS 1.3で使用される場合のデータフローの例が含まれています。以下の例は、例示的な目的のみを示しています。読者は、詳細については、ドキュメントの本体を参照する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-1--Establishing-an-IKE-Session">
B.1. Establishing an IKE Session
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.1. IKEセッションの確立
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   Client                              Server
                 ----------                          ----------
     1)  --------------------  TCP Connection  -------------------
         (IP_I:Port_I  -&gt; IP_R:Port_R)
         TcpSyn                   -------&gt;
                                  &lt;-------              TcpSyn,Ack
         TcpAck                   -------&gt;
     2)  ---------------------  TLS Session  ---------------------
         ClientHello              -------&gt;
                                                       ServerHello
                                             {EncryptedExtensions}
                                                    {Certificate*}
                                              {CertificateVerify*}
                                  &lt;-------              {Finished}
         {Finished}               -------&gt;
     3)  ---------------------- Stream Prefix --------------------
         &#34;IKETCP&#34;                 -------&gt;
     4)  ----------------------- IKE Session ---------------------
         Length + Non-ESP Marker  -------&gt;
         IKE_SA_INIT
         HDR, SAi1, KEi, Ni,
         [N(NAT_DETECTION_SOURCE_IP)],
         [N(NAT_DETECTION_DESTINATION_IP)]
                                  &lt;------- Length + Non-ESP Marker
                                                       IKE_SA_INIT
                                               HDR, SAr1, KEr, Nr,
                                     [N(NAT_DETECTION_SOURCE_IP)],
                                 [N(NAT_DETECTION_DESTINATION_IP)]
         Length + Non-ESP Marker  -------&gt;
         first IKE_AUTH
         HDR, SK {IDi, [CERTREQ]
         CP(CFG_REQUEST), IDr,
         SAi2, TSi, TSr, ...}
                                  &lt;------- Length + Non-ESP Marker
                                                    first IKE_AUTH
                                       HDR, SK {IDr, [CERT], AUTH,
                                              EAP, SAr2, TSi, TSr}
         Length + Non-ESP Marker  -------&gt;
         IKE_AUTH (repeat 1..N times)
         HDR, SK {EAP}
                                  &lt;------- Length + Non-ESP Marker
                                      IKE_AUTH (repeat 1..N times)
                                                      HDR SK {EAP}
         Length + Non-ESP Marker  -------&gt;
         final IKE_AUTH
         HDR, SK {AUTH}
                                  &lt;------- Length + Non-ESP Marker
                                                    final IKE_AUTH
                                     HDR, SK {AUTH, CP(CFG_REPLY),
                                                SA, TSi, TSr, ...}
         -------------- IKE and IPsec SAs Established ------------
         Length + ESP Frame       -------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The client establishes a TCP connection with the server on port 4500 or on an alternate preconfigured port that the server is listening on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. クライアントは、ポート4500またはサーバーがリッスンしている別の事前に構成されたポートでサーバーとのTCP接続を確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If configured to use TLS, the client initiates a TLS handshake. During the TLS handshake, the server SHOULD NOT request the client&#39;s certificate since authentication is handled as part of IKE negotiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. TLSを使用するように構成されている場合、クライアントはTLSの握手を開始します。TLSの握手中、認証はIKE交渉の一部として処理されるため、サーバーはクライアントの証明書を要求してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The client sends the stream prefix for TCP-encapsulated IKE (Section 4) traffic to signal the beginning of IKE negotiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. クライアントは、TCPにカプセル化されたIKE（セクション4）のストリームプレフィックスを送信して、IKE交渉の開始を通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The client and server establish an IKE connection. This example shows EAP-based authentication, although any authentication type may be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. クライアントとサーバーがIKE接続を確立します。この例は、EAPベースの認証を示していますが、任意の認証タイプを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-2--Deleting-an-IKE-Session">
B.2. Deleting an IKE Session
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.2. IKEセッションの削除
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   Client                              Server
                 ----------                          ----------
     1)  ----------------------- IKE Session ---------------------
         Length + Non-ESP Marker  -------&gt;
         INFORMATIONAL
         HDR, SK {[N,] [D,]
                [CP,] ...}
                                  &lt;------- Length + Non-ESP Marker
                                                     INFORMATIONAL
                                                HDR, SK {[N,] [D,]
                                                        [CP], ...}
     2)  ---------------------  TLS Session  ---------------------
         close_notify             -------&gt;
                                  &lt;-------            close_notify
     3)  --------------------  TCP Connection  -------------------
         TcpFin                   -------&gt;
                                  &lt;-------                     Ack
                                  &lt;-------                  TcpFin
         Ack                      -------&gt;
         --------------------  IKE SA Deleted  -------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The client and server exchange informational messages to notify IKE SA deletion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. クライアントとサーバーは、IKE SAの削除を通知するための情報メッセージを交換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The client and server negotiate TLS session deletion using TLS CLOSE_NOTIFY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. クライアントとサーバーは、TLS close_notifyを使用してTLSセッションの削除をネゴシエートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The TCP connection is torn down.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. TCP接続が取り壊されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The deletion of the IKE SA should lead to the disposal of the underlying TLS and TCP state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IKE SAの削除は、基礎となるTLSおよびTCP状態の処分につながるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-3--Re-establishing-an-IKE-Session">
B.3. Re-establishing an IKE Session
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.3. IKEセッションの再確立
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   Client                              Server
                 ----------                          ----------
     1)  --------------------  TCP Connection  -------------------
         (IP_I:Port_I  -&gt; IP_R:Port_R)
         TcpSyn                   -------&gt;
                                  &lt;-------              TcpSyn,Ack
         TcpAck                   -------&gt;
     2)  ---------------------  TLS Session  ---------------------
         ClientHello              -------&gt;
                                                       ServerHello
                                             {EncryptedExtensions}
                                  &lt;-------              {Finished}
         {Finished}               -------&gt;
     3)  ---------------------- Stream Prefix --------------------
         &#34;IKETCP&#34;                 -------&gt;
     4)  &lt;---------------------&gt; IKE/ESP Flow &lt;------------------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If a previous TCP connection was broken (for example, due to a TCP Reset), the client is responsible for re-initiating the TCP connection. The TCP Originator&#39;s address and port (IP_I and Port_I) may be different from the previous connection&#39;s address and port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 以前のTCP接続が壊れていた場合（たとえば、TCPリセットのため）、クライアントはTCP接続の再刺激を担当します。TCP Originatorのアドレスとポート（IP_IおよびPORT_I）は、前の接続のアドレスとポートとは異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The client SHOULD attempt TLS session resumption if it has previously established a session with the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. クライアントは、以前にサーバーとのセッションを確立した場合、TLSセッション再開を試みる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. After TCP and TLS are complete, the client sends the stream prefix for TCP-encapsulated IKE traffic (Section 4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. TCPとTLSが完了した後、クライアントはTCPにカプセル化されたIKEトラフィックのストリームプレフィックスを送信します（セクション4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The IKE and ESP packet flow can resume. If MOBIKE is being used, the Initiator SHOULD send an UPDATE_SA_ADDRESSES message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. IKEおよびESPパケットフローは再開できます。Mobikeが使用されている場合、イニシエーターはupdate_sa_addressesメッセージを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="B-4--Using-MOBIKE-between-UDP-and-TCP-Encapsulation">
B.4. Using MOBIKE between UDP and TCP Encapsulation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.4. UDPとTCPカプセル化の間のMobikeを使用します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                     Client                              Server
                   ----------                          ----------
     1)  --------------------- IKE_session ----------------------
         (IP_I1:UDP500 -&gt; IP_R:UDP500)
         IKE_SA_INIT              -------&gt;
         HDR, SAi1, KEi, Ni,
         [N(NAT_DETECTION_SOURCE_IP)],
         [N(NAT_DETECTION_DESTINATION_IP)]
                                  &lt;-------            IKE_SA_INIT
                                               HDR, SAr1, KEr, Nr,
                                     [N(NAT_DETECTION_SOURCE_IP)],
                                 [N(NAT_DETECTION_DESTINATION_IP)]
         (IP_I1:UDP4500 -&gt; IP_R:UDP4500)
         Non-ESP Marker           -------&gt;
         IKE_AUTH
         HDR, SK { IDi, CERT, AUTH,
         SAi2, TSi, TSr,
         N(MOBIKE_SUPPORTED) }
                                  &lt;-------          Non-ESP Marker
                                                          IKE_AUTH
                                        HDR, SK { IDr, CERT, AUTH,
                                                   SAr2, TSi, TSr,
                                             N(MOBIKE_SUPPORTED) }
         &lt;---------------------&gt; IKE/ESP Flow &lt;------------------&gt;
     2)  ------------ MOBIKE Attempt on New Network --------------
         (IP_I2:UDP4500 -&gt; IP_R:UDP4500)
         Non-ESP Marker           -------&gt;
         INFORMATIONAL
         HDR, SK { N(UPDATE_SA_ADDRESSES),
         N(NAT_DETECTION_SOURCE_IP),
         N(NAT_DETECTION_DESTINATION_IP) }
     3)  --------------------  TCP Connection  -------------------
         (IP_I2:Port_I -&gt; IP_R:Port_R)
         TcpSyn                   -------&gt;
                                  &lt;-------              TcpSyn,Ack
         TcpAck                   -------&gt;
     4)  ---------------------  TLS Session  ---------------------
         ClientHello              -------&gt;
                                                       ServerHello
                                             {EncryptedExtensions}
                                                    {Certificate*}
                                              {CertificateVerify*}
                                  &lt;-------              {Finished}
         {Finished}               -------&gt;
     5)  ---------------------- Stream Prefix --------------------
         &#34;IKETCP&#34;                 -------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     6)  ------------ Retransmit Message from step 2 -------------
         Length + Non-ESP Marker  -------&gt;
         INFORMATIONAL
         HDR, SK { N(UPDATE_SA_ADDRESSES),
         N(NAT_DETECTION_SOURCE_IP),
         N(NAT_DETECTION_DESTINATION_IP) }
                                  &lt;------- Length + Non-ESP Marker
                                                     INFORMATIONAL
                             HDR, SK { N(NAT_DETECTION_SOURCE_IP),
                                 N(NAT_DETECTION_DESTINATION_IP) }
     7)  -- New Exchange with recalculated  NAT_DETECTION_*_IP ---
         Length + Non-ESP Marker  -------&gt;
         INFORMATIONAL
         HDR, SK { N(UPDATE_SA_ADDRESSES),
         N(NAT_DETECTION_SOURCE_IP),
         N(NAT_DETECTION_DESTINATION_IP) }
                                  &lt;------- Length + Non-ESP Marker
                                                     INFORMATIONAL
                             HDR, SK { N(NAT_DETECTION_SOURCE_IP),
                                 N(NAT_DETECTION_DESTINATION_IP) }
     8)  &lt;---------------------&gt; IKE/ESP Flow &lt;------------------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. During the IKE_AUTH exchange, the client and server exchange MOBIKE_SUPPORTED notify payloads to indicate support for MOBIKE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. IKE_AUTH Exchangeの間、クライアントとサーバーの交換Mobike_Supportedは、Payloadsに通知してMobikeのサポートを示しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The client changes its point of attachment to the network and receives a new IP address. The client attempts to re-establish the IKE session using the UPDATE_SA_ADDRESSES notify payload, but the server does not respond because the network blocks UDP traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. クライアントは、ネットワークへの添付ポイントを変更し、新しいIPアドレスを受け取ります。クライアントは、update_sa_addressesがペイロードを通知することを使用してIKEセッションを再確立しようとしますが、ネットワークがUDPトラフィックをブロックするため、サーバーは応答しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The client brings up a TCP connection to the server in order to use TCP encapsulation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. クライアントは、TCPカプセル化を使用するために、サーバーへのTCP接続を持ち出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The client initiates a TLS handshake with the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. クライアントは、サーバーでTLSの握手を開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. The client sends the stream prefix for TCP-encapsulated IKE traffic (Section 4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. クライアントは、TCPがカプセル化されたIKEトラフィックのストリームプレフィックスを送信します（セクション4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. The client sends the UPDATE_SA_ADDRESSES notify payload in the INFORMATIONAL exchange on the TCP-encapsulated connection. Note that this IKE message is the same as the one sent over UDP in step 2; it should have the same message ID and contents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. クライアントは、update_sa_addressesを送信し、TCPにカプセル化された接続の情報交換でペイロードに通知します。このIKEメッセージは、ステップ2でUDPを介して送信されたメッセージと同じであることに注意してください。同じメッセージIDとコンテンツが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Once the client receives a response on the TCP-encapsulated connection, it immediately starts a new INFORMATIONAL exchange with an UPDATE_SA_ADDRESSES notify payload and recalculated NAT_DETECTION_*_IP notify payloads in order to get correct information about the presence of NATs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. クライアントがTCPにカプセル化された接続の応答を受信すると、NATの存在に関する正しい情報を取得するために、update_sa_addressesとの新しい情報交換を直ちに開始します_*_ IP通知ペイロード_*_ IPがペイロードを通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. The IKE and ESP packet flow can resume.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. IKEおよびESPパケットフローは再開できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to the authors of RFC 8229 (Tommy Pauly, Samy Touati, and Ravi Mantha). Since this document clarifies and obsoletes RFC 8229, most of its text was borrowed from the original document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 8229（Tommy Pauly、Samy Touati、Ravi Mantha）の著者に感謝します。このドキュメントはRFC 8229を明確にし、廃止しているため、そのテキストのほとんどは元の文書から借用されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following people provided valuable feedback and advice while preparing RFC 8229: Stuart Cheshire, Delziel Fernandes, Yoav Nir, Christoph Paasch, Yaron Sheffer, David Schinazi, Graham Bartlett, Byju Pularikkal, March Wu, Kingwel Xie, Valery Smyslov, Jun Hu, and Tero Kivinen. Special thanks to Eric Kinnear for his implementation work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の人々は、RFC 8229の準備中に貴重なフィードバックとアドバイスを提供しました：スチュアートチェシャー、デルツィエルフェルナンデス、ヨーブニール、クリストフパシュ、ヤロンシェファー、デビッドシナジ、グラハムバートレット、byju pularikkal、3月ウー、キングウェルシー、ヴァルリースミスロフ、ジュンフー、テロキビネン。彼の実装作業をしてくれたEric Kinnearに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors would like to thank Tero Kivinen, Paul Wouters, Joseph Touch, and Christian Huitema for their valuable comments while preparing this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者は、この文書を準備しながら貴重なコメントをしてくれたTero Kivinen、Paul Wouters、Joseph Touch、Christian Huitemaに感謝したいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tommy Pauly Apple Inc. 1 Infinite Loop Cupertino, California 95014 United States of America Email: tpauly@apple.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tommy Pauly Apple Inc. 1 Infinite Loop Cupertino、カリフォルニア95014アメリカ合衆国電子メール：tpauly@apple.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Valery Smyslov ELVIS-PLUS PO Box 81 Moscow (Zelenograd) 124460 Russian Federation Phone: +7 495 276 0211 Email: svan@elvis.ru
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Valery Smyslov Elvis-Plus PO Box 81 Moscow（Zelenograd）124460ロシア連邦電話：7 495 276 0211メール：svan@elvis.ru
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
